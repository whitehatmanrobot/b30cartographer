n;
#endif
}

//------------------------------------------------------------------------

GENERIC_MAPPING CJobSecurityDescriptor::s_AccessMapping =
{
    STANDARD_RIGHTS_READ,
    STANDARD_RIGHTS_WRITE,
    STANDARD_RIGHTS_EXECUTE,
    STANDARD_RIGHTS_ALL
};

CJobSecurityDescriptor::CJobSecurityDescriptor(
    SidHandle OwnerSid
    )
{
    PACL pACL = NULL;
    PSECURITY_DESCRIPTOR pSD = 0;

    try
        {
        EXPLICIT_ACCESS ea[2];
        size_t  SizeNeeded;

        pSD = (PSECURITY_DESCRIPTOR) new char[SECURITY_DESCRIPTOR_MIN_LENGTH];

        if (!InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION))
            {
            HRESULT HrError = HRESULT_FROM_WIN32( GetLastError() );
            LogError( "InitializeSecurityDescriptor Error %!winerr!", HrError );
            throw ComError( HrError );
            }

        if (!SetSecurityDescriptorOwner( pSD, OwnerSid.get(), TRUE))
            {
            HRESULT HrError = HRESULT_FROM_WIN32( GetLastError() );
            LogError( "SetSecurityDescriptorOwner Error %!winerr!", HrError );
            throw ComError( HrError );
            }

        if (!SetSecurityDescriptorGroup( pSD, OwnerSid.get(), TRUE))
            {
            HRESULT HrError = HRESULT_FROM_WIN32( GetLastError() );
            LogError( "SetSecurityDescriptorGroup Error %!winerr!", HrError );
            throw ComError( HrError );
            }

        // Initialize an EXPLICIT_ACCESS structure for an ACE.
        // The ACE will allow the Administrators group full access to the key.
        memset(ea, 0, sizeof(ea));

        ea[0].grfAccessPermissions = KEY_ALL_ACCESS;
        ea[0].grfAccessMode = SET_ACCESS;
        ea[0].grfInheritance= NO_INHERITANCE;
        ea[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
        ea[0].Trustee.TrusteeType = TRUSTEE_IS_USER;
        ea[0].Trustee.ptstrName  = (LPTSTR) OwnerSid.get();

        // Initialize an EXPLICIT_ACCESS structure for an ACE.
        // The ACE will allow the Administrators group full access to the key.

        ea[1].grfAccessPermissions = KEY_ALL_ACCESS;
        ea[1].grfAccessMode = SET_ACCESS;
        ea[1].grfInheritance= NO_INHERITANCE;
        ea[1].Trustee.TrusteeForm = TRUSTEE_IS_SID;
        ea[1].Trustee.TrusteeType = TRUSTEE_IS_GROUP;
        ea[1].Trustee.ptstrName  = (LPTSTR) g_GlobalInfo->m_AdministratorsSid.get();

        // Create a new ACL that contains the new ACEs.

        DWORD s = SetEntriesInAcl(2, ea, NULL, &pACL);
        if (s != ERROR_SUCCESS)
            {
            HRESULT HrError = HRESULT_FROM_WIN32( s );
            LogError( "create SD : SetEntriesInAcl failed %!winerr!", HrError );
            throw ComError( HrError );
            }

        // Add the ACL to the security descriptor.

        if (!SetSecurityDescriptorDacl( pSD,
                                        TRUE,     // fDaclPresent flag
                                        pACL,
                                        TRUE))   // a default DACL
            {
            HRESULT HrError = HRESULT_FROM_WIN32( GetLastError() );
            LogError( "SetSecurityDescriptorDacl Error %!winerr!", HrError );
            throw ComError( HrError );
            }

        //
        // Add the pointers our object.
        //
        m_sd         = pSD;
        m_sdOwnerSid = OwnerSid;
        m_sdGroupSid = OwnerSid;
        m_Dacl       = pACL;
        }
    catch( ComError exception )
        {
        if (pACL)
            LocalFree(pACL);

        if (pSD)
            delete[] ((char*)pSD);

        throw;
        }
}

CJobSecurityDescriptor::CJobSecurityDescriptor(
    PSECURITY_DESCRIPTOR sd,
    SidHandle   sdOwnerSid,
    SidHandle   sdGroupSid,
    PACL        sdDacl
    )
{
    m_sd         = sd;
    m_sdOwnerSid = sdOwnerSid;
    m_sdGroupSid = sdGroupSid;
    m_Dacl       = sdDacl;
}


CJobSecurityDescriptor::~CJobSecurityDescriptor()
{
    if (m_Dacl)
        LocalFree(m_Dacl);

    delete m_sd;
}


HRESULT
CJobSecurityDescriptor::_ModifyAcl(
    PSID sid,
    BOOL fGroupSid,
    DWORD access,
    BOOL  fAdd
    )
{
    HRESULT hr;
    DWORD dwRes;
    PACL pNewAcl = NULL;
    EXPLICIT_ACCESS ea;

    // Initialize an EXPLICIT_ACCESS structure for the new ACE.

    ZeroMemory(&ea, sizeof(EXPLICIT_ACCESS));
    ea.grfAccessPermissions = access;
    ea.grfAccessMode        = (fAdd) ? SET_ACCESS : REVOKE_ACCESS;
    ea.grfInheritance       = NO_INHERITANCE;
    ea.Trustee.TrusteeForm  = TRUSTEE_IS_SID;
    ea.Trustee.TrusteeType  = (fGroupSid) ? TRUSTEE_IS_GROUP : TRUSTEE_IS_USER;
    ea.Trustee.ptstrName    = LPTSTR(sid);

    // Create a new ACL that merges the new ACE
    // into the existing DACL.

    dwRes = SetEntriesInAcl( 1, &ea, m_Dacl, &pNewAcl );
    if (ERROR_SUCCESS != dwRes)
        {
        hr = HRESULT_FROM_WIN32( dwRes );
        goto Cleanup;
        }

    // Attach the new ACL as the object's DACL.

    if (!SetSecurityDescriptorDacl( m_sd,
                                    TRUE,     // fDaclPresent flag
                                    pNewAcl,
                                    FALSE ))   // a default DACL
        {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        LogError( "SetSecurityDescriptorDacl Error %!winerr!", hr );
        goto Cleanup;
        }

    LocalFree( m_Dacl );

    m_Dacl = pNewAcl;

    pNewAcl = NULL;

    hr = S_OK;

Cleanup:

    if(pNewAcl)
        LocalFree((HLOCAL) pNewAcl);

    return hr;
}

HRESULT
CJobSecurityDescriptor::CheckTokenAccess(
    HANDLE hToken,
    DWORD RequestedAccess,
    DWORD * pAllowedAccess,
    BOOL * pSuccess
    )
{

    PRIVILEGE_SET * PrivilegeSet = 0;
    DWORD PrivilegeSetSize;
    //
    // Get space for the privilege set.  I don't expect to use any...
    //
    PrivilegeSetSize = sizeof(PRIVILEGE_SET) + sizeof(LUID_AND_ATTRIBUTES);
    auto_ptr<char> Buffer;

    try
        {
        Buffer = auto_ptr<char>( new char[ PrivilegeSetSize ] );
        }
    catch( ComError Error )
        {
        return Error.Error();
        }

    PrivilegeSet = (PRIVILEGE_SET *) Buffer.get();

    //
    // See whether the security descriptor allows access.
    //
    if (!AccessCheck( m_sd,
                      hToken,
                      RequestedAccess,
                      &s_AccessMapping,
                      PrivilegeSet,
                      &PrivilegeSetSize,
                      pAllowedAccess,
                      pSuccess
                      ))
    {
        HRESULT HrError = HRESULT_FROM_WIN32( GetLastError() );
        LogError( "AccessCheck failed, error %!winerr!", HrError );
        return HrError;
    }

    return S_OK;

}

HRESULT
CJobSecurityDescriptor::Serialize(
    HANDLE hFile
    )
{
    try
        {
        ULONG   SdSize;
        auto_ptr<char> pSD;    // auto_ptr<void> apparently doesn't work

        //
        // Convert the security descriptor into self-relative format for storage.
        //
        SdSize = 0;
        MakeSelfRelativeSD( m_sd, NULL, &SdSize );
        if (SdSize == 0)
            {
            throw ComError( HRESULT_FROM_WIN32(GetLastError()) );
            }

        pSD = auto_ptr<char>( new char[ SdSize ] );

        if (!MakeSelfRelativeSD( m_sd, pSD.get(), &SdSize ))
            {
            throw ComError( HRESULT_FROM_WIN32(GetLastError()) );
            }

        SafeWriteFile( hFile, SdSize );
        SafeWriteFile( hFile, pSD.get(), SdSize );
        }
    catch( ComError err )
        {
        LogError("SD serialize failed with %!winerr!", err.Error() );

        throw;
        }

    return S_OK;
}


CJobSecurityDescriptor *
CJobSecurityDescriptor::Unserialize(
    HANDLE hFile
    )
{
    //
    // Allocations here must match the deletes in the destructor.
    //
    char * SdBuf = 0;
    char * DaclBuf = 0;
    CJobSecurityDescriptor * pObject = NULL;

    try
        {
        DWORD SdSize = 0;
        DWORD DaclSize = 0;
        DWORD SaclSize = 0;
        DWORD OwnerSize = 0;
        DWORD GroupSize = 0;

        PSECURITY_DESCRIPTOR sd;
        auto_ptr<char> pSD;    // auto_ptr<void> apparently doesn't work

        PACL    sdDacl;
        PACL    sdSacl;


        SafeReadFile( hFile, &SdSize );

        pSD = auto_ptr<char>( new char[ SdSize ] );

        SafeReadFile( hFile, pSD.get(), SdSize );

        MakeAbsoluteSD( pSD.get(),
                        NULL, &SdSize,
                        NULL, &DaclSize,
                        NULL, &SaclSize,
                        NULL, &OwnerSize,
                        NULL, &GroupSize
                        );

        if (!SdSize || !DaclSize || !OwnerSize || !GroupSize)
            {
            throw ComError( HRESULT_FROM_WIN32(GetLastError()));
            }

        SdBuf      = new char[ SdSize + SaclSize ];
        SidHandle OwnerSid = new char[ OwnerSize ];
        SidHandle GroupSid = new char[ GroupSize ];

        DaclBuf = (char *) LocalAlloc( LMEM_FIXED, DaclSize );

        sdDacl     = (PACL) DaclBuf;
        sd         = (PSECURITY_DESCRIPTOR) SdBuf;
        sdSacl     = (PACL) (SdBuf+SdSize);

        if (!MakeAbsoluteSD( pSD.get(),
                             sd, &SdSize,
                             sdDacl, &DaclSize,
                             sdSacl, &SaclSize,
                             OwnerSid.get(), &OwnerSize,
                             GroupSid.get(), &GroupSize
                             ))
            {
            throw ComError( HRESULT_FROM_WIN32(GetLastError()));
            }

        pObject = new CJobSecurityDescriptor( sd,
                                              OwnerSid,
                                              GroupSid,
                                              sdDacl
                                              );
        }
    catch (ComError exception)
        {
        delete[] SdBuf;

        LocalFree( DaclBuf );
        delete pObject;

        throw;
        }

    return pObject;
}

//------------------------------------------------------------------------

PSID
CopyTokenSid(
    HANDLE Token
    )
{
    TOKEN_USER * TokenData;
    DWORD SizeNeeded;

    // Get the size first.
    if (!GetTokenInformation(
             Token,
             TokenUser,
             0,
             0,
             &SizeNeeded
             ))
        {
        DWORD dwLastError = GetLastError();

        if (ERROR_INSUFFICIENT_BUFFER != dwLastError)
            {
            THROW_HRESULT( HRESULT_FROM_WIN32( GetLastError()));
            }
        }

    auto_ptr<char> Buffer( new char[ SizeNeeded ] );
    TokenData = (TOKEN_USER *) Buffer.get();

    if (!GetTokenInformation(
             Token,
             TokenUser,
             TokenData,
             SizeNeeded,
             &SizeNeeded
             ))
        {
        THROW_HRESULT( HRESULT_FROM_WIN32( GetLastError()));
        }

    PSID sid = DuplicateSid( TokenData->User.Sid );
    if (sid == NULL)
        {
        THROW_HRESULT( E_OUTOFMEMORY);
        }

    return sid;
}


HANDLE
CopyThreadToken()
/*

    Makes a copy of the current thread's impersonation token.
    Returns NULL if not impersonating.
    Throws an exception if an error occurs.

*/
{
    HANDLE token = NULL;

    if (OpenThreadToken( GetCurrentThread(),
                     MAXIMUM_ALLOWED,
                     TRUE,
                     &token))
        {
        return token;
        }
    else if (GetLastError() == ERROR_NO_TOKEN)
        {
        return NULL;
        }
    else
        {
        throw ComError( HRESULT_FROM_WIN32( GetLastError() ));
        }
}

SidHandle
GetThreadClientSid()
/*

    Returns the SID of the current thread's COM client.
    Throws an exception if an error occurs.

*/
{
    CNestedImpersonation imp;

    return imp.CopySid();
}



HRESULT
IsRemoteUser()
{
    return CheckClientGroupMembership( g_GlobalInfo->m_NetworkUsersSid );
}


HRESULT
CheckClientGroupMembership(
    SidHandle group
    )
{
    try
        {
        BOOL fIsMember;

        CNestedImpersonation imp;

        if (!CheckTokenMembership( imp.QueryToken(),
                                   group.get(),
                                   &fIsMember))
            {
            return HRESULT_FROM_WIN32( GetLastError() );
            }

        if (fIsMember)
            {
            return S_OK;
            }

        return S_FALSE;
        }
    catch( ComError Error )
        {
        return Error.Error();
        }
}

HRESULT
DenyRemoteAccess()
{
    HRESULT hr = CheckClientGroupMembership( g_GlobalInfo->m_NetworkUsersSid );

    if (FAILED(hr))
        {
        return hr;
        }

    if (hr == S_OK)
        {
        return BG_E_REMOTE_NOT_SUPPORTED;
        }

    return S_OK;
}

HRESULT
DenyNonAdminAccess()
{
    HRESULT hr = CheckClientGroupMembership( g_GlobalInfo->m_AdministratorsSid );

    if (FAILED(hr))
        {
        return hr;
        }

    if (hr == S_FALSE)
        {
        return E_ACCESSDENIED;
        }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\newjob\csens.cpp ===
/************************************************************************

Copyright (c) 2001 - Microsoft Corporation

Module Name :

    csens.cpp

Abstract :

    Code for recieving logon notifications from SENS.

Author :

Revision History :

 ***********************************************************************/

#include "stdafx.h"
#include <wtsapi32.h>

#if !defined(BITS_V12_ON_NT4)
#include "csens.tmh"
#endif

HRESULT GetConsoleUserPresent( bool * pfPresent );

HRESULT GetConsoleUsername( LPWSTR * User );

//------------------------------------------------------------------------

CLogonNotification::CLogonNotification() :
m_EventSystem( NULL ),
m_TypeLib( NULL ),
m_TypeInfo( NULL )
{
   try
   {
       m_EventSubscriptions[0] = NULL;
       m_EventSubscriptions[1] = NULL;

#if defined( BITS_V12_ON_NT4 )

        {

        // try to load the SENS typelibrary
        // {D597DEED-5B9F-11D1-8DD2-00AA004ABD5E}

        HRESULT Hr;
        static const GUID SensTypeLibGUID =
            { 0xD597DEED, 0x5B9F, 0x11D1, { 0x8D, 0xD2, 0x00, 0xAA, 0x00, 0x4A, 0xBD, 0x5E } };


        Hr = LoadRegTypeLib( SensTypeLibGUID, 2, 0, GetSystemDefaultLCID(), &m_TypeLib);

        if ( TYPE_E_CANTLOADLIBRARY == Hr || TYPE_E_LIBNOTREGISTERED == Hr )
            {

            Hr = LoadRegTypeLib( SensTypeLibGUID, 1, 0, GetSystemDefaultLCID(), &m_TypeLib );

            if ( TYPE_E_CANTLOADLIBRARY == Hr || TYPE_E_LIBNOTREGISTERED == Hr )
                Hr = LoadTypeLibEx( L"SENS.DLL", REGKIND_NONE, &m_TypeLib );

            }

        THROW_HRESULT( Hr );

        }

#else

        THROW_HRESULT( LoadTypeLibEx( L"SENS.DLL", REGKIND_NONE, &m_TypeLib ) );

#endif

        THROW_HRESULT( m_TypeLib->GetTypeInfoOfGuid( __uuidof( ISensLogon ), &m_TypeInfo ) );

        THROW_HRESULT( CoCreateInstance( CLSID_CEventSystem,
                                         NULL,
                                         CLSCTX_SERVER,
                                         IID_IEventSystem,
                                         (void**)&m_EventSystem
                                         ) );


        // Register for the individual methods
        const WCHAR *MethodNames[] =
            {
            L"Logon",
            L"Logoff"
            };

        const WCHAR *UniqueIdentifies[] =
            {
            L"{c69c8f03-b25c-45d1-96fa-6dfb1f292b26}",
            L"{5f4f5e8d-4599-4ba0-b53d-1de5440b8770}"
            };

        for( SIZE_T i = 0; i < ( sizeof(MethodNames) / sizeof(*MethodNames) ); i++ )
            {

            WCHAR EventGuidString[ 50 ];

            THROW_HRESULT( CoCreateInstance( CLSID_CEventSubscription,
                                             NULL,
                                             CLSCTX_SERVER,
                                             IID_IEventSubscription,
                                             (LPVOID *) &m_EventSubscriptions[i]
                                             ) );


            StringFromGUID2( SENSGUID_EVENTCLASS_LOGON, EventGuidString, 50 );

            THROW_HRESULT( m_EventSubscriptions[i]->put_EventClassID( EventGuidString ) );
            THROW_HRESULT( m_EventSubscriptions[i]->put_SubscriberInterface( this ) );
            THROW_HRESULT( m_EventSubscriptions[i]->put_SubscriptionName( (BSTR) L"Microsoft-BITS" ) );
            THROW_HRESULT( m_EventSubscriptions[i]->put_Description( (BSTR) L"BITS Notification" ) );
            THROW_HRESULT( m_EventSubscriptions[i]->put_Enabled( FALSE ) );

            THROW_HRESULT( m_EventSubscriptions[i]->put_MethodName( (BSTR)MethodNames[i] ) );
            THROW_HRESULT( m_EventSubscriptions[i]->put_SubscriptionID( (BSTR)UniqueIdentifies[i] ) );

            THROW_HRESULT( m_EventSystem->Store(PROGID_EventSubscription, m_EventSubscriptions[i] ) );
            }
   }
   catch( ComError Error )
   {
       Cleanup();

       throw;
   }
}

void
CLogonNotification::DeRegisterNotification()
{
    SafeRelease( m_EventSubscriptions[0] );
    SafeRelease( m_EventSubscriptions[1] );

    if ( m_EventSystem )
        {
        int ErrorIndex;

        m_EventSystem->Remove( PROGID_EventSubscription,
                               L"EventClassID == {D5978630-5B9F-11D1-8DD2-00AA004ABD5E} AND SubscriptionName == Microsoft-BITS",
                               &ErrorIndex );

        SafeRelease( m_EventSystem );
        }
}

void
CLogonNotification::Cleanup()
{
    DeRegisterNotification();

    SafeRelease( m_TypeInfo );
    SafeRelease( m_TypeLib );

    LogInfo("cleanup complete");
}

HRESULT CLogonNotification::SetEnableState( bool fEnable )
{
    try
        {
        for (int i=0; i <= 1; ++i)
            {
            THROW_HRESULT( m_EventSubscriptions[i]->put_Enabled( fEnable ) );
            }

        for (int i=0; i <= 1; ++i)
            {
            THROW_HRESULT( m_EventSystem->Store(PROGID_EventSubscription, m_EventSubscriptions[i] ) );
            }

        LogInfo("SENS enable state is %d", fEnable);
        return S_OK;
        }
    catch ( ComError err )
        {
        LogInfo("SENS set enable state (%d) returned %x", fEnable, err.Error());
        return err.Error();
        }
}

STDMETHODIMP
CLogonNotification::GetIDsOfNames(
    REFIID,
    OLECHAR FAR* FAR* rgszNames,
    unsigned int cNames,
    LCID,
    DISPID FAR* rgDispId )
{

    return m_TypeInfo->GetIDsOfNames(
        rgszNames,
        cNames,
        rgDispId );

}


STDMETHODIMP
CLogonNotification::GetTypeInfo(
    unsigned int iTInfo,
    LCID,
    ITypeInfo FAR* FAR* ppTInfo )
{

    if ( iTInfo != 0 )
        return DISP_E_BADINDEX;

    *ppTInfo = m_TypeInfo;
    m_TypeInfo->AddRef();

    return S_OK;
}

STDMETHODIMP
CLogonNotification::GetTypeInfoCount(
    unsigned int FAR* pctinfo )
{
    *pctinfo = 1;
    return S_OK;

}

STDMETHODIMP
CLogonNotification::Invoke(
    DISPID dispID,
    REFIID riid,
    LCID,
    WORD wFlags,
    DISPPARAMS FAR* pDispParams,
    VARIANT FAR* pvarResult,
    EXCEPINFO FAR* pExcepInfo,
    unsigned int FAR* puArgErr )
{

    if (riid != IID_NULL)
        {
        return DISP_E_UNKNOWNINTERFACE;
        }

    return m_TypeInfo->Invoke(
        (IDispatch*) this,
        dispID,
        wFlags,
        pDispParams,
        pvarResult,
        pExcepInfo,
        puArgErr
        );

}


STDMETHODIMP
CLogonNotification::DisplayLock(
    BSTR UserName )
{
    return S_OK;
}

STDMETHODIMP
CLogonNotification::DisplayUnlock(
    BSTR UserName )
{
    return S_OK;
}

STDMETHODIMP
CLogonNotification::StartScreenSaver(
    BSTR UserName )
{
    return S_OK;
}

STDMETHODIMP
CLogonNotification::StopScreenSaver(
    BSTR UserName )
{
    return S_OK;
}

STDMETHODIMP
CLogonNotification::Logon(
    BSTR UserName )
{
    LogInfo( "SENS logon notification for %S", (WCHAR*)UserName );

    HRESULT Hr = SessionLogonCallback( 0 );

    LogInfo( "SENS logon notification for %S processed, %!winerr!", (WCHAR*)UserName, Hr );

    return Hr;
}

STDMETHODIMP
CLogonNotification::Logoff(
    BSTR UserName )
{
    LogInfo( "SENS logoff notification for %S", (WCHAR*)UserName );

    HRESULT Hr = SessionLogoffCallback( 0 );

    LogInfo( "SENS logoff notification for %S processed, %!winerr!", (WCHAR*)UserName, Hr );

    return Hr;
}

STDMETHODIMP
CLogonNotification::StartShell(
    BSTR UserName )
{
    return S_OK;
}

//------------------------------------------------------------------------

CTerminalServerLogonNotification::CTerminalServerLogonNotification()
    : m_PendingUserChecks( 0 ),
    m_fConsoleUser( false )
{
}

CTerminalServerLogonNotification::~CTerminalServerLogonNotification()
{
    while (m_PendingUserChecks)
        {
        LogInfo("m_PendingUserChecks is %d", m_PendingUserChecks);
        Sleep(50);
        }
}

STDMETHODIMP
CTerminalServerLogonNotification::Logon(
    BSTR UserName )
{
    HRESULT Hr = S_OK;

    LogInfo( "TS SENS logon notification for %S", (WCHAR*)UserName );

    if (!m_fConsoleUser)
        {
        // Wait a few seconds in case TS hasn't seen the notification yet, then
        // check whetherthe notification was for the console.
        // if it fails, not much recourse.
        //
        Hr = QueueConsoleUserCheck();
        }

    LogInfo( "hr = %!winerr!", Hr );

    return Hr;
}

STDMETHODIMP
CTerminalServerLogonNotification::Logoff(
    BSTR UserName )
{
    HRESULT Hr = S_OK;

    LogInfo( "TS SENS logoff notification for %S", (WCHAR*)UserName );

    if (m_fConsoleUser)
        {
        bool fSame;
        LPWSTR ConsoleUserName = NULL;

        Hr = GetConsoleUsername( &ConsoleUserName );

        if (FAILED( Hr ))
            {
            //
            // unable to check.  Security dictates that we be conservative and remove the user.
            //
            LogError("unable to fetch console username %x, thus logoff callback", Hr);

            Hr = SessionLogoffCallback( 0 );
            m_fConsoleUser = false;
            }
        else if (ConsoleUserName == NULL)
            {
            //
            // no user logged in at the console
            //
            LogInfo("no one logged in at the console, thus logoff callback");

            Hr = SessionLogoffCallback( 0 );
            m_fConsoleUser = false;
            }
        else if (0 != _wcsicmp( UserName, ConsoleUserName))
            {
            LogInfo("console user is %S; doesn't match", ConsoleUserName);

            delete [] ConsoleUserName;
            Hr = S_OK;
            }
        else
            {
            // correct user, but (s)he might have logged off from a TS session.
            // We should wait a few seconds before checking the console state because the
            // TS code may not have seen the logoff notification yet.  Because Logoff is a synchronous
            // notification, we cannot just Sleep before checking..
            //
            delete [] ConsoleUserName;

            if (FAILED(QueueConsoleUserCheck()))
                {
                //
                // unable to check.  Security dictates that we be conservative and remove the user.
                //
                LogError("unable to queue check, thus logoff callback");
                Hr = SessionLogoffCallback( 0 );
                m_fConsoleUser = false;
                }
            }
        }
    else
        {
        LogInfo("ignoring, no console user");
        }

    LogInfo( "hr = %!winerr!", Hr );

    return Hr;
}

HRESULT
CTerminalServerLogonNotification::QueueConsoleUserCheck()
{
    if (QueueUserWorkItem( UserCheckThreadProc, this, WT_EXECUTELONGFUNCTION ))
        {
        InterlockedIncrement( &m_PendingUserChecks );
        LogInfo("queued user check: about %d pending", m_PendingUserChecks );
        return S_OK;
        }
    else
        {
        DWORD s = GetLastError();
        LogError("unable to queue user check %!winerr!", s);
        return HRESULT_FROM_WIN32( s );
        }
}

DWORD WINAPI
CTerminalServerLogonNotification::UserCheckThreadProc(
    LPVOID arg
    )
{
    CTerminalServerLogonNotification * _this = reinterpret_cast<CTerminalServerLogonNotification *>(arg);

    LogInfo("sleeping before user check");
    Sleep( 5 * 1000 );

    _this->ConsoleUserCheck();

    return 0;
}

void CTerminalServerLogonNotification::ConsoleUserCheck()
{
    HRESULT Hr;

    LogInfo("SENS console user check");

    if (IsServiceShuttingDown())
        {
        LogWarning("service is shutting down.");
        InterlockedDecrement( &m_PendingUserChecks );
        return;
        }

    bool bConsoleUser;

    Hr = GetConsoleUserPresent( &bConsoleUser );

    //
    // Security requires us to be conservative: if we can't tell whether the user
    // is logged in, we must release his token.
    //
    if (FAILED(Hr))
        {
        LogError("GetConsoleUserPresent returned %x", Hr );
        }

    if (FAILED(Hr) || !bConsoleUser)
        {
        LogInfo("logoff callback");
        if (FAILED(SessionLogoffCallback( 0 )))
            {
            // unusual: the only obvious generator is
            // - no known user at console
            // - TS logon or failing console logon
            // - memory allocation failure referring to m_ActiveSessions[ session ]
            // either way, we don't think a user is at the console, so m_fConsoleUser should be false.
            }
        m_fConsoleUser = false;
        }
    else
        {
        LogInfo("logon callback");
        m_fConsoleUser = true;
        if (FAILED(SessionLogonCallback( 0 )))
            {
            // no user token available, but we still know that there is a console user.
            }
        }

    InterlockedDecrement( &m_PendingUserChecks );
}

HRESULT
GetConsoleUserPresent( bool * pfPresent )
{
    /*
    If logon fails, we still know that there is a user at the console.  
    Setting the flag will prevent queued checks for further logons, and 
    logoff handles the no-user case.

    For Logoff, regardless of exit path there is no user recorded for that session.  
    Setting the flag prevents queued checks for future logoffs.
    */

    INT * pConnectState = 0;
    DWORD size;
    if (WTSQuerySessionInformation( WTS_CURRENT_SERVER,
                                    0,
                                    WTSConnectState,
                                    reinterpret_cast<LPTSTR *>(&pConnectState),
                                    &size))
        {
        LogInfo("console session state is %d", *pConnectState);
        if (*pConnectState == WTSActive ||
            *pConnectState == WTSDisconnected)
            {
            LogInfo("console user present");
            *pfPresent = true;
            }
        else
            {
            LogInfo("no console user");
            *pfPresent = false;
            }

        WTSFreeMemory( pConnectState );
        return S_OK;
        }
    else
        {
        DWORD s = GetLastError();
        LogInfo("WTSQuerySessionInformation returned %!winerr!", s);
        return HRESULT_FROM_WIN32( s );
        }
}

HRESULT GetConsoleUsername( LPWSTR * pFinalName )
{
    HRESULT hr;

    LPWSTR UserName = NULL;
    LPWSTR DomainName = NULL;

    *pFinalName = NULL;

   try
       {
       DWORD UserSize;
       DWORD DomainSize;

       if (!WTSQuerySessionInformationW( WTS_CURRENT_SERVER,
                                       0,
                                       WTSUserName,
                                       &UserName,
                                       &UserSize))
           {
           ThrowLastError();
           }

       if (!WTSQuerySessionInformationW( WTS_CURRENT_SERVER,
                                       0,
                                       WTSDomainName,
                                       &DomainName,
                                       &DomainSize))
           {
           ThrowLastError();
           }

       *pFinalName = new WCHAR[ DomainSize + 1 + UserSize + 1 ];

       hr = StringCchPrintf( *pFinalName,
                             UserSize + 1 + DomainSize + 1,
                             L"%s\\%s", DomainName, UserName
                             );
       }
   catch ( ComError err )
       {
       delete [] *pFinalName;
       *pFinalName = NULL;

       hr = err.Error();
       }

   if (DomainName)
       {
       WTSFreeMemory( DomainName );
       }

   if (UserName)
       {
       WTSFreeMemory( UserName );
       }

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\newjob\csens.h ===
class CLogonNotification : public CSimpleExternalIUnknown<ISensLogon>
{

public:
    CLogonNotification();
    ~CLogonNotification() { Cleanup(); }

private:

    IEventSubscription * m_EventSubscriptions[2];
    IEventSystem *m_EventSystem;
    ITypeLib *m_TypeLib;
    ITypeInfo *m_TypeInfo;

    void Cleanup();

public:

    HRESULT SetEnableState( bool fEnable );

    void DeRegisterNotification();

    HRESULT STDMETHODCALLTYPE GetIDsOfNames(
        REFIID riid,
        OLECHAR FAR* FAR* rgszNames,
        unsigned int cNames,
        LCID lcid,
        DISPID FAR*
        rgDispId );

    HRESULT STDMETHODCALLTYPE GetTypeInfo(
        unsigned int iTInfo,
        LCID lcid,
        ITypeInfo FAR* FAR* ppTInfo );

    HRESULT STDMETHODCALLTYPE GetTypeInfoCount(
        unsigned int FAR* pctinfo );

    HRESULT STDMETHODCALLTYPE Invoke(
        DISPID dispIdMember,
        REFIID riid,
        LCID lcid,
        WORD wFlags,
        DISPPARAMS FAR* pDispParams,
        VARIANT FAR* pVarResult,
        EXCEPINFO FAR* pExcepInfo,
        unsigned int FAR* puArgErr );

    HRESULT STDMETHODCALLTYPE DisplayLock( BSTR UserName );
    HRESULT STDMETHODCALLTYPE DisplayUnlock( BSTR UserName );
    HRESULT STDMETHODCALLTYPE StartScreenSaver( BSTR UserName );
    HRESULT STDMETHODCALLTYPE StopScreenSaver( BSTR UserName );
    HRESULT STDMETHODCALLTYPE Logon( BSTR UserName );
    HRESULT STDMETHODCALLTYPE Logoff( BSTR UserName );
    HRESULT STDMETHODCALLTYPE StartShell( BSTR UserName );
};

class CTerminalServerLogonNotification : public CLogonNotification
{
public:
    CTerminalServerLogonNotification();
    ~CTerminalServerLogonNotification();

protected:

    void ConsoleUserCheck();

    HRESULT QueueConsoleUserCheck();

    static DWORD WINAPI
    UserCheckThreadProc(
        LPVOID arg
        );

    // true if we believe that a user is logged in at the console.
    //
    bool m_fConsoleUser;

    // number of queued calls to ConsoleUserCheck()
    //
    LONG m_PendingUserChecks;

public:

    HRESULT STDMETHODCALLTYPE Logon( BSTR UserName );
    HRESULT STDMETHODCALLTYPE Logoff( BSTR UserName );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\newjob\cmarshal.h ===
//-------------------------------------------------------------

inline void *
AdvanceBuffer(
    void * Buffer,
    size_t Bytes
    )
/*
    Adds a given number of bytes to a pointer, returning the result.
    The original pointer is not changed.
*/
{
    char * buf = reinterpret_cast<char *>( Buffer );

    return (buf + Bytes);
}

inline void
ScrubBuffer(
    void * Buffer,
    size_t Length
    )
{
    MySecureZeroMemory( Buffer, Length );
}

inline void
ScrubStringW(
    LPWSTR String
    )
{
    if (String == 0)
        {
        return;
        }

    //
    // The volatile attribute ensures that the loop cannot be optimized away.
    //
    volatile wchar_t * p = String;

    while (*p != 0)
        {
        *p = 0;
        ++p;
        }
}

inline void
ScrubBasicCredentials(
    BG_BASIC_CREDENTIALS & cred
    )
{
    ScrubStringW( cred.UserName );
    ScrubStringW( cred.Password );
}

inline void
ScrubCredentials(
    BG_AUTH_CREDENTIALS & val
    )
{
    switch (val.Scheme)
        {
        case BG_AUTH_SCHEME_BASIC:
        case BG_AUTH_SCHEME_DIGEST:
        case BG_AUTH_SCHEME_NTLM:
        case BG_AUTH_SCHEME_NEGOTIATE:
        case BG_AUTH_SCHEME_PASSPORT:

             ScrubBasicCredentials( val.Credentials.Basic );
             break;

        default:

            ASSERT( 0 && "unknown auth scheme" );
            THROW_HRESULT( E_FAIL );
        }
}

class CMarshalCursor
{
public:

    CMarshalCursor( void * Buffer, size_t Length )
    {
        m_BufferStart = Buffer;
        m_BufferCurrent = Buffer;
        m_Length = Length;
    }

    void * GetBufferStart()
    {
        return m_BufferStart;
    }

    void * GetBufferCurrent()
    {
        return m_BufferCurrent;
    }

    void * Advance( size_t Length )
    {
        if (GetLengthRemaining() < Length)
            {
            THROW_HRESULT( E_INVALIDARG );
            }

        m_BufferCurrent = AdvanceBuffer( m_BufferCurrent, Length );
    }

    size_t GetLengthUsed()
    {
        char * b1 = reinterpret_cast<char *>( m_BufferStart );
        char * b2 = reinterpret_cast<char *>( m_BufferCurrent );

        return (b2-b1);
    }

    size_t GetLengthRemaining()
    {
        return m_Length - GetLengthUsed();
    }

    CMarshalCursor GetSubCursor()
    {
        CMarshalCursor SubCursor( m_BufferCurrent, GetLengthRemaining() );

        return SubCursor;
    }

    void CommitSubCursor( CMarshalCursor & SubCursor )
    {
        if (SubCursor.m_BufferStart   < m_BufferStart ||
            SubCursor.m_BufferCurrent > AdvanceBuffer( m_BufferStart, m_Length ))
            {
            THROW_HRESULT( E_INVALIDARG );
            }

        m_BufferCurrent = SubCursor.m_BufferCurrent;
    }

    void Rewind()
    {
        m_BufferCurrent = m_BufferStart;
    }

    void Scrub()
    {
        ScrubBuffer( m_BufferStart, GetLengthUsed() );
    }

    void ScrubUnusedSpace()
    {
        ScrubBuffer( m_BufferCurrent, GetLengthRemaining() );
    }

    inline void Read( void * Buffer, size_t Length );
    inline void Write( const void * Buffer, size_t Length );

private:

    void * m_BufferStart;
    void * m_BufferCurrent;

    size_t  m_Length;
};

void CMarshalCursor::Write( const void * Buffer, size_t Length )
{
    if (GetLengthRemaining() < Length)
        {
        THROW_HRESULT( E_INVALIDARG );
        }

    memcpy( m_BufferCurrent, Buffer, Length );

    m_BufferCurrent = AdvanceBuffer( m_BufferCurrent, Length );
}

void CMarshalCursor::Read( void * Buffer, size_t Length )
{
    if (GetLengthRemaining() < Length)
        {
        THROW_HRESULT( E_INVALIDARG );
        }

    memcpy( Buffer, m_BufferCurrent, Length );

    m_BufferCurrent = AdvanceBuffer( m_BufferCurrent, Length );
}

class CBufferMarshaller
{
public:

    CBufferMarshaller( CMarshalCursor & Cursor ) : m_Cursor( Cursor )
    {
    }

    CBufferMarshaller( CMarshalCursor & Cursor, const void * Buffer, size_t Length ) : m_Cursor( Cursor )
    {
        Marshal( Buffer, Length );
    }

    void Marshal( const void * Buffer, size_t Length )
    {
        m_Cursor.Write( Buffer, Length );
    }

protected:

    CMarshalCursor & m_Cursor;
};

class CBufferUnmarshaller
{
public:

    CBufferUnmarshaller( CMarshalCursor & Cursor ) : m_Cursor( Cursor )
    {
    }

    CBufferUnmarshaller( CMarshalCursor & Cursor, void * Buffer, size_t Length ) : m_Cursor( Cursor )
    {
        Unmarshal( Buffer, Length );
    }

    void Unmarshal( void * Buffer, size_t Length )
    {
        m_Cursor.Read( Buffer, Length );
    }

protected:

    CMarshalCursor & m_Cursor;
};

template<class T> class CBasicMarshaller
{
public:

    CBasicMarshaller( CMarshalCursor & Cursor ) : m_Cursor( Cursor )
    {
    }

    CBasicMarshaller( CMarshalCursor & Cursor, const T & val ) : m_Cursor( Cursor )
    {
        Marshal( val );
    }

    static size_t Size( const T & val )
    {
        return sizeof(T);
    }

    virtual void Marshal( const T & val )
    {
        m_Cursor.Write( &val, sizeof(T));
    }

protected:

    CMarshalCursor & m_Cursor;
};

template<class T> class CBasicUnmarshaller
{
public:

    CBasicUnmarshaller( CMarshalCursor & Cursor ) : m_Cursor( Cursor )
    {
    }

    CBasicUnmarshaller( CMarshalCursor & Cursor, T & val ) : m_Cursor( Cursor )
    {
        Unmarshal( val );
    }

    void Unmarshal( T & val )
    {
        m_Cursor.Read( &val, sizeof(T));
    }

protected:

    CMarshalCursor & m_Cursor;
};


typedef CBasicMarshaller<DWORD> CDwordMarshaller;
typedef CBasicMarshaller<BG_AUTH_SCHEME> CSchemeMarshaller;
typedef CBasicMarshaller<BG_AUTH_TARGET> CTargetMarshaller;

typedef CBasicUnmarshaller<DWORD> CDwordUnmarshaller;
typedef CBasicUnmarshaller<BG_AUTH_SCHEME> CSchemeUnmarshaller;
typedef CBasicUnmarshaller<BG_AUTH_TARGET> CTargetUnmarshaller;

class CUnicodeStringMarshaller
{
public:

    CUnicodeStringMarshaller( CMarshalCursor & Cursor ) : m_Cursor( Cursor )
    {
    }

    CUnicodeStringMarshaller( CMarshalCursor & Cursor, const LPWSTR & val ) : m_Cursor( Cursor )
    {
        Marshal( val );
    }

    static size_t Size( const LPWSTR & val )
    {
        DWORD StringBytes;

        if (val)
            {
            StringBytes = sizeof(wchar_t) * (1+wcslen(val));
            }
        else
            {
            StringBytes = 0;
            }

        return CDwordMarshaller::Size( StringBytes ) + StringBytes;
    }

    void Marshal( const LPWSTR & val )
    {
        CMarshalCursor Cursor =  m_Cursor.GetSubCursor();

        try
            {
            DWORD StringBytes;

            if (val)
                {
                StringBytes = sizeof(wchar_t) * (1+wcslen(val));

                CDwordMarshaller m1( Cursor, StringBytes );
                CBufferMarshaller m2( Cursor, val, StringBytes );
                }
            else
                {
                StringBytes = 0;
                CDwordMarshaller m1( Cursor, StringBytes );
                }

            m_Cursor.CommitSubCursor( Cursor );
            }
        catch ( ComError err )
            {
            m_Cursor.Scrub();
            throw;
            }
    }

protected:

    CMarshalCursor & m_Cursor;
};

class CUnicodeStringUnmarshaller
{
public:

    CUnicodeStringUnmarshaller( CMarshalCursor & Cursor ) : m_Cursor( Cursor )
    {
    }

    CUnicodeStringUnmarshaller( CMarshalCursor & Cursor, LPWSTR & val ) : m_Cursor( Cursor )
    {
        Unmarshal( val );
    }

    void Unmarshal( LPWSTR & val )
    {
        CMarshalCursor Cursor = m_Cursor.GetSubCursor();

        try
            {
            DWORD StringBytes;
            val = 0;

            CDwordUnmarshaller m1( Cursor, StringBytes );

            if (StringBytes)
                {
                val = reinterpret_cast<LPWSTR>( new char[ StringBytes ] );
                CBufferUnmarshaller m2( Cursor, val, StringBytes );
                }

            m_Cursor.CommitSubCursor( Cursor );
            }
        catch ( ComError err )
            {
            delete val;
            val = 0;
            throw;
            }
    }

protected:

    CMarshalCursor & m_Cursor;
};

class CBasicCredentialsMarshaller
{
public:

    CBasicCredentialsMarshaller( CMarshalCursor & Cursor ) : m_Cursor( Cursor )
    {
    }

    CBasicCredentialsMarshaller( CMarshalCursor & Cursor, const BG_BASIC_CREDENTIALS & val ) : m_Cursor( Cursor )
    {
        Marshal( val );
    }

    static size_t Size( const BG_BASIC_CREDENTIALS & val )
    {
        return    CUnicodeStringMarshaller::Size( val.UserName )
                + CUnicodeStringMarshaller::Size( val.Password );
    }

    void Marshal( const BG_BASIC_CREDENTIALS & val )
    {
        CMarshalCursor Cursor = m_Cursor.GetSubCursor();

        try
            {
            CUnicodeStringMarshaller m1( Cursor, val.UserName );
            CUnicodeStringMarshaller m2( Cursor, val.Password );

            m_Cursor.CommitSubCursor( Cursor );
            }
        catch ( ComError err )
            {
            Cursor.Scrub();
            throw;
            }
    }

protected:

    CMarshalCursor & m_Cursor;
};

class CBasicCredentialsUnmarshaller
{
public:

    CBasicCredentialsUnmarshaller( CMarshalCursor & Cursor ) : m_Cursor( Cursor )
    {
    }

    CBasicCredentialsUnmarshaller( CMarshalCursor & Cursor, BG_BASIC_CREDENTIALS & val ) : m_Cursor( Cursor )
    {
        Unmarshal( val );
    }

    void Unmarshal( BG_BASIC_CREDENTIALS & val )
    {
        val.UserName = 0;
        val.Password = 0;

        CMarshalCursor Cursor = m_Cursor.GetSubCursor();

        try
            {
            CUnicodeStringUnmarshaller m1( Cursor, val.UserName );
            CUnicodeStringUnmarshaller m2( Cursor, val.Password );

            m_Cursor.CommitSubCursor( Cursor );
            }
        catch ( ComError err )
            {
            ScrubStringW( val.UserName );
            delete val.UserName;

            ScrubStringW( val.Password );
            delete val.Password;
            throw;
            }
    }

protected:

    CMarshalCursor & m_Cursor;
};

class CAuthCredentialsMarshaller
{
public:

    CAuthCredentialsMarshaller( CMarshalCursor & Cursor ) : m_Cursor( Cursor )
    {
    }

    CAuthCredentialsMarshaller( CMarshalCursor & Cursor, const BG_AUTH_CREDENTIALS * val ) : m_Cursor( Cursor )
    {
        Marshal( val );
    }

    static size_t Size( const BG_AUTH_CREDENTIALS * val )
    {
        switch (val->Scheme)
            {
            case BG_AUTH_SCHEME_BASIC:
            case BG_AUTH_SCHEME_DIGEST:
            case BG_AUTH_SCHEME_NTLM:
            case BG_AUTH_SCHEME_NEGOTIATE:
            case BG_AUTH_SCHEME_PASSPORT:
                {
                return    CDwordMarshaller::Size( val->Scheme )
                        + CDwordMarshaller::Size( val->Target )
                        + CBasicCredentialsMarshaller::Size( val->Credentials.Basic );
                }

            default:

                ASSERT( 0 && "size: unknown auth scheme" );
                throw ComError( E_FAIL );
            }
    }

    void Marshal( const BG_AUTH_CREDENTIALS * val )
    {
        CMarshalCursor Cursor = m_Cursor.GetSubCursor();

        try
            {
            CSchemeMarshaller m1( Cursor, val->Scheme );
            CTargetMarshaller m2( Cursor, val->Target );

            switch (val->Scheme)
                {
                case BG_AUTH_SCHEME_BASIC:
                case BG_AUTH_SCHEME_DIGEST:
                case BG_AUTH_SCHEME_NTLM:
                case BG_AUTH_SCHEME_NEGOTIATE:
                case BG_AUTH_SCHEME_PASSPORT:
                    {
                    CBasicCredentialsMarshaller m3( Cursor, val->Credentials.Basic );
                    break;
                    }

                default:

                    ASSERT( 0 && "marshal: unknown auth scheme" );
                    throw ComError( E_FAIL );
                }

            m_Cursor.CommitSubCursor( Cursor );
            }
        catch ( ComError err )
            {
            Cursor.Scrub();
            throw;
            }
    }

protected:

    CMarshalCursor & m_Cursor;
};


class CAuthCredentialsUnmarshaller
{
public:

    CAuthCredentialsUnmarshaller( CMarshalCursor & Cursor ) : m_Cursor( Cursor )
    {
    }

    CAuthCredentialsUnmarshaller( CMarshalCursor & Cursor, BG_AUTH_CREDENTIALS & val ) : m_Cursor( Cursor )
    {
        Unmarshal( val );
    }

    CAuthCredentialsUnmarshaller( CMarshalCursor & Cursor, BG_AUTH_CREDENTIALS ** val ) : m_Cursor( Cursor )
    {
        Unmarshal( val );
    }

    void Unmarshal( BG_AUTH_CREDENTIALS & val )
    {
        CMarshalCursor Cursor =  m_Cursor.GetSubCursor();

        try
            {
            CSchemeUnmarshaller m1( Cursor, val.Scheme );
            CTargetUnmarshaller m2( Cursor, val.Target );

            switch (val.Scheme)
                {
                case BG_AUTH_SCHEME_BASIC:
                case BG_AUTH_SCHEME_DIGEST:
                case BG_AUTH_SCHEME_NTLM:
                case BG_AUTH_SCHEME_NEGOTIATE:
                case BG_AUTH_SCHEME_PASSPORT:
                    {
                    CBasicCredentialsUnmarshaller m3( Cursor, val.Credentials.Basic );
                    break;
                    }

                default:

                    ASSERT( 0 && "unmarshal: unknown auth scheme" );
                    THROW_HRESULT( E_FAIL );
                }

            m_Cursor.CommitSubCursor( Cursor );
            }
        catch ( ComError err )
            {
            throw;
            }
    }

    void Unmarshal( BG_AUTH_CREDENTIALS ** ppval )
    {
        BG_AUTH_CREDENTIALS * pval = 0;

        try
            {
            pval = new BG_AUTH_CREDENTIALS;

            Unmarshal( *pval );

            *ppval = pval;
            }
        catch ( ComError err )
            {
            delete pval;
            throw;
            }
    }

protected:

    CMarshalCursor & m_Cursor;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\newjob\cunknown.cpp ===
#include "stdafx.h"

#if !defined(BITS_V12_ON_NT4)
#include "cunknown.tmh"
#endif

template<class T>
CSimpleExternalIUnknown<T>::CSimpleExternalIUnknown() :
    m_ServiceInstance( g_ServiceInstance ),
    m_refs(1) // always start with one ref count!
{
    GlobalLockServer( TRUE );
}

template<class T>
CSimpleExternalIUnknown<T>::~CSimpleExternalIUnknown()
{
    GlobalLockServer( FALSE );
}

template<class T>
STDMETHODIMP
CSimpleExternalIUnknown<T>::QueryInterface(
    REFIID iid,
    void** ppvObject
    )
{

    BEGIN_EXTERNAL_FUNC

    HRESULT Hr = S_OK;
    *ppvObject = NULL;

    if ((iid == IID_IUnknown) || (iid == _uuidof(T)))
        {
        *ppvObject = static_cast<T *> (this);
        (static_cast<IUnknown *>(*ppvObject))->AddRef();
        }
    else
        {
        Hr = E_NOINTERFACE;
        }

    LogRef( "IUnknown %p QueryInterface: iid %!guid!, Hr %x", this, &iid, Hr );

    return Hr;

    END_EXTERNAL_FUNC
}

template<class T>
ULONG
CSimpleExternalIUnknown<T>::AddRef()
{
    BEGIN_EXTERNAL_FUNC

    ASSERT( m_refs != 0 );

    ULONG newrefs = InterlockedIncrement(&m_refs);

    LogRef( "IUnknown %p addref: new refs = %d", this, newrefs );

    return newrefs;

    END_EXTERNAL_FUNC
}

template<class T>
ULONG
CSimpleExternalIUnknown<T>::Release()
{

    BEGIN_EXTERNAL_FUNC;

    ULONG newrefs = InterlockedDecrement(&m_refs);

    LogRef( "IUnknown %p release: new refs = %d", this, newrefs );

    if (newrefs == 0)
        {
        LogInfo( "Deleting object due to ref count hitting 0" );

        delete this;
        return 0;
        }

    return m_refs;

    END_EXTERNAL_FUNC
}


// Work around problem in logging where functions in headers can't have logging

template CSimpleExternalIUnknown<IBackgroundCopyError>;

template CSimpleExternalIUnknown<IEnumBackgroundCopyFiles>;
template CSimpleExternalIUnknown<IEnumBackgroundCopyGroups>;
template CSimpleExternalIUnknown<IEnumBackgroundCopyJobs>;
template CSimpleExternalIUnknown<IEnumBackgroundCopyJobs1>;
template CSimpleExternalIUnknown<ISensLogon>;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\newjob\cunknown.h ===
template<SIZE_T Offset>
class TrackedClassObject
{
   static LONG* GetCounter()
   {
      return reinterpret_cast<LONG*>( reinterpret_cast<char*>( g_GlobalInfo->m_StatSection ) + Offset );
   }
protected:
   TrackedClassObject()
   {
      InterlockedIncrement( GetCounter() );
   }
   ~TrackedClassObject()
   {
       if (g_ServiceState == MANAGER_INACTIVE)
           {
           return;
           }
       InterlockedDecrement( GetCounter() );
   }
};

//------------------------------------------------------------------------

template<class T>
class CSimpleExternalIUnknown : public T
{
public:

    // IUnknown Methods
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObject);
    ULONG _stdcall AddRef(void);
    ULONG _stdcall Release(void);

protected:
    CSimpleExternalIUnknown();
    virtual ~CSimpleExternalIUnknown();

    long m_ServiceInstance;
    LONG m_refs;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\newjob\drizcpat.cpp ===
/************************************************************************

Copyright (c) 2000 - 2000 Microsoft Corporation

Module Name :

    drizcpat.cpp

Abstract :

    Compatibility wrapper against the old AU bits.

Author :

Revision History :

 ***********************************************************************/

#include "stdafx.h"

#if !defined(BITS_V12_ON_NT4)
#include "drizcpat.tmh"
#endif

DWORD NewJobSizeToOldSize( UINT64 NewSize )
{
    if ( NewSize == UINT64(-1))
        return 0;

    return (DWORD)NewSize;
}

DWORD MapOldNotifyToNewNotify( DWORD dwOldNotify )
{
     // The mars interface has error on by default.
     DWORD dwReturnVal = BG_NOTIFY_JOB_ERROR;

     if ( dwOldNotify &
          ~(  QM_NOTIFY_GROUP_DONE | QM_NOTIFY_DISABLE_NOTIFY ) )
         throw ComError( E_NOTIMPL );

     if ( dwOldNotify & QM_NOTIFY_GROUP_DONE )
         dwReturnVal |= BG_NOTIFY_JOB_TRANSFERRED;

     if ( dwOldNotify & QM_NOTIFY_DISABLE_NOTIFY )
         dwReturnVal |= BG_NOTIFY_DISABLE;

     return dwReturnVal;
}

DWORD MapNewNotifyToOldNotify( DWORD dwNewNotify )
{
     DWORD dwReturnVal = 0;

     if ( dwNewNotify & BG_NOTIFY_JOB_TRANSFERRED )
         dwReturnVal |= QM_NOTIFY_GROUP_DONE;

     if ( dwNewNotify & BG_NOTIFY_DISABLE )
         dwReturnVal |= QM_NOTIFY_DISABLE_NOTIFY;

     return dwReturnVal;
}

COldGroupInterface::COldGroupInterface(
    CJob *pJob ) :
    m_refs(1),
    m_ServiceInstance( g_ServiceInstance ),
    m_NotifyPointer( NULL ),
    m_NotifyClsid( GUID_NULL ),
    m_pJob(pJob),
    m_pJobExternal( pJob->GetExternalInterface() )
{
    m_pJobExternal->AddRef();
}

COldGroupInterface::~COldGroupInterface()
{
    m_pJobExternal->Release();
}


STDMETHODIMP
COldGroupInterface::QueryInterface(
    REFIID iid,
    void** ppvObject
    )
{
    BEGIN_EXTERNAL_FUNC

    LogPublicApiBegin( "iid %!guid!, ppvObject %p", &iid, ppvObject );
    HRESULT Hr = S_OK;
    *ppvObject = NULL;

    if ((iid == _uuidof(IUnknown)) || (iid == __uuidof(IBackgroundCopyGroup)) )
        {
        *ppvObject = (IBackgroundCopyGroup *)this;
        ((IUnknown *)(*ppvObject))->AddRef();
        }
    else
        {
        Hr = E_NOINTERFACE;
        }

    LogPublicApiEnd( "iid %!guid!, ppvObject %p", &iid, ppvObject );
    return Hr;

    END_EXTERNAL_FUNC
}

ULONG _stdcall
COldGroupInterface::AddRef(void)
{
   BEGIN_EXTERNAL_FUNC

   ULONG newrefs = InterlockedIncrement(&m_refs);

   LogRef( "job %p, refs = %d", m_pJob, newrefs );

   return newrefs;

   END_EXTERNAL_FUNC
}

ULONG _stdcall
COldGroupInterface::Release(void)
{
   BEGIN_EXTERNAL_FUNC

   ULONG newrefs = InterlockedDecrement(&m_refs);

   LogRef( "job %p, refs = %d", m_pJob, newrefs );

   if (newrefs == 0)
       {
       delete this;
       }

   return newrefs;

   END_EXTERNAL_FUNC
}


STDMETHODIMP
COldGroupInterface::GetPropInternal(
    GROUPPROP property,
    VARIANT * pVal
    )
{
    HRESULT Hr = S_OK;
    CLockedJobReadPointer LockedJob(m_pJob);
    LogPublicApiBegin( "property %u, pVal %p", property, pVal );

    WCHAR * pString = NULL;

    try
    {
       ASSERT( pVal );

       VariantClear( pVal );

       THROW_HRESULT( LockedJob.ValidateAccess() );

       switch (property)
           {
           case GROUPPROP_PRIORITY:
               pVal->vt = VT_INT;
               pVal->intVal = 1;
               break;

           case GROUPPROP_PROTOCOLFLAGS:
               pVal->vt = VT_INT;
               pVal->intVal = QM_PROTOCOL_HTTP;
               break;

           case GROUPPROP_NOTIFYFLAGS:
               pVal->vt = VT_INT;
               pVal->intVal = MapNewNotifyToOldNotify( LockedJob->GetNotifyFlags() );
               break;

           case GROUPPROP_NOTIFYCLSID:
               {
               THROW_HRESULT( StringFromIID( m_NotifyClsid, &pString ));

               pVal->vt = VT_BSTR;
               pVal->bstrVal = SysAllocString( pString );

               if ( !pVal->bstrVal )
                   throw ComError( E_OUTOFMEMORY );

               break;
               }

           case GROUPPROP_DISPLAYNAME:
               {

               THROW_HRESULT( LockedJob->GetDisplayName( &pString ) );

               pVal->vt = VT_BSTR;
               pVal->bstrVal = SysAllocString( pString );

               if ( !pVal->bstrVal )
                   throw ComError( E_OUTOFMEMORY );

               break;
               }

           case GROUPPROP_DESCRIPTION:
               {

               THROW_HRESULT( LockedJob->GetDescription( &pString ) );

               pVal->vt = VT_BSTR;
               pVal->bstrVal = SysAllocString( pString );

               if ( !pVal->bstrVal )
                   throw ComError( E_OUTOFMEMORY );

               break;
               }

           default:
               return E_NOTIMPL;
           }

    }
    catch( ComError Error )
    {
        Hr = Error.Error();
        VariantClear( pVal );
    }

    CoTaskMemFree( pString );

    LogPublicApiEnd( "property %u, pVal %p", property, pVal );
    return Hr;

}

STDMETHODIMP
COldGroupInterface::SetPropInternal(
    GROUPPROP property,
    VARIANT *pvarVal
    )
{
    HRESULT Hr = S_OK;
    CLockedJobWritePointer LockedJob(m_pJob);
    LogPublicApiBegin( "property %u, Val %p", property, pvarVal );

    DWORD dwValue = -1;
    BSTR bstrIn = NULL;

    try
    {
        if (!pvarVal)
            throw ComError(E_INVALIDARG);

        THROW_HRESULT( LockedJob.ValidateAccess() );

        //
        // This is how the old code did it.  Unfortunate, but compatible.
        //
        switch (pvarVal->vt)
            {
            case VT_I4:
                dwValue = (DWORD)(pvarVal->lVal < 0) ? -1 : pvarVal->lVal;
                break;
            case VT_I2:
                dwValue = (DWORD)(pvarVal->iVal < 0) ? -1 : pvarVal->iVal;
                break;
            case VT_UI2:
                dwValue = (DWORD)pvarVal->uiVal;
                break;
            case VT_UI4:
                dwValue = (DWORD)pvarVal->ulVal;
                break;
            case VT_INT:
                dwValue = (DWORD)(pvarVal->intVal < 0) ? -1 : pvarVal->intVal;
                break;
            case VT_UINT:
                dwValue = (DWORD)pvarVal->uintVal;
                break;
            case VT_BSTR:
                bstrIn = pvarVal->bstrVal;
                break;
            default:
                return E_INVALIDARG;
            }

        switch (property)
           {
           case GROUPPROP_PRIORITY:
               //
               // Only one priority was supported.  No need to store it.
               //
               if (dwValue != 1)
                   {
                   throw ComError( E_NOTIMPL );
                   }
               break;

           case GROUPPROP_PROTOCOLFLAGS:

               //
               // Only HTTP was supported.  No need to store it.
               //
               if (dwValue != QM_PROTOCOL_HTTP)
                   {
                   throw ComError( E_NOTIMPL );
                   }
               break;

           case GROUPPROP_NOTIFYFLAGS:

               THROW_HRESULT( LockedJob->SetNotifyFlags( MapOldNotifyToNewNotify( dwValue ) ) );
               break;

            case GROUPPROP_NOTIFYCLSID:
                {
                if (NULL == bstrIn)
                    {
                    throw ComError( E_INVALIDARG );
                    }

                GUID clsid;
                THROW_HRESULT( IIDFromString( bstrIn, &clsid ) );

                m_NotifyClsid = clsid;
                break;
                }

           case GROUPPROP_DISPLAYNAME:
               THROW_HRESULT( LockedJob->SetDisplayName( (WCHAR *)bstrIn ) );
               break;

           case GROUPPROP_DESCRIPTION:
               THROW_HRESULT( LockedJob->SetDescription( (WCHAR *)bstrIn ) );
               break;

           default:
               return E_NOTIMPL;
           }

    }
    catch( ComError Error )
    {
        Hr = Error.Error();
    }

    LogPublicApiEnd( "property %u, pVal %p", property, pvarVal );
    return Hr;

}

STDMETHODIMP
COldGroupInterface::GetProgressInternal(
    DWORD flags,
    DWORD * pProgress
    )
{

    HRESULT Hr = S_OK;
    CLockedJobReadPointer LockedJob(m_pJob);
    LogPublicApiBegin( "flags %u", flags );

    try
    {

        ASSERT( pProgress );
        THROW_HRESULT( LockedJob.ValidateAccess() );

        BG_JOB_PROGRESS JobProgress;
        LockedJob->GetProgress( &JobProgress );

        switch( flags )
            {
            case QM_PROGRESS_SIZE_DONE:
                {

                *pProgress = NewJobSizeToOldSize( JobProgress.BytesTransferred );
                break;
                }

            case QM_PROGRESS_PERCENT_DONE:
                {

                if ( ( -1 == JobProgress.BytesTotal ) ||
                     ( -1 == JobProgress.BytesTransferred ) ||
                     ( 0 == JobProgress.BytesTotal ) )
                    {
                    *pProgress = 0;
                    }
                else
                    {
                    double ratio = double(JobProgress.BytesTransferred) / double(JobProgress.BytesTotal );
                    *pProgress = DWORD( ratio * 100.0 );
                    }
                break;
                }

            default:
                {
                throw ComError( E_NOTIMPL );
                }
            }
    }
    catch( ComError Error )
    {
       Hr = Error.Error();
       *pProgress = 0;
    }

    LogPublicApiEnd( "progress %d", *pProgress );
    return Hr;
}

STDMETHODIMP
COldGroupInterface::GetStatusInternal(
    DWORD *pdwStatus,
    DWORD *pdwJobIndex)
{

    HRESULT Hr = S_OK;
    CLockedJobReadPointer LockedJob(m_pJob);
    LogPublicApiBegin( "pdwStatus %p, pdwJobIndex %p", pdwStatus, pdwJobIndex );

    try
    {
        ASSERT( pdwStatus && pdwJobIndex );
        *pdwStatus = *pdwJobIndex = 0;

        THROW_HRESULT( LockedJob.ValidateAccess() );

        // Note: we never increment the JobIndex anymore

        BG_JOB_STATE State = LockedJob->_GetState();
        BG_JOB_PRIORITY Priority = LockedJob->_GetPriority();

        if ( BG_JOB_PRIORITY_FOREGROUND == Priority )
            *pdwStatus |= QM_STATUS_GROUP_FOREGROUND;

        switch( State )
            {
            case BG_JOB_STATE_QUEUED:
            case BG_JOB_STATE_CONNECTING:
            case BG_JOB_STATE_TRANSFERRING:
                *pdwStatus |= QM_STATUS_GROUP_INCOMPLETE;
                break;

            case BG_JOB_STATE_SUSPENDED:
                *pdwStatus |= ( QM_STATUS_GROUP_SUSPENDED | QM_STATUS_GROUP_INCOMPLETE );
                break;

            case BG_JOB_STATE_ERROR:
                *pdwStatus |= ( QM_STATUS_GROUP_ERROR | QM_STATUS_GROUP_INCOMPLETE | QM_STATUS_GROUP_SUSPENDED );
                break;

            case BG_JOB_STATE_TRANSIENT_ERROR:
                *pdwStatus |= ( QM_STATUS_GROUP_INCOMPLETE );
                break;

            case BG_JOB_STATE_TRANSFERRED:
                *pdwStatus |= ( QM_STATUS_GROUP_COMPLETE | QM_STATUS_GROUP_SUSPENDED );
                break;

            case BG_JOB_STATE_ACKNOWLEDGED:
                *pdwStatus |= ( QM_STATUS_GROUP_COMPLETE | QM_STATUS_GROUP_SUSPENDED );
                break;

            case BG_JOB_STATE_CANCELLED:
                break;
            }

    }
    catch( ComError Error )
    {
        Hr = Error.Error();
        *pdwStatus = 0;
    }

    LogPublicApiEnd( "pdwStatus %p, pdwJobIndex %p", pdwStatus, pdwJobIndex );
    return Hr;

}

STDMETHODIMP
COldGroupInterface::GetJobInternal(
    GUID jobID,
    IBackgroundCopyJob1 **ppJob)
{

    HRESULT Hr = S_OK;
    CLockedJobReadPointer LockedJob(m_pJob);
    LogPublicApiBegin( "jobID %!guid!, ppJob %p", &jobID, ppJob );

    try
    {
        ASSERT( ppJob );
        *ppJob = NULL;

        THROW_HRESULT( LockedJob.ValidateAccess() );

        COldJobInterface *pOldJob = m_pJob->GetOldExternalJobInterface();

        if (!pOldJob)
            throw ComError( QM_E_ITEM_NOT_FOUND );

        if (jobID != pOldJob->GetOldJobId() )
            throw ComError( QM_E_ITEM_NOT_FOUND );

        *ppJob = pOldJob;
        (*ppJob)->AddRef();

    }
    catch( ComError Error )
    {
        Hr = Error.Error();
    }

    LogPublicApiEnd( "jobID %!guid!, ppJob %p", &jobID, ppJob );
    return Hr;

}

STDMETHODIMP
COldGroupInterface::SuspendGroupInternal(
    )
{

    HRESULT Hr = S_OK;
    CLockedJobWritePointer LockedJob(m_pJob);
    LogPublicApiBegin( "void" );

    try
    {
        THROW_HRESULT( LockedJob.ValidateAccess() );
        THROW_HRESULT( LockedJob->Suspend() );
    }
    catch( ComError Error )
    {
        Hr = Error.Error();
    }

    LogPublicApiEnd( "void" );
    return Hr;
}

STDMETHODIMP
COldGroupInterface::ResumeGroupInternal(
    )
{
    HRESULT Hr = S_OK;
    CLockedJobWritePointer LockedJob(m_pJob);
    LogPublicApiBegin( " " );

    try
    {
        THROW_HRESULT( LockedJob.ValidateAccess() );

        THROW_HRESULT( LockedJob->Resume() );
    }
    catch( ComError Error )
    {
        Hr = Error.Error();
    }

    LogPublicApiEnd( " " );
    return Hr;
}

STDMETHODIMP
COldGroupInterface::CancelGroupInternal(
    )
{
    HRESULT Hr = S_OK;
    CLockedJobWritePointer LockedJob(m_pJob);
    LogPublicApiBegin( " " );

    try
    {
        THROW_HRESULT( LockedJob.ValidateAccess() );
        THROW_HRESULT( LockedJob->Complete() );
    }
    catch( ComError Error )
    {
        Hr = Error.Error();
    }

    LogPublicApiEnd( " " );
    return Hr;
}

STDMETHODIMP
COldGroupInterface::get_SizeInternal(
    DWORD *pdwSize
    )
{

    HRESULT Hr = S_OK;
    CLockedJobReadPointer LockedJob(m_pJob);
    LogPublicApiBegin( " " );

    try
    {
        ASSERT( pdwSize );

        THROW_HRESULT( LockedJob.ValidateAccess() );

        BG_JOB_PROGRESS Progress;
        LockedJob->GetProgress( &Progress );

        *pdwSize = NewJobSizeToOldSize( Progress.BytesTotal );
    }
    catch( ComError Error )
    {
        Hr = Error.Error();
        *pdwSize = 0;
    }


    LogPublicApiEnd( "dwSize %d", *pdwSize );
    return Hr;
}

STDMETHODIMP
COldGroupInterface::get_GroupIDInternal(
    GUID *pguidGroupID )
{

    HRESULT Hr = S_OK;
    CLockedJobReadPointer LockedJob(m_pJob);
    LogPublicApiBegin( " " );

    try
    {
        ASSERT( pguidGroupID );

        THROW_HRESULT( LockedJob.ValidateAccess() );

        *pguidGroupID = LockedJob->GetId();

    }
    catch( ComError Error )
    {
        Hr = Error.Error();
        memset( pguidGroupID, 0 , sizeof(*pguidGroupID) );
    }

    LogPublicApiEnd( "id %!guid!", pguidGroupID );
    return Hr;

}

STDMETHODIMP
COldGroupInterface::CreateJobInternal(
    GUID guidJobID,
    IBackgroundCopyJob1 **ppJob )
{

    HRESULT Hr = S_OK;
    CLockedJobWritePointer LockedJob(m_pJob);
    LogPublicApiBegin( "guidJobID %!guid!", &guidJobID );

    try
    {
        ASSERT( ppJob );
        *ppJob = NULL;

        THROW_HRESULT( LockedJob.ValidateAccess() );

        BG_JOB_STATE State = LockedJob->_GetState();
        switch( State )
            {

            case BG_JOB_STATE_QUEUED:
            case BG_JOB_STATE_CONNECTING:
            case BG_JOB_STATE_TRANSFERRING:
                throw ComError( QM_E_INVALID_STATE );
                break;

            case BG_JOB_STATE_SUSPENDED:
            case BG_JOB_STATE_ERROR:
                break;

            case BG_JOB_STATE_TRANSIENT_ERROR:
            case BG_JOB_STATE_TRANSFERRED:
            case BG_JOB_STATE_ACKNOWLEDGED:
            case BG_JOB_STATE_CANCELLED:
                throw ComError( QM_E_INVALID_STATE );
                break;

            default:
                throw ComError( QM_E_INVALID_STATE );
                break;
            }

        if (LockedJob->GetOldExternalJobInterface())
            throw ComError( E_NOTIMPL );

        COldJobInterface *pOldJob = new COldJobInterface( guidJobID, m_pJob );

        LockedJob->SetOldExternalJobInterface( pOldJob );

        *ppJob = pOldJob;
        (*ppJob)->AddRef();

        g_Manager->Serialize();

    }
    catch( ComError Error )
    {
        Hr = Error.Error();
    }

    LogPublicApiEnd( "ppJob %p", *ppJob );
    return Hr;
}

STDMETHODIMP
COldGroupInterface::EnumJobsInternal(
    DWORD dwFlags,
    IEnumBackgroundCopyJobs1 **ppEnumJobs )
{

    HRESULT Hr = S_OK;
    CLockedJobReadPointer LockedJob(m_pJob);
    LogPublicApiBegin( "dwFlags %u, ppEnumJobs %p", dwFlags, ppEnumJobs );

    CEnumOldJobs* pEnum = NULL;
    try
    {
        ASSERT( ppEnumJobs );
        *ppEnumJobs = NULL;

        THROW_HRESULT( LockedJob.ValidateAccess() );

        if (dwFlags)
            throw ComError( E_NOTIMPL );

        pEnum = new CEnumOldJobs;

        COldJobInterface *pOldJob = LockedJob->GetOldExternalJobInterface();
        if (pOldJob)
            {
            GUID guid = pOldJob->GetOldJobId();
            pEnum->Add( guid );
            }

        *ppEnumJobs = pEnum;

    }
    catch( ComError Error )
    {
        Hr = Error.Error();
    }

    LogPublicApiEnd( "dwFlags %u, ppEnumJobs %p", dwFlags, ppEnumJobs );
    return Hr;

}

STDMETHODIMP
COldGroupInterface::SwitchToForegroundInternal(
    )
{

    HRESULT Hr = S_OK;
    CLockedJobWritePointer LockedJob(m_pJob);
    LogPublicApiBegin( " " );

    try
    {
        THROW_HRESULT( LockedJob.ValidateAccess() );

        THROW_HRESULT( LockedJob->SetPriority( BG_JOB_PRIORITY_FOREGROUND ) );
    }
    catch( ComError Error )
    {
        Hr = Error.Error();
    }

    LogPublicApiEnd( " " );
    return Hr;

}

STDMETHODIMP
COldGroupInterface::QueryNewJobInterface(
    REFIID iid,
    IUnknown **pUnk
    )
{
    LogInfo("QueryNewJobInterface %!guid!", &iid);

    if (iid != __uuidof(IBackgroundCopyJob))
        {
        LogError("E_NOTIMPL");
        *pUnk = NULL;
        return E_NOTIMPL;
        }

    *pUnk = m_pJob->GetExternalInterface();
    (*pUnk)->AddRef();

    LogInfo("OK");
    return S_OK;
}

STDMETHODIMP
COldGroupInterface::SetNotificationPointer(
    REFIID iid,
    IUnknown *pUnk
    )
{
    HRESULT Hr = S_OK;

    IBackgroundCopyCallback1 *pICB = NULL;

    LogPublicApiBegin( "IID %!guid!  ptr %p", &iid, pUnk );

    if (iid != __uuidof(IBackgroundCopyCallback1))
        {
        Hr = E_NOTIMPL;
        }
    else if ( pUnk )
        {
        try
            {
            CNestedImpersonation imp;

            //
            // Gotta do it twice, because SwitchToLogonToken will fail
            // if the user is not interactively logged in.
            //
            THROW_HRESULT( SetStaticCloaking( pUnk ) );

            imp.SwitchToLogonToken();

            THROW_HRESULT( SetStaticCloaking( pUnk ) );

            THROW_HRESULT( pUnk->QueryInterface( iid, (void**)&pICB ) );

            THROW_HRESULT( SetStaticCloaking( pICB ) );

            SafeRelease( m_NotifyPointer );

            m_NotifyPointer = pICB;
            }
        catch( ComError Error )
            {
            SafeRelease( pICB );
            Hr = Error.Error();
            }
        }

    LogPublicApiEnd( " " );

    return Hr;
}

IBackgroundCopyCallback1 *
COldGroupInterface::GetNotificationPointer()
{
    if (m_NotifyPointer)
        {
        m_NotifyPointer->AddRef();
        }

    return m_NotifyPointer;
}


void
COldGroupInterface::Serialize(
    HANDLE hFile
    )
{
    SafeWriteFile( hFile, m_NotifyClsid );

    if ( m_pJob->GetOldExternalJobInterface() )
        {
        SafeWriteFile( hFile, (bool)true );
        m_pJob->GetOldExternalJobInterface()->Serialize( hFile );
        }
    else
        {
        SafeWriteFile( hFile, (bool)false );
        }
    return;
}

COldGroupInterface *
COldGroupInterface::UnSerialize(
    HANDLE  hFile,
    CJob*   Job
    )
{
    COldGroupInterface * group = NULL;

    try
        {
        group = new COldGroupInterface(Job);
        if (!group)
            {
            throw ComError( E_OUTOFMEMORY );
            }

        SafeReadFile( hFile, &group->m_NotifyClsid );

        bool bHasOldExternalJobInterface;

        SafeReadFile( hFile, &bHasOldExternalJobInterface );

        if ( bHasOldExternalJobInterface )
            {
            COldJobInterface *OldJobInterface = COldJobInterface::Unserialize( hFile, Job );
            Job->SetOldExternalJobInterface( OldJobInterface );
            }

        }
    catch ( ComError Error )
        {
        delete group;
        throw;
        }

    return group;
}

COldJobInterface::COldJobInterface(
    GUID JobGuid,
    CJob *pJob ) :
    m_refs(1),
    m_ServiceInstance( g_ServiceInstance ),
    m_OldJobGuid( JobGuid ),
    m_pJob( pJob ),
    m_pJobExternal( pJob->GetExternalInterface() )
{
    m_pJobExternal->AddRef();
}

COldJobInterface::~COldJobInterface()
{
    m_pJobExternal->Release();
}

STDMETHODIMP
COldJobInterface::QueryInterface(
    REFIID iid,
    void** ppvObject
    )
{
    BEGIN_EXTERNAL_FUNC

    LogPublicApiBegin( "iid %!guid!, ppvObject %p", &iid, ppvObject );
    HRESULT Hr = S_OK;
    *ppvObject = NULL;

    if ((iid == _uuidof(IUnknown)) || (iid == __uuidof(IBackgroundCopyJob1)) )
        {
        *ppvObject = (IBackgroundCopyJob1 *)this;
        ((IUnknown *)(*ppvObject))->AddRef();
        }
    else
        {
        Hr = E_NOINTERFACE;
        }

    LogPublicApiEnd( "iid %!guid!, ppvObject %p", &iid, ppvObject );
    return Hr;

    END_EXTERNAL_FUNC
}

ULONG _stdcall
COldJobInterface::AddRef(void)
{
    BEGIN_EXTERNAL_FUNC

    ULONG newrefs = InterlockedIncrement(&m_refs);

    LogRef( "job %p, refs = %d", m_pJob, newrefs );

    return newrefs;

    END_EXTERNAL_FUNC
}

ULONG _stdcall
COldJobInterface::Release(void)
{
    BEGIN_EXTERNAL_FUNC

    ULONG newrefs = InterlockedDecrement(&m_refs);

    LogRef( "job %p, refs = %d", m_pJob, newrefs );

    if (newrefs == 0)
        {
        delete this;
        }

    return newrefs;

    END_EXTERNAL_FUNC
}


STDMETHODIMP
COldJobInterface::AddFilesInternal(
    ULONG cFileCount,
    FILESETINFO **ppFileSet
    )
{
    HRESULT Hr = S_OK;
    CLockedJobWritePointer LockedJob(m_pJob);
    LogPublicApiBegin( "cFileCount %u, ppFileSet %p", cFileCount, ppFileSet );

    BG_FILE_INFO *pFileInfo = NULL;

    try
    {
        ASSERT( ppFileSet );

        THROW_HRESULT( LockedJob.ValidateAccess() );

        pFileInfo = new BG_FILE_INFO[cFileCount];
        if (!pFileInfo )
            {
            throw ComError(E_OUTOFMEMORY);
            }

        for(ULONG c = 0; c < cFileCount; c++ )
            {
            if ( !ppFileSet[c])
                throw ComError(E_INVALIDARG);

            // BSTRS act like WCHAR *
            pFileInfo[c].LocalName  = LPWSTR( (ppFileSet[c])->bstrLocalFile );
            pFileInfo[c].RemoteName = LPWSTR( (ppFileSet[c])->bstrRemoteFile );

            }

        THROW_HRESULT( LockedJob->AddFileSet( cFileCount,
                                              pFileInfo ) );

    }
    catch(ComError Error )
    {
        Hr = Error.Error();
    }

    // Should handle NULL
    delete[] pFileInfo;

    LogPublicApiEnd( "cFileCount %u, ppFileSet %p", cFileCount, ppFileSet );
    return Hr;
}

STDMETHODIMP
COldJobInterface::GetFileCountInternal(
    DWORD * pCount
    )
{
    HRESULT Hr = S_OK;
    CLockedJobReadPointer LockedJob(m_pJob);
    LogPublicApiBegin( "pCount %p", pCount );

    try
    {
        ASSERT( pCount );

        THROW_HRESULT( LockedJob.ValidateAccess() );

        BG_JOB_PROGRESS JobProgress;
        LockedJob->GetProgress( &JobProgress );

        *pCount = JobProgress.FilesTotal;

    }
    catch(ComError Error )
    {
        Hr = Error.Error();
        *pCount = 0;
    }

    LogPublicApiEnd( "pCount %p", pCount );
    return Hr;

}

STDMETHODIMP
COldJobInterface::GetFileInternal(
    ULONG cFileIndex,
    FILESETINFO *pFileInfo
    )
{
    HRESULT Hr = S_OK;
    CLockedJobReadPointer LockedJob(m_pJob);
    LogPublicApiBegin( "cFileIndex %u, pFileInfo %p", cFileIndex, pFileInfo );

    WCHAR *pLocalName = NULL;
    WCHAR *pRemoteName = NULL;
    try
        {

        ASSERT( pFileInfo );
        memset( pFileInfo, 0, sizeof(FILESETINFO) );

        THROW_HRESULT( LockedJob.ValidateAccess() );

        CFile *pFile = LockedJob->_GetFileIndex( cFileIndex );
        if (!pFile)
            throw ComError ( QM_E_ITEM_NOT_FOUND );


        THROW_HRESULT( pFile->GetLocalName( &pLocalName ) );
        THROW_HRESULT( pFile->GetRemoteName( &pRemoteName ) );

        pFileInfo->bstrLocalFile = SysAllocString( pLocalName );
        pFileInfo->bstrRemoteFile = SysAllocString( pRemoteName );

        if ( !pFileInfo->bstrLocalFile ||
             !pFileInfo->bstrRemoteFile )
            throw ComError( E_OUTOFMEMORY );

        BG_FILE_PROGRESS FileProgress;
        pFile->GetProgress( &FileProgress );

        pFileInfo->dwSizeHint = NewJobSizeToOldSize( FileProgress.BytesTotal );

        }
    catch ( ComError Error )
        {
        Hr = Error.Error();

        if ( pFileInfo )
            {
            SysFreeString( pFileInfo->bstrLocalFile );
            SysFreeString( pFileInfo->bstrRemoteFile );
            memset( pFileInfo, 0, sizeof(FILESETINFO) );
            }
        }

    // CoTaskMemFree handles NULL
    CoTaskMemFree( pLocalName );
    CoTaskMemFree( pRemoteName );

    LogPublicApiEnd( "cFileIndex %u, pFileInfo %p", cFileIndex, pFileInfo );
    return Hr;
}

STDMETHODIMP
COldJobInterface::CancelJobInternal()
{
    HRESULT Hr = E_NOTIMPL;
    LogPublicApiBegin( "void" );
    LogPublicApiEnd( "void" );
    return Hr;
}


STDMETHODIMP
COldJobInterface::get_JobIDInternal(
    GUID * pId
    )
{
    HRESULT Hr = S_OK;
    CLockedJobReadPointer LockedJob(m_pJob);
    LogPublicApiBegin( "pId %p", pId );

    try
    {
        ASSERT( pId );
        THROW_HRESULT( LockedJob.ValidateAccess() );

        *pId = GetOldJobId();
    }
    catch(ComError Error )
    {
        Hr = Error.Error();
        memset( pId, 0, sizeof(*pId) );
    }

    LogPublicApiEnd( "pId %p", pId );
    return Hr;
}



STDMETHODIMP
COldJobInterface::GetProgressInternal(
    DWORD flags,
    DWORD * pProgress
    )
{
    HRESULT Hr = S_OK;
    CLockedJobReadPointer LockedJob(m_pJob);
    LogPublicApiBegin( "flags %u, pProgress %p", flags, pProgress );

    try
    {

        ASSERT( pProgress );
        *pProgress = NULL;

        THROW_HRESULT( LockedJob.ValidateAccess() );

        BG_JOB_PROGRESS JobProgress;
        LockedJob->GetProgress( &JobProgress );

        switch (flags)
            {
            case QM_PROGRESS_SIZE_DONE:
                {

                *pProgress = NewJobSizeToOldSize( JobProgress.BytesTransferred );
                break;
                }

            case QM_PROGRESS_PERCENT_DONE:
                {

                if ( ( -1 == JobProgress.BytesTotal ) ||
                     ( -1 == JobProgress.BytesTransferred ) ||
                     ( 0 == JobProgress.BytesTotal ) )
                    {
                    *pProgress = 0;
                    }
                else
                    {
                    double ratio = double(JobProgress.BytesTransferred) / double(JobProgress.BytesTotal );
                    *pProgress = DWORD( ratio * 100.0 );
                    }
                break;
                }

            default:
                {
                throw ComError( E_NOTIMPL );
                }
            }

    }
    catch( ComError Error )
    {
        Hr = Error.Error();
    }

    LogPublicApiEnd( "flags %u, pProgress %p", flags, pProgress );
    return Hr;
}

STDMETHODIMP
COldJobInterface::SwitchToForegroundInternal()
{

    HRESULT Hr = S_OK;
    CLockedJobWritePointer LockedJob(m_pJob);
    LogPublicApiBegin( "void" );

    try
    {
        THROW_HRESULT( LockedJob.ValidateAccess() );
        Hr = E_NOTIMPL;
    }
    catch( ComError Error )
    {
        Hr = Error.Error();
    }

    LogPublicApiEnd( "void" );
    return Hr;
}

STDMETHODIMP
COldJobInterface::GetStatusInternal(
    DWORD *pdwStatus,
    DWORD *pdwWin32Result,
    DWORD *pdwTransportResult,
    DWORD *pdwNumOfRetries
    )
{

    HRESULT Hr = S_OK;
    CLockedJobReadPointer LockedJob(m_pJob);
    LogPublicApiBegin( "pdwStatus %p, pdwWin32Result %p, pdwTransportResult %p, pdwNumOfRetries %p",
                       pdwStatus, pdwWin32Result, pdwTransportResult, pdwNumOfRetries );

    try
    {
        ASSERT( pdwStatus && pdwWin32Result &&
                pdwTransportResult && pdwNumOfRetries );

        *pdwStatus = *pdwWin32Result = *pdwTransportResult = *pdwNumOfRetries = 0;

        THROW_HRESULT( LockedJob.ValidateAccess() );

        BG_JOB_PRIORITY Priority = LockedJob->_GetPriority();
        BG_JOB_STATE State       = LockedJob->_GetState();

        THROW_HRESULT( LockedJob->GetErrorCount( pdwNumOfRetries ) );

        if ( BG_JOB_PRIORITY_FOREGROUND == Priority )
            *pdwStatus |= QM_STATUS_JOB_FOREGROUND;

        switch( State )
            {
            case BG_JOB_STATE_QUEUED:
            case BG_JOB_STATE_CONNECTING:
            case BG_JOB_STATE_TRANSFERRING:
                *pdwStatus |= QM_STATUS_JOB_INCOMPLETE;
                break;
            case BG_JOB_STATE_SUSPENDED:
                *pdwStatus |= QM_STATUS_JOB_INCOMPLETE;
                break;
            case BG_JOB_STATE_ERROR:
                *pdwStatus |= QM_STATUS_JOB_ERROR;
                break;
            case BG_JOB_STATE_TRANSIENT_ERROR:
                *pdwStatus |= QM_STATUS_JOB_INCOMPLETE;
                break;
            case BG_JOB_STATE_TRANSFERRED:
                *pdwStatus |= QM_STATUS_JOB_COMPLETE;
                break;
            case BG_JOB_STATE_ACKNOWLEDGED:
                *pdwStatus |= QM_STATUS_JOB_COMPLETE;
                break;
            case BG_JOB_STATE_CANCELLED:
                break;
            default:
                ASSERT(0);
                break;
            }

        if ( BG_JOB_STATE_ERROR == State )
            {

            const CJobError * pError = LockedJob->GetError();

            ASSERT( pError );

            if ( pError )
                {
                pError->GetOldInterfaceErrors( pdwWin32Result, pdwTransportResult );
                }

            }

    }
    catch( ComError Error )
    {
        Hr = Error.Error();

        *pdwStatus = 0;
        *pdwWin32Result = 0;
        *pdwTransportResult = 0;
        *pdwNumOfRetries = 0;
    }

    LogPublicApiEnd( "pdwStatus %p, pdwWin32Result %p, pdwTransportResult %p, pdwNumOfRetries %p",
                     pdwStatus, pdwWin32Result, pdwTransportResult, pdwNumOfRetries );
    return Hr;
}

void
COldJobInterface::Serialize(
    HANDLE hFile
    )
{
    SafeWriteFile( hFile, m_OldJobGuid );
}

COldJobInterface *
COldJobInterface::Unserialize(
    HANDLE  hFile,
    CJob*   Job
    )
{
    COldJobInterface * OldJob = NULL;

    try
        {
        GUID OldJobGuid;
        SafeReadFile( hFile, &OldJobGuid );
        OldJob = new COldJobInterface( OldJobGuid, Job );
        if (!OldJob)
            {
            throw ComError( E_OUTOFMEMORY );
            }
        }
    catch ( ComError Error )
        {
        delete OldJob;
        throw;
        }

    return OldJob;
}

COldQmgrInterface::COldQmgrInterface() :
    m_refs(1),
    m_ServiceInstance( g_ServiceInstance )
{
}


STDMETHODIMP
COldQmgrInterface::QueryInterface(
    REFIID iid,
    void** ppvObject
    )
{
    BEGIN_EXTERNAL_FUNC

    LogPublicApiBegin( "iid %!guid!, ppvObject %p", &iid, ppvObject );
    HRESULT Hr = S_OK;
    *ppvObject = NULL;

    if ((iid == _uuidof(IUnknown)) || (iid == __uuidof(IBackgroundCopyQMgr)) )
        {
        *ppvObject = (IBackgroundCopyQMgr *)this;
        ((IUnknown *)(*ppvObject))->AddRef();
        }
    else if ( iid == __uuidof(IClassFactory) )
        {
        *ppvObject = (IClassFactory *)this;
        ((IUnknown *)(*ppvObject))->AddRef();
        }
    else
        {
        Hr = E_NOINTERFACE;
        }

    LogPublicApiEnd( "iid %!guid!, ppvObject %p", &iid, ppvObject );
    return Hr;

    END_EXTERNAL_FUNC
}

ULONG _stdcall
COldQmgrInterface::AddRef(void)
{
    BEGIN_EXTERNAL_FUNC

    ULONG newrefs = InterlockedIncrement(&m_refs);

    LogRef( "new refs = %d", newrefs );

    return newrefs;

    END_EXTERNAL_FUNC
}

ULONG _stdcall
COldQmgrInterface::Release(void)
{
    BEGIN_EXTERNAL_FUNC

    ULONG newrefs = InterlockedDecrement(&m_refs);

    LogRef( "new refs = %d", newrefs );

    if (newrefs == 0)
        {
        delete this;
        }

    return newrefs;

    END_EXTERNAL_FUNC
}

STDMETHODIMP
COldQmgrInterface::CreateInstance(
    IUnknown * pUnkOuter,
    REFIID riid,
    void ** ppvObject )
{

    BEGIN_EXTERNAL_FUNC

    HRESULT hr = S_OK;

    if (g_ServiceInstance != m_ServiceInstance ||
        g_ServiceState    != MANAGER_ACTIVE)
        {
        hr = CO_E_SERVER_STOPPING;
        }
    else if (pUnkOuter != NULL)
    {
        hr = CLASS_E_NOAGGREGATION;
    }
    else
    {
        if ((riid == IID_IBackgroundCopyQMgr) || (riid == IID_IUnknown))
        {
            hr = QueryInterface(riid, ppvObject);
        }
        else
        {
            // BUGBUG why this error coed?
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;

    END_EXTERNAL_FUNC

}

STDMETHODIMP
COldQmgrInterface::LockServer(
    BOOL fLock
    )
{
    BEGIN_EXTERNAL_FUNC

    return GlobalLockServer( fLock );

    END_EXTERNAL_FUNC
}

STDMETHODIMP
COldQmgrInterface::CreateGroupInternal(
    GUID id,
    IBackgroundCopyGroup **ppGroup
    )
{
    HRESULT Hr = S_OK;
    CLockedJobManagerWritePointer LockedJobManager( m_pJobManager );
    LogPublicApiBegin( "id %!guid!", &id );

    CJob *job = NULL;

    //
    // create the job
    //
    try
        {

        THROW_HRESULT( LockedJobManager.ValidateAccess() );

        ASSERT( ppGroup );

        const WCHAR *DisplayName = L"";
        CLSID *CallbackClass = NULL;
        BG_JOB_TYPE Type = BG_JOB_TYPE_DOWNLOAD;

        THROW_HRESULT( LockedJobManager->CreateJob( DisplayName,
                                                    Type,
                                                    id,
                                                    GetThreadClientSid(),
                                                    &job,
                                                    true
                                                    ));

        THROW_HRESULT( job->SetNotifyFlags( MapOldNotifyToNewNotify(0) ) );

        *ppGroup = ( IBackgroundCopyGroup * )job->GetOldExternalGroupInterface();
        ASSERT( *ppGroup );

        (*ppGroup)->AddRef();

        }

    catch( ComError exception )
        {
        Hr = exception.Error();

        if ( job )
            job->Cancel();
        }

    LogPublicApiEnd( "id %!guid!, group %p", &id, *ppGroup );
    return Hr;
}


STDMETHODIMP
COldQmgrInterface::GetGroupInternal(
    GUID id,
    IBackgroundCopyGroup ** ppGroup
    )
{
    HRESULT Hr = S_OK;
    CLockedJobManagerWritePointer LockedJobManager( m_pJobManager );
    LogPublicApiBegin( "id %!guid!", &id );

    CJob *pJob = NULL;

    try
    {
        ASSERT( ppGroup );
        *ppGroup = NULL;

        THROW_HRESULT( LockedJobManager.ValidateAccess() );

        Hr = LockedJobManager->GetJob( id, &pJob );

        if (FAILED(Hr))
            {
            if (Hr == BG_E_NOT_FOUND)
                {
                Hr = QM_E_ITEM_NOT_FOUND;
                }

            throw ComError( Hr );
            }

        COldGroupInterface *pOldGroup = pJob->GetOldExternalGroupInterface();
        if ( !pOldGroup )
            throw ComError( QM_E_ITEM_NOT_FOUND );

        // try to take ownership of the job/group
        // this should suceed even if we are the current owner

        THROW_HRESULT( pJob->AssignOwnership( GetThreadClientSid() ) );

        pOldGroup->AddRef();

        *ppGroup = (IBackgroundCopyGroup*)pOldGroup;
    }
    catch( ComError Error )
    {
        Hr = Error.Error();
    }

    LogPublicApiEnd( "id %!guid!, group %p", &id, *ppGroup );
    return Hr;

}

STDMETHODIMP
COldQmgrInterface::EnumGroupsInternal(
    DWORD flags,
    IEnumBackgroundCopyGroups **ppEnum
    )
{

    HRESULT Hr = S_OK;
    CLockedJobManagerWritePointer LockedJobManager( m_pJobManager );
    LogPublicApiBegin( "flags %u, ppEnum %p", flags, ppEnum );

    CEnumOldGroups *pEnum = NULL;

    try
    {

        ASSERT( ppEnum );
        *ppEnum = NULL;

        THROW_HRESULT( LockedJobManager.ValidateAccess() );

        if (flags)
            {
            LogWarning( "rejecting nonzero dwFlags");
            throw ComError( E_NOTIMPL );
            }

        pEnum = new CEnumOldGroups;

        for (CJobList::iterator iter = LockedJobManager->m_OnlineJobs.begin();
             iter != LockedJobManager->m_OnlineJobs.end();
             ++iter)
            {

            Hr = (*iter).IsVisible();
            if (FAILED(Hr))
                {
                throw ComError( Hr );
                }

            if (Hr == S_FALSE)
                {
                continue;
                }

            // Skip jobs that were not created with the old interface.
            if (!(*iter).GetOldExternalGroupInterface())
                {
                continue;
                }

            GUID guid = (*iter).GetId();
            pEnum->Add( guid );
            }

        *ppEnum = pEnum;
    }
    catch( ComError Error )
    {
        Hr = Error.Error();
        delete pEnum;
    }

    LogPublicApiEnd( "flags %u, ppEnum %p", flags, ppEnum );
    return Hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\newjob\init.cpp ===
#include "stdafx.h"

#if !defined(BITS_V12_ON_NT4)
#include "init.tmh"
#endif

BOOL
CreateAndWaitForThread(
    LPTHREAD_START_ROUTINE fn,
    HANDLE * pThreadHandle,
    DWORD *  pThreadId
    );



//
// The whole block of code is an attempt to work
// around the C++ termination handler.   The idea is to
// intercept the C++ exception code and map it to
// a bogus code which probably won't be handled.
// This should give us the Dr. Watson.
//

// The NT exception # used by C runtime
#define EH_EXCEPTION_NUMBER ('msc' | 0xE0000000)

DWORD BackgroundThreadProcFilter(
    LPEXCEPTION_POINTERS ExceptionPointers )
{

    //  Values are 32 bit values layed out as follows:
    //
    //   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
    //   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
    //  +---+-+-+-----------------------+-------------------------------+
    //  |Sev|C|R|     Facility          |               Code            |
    //  +---+-+-+-----------------------+-------------------------------+

    //  pick a random code that probably won't be handled.


    if ( EH_EXCEPTION_NUMBER == ExceptionPointers->ExceptionRecord->ExceptionCode )
        ExceptionPointers->ExceptionRecord->ExceptionCode = 0xE0000001;

    return EXCEPTION_CONTINUE_SEARCH;
}

DWORD BackgroundThreadProc( void *lp );

DWORD WINAPI BackgroundThreadProcWrap( void *lp )
{
    __try
    {
        return BackgroundThreadProc( lp );
    }
    __except( BackgroundThreadProcFilter(
                  GetExceptionInformation() ) )
    {
        ASSERT( 0 );
    }
    ASSERT( 0 );

    return 0;
}


DWORD BackgroundThreadProc( void *lp )
//
// 5-18-2001: I'm avoiding LogInfo calls before g_Manager is initialized,
//            in order to catch a bug where init and Uninit seem to overlap.
//
{
    MSG msg;
    HRESULT hr = S_OK;
    DWORD   dwRegCONew = 0;
    DWORD   dwRegCOOld = 0;

    DWORD  instance = g_ServiceInstance;

    HANDLE hEvent = (HANDLE) lp;

    //CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);   //not on Win95!
    //hr = CoInitialize(NULL);
    hr = CoInitializeEx( NULL, COINIT_MULTITHREADED );
    if (FAILED(hr))
        {
        LogInfo( "background thread failed CoInit, instance %d, hr %x", instance, hr );

        return hr;
        }

    //force it to create a msg queue
    PeekMessage(&msg, NULL, WM_APP, WM_APP, PM_NOREMOVE);

    try
        {
        ASSERT( g_Manager == NULL );

        g_Manager = new CJobManager;

        LogInfo( "background thread starting, instance %d, manager %p", instance, g_Manager );

        THROW_HRESULT( g_Manager->Unserialize() );

        //
        // List currently active users as logged in.
        // List the Big Three service accounts as logged in.
        //
        THROW_HRESULT( g_Manager->m_Users.AddActiveUsers() );
        THROW_HRESULT( g_Manager->m_Users.AddServiceAccounts() );

        g_Manager->m_Users.Dump();

        //
        // If any networks are active, begin processing jobs.
        //
        g_Manager->OnNetworkChange();

        //
        // Allow client calls.
        //
        THROW_HRESULT( g_Manager->RegisterClassObjects() );


        LogInfo( "Background thread initialized.");

        //
        // The thread has set up completely.
        //
        SetEvent( hEvent );
        }
    catch (ComError exception)
        {
        hr = exception.Error();
        LogInfo( "background thread failed, instance %d, hr %x", instance, hr );
        goto exit;
        }
    catch (HRESULT exception )
        {
        LogError( "init : caught unhandled HRESULT %x", exception);

        #ifdef DBG
        DbgBreakPoint();
        #endif

        hr = exception;
        goto exit;
        }
    catch (DWORD exception )
        {
        LogError( "init : caught unhandled error %d", exception);

        #ifdef DBG


        DbgBreakPoint();
        #endif

        hr = exception;

        goto exit;

        }

    //
    // Message & task pump: returns only when the object shuts down.
    // Intentionally, call this function outside of a try/catch
    // since any unhandled exception in this function should
    // be an AV.
    g_Manager->TaskThread();

exit:
    LogInfo("task thread exiting, hr %x", hr);

    if (g_Manager)
        {
        ASSERT( instance == g_ServiceInstance );

        g_Manager->Shutdown();
        delete g_Manager;
        g_Manager = NULL;
        }

    CoUninitialize();
    return hr;
}

HANDLE  g_hBackgroundThread;
DWORD   g_dwBackgroundThreadId;

// void TestImpersonationObjects();

HRESULT WINAPI
InitQmgr()
{
    ++g_ServiceInstance;

    if (!CreateAndWaitForThread( BackgroundThreadProcWrap,
                                 &g_hBackgroundThread,
                                 &g_dwBackgroundThreadId
                                 ))
        {
        return HRESULT_FROM_WIN32( GetLastError() );
        }

    LogInfo( "Finishing InitQmgr()" );

    return S_OK;
}

HRESULT WINAPI
UninitQmgr()
{
    DWORD s;
    HANDLE hThread = g_hBackgroundThread;

    if (hThread == NULL)
        {
        // never set up
        LogInfo("Uninit Qmgr: nothing to do");
        return S_OK;
        }

    LogInfo("Uninit Qmgr: beginning");

    //
    // Tell the thread to terminate.
    //
    // 3.5 interrupt the downloader.

    g_Manager->LockWriter();

    // Hold the writer lock while killing the downloader.

    g_Manager->InterruptDownload();

    g_Manager->UnlockWriter();

    PostThreadMessage(g_dwBackgroundThreadId, WM_QUIT, 0, 0);

    g_dwBackgroundThreadId = 0;
    g_hBackgroundThread = NULL;

    //
    // Wait until the thread actually terminates.
    //
    s = WaitForSingleObject( hThread, INFINITE );

    LogInfo("Uninit Qmgr: wait finished with %d", s);

    CloseHandle(hThread);

    if (s != WAIT_OBJECT_0)
        {
        return HRESULT_FROM_WIN32( s );
        }

    return S_OK;
}


HRESULT
CheckServerInstance(
    long ObjectServiceInstance
    )
{
    IncrementCallCount();

    if (g_ServiceInstance != ObjectServiceInstance ||
        g_ServiceState    != MANAGER_ACTIVE)
        {
        LogWarning("call blocked: mgr state %d, instance %d vs. %d",
                   g_ServiceState, g_ServiceInstance, ObjectServiceInstance);

        DecrementCallCount();

        return CO_E_SERVER_STOPPING;
        }

    return S_OK;
}

BOOL
CreateAndWaitForThread(
    LPTHREAD_START_ROUTINE fn,
    HANDLE * pThreadHandle,
    DWORD *  pThreadId
    )
{
    HANDLE  hThread = NULL;
    HANDLE  hEvent  = NULL;
    HANDLE  Handles[2];
    DWORD   dwThreadID;
    DWORD   s = 0;

    *pThreadHandle = NULL;
    *pThreadId     = 0;

    //
    // Create the message-pump thread, then wait for the thread to exit or to signal success.
    //
    hEvent = CreateEvent( NULL,     // no security
                          FALSE,    // not manual reset
                          FALSE,    // initially not set
                          NULL
                          );
    if (!hEvent)
        {
        goto Cleanup;
        }

    hThread = CreateThread(NULL, 0, fn, PVOID(hEvent), 0, &dwThreadID);
    if (hThread == NULL)
        {
        goto Cleanup;
        }

    enum
    {
        THREAD_INDEX = 0,
        EVENT_INDEX = 1
    };

    Handles[ THREAD_INDEX ] = hThread;
    Handles[ EVENT_INDEX ] = hEvent;

    s = WaitForMultipleObjects( 2,          // 2 handles
                                Handles,
                                FALSE,      // don't wait for all
                                INFINITE
                                );
    switch (s)
        {
        case WAIT_OBJECT_0 + THREAD_INDEX:
            {
            // the thread exited.
            if (GetExitCodeThread( hThread, &s))
                {
                SetLastError( s );
                }
            goto Cleanup;
            }

        case WAIT_OBJECT_0 + EVENT_INDEX:
            {
            // success
            break;
            }

        default:
            {
            // some random error.  We are really toasted if
            // WaitForMultipleObjects is failing.
            ASSERT(0);
            goto Cleanup;
            }
        }

    CloseHandle( hEvent );
    hEvent = NULL;

    *pThreadHandle = hThread;
    *pThreadId     = dwThreadID;

    return TRUE;

Cleanup:


    if (hThread)
        {
        CloseHandle( hThread );
        }

    if (hEvent)
        {
        CloseHandle( hEvent );
        }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\newjob\logontable.cpp ===
/************************************************************************

Copyright (c) 2000 - 2000 Microsoft Corporation

Module Name :

    logontable.cpp

Abstract :

    Source file for the logon table.

Author :

Revision History :

 ***********************************************************************/


#include "stdafx.h"

#include <winsta.h>
#include <wtsapi32.h>
#include <userenv.h>

#if !defined(BITS_V12_ON_NT4)
#include "logontable.tmh"
#endif

HRESULT DetectTerminalServer( bool * pfTS );

HRESULT
GetUserToken(
    ULONG LogonId,
    PHANDLE pUserToken
    );

HRESULT
WaitForUserToken(
    DWORD session,
    HANDLE * pToken
    )
{
    const MaxWait = 30 * 1000;
    const WaitInterval = 500;

    long StartTime = GetTickCount();

    HRESULT Hr = E_FAIL;

    do
        {

        Hr = GetUserToken( session, pToken );

        if ( SUCCEEDED( Hr ) )
            return Hr;

        LogError("logon : unable to get token : %!winerr!", Hr );

        Sleep( WaitInterval );
        }
    while ( GetTickCount() - StartTime < MaxWait );

    return Hr;
}

CLoggedOnUsers::CLoggedOnUsers(
    TaskScheduler & sched
    ) : m_TaskScheduler( sched ),
    m_SensNotifier( NULL )
{
    FILETIME time;
    GetSystemTimeAsFileTime( &time );

    m_CurrentCookie = time.dwLowDateTime;

    if ( WINDOWS2000_PLATFORM == g_PlatformVersion )
        {
        try
            {
            bool fTS;

            THROW_HRESULT( DetectTerminalServer( &fTS ));

            if (fTS)
                {
                m_SensNotifier = new CTerminalServerLogonNotification;
                LogInfo( "TS-enabled SENS notification activated" );
                }
            else
                {
                m_SensNotifier = new CLogonNotification;
                LogInfo( "regular SENS notification activated" );
                }
            }
        catch( ComError Error )
            {
            if ( Error.Error() == TYPE_E_CANTLOADLIBRARY ||
                 Error.Error() == TYPE_E_LIBNOTREGISTERED )
                {
                LogInfo( "SENS doesn't exist on this platform, skipping" );
                return;
                }
            else
                {
                LogInfo("SENS object failed with %x", Error.Error() );
                throw;
                }
            }
        }
}

CLoggedOnUsers::~CLoggedOnUsers()
{
    if (m_SensNotifier)
        {
        m_SensNotifier->DeRegisterNotification();
        m_SensNotifier->Release();
        }
}


HRESULT
CLoggedOnUsers::LogonSession(
    DWORD session
    )
{
    CUser * user = NULL;

    try
        {
        HANDLE Token = NULL;
        auto_HANDLE<NULL> AutoToken;

        //
        // Get the user's token and SID, then create a user object.
        //
        THROW_HRESULT( WaitForUserToken( session, &Token ));

        ASSERT( Token ); // Token can't be NULL

        AutoToken = Token;

        user = new CUser( Token );

        //
        // Add the user to our by-session and by-SID indexes.
        //
        HoldWriterLock lock ( m_TaskScheduler );

        try
            {
            // Just in case...delete any previously recorded user.
            //
            LogoffSession( session );

            //
            // Subtlety: if the node for m_ActiveSessions[ session ] doesn't exist,
            // then the first reference to it will cause a node to be allocated.  This may
            // throw E_OUTOFMEMORY.
            //
            m_ActiveSessions[ session ] = user;

            m_ActiveUsers.insert( make_pair( user->QuerySid(), user ) );
            }
        catch( ComError Error )
            {
            m_ActiveSessions.erase( session );
            throw;
            }

        Dump();

        g_Manager->UserLoggedOn( user->QuerySid() );

        return S_OK;
        }
    catch( ComError err )
        {
        delete user;

        LogError("logon : returning error 0x%x", err.Error() );
        Dump();
        return err.Error();
        }
}

HRESULT
CLoggedOnUsers::LogoffSession(
    DWORD session
    )
{
    try
        {
        HoldWriterLock lock ( m_TaskScheduler );

        CUser * user = m_ActiveSessions[ session ];

        if (!user)
            return S_OK;

        bool b = m_ActiveUsers.RemovePair( user->QuerySid(), user );

        ASSERT( b );

        m_ActiveSessions.erase( session );

        Dump();

        if (false == g_Manager->IsUserLoggedOn( user->QuerySid() ))
            {
            g_Manager->UserLoggedOff( user->QuerySid() );
            }

        user->DecrementRefCount();

        return S_OK;
        }
    catch( ComError err )
        {
        LogWarning("logoff : exception 0x%x thrown", err.Error());
        Dump();
        return err.Error();
        }
}

CUser *
CLoggedOnUsers::CUserList::FindSid(
    SidHandle sid
    )
{
    iterator iter = find( sid );

    if (iter == end())
        {
        return NULL;
        }

    return iter->second;
}


bool
CLoggedOnUsers::CUserList::RemovePair(
    SidHandle sid,
    CUser * user
    )
{
    //
    // Find the user in the user list and delete it.
    //
    pair<iterator, iterator> b = equal_range( sid );

    for (iterator i = b.first; i != b.second; ++i)
        {
        if (i->second == user)
            {
            erase( i );
            return true;
            }
        }

    return false;
}

CUser *
CLoggedOnUsers::CUserList::RemoveByCookie(
    SidHandle sid,
    DWORD cookie
    )
{
    //
    // Find the user in the user list and delete it.
    //
    pair<iterator, iterator> b = equal_range( sid );

    for (iterator i = b.first; i != b.second; ++i)
        {
        CUser * user = i->second;

        if (user->GetCookie() == cookie)
            {
            erase( i );
            return user;
            }
        }

    return NULL;
}

HRESULT
CLoggedOnUsers::LogonService(
    HANDLE Token,
    DWORD * pCookie
    )
{
    CUser * user = NULL;

    try
        {
        user = new CUser( Token );

        *pCookie = InterlockedIncrement( &m_CurrentCookie );

        user->SetCookie( *pCookie );

        HoldWriterLock lock ( m_TaskScheduler );

        m_ActiveServiceAccounts.insert( make_pair( user->QuerySid(), user ));

        return S_OK;
        }
    catch( ComError err )
        {
        delete user;

        LogError("logon service : returning error 0x%x", err.Error() );
        return err.Error();
        }
}


HRESULT
CLoggedOnUsers::LogoffService(
    SidHandle Sid,
    DWORD  Cookie
    )
{
    try
        {
        HoldWriterLock lock ( m_TaskScheduler );

        CUser * user = m_ActiveServiceAccounts.RemoveByCookie( Sid, Cookie );

        if (!user)
            {
            LogWarning("logoff : invalid cookie %d", Cookie);
            return E_INVALIDARG;
            }

        user->DecrementRefCount();

        return S_OK;
        }
    catch( ComError err)
        {
        LogWarning("logoff : exception 0x%x thrown", err.Error());
        return err.Error();
        }
}

HRESULT
CLoggedOnUsers::AddServiceAccounts()
{
    HRESULT hr = S_OK;
    DWORD ignore;

    HoldWriterLock lock ( m_TaskScheduler );

    //
    // Add the LOCAL_SYSTEM account.
    //
    HANDLE Token;
    if (OpenProcessToken( GetCurrentProcess(), TOKEN_QUERY | TOKEN_DUPLICATE, &Token ))
        {
        hr = LogonService( Token, &ignore );
        CloseHandle( Token );
        }
    else
        {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        }

    if (FAILED(hr))
        {
        LogWarning( "failed to register LocalSystem : %!winerr!", hr );
        return hr;
        }

    if (g_PlatformVersion >= WINDOWSXP_PLATFORM)
        {
        //
        // Add the LocalService account.
        //
        if (LogonUser( L"LocalService",
                        L"NT AUTHORITY",
                        L"",
                        LOGON32_LOGON_SERVICE,
                        LOGON32_PROVIDER_DEFAULT,
                        &Token))
            {
            hr = LogonService( Token, &ignore );
            CloseHandle( Token );
            }
        else
            {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            }

        if (FAILED(hr))
            {
            LogWarning( "failed to register LocalService : %!winerr!", hr );
            if ( HRESULT_FROM_WIN32( ERROR_LOGON_FAILURE ) == hr )
               LogWarning( "LocalService doesn't exist, skip it.\n");
            else
               return hr;
            }

        //
        // Add the NetworkService account.
        //
        if (LogonUser( L"NetworkService",
                        L"NT AUTHORITY",
                        L"",
                        LOGON32_LOGON_SERVICE,
                        LOGON32_PROVIDER_DEFAULT,
                        &Token))
            {
            hr = LogonService( Token, &ignore );
            CloseHandle( Token );
            }
        else
            {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            }

        if (FAILED(hr))
            {
            LogWarning( "failed to register NetworkService : %!winerr!", hr );
            if ( HRESULT_FROM_WIN32( ERROR_LOGON_FAILURE ) == hr )
               LogWarning( "NetworkService doesn't exist, skip it.\n");
            else
               return hr;
            }
        }

    //
    // done
    //
    return S_OK;
}

HRESULT
CLoggedOnUsers::AddActiveUsers()
{
    HRESULT hr = S_OK;
    WTS_SESSION_INFO * SessionInfo = 0;

    HANDLE Token;

    HoldWriterLock lock ( m_TaskScheduler );

    //
    // Get the console token, if any, without using Terminal Services.
    //
    if ( SUCCEEDED( GetUserToken( 0, &Token) ) )
        {
        CloseHandle( Token );

        hr = LogonSession( 0 );
        if (FAILED(hr))
            {
            // ignore it and try to carry on...
            LogWarning( "service : unable to logon session zero : %!winerr!", hr );
            }
        }

#if !defined( BITS_V12_ON_NT4 )

    //
    // The call may return FALSE, because Terminal Services is not always loaded.
    //
    DWORD SessionCount = 0;

    BOOL b = WTSEnumerateSessions( WTS_CURRENT_SERVER_HANDLE,
                                   0,                   // reserved
                                   1,                   // version 1 is the only supported v.
                                   &SessionInfo,
                                   &SessionCount
                                   );

    if (b)
        {
        int i;
        for (i=0; i < SessionCount; ++i)
            {
            if (SessionInfo[i].SessionId == 0)
                {
                // console was handled by GetCurrentUserToken.
                continue;
                }

            if (SessionInfo[i].State == WTSActive ||
                SessionInfo[i].State == WTSDisconnected)
                {
                LogInfo("service : logon session %d, state %d",
                        SessionInfo[i].SessionId,
                        SessionInfo[i].State );

                hr = LogonSession( SessionInfo[i].SessionId );
                if (FAILED(hr))
                    {
                    // ignore it and try to carry on...
                    LogWarning( "service : unable to logon session %d : %!winerr!",
                                SessionInfo[i].SessionId,
                                hr );
                    }
                }
            }
        }

    if (SessionInfo)
        {
        WTSFreeMemory( SessionInfo );
        }

    //
    // Now that the current population is recorded, keep abreast of changes.
    //
    if (m_SensNotifier)
        {
        m_SensNotifier->SetEnableState( true );
        }

#endif

    return S_OK;
}

CUser *
CLoggedOnUsers::FindUser(
    SidHandle sid,
    DWORD     session
    )
{
    HoldReaderLock lock ( m_TaskScheduler );

    CUser * user = 0;

    //
    // Look for a session with the right user.
    //
    if (session == ANY_SESSION)
        {
        user = m_ActiveUsers.FindSid( sid );
        }
    else
        {
        try
            {
            user = m_ActiveSessions[ session ];

            if (user && user->QuerySid() != sid)
                {
                user = 0;
                }
            }
        catch( ComError Error )
            {
            user = 0;
            }
        }

    //
    // Look in the service account list, if the session is compatible.
    //
    if (!user && (session == 0 || session == ANY_SESSION))
        {
        user = m_ActiveServiceAccounts.FindSid( sid );
        }

    if (user)
        {
        user->IncrementRefCount();
        }

    return user;

}

void CLoggedOnUsers::Dump()
{
    HoldReaderLock lock ( m_TaskScheduler );

    LogInfo("sessions:");

    m_ActiveSessions.Dump();

    LogInfo("users:");

    m_ActiveUsers.Dump();

    LogInfo("service accounts:");

    m_ActiveServiceAccounts.Dump();
}

void CLoggedOnUsers::CSessionList::Dump()
{
    for (iterator iter = begin(); iter != end(); ++iter)
        {
        LogInfo("    session %d  user %p", iter->first, iter->second);
        }
}

void CLoggedOnUsers::CUserList::Dump()
{
    for (iterator iter = begin(); iter != end(); ++iter)
        {
        if (iter->second)
            {
            (iter->second)->Dump();
            }
        }
}

CLoggedOnUsers::CUserList::~CUserList()
{
    iterator iter;

    while ((iter=begin()) != end())
        {
        delete iter->second;

        erase( iter );
        }
}


void CUser::Dump()
{
    LogInfo( "    user at %p:", this);

    LogInfo( "          %d refs,  sid %!sid!", _ReferenceCount, _Sid.get());
}

long CUser::IncrementRefCount()
{
    long count = InterlockedIncrement( & _ReferenceCount );

    LogRef("refs %d", count);

    return count;
}

long CUser::DecrementRefCount()
{
    long count = InterlockedDecrement( & _ReferenceCount );

    LogRef("refs %d", count);

    if (0 == count)
        {
        delete this;
        }

    return count;
}

CUser::CUser(
       HANDLE Token
       )
/*++

Routine Description:

    Initializes a new CUser.

At entry:

    <Sid> points to the user's SID.
    <Token> points to the user's token.  It can be an impersonation or primary token.
    <phr> points to an error-return variable.

At exit:

    The CUser is set up.  The caller can delete <Sid> and <Token> if it wants to.

    if an error occurs, it is mapped to an HRESULT and written to <phr>.
    otherwise <*phr> is untouched and the CUser is ready for use.

--*/
{
    _ReferenceCount = 1;

    _Sid = CopyTokenSid( Token );

    //
    // Copy the token.  Whether the source is primary or impersonation,
    // the result will be a primary token.
    //
    if (!DuplicateHandle(
        GetCurrentProcess(),
        Token,
        GetCurrentProcess(),
        &_Token,
        TOKEN_ALL_ACCESS,
        FALSE,                // not inheritable
        0                     // no funny options
        ))
        {

        HRESULT HrError = HRESULT_FROM_WIN32( GetLastError() );

        LogError( "CUser: can't duplicate token %!winerr!", HrError );

        throw ComError( HrError );
        }
}

CUser::~CUser()
{
    CloseHandle( _Token );
}

HRESULT
CUser::LaunchProcess(
    StringHandle CmdLine
    )
{
    DWORD s;

    PVOID EnvironmentBlock = 0;

    PROCESS_INFORMATION ProcessInformation;
    memset( &ProcessInformation, 0, sizeof( PROCESS_INFORMATION ));

    try
        {
        STARTUPINFO si;
        memset( &si, 0, sizeof( STARTUPINFO ));
        si.cb = sizeof(STARTUPINFO);

        CAutoString WritableCmdLine ( CopyString( CmdLine ));

        LogInfo( "creating process: %S", WritableCmdLine.get() );

        if (!CreateEnvironmentBlock( &EnvironmentBlock,
                                     _Token,
                                     FALSE
                                     ))
            {
            ThrowLastError();
            }

        if (!CreateProcessAsUser( _Token,
                                  NULL,  // CmdLine contains the .exe name as well as the args
                                  WritableCmdLine.get(),
                                  0,     // no special security attributes
                                  0,     // no special thread attributes
                                  false, // don't inherit my handles
                                  NORMAL_PRIORITY_CLASS | CREATE_UNICODE_ENVIRONMENT,
                                  EnvironmentBlock,
                                  NULL,  // default current directory
                                  &si,
                                  &ProcessInformation
                                  ))
            {
            ThrowLastError();
            }

        DestroyEnvironmentBlock( EnvironmentBlock );
        EnvironmentBlock = 0;

        CloseHandle( ProcessInformation.hThread );
        ProcessInformation.hThread = 0;

        CloseHandle( ProcessInformation.hProcess );
        ProcessInformation.hProcess = 0;

        LogInfo("success, pid is 0x%x", ProcessInformation.dwProcessId);

        //
        // We succeeded.
        //
        return S_OK;
        }
    catch ( ComError err )
        {
        LogError("unable to create process, %x", err.Error() );

        if (EnvironmentBlock)
            {
            DestroyEnvironmentBlock( EnvironmentBlock );
            }

        return err.Error();
        }
}

#if ENABLE_STL_LOCK_OVERRIDE

    /*
        This file implements the STL lockit class to avoid linking to msvcprt.dll.
    */
    CCritSec CrtLock;

    #pragma warning(push)
    #pragma warning(disable:4273)  // __declspec(dllimport) attribute overridden

     std::_Lockit::_Lockit()
    {
        CrtLock.WriteLock();
    }

     std::_Lockit::~_Lockit()
    {
        CrtLock.WriteUnlock();
    }

    #pragma warning(pop)

#endif

extern "C"
{
HANDLE
GetCurrentUserTokenW(
                      WCHAR Winsta[],
                      DWORD DesiredAccess
                      );

void * __RPC_USER MIDL_user_allocate(size_t size)
{
    try
    {
        return new char[size];
    }
    catch( ComError Error )
    {
        return NULL;
    }
}

void __RPC_USER MIDL_user_free( void * block)
{
    delete block;
}


}


HRESULT
GetUserToken(
    ULONG LogonId,
    PHANDLE pUserToken
    )
{
    //
    // This gets the token of the user logged onto the WinStation
    // if we are an admin caller.
    //
    if (LogonId == 0)
        {
        // don't need the TS API.

        *pUserToken = GetCurrentUserTokenW( L"WinSta0", TOKEN_ALL_ACCESS );
        if (*pUserToken != NULL)
            {
            return S_OK;
            }

        // if not, try the TS API.
        }

    //
    // Use Terminal Services for non-console Logon IDs.
    //
    BOOL   Result;
    ULONG  ReturnLength;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjA;
    HANDLE ImpersonationToken;
    WINSTATIONUSERTOKEN Info;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;

    static PWINSTATIONQUERYINFORMATIONW pWinstationQueryInformation = 0;

    //
    // See if the entry point is loaded yet.
    //
    if (!pWinstationQueryInformation)
        {
        HMODULE module = LoadLibrary(_T("winsta.dll"));
        if (module == NULL)
            {
            HRESULT HrError = HRESULT_FROM_WIN32( GetLastError() );
            ASSERT( S_OK != HrError );
            LogInfo( "Load library of winsta failed, error %!winerr!", HrError );
            return HrError;
            }

        pWinstationQueryInformation = (PWINSTATIONQUERYINFORMATIONW) GetProcAddress( module, "WinStationQueryInformationW" );
        if (!pWinstationQueryInformation)
            {
            HRESULT HrError = HRESULT_FROM_WIN32( GetLastError() );
            ASSERT( S_OK != HrError );
            LogInfo( "GetProcAddress of WinStationQueryInformationW, error %!winerr!", HrError );
            FreeLibrary(module);
            return HrError;
            }
        }

    //
    // Ask for the token.
    //
    Info.ProcessId = UlongToHandle(GetCurrentProcessId());
    Info.ThreadId = UlongToHandle(GetCurrentThreadId());

    Result = (*pWinstationQueryInformation)(
                 SERVERNAME_CURRENT,
                 LogonId,
                 WinStationUserToken,
                 &Info,
                 sizeof(Info),
                 &ReturnLength
                 );

    if( !Result )
        {
        HRESULT HrError = HRESULT_FROM_WIN32( GetLastError() );
        ASSERT( S_OK != HrError );
        LogError("token : WinstationQueryInfo failed with %!winerr!%", HrError );
        return HrError;
        }

    //
    // The token returned is a duplicate of a primary token.
    //
    *pUserToken = Info.UserToken;

    return S_OK;
}

BOOL
SidToString(
    PSID sid,
    wchar_t buffer[],
    USHORT bytes
    )
{
    UNICODE_STRING UnicodeString;

    UnicodeString.Buffer        = buffer;
    UnicodeString.Length        = 0;
    UnicodeString.MaximumLength = bytes;

    NTSTATUS NtStatus;
    NtStatus = RtlConvertSidToUnicodeString( &UnicodeString,
                                             sid,
                                             FALSE
                                             );
    if (!NT_SUCCESS(NtStatus))
        {
        LogWarning( "RtlConvertSid failed %x", NtStatus);
        StringCbCopy( buffer, bytes, L"(conversion failed)" );
        return FALSE;
        }

    buffer[ UnicodeString.Length ] = 0;

    return TRUE;
}

HRESULT
SetStaticCloaking(
    IUnknown *pUnk
    )
{
    // Sets static cloaking on the current object so that we
    // should always impersonate the current context.
    // Also sets the impersonation level to identify.

    HRESULT Hr = S_OK;

    IClientSecurity *pSecurity = NULL;
    OLECHAR *ServerPrincName = NULL;

    try
    {
        Hr = pUnk->QueryInterface( __uuidof( IClientSecurity ),
                                             (void**)&pSecurity );
        if (Hr == E_NOINTERFACE)
            {
            //
            // This is not a proxy; the client is in the same apartment as we are.
            // Identity issn't an issue, because the client already has access to system
            // credentials.
            //
            return S_OK;
            }

        DWORD AuthnSvc, AuthzSvc;
        DWORD AuthnLevel, ImpLevel, Capabilites;

        THROW_HRESULT(
            pSecurity->QueryBlanket(
                pUnk,
                &AuthnSvc,
                &AuthzSvc,
                &ServerPrincName,
                &AuthnLevel,
                NULL, // Don't need impersonation handle since were setting that
                NULL, // don't need indenty handle since were setting that
                &Capabilites ) );

        THROW_HRESULT(
            pSecurity->SetBlanket(
                pUnk,
                AuthnSvc,
                AuthzSvc,
                ServerPrincName,
                AuthnLevel,
                RPC_C_IMP_LEVEL_IDENTIFY,
                NULL, // COM use indentity from token
#if !defined( BITS_V12_ON_NT4 )
                EOAC_STATIC_CLOAKING // The point of the exercise
#else
                0
#endif
                ) );

    }
    catch( ComError Error )
    {
        Hr = Error.Error();
    }

    CoTaskMemFree( ServerPrincName );
    SafeRelease( pSecurity );

    return Hr;
}

HRESULT DetectTerminalServer( bool * pfTS )
{

        //
        // Test for Terminal Services.
        //
        INT * pConnectState;
        DWORD size;
        if (WTSQuerySessionInformation( WTS_CURRENT_SERVER,
                                        0,
                                        WTSConnectState,
                                        reinterpret_cast<LPTSTR *>(&pConnectState),
                                        &size))
            {
            LogInfo("TS test: TS is installed");
            *pfTS = true;

            WTSFreeMemory( pConnectState );
            return S_OK;
            }
        else if (GetLastError() == ERROR_APP_WRONG_OS)
            {
            LogInfo("TS test: no TS");

            *pfTS = false;
            return S_OK;
            }
        else
            {
            DWORD s = GetLastError();
            LogError("TS test returned %d", s);
            return HRESULT_FROM_WIN32( s );
            }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\newjob\drizcpat.h ===
/************************************************************************

Copyright (c) 2000 - 2000 Microsoft Corporation

Module Name :

    drizcpat.h

Abstract :

    Compatibility wrapper against the old AU bits.

Author :

Revision History :

 ***********************************************************************/

#pragma once
#if !defined(___DRIZCPAT_H___)
#define ___DRIZCPAT_H___

#include "qmgrlib.h"
#include "qmgr.h"

class COldJobInterface : public IBackgroundCopyJob1
{
public:

    // IUnknown Methods
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObject);
    ULONG _stdcall AddRef(void);
    ULONG _stdcall Release(void);

    // IBackgroundCopyJob1 methods

    STDMETHOD(AddFilesInternal)( ULONG cFileCount, FILESETINFO **ppFileSet );
    STDMETHOD(AddFiles)( ULONG cFileCount, FILESETINFO **ppFileSet )
        { EXTERNAL_FUNC_WRAP( AddFilesInternal( cFileCount, ppFileSet ) ) }
    STDMETHOD(GetFileCountInternal)( DWORD *pCount );
    STDMETHOD(GetFileCount)( DWORD *pCount )
        { EXTERNAL_FUNC_WRAP( GetFileCountInternal( pCount ) ) }
    STDMETHOD(GetFileInternal)( ULONG cFileIndex, FILESETINFO *pFileInfo );
    STDMETHOD(GetFile)( ULONG cFileIndex, FILESETINFO *pFileInfo )
        { EXTERNAL_FUNC_WRAP( GetFileInternal( cFileIndex, pFileInfo ) ) }
    STDMETHOD(CancelJobInternal)();
    STDMETHOD(CancelJob)()
        { EXTERNAL_FUNC_WRAP( CancelJobInternal( ) ) }
    STDMETHOD(get_JobIDInternal)(GUID *pId);
    STDMETHOD(get_JobID)(GUID *pId)
        { EXTERNAL_FUNC_WRAP( get_JobIDInternal( pId ) ) }
    STDMETHOD(GetProgressInternal)(DWORD flags, DWORD *pProgress);
    STDMETHOD(GetProgress)(DWORD flags, DWORD *pProgress)
        { EXTERNAL_FUNC_WRAP( GetProgressInternal( flags, pProgress ) ) }
    STDMETHOD(SwitchToForegroundInternal)();
    STDMETHOD(SwitchToForeground)()
        { EXTERNAL_FUNC_WRAP( SwitchToForegroundInternal( ) ) }
    STDMETHOD(GetStatusInternal)(DWORD *pdwStatus,DWORD *pdwWin32Result, DWORD *pdwTransportResult, DWORD *pdwNumOfRetries );
    STDMETHOD(GetStatus)(DWORD *pdwStatus,DWORD *pdwWin32Result, DWORD *pdwTransportResult, DWORD *pdwNumOfRetries )
        { EXTERNAL_FUNC_WRAP( GetStatusInternal( pdwStatus, pdwWin32Result, pdwTransportResult, pdwNumOfRetries ) ) }

    GUID GetOldJobId()
    {
        return m_OldJobGuid;
    }

    COldJobInterface( GUID JobGuid, CJob *pJob );
    ~COldJobInterface();

    void Serialize( HANDLE hFile );

    static COldJobInterface *Unserialize(
        HANDLE  hFile,
        CJob*   Job
        );

    void SetInterfaceClass(
        CJob *pVal
        )
    {
        m_pJob = pVal;
    }

private:

    long    m_refs;
    long    m_ServiceInstance;

    const GUID              m_OldJobGuid;
    CJob *                  m_pJob;
    CJobExternal * const    m_pJobExternal;
};

class COldGroupInterface : public IBackgroundCopyGroup
{
public:

    // IUnknown Methods
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObject);
    ULONG _stdcall AddRef(void);
    ULONG _stdcall Release(void);

    // IBackgroundCopyGroup methods

    STDMETHOD(GetPropInternal)( GROUPPROP property, VARIANT * pVal );
    STDMETHOD(GetProp)( GROUPPROP property, VARIANT * pVal )
        { EXTERNAL_FUNC_WRAP( GetPropInternal( property, pVal ) ) }
    STDMETHOD(SetPropInternal)( GROUPPROP property, VARIANT *pvarVal );
    STDMETHOD(SetProp)( GROUPPROP property, VARIANT *pvarVal )
        { EXTERNAL_FUNC_WRAP( SetPropInternal( property, pvarVal ) ) }
    STDMETHOD(GetProgressInternal)( DWORD flags, DWORD * pProgress );
    STDMETHOD(GetProgress)( DWORD flags, DWORD * pProgress )
        { EXTERNAL_FUNC_WRAP( GetProgressInternal( flags, pProgress ) ) }
    STDMETHOD(GetStatusInternal)( DWORD *pdwStatus, DWORD *pdwJobIndex );
    STDMETHOD(GetStatus)( DWORD *pdwStatus, DWORD *pdwJobIndex )
        { EXTERNAL_FUNC_WRAP( GetStatusInternal( pdwStatus, pdwJobIndex ) ) }
    STDMETHOD(GetJobInternal)( GUID jobID, IBackgroundCopyJob1 **ppJob );
    STDMETHOD(GetJob)( GUID jobID, IBackgroundCopyJob1 **ppJob )
        { EXTERNAL_FUNC_WRAP( GetJobInternal( jobID, ppJob ) ) }
    STDMETHOD(SuspendGroupInternal)();
    STDMETHOD(SuspendGroup)()
        { EXTERNAL_FUNC_WRAP( SuspendGroupInternal() ) }
    STDMETHOD(ResumeGroupInternal)();
    STDMETHOD(ResumeGroup)()
        { EXTERNAL_FUNC_WRAP( ResumeGroupInternal() ) }
    STDMETHOD(CancelGroupInternal)();
    STDMETHOD(CancelGroup)()
        { EXTERNAL_FUNC_WRAP( CancelGroupInternal() ) }
    STDMETHOD(get_SizeInternal)( DWORD *pdwSize );
    STDMETHOD(get_Size)( DWORD *pdwSize )
        { EXTERNAL_FUNC_WRAP( get_SizeInternal( pdwSize ) ) }
    STDMETHOD(get_GroupIDInternal)( GUID *pguidGroupID );
    STDMETHOD(get_GroupID)( GUID *pguidGroupID )
        { EXTERNAL_FUNC_WRAP( get_GroupIDInternal( pguidGroupID ) ) }
    STDMETHOD(CreateJobInternal)( GUID guidJobID, IBackgroundCopyJob1 **ppJob );
    STDMETHOD(CreateJob)( GUID guidJobID, IBackgroundCopyJob1 **ppJob )
        { EXTERNAL_FUNC_WRAP( CreateJobInternal( guidJobID, ppJob ) ) }
    STDMETHOD(EnumJobsInternal)( DWORD dwFlags, IEnumBackgroundCopyJobs1 **ppEnumJobs );
    STDMETHOD(EnumJobs)( DWORD dwFlags, IEnumBackgroundCopyJobs1 **ppEnumJobs )
        { EXTERNAL_FUNC_WRAP( EnumJobsInternal( dwFlags, ppEnumJobs ) ) }
    STDMETHOD(SwitchToForegroundInternal)();
    STDMETHOD(SwitchToForeground)()
        { EXTERNAL_FUNC_WRAP( SwitchToForegroundInternal() ) }

    // extensions to IBackgroundCopyGroup, not in original Mars interface

    STDMETHOD(QueryNewJobInterface)( REFIID iid, IUnknown ** pUnk );
    STDMETHOD(SetNotificationPointer)( REFIID iid, IUnknown * pUnk );

    COldGroupInterface( CJob *pJob );
    ~COldGroupInterface();

    void Serialize( HANDLE hFile );
    static COldGroupInterface *UnSerialize(HANDLE  hFile, CJob* Job);

    IBackgroundCopyCallback1 * GetNotificationPointer();

    void SetInterfaceClass(
        CJob *pVal
        )
    {
        m_pJob = pVal;
    }

private:

    long m_refs;
    long m_ServiceInstance;

    CJob *                  m_pJob;
    CJobExternal * const    m_pJobExternal;

    IBackgroundCopyCallback1 * m_NotifyPointer;
    GUID                       m_NotifyClsid;
};


class COldQmgrInterface : public IBackgroundCopyQMgr,
                          public IClassFactory
{
public:

    // IUnknown Methods
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObject);
    ULONG _stdcall AddRef(void);
    ULONG _stdcall Release(void);

    // IClassFactory
    STDMETHOD(CreateInstance)( IUnknown * pUnkOuter, REFIID riid, void ** ppvObject );
    STDMETHOD(LockServer)( BOOL fLock );

    // IBackgroundCopyQmgr
    STDMETHOD(CreateGroupInternal)(GUID id, IBackgroundCopyGroup **ppGroup);
    STDMETHOD(CreateGroup)(GUID id, IBackgroundCopyGroup **ppGroup)
        { EXTERNAL_FUNC_WRAP( CreateGroupInternal( id, ppGroup ) ) }
    STDMETHOD(GetGroupInternal)(GUID id, IBackgroundCopyGroup ** ppGroup);
    STDMETHOD(GetGroup)(GUID id, IBackgroundCopyGroup ** ppGroup)
        { EXTERNAL_FUNC_WRAP( GetGroupInternal( id, ppGroup ) ) }
    STDMETHOD(EnumGroupsInternal)(DWORD flags, IEnumBackgroundCopyGroups **ppEnum );
    STDMETHOD(EnumGroups)(DWORD flags, IEnumBackgroundCopyGroups **ppEnum )
        { EXTERNAL_FUNC_WRAP( EnumGroupsInternal( flags, ppEnum ) ) }

    // other methods

    COldQmgrInterface();

    void SetInterfaceClass(
        CJobManager *pVal
        )
    {
        m_pJobManager = pVal;
    }

private:

    long m_refs;
    long m_ServiceInstance;

    CJobManager *m_pJobManager;
};

class CEnumOldGroups : public CEnumItem<IEnumBackgroundCopyGroups,GUID>
{
public:
    CEnumOldGroups();
};

class CEnumOldJobs : public CEnumItem<IEnumBackgroundCopyJobs1,GUID>
{
public:
    CEnumOldJobs();
};

#endif //__DRIZCPAT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\newjob\downloader.cpp ===
/************************************************************************

Copyright (c) 2000 - 2000 Microsoft Corporation

Module Name :

    downloader.cpp

Abstract :

    Main Source file for downloader.

Author :

Revision History :

 ***********************************************************************/

#include "stdafx.h"
#include "malloc.h"

#if !defined(BITS_V12_ON_NT4)
#include "downloader.tmh"
#endif


void SafeCloseInternetHandle( HINTERNET & h )
{
    if (h)
        {
        InternetCloseHandle( h );
        h = NULL;
        }
}

#define ACCEPT_ENCODING_STRING _T("Accept-encoding: identity")

BOOL NeedRetry( QMErrInfo * );
bool NeedCredentials( HINTERNET hRequest, DWORD err );
bool IsPossibleProxyFailure( DWORD err );

DWORD GetRequestStatus( HINTERNET hRequest ) throw( ComError );

bool
ApplyCredentials(
    HINTERNET hRequest,
    const CCredentialsContainer * Credentials,
    WCHAR UserName[],
    WCHAR Password[]
    ) throw( ComError );

bool
ApplySchemeCredentials(
    HINTERNET hRequest,
    DWORD dwTarget,
    DWORD dwScheme,
    const CCredentialsContainer * Credentials,
    WCHAR UserName[],
    WCHAR Password[]
    ) throw( ComError );

HRESULT
CheckReplyRange(
    HINTERNET hRequest,
    UINT64 CorrectStart,
    UINT64 CorrectEnd,
    UINT64 CorrectTotal
    );

HRESULT
CheckReplyLength(
    HINTERNET hRequest,
    UINT64 CorrectOffset,
    UINT64 CorrectTotal
    );

#ifndef USE_WININET

VOID CALLBACK
HttpRequestCallback(
    IN HINTERNET hInternet,
    IN DWORD_PTR dwContext,
    IN DWORD dwInternetStatus,
    IN LPVOID lpvStatusInformation OPTIONAL,
    IN DWORD dwStatusInformationLength
    );

DWORD
MapSecureHttpErrorCode(
    DWORD flags
    );

#endif

CACHED_AUTOPROXY * g_ProxyCache;

BYTE g_FileDataBuffer[ FILE_DATA_BUFFER_LEN ];

HRESULT
CreateHttpDownloader(
    Downloader **ppDownloader,
    QMErrInfo *pErrInfo
    )
{
    Downloader * pDownloader = 0;

    try
        {
        *ppDownloader = NULL;

        g_ProxyCache = new CACHED_AUTOPROXY;
        pDownloader = new CProgressiveDL( pErrInfo );

        *ppDownloader = pDownloader;
        return S_OK;
        }
    catch ( ComError err )
        {
        delete g_ProxyCache; g_ProxyCache = 0;
        delete pDownloader;

        return err.Error();
        }
}

void
DeleteHttpDownloader(
    Downloader *pDownloader
    )
{
    CProgressiveDL * ptr = (CProgressiveDL *) pDownloader;

    delete ptr;

    delete g_ProxyCache; g_ProxyCache = 0;
}

/////////////////////////////////////////////////////////////////////////////
// CProgressiveDL
CProgressiveDL::CProgressiveDL(
    QMErrInfo *pErrInfo
    ) :
    m_bThrottle( TRUE ),
    m_wupdinfo( NULL ),
    m_hOpenRequest( NULL ),
    m_hFile( INVALID_HANDLE_VALUE )
{
    m_pQMInfo = pErrInfo;
}

CProgressiveDL::~CProgressiveDL()
{
    ASSERT( m_hFile == INVALID_HANDLE_VALUE );
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Public function Download()
//          Accepts a URL and destination to download, callback to report various status
// Input: url, destination, flags, callback for status
// Output: todo handle
// Return: hresult
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT
CProgressiveDL::Download(
    LPCTSTR szURL,
    LPCTSTR szDest,
    UINT64  Offset,
    ITransferCallback * Callbacks,
    QMErrInfo *pQMErrInfo,
    HANDLE hToken,
    BOOL bThrottle,
    const PROXY_SETTINGS * ProxySettings,
    const CCredentialsContainer * Credentials,
    const StringHandle HostId
    )
{
    HRESULT hr = S_OK;
    DWORD dwThreadID;

    m_Callbacks = Callbacks;
    m_pQMInfo = pQMErrInfo;
    m_bThrottle = bThrottle;
    m_pQMInfo->result = QM_FILE_FATAL_ERROR;

    ASSERT( Callbacks );
    ASSERT( pQMErrInfo );

    if (!m_pQMInfo)
        {
        return E_FAIL;
        }

    if ((!szURL) || (!szDest))
        {
        SetError( SOURCE_HTTP_UNKNOWN, ERROR_STYLE_HRESULT, E_INVALIDARG, "NULL file name" );
        return E_FAIL;
        }

    ASSERT( wcslen( szURL ) <= INTERNET_MAX_URL_LENGTH );
    ASSERT( wcslen( szDest ) <= MAX_PATH );

    LogDl( "---------------------------------------------------------------------" );

    LogDl( "Downloading file %!ts! offset %d", szDest, DWORD(Offset) );

    m_pQMInfo->result = QM_IN_PROGRESS;

    do
        {
        hr = DownloadFile( hToken, ProxySettings, Credentials, szURL, szDest, Offset, HostId );
        }
    while ( hr == E_RETRY );

    if (hr == S_OK)
        {
        m_pQMInfo->result = QM_FILE_DONE;
        LogDl( "Done file %!ts!", szDest );
        }
    else if ( hr == S_FALSE )
        {
        m_pQMInfo->result = QM_FILE_ABORTED;
        LogDl( "File %!ts! aborted", szDest );
        }
    else if ( m_pQMInfo->result != QM_SERVER_FILE_CHANGED )
        {
        ASSERT( IsErrorSet() );

        if (NeedRetry(m_pQMInfo))
            {
            m_pQMInfo->result = QM_FILE_TRANSIENT_ERROR;
            }
        else
            {
            m_pQMInfo->result = QM_FILE_FATAL_ERROR;
            }
        }

    ASSERT( m_pQMInfo->result != QM_IN_PROGRESS );

    LogDl( "---------------------------------------------------------------------" );

    // if abort request came in after file failed, overwrite failed flag.
    if ( (QM_FILE_DONE != m_pQMInfo->result) && IsAbortRequested() )
    {
        m_pQMInfo->result = QM_FILE_ABORTED;
    }

    ASSERT( m_hFile == INVALID_HANDLE_VALUE );

    return hr;
}


HRESULT
CProgressiveDL::DownloadFile(
    HANDLE  hToken,
    const PROXY_SETTINGS * ProxySettings,
    const CCredentialsContainer * Credentials,
    LPCTSTR Url,
    LPCWSTR Path,
    UINT64  Offset,
    StringHandle HostId
    )
{
    HRESULT hr = S_OK;

    ASSERT( m_wupdinfo == NULL );
    ASSERT( m_hOpenRequest == NULL );

    m_pQMInfo->Clear();

    try
        {
        if (!ImpersonateLoggedOnUser(hToken))
            {
            SetError( SOURCE_HTTP_UNKNOWN, ERROR_STYLE_WIN32, GetLastError(), "Impersonate" );
            throw ComError( E_FAIL );
            }

        //
        // Open a connection to the server, and use that data for our first estimate of the line speed.
        //
        m_wupdinfo = ConnectToUrl( Url, ProxySettings, Credentials, (const TCHAR*)HostId, m_pQMInfo );
        if (!m_wupdinfo)
            {
            ASSERT( IsErrorSet() );
            throw ComError( E_FAIL );
            }

        //
        // Get file size and time stamp.
        //
        if (! GetRemoteResourceInformation( m_wupdinfo, m_pQMInfo ))
            {
            ASSERT( IsErrorSet() );
            throw ComError( E_FAIL );
            }

        if (!OpenLocalDownloadFile(Path, Offset, m_wupdinfo->FileSize, m_wupdinfo->UrlModificationTime))
            {
            ASSERT( IsErrorSet() );
            throw ComError( E_FAIL );
            }

        // Be sure to check for an end of file before attempting
        // to download more bytes.
        if (IsFileComplete())
           {
            LogDl( "File is done already.\n" );

           if (!SetFileTimes())
              {
              ASSERT( IsErrorSet() );
              hr = E_FAIL;
              }

            hr = S_OK;
            }
        //
        // Transfer data from the server.
        //
        else if ( !m_bThrottle )
            {
            hr = DownloadForegroundFile();
            }
        else
            {

            //
            // Use either the server's host name or the proxy's host name to find the right network adapter..
            //
            hr = m_Network.SetInterfaceIndex( m_wupdinfo->fProxy ? m_wupdinfo->ProxyHost.get() : m_wupdinfo->HostName );
            if (FAILED(hr))
                {
                SetError( SOURCE_HTTP_CLIENT_CONN, ERROR_STYLE_HRESULT, hr, "GetInterfaceIndex" );
                throw ComError( E_FAIL );
                }

            while (1)
               {
               if (IsAbortRequested())
                   {
                   hr = S_FALSE;
                   break;
                   }

               hr = GetNextBlock();

               if ( S_FALSE == hr )
                   break;

               if (FAILED(hr) )
                   {
                   ASSERT( hr == E_RETRY || IsErrorSet() );
                   break;
                   }

               if (IsFileComplete())
                   {
                   if (!SetFileTimes())
                       {
                       ASSERT( IsErrorSet() );
                       hr = E_FAIL;
                       break;
                       }

                   hr = S_OK;
                   break;
                   }
               }
            }
        }
    catch( ComError exception )
        {
        ASSERT( IsErrorSet() );
        hr = exception.Error();
        }

    if ( m_bThrottle )
       {
       m_Network.StopTimer();
       }

    CloseLocalFile();

    RevertToSelf();

    delete m_wupdinfo; m_wupdinfo = NULL;

    SafeCloseInternetHandle( m_hOpenRequest );

    if (FAILED(hr))
        {
        ASSERT( hr == E_RETRY || IsErrorSet() );
        }

    return hr;
}

HRESULT
CProgressiveDL::DownloadForegroundFile()
{
    HRESULT hr = E_FAIL;
    LogDl( "Starting foreground file download" );

    while( 1 )
        {

        //
        // Loop of HTTP requests.  This is to work around a wininet/winhttp limitation
        // where request sizes can be a maximum of 4GB.
        //

        UINT64 BlockSize64  = m_wupdinfo->FileSize - m_CurrentOffset;
        DWORD BlockSize     = (DWORD)min( BlockSize64, 2147483648 );
        LogDl( "Starting foreground file download request block: file size %d, offset %d, block %d",
               DWORD( m_wupdinfo->FileSize ), DWORD(m_CurrentOffset), BlockSize );

        //
        // Send a block request and read the reply headers.
        //
//        hr = (m_wupdinfo->bRange) ? StartRangeRequest( BlockSize ) : StartEncodedRangeRequest( BlockSize );

        hr = StartRangeRequest( BlockSize );
        if (FAILED(hr))
            {
            ASSERT( IsErrorSet() );
            return hr;
            }

        const DWORD MIN_FOREGROUND_BLOCK = 4096;
        const DWORD MAX_FOREGROUND_BLOCK = FILE_DATA_BUFFER_LEN;
        const DWORD FOREGROUND_BLOCK_INCREMENT = 1024;
        const DWORD FOREGROUND_UPDATE_RATE = 2000;

        DWORD ForegroundBlockSize = min( MIN_FOREGROUND_BLOCK, BlockSize );
        DWORD dwPrevTick = GetTickCount();

        while( 1 )
            {

            //
            //  Loop of read blocks inside an individual request.
            //

            if (IsAbortRequested())
                {
                return S_FALSE;
                }

            if ( IsFileComplete() )
                {
                LogDl( "File is done, exiting.\n" );

                if (!SetFileTimes())
                    {
                    ASSERT( IsErrorSet() );
                    return E_FAIL;
                    }
                return S_OK;
                }

            BYTE *p = g_FileDataBuffer;
            DWORD dwTotalBytesRead = 0;
            DWORD dwBytesToRead = ForegroundBlockSize;
            DWORD dwRead;

            while( 1 )
                {

                if (! InternetReadFile(m_hOpenRequest, p, dwBytesToRead, &dwRead) )
                    {
                    SetError( SOURCE_HTTP_CLIENT_CONN, ERROR_STYLE_WIN32, GetLastError(), "InternetReadFile" );

                    LogWarning( "InternetReadFile failed: len=%d, offset=%I64d, err=%d",
                                ForegroundBlockSize, m_CurrentOffset, GetLastError());
                    return E_FAIL;
                    }

                if ( !dwRead )
                   break;

                dwTotalBytesRead += dwRead;
                dwBytesToRead -= dwRead;
                p += dwRead;

                if ( !dwBytesToRead )
                   break;
                }

            if (!WriteBlockToCache( (LPBYTE) g_FileDataBuffer, dwTotalBytesRead ))
                {
                ASSERT( IsErrorSet() );
                return hr;
                }

            if (dwTotalBytesRead != ForegroundBlockSize &&
                m_CurrentOffset != m_wupdinfo->FileSize)
                {
                LogError("Download block : EOF after %d", dwRead );
                SetError( SOURCE_HTTP_CLIENT_CONN, ERROR_STYLE_WIN32, ERROR_INTERNET_CONNECTION_RESET, "DownloadBlock" );
                return E_FAIL;
                }

            if (m_Callbacks->DownloaderProgress( m_CurrentOffset, m_wupdinfo->FileSize ))
                {
                // abort was requested
                return S_FALSE;
                }

            DWORD dwNewTick = GetTickCount();
            DWORD dwTimeDelta = dwNewTick - dwPrevTick;

            if ( dwTimeDelta < FOREGROUND_UPDATE_RATE )
                ForegroundBlockSize = min( ForegroundBlockSize + FOREGROUND_BLOCK_INCREMENT, MAX_FOREGROUND_BLOCK );
            else if ( dwTimeDelta > FOREGROUND_UPDATE_RATE )
                ForegroundBlockSize = max( ForegroundBlockSize - FOREGROUND_BLOCK_INCREMENT, MIN_FOREGROUND_BLOCK );

            ForegroundBlockSize = min( ForegroundBlockSize, ( m_wupdinfo->FileSize - m_CurrentOffset ) );
            dwPrevTick = dwNewTick;

            //
            // End loop of read blocks
            //
            }

        //
        // End loop of requests
        //
        }
}

HRESULT
CProgressiveDL::GetNextBlock()
{
    HRESULT hr = E_FAIL;

    LogDl( "file size %d, offset %d", DWORD(m_wupdinfo->FileSize), DWORD(m_CurrentOffset) );

    m_Network.CalculateIntervalAndBlockSize( m_wupdinfo->FileSize - m_CurrentOffset );

    DWORD BlockSize = m_Network.m_BlockSize;

    if (BlockSize == 0)
        {
        m_Network.TakeSnapshot( CNetworkInterface::BLOCK_START );
        m_Network.TakeSnapshot( CNetworkInterface::BLOCK_END );
        }
    else
        {
        m_Network.TakeSnapshot( CNetworkInterface::BLOCK_START );

        //
        // Request a block from the server.
        //
//        hr = (m_wupdinfo->bRange) ? StartRangeRequest( BlockSize ) : StartEncodedRangeRequest( BlockSize );

        hr = StartRangeRequest( BlockSize );
        if (FAILED(hr))
            {
            ASSERT( IsErrorSet() );
            return hr;
            }

        //
        // A single call to InternetReadFile may return only part of the requested data,
        // so loop until the entire block has arrived.
        //
        DWORD dwBytesRead = 0;
        while (dwBytesRead < BlockSize )
            {
            DWORD dwSize = min( (BlockSize - dwBytesRead) , FILE_DATA_BUFFER_LEN );
            DWORD dwRead = 0;

            if (! InternetReadFile( m_hOpenRequest,
                                    g_FileDataBuffer,
                                    dwSize,
                                    &dwRead ))
                {
                SetError( SOURCE_HTTP_CLIENT_CONN, ERROR_STYLE_WIN32, GetLastError(), "InternetReadFile" );

                LogWarning( "InternetReadFile failed: len=%d, offset=%I64d, err=%d",
                            dwSize, m_CurrentOffset, GetLastError());

                return E_FAIL;
                }
            else if (dwRead == 0)
                {
                break;
                }

            dwBytesRead += dwRead;

            //
            // Save the data.
            //
            if (!WriteBlockToCache( (LPBYTE) g_FileDataBuffer, dwRead ))
                {
                ASSERT( IsErrorSet() );
                return hr;
                }

            }

        if (dwBytesRead != BlockSize)
            {
            LogError("Download block : EOF after %d", dwBytesRead );

            SetError( SOURCE_HTTP_CLIENT_CONN, ERROR_STYLE_WIN32, ERROR_INTERNET_CONNECTION_RESET, "DownloadBlock" );

            return E_FAIL;
            }

        m_Network.TakeSnapshot( CNetworkInterface::BLOCK_END );

        if (m_Callbacks->DownloaderProgress( m_CurrentOffset, m_wupdinfo->FileSize ))
            {
            // abort was requested
            return S_FALSE;
            }
        }

    //
    // Allow other apps to use the network for the rest of the time interval,
    // then take the end-of-interval snapshot.
    //
    m_Network.Wait();

    hr = m_Network.TakeSnapshot( CNetworkInterface::BLOCK_INTERVAL_END );
    if (SUCCEEDED(hr))
        {
        m_Network.SetInterfaceSpeed();
        }
    else if (hr == HRESULT_FROM_WIN32( ERROR_INVALID_DATA ))
        {
        //
        // If the snapshot fails with ERROR_INVALID_DATA and the downloads
        // keep working, then our NIC has been removed and the networking
        // layer has silently transferred our connection to another available
        // NIC.  We need to identify the NIC that we are now using.
        //
        LogWarning("NIC is no longer valid.  Requesting retry.");
        hr = E_RETRY;
        }
    else
        SetError( SOURCE_HTTP_CLIENT_CONN, ERROR_STYLE_HRESULT, hr, "TakeSnapshot" );

    return hr;
}

URL_INFO::URL_INFO(
    LPCTSTR Url,
    const PROXY_SETTINGS * a_ProxySettings,
    const CCredentialsContainer * a_Credentials,
    LPCTSTR HostId
    ) :
    hInternet( 0 ),
    hConnect( 0 ),
    FileSize( 0 ),
    dwFlags( 0 ),
    bHttp11( true ),
    ProxySettings( 0 ),
    fProxy( false ),
    Credentials( a_Credentials )
{
    try
        {
        LogInfo("new URL_INFO at %p", this );

        //
        // Split the URL into server, path, name, and password components.
        //
        URL_COMPONENTS  UrlComponents;

        ZeroMemory(&UrlComponents, sizeof(UrlComponents));

        UrlComponents.dwStructSize        = sizeof(UrlComponents);
        UrlComponents.lpszHostName        = HostName;
        UrlComponents.dwHostNameLength    = RTL_NUMBER_OF(HostName);
        UrlComponents.lpszUrlPath         = UrlPath;
        UrlComponents.dwUrlPathLength     = RTL_NUMBER_OF(UrlPath);
        UrlComponents.lpszUserName        = UserName;
        UrlComponents.dwUserNameLength    = RTL_NUMBER_OF(UserName);
        UrlComponents.lpszPassword        = Password;
        UrlComponents.dwPasswordLength    = RTL_NUMBER_OF(Password);

        if (! InternetCrackUrl(Url, 0, 0, &UrlComponents))
            {
            if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
                {
                THROW_HRESULT( HRESULT_FROM_WIN32( ERROR_WINHTTP_INVALID_URL ));
                }
            ThrowLastError();
            }

        if (-1 == UrlComponents.dwHostNameLength ||
            -1 == UrlComponents.dwUrlPathLength ||
            -1 == UrlComponents.dwUserNameLength ||
            -1 == UrlComponents.dwPasswordLength)
            {
            THROW_HRESULT( HRESULT_FROM_WIN32( ERROR_WINHTTP_INVALID_URL ));
            }

        Port = UrlComponents.nPort;

        if (0 == _tcslen(HostName))
            {
            THROW_HRESULT( E_INVALIDARG );
            }

        if ( HostId && *HostId )
            {
            // redirected to another host.

            THROW_HRESULT( StringCbCopy( HostName, sizeof(HostName), HostId ));

            LogDl( "Stuck to %!ts!...", UrlComponents.lpszHostName );
            }

        //
        // Set the connect flags.
        //
        dwFlags = INTERNET_FLAG_NO_UI | INTERNET_FLAG_RELOAD;

    #if !defined( USE_WININET )
        dwFlags |= WINHTTP_FLAG_ESCAPE_DISABLE_QUERY;
    #endif

        if(UrlComponents.nScheme == INTERNET_SCHEME_HTTPS)
            {
            dwFlags |= INTERNET_FLAG_SECURE;
            }

        ProxySettings = new PROXY_SETTINGS_CONTAINER( Url, a_ProxySettings );
        }
    catch ( ComError err )
        {
        Cleanup();
        throw;
        }
}

//
// Splitting the explicit cleanup into a separate function allows the constructor to re-use the code.
// The constructor *cannot* explicitly call the destructor if it is going to throw an exception,
// because the destructor will call the StringHandle member destructors and then the constructor
// will call them again (because it is throwing an exception and cleans up the already-constructed
// members).
//
URL_INFO::~URL_INFO()
{
    Cleanup();
}

void URL_INFO::Cleanup()
{
    LogInfo("deleting URL_INFO at %p", this );

    Disconnect();

    MySecureZeroMemory( UserName, sizeof(UserName) );
    MySecureZeroMemory( Password, sizeof(Password) );

    delete ProxySettings; ProxySettings = NULL;
}

void
URL_INFO::Disconnect()
{
    SafeCloseInternetHandle( hConnect );
    SafeCloseInternetHandle( hInternet );
}

QMErrInfo
URL_INFO::Connect()
{
    try
        {
        //
        // The proxy stuff is ignored because we will set an explicit proxy on each request.
        //
        hInternet = InternetOpen( C_BITS_USER_AGENT,
                                  INTERNET_OPEN_TYPE_DIRECT,
                                  NULL,
                                  NULL,
                                  0 );

        if (! hInternet )
            {
            ThrowLastError();
            }

    #ifdef USE_WININET
        {
            DWORD   dwDisable = 1;
            if (!InternetSetOption(hInternet, INTERNET_OPTION_DISABLE_AUTODIAL, &dwDisable, sizeof(DWORD)))
                {
                ThrowLastError();
                }
        }
    #endif

        if (! (hConnect = WinHttpConnect( hInternet,
                                                HostName,
                                                Port,
                                                0)))                //context
            {
            ThrowLastError();
            }

        QMErrInfo Success;

        return Success;
        }
    catch ( ComError err )
        {
        LogError( "error %x connecting to server", err.Error() );

        QMErrInfo QmError( SOURCE_HTTP_CLIENT_CONN, ERROR_STYLE_WIN32, err.Error() );

        return QmError;
        }
}

URL_INFO *
ConnectToUrl(
    LPCTSTR                Url,
    const PROXY_SETTINGS * ProxySettings,
    const CCredentialsContainer * Credentials,
    const TCHAR *          HostId,
    QMErrInfo * pErrInfo
    )
{
    //
    // Open a connection to the server.
    //
    LogDl( "Connecting to %!ts!...", Url);

    //
    // This should have been checked by the caller.
    //
    ASSERT( HostId == NULL || wcslen(HostId) < INTERNET_MAX_HOST_NAME_LENGTH );

    try
        {
        URL_INFO * Info = new URL_INFO( Url, ProxySettings, Credentials, HostId );

        *pErrInfo =  Info->Connect();

        if (pErrInfo->IsSet())
            {
            delete Info;
            return NULL;
            }

        return Info;
        }
    catch ( ComError err )
        {
        pErrInfo->Set( SOURCE_HTTP_CLIENT_CONN, ERROR_STYLE_HRESULT, err.Error(), "untracked API" );
        return NULL;
        }
}


BOOL
CProgressiveDL::GetRemoteResourceInformation(
    URL_INFO * Info,
    QMErrInfo *pQMErrInfo
    )
/*

    We begin with an HTTP 1.1 HEAD request.
    If the server replies with version 1.1, we have a persistent connection and the proxy, if present, can cache our requests.
    If the server replies with version 1.0, we do not have either characteristic.  Our GET requests will add "Connection: keep-alive"
    but it may not do any good.  The proxy server, if present, may not understand ranges and if we allow caching then it will
    cache a range request as if it were the entire file.
    If the server replies with any other version or the call fails, then we should bail with BG_E_INSUFFICIENT_SERVER_SUPPORT.
    If an error occurs, we report it and bail.

*/
{
    HRESULT FailureCode = 0;
    unsigned FailureLine = 0;

#define CHECK_HRESULT( x )   \
    { \
    HRESULT _hr_ = x;  \
    if (FAILED(_hr_))  \
        {  \
        FailureCode = _hr_; \
        FailureLine = __LINE__; \
        goto exit;  \
        }   \
    }

#define CHECK_BOOL( x )  \
    { \
    if (! x )  \
        {  \
        FailureCode = HRESULT_FROM_WIN32( GetLastError() ); \
        FailureLine = __LINE__; \
        goto exit;  \
        }   \
    }

    // Assume HTTP1.1 with no proxy until we determine otherwise.
    //
    Info->bHttp11 = TRUE;
    Info->bRange = TRUE;
    Info->fProxy = FALSE;

    BOOL b = FALSE;
    HRESULT hr;
    HINTERNET hRequest = NULL;
    DWORD dwErr, dwLength = 0, dwStatus = 0, dwState = 0;

    CHECK_HRESULT( OpenHttpRequest( _T("HEAD"), _T("HTTP/1.1"), *Info, &hRequest ) );

    CHECK_HRESULT( SendRequest( hRequest, Info ));

    // check status
    dwLength = sizeof(dwStatus);

    CHECK_BOOL( HttpQueryInfo( hRequest,
                         HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER,
                         (LPVOID)&dwStatus,
                         &dwLength,
                         NULL));

    if (dwStatus != HTTP_STATUS_OK)
        {
        pQMErrInfo->Set( SOURCE_HTTP_SERVER, ERROR_STYLE_HTTP, dwStatus );
        goto exit;
        }

    //
    // We know that the server replied with a success code.  Now determine the HTTP version.
    //
    unsigned MajorVersion;
    unsigned MinorVersion;

    CHECK_HRESULT( GetResponseVersion( hRequest, &MajorVersion, &MinorVersion ));

    if (MajorVersion != 1)
        {
        LogWarning("server version %d.%d is outside our supported range", MajorVersion, MinorVersion );
        pQMErrInfo->Set( SOURCE_HTTP_CLIENT_CONN, ERROR_STYLE_HRESULT, BG_E_INSUFFICIENT_HTTP_SUPPORT );
        goto exit;
        }

    if (MinorVersion < 1)
        {
        Info->bHttp11   = FALSE;
        Info->dwFlags |= INTERNET_FLAG_DONT_CACHE;
        }

    //
    // Now determine the proxy server.
    //
    CHECK_BOOL( Info->GetProxyUsage( hRequest, pQMErrInfo ));

    // check file size
    WCHAR FileSizeText[ INT64_DIGITS+1 ];
    dwLength = sizeof( FileSizeText );

    if (!HttpQueryInfo( hRequest,
                        HTTP_QUERY_CONTENT_LENGTH,
                        FileSizeText,
                        &dwLength,
                        NULL))
        {
        pQMErrInfo->Set( SOURCE_HTTP_CLIENT_CONN, ERROR_STYLE_HRESULT, BG_E_MISSING_FILE_SIZE, "HttpQueryInfo: content length" );
        goto exit;
        }

    if ( 1 != swscanf( FileSizeText, L"%I64u", &Info->FileSize ) )
        {
        pQMErrInfo->Set( SOURCE_HTTP_CLIENT_CONN, ERROR_STYLE_HRESULT, BG_E_MISSING_FILE_SIZE, "swscanf: content length" );
        goto exit;
        }

    LogDl( "File size of %!ts! = %I64u", Info->UrlPath, Info->FileSize);

    // check file time
    //
    SYSTEMTIME sysTime;
    dwLength = sizeof(sysTime);
    if (!HttpQueryInfo( hRequest,
                        HTTP_QUERY_LAST_MODIFIED | HTTP_QUERY_FLAG_SYSTEMTIME,
                        (LPVOID)&sysTime,
                        &dwLength,
                        NULL))
        {
        LogWarning( "GetFileSize : HttpQueryInfo( LAST_MODIFIED ) failed with %d", GetLastError());
        memset( &Info->UrlModificationTime, 0, sizeof(Info->UrlModificationTime) );
        }
    else
        {
        SystemTimeToFileTime(&sysTime, &Info->UrlModificationTime);
        }

    b = TRUE;

exit:

    if (FailureCode)
        {
        LogError("failure at line %d; hresult = %x", FailureLine, FailureCode );
        pQMErrInfo->Set( SOURCE_HTTP_CLIENT_CONN, ERROR_STYLE_HRESULT, FailureCode );
        }

    // release allocated objects
    //
    SafeCloseInternetHandle( hRequest );

    return b;

#undef CHECK_HRESULT
#undef CHECK_BOOL
}

BOOL
URL_INFO::GetProxyUsage(
    HINTERNET hRequest,
    QMErrInfo *ErrInfo
    )
/*

    This function determines whether the completed request in <hRequest> used a proxy server,
    and if so which one.  In BITS 1.0 (Windows XP), it looked in the HTTP 1.1 Via header, but
    that header isn't present in HTTP 1.0 replies, and a server is allowed to return a fake host name.
    (see RFC 2616 section 14.45 for details.)

    The current version parses the current proxy value in this->ProxySettings, which was calculated
    by the HTTP layer.  The format of a proxy-server entry is as follows:

                ([<scheme>=][<scheme>"://"]<server>[":"<port>])

    this->ProxyHost should include only the server name.

On exit:

    if TRUE, fProxy and ProxyHost are set.
    if FALSE, fProxy and ProxyHost are unchanged and ErrInfo is set.

*/
{
    try
        {
        LPCWSTR p = ProxySettings->GetCurrentProxy();

        if (!p)
            {
            fProxy = FALSE;
            return TRUE;
            }

        LPCWSTR p2;

        //
        // Skip past the [<scheme>=] segment.
        //
        p2 = wcschr( p, '=' );
        if (p2)
            {
            ++p2;
            p = p2;
            }

        //
        // Skip past the [<scheme>"://"] segment.
        //
        p2 = wcschr( p, '/' );
        if (p2)
            {
            ++p2;
            if (*p2 == '/')
                {
                ++p2;
                }

            p = p2;
            }

        //
        // p now points to the beginning of the server name.  Copy it.
        //

        ProxyHost = CAutoString( CopyString( p ));

        //
        // Find the [":"<port>] segment.
        //
        LPWSTR pColon = wcschr( ProxyHost.get(), ':' );
        if (pColon)
            {
            *pColon = '\0';
            }

        fProxy = TRUE;
        return TRUE;
        }
    catch ( ComError err )
        {
        ErrInfo->Set( SOURCE_HTTP_UNKNOWN, ERROR_STYLE_HRESULT, err.Error() );
        return FALSE;
        }
}

//HRESULT
//CProgressiveDL::StartEncodedRangeRequest(
//    DWORD   Length
//    )
//{
//    HRESULT hr = S_OK;
//    DWORD  dwTotalRead = 0, dwRead = 0, dwErr, dwSize = 0, dwStatus;
//
//    if (FAILED(hr = CreateBlockUrl(m_wupdinfo->BlockUrl, Length)))
//        {
//        return hr;
//        }
//
//    UINT64 Offset = m_CurrentOffset;
//
//    //
//    // Every block goes to a different URL, so open a new request each time.
//    //
//    SafeCloseInternetHandle( m_hOpenRequest );
//
//    LPCTSTR AcceptTypes[] = {_T("*/*"), NULL};
//
//    if (! (m_hOpenRequest = HttpOpenRequest(
//        m_wupdinfo->hConnect,
//        NULL,                // "GET"
//        m_wupdinfo->BlockUrl,
//        _T("HTTP/1.0"),
//        NULL,               //referer
//        AcceptTypes,
//        m_wupdinfo->dwFlags,
//        0)))                //context
//        {
//        SetError( SOURCE_HTTP_CLIENT_CONN, ERROR_STYLE_WIN32, GetLastError(), "InternetOpenUrl" );
//        return E_FAIL;
//        }
//
//    hr = AddIf_Unmodified_SinceHeader( m_hOpenRequest, m_wupdinfo->FileCreationTime );
//    if (FAILED(hr))
//        {
//        SetError( SOURCE_HTTP_CLIENT_CONN, ERROR_STYLE_HRESULT, hr, "adding if-unmodifed-since header" );
//        return E_FAIL;
//        }
//
//    if (! HttpAddRequestHeaders(m_hOpenRequest, ACCEPT_ENCODING_STRING, -1L, HTTP_ADDREQ_FLAG_ADD | HTTP_ADDREQ_FLAG_REPLACE ))
//        {
//        SetError( SOURCE_HTTP_CLIENT_CONN, ERROR_STYLE_WIN32, GetLastError(), "add header: accept-encoding" );
//        return E_FAIL;
//        }
//
//    hr = SendRequest( m_hOpenRequest, m_wupdinfo );
//    if (FAILED(hr))
//        {
//        SetError( SOURCE_HTTP_CLIENT_CONN, ERROR_STYLE_HRESULT, hr, "HttpSendRequest" );
//        LogError( "HttpSendRequest failed in progressive download loop - offset=%I64d",
//                   m_CurrentOffset );
//        return E_FAIL;
//        }
//
//    dwSize = sizeof(dwStatus);
//    if (! HttpQueryInfo(m_hOpenRequest,
//                HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER,
//                (void *)&dwStatus,
//                &dwSize,
//                NULL))
//        {
//        SetError( SOURCE_HTTP_CLIENT_CONN, ERROR_STYLE_WIN32, GetLastError(), "HttpQueryInfo" );
//        return E_FAIL;
//        }
//
//    if ( HTTP_STATUS_PRECOND_FAILED == dwStatus )
//        {
//        SetError( SOURCE_HTTP_SERVER, ERROR_STYLE_HTTP, dwStatus );
//        m_pQMInfo->result = QM_SERVER_FILE_CHANGED;
//        return E_FAIL;
//        }
//
//    if ((dwStatus != HTTP_STATUS_OK) && (dwStatus != HTTP_STATUS_PARTIAL_CONTENT))
//        {
//        if (DoesErrorIndicateNoISAPI( dwStatus ) )
//            {
//            LogError("HTTP 1.0 server returned %d, returning INSUFFICIENT_HTTP_SUPPORT", dwStatus);
//            SetError( SOURCE_HTTP_SERVER, ERROR_STYLE_HRESULT, BG_E_INSUFFICIENT_HTTP_SUPPORT );
//            return BG_E_INSUFFICIENT_HTTP_SUPPORT;
//            }
//        else
//            {
//            SetError( SOURCE_HTTP_SERVER, ERROR_STYLE_HTTP, dwStatus );
//            return E_FAIL;
//            }
//        }
//    return S_OK;
//}
//
//HRESULT
//CProgressiveDL::CreateBlockUrl(
//    LPTSTR lpszNewUrl,
//    DWORD  Length
//    )
//{
//    HRESULT hr;
//    UINT64 Offset = m_CurrentOffset;
//
//    hr = StringCchPrintf( lpszNewUrl,
//                          INTERNET_MAX_URL_LENGTH,
//                          _T("%s@%I64d-%I64d@"),
//                          m_wupdinfo->UrlPath,
//                          Offset,
//                          Offset + Length - 1
//                          );
//    if (FAILED(hr))
//        {
//        SetError( SOURCE_HTTP_CLIENT_CONN, ERROR_STYLE_HRESULT, hr, "printf" );
//        return E_FAIL;
//        }
//
//    return S_OK;
//}

HRESULT
CProgressiveDL::StartRangeRequest(
    DWORD   Length
    )
{
    HRESULT hr;
    DWORD  dwBegin, dwEnd, dwTotalRead = 0, dwRead = 0, dwErr, dwLength, dwStatus;

    UINT64 Offset = m_CurrentOffset;

    //todo cleanup by goto exit and close handles

    if ( !m_hOpenRequest )
        {
        HINTERNET hRequest;

        hr = OpenHttpRequest( NULL,             // default is "GET"
                              m_wupdinfo->bHttp11 ? _T("HTTP/1.1") : _T("HTTP/1.0"),
                              *m_wupdinfo,
                              &hRequest
                              );
        if (FAILED(hr))
            {
            SetError( SOURCE_HTTP_CLIENT_CONN, ERROR_STYLE_HRESULT, hr, "CreateHttpRequest");
            return E_FAIL;
            }

        m_hOpenRequest = hRequest;

        //
        // These headers are constant for a particular file download attempt.
        //
        hr = AddIf_Unmodified_SinceHeader( m_hOpenRequest, m_wupdinfo->FileCreationTime );
        if (FAILED(hr))
            {
            SetError( SOURCE_HTTP_CLIENT_CONN, ERROR_STYLE_HRESULT, hr );
            LogError( "unable to add If-Unmodified-Since header: %x", hr);
            return E_FAIL;
            }

        if (! HttpAddRequestHeaders(m_hOpenRequest, ACCEPT_ENCODING_STRING, -1L, HTTP_ADDREQ_FLAG_ADD | HTTP_ADDREQ_FLAG_REPLACE ))
            {
            SetError( SOURCE_HTTP_CLIENT_CONN, ERROR_STYLE_WIN32, GetLastError(), "add header: accept-encoding" );
            return E_FAIL;
            }
        }

    hr = AddRangeHeader( m_hOpenRequest, Offset, Offset + Length - 1 );
    if (FAILED(hr))
        {
        SetError( SOURCE_HTTP_CLIENT_CONN, ERROR_STYLE_HRESULT, hr, "AddRangeHeader" );
        return E_FAIL;
        }

    hr = SendRequest( m_hOpenRequest, m_wupdinfo );
    if (FAILED(hr))
        {
        SetError( SOURCE_HTTP_CLIENT_CONN, ERROR_STYLE_HRESULT, hr, "HttpSendRequest" );
        LogError( "HttpSendRequest failed in progressive download loop - offset=%I64d",
                   m_CurrentOffset );
        return E_FAIL;
        }

    //
    // The server sent a reply.  See if it was successful.
    //
    dwLength = sizeof(dwStatus);
    if (! HttpQueryInfo(m_hOpenRequest,
                HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER,
                (LPVOID)&dwStatus,
                &dwLength,
                NULL))
        {
        SetError( SOURCE_HTTP_CLIENT_CONN, ERROR_STYLE_WIN32, GetLastError(), "HttpQueryInfo" );
        return E_FAIL;
        }

    //
    // If the server file changed, stop downloading and indicate that to the caller.
    //
    if ( HTTP_STATUS_PRECOND_FAILED == dwStatus )
        {
        SetError( SOURCE_HTTP_SERVER, ERROR_STYLE_HTTP, dwStatus );
        m_pQMInfo->result = QM_SERVER_FILE_CHANGED;
        return E_FAIL;
        }

    //
    // If the server sent an error, fail.
    //
    if ( dwStatus != HTTP_STATUS_PARTIAL_CONTENT &&
         dwStatus != HTTP_STATUS_OK)
        {
        SetError( SOURCE_HTTP_SERVER, ERROR_STYLE_HTTP, dwStatus );
        return E_FAIL;
        }

    if (dwStatus == HTTP_STATUS_PARTIAL_CONTENT)
        {
        //
        // Now see whether the server understood the range request.
        // If it understands ranges, then it should have responded with a Content-Range header
        // matching our request.
        //
        hr = CheckReplyRange( m_hOpenRequest,
                              m_CurrentOffset,
                              m_CurrentOffset + Length - 1,
                              m_wupdinfo->FileSize
                              );
        if (FAILED(hr))
            {
            SetError( SOURCE_HTTP_CLIENT_CONN, ERROR_STYLE_HRESULT, hr, "Reply range" );
            return hr;
            }

        //
        // If the server appears not to support ranges, give up.
        //
        if (S_FALSE == hr)
            {
            m_wupdinfo->Disconnect();
            SetError( SOURCE_HTTP_SERVER, ERROR_STYLE_HRESULT, BG_E_INSUFFICIENT_RANGE_SUPPORT );
            return BG_E_INSUFFICIENT_RANGE_SUPPORT;
            }
        }
    else
        {
        //
        // The server replied with status 200.  This could mean that the server doesn't understand
        // range requests, or that the request encompassed the entire file.
        // (In this situation, IIS 5.0 and 6.0 return 206, but some Apache versions return 200.)
        // To distinguish them, make sure the starting offset of the request was zero and the
        // file length is equal to the original request length.
        //
        hr = CheckReplyLength( m_hOpenRequest, m_CurrentOffset, Length );
        if (FAILED(hr))
            {
            SetError( SOURCE_HTTP_CLIENT_CONN, ERROR_STYLE_HRESULT, hr, "content length" );
            return hr;
            }

        //
        // If the server did not include a Content-Length header, give up.
        //
        if (S_FALSE == hr)
            {
            m_wupdinfo->Disconnect();
            SetError( SOURCE_HTTP_SERVER, ERROR_STYLE_HRESULT, BG_E_INSUFFICIENT_RANGE_SUPPORT );
            return BG_E_INSUFFICIENT_RANGE_SUPPORT;
            }
        }


    //
    // Here is the code to switch to encoded range format, in case we need it later.
    //
    //    if (S_FALSE == hr)
    //        {
    //        LogDl( "server does not support ranges." );
    //
    //        m_wupdinfo->bHttp11 = FALSE;
    //        m_wupdinfo->bRange = FALSE;
    //
    //        //
    //        // We can't just drain the rest of the server response and send again, because the server
    //        // response is very likely the entire file.  Closing the connection will prevent the server
    //        // from writing, at max, any more than the client socket buffer size (16K).
    //        //
    //        m_wupdinfo->Disconnect();
    //
    //        *m_pQMInfo = m_wupdinfo->Connect();
    //        if (m_pQMInfo->IsSet())
    //            {
    //            return E_FAIL;
    //            }
    //
    //        HRESULT HrReadUrl = StartEncodedRangeRequest( Length );
    //
    //        if ( BG_E_INSUFFICIENT_HTTP_SUPPORT == HrReadUrl )
    //            {
    //            SetError( SOURCE_HTTP_SERVER, ERROR_STYLE_HRESULT, BG_E_INSUFFICIENT_RANGE_SUPPORT );
    //            return BG_E_INSUFFICIENT_RANGE_SUPPORT;
    //            }
    //
    //        return HrReadUrl;
    //        }

    //
    // Getting here means the range request succeeded.
    //

    return S_OK;
}

bool
CProgressiveDL::DoesErrorIndicateNoISAPI(
    DWORD dwHttpError
    )
{
    // This function is used on the HTTP return code on an attept
    // to use the isapi dll to estimate if the isapi is installed.
    // Note, that the ISAPI should only be used after trying
    // native HTTP/1.1 and this table assume 1.1 was tried first.

    // From RFC 2616

    switch( dwHttpError )
        {
        case 100: return false; // Continue
        case 101: return false; // Switching Protocols
        case 200: return false; // OK
        case 201: return false; // Created
        case 202: return false; // Accepted
        case 203: return false; // Non-Authoritative
        case 204: return false; // No Content
        case 205: return false; // Reset Context
        case 206: return false; // Partial Content
        case 300: return false; // Multiple Choices
        case 301: return false; // Moved Permanently
        case 302: return false; // Found
        case 303: return false; // See other
        case 304: return false; // Not Modified
        case 305: return false; // Use Proxy
        case 306: return false; // Unused
        case 307: return false; // Temporary Redirect
        case 400: return true;  // Bad Request
        case 401: return false; // Unauthorized
        case 402: return false; // Payment Required
        case 403: return false; // Forbidden
        case 404: return true;  // Not Found
        case 405: return false; // Method Not Allowed
        case 406: return false; // Not Acceptable
        case 407: return false; // Proxy Authentication Required
        case 408: return false; // Request Timeout
        case 409: return false; // Conflict
        case 410: return true;  // Gone
        case 411: return false; // Length Required
        case 412: return false; // Precondition Failed
        case 413: return false; // Request Entity Too Large
        case 414: return false; // Request URI too long
        case 415: return false; // Unsupported Media Type
        case 416: return false; // Requested Range Not Satisfiable
        case 417: return false; // Expectation Failed
        case 500: return true;  // Internal Server Error
        case 501: return true;  // Not Implemented
        case 502: return true;  // Bad Gateway
        case 503: return false; // Service Unavailable
        case 504: return false; // Gateway Timeout
        case 505: return false; // HTTP Version Not Supported

        default:
            // As indicated in the spec, map unknown codes
            // to first code in the catagory
            if ( dwHttpError >= 100 && dwHttpError < 200 )
                return DoesErrorIndicateNoISAPI( 100 );
            else if ( dwHttpError >= 200 && dwHttpError < 300 )
                return DoesErrorIndicateNoISAPI( 200 );
            else if ( dwHttpError >= 300 && dwHttpError < 400 )
                return DoesErrorIndicateNoISAPI( 300 );
            else if ( dwHttpError >= 400 && dwHttpError < 500 )
                return DoesErrorIndicateNoISAPI( 400 );
            else if ( dwHttpError >= 500 && dwHttpError < 500 )
                return DoesErrorIndicateNoISAPI( 500 );
            else
                // No clue what the error is, assume this has nothing to do with the ISAPI
                return false;
        }

}

BOOL
NeedRetry(
    QMErrInfo  * ErrInfo
    )

{
    BOOL bRetry = FALSE;

    if (ErrInfo->Source == SOURCE_HTTP_SERVER)
        {
        // Almost all of the 400 series HTTP errors( client errors ) are
        // fatal. A few such as request timeout may happen during
        // stress conditions...
        // Note that RFC 2616 says to handle unknown 400 errors as error 400.

        if ( ( ErrInfo->Code >= 400 ) &&
             ( ErrInfo->Code < 500 ) )
            {

            switch( ErrInfo->Code )
                {
                case 408: // request timeout
                case 409: // Conflict - Isn't really clear what this is about...
                    return TRUE;  // retry these error
                default:
                   return FALSE; // don't retry other 400

                }
            }
        }


    if ( ErrInfo->Style == ERROR_STYLE_HRESULT )
        {

        switch( LONG(ErrInfo->Code) )
            {
            // These codes indicate dynamic content or
            // an unsupported server so no retries are necessary.
            case BG_E_MISSING_FILE_SIZE:
            case BG_E_INSUFFICIENT_HTTP_SUPPORT:
            case BG_E_INSUFFICIENT_RANGE_SUPPORT:
            case HRESULT_FROM_WIN32( ERROR_INTERNET_SEC_CERT_ERRORS ):
            case HRESULT_FROM_WIN32( ERROR_INTERNET_INVALID_CA ):
            case HRESULT_FROM_WIN32( ERROR_INTERNET_SEC_CERT_CN_INVALID ):
            case HRESULT_FROM_WIN32( ERROR_INTERNET_SEC_CERT_DATE_INVALID ):
            case HRESULT_FROM_WIN32( ERROR_INTERNET_SEC_CERT_REV_FAILED ):
            case HRESULT_FROM_WIN32( ERROR_INTERNET_SEC_CERT_NO_REV ):
            case HRESULT_FROM_WIN32( ERROR_WINHTTP_SECURE_CERT_REVOKED ):
            case HRESULT_FROM_WIN32( ERROR_WINHTTP_SECURE_INVALID_CERT ):

            return FALSE;
            }

        }

    if (COMPONENT_TRANS == (ErrInfo->Source & COMPONENT_MASK))
        {
        return TRUE;
        }

    switch (ErrInfo->Style)
        {
        case ERROR_STYLE_WIN32:
            {
            switch (ErrInfo->Code)
                {
                case ERROR_NOT_ENOUGH_MEMORY:
                    return TRUE;
                }
            }
        }

    return FALSE;
}

HRESULT
CProgressiveDL::GetRemoteFileInformation(
    HANDLE hToken,
    LPCTSTR szURL,
    UINT64 *  pFileSize,
    FILETIME *pFileTime,
    QMErrInfo *pErrInfo,
    const PROXY_SETTINGS * pProxySettings,
    const CCredentialsContainer * Credentials,
    StringHandle HostId
    )
{
    *pFileSize = 0;
    memset( pFileTime, 0, sizeof(FILETIME) );
    pErrInfo->result = QM_IN_PROGRESS;

    HRESULT Hr = S_OK;

    try
        {
        CNestedImpersonation imp( hToken );

        auto_ptr<URL_INFO> UrlInfo = auto_ptr<URL_INFO>( ConnectToUrl( szURL, pProxySettings, Credentials, (const WCHAR*)HostId, pErrInfo ));

        if (!UrlInfo.get())
            {
            ASSERT( pErrInfo->IsSet() );
            throw ComError( E_FAIL );
            }

        //
        // Get file size and time stamp.
        //
        if (! GetRemoteResourceInformation( UrlInfo.get(), pErrInfo ))
            {
            ASSERT( pErrInfo->IsSet() );
            throw ComError( E_FAIL );
            }

        *pFileTime = UrlInfo.get()->UrlModificationTime;
        *pFileSize = UrlInfo.get()->FileSize;

        pErrInfo->result = QM_FILE_DONE;
        return S_OK;
        }
    catch( ComError Error )
        {
        Hr = Error.Error();

        if (!pErrInfo->IsSet())
            {
            pErrInfo->Set( SOURCE_HTTP_UNKNOWN, ERROR_STYLE_HRESULT, Hr );
            }

        if (NeedRetry(pErrInfo))
            {
            pErrInfo->result = QM_FILE_TRANSIENT_ERROR;
            }
        else
            {
            pErrInfo->result = QM_FILE_FATAL_ERROR;
            }
        return E_FAIL;
        }

    return Hr;
}


void
CProgressiveDL::SetError(
    ERROR_SOURCE  Source,
    ERROR_STYLE   Style,
    UINT64        Code,
    char *        comment
    )
{
    m_pQMInfo->Set( Source, Style, Code, comment );
}

void QMErrInfo::Log()
{
    LogDl( "errinfo: result=%d, error style=%d, code=0x%x, source=%x, description='%S'",
             result, (DWORD) Style, (DWORD) Code, (DWORD) Source, Description ? Description : L"" );
}

QMErrInfo::QMErrInfo(
    ERROR_SOURCE  Source,
    ERROR_STYLE   Style,
    UINT64        Code,
    char *        comment
    )
{
    result = QM_FILE_TRANSIENT_ERROR;
    Description = NULL;

    Set( Source, Style, Code, comment );
}

void
QMErrInfo::Set(
    ERROR_SOURCE  Source,
    ERROR_STYLE   Style,
    UINT64        Code,
    char *        comment
    )
{
    this->Source   = Source;
    this->Style    = Style;
    this->Code     = Code;

    LogWarning( " errinfo: error %s %s : style %d, source %x, code 0x%x",
                comment ? "in" : "",
                comment ? comment : "",
                (DWORD) Style,
                (DWORD) Source,
                (DWORD) Code
                );
}

HRESULT
OpenHttpRequest(
    LPCTSTR Verb,
    LPCTSTR Protocol,
    URL_INFO & Info,
    HINTERNET * phRequest
    )
{
    HINTERNET hRequest = 0;

    *phRequest = 0;

    try
        {
        LPCTSTR AcceptTypes[] = {_T("*/*"), NULL};

        if (! (hRequest = HttpOpenRequest( Info.hConnect, Verb,
                                           Info.UrlPath,
                                           Protocol,
                                           NULL,               //referer
                                           AcceptTypes,
                                           Info.dwFlags,
                                           0)))                //context
            {
            ThrowLastError();
            }

        #ifndef USE_WININET
        //
        // BUGBUG jroberts, 10-2-2001:
        // WinHttp sometimes mistakenly thinks a site is outside the org, and disallows NTLM.
        //
        DWORD flag = WINHTTP_AUTOLOGON_SECURITY_LEVEL_LOW;

        if (!WinHttpSetOption( hRequest,
                               WINHTTP_OPTION_AUTOLOGON_POLICY,
                               &flag,
                               sizeof(DWORD)
                               ))
            {
            ThrowLastError();
            }
        #endif

        *phRequest = hRequest;
        return S_OK;
        }
    catch ( ComError err )
        {
        SafeCloseInternetHandle( hRequest );
        return err.Error();
        }
}

HRESULT
SendRequest(
    HINTERNET hRequest,
    URL_INFO * Info
    )
{
    DWORD err = 0;

    PVOID Address = &err;

    try
        {
        if (!WinHttpSetOption( hRequest,
                               WINHTTP_OPTION_CONTEXT_VALUE,
                               &Address,
                               sizeof(PVOID)
                               ))
            {
            err = GetLastError();

            LogWarning( "can't set context option: %!winerr!", err );
            throw ComError( HRESULT_FROM_WIN32( err ));
            }

        //
        // Catch errors in the server certificate.
        //
        if (WINHTTP_INVALID_STATUS_CALLBACK  == WinHttpSetStatusCallback( hRequest,
                                                                          HttpRequestCallback,
                                                                          WINHTTP_CALLBACK_FLAG_SECURE_FAILURE,
                                                                          NULL
                                                                          ))
            {
            err = GetLastError();
            LogError("WinHttpSetStatusCallback failed %d", err );
            throw ComError( HRESULT_FROM_WIN32( err ));
            }

        bool fProxyCredentials = false;
        bool fServerCredentials = false;

retry:

        err = 0;

        RETURN_HRESULT( SetRequestProxy( hRequest, Info->ProxySettings ));
        RETURN_HRESULT( SetRequestProxy( Info->hInternet, Info->ProxySettings ));

        BOOL b = HttpSendRequest( hRequest, NULL, 0, NULL, 0 );

        // err is modified by the callback routine if something was wrong with the server certificate

        if (!b)
            {
            if (!err)
                {
                err = GetLastError();
                }
            LogError("SendRequest failed %d", err );
            }

        //
        // If the proxy failed, try the next proxy in the list.
        //
        if (IsPossibleProxyFailure( err ))
            {
            if (Info->ProxySettings->UseNextProxy())
                {
                fProxyCredentials = false;
                goto retry;
                }

            throw ComError( HRESULT_FROM_WIN32( err ));
            }

        //
        // If the request wasn't sent or the security callback routine reported an error, fail.
        //
        if (err)
            {
            throw ComError( HRESULT_FROM_WIN32( err ));
            }

        //
        // If the server or proxy server asked for auth information and we haven't already set it,
        // find matching credentials and try again.
        //
        switch (GetRequestStatus( hRequest ))
            {
            case HTTP_STATUS_PROXY_AUTH_REQ:
                {
                LogInfo("server returned HTTP_STATUS_PROXY_AUTH_REQ" );

                if (!fProxyCredentials && ApplyCredentials( hRequest, Info->Credentials, Info->UserName, Info->Password ))
                    {
                    fProxyCredentials = true;
                    goto retry;
                    }
                else
                    {
                    // return S_OK and the caller will find the status code
                    }
                break;
                }

            case HTTP_STATUS_DENIED:
                {
                LogInfo("server returned HTTP_STATUS_DENIED");

                if (!fServerCredentials && ApplyCredentials( hRequest, Info->Credentials, Info->UserName, Info->Password ))
                    {
                    fServerCredentials = true;
                    goto retry;
                    }
                else
                    {
                    // return S_OK and the caller will find the status code
                    }
                break;
                }
            }

        return S_OK;
        }
    catch ( ComError err )
        {
        return err.Error();
        }
}

HRESULT
GetResponseVersion(
    HINTERNET hRequest,
    unsigned * MajorVersion,
    unsigned * MinorVersion
    )
{
    HRESULT hr;

    CAutoString Value;

    wchar_t Template[] = L"HTTP/%u.%u";
    const MaxChars = RTL_NUMBER_OF( Template ) + INT_DIGITS + INT_DIGITS;

    hr = GetRequestHeader( hRequest,
                           WINHTTP_QUERY_VERSION,
                           WINHTTP_HEADER_NAME_BY_INDEX,
                           Value,
                           MaxChars
                           );
    if (FAILED(hr))
        {
        LogError("error %x retrieving the response version", hr);
        return BG_E_INSUFFICIENT_RANGE_SUPPORT;
        }

    if (hr == S_FALSE)
        {
        LogError("no response version!");
        return BG_E_INSUFFICIENT_RANGE_SUPPORT;
        }

    if (2 != swscanf(Value.get(), Template, MajorVersion, MinorVersion ))
        {
        LogError("invalid response version");
        return BG_E_INSUFFICIENT_RANGE_SUPPORT;
        }

    LogInfo("server HTTP version is %d.%d", *MajorVersion, *MinorVersion );

    return S_OK;
}

HRESULT
CheckReplyLength(
    HINTERNET hRequest,
    UINT64 CorrectOffset,
    UINT64 CorrectTotal
    )
{
    HRESULT hr;

    UINT64 ReplyTotal;

    CAutoString Value;

    if (CorrectOffset != 0)
        {
        LogError( "received a 200 reply when the requested offset is nonzero: %I64d", CorrectOffset );
        return BG_E_INSUFFICIENT_RANGE_SUPPORT;
        }

    wchar_t Template[] = L"%I64d";
    const MaxChars = RTL_NUMBER_OF( Template ) + INT64_DIGITS;

    hr = GetRequestHeader( hRequest,
                           WINHTTP_QUERY_CONTENT_LENGTH,
                           WINHTTP_HEADER_NAME_BY_INDEX,
                           Value,
                           MaxChars
                           );
    if (FAILED(hr))
        {
        LogError("error %x retrieving the content-length header", hr);
        return hr;
        }

    if (hr == S_FALSE)
        {
        LogWarning("no content-length header");
        return S_FALSE;
        }

    if (1 != swscanf(Value.get(), Template, &ReplyTotal))
        {
        LogError("invalid content-length header");
        return BG_E_INSUFFICIENT_RANGE_SUPPORT;
        }

    if (ReplyTotal != CorrectTotal)
        {
        LogError("incorrect content-length header: %S", Value.get());
        return BG_E_INSUFFICIENT_RANGE_SUPPORT;
        }

    return S_OK;
}

HRESULT
CheckReplyRange(
    HINTERNET hRequest,
    UINT64 CorrectStart,
    UINT64 CorrectEnd,
    UINT64 CorrectTotal
    )
{
    HRESULT hr;

    UINT64 RangeStart;
    UINT64 RangeEnd;
    UINT64 RangeTotal;

    CAutoString Value;

    wchar_t Template[] = L"bytes %I64d-%I64d/%I64d";
    const MaxChars = RTL_NUMBER_OF( Template ) + INT64_DIGITS + INT64_DIGITS + INT64_DIGITS;

    hr = GetRequestHeader( hRequest,
                           WINHTTP_QUERY_CONTENT_RANGE,
                           WINHTTP_HEADER_NAME_BY_INDEX,
                           Value,
                           MaxChars
                           );
    if (FAILED(hr))
        {
        LogError("error %x retrieving the content-range header", hr);
        return hr;
        }

    if (hr == S_FALSE)
        {
        LogWarning("no reply range header");
        return S_FALSE;
        }

    if (3 != swscanf(Value.get(), Template, &RangeStart, &RangeEnd, &RangeTotal))
        {
        LogError("invalid reply range header");
        return BG_E_INSUFFICIENT_RANGE_SUPPORT;
        }

    if (RangeStart != CorrectStart ||
        RangeEnd != CorrectEnd ||
        RangeTotal != CorrectTotal)
        {
        LogError("incorrect reply range header: %I64d-%I64d/%I64d", RangeStart, RangeEnd, RangeTotal);
        return BG_E_INSUFFICIENT_RANGE_SUPPORT;
        }

    return S_OK;
}

HRESULT
GetRequestHeader(
    HINTERNET hRequest,
    DWORD HeaderIndex,
    LPCWSTR HeaderName,
    CAutoString & Destination,
    size_t MaxChars
    )
/*

    Fetch an arbitrary header's value from the request, allocating a string to hold it.

Input:

    HeaderIndex and HeaderName follow the rules for WinHttpQueryHeaders() parameters
    dwInfoLevel and pwszName respectively.

Returns:

    S_OK: header found, and Destination holds the value.
    S_FALSE: header not found
    all others: an error occurred along the way

*/
{
    try
        {
        DWORD s;
        HRESULT hr;
        DWORD ValueLength;
        CAutoString Value;

        WinHttpQueryHeaders( hRequest, HeaderIndex, HeaderName, NULL, &ValueLength, WINHTTP_NO_HEADER_INDEX  );

        s = GetLastError();
        if (s == ERROR_WINHTTP_HEADER_NOT_FOUND)
            {
            return S_FALSE;
            }

        if (s != ERROR_INSUFFICIENT_BUFFER)
            {
            return HRESULT_FROM_WIN32( s );
            }

        if (ValueLength > ((MaxChars+1) * sizeof(wchar_t)))
            {
            return E_FAIL;
            }

        Value = CAutoString( new wchar_t[ ValueLength ] );

        if (!WinHttpQueryHeaders( hRequest, HeaderIndex, HeaderName, Value.get(), &ValueLength, WINHTTP_NO_HEADER_INDEX  ))
            {
            return HRESULT_FROM_WIN32( GetLastError() );
            }

        Destination = Value;

        return S_OK;
        }
    catch ( ComError err )
        {
        return err.Error();
        }
}

HRESULT
AddRangeHeader(
    HINTERNET hRequest,
    UINT64 Start,
    UINT64 End
    )
{
    static const TCHAR RangeTemplate[] =_T("Range: bytes=%I64d-%I64d\r\n");

    HRESULT hr;
    TCHAR szHeader[ RTL_NUMBER_OF(RangeTemplate) + INT64_DIGITS + INT64_DIGITS ];

    hr = StringCbPrintf(szHeader, sizeof(szHeader), RangeTemplate, Start, End);
    if (FAILED(hr))
        {
        LogError( "range header is too large for its buffer.  start %I64d, end %I64d", Start, End );
        return hr;
        }

    if (! HttpAddRequestHeaders( hRequest, szHeader, -1L, HTTP_ADDREQ_FLAG_ADD | HTTP_ADDREQ_FLAG_REPLACE))
        {
        return HRESULT_FROM_WIN32( GetLastError() );
        }

    return S_OK;
}

HRESULT
AddIf_Unmodified_SinceHeader(
    HINTERNET hRequest,
    const FILETIME &Time
    )
{
    const TCHAR szIfModifiedTemplate[] = _T("If-Unmodified-Since: %s\r\n");
    static TCHAR szIfModifiedHeader[ (sizeof(szIfModifiedTemplate) / sizeof(TCHAR)) + INTERNET_RFC1123_BUFSIZE*2 ];
    static TCHAR szIfModifiedTime[ INTERNET_RFC1123_BUFSIZE*2 ];

    HRESULT hr;

    SYSTEMTIME stFileCreationTime;
    if ( !FileTimeToSystemTime( &Time, &stFileCreationTime ) )
        {
        return HRESULT_FROM_WIN32( GetLastError() );
        }

    if ( !InternetTimeFromSystemTime( &stFileCreationTime, INTERNET_RFC1123_FORMAT, szIfModifiedTime,
                                      sizeof( szIfModifiedTime ) ) )
        {
        return HRESULT_FROM_WIN32( GetLastError() );
        }

    hr = StringCbPrintf( szIfModifiedHeader, sizeof(szIfModifiedHeader), szIfModifiedTemplate, szIfModifiedTime );
    if (FAILED(hr))
        {
        return HRESULT_FROM_WIN32( GetLastError() );
        }

    if (! HttpAddRequestHeaders( hRequest, szIfModifiedHeader, -1L, HTTP_ADDREQ_FLAG_ADD | HTTP_ADDREQ_FLAG_REPLACE ))
        {
        return HRESULT_FROM_WIN32( GetLastError() );
        }

    return S_OK;
}

bool
ApplyCredentials(
    HINTERNET hRequest,
    const CCredentialsContainer * Credentials,
    WCHAR UserName[],
    WCHAR Password[]
    )
{
    HRESULT hr;
    DWORD dwSupportedSchemes;
    DWORD dwPreferredScheme;
    DWORD dwTarget;

   if (!WinHttpQueryAuthSchemes( hRequest,
                                 &dwSupportedSchemes,
                                 &dwPreferredScheme,
                                 &dwTarget ))
       {
       if (GetLastError() == ERROR_INVALID_OPERATION)
           {
           // no schemes available at all
           LogWarning("the server listed no auth schemes");
           return false;
           }

       ThrowLastError();
       }

   LogInfo("target %d, preferred scheme %x, supported schemes %x", dwTarget, dwPreferredScheme, dwSupportedSchemes );

   //
   // First look for credentials supporting the preferred scheme.
   //
   if (ApplySchemeCredentials( hRequest, dwTarget, dwPreferredScheme, Credentials, UserName, Password ))
       {
       return true;
       }

   //
   // Look for any other credential scheme supported by both sides.
   //
   signed bit;
   for (bit=31; bit >= 0; --bit)
       {
       DWORD dwScheme = (1 << bit);

       if (0 != (dwSupportedSchemes & dwScheme))
           {
           if (ApplySchemeCredentials( hRequest, dwTarget, dwScheme, Credentials, UserName, Password ))
               {
               return true;
               }
           }
       }

   //
   // No matching security credential.
   //
   return false;
}

DWORD GetRequestStatus( HINTERNET hRequest )
{
    DWORD Status;
    DWORD dwLength = sizeof(Status);
    if (! HttpQueryInfo( hRequest,
                HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER,
                (LPVOID)&Status,
                &dwLength,
                NULL))
        {
        ThrowLastError();
        }

    return Status;
}

bool
SchemeFromWinHttp(
    DWORD Scheme,
    BG_AUTH_SCHEME * pScheme
    )
{
    switch (Scheme)
        {
        case WINHTTP_AUTH_SCHEME_BASIC:     *pScheme = BG_AUTH_SCHEME_BASIC;     return true;
        case WINHTTP_AUTH_SCHEME_DIGEST:    *pScheme = BG_AUTH_SCHEME_DIGEST;    return true;
        case WINHTTP_AUTH_SCHEME_NTLM:      *pScheme = BG_AUTH_SCHEME_NTLM;      return true;
        case WINHTTP_AUTH_SCHEME_NEGOTIATE: *pScheme = BG_AUTH_SCHEME_NEGOTIATE; return true;
        case WINHTTP_AUTH_SCHEME_PASSPORT:  *pScheme = BG_AUTH_SCHEME_PASSPORT;  return true;
        default:
            LogWarning("unknown WinHttp scheme 0x%x", Scheme );
            return false;
        }
}

BG_AUTH_TARGET TargetFromWinHttp(  DWORD Target )
{
    if (Target == WINHTTP_AUTH_TARGET_PROXY)
        {
        return BG_AUTH_TARGET_PROXY;
        }

    if (Target == WINHTTP_AUTH_TARGET_SERVER)
        {
        return BG_AUTH_TARGET_SERVER;
        }

    LogWarning("unknown WinHttp target 0x%x", Target );
    ASSERT( 0 );

    return BG_AUTH_TARGET_SERVER;
}

bool
ApplySchemeCredentials(
    HINTERNET hRequest,
    DWORD dwTarget,
    DWORD dwScheme,
    const CCredentialsContainer * Credentials,
    WCHAR UserName[],
    WCHAR Password[]
    )
{
    BG_AUTH_TARGET BitsTarget;
    BG_AUTH_SCHEME BitsScheme;
    BG_AUTH_CREDENTIALS * cred = 0;

    BitsTarget = TargetFromWinHttp( dwTarget );

    //
    // Translate the scheme into the BITS ID and see if a matching credential is available.
    //
    if (!SchemeFromWinHttp( dwScheme, &BitsScheme ))
        {
        // BITS doesn't understand this scheme.
        return false;
        }

    if (BitsScheme == BG_AUTH_SCHEME_BASIC && UserName && UserName[0])
        {
        // use credentials embedded in URL
        //
        }
    else
        {
        HRESULT hr;
        THROW_HRESULT( hr = Credentials->Find( BitsTarget, BitsScheme, &cred ));

        if (hr != S_OK)
            {
            // no credential available for this scheme.
            return false;
            }

        // use the credential in the dictionary.
        //
        UserName = cred->Credentials.Basic.UserName;
        Password = cred->Credentials.Basic.Password;
        }

    //
    // Apply the credentials we found.
    //
    LogInfo("found credentials for scheme %d", BitsScheme );

    if (!WinHttpSetCredentials( hRequest,
                                dwTarget,
                                dwScheme,
                                UserName,
                                Password,
                                NULL
                                ))
        {
        if (cred)
            {
            ScrubCredentials( *cred );
            }

        ThrowLastError();
        }

    if (cred)
        {
        ScrubCredentials( *cred );
        }

    return true;
}

#ifndef USE_WININET

DWORD
MapSecureHttpErrorCode(
    DWORD flags
    )
{
    if (flags & WINHTTP_CALLBACK_STATUS_FLAG_INVALID_CERT)
        {
        return ERROR_INTERNET_SEC_CERT_ERRORS;
        }

    if (flags & WINHTTP_CALLBACK_STATUS_FLAG_INVALID_CA)
        {
        return ERROR_INTERNET_INVALID_CA;
        }

    if (flags & WINHTTP_CALLBACK_STATUS_FLAG_CERT_CN_INVALID)
        {
        return ERROR_INTERNET_SEC_CERT_CN_INVALID;
        }

    if (flags & WINHTTP_CALLBACK_STATUS_FLAG_CERT_DATE_INVALID)
        {
        return ERROR_INTERNET_SEC_CERT_DATE_INVALID;
        }

    if (flags & WINHTTP_CALLBACK_STATUS_FLAG_CERT_REVOKED)
        {
        return ERROR_ACCESS_DENIED;
        }

    if (flags & WINHTTP_CALLBACK_STATUS_FLAG_CERT_REV_FAILED)
        {
        return ERROR_INTERNET_SEC_CERT_REV_FAILED;
        }

    if (flags & WINHTTP_CALLBACK_STATUS_FLAG_SECURITY_CHANNEL_ERROR)
        {
        return ERROR_INTERNET_INTERNAL_ERROR;
        }

    ASSERT( flags );

    if (flags)
        {
        return ERROR_ACCESS_DENIED;
        }

    return 0;
}

VOID CALLBACK
HttpRequestCallback(
    IN HINTERNET hInternet,
    IN DWORD_PTR dwContext,
    IN DWORD dwInternetStatus,
    IN LPVOID lpvStatusInformation OPTIONAL,
    IN DWORD dwStatusInformationLength
    )
{
    switch (dwInternetStatus)
        {
        case WINHTTP_CALLBACK_STATUS_SECURE_FAILURE:
            {
            DWORD * pErr = LPDWORD( dwContext );
            DWORD * pFlags = LPDWORD( lpvStatusInformation );

            ASSERT( pErr != NULL );

            LogWarning("SSL error: flags %x", *pFlags );

            *pErr = MapSecureHttpErrorCode( *pFlags );
            break;
            }
        default:
            LogWarning("bogus HTTP notification %x", dwInternetStatus );
            break;
        }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\newjob\downloader.h ===
/************************************************************************

Copyright (c) 2000 - 2000 Microsoft Corporation

Module Name :

    progressivedl.h

Abstract :

    Main header file for downloader.

Author :

Revision History :

 ***********************************************************************/

#pragma once

#define MIN(a, b)       (a>b ? b:a)
#define MAX(a, b)       (a>b ? a:b)

#define MAX_REPLY_DATA (2 * INTERNET_MAX_URL_LENGTH)

#define E_RETRY                     HRESULT_FROM_WIN32( ERROR_RETRY )
#define BG_E_HEADER_NOT_FOUND       HRESULT_FROM_WIN32( ERROR_HTTP_HEADER_NOT_FOUND )

//
// valid in HTTP 1.1, but not defined in the Windows-XP version of wininet.h
//
#define HTTP_STATUS_RANGE_NOT_SATISFIABLE    416

//----------------------------------------------------------------------

typedef HRESULT (*QMCALLBACK)(DWORD, DWORD, LPBYTE, DWORD);

#define             MAX_VIA_HEADER_LENGTH  300

#define FILE_DATA_BUFFER_LEN 63000

extern BYTE g_FileDataBuffer[];

//--------------------------------------------

struct URL_INFO
{
    HINTERNET           hInternet;
    HINTERNET           hConnect;

    FILETIME            UrlModificationTime;
    FILETIME            FileCreationTime;
    UINT64              FileSize;
    DWORD               dwFlags;

    bool                bHttp11;
    bool                bRange;
    bool                fProxy;

    //
    // Most of these could be stack variables, but they are too big.
    //

    TCHAR               HostName[INTERNET_MAX_URL_LENGTH + 1];

    // host-relative URL
    //
    TCHAR               UrlPath[INTERNET_MAX_URL_LENGTH + 1];

    INTERNET_PORT Port;

    // a copy of <UrlPath> with range information appended as parameters
    //
    TCHAR               BlockUrl[INTERNET_MAX_URL_LENGTH + 1];

    TCHAR               UserName[UNLEN + 1];
    TCHAR               Password[UNLEN + 1];

    PROXY_SETTINGS_CONTAINER * ProxySettings;

    CAutoString         ProxyHost;

    TCHAR               ViaHeader[ MAX_VIA_HEADER_LENGTH + 1];

    const CCredentialsContainer * Credentials;

    //--------

    URL_INFO(
        LPCTSTR a_Url,
        const PROXY_SETTINGS * a_ProxySettings,
        const CCredentialsContainer * a_Credentials,
        LPCTSTR HostId = NULL
        );

    ~URL_INFO();

    void Cleanup();

    QMErrInfo Connect();

    void Disconnect();

    BOOL
    GetProxyUsage(
        HINTERNET   hRequest,
        QMErrInfo   *pQMErrInfo
        );

};

//---------------------------------------------

class CUploadJob;

class CJobManager;

class ITransferCallback
{
public:

    virtual bool
    DownloaderProgress(
        UINT64 BytesTransferred,
        UINT64 BytesTotal
        ) = 0;

    virtual bool
    PollAbort() = 0;

    virtual bool
    UploaderProgress(
        UINT64 BytesTransferred
        ) = 0;

};

class Downloader
{
public:

    virtual HRESULT Download( LPCTSTR szURL,
                              LPCTSTR szDest,
                              UINT64  Offset,
                              ITransferCallback *CallBack,
                              QMErrInfo *pErrInfo,
                              HANDLE hToken,
                              BOOL   bThrottle,
                              const PROXY_SETTINGS * pProxySettings, // optional
                              const CCredentialsContainer * Credentials,
                              const StringHandle HostId = StringHandle() // optional
                              ) = 0;

    virtual HRESULT GetRemoteFileInformation(
        HANDLE hToken,
        LPCTSTR szURL,
        UINT64 *  pFileSize,
        FILETIME *pFileTime,
        QMErrInfo *pErrInfo,
        const PROXY_SETTINGS * pProxySettings, //optional
        const CCredentialsContainer * Credentials, // optional
        const StringHandle HostId = StringHandle() // optional
        ) = 0;

    virtual ~Downloader()  {}

protected:

};

HRESULT CreateHttpDownloader( Downloader **ppDownloader, QMErrInfo *pErrInfo );
void    DeleteHttpDownloader( Downloader *  pDownloader );

extern DWORD g_dwDownloadThread;
extern HWND ghPDWnd;

//
// conversion factor to go from time in milliseconds to time in 100-nanoseconds.
//
#define ONE_MSEC_IN_100_NSEC  (10 * 1000)

class CPeriodicTimer
{
public:

    CPeriodicTimer(
        LPSECURITY_ATTRIBUTES Security = NULL,
        BOOL ManualReset               = FALSE,
        LPCTSTR Name                   = NULL
        )
    {
        m_handle = CreateWaitableTimer( Security, ManualReset, Name );
        if (!m_handle)
            {
            ThrowLastError();
            }
    }

    ~CPeriodicTimer()
    {
        if (m_handle)
            {
            CloseHandle( m_handle );
            }
    }

    BOOL Start(
        LONG Period,
        BOOL fResume        = FALSE,
        PTIMERAPCROUTINE fn = NULL,
        LPVOID arg          = NULL
        )
    {
        LARGE_INTEGER Time;

        //
        // negative values are relative; positive values are absolute.
        // The period is in milliseconds, but the start time is in units of 100-nanoseconds,
        //
        Time.QuadPart = -1 * Period * ONE_MSEC_IN_100_NSEC;

        return SetWaitableTimer( m_handle, &Time, Period, fn, arg, fResume );
    }

    BOOL Stop()
    {
        return CancelWaitableTimer( m_handle );
    }

    BOOL Wait(
        LONG msec = INFINITE
        )
    {
        if (WAIT_OBJECT_0 != WaitForSingleObject( m_handle, msec ))
            {
            return FALSE;
            }

        return TRUE;
    }

private:

    HANDLE m_handle;
};

//
// Network rate is in bytes per second.
//
typedef float NETWORK_RATE;

class CNetworkInterface
{
public:

    //
    // snapshot indices
    //
    enum
    {
        BLOCK_START = 0,
        BLOCK_END,
        BLOCK_INTERVAL_END,
        BLOCK_COUNT
    };

    typedef float SECONDS;

    //
    // public interface
    //

    CNetworkInterface();

    void Reset();

    void SetInterfaceSpeed();

    HRESULT
    TakeSnapshot(
        int SnapshotIndex
        );

    HRESULT
    SetInterfaceIndex(
        const TCHAR host[]
        );

    BOOL
    SetTimerInterval(
        SECONDS interval
        );

    NETWORK_RATE GetInterfaceSpeed()
    {
        return m_ServerSpeed;
    }

    float GetPercentFree()
    {
        return m_PercentFree;
    }

    void ResetInterface()
    {
        m_InterfaceIndex = -1;
    }

    void Wait()      { m_Timer.Wait(); }
    void StopTimer() { m_Timer.Stop(); }

    void CalculateIntervalAndBlockSize( UINT64 MaxBlockSize );

    DWORD               m_BlockSize;

    SECONDS             m_BlockInterval;

private:

    static const NETWORK_RATE DEFAULT_SPEED;

    struct NET_SNAPSHOT
    {
        LARGE_INTEGER   TimeStamp;
        UINT   BytesIn;
        UINT   BytesOut;
    };

    //
    // index of the interface that Wininet would use to talk to the server.
    //
    DWORD           m_InterfaceIndex;

    //
    // the "start" and "end" pictures of network activity.
    //
    NET_SNAPSHOT    m_Snapshots[BLOCK_COUNT];

    //
    // the apparent speed of the connection to our server
    //
    NETWORK_RATE    m_ServerSpeed;

    //
    // The local interface's apparent speed
    //
    NETWORK_RATE    m_NetcardSpeed;

    //
    //
    //
    float           m_PercentFree;

    //
    // Error value from previous snapshots in the current series {BLOCK_START, BLOCK_END, INTERVAL_END}.
    //
    HRESULT         m_SnapshotError;

    //
    // true if all three snapshots in the current series are valid.
    // If so, then it is safe to calculate network speed and server speed.
    //
    bool            m_SnapshotsValid;

    MIB_IFROW       m_TempRow;

    //
    // The download thread sends only one packet per timer notification.
    // This is the timer.
    //
    CPeriodicTimer      m_Timer;

    enum DOWNLOAD_STATE
    {
        DOWNLOADED_BLOCK = 0x55,
        SKIPPED_ONE_BLOCK,
        SKIPPED_TWO_BLOCKS
    };

    enum DOWNLOAD_STATE m_state;

    static HRESULT
    FindInterfaceIndex(
        const TCHAR host[],
        DWORD * pIndex
        );

    float GetTimeDifference( int start, int finish );

    //throttle related

    DWORD
    BlockSizeFromInterval(
        SECONDS interval
        );

    SECONDS
    IntervalFromBlockSize(
        DWORD BlockSize
        );

};

/////////////////////////////////////////////////////////////////////////////
// CProgressiveDL
//
class CProgressiveDL : public Downloader
{
public:
    CProgressiveDL( QMErrInfo *pErrInfo );
    ~CProgressiveDL();

    // pure virtual method from class Downloader

    virtual HRESULT
    Download( LPCTSTR szURL,
              LPCTSTR szDest,
              UINT64  Offset,
              ITransferCallback * CallBack,
              QMErrInfo *pErrInfo,
              HANDLE hToken,
              BOOL   bThrottle,
              const PROXY_SETTINGS *pProxySettings,
              const CCredentialsContainer * Credentials,
              const StringHandle HostId = StringHandle()
              );

    virtual HRESULT
    GetRemoteFileInformation(
        HANDLE hToken,
        LPCTSTR szURL,
        UINT64 *  pFileSize,
        FILETIME *pFileTime,
        QMErrInfo *pErrInfo,
        const PROXY_SETTINGS * pProxySettings,
        const CCredentialsContainer * Credentials,
        const StringHandle HostId = StringHandle()
        );

// other methods

private:

    //download related

    BOOL
    OpenLocalDownloadFile( LPCTSTR Path,
                           UINT64  Offset,
                           UINT64  Size,
                           FILETIME UrlModificationTime
                           );

    BOOL CloseLocalFile();

    BOOL    WriteBlockToCache(LPBYTE lpBuffer, DWORD dwRead);

    BOOL    SetFileTimes();

    HRESULT
    DownloadFile(
        HANDLE  hToken,
        const PROXY_SETTINGS * ProxySettings,
        const CCredentialsContainer * Credentials,
        LPCTSTR Url,
        LPCWSTR Path,
        UINT64  Offset,
        StringHandle HostId
        );

    HRESULT GetNextBlock( );
    BOOL    DownloadBlock( void * Buffer, DWORD * pdwRead);

    HRESULT OpenConnection();
    void    CloseHandles();

    BOOL IsAbortRequested()
    {
        return m_Callbacks->PollAbort();
    }

    BOOL IsFileComplete()
    {
        if (m_CurrentOffset == m_wupdinfo->FileSize)
            {
            return TRUE;
            }

        return FALSE;
    }

    void ClearError();

    void
    SetError(
        ERROR_SOURCE  Source,
        ERROR_STYLE   Style,
        UINT64        Code,
        char *        comment = 0
        );

    BOOL IsErrorSet()
    {

        // If the file was aborted, the error wont
        // be set.
        if (QM_FILE_ABORTED == m_pQMInfo->result)
            {
            return TRUE;
            }

        if (QM_SERVER_FILE_CHANGED == m_pQMInfo->result )
            {
            return TRUE;
            }

        if (m_pQMInfo->Style != 0)
            {
            return TRUE;
            }

        return FALSE;
    }

    BOOL
    GetRemoteResourceInformation(
        URL_INFO * Info,
        QMErrInfo * pQMErrInfo
        );

    //
    // These are static so they they don't mess with member data accidentally
    //

    static bool
    DoesErrorIndicateNoISAPI(
        DWORD dwHttpError
        );

    HRESULT CreateBlockUrl( LPTSTR lpszNewUrl, DWORD Length);

    HRESULT StartEncodedRangeRequest( DWORD Length );

    HRESULT StartRangeRequest( DWORD Length );

    //--------------------------------------------------------------------

    HANDLE m_hFile;

    //download related

    URL_INFO    *   m_wupdinfo;

    UINT64          m_CurrentOffset;

    HINTERNET       m_hOpenRequest;

    QMErrInfo       *m_pQMInfo;

    ITransferCallback * m_Callbacks;

    BOOL            m_bThrottle;

    HRESULT DownloadForegroundFile();

public:

    //
    // Tracks network statistics.
    //
    CNetworkInterface   m_Network;

};

extern CACHED_AUTOPROXY * g_ProxyCache;



HRESULT
SendRequest(
    HINTERNET hRequest,
    URL_INFO * Info
    );

HRESULT
SetRequestCredentials(
    HINTERNET hRequest,
    const CCredentialsContainer & Container
    );

HRESULT
SetRequestProxy(
    HINTERNET hRequest,
    PROXY_SETTINGS_CONTAINER * ProxySettings
    );

HRESULT
OpenHttpRequest(
    LPCTSTR Verb,
    LPCTSTR Protocol,
    URL_INFO & Info,
    HINTERNET * phRequest
    );

URL_INFO *
ConnectToUrl(
    LPCTSTR          Url,
    const PROXY_SETTINGS * ProxySettings,
    const CCredentialsContainer * Credentials,
    LPCTSTR          HostId,
    QMErrInfo * pErrInfo
    );

HRESULT
GetRequestHeader(
    HINTERNET hRequest,
    DWORD HeaderIndex,
    LPCWSTR HeaderName,
    CAutoString & Destination,
    size_t MaxChars
    );

HRESULT
GetResponseVersion(
    HINTERNET hRequest,
    unsigned * MajorVersion,
    unsigned * MinorVersion
    );

HRESULT
AddRangeHeader(
    HINTERNET hRequest,
    UINT64 Start,
    UINT64 End
    );

HRESULT
AddIf_Unmodified_SinceHeader(
    HINTERNET hRequest,
    const FILETIME &Time
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\newjob\logontable.h ===
/************************************************************************

Copyright (c) 2000 - 2000 Microsoft Corporation

Module Name :

    logontable.h

Abstract :

    Header file for the logon table

Author :

Revision History :

 ***********************************************************************/

#pragma once

#include <wtypes.h>
#include <unknwn.h>

#include <utility>
#include <set>
#include <map>
#include "tasksched.h"

class CUser
{
public:

    CUser( HANDLE Token );
    ~CUser();

    long IncrementRefCount();
    long DecrementRefCount();

    void SetCookie( DWORD cookie )
    {
        _Cookie = cookie;
    }

    DWORD GetCookie()
    {
        return _Cookie;
    }

    DWORD CopyToken( HANDLE * pToken )
    {
        if (!DuplicateHandle( GetCurrentProcess(),
                              _Token,
                              GetCurrentProcess(),
                              pToken,
                              TOKEN_ALL_ACCESS,
                              FALSE,              // no inheritance
                              0                   // no extra options
                              ))
            {
            return GetLastError();
            }

        return 0;
    }

    HRESULT Impersonate()
    {
        if (!ImpersonateLoggedOnUser(_Token))
            {
            return HRESULT_FROM_WIN32( GetLastError() );
            }

        return S_OK;
    }

    SidHandle & QuerySid()
    {
        return _Sid;
    }

    void Dump();

    HRESULT
    LaunchProcess(
        StringHandle CmdLine
        );

private:

    long            _ReferenceCount;
    HANDLE          _Token;
    SidHandle       _Sid;
    DWORD           _Cookie;

    //--------------------------------------------------------------------

};


class CLoggedOnUsers
{
    class  CSessionList : public std::map<DWORD, CUser *>
    {
    public:

        void Dump();
    };

    class CUserList : public std::multimap<SidHandle, CUser *, CSidSorter>
    {
    public:

        ~CUserList();

        CUser *
        RemoveByCookie(
            SidHandle sid,
            DWORD cookie
            );

        bool
        RemovePair(
            SidHandle sid,
            CUser * user
            );

        CUser *
        FindSid(
            SidHandle sid
            );

        void Dump();
    };

public:

    CLoggedOnUsers( TaskScheduler & sched );
    ~CLoggedOnUsers();

    HRESULT AddServiceAccounts();
    HRESULT AddActiveUsers();

    HRESULT LogonSession( DWORD session );
    HRESULT LogoffSession( DWORD session );

    HRESULT LogonService( HANDLE token, DWORD * cookie );
    HRESULT LogoffService( SidHandle Sid, DWORD  cookie );

    CUser * FindUser( SidHandle sid, DWORD session );

    void Dump();

private:

    //--------------------------------------------------------------------

    TaskScheduler & m_TaskScheduler;
    CSessionList    m_ActiveSessions;
    CUserList       m_ActiveUsers;
    CUserList       m_ActiveServiceAccounts;
    long            m_CurrentCookie;

    CLogonNotification * m_SensNotifier;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\newjob\metadata.h ===
/************************************************************************

Copyright (c) 2000 - 2000 Microsoft Corporation

Module Name :

    metadata.h

Abstract :

    Main header for code for reading and writting to the metadata.

Author :

Revision History :

 ***********************************************************************/

// These functions may throw a ComError.
//
void SafeWriteFile( HANDLE hFile, void *pBuffer, DWORD dwSize );
void SafeReadFile( HANDLE hFile, void *pBuffer, DWORD dwSize );
void SafeWriteStringHandle( HANDLE hFile, StringHandle & str );
StringHandle SafeReadStringHandle( HANDLE hFile );

void SafeWriteFile( HANDLE hFile, WCHAR * str );
void SafeReadFile( HANDLE hFile, WCHAR ** pStr );


void SafeWriteSid( HANDLE hFile, SidHandle & Sid );
void SafeReadSid( HANDLE hFile, SidHandle & sid );

template <class T>
void SafeWriteFile( HANDLE hFile, T Data )
{
    SafeWriteFile( hFile, &Data, sizeof( Data ) );
}

template <class T>
void SafeReadFile( HANDLE hFile, T *pBuffer)
{
    SafeReadFile( hFile, pBuffer, sizeof(*pBuffer) );
}

void SafeWriteBlockBegin( HANDLE hFile, GUID BlockGuid );
void SafeWriteBlockEnd( HANDLE hFile, GUID BlockGuid );
void SafeReadBlockBegin( HANDLE hFile, GUID BlockGuid );
void SafeReadBlockEnd( HANDLE hFile, GUID BlockGuid );

//
// allows any one of several GUIDs.
//
int SafeReadGuidChoice( HANDLE hFile, const GUID * guids[] );


class CQmgrStateFiles
    {
    auto_FILE_HANDLE m_Files[2];
    auto_ptr<WCHAR> m_FileNames[2];
    UINT64 m_ExpandSize[2];
    INT64 m_OriginalFileSizes[2];
    DWORD m_CurrentIndex;

    static auto_ptr<WCHAR> GetNameFromIndex( DWORD dwIndex );
    static auto_FILE_HANDLE OpenMetadataFile( auto_ptr<WCHAR> FileName );

public:
    CQmgrStateFiles();
    HANDLE GetNextStateFile();
    void UpdateStateFile();
    HANDLE GetCurrentStateFile();

    void ExtendMetadata( INT64 ExtendAmount = ( METADATA_PREALLOC_SIZE + METADATA_PADDING ) );
    void ShrinkMetadata();
    };

class CQmgrReadStateFile
    {
private:
    CQmgrStateFiles & m_StateFiles;
    HANDLE m_FileHandle;

public:
    CQmgrReadStateFile( CQmgrStateFiles & StateFiles );
    HANDLE GetHandle() { return m_FileHandle;}
    void ValidateEndOfFile();
    };


class CQmgrWriteStateFile
    {
private:
    CQmgrStateFiles & m_StateFiles;
    HANDLE m_FileHandle;

public:
    CQmgrWriteStateFile( CQmgrStateFiles & StateFiles );
    HANDLE GetHandle() { return m_FileHandle;}
    void CommitFile();
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\newjob\netspeed.cpp ===
/************************************************************************

Copyright (c) 2000 - 2000 Microsoft Corporation

Module Name :

    netspeed.cpp

Abstract :

    Main source file for throttle control.

Author :

Revision History :


---> for small files, we need to feed the file size in to the block calculator,
     because the server-speed estimator will be incorrect if m_BlockSize is 65000
     but the download time is based on a file size of 2002 bytes.

 ***********************************************************************/


#include "stdafx.h"
#include <malloc.h>
#include <limits.h>

#if !defined(BITS_V12_ON_NT4)
#include "netspeed.tmh"
#endif

//
// the maximum % of the perceived bandwidth that BITS will use for itself
//
const float MAX_BANDWIDTH_FRACTION = 0.95f;

//
// timer periods in seconds
//
const float DEFAULT_BLOCK_INTERVAL = 2.0f;
const float MIN_BLOCK_INTERVAL = 0.001f;
const float MAX_BLOCK_INTERVAL = 5.0f;

//
// observed header sizes.  request = 250, reply = 300
//
#define REQUEST_OVERHEAD 550

//
// smallest block we will pull down
//
#define MIN_BLOCK_SIZE 2000

//
// size when we occasionally pull down a block on a full network
//
#define BUSY_BLOCK_SIZE 1500

//
// Very small blocks give unreliable speed measurements.
//
#define MIN_BLOCK_SIZE_TO_MEASURE 500

const NETWORK_RATE  CNetworkInterface::DEFAULT_SPEED = 1600.0f;

// Work around limitations of the protocol stack

const DWORD MAX_BLOCK_SIZE = 2147483648;

//------------------------------------------------------------------------

//
// The observed server speed is reported as the average of this many usable samples.
//
const float SERVER_SPEED_SAMPLE_COUNT = 3.0F;

/*

The algorithm used to determine the speed and loading of the network is as follows:

1.  After contacting the web site with Wininet calls, see whether an HTTP 1.1 "Via" header is present.
    If so, a proxy was used, and we locate the proper net card to talk with the proxy.  Otherwise,
    a proxy was not used, and we locate the proper net card to talk with the HTTP server itself.

2.  Chop time into 1/2-second intervals, and measure the interface's bytes-in and bytes-out count
    three times per interval: first at the beginning, just before a block is downloaded, second at
    the completion of the block, and third at the end of the interval.


*/

HRESULT
CNetworkInterface::TakeSnapshot(
    int StatIndex
    )
{
    DWORD s;
    ULONG size = 0;

    //
    // The network speed can be calculated only if all three snapshots succeeded.
    // We keep track of the error status of the current series of snapshots.
    //
    if (StatIndex == BLOCK_START)
        {
        m_SnapshotError = S_OK;
        m_SnapshotsValid = false;
        }

    m_TempRow.dwIndex = m_InterfaceIndex;
    DWORD dwGetIfEntryError = GetIfEntry( &m_TempRow );
    if ( dwGetIfEntryError )
        {
        LogWarning( "[%d] : GetIfRow(%d)  failed %!winerr!", StatIndex, m_InterfaceIndex, dwGetIfEntryError );
        m_SnapshotError = HRESULT_FROM_WIN32( dwGetIfEntryError );
        return m_SnapshotError;
        }

    QueryPerformanceCounter( &m_Snapshots[ StatIndex ].TimeStamp );

    m_Snapshots[ StatIndex ].BytesIn   = m_TempRow.dwInOctets;
    m_Snapshots[ StatIndex ].BytesOut  = m_TempRow.dwOutOctets;

    LogDl( "[%d] : in=%d, out=%d, timestamp=%d",
         StatIndex,
         m_Snapshots[ StatIndex ].BytesIn,
         m_Snapshots[ StatIndex ].BytesOut,
         m_Snapshots[ StatIndex ].TimeStamp.u.LowPart );

    if (StatIndex == BLOCK_INTERVAL_END &&
        m_SnapshotError == S_OK)
        {
        m_SnapshotsValid = true;
        }

    return S_OK;
}


float
CNetworkInterface::GetTimeDifference(
    int start,
    int finish
    )
{
    float TotalTime;

    TotalTime = m_Snapshots[ finish ].TimeStamp.QuadPart - m_Snapshots[ start ].TimeStamp.QuadPart;

    TotalTime /= g_GlobalInfo->m_PerformanceCounterFrequency.QuadPart;  // convert to seconds

    if (TotalTime <= 0)
        {
        // pretend it was half a tick.
        TotalTime = 1 / float(2 * g_GlobalInfo->m_PerformanceCounterFrequency.QuadPart);
        }

    return TotalTime;
}


CNetworkInterface::CNetworkInterface()
{
    Reset();
}

HRESULT
CNetworkInterface::SetInterfaceIndex(
    const TCHAR host[]
    )
{
    DWORD index;

    HRESULT Hr = FindInterfaceIndex( host, &index );
    if (FAILED(Hr))
        return Hr;

    if (m_InterfaceIndex != index)
        {
        m_InterfaceIndex = index;
        Reset();
        }

    return S_OK;
}

void
CNetworkInterface::Reset()
{
    m_ServerSpeed = DEFAULT_SPEED;
    m_NetcardSpeed = DEFAULT_SPEED;
    m_PercentFree = 0.5f;

    m_SnapshotsValid = false;
    m_SnapshotError = E_FAIL;
    m_state = DOWNLOADED_BLOCK;
}


void
CNetworkInterface::SetInterfaceSpeed()
{
    float TotalTime, ratio;
    NETWORK_RATE rate = 0;

    //
    // Adjust server speed based on block download stats.
    //
    if (m_SnapshotsValid && m_BlockSize)
        {
        float ExpectedTime = m_BlockInterval * m_PercentFree;

        //
        // Calculate interface speed from the time the last block took.
        //
        TotalTime = GetTimeDifference( BLOCK_START, BLOCK_END );

        if (ExpectedTime > 0)
            {
            ratio = ExpectedTime / TotalTime;

            rate = m_ServerSpeed * ratio;
            }
        else
            {
            // either m_PercentFree was zero, or the interval was zero.  The ordinary calculation
            // would always produce a ratio of zero and drag down our average speed incorrectly.

            // use strict bytes per second measure
            rate = m_BlockSize / TotalTime;
            if (rate < m_ServerSpeed)
                {
                rate = m_ServerSpeed;
                }
            }

        m_ServerSpeed *= (SERVER_SPEED_SAMPLE_COUNT-1) / SERVER_SPEED_SAMPLE_COUNT;
        m_ServerSpeed += (rate / SERVER_SPEED_SAMPLE_COUNT);

        LogDl("expected interval %f, actual= %f, rate= %!netrate!, avg %!netrate!",
              ExpectedTime, TotalTime, rate, m_ServerSpeed );
        }

    //
    // Adjust usage and netcard speed based on interval stats.
    //
    if (m_SnapshotsValid)
        {
        float Bytes;

        Bytes  = m_Snapshots[ BLOCK_END ].BytesIn  - m_Snapshots[ BLOCK_START ].BytesIn;
        Bytes += m_Snapshots[ BLOCK_END ].BytesOut - m_Snapshots[ BLOCK_START ].BytesOut;

        ASSERT( Bytes >= 0 );

        TotalTime = GetTimeDifference( BLOCK_START, BLOCK_END );

        rate = Bytes/TotalTime;

        // use whichever estimate is larger

        if (rate < m_ServerSpeed)
            {
            rate = m_ServerSpeed;
            }

        if (m_NetcardSpeed == 0)
            {
            m_NetcardSpeed = rate;
            }
        else
            {
            if (rate < m_NetcardSpeed * 0.9f)
                {
                //
                // If the rate drops precipitously, it's probably just a quiet moment on the Net;
                // a strict average would unduly lower our estimated throughput.
                // But reduce the average a little in case it's a long-term slowdown.  If so,
                // eventually the average will be lowered enough that the incoming rates are greater
                // than m_NetcardSpeed / 2.
                //
                rate = m_NetcardSpeed * 0.9f;
                }

            //
            // Keep a running average of the perceived rate.
            //
            m_NetcardSpeed *= (SERVER_SPEED_SAMPLE_COUNT-1) / SERVER_SPEED_SAMPLE_COUNT;
            m_NetcardSpeed += (rate / SERVER_SPEED_SAMPLE_COUNT);
            }

        LogDl("bandwidth: bytes %f, time %f, rate %f, avg. %f", Bytes, TotalTime, rate, m_NetcardSpeed);

        //
        // Subtract our usage from the calculated usage.  Compare usage to top speed to get free bandwidth.
        //
        Bytes  = m_Snapshots[ BLOCK_INTERVAL_END ].BytesIn  - m_Snapshots[ BLOCK_START ].BytesIn;
        Bytes += m_Snapshots[ BLOCK_INTERVAL_END ].BytesOut - m_Snapshots[ BLOCK_START ].BytesOut;
        Bytes -= m_BlockSize;

        if (Bytes < 0)
            {
            Bytes = 0;
            }

        TotalTime = GetTimeDifference( BLOCK_START, BLOCK_INTERVAL_END );

        rate = Bytes/TotalTime;

        m_PercentFree = 1 - (rate / m_NetcardSpeed);
        }

    LogDl("usage: %f / %f, percent free %f", rate, m_NetcardSpeed, m_PercentFree);

    if (m_PercentFree < 0)
        {
        m_PercentFree = 0;
        }
    else if (m_PercentFree > MAX_BANDWIDTH_FRACTION)      // never monopolize the net
        {
        m_PercentFree = MAX_BANDWIDTH_FRACTION;
        }
}

//------------------------------------------------------------------------

DWORD
CNetworkInterface::BlockSizeFromInterval(
    SECONDS interval
    )
{
    NETWORK_RATE FreeBandwidth = GetInterfaceSpeed() * GetPercentFree() * interval;

    if (FreeBandwidth <= REQUEST_OVERHEAD)
        {
        return 0;
        }

    return FreeBandwidth - REQUEST_OVERHEAD;
}

CNetworkInterface::SECONDS
CNetworkInterface::IntervalFromBlockSize(
    DWORD BlockSize
    )
{
    NETWORK_RATE FreeBandwidth = GetInterfaceSpeed() * GetPercentFree();

    BlockSize += REQUEST_OVERHEAD;

    if (BlockSize / MAX_BLOCK_INTERVAL > FreeBandwidth )
        {
        return -1;
        }

    return BlockSize / FreeBandwidth;
}

void
CNetworkInterface::CalculateIntervalAndBlockSize(
    UINT64 MaxBlockSize
    )
{
    MaxBlockSize = min( MaxBlockSize, MAX_BLOCK_SIZE );

    if (MaxBlockSize == 0)
        {
        m_BlockInterval = 0;
        m_BlockSize     = 0;

        SetTimerInterval( m_BlockInterval );
        LogDl( "block %d bytes, interval %f seconds", m_BlockSize, m_BlockInterval );
        return;
        }

    //
    // Calculate new block size from the average interface speed.
    //
    DWORD OldState = m_state;

    m_BlockInterval = DEFAULT_BLOCK_INTERVAL;
    m_BlockSize     = BlockSizeFromInterval( m_BlockInterval );

    if (m_BlockSize > MaxBlockSize)
        {
        m_BlockSize     = MaxBlockSize;
        m_BlockInterval = IntervalFromBlockSize( m_BlockSize );

        ASSERT( m_BlockInterval > 0 );
        }
    else if (m_BlockSize < MIN_BLOCK_SIZE)
        {
        m_BlockSize     = min( MIN_BLOCK_SIZE, MaxBlockSize );
        m_BlockInterval = IntervalFromBlockSize( m_BlockSize );
        }

    if (m_BlockInterval < 0)
        {
        m_BlockSize = 0;
        }

    //
    // choose the new block download state.
    //
    if (m_BlockSize > 0)
        {
        m_state = DOWNLOADED_BLOCK;
        }
    else
        {
        //
        // The first time m_BlockSize is set to zero, retain the default interval.
        // If blocksize is zero twice in a row, expand to MAX_BLOCK_INTERVAL.
        // Then force a small download.
        //
        switch (OldState)
            {
            case DOWNLOADED_BLOCK:
                {
                m_BlockInterval = DEFAULT_BLOCK_INTERVAL;
                m_state         = SKIPPED_ONE_BLOCK;
                break;
                }

            case SKIPPED_ONE_BLOCK:
                {
                m_BlockInterval = MAX_BLOCK_INTERVAL;
                m_state         = SKIPPED_TWO_BLOCKS;
                break;
                }

            case SKIPPED_TWO_BLOCKS:
                {
                m_BlockSize     = min( BUSY_BLOCK_SIZE, MaxBlockSize);
                m_BlockInterval = MAX_BLOCK_INTERVAL;
                m_state         = DOWNLOADED_BLOCK;
                break;
                }

            default:
                ASSERT( 0 );
            }
        }

    SetTimerInterval( m_BlockInterval );

    LogDl( "block %d bytes, interval %f seconds", m_BlockSize, m_BlockInterval );

    ASSERT( m_BlockSize <= MaxBlockSize );
}

BOOL
CNetworkInterface::SetTimerInterval(
    SECONDS interval
    )
{
    DWORD msec = interval*1000;

    if (msec <= 0)
        {
        msec = MIN_BLOCK_INTERVAL;
        }

    LogDl( "%d milliseconds", msec );

    if (FALSE == m_Timer.Start( msec ))
        {
        return FALSE;
        }

    return TRUE;
}

HRESULT
CNetworkInterface::FindInterfaceIndex(
    const TCHAR host[],
    DWORD * pIndex
    )
{
    //related to finding statistics
    /* Use GetBestInterface with some IP address to get the index. Double check that this index
     * occurs in the output of the IP Address table and look it up in the results of GetIfTable.
     */

    #define AOL_ADAPTER         _T("AOL Adapter")
    #define AOL_DIALUP_ADAPTER  _T("AOL Dial-Up Adapter")

    BOOL bFound = FALSE;
    BOOL bAOL = FALSE;

    unsigned i;
    DWORD   dwAddr;

    ULONG  HostAddress;
    struct sockaddr_in dest;

    DWORD dwIndex = -1;
    static TCHAR szIntfName[512];

    *pIndex = -1;

    try
        {
        //
        // Translate the host name into a SOCKADDR.
        //

        unsigned length = 3 * lstrlen(host);

        CAutoStringA AsciiHost ( new char[ length ]);

        if (! WideCharToMultiByte( CP_ACP,
                                   0,       // no flags
                                   host,
                                   -1,      // use strlen
                                   AsciiHost.get(),
                                   length,  // use strlen
                                   NULL,    // no default char
                                   NULL     // no default char
                                   ))
            {
            DWORD dwError = GetLastError();
            LogError( "Unicode conversion failed %!winerr!", dwError );
            return HRESULT_FROM_WIN32( dwError );
            }

        HostAddress = inet_addr( AsciiHost.get() );
        if (HostAddress == -1)
            {
            struct hostent *pHostEntry = gethostbyname( AsciiHost.get() );

            if (pHostEntry == 0)
                {
                DWORD dwError = WSAGetLastError();
                LogError( "failed to find host '%s': %!winerr!", AsciiHost.get(), dwError );
                return HRESULT_FROM_WIN32( dwError );
                }

            HostAddress = *(unsigned long *)pHostEntry->h_addr;
            }
        }
    catch ( ComError err )
        {
        LogError( "exception 0x%x finding server IP address", err.Error() );
        return err.Error();
        }

    //for remote addr
    dest.sin_addr.s_addr = HostAddress;
    dest.sin_family = AF_INET;
    dest.sin_port = 80;

    DWORD dwGetBestInterfaceError = GetBestInterface(dest.sin_addr.s_addr, &dwIndex);

    if (dwGetBestInterfaceError != NO_ERROR)
        {
        LogError( "GetBestInterface failed with error %!winerr!, might be Win95", dwGetBestInterfaceError);

        //manually parse the routing table

        ULONG size = 0;
        DWORD dwIpForwardError = GetIpForwardTable(NULL, &size, FALSE);
        if (dwIpForwardError != ERROR_INSUFFICIENT_BUFFER)
            {
            LogError( "sizing GetIpForwardTable failed %!winerr!", dwIpForwardError );
            return HRESULT_FROM_WIN32( dwIpForwardError );
            }


        auto_ptr<MIB_IPFORWARDTABLE> pIpFwdTable((PMIB_IPFORWARDTABLE)new char[size]);
        if ( !pIpFwdTable.get() )
            {
            LogError( "out of memory getting %d bytes", size);
            return E_OUTOFMEMORY;
            }

        dwIpForwardError = GetIpForwardTable(pIpFwdTable.get(), &size, TRUE);

        if (dwIpForwardError == NO_ERROR)    //sort by dest addr
            {
            //perform bitwise AND of dest address with netmask and see if it matches network dest
            //todo check for multiple matches and then take longest mask
            for (i=0; i < pIpFwdTable->dwNumEntries; i++)
                {
                if ((dest.sin_addr.s_addr & pIpFwdTable->table[i].dwForwardMask) == pIpFwdTable->table[i].dwForwardDest)
                    {
                    dwIndex = pIpFwdTable->table[i].dwForwardIfIndex;
                    break;
                    }
                }

            if (dwIndex == -1)
                {
                // no match
                return HRESULT_FROM_WIN32( ERROR_NETWORK_UNREACHABLE );
                }
            }
        else
            {
            LogError( "GetIpForwardTable failed with error %!winerr!, exiting", dwIpForwardError );
            return HRESULT_FROM_WIN32( dwIpForwardError );
            }
        }

    //
    // At this point dwIndex should be correct.
    //
    ASSERT( dwIndex != -1 );

#if DBG
    try
        {
        //
        // Discover the local IP address for the correct interface.
        //
        ULONG size = 0;
        DWORD dwGetIpAddr = GetIpAddrTable(NULL, &size, FALSE);
        if (dwGetIpAddr != ERROR_INSUFFICIENT_BUFFER)
            {
            LogError( "GetIpAddrTable #1 returned %!winerr!", dwGetIpAddr );
            return HRESULT_FROM_WIN32( dwGetIpAddr );
            }

        auto_ptr<MIB_IPADDRTABLE> pAddrTable( (PMIB_IPADDRTABLE) new char[size] );

        dwGetIpAddr = GetIpAddrTable(pAddrTable.get(), &size, TRUE);
        if (dwGetIpAddr != NO_ERROR)
            {
            LogError( "GetIpAddrTable #2 returned %!winerr!", dwGetIpAddr );
            return HRESULT_FROM_WIN32( dwGetIpAddr );
            }

        for (i=0; i < pAddrTable->dwNumEntries; i++)
            {
            if (dwIndex == pAddrTable->table[i].dwIndex)
                {
                in_addr address;

                address.s_addr = pAddrTable->table[i].dwAddr;

                LogDl( "Throttling on interface with IP address - %s", inet_ntoa( address ));
                break;
                }
            }

        if (i >= pAddrTable->dwNumEntries)
            {
            LogWarning( "can't find interface with index %d in the IP address table", dwIndex );
            }
        }
    catch ( ComError err )
        {
        LogWarning("unable to print the local IP address due to exception %x", err.Error() );
        }
#endif // DBG

    //
    // See if the adapter in question is the AOL adapter.  If so, use the AOL dial-up adapter instead.
    //

    static MIB_IFROW s_TempRow;
    s_TempRow.dwIndex = dwIndex;

    DWORD dwEntryError = GetIfEntry( &s_TempRow );
    if ( NO_ERROR != dwEntryError )
        {
        LogError( "GetIfEntry(%d) returned %!winerr!", dwIndex, dwEntryError );
        return HRESULT_FROM_WIN32( dwEntryError );
        }

    if (lstrcmp( LPCWSTR(s_TempRow.bDescr), AOL_ADAPTER) == 0)
        {
        LogWarning( "found AOL adapter, searching for dial-up adapter...");

        dwIndex = -1;

        ULONG size = 0;
        DWORD dwGetIfTableError = GetIfTable( NULL, &size, FALSE );

        if (dwGetIfTableError != ERROR_INSUFFICIENT_BUFFER)
            {
            LogError( "GetIfTable #2 returned %!winerr!", dwGetIfTableError );
            return HRESULT_FROM_WIN32( dwGetIfTableError );
            }

        auto_ptr<MIB_IFTABLE> pIfTable( (PMIB_IFTABLE) new char[size] );
        if ( !pIfTable.get() )
            {
            LogError( "out of memory getting %d bytes", size);
            return E_OUTOFMEMORY;
            }

        dwGetIfTableError = GetIfTable( pIfTable.get(), &size, FALSE );
        if ( NO_ERROR != dwGetIfTableError )
            {
            LogError( "GetIfTable #2 returned %!winerr!", dwGetIfTableError );
            return HRESULT_FROM_WIN32( dwGetIfTableError );
            }

        for (i=0; i < pIfTable->dwNumEntries; ++i)
            {
            if (lstrcmp( LPCWSTR(pIfTable->table[i].bDescr), AOL_DIALUP_ADAPTER) == 0)
                {
                dwIndex = pIfTable->table[i].dwIndex;
                break;
                }
            }
        }

    ASSERT( dwIndex != -1 );

    *pIndex = dwIndex;

    LogDl( "using interface index %d", dwIndex );
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\newjob\stdafx.h ===
/************************************************************************

Copyright (c) 2000 - 2000 Microsoft Corporation

Module Name :

    stdafx.h

Abstract :

    Main header file for QMGR.

Author :

Revision History :

 ***********************************************************************/

#pragma once
#if !defined(__QMGR_QMGR_STDAFX__)

#define INITGUID

// Global Headers
#include<nt.h>
#include<ntrtl.h>
#include<nturtl.h>

#include <windows.h>
#include <olectl.h>
#include <objbase.h>
#include <docobj.h>
//shell related
#include <shlwapi.h>            //for PathFindFileName
#include <shlguid.h>            //for CGID_ShellServiceObject

#include <tchar.h>
#include <lmcons.h>
#include <setupapi.h>
#include <inseng.h>

#ifdef USE_WININET
#include <wininet.h>
#else
#include "winhttp.h"
#include "inethttp.h"
#endif

#include <coguid.h>
#include <sens.h>
#include <sensevts.h>
#include <eventsys.h>

#include <winsock2.h>
#include <iphlpapi.h>
#include <bitsmsg.h>
#include <memory>

#include "qmgrlib.h"
#include "metadata.h"

#include "bits.h"
#include "bits1_5.h"
#include "locks.hxx"
#include "caddress.h"
#include "cmarshal.h"
#include "ccred.h"
#include "proxy.h"
#include "downloader.h"
#include "uploader.h"
#include "csd.h"
#include "cunknown.h"
#include "csens.h"
#include "logontable.h"
#include "tasksched.h"
#include "cfile.h"
#include "cerror.h"
#include "cjob.h"
#include "cenum.h"
#include "drizcpat.h"
#include "cmanager.h"

using namespace std;

#define GUIDSTR_MAX (1+ 8 + 1 + 4 + 1 + 4 + 1 + 4 + 1 + 12 + 1 + 1)

inline void SafeFreeBSTR( BSTR & p) { if (NULL != (p)) { SysFreeString(p); p = NULL; } }

#define QM_STATUS_FILE_ERROR        0x00000004#

// Global vars
extern long g_cLocks;
extern long g_cComponents;
extern HINSTANCE g_hinstDll;

// Macros
#ifndef ARRAYSIZE
#define ARRAYSIZE(x)   (sizeof((x))/sizeof((x)[0]))
#endif

HRESULT GlobalLockServer(BOOL fLock);

#endif //__QMGR_QMGR_STDAFX__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\newjob\proxy.h ===
inline DWORD
ProxyUsageFromJobProxyUsage(
    BG_JOB_PROXY_USAGE JobUsage
    )
{
    switch( JobUsage )
        {
        case BG_JOB_PROXY_USAGE_PRECONFIG: return INTERNET_OPEN_TYPE_PRECONFIG;
        case BG_JOB_PROXY_USAGE_NO_PROXY:  return INTERNET_OPEN_TYPE_DIRECT;
        case BG_JOB_PROXY_USAGE_OVERRIDE:  return INTERNET_OPEN_TYPE_PROXY;
        default:                           ASSERT( 0 ); return INTERNET_OPEN_TYPE_DIRECT;
        }
}


struct PROXY_SETTINGS
{
   BG_JOB_PROXY_USAGE   ProxyUsage;
   LPTSTR               ProxyList;
   LPTSTR               ProxyBypassList;

   PROXY_SETTINGS()
   {
       ProxyUsage = BG_JOB_PROXY_USAGE_PRECONFIG;

       ProxyList       =  NULL;
       ProxyBypassList =  NULL;
   }

   ~PROXY_SETTINGS()
   {
       delete ProxyList;
       delete ProxyBypassList;
   }
};

class PROXY_SETTINGS_CONTAINER
{
    DWORD           m_ProxyUsage;
    StringHandle    m_BypassList;
    StringHandle    m_MasterProxyList;
    DWORD           m_AccessType;

    StringHandle    m_ProxyList;
    LPWSTR          m_CurrentProxy;
    LPWSTR          m_TokenCursor;

public:

    PROXY_SETTINGS_CONTAINER(
        LPCWSTR Url,
        const PROXY_SETTINGS * ProxySettings
        );

    bool UseNextProxy()
    {
        m_CurrentProxy = m_ProxyList.GetToken( m_TokenCursor, _T("; "), &m_TokenCursor );
        if (m_CurrentProxy == NULL)
            {
            return false;
            }

        return true;
    }

    void ResetCurrentProxy()
    {
        m_ProxyList = m_MasterProxyList.Copy();

        m_CurrentProxy = m_ProxyList.GetToken( NULL, _T(";"), &m_TokenCursor );
    }

    DWORD GetProxyUsage()
    {
        return m_ProxyUsage;
    }

    LPCWSTR GetCurrentProxy()
    {
        return m_CurrentProxy;
    }

    LPCWSTR GetProxyList()
    {
        return m_MasterProxyList;
    }

    LPCWSTR GetBypassList()
    {
        if (static_cast<LPCWSTR>(m_BypassList)[0] == 0)
            {
            return NULL;
            }

        return m_BypassList;
    }
};

class CACHED_AUTOPROXY
{
public:

    // a cache entry lasts for 5 minutes.
    //
    const static CACHED_PROXY_LIFETIME_IN_MSEC = (5 * 60 * 1000);

    //----------------------------------------------------------

    inline CACHED_AUTOPROXY()
    {
        m_fValid = false;
        m_TimeStamp = 0;
        m_hInternet = 0;

        ZeroMemory(&m_ProxyInfo, sizeof(m_ProxyInfo));

        m_hInternet = InternetOpen( C_BITS_USER_AGENT,
                                    INTERNET_OPEN_TYPE_PRECONFIG,
                                    NULL,  // proxy list
                                    NULL,  // proxy bypass list
                                    0 );
        if (!m_hInternet)
            {
            ThrowLastError();
            }
    }

    inline ~CACHED_AUTOPROXY()
    {
        Clear();

        if (m_hInternet)
            {
            InternetCloseHandle( m_hInternet );
            }
    }

    void Clear();

    HRESULT
    Generate(
        const TCHAR Host[]
        );

    LPCWSTR GetProxyList()
    {
        return m_ProxyInfo.lpszProxy;
    }

    LPCWSTR GetBypassList()
    {
        return m_ProxyInfo.lpszProxyBypass;
    }

    DWORD GetAccessType()
    {
        return m_ProxyInfo.dwAccessType;
    }

protected:

    //
    // m_ProxyInfo contains valid data.
    //
    bool m_fValid;

    //
    // The host used to calculate the proxy value.
    //
    StringHandleT   m_HostName;

    //
    // The results of the proxy calculation.
    //
    WINHTTP_PROXY_INFO m_ProxyInfo;

    //
    // Time of last update.
    //
    long m_TimeStamp;

    HINTERNET m_hInternet;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\newjob\metadata.cpp ===
/************************************************************************

Copyright (c) 2000 - 2000 Microsoft Corporation

Module Name :

    metadata.cpp

Abstract :

    Main code for reading and writting to the metadata.

Author :

Revision History :

NOTES:

   For robustness, the code preallocates disk space at the begining of a
change which might have a large impact on the metadata file size.  This
preallocation eliminates most of the errors which can occure during the serialize
operation. After serializing, metedata files are shrunk to the size used.  The
metadata files are not expanded for operations such as Resume which won't have
a large effect on the file sizes.  Instead a 4K pad is maintained at the end for
these operations to use.

  Several of the check in the code can be clasified as paranoia checks.

 ***********************************************************************/

#include "stdafx.h"
#include <malloc.h>
#include <sddl.h>
#include <limits>

#if !defined(BITS_V12_ON_NT4)
#include "metadata.tmh"
#endif

void BITSSetEndOfFile( HANDLE File )
{
    if ( !SetEndOfFile( File ) )
        {
        HRESULT Hr = HRESULT_FROM_WIN32( GetLastError() );
        LogError( "SetEndOfFile failed, error %!winerr!", Hr );
        throw ComError( Hr );
        }
}

INT64 BITSSetFilePointer(
    HANDLE File,
    INT64 Offset,
    DWORD MoveMethod
)
{
    LARGE_INTEGER LargeIntegerOffset;
    LargeIntegerOffset.QuadPart = Offset;

    LARGE_INTEGER LargeIntegerNewPointer;

    if ( !SetFilePointerEx( File, LargeIntegerOffset, &LargeIntegerNewPointer, MoveMethod ) )
        {
        HRESULT Hr = HRESULT_FROM_WIN32( GetLastError() );
        LogError( "SetFilePointerEx failed, error %!winerr!", Hr );
        throw ComError( Hr );
        }

    return LargeIntegerNewPointer.QuadPart;
}

INT64 BITSGetFileSize( HANDLE File )
{

    LARGE_INTEGER LargeIntegerSize;

    if ( !GetFileSizeEx( File, &LargeIntegerSize ) )
        {
        HRESULT Hr = HRESULT_FROM_WIN32( GetLastError() );
        LogError( "GetFileSize failed, error %!winerr!", Hr );
        throw ComError( Hr );
        }

    return LargeIntegerSize.QuadPart;
}

void BITSFlushFileBuffers( HANDLE File )
{
    if ( !FlushFileBuffers( File ) )
        {
        HRESULT Hr = HRESULT_FROM_WIN32( GetLastError() );
        LogError( "FlushFileBuffers failed, error %!winerr!", Hr );
        throw ComError( Hr );
        }
}

bool
printable( char c )
{
    if ( c < 32 )
        {
        return false;
        }

    if ( c > 126 )
        {
        return false;
        }

    return true;
}

void
DumpBuffer(
          void * Buffer,
          unsigned Length
          )
{
    if( false == LogLevelEnabled( LogFlagSerialize ) )
       {
        return;
       }

    const BYTES_PER_LINE = 16;

    unsigned char FAR *p = (unsigned char FAR *) Buffer;

    //
    // 3 chars per byte for hex display, plus an extra space every 4 bytes,
    // plus a byte for the printable representation, plus the \0.
    //
    char Outbuf[BYTES_PER_LINE*3+BYTES_PER_LINE/4+BYTES_PER_LINE+1];
    Outbuf[0] = 0;
    Outbuf[sizeof(Outbuf)-1] = 0;
    char * HexDigits = "0123456789abcdef";

    unsigned Index;
    for ( unsigned Offset=0; Offset < Length; Offset++ )
        {
        Index = Offset % BYTES_PER_LINE;

        if ( Index == 0 )
            {
            LogSerial( "   %s", Outbuf);

            memset(Outbuf, ' ', sizeof(Outbuf)-1);
            }

        Outbuf[Index*3+Index/4  ] = HexDigits[p[Offset] / 16];
        Outbuf[Index*3+Index/4+1] = HexDigits[p[Offset] % 16];
        Outbuf[BYTES_PER_LINE*3+BYTES_PER_LINE/4+Index] = printable(p[Offset]) ? p[Offset] : '.';
        }

    LogSerial( "   %s", Outbuf);
}

// All of these methods and functions throw a ComError

void SafeWriteFile( HANDLE hFile, void *pBuffer, DWORD dwSize )
{
    DWORD dwBytesWritten;

    LogSerial("safe-write: writing file data, %d bytes:", dwSize );

    DumpBuffer( pBuffer, dwSize );

    BOOL bResult =
    WriteFile( hFile, pBuffer, dwSize, &dwBytesWritten, NULL );

    if ( !bResult ) throw ComError( HRESULT_FROM_WIN32(GetLastError()) );

    if ( dwBytesWritten != dwSize )
        throw ComError( HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER) );
}

void SafeReadFile( HANDLE hFile, void *pBuffer, DWORD dwSize )
{
    DWORD dwBytesRead;

    LogSerial("safe-read: reading %d bytes", dwSize );

    BOOL bResult =
    ReadFile( hFile, pBuffer, dwSize, &dwBytesRead, NULL );

    HRESULT Hr = ( bResult ) ? S_OK : HRESULT_FROM_WIN32( GetLastError() );

    DumpBuffer( pBuffer, dwBytesRead );

    if ( !bResult )
        {
        LogSerial("safe-read: only %d bytes read: %!winerr!", dwBytesRead, Hr );
        throw ComError( Hr );
        }

    if ( dwBytesRead != dwSize )
        throw ComError( HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER) );
}

void SafeWriteStringHandle( HANDLE hFile, StringHandle & str )
{
    DWORD dwStringSize = str.Size() + 1;

    SafeWriteFile( hFile, dwStringSize );

    SafeWriteFile( hFile, (void*)(const WCHAR*) str, dwStringSize * sizeof(wchar_t) );

}

StringHandle SafeReadStringHandle( HANDLE hFile )
{
    DWORD dwStringSize;
    bool bResult;

    SafeReadFile( hFile, &dwStringSize, sizeof(dwStringSize) );

    auto_ptr<wchar_t> buf( new wchar_t[ dwStringSize ] );

    SafeReadFile( hFile, buf.get(),  dwStringSize * sizeof(wchar_t) );

    if ( buf.get()[ dwStringSize-1 ] != L'\0' )
        throw ComError( HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER) );

    return StringHandle( buf.get() );
}

void SafeWriteFile( HANDLE hFile, WCHAR * str )
{

    bool bString = (NULL != str );
    SafeWriteFile( hFile, bString );
    if ( bString )
        {
        DWORD dwStringSize = (DWORD)wcslen(str) + 1;
        SafeWriteFile( hFile, dwStringSize );
        SafeWriteFile( hFile, (void*)str, dwStringSize * sizeof(WCHAR) );
        }
}

void SafeReadFile( HANDLE hFile, WCHAR ** pStr )
{

    bool bString;

    SafeReadFile( hFile, &bString );

    if ( !bString )
        {
        *pStr = NULL;
        return;
        }

    DWORD dwStringSize;
    SafeReadFile( hFile, &dwStringSize );

    *pStr = new WCHAR[ dwStringSize ];
    if ( !*pStr )
        throw ComError( E_OUTOFMEMORY );

    try
        {
        SafeReadFile( hFile, (void*)*pStr, dwStringSize * sizeof(WCHAR));

        if ( (*pStr)[ dwStringSize - 1] != L'\0' )
            throw ComError( HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER) );
        }
    catch ( ComError Error )
        {
        delete[] *pStr;
        *pStr = NULL;
        throw;
        }
}


void SafeWriteSid( HANDLE hFile,  SidHandle & sid  )
{
    DWORD length;
    LPWSTR str = NULL;

    try
        {
        if ( !ConvertSidToStringSid( sid.get(), &str) )
            {
            throw ComError( HRESULT_FROM_WIN32( GetLastError()));
            }

        length = 1+wcslen( str );

        SafeWriteFile( hFile, length );
        SafeWriteFile( hFile, str, length * sizeof(wchar_t));

        LocalFree( str );
        }
    catch ( ComError Error )
        {
        if ( str )
            {
            LocalFree( str );
            }

        throw;
        }
}

void SafeReadSid( HANDLE hFile, SidHandle & sid )
{
    DWORD dwStringSize;
    bool bResult;

    SafeReadFile( hFile, &dwStringSize, sizeof(dwStringSize) );

    auto_ptr<wchar_t> buf( new wchar_t[ dwStringSize ] );

    SafeReadFile( hFile, buf.get(),  dwStringSize * sizeof(wchar_t) );

    if ( buf.get()[ dwStringSize-1 ] != L'\0' )
        throw ComError( HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER) );

    PSID TempSid;
    if (!ConvertStringSidToSid( buf.get(), &TempSid ))
        {
        if (GetLastError() == ERROR_INVALID_SID)
            {
            THROW_HRESULT( HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER) );
            }
        THROW_HRESULT( HRESULT_FROM_WIN32( GetLastError() ));
        }

    try
        {
        sid = DuplicateSid( TempSid );
        LocalFree( TempSid );
        }
    catch( ComError err )
        {
        LocalFree( TempSid );
        throw;
        }
}


int SafeReadGuidChoice( HANDLE hFile, const GUID * guids[] )
{
    GUID guid;
    SafeReadFile( hFile, &guid );

    int i = 0;

    for ( i=0; guids[i] != NULL; ++i )
        {
        if ( guid == *guids[i] )
            {
            return i;
            }
        }

    throw ComError( HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER) );
}

void SafeWriteBlockBegin( HANDLE hFile, GUID BlockGuid )
{
    SafeWriteFile( hFile, BlockGuid );
}

void SafeWriteBlockEnd( HANDLE hFile, GUID BlockGuid )
{
    SafeWriteFile( hFile, BlockGuid );
}

void SafeReadBlockBegin( HANDLE hFile, GUID BlockGuid )
{
    GUID FileBlockGuid;
    SafeReadFile( hFile, &FileBlockGuid );

    if ( memcmp( &FileBlockGuid, &BlockGuid, sizeof(GUID)) != 0 )
        throw ComError( HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER) );

}

void SafeReadBlockEnd( HANDLE hFile, GUID BlockGuid )
{
    GUID FileBlockGuid;
    SafeReadFile( hFile, &FileBlockGuid );

    if ( memcmp( &FileBlockGuid, &BlockGuid, sizeof(GUID)) != 0 )
        throw ComError( HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER) );

}

// {2B196AF5-007C-438f-8D12-1CFCA4CC9B76}
static const GUID QmgrStateStorageGUID =
{ 0x2b196af5, 0x7c, 0x438f, { 0x8d, 0x12, 0x1c, 0xfc, 0xa4, 0xcc, 0x9b, 0x76 } };

CQmgrStateFiles::CQmgrStateFiles()
{

    for ( unsigned int i = 0; i < 2; i++ )
        {
        m_FileNames[i]           = GetNameFromIndex(i);
        m_Files[i]               = OpenMetadataFile( m_FileNames[i] );
        m_ExpandSize[i]          = 0;
        m_OriginalFileSizes[i]   = 0;
        }

    HRESULT hResult =
    GetRegDWordValue( C_QMGR_STATE_INDEX, &m_CurrentIndex);

    if ( !SUCCEEDED(hResult) )
        {
        m_CurrentIndex = 0;
        }
}

auto_ptr<WCHAR> CQmgrStateFiles::GetNameFromIndex( DWORD dwIndex )
{
    using namespace std;

    TCHAR Template[] =  _T("%sqmgr%u.dat");

    SIZE_T StringSize = _tcslen(g_GlobalInfo->m_QmgrDirectory)
                                + RTL_NUMBER_OF( Template )
                                + numeric_limits<unsigned long>::digits10;

    auto_ptr<TCHAR> ReturnString(new TCHAR[StringSize] );

    THROW_HRESULT( StringCchPrintf( ReturnString.get(), StringSize, Template, g_GlobalInfo->m_QmgrDirectory, dwIndex ));

    return ReturnString;
}

auto_FILE_HANDLE CQmgrStateFiles::OpenMetadataFile( auto_ptr<WCHAR> FileName )
{

    SECURITY_ATTRIBUTES SecurityAttributes;
    SecurityAttributes.nLength = sizeof(SecurityAttributes);
    SecurityAttributes.lpSecurityDescriptor = (void*)g_GlobalInfo->m_MetadataSecurityDescriptor;
    SecurityAttributes.bInheritHandle = FALSE;

    HANDLE hFileHandle =
    CreateFile( FileName.get(),
                GENERIC_READ | GENERIC_WRITE,
                0,
                &SecurityAttributes,
                OPEN_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL );

    if ( INVALID_HANDLE_VALUE == hFileHandle )
        throw ComError( HRESULT_FROM_WIN32(GetLastError()) );

    auto_FILE_HANDLE FileHandle( hFileHandle );

    // Ensure file size is at least METADATA_PADDING

    if ( BITSGetFileSize( hFileHandle ) < METADATA_PADDING )
        {
        BITSSetFilePointer( hFileHandle, METADATA_PADDING, FILE_BEGIN );
        BITSSetEndOfFile( hFileHandle );
        BITSSetFilePointer( hFileHandle, 0, FILE_BEGIN );
        }

    return FileHandle;
}


HANDLE CQmgrStateFiles::GetNextStateFile()
{
    DWORD dwNextIndex = ( m_CurrentIndex + 1) % 2;

    HANDLE hFile = m_Files[ dwNextIndex ].get();

    BITSSetFilePointer( hFile, 0, FILE_BEGIN );

    return hFile;
}

void CQmgrStateFiles::UpdateStateFile()
{

    DWORD OldCurrentIndex = m_CurrentIndex;
    DWORD NewCurrentIndex = ( m_CurrentIndex + 1) % 2;

    // Truncate the current file only if more then METADATA_PADDING remains

    HANDLE CurrentFileHandle = m_Files[ NewCurrentIndex ].get();

    INT64 CurrentPosition = BITSSetFilePointer( CurrentFileHandle, 0, FILE_CURRENT );
    INT64 CurrentFileSize = BITSGetFileSize( CurrentFileHandle );

#if DBG
    // ASSERT( CurrentPosition <= ( m_OriginalFileSizes[ NewCurrentIndex ] + m_ExpandSize[ NewCurrentIndex ] ) );
    if (CurrentPosition > ( m_OriginalFileSizes[ NewCurrentIndex ] + m_ExpandSize[ NewCurrentIndex ] ) &&
        (m_OriginalFileSizes[ NewCurrentIndex ] > 0))
        {
        LogError("new idx %d, position %u, original size %u, expanded by %u",
                 NewCurrentIndex,
                 DWORD(CurrentPosition),
                 DWORD(m_OriginalFileSizes[ NewCurrentIndex ]),
                 DWORD(m_ExpandSize[ NewCurrentIndex ])
                 );

        Log_Close();

        Sleep(30 * 1000);

        ASSERT( 0 && "BITS: encountered bug 483866");
        }
#endif

    if ( ( CurrentFileSize - CurrentPosition ) > METADATA_PADDING )
        {
        BITSSetFilePointer( CurrentFileHandle, METADATA_PADDING, FILE_CURRENT );
        BITSSetEndOfFile( CurrentFileHandle );
        }

    BITSFlushFileBuffers( CurrentFileHandle );

    m_ExpandSize[ NewCurrentIndex ] = 0;
    m_OriginalFileSizes[ NewCurrentIndex ] = 0;

    HRESULT hResult = SetRegDWordValue( C_QMGR_STATE_INDEX, NewCurrentIndex);

    if ( !SUCCEEDED( hResult ) )
        throw ComError( hResult );

    m_CurrentIndex = NewCurrentIndex;

    //
    // Shrink the backup files if necessary
    //

    if ( m_ExpandSize[ OldCurrentIndex ] )
        {
        try
            {
            INT64 NewSize = BITSGetFileSize( m_Files[ NewCurrentIndex ].get() );

            if ( NewSize > m_OriginalFileSizes[ OldCurrentIndex ] )
                {
                BITSSetFilePointer( m_Files[ OldCurrentIndex ].get(), NewSize, FILE_BEGIN );
                BITSSetEndOfFile( m_Files[ OldCurrentIndex ].get() );
                }

            m_OriginalFileSizes[ OldCurrentIndex ] = 0;
            m_ExpandSize[ OldCurrentIndex ] = 0;

            }
        catch ( ComError Error )
            {
            LogError( "Unable to shrink file %u, error %!winerr!", OldCurrentIndex, Error.Error() );
            return;
            }

        }

}

HANDLE CQmgrStateFiles::GetCurrentStateFile()
{

    HANDLE hFile = m_Files[ m_CurrentIndex ].get();

    BITSSetFilePointer( hFile, 0, FILE_BEGIN );

    return hFile;
}

void
CQmgrStateFiles::ExtendMetadata( INT64 ExtendAmount )
{

    //
    // Get the original file sizes
    //

    SIZE_T OriginalExpansion[2] =
    { m_ExpandSize[0], m_ExpandSize[1]};

    for ( unsigned int i=0; i < 2; i++ )
        {
        if ( !m_ExpandSize[i] )
            {
            m_OriginalFileSizes[i] = BITSGetFileSize( m_Files[i].get() );
            }
        }

    bool WasExpanded[2] = { false, false};

    try
        {
        for ( unsigned int i=0; i < 2; i++ )
            {
            BITSSetFilePointer( m_Files[i].get(), ExtendAmount, FILE_END );
            BITSSetEndOfFile( m_Files[i].get() );

            WasExpanded[i] = true;
            m_ExpandSize[i] += ExtendAmount;
            }
        }

    catch ( ComError Error )
        {

        LogError( "Unable to extend the size of the metadata files, error %!winerr!", Error.Error() );

        for ( unsigned int i=0; i < 2; i++ )
            {

            try
                {
                if ( WasExpanded[i] )
                    {

                    BITSSetFilePointer( m_Files[i].get(), -ExtendAmount, FILE_END );
                    BITSSetEndOfFile( m_Files[i].get() );

                    m_ExpandSize[i] = OriginalExpansion[i];
                    }

                }
            catch ( ComError Error )
                {
                LogError( "Unable to reshrink file %u, error %!winerr!", i, Error.Error() );
                continue;
                }

            }

        throw;

        }

}

void
CQmgrStateFiles::ShrinkMetadata()
{

    for ( unsigned int i = 0; i < 2; i++ )
        {

        try
            {
            if ( m_ExpandSize[i] )
                {

                BITSSetFilePointer( m_Files[i].get(), m_OriginalFileSizes[i], FILE_BEGIN );
                BITSSetEndOfFile( m_Files[i].get() );

                m_ExpandSize[i] = 0;
                m_OriginalFileSizes[i] = 0;

                }

            }
        catch ( ComError Error )
            {
            LogError( "Unable to shrink file %u, error %!winerr!", i, Error.Error() );
            continue;
            }

        }
}


CQmgrReadStateFile::CQmgrReadStateFile( CQmgrStateFiles & StateFiles ) :
m_StateFiles( StateFiles ),
m_FileHandle(  StateFiles.GetCurrentStateFile() )
{
    // Validate the file
    SafeReadBlockBegin( m_FileHandle, QmgrStateStorageGUID );
}

void CQmgrReadStateFile::ValidateEndOfFile()
{
    SafeReadBlockEnd( m_FileHandle, QmgrStateStorageGUID );
}

CQmgrWriteStateFile::CQmgrWriteStateFile( CQmgrStateFiles & StateFiles ) :
m_StateFiles( StateFiles ),
m_FileHandle( StateFiles.GetNextStateFile() )
{

    SafeWriteBlockBegin( m_FileHandle, QmgrStateStorageGUID );

}

void CQmgrWriteStateFile::CommitFile()
{
    SafeWriteBlockEnd( m_FileHandle, QmgrStateStorageGUID );

    m_StateFiles.UpdateStateFile();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\newjob\stl.cpp ===
#include "stdafx.h"


CRITICAL_SECTION g_STLCs;
BOOL g_STLCsInitialized = FALSE;



bool InitCompilerLibrary()
{
    if ( !InitializeCriticalSectionAndSpinCount( &g_STLCs, 0x80000000 ) )
        return false;

    g_STLCsInitialized = TRUE;

    return true;
}

bool UninitCompilerLibrary()
{
    if ( g_STLCsInitialized )
        {
        DeleteCriticalSection( &g_STLCs );
        g_STLCsInitialized = FALSE;
        }

    return true;
}

#if 1

#pragma warning( disable : 4273 )

std::_Lockit::_Lockit()
{
    EnterCriticalSection(&g_STLCs);
}

std::_Lockit::~_Lockit()
{
    LeaveCriticalSection(&g_STLCs);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\newjob\tasksched.cpp ===
/************************************************************************

Copyright (c) 2000 - 2000 Microsoft Corporation

Module Name :

    tasksched.cpp

Abstract :

    Source file for task manager classes and routines.

Author :

Revision History :

 ***********************************************************************/


#include "stdafx.h"

#if !defined(BITS_V12_ON_NT4)
#include "tasksched.tmh"
#endif

////////////////////////////////////////////////////////////////////////////////////
//
// TaskSchedulerWorkItem
//
////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////
// Constructor/Destructor
////////////////////////////////////////////////////////////////////////////////////

TaskSchedulerWorkItem::TaskSchedulerWorkItem( FILETIME *pTimeToRun ) :
m_Container( NULL ),
m_CancelEvent(NULL),
m_ItemComplete(NULL),
m_ItemCanceled(NULL),
m_State(TASK_STATE_NOTHING),
m_WorkGroup(NULL)
{
    try
        {
        // All events are manual reset.
        m_ItemCanceled = CreateEvent( NULL, TRUE, FALSE, NULL );
        if ( !m_ItemCanceled )
            throw ComError( HRESULT_FROM_WIN32(GetLastError()));
        // new items are complete
        m_CancelEvent = CreateEvent( NULL, TRUE, TRUE, NULL );
        if ( !m_CancelEvent )
            throw ComError( HRESULT_FROM_WIN32(GetLastError()));
        m_ItemComplete = CreateEvent( NULL, TRUE, FALSE, NULL );
        if ( !m_ItemComplete )
            throw ComError( HRESULT_FROM_WIN32(GetLastError()));
        }
    catch ( ComError Error )
        {
        this->~TaskSchedulerWorkItem();
        throw;
        }
}

TaskSchedulerWorkItem::~TaskSchedulerWorkItem()
{
    if ( m_ItemComplete ) SetEvent( m_ItemComplete );
    if ( m_CancelEvent ) CloseHandle( m_CancelEvent );
    if ( m_ItemCanceled ) CloseHandle( m_ItemCanceled );
    if ( m_ItemComplete ) CloseHandle( m_ItemComplete );
}

void
TaskSchedulerWorkItem::Serialize(
    HANDLE hFile
    )
{

    //
    // If this function changes, be sure that the metadata extension
    // constants are adequate.
    //

    bool fActive = g_Manager->m_TaskScheduler.IsWorkItemInScheduler( this );

    SafeWriteFile( hFile, fActive );

    if (fActive)
        {
        SafeWriteFile( hFile, m_InsertionTime );
        SafeWriteFile( hFile, m_TimeToRun );
        }
}

void
TaskSchedulerWorkItem::Unserialize(
    HANDLE hFile
    )
{
    bool fActive;

    SafeReadFile( hFile, &fActive );

    if (fActive)
        {
        SafeReadFile( hFile, &m_InsertionTime );
        SafeReadFile( hFile, &m_TimeToRun );

        LogTask("workitem %p : adding to scheduler for %I64d", this, FILETIMEToUINT64(m_TimeToRun) );

        g_Manager->m_TaskScheduler.InsertWorkItem( this, &m_TimeToRun );
        }
    else
        {
        LogTask("workitem %p: not in scheduler", this );
        }
}

////////////////////////////////////////////////////////////////////////////////////
//
// TaskScheduler
//
////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////
// Constructor/Destructor
////////////////////////////////////////////////////////////////////////////////////

TaskScheduler::TaskScheduler() :
m_bShouldDie(false),
m_WaitableTimer(NULL),
m_ReaderLock(NULL),
m_WriterSemaphore(NULL),
m_ReaderCount(0),
m_WorkItemTLS((DWORD)-1),
m_WriterOwner(0),
m_WorkerInitialized(NULL)
{
    try
        {
        m_WorkItemTLS = TlsAlloc();
        if ( (DWORD)-1 == m_WorkItemTLS)
            throw ComError( HRESULT_FROM_WIN32(GetLastError()));

        m_SchedulerLock = CreateMutex( NULL, FALSE, NULL );
        if ( !m_SchedulerLock )
            throw ComError( HRESULT_FROM_WIN32(GetLastError()));

        m_WaitableTimer = CreateWaitableTimer( NULL, FALSE, NULL );
        if ( !m_WaitableTimer )
            throw ComError( HRESULT_FROM_WIN32(GetLastError()));

        // Create and autoreset event for synchronization on startup
        m_WorkerInitialized = CreateEvent( NULL, FALSE, FALSE, NULL );
        if ( !m_WorkerInitialized )
            throw ComError( HRESULT_FROM_WIN32(GetLastError()));

        m_ReaderLock = CreateMutex( NULL, FALSE, NULL );
        if ( !m_ReaderLock )
            throw ComError( HRESULT_FROM_WIN32(GetLastError()));

        m_WriterSemaphore = CreateSemaphore( NULL, 1, 1, NULL );
        if ( !m_WriterSemaphore )
            throw ComError( HRESULT_FROM_WIN32(GetLastError()));
        }
    catch ( ComError Error )
        {
        this->~TaskScheduler();
        throw;
        }
}

TaskScheduler::~TaskScheduler()
{
    if ((DWORD)-1 != m_WorkItemTLS)
        TlsFree( m_WorkItemTLS );
    if ( m_SchedulerLock )
        CloseHandle( m_SchedulerLock );
    if ( m_WaitableTimer )
        CloseHandle( m_WaitableTimer );
    if ( m_WorkerInitialized )
        CloseHandle( m_WorkerInitialized );
    if ( m_ReaderLock )
        CloseHandle( m_ReaderLock );
    if ( m_WriterSemaphore )
        CloseHandle( m_WriterSemaphore );
}

//////////////////////////////////////////////////////////////////////////////////////////
//  WorkItem control
//////////////////////////////////////////////////////////////////////////////////////////

bool TaskScheduler::CancelWorkItem( TaskSchedulerWorkItem * pWorkItem )
{
    LogTask( "cancelling %p", pWorkItem );

    RTL_VERIFY( WAIT_OBJECT_0 == WaitForSingleObject( m_SchedulerLock, INFINITE ) );

    HANDLE hHandles[2];
    hHandles[0] = pWorkItem->m_ItemCanceled;
    hHandles[1] = pWorkItem->m_ItemComplete;

    DWORD dwResult = WaitForMultipleObjects( 2, hHandles, FALSE, 0 );
    if ( (WAIT_OBJECT_0 == dwResult) ||
         ((WAIT_OBJECT_0 + 1) == dwResult ) )
        {
        RTL_VERIFY( ReleaseMutex( m_SchedulerLock ) );
        return true; // Job completed before the cancel
        }

    // If canceling the current work item, call Acknowlege immedialtly
    if ( GetCurrentWorkItem() == pWorkItem )
        {
        LogTask( "Canceling work item %p, we are the owner", pWorkItem );
        RTL_VERIFY( SetEvent( pWorkItem->m_CancelEvent ) );
        AcknowledgeWorkItemCancel();
        RTL_VERIFY( ReleaseMutex( m_SchedulerLock ) );
        return false; // Job canceled
        }

    //
    // Remove the work item from its list.
    //

    switch( pWorkItem->m_State )
        {

        case TASK_STATE_WAITING:
            {

            m_WaitingList.erase( *pWorkItem );
            pWorkItem->m_State = TASK_STATE_CANCELED;
            pWorkItem->m_WorkGroup = NULL;
            Reschedule();
            RTL_VERIFY( ReleaseMutex( m_SchedulerLock ) );
            return false;

            }

        case TASK_STATE_READY:
            {

            TaskSchedulerWorkGroup *pGroup =
                static_cast<TaskSchedulerWorkGroup*>(pWorkItem->m_WorkGroup);
            pGroup->m_ReadyList.erase( *pWorkItem );
            // Kill one on the semaphore
            RTL_VERIFY( WAIT_OBJECT_0 == WaitForSingleObject( pGroup->m_ItemAvailableSemaphore, 0 ) );
            pWorkItem->m_State = TASK_STATE_CANCELED;
            pWorkItem->m_WorkGroup = NULL;
            RTL_VERIFY( ReleaseMutex( m_SchedulerLock ) );
            return false;

            }
        case TASK_STATE_RUNNING:
            {

            // cancelling on another thread
            RTL_VERIFY( SetEvent( pWorkItem->m_CancelEvent ) );
            RTL_VERIFY( ReleaseMutex( m_SchedulerLock ) );

            dwResult = WaitForMultipleObjects( 2, hHandles, FALSE, INFINITE );
            ASSERT( ( WAIT_OBJECT_0 == dwResult ) || ( WAIT_OBJECT_0 + 1 == dwResult ) );

            return WAIT_OBJECT_0 != dwResult;

            }

        case TASK_STATE_CANCELED:
        case TASK_STATE_COMPLETE:
        case TASK_STATE_NOTHING:
        default:

           ASSERT( TASK_STATE_CANCELED == pWorkItem->m_State ||
                   TASK_STATE_COMPLETE == pWorkItem->m_State ||
                   TASK_STATE_NOTHING == pWorkItem->m_State );
           ASSERT( NULL == pWorkItem->m_WorkGroup );
           RTL_VERIFY( ReleaseMutex( m_SchedulerLock ) );
           return true;
        }

}

void TaskScheduler::CompleteWorkItem( bool bCancel )
{
    RTL_VERIFY( WaitForSingleObject( m_SchedulerLock, INFINITE ) == WAIT_OBJECT_0 );

    TaskSchedulerWorkItem *pWorkItem = GetCurrentWorkItem();

    LogTask( "completing %p", pWorkItem );

//    ASSERT( pWorkItem );
    if (pWorkItem)
        {
        RTL_VERIFY( TlsSetValue( m_WorkItemTLS, NULL ) );
        TaskSchedulerWorkGroup *pGroup =
            static_cast<TaskSchedulerWorkGroup*>(pWorkItem->m_WorkGroup);
        pGroup->m_RunningList.erase( *pWorkItem );
        pWorkItem->m_WorkGroup = NULL;
        pWorkItem->m_State = bCancel ? TASK_STATE_CANCELED : TASK_STATE_COMPLETE;
        RTL_VERIFY( SetEvent( bCancel ? pWorkItem->m_ItemCanceled : pWorkItem->m_ItemComplete ) );
        }

    RTL_VERIFY( ReleaseMutex( m_SchedulerLock ) );
}

void TaskScheduler::DispatchWorkItem()
{
    TaskSchedulerWorkItem *pWorkItem = NULL;

    RTL_VERIFY( WaitForSingleObject( m_SchedulerLock, INFINITE ) == WAIT_OBJECT_0 );

    // Move all the jobs that are available from waiting
    // to ready
    while ( !m_WaitingList.empty() )
        {
        FILETIME ftCurrentTime;
        GetSystemTimeAsFileTime( &ftCurrentTime );

        TaskSchedulerWorkItem * pHeadItem = &(*m_WaitingList.begin());
        UINT64 CurrentTime = FILETIMEToUINT64( ftCurrentTime );
        UINT64 HeadTime = FILETIMEToUINT64( pHeadItem->m_TimeToRun );


        if ( HeadTime > CurrentTime )
            {
            // All the jobs in the list are still waiting,
            // let them continue waiting
            break;
            }

        // transfer the head work item from the waiting list
        // to the ready list of the correct work group
        m_WaitingList.erase( *pHeadItem );
        AddItemToWorkGroup( pHeadItem->GetSid(), pHeadItem );

        }

    Reschedule();
    RTL_VERIFY( ReleaseMutex( m_SchedulerLock ) );

}

void
TaskScheduler::InsertDelayedWorkItem(
    TaskSchedulerWorkItem *pWorkItem,
    UINT64 Delay100Nsec
    )
{
    FILETIME ftCurrentTime;

    GetSystemTimeAsFileTime( &ftCurrentTime );

    UINT64 TimeToRun = Delay100Nsec + FILETIMEToUINT64( ftCurrentTime );

    FILETIME ftTimeToRun = UINT64ToFILETIME( TimeToRun );

    InsertWorkItem( pWorkItem, &ftTimeToRun );
}

void
TaskScheduler::RescheduleDelayedTask(
    TaskSchedulerWorkItem *pWorkItem,
    UINT64 Delay100Nsec
    )
{
    // Resets the time for the work item to run to be Delay100NSec after
    // the insertion time.

    // If the work item is not in the queue, running, completed,
    // or canceled then this operation is ignored.

    // Otherwise, the job is rescheduled.

    LogTask( "rescheduling %p", pWorkItem );

    RTL_VERIFY( WaitForSingleObject( m_SchedulerLock, INFINITE ) == WAIT_OBJECT_0 );

    // If the work item is not on a running list or the pending list,
    // ignore the call.

    if ( TASK_STATE_READY == pWorkItem->m_State )
        {
        TaskSchedulerWorkGroup *pGroup =
            static_cast<TaskSchedulerWorkGroup*>( pWorkItem->m_WorkGroup );
        pGroup->m_ReadyList.erase( *pWorkItem );
        RTL_VERIFY( WAIT_OBJECT_0 == WaitForSingleObject( pGroup->m_ItemAvailableSemaphore, 0 ) );
        }
    else if ( TASK_STATE_WAITING == pWorkItem->m_State )
        {
        m_WaitingList.erase( *pWorkItem );
        }
    else
        {
        LogTask( "item %p not pending.  Ignoring.", pWorkItem );
        RTL_VERIFY( ReleaseMutex( m_SchedulerLock ) );
        return;
        }

    UINT64 TimeToRun = Delay100Nsec + FILETIMEToUINT64( pWorkItem->m_InsertionTime );
    pWorkItem->m_TimeToRun = UINT64ToFILETIME( TimeToRun );

    m_WaitingList.insert( *pWorkItem );
    pWorkItem->m_State = TASK_STATE_WAITING;
    pWorkItem->m_WorkGroup = NULL;
    Reschedule();

    LogTask( "item %p rescheduled", pWorkItem );

    RTL_VERIFY( ReleaseMutex( m_SchedulerLock ) );
}

inline INT64 abs(INT64 x)
{
    if (x >= 0)
        {
        return x;
        }
    else
        {
        return -x;
        }
}

void TaskScheduler::InsertWorkItem( TaskSchedulerWorkItem *pWorkItem, FILETIME *pTimeToRun )
{
    {
    INT64  Difference;
    FILETIME ftCurrentTime;
    GetSystemTimeAsFileTime( &ftCurrentTime );

    if (pTimeToRun)
        {
        Difference = INT64(FILETIMEToUINT64( *pTimeToRun )) - INT64(FILETIMEToUINT64( ftCurrentTime ));

        if (abs(Difference) > 86400 * NanoSec100PerSec)
            {
            LogTask( "inserting %p; activates in %f days", pWorkItem, float(Difference) / (float(NanoSec100PerSec) * 86400) );
            }
        else
            {
            LogTask( "inserting %p; activates in %f seconds", pWorkItem, float(Difference) / float(NanoSec100PerSec) );
            }
        }
    else
        {
        LogTask( "inserting %p; activates now", pWorkItem );
        }
    }

    RTL_VERIFY( WaitForSingleObject( m_SchedulerLock, INFINITE ) == WAIT_OBJECT_0 );
    GetSystemTimeAsFileTime( &pWorkItem->m_InsertionTime );

    RTL_VERIFY( ResetEvent( pWorkItem->m_CancelEvent ) );
    RTL_VERIFY( ResetEvent( pWorkItem->m_ItemComplete ) );
    RTL_VERIFY( ResetEvent( pWorkItem->m_ItemCanceled ) );

    if ( !pTimeToRun && !m_bShouldDie )
        {
        pWorkItem->m_TimeToRun = pWorkItem->m_InsertionTime;
        AddItemToWorkGroup( pWorkItem->GetSid(), pWorkItem );
        }
    else
        {
        if (pTimeToRun)
            {
            pWorkItem->m_TimeToRun = *pTimeToRun;
            }
        else
            {
            GetSystemTimeAsFileTime( &pWorkItem->m_TimeToRun );
            }

        pWorkItem->m_State = TASK_STATE_WAITING;
        m_WaitingList.insert( *pWorkItem );
        Reschedule();
        }

    RTL_VERIFY( ReleaseMutex( m_SchedulerLock ) );

}

bool TaskScheduler::IsWorkItemInScheduler( TaskSchedulerWorkItem *pWorkItem )
{
    bool b;

    RTL_VERIFY( WaitForSingleObject( m_SchedulerLock, INFINITE ) == WAIT_OBJECT_0 );

    b = ( TASK_STATE_WAITING == pWorkItem->m_State ||
          TASK_STATE_READY == pWorkItem->m_State ||
          TASK_STATE_RUNNING == pWorkItem->m_State );

    RTL_VERIFY( ReleaseMutex( m_SchedulerLock ) );

    return b;
}

void TaskScheduler::Reschedule()
{
    if ( m_WaitingList.empty() )
        {
        // Nothing to do, cancel waitable timer.
        RTL_VERIFY( CancelWaitableTimer( m_WaitableTimer ) );
        return;
        }

    LARGE_INTEGER NextItemTime;
    FILETIME ftNextItemTime = (*m_WaitingList.begin()).m_TimeToRun;
    NextItemTime.QuadPart = (INT64)FILETIMEToUINT64( ftNextItemTime );

    RTL_VERIFY(
        SetWaitableTimer(
            m_WaitableTimer,
            &NextItemTime,
            0,
            NULL,
            NULL,
            FALSE ) );
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//  Reader/Writer lock
//
//  Algorithm:
//
//  Writer:
//     Wait on writer lock and cancel event.   Return when either is signaled
//
//  Unlock writer:
//     Release the writer lock
//
//  Lock reader:
//     Lock reader lock to protect count.   If I am the first reader, grab the writer semaphore.
//     Unlock reader lock.   If on either wait the cancel event is signaled, abort.
//
//  Unlock reader:
//     Decrement the reader count.  If last reader, release the writer lock.
//
/////////////////////////////////////////////////////////////////////////////////////////////////

bool TaskScheduler::LockReader()
{
    LogLock( "reader" );
    HANDLE hCancel = GetCancelEvent();
    if ( !hCancel )
        {
        RTL_VERIFY( WaitForSingleObject( m_ReaderLock, INFINITE ) == WAIT_OBJECT_0 );

        // InterlockedIncrement returns the new value
        if ( InterlockedIncrement( &m_ReaderCount ) == 1 )
            {
            RTL_VERIFY( WaitForSingleObject( m_WriterSemaphore, INFINITE ) == WAIT_OBJECT_0 );
            }

        RTL_VERIFY( ReleaseMutex( m_ReaderLock ) );
        LogLock("reader lock acquired");
        ASSERT( !m_WriterOwner );
        return false;
        }

    DWORD dwResult;
    HANDLE hReaderLockHandles[2];
    hReaderLockHandles[0] = hCancel;
    hReaderLockHandles[1] = m_ReaderLock;

    dwResult = WaitForMultipleObjects( 2, hReaderLockHandles, false, INFINITE );
    switch ( dwResult )
        {
        case WAIT_OBJECT_0 + 0:
            // cancel request
            LogLock( "Cancel requested, aborting read lock" );
            return true;
        case WAIT_OBJECT_0 + 1:
            // lock acquired
            break;
        default:
            ASSERT(0);
        }

    bool bReturnVal = false;
    ULONG NewReaderCount = InterlockedIncrement( &m_ReaderCount );
    if (1 == NewReaderCount )
        {
        LogLock("First reader, need to block writers");
        HANDLE hWriterLockHandles[2];
        hWriterLockHandles[0] = hCancel;
        hWriterLockHandles[1] = m_WriterSemaphore;

        dwResult = WaitForMultipleObjects( 2, hWriterLockHandles, false, INFINITE );
        switch ( dwResult )
            {
            case WAIT_OBJECT_0 + 0:
                // cancel request
                LogLock( "Cancel requested, aborting acquire of writer lock");
                bReturnVal = true;
            case WAIT_OBJECT_0 + 1:
                // lock acquired
                break;
            default:
                ASSERT(0);
            }

        }
    RTL_VERIFY( ReleaseMutex( m_ReaderLock ) );

    if (!bReturnVal)
        {
        LogLock("reader lock acquired");
        ASSERT( !m_WriterOwner );
        }

    return bReturnVal;
}

void TaskScheduler::UnlockReader()
{
    LogLock( "reader unlock" );
    LONG lNewReaderCount = InterlockedDecrement( &m_ReaderCount );
    ASSERT( lNewReaderCount >= 0 );
    if (!lNewReaderCount ) //Last reader
        {
        LogLock( "Last reader, letting writers pass" );
        RTL_VERIFY( ReleaseSemaphore( m_WriterSemaphore, 1, NULL ) );
        }
    LogLock( "Unlocked read access to lock" );
}

bool TaskScheduler::LockWriter()
{
    LogLock( "writer lock" );
    HANDLE hCancel = GetCancelEvent();

    if (!hCancel)
        {
        RTL_VERIFY( WaitForSingleObject( m_WriterSemaphore, INFINITE ) == WAIT_OBJECT_0 );
        ASSERT( !m_WriterOwner );
        m_WriterOwner = GetCurrentThreadId();
        LogLock("Lock acquired with write access");
        return false;
        }

    HANDLE hHandles[2];
    hHandles[0] = hCancel;
    hHandles[1] = m_WriterSemaphore;

    DWORD dwResult = WaitForMultipleObjects( 2, hHandles, false, INFINITE );

    switch ( dwResult )
        {
        case WAIT_OBJECT_0 + 0:
            // cancel request
            LogLock("Cancel requested, aborting lock with write access");
            return true;
        case WAIT_OBJECT_0 + 1:
            // lock acquired
            ASSERT( !m_WriterOwner );
            m_WriterOwner = GetCurrentThreadId();
            LogLock("Lock acquired with write access");
            return false;
        default:
            ASSERT(0);
            return false;
        }

}

void TaskScheduler::UnlockWriter()
{
    LogLock( "writer unlock" );
    ASSERT( GetCurrentThreadId() == m_WriterOwner );
    m_WriterOwner = 0;
    RTL_VERIFY( ReleaseSemaphore( m_WriterSemaphore, 1, NULL ) );
    LogLock("Unlocked lock with write access");
}

TaskScheduler::TaskSchedulerWorkGroup::TaskSchedulerWorkGroup(
    SidHandle Sid ) :
    m_Sid(Sid),
    m_ItemAvailableSemaphore(NULL),
    m_Threads(0),
    m_BusyThreads(0)
{
    memset( m_Thread, 0, sizeof( m_Thread ) );
    memset( m_ThreadId, 0, sizeof( m_ThreadId ) );

    m_ItemAvailableSemaphore =
        CreateSemaphore(
            NULL,
            0, // InitialCount
            0x7FFFFFFF, // MaxCount
            NULL );

    if ( !m_ItemAvailableSemaphore )
        throw ComError( HRESULT_FROM_WIN32( GetLastError() ) );

}

TaskScheduler::TaskSchedulerWorkGroup::~TaskSchedulerWorkGroup()
{
   if ( m_ItemAvailableSemaphore )
       CloseHandle( m_ItemAvailableSemaphore );
}

void
TaskScheduler::AddItemToWorkGroup(
    SidHandle Sid,
    TaskSchedulerWorkItem *pWorkItem )
{
   // If the work group has alread been created,
   // don't create it again

   WorkGroupMapType::iterator i = m_WorkGroupMap.find( Sid );
   TaskSchedulerWorkGroup *pWorkGroup = NULL;

   if ( m_WorkGroupMap.end() != i )
       {
       pWorkGroup = (*i).second;
       }
   else
       {
       LogTask( "Creating a new work group" );

       while(1)
           {

           try
           {
               pWorkGroup = new TaskSchedulerWorkGroup( Sid );
               m_WorkGroupMap.insert( WorkGroupMapType::value_type( Sid, pWorkGroup ) );
               LogTask( "Created new workgroup %p", pWorkGroup );
               break;
           }
           catch( ComError Error )
           {
               LogError( "Unable to create new workgroup sleeping, error %!winerr!", Error.Error() );
               m_WorkGroupMap.erase( Sid );
               delete pWorkGroup;
               pWorkGroup = NULL;
               Sleep( 5000 );
           }

           }
       }


   LogInfo( "Adding %p to workgroup %p", pWorkItem, pWorkGroup );
   pWorkGroup->m_ReadyList.insert( *pWorkItem );
   pWorkItem->m_State = TASK_STATE_READY;
   pWorkItem->m_WorkGroup = pWorkGroup;
   RTL_VERIFY( ReleaseSemaphore( pWorkGroup->m_ItemAvailableSemaphore, 1, NULL ) );

   // use a very aproximative heuristic to determine when to add more threads.
   // The load is the number of work items that are ready to run plus the number
   // of items being worked on(busy threads). See the note below why the number of
   // ready work items is not a good estimate.
   size_t Load = pWorkGroup->m_ReadyList.size() + pWorkGroup->m_BusyThreads;
   if ( Load > pWorkGroup->m_Threads &&
        pWorkGroup->m_Threads < MAX_WORKGROUP_THREADS )
       {

       LogInfo( "load of %u and %u threads. Add another thread",
                Load, pWorkGroup->m_Threads );

       while(1)
           {

           m_NewWorkerGroup = pWorkGroup;
           ASSERT( m_WorkGroupMap.end() != m_WorkGroupMap.find( m_NewWorkerGroup->m_Sid ) );
           RTL_VERIFY( ResetEvent( m_WorkerInitialized ) );

           HANDLE & ThreadHandle = pWorkGroup->m_Thread[ pWorkGroup->m_Threads ];
           DWORD & ThreadId = pWorkGroup->m_ThreadId[ pWorkGroup->m_Threads ];

           ThreadHandle =
               CreateThread(
                   NULL, // security descriptor
                   0,    // Use default stack
                   TaskScheduler::WorkGroupWorkerThunk,
                   static_cast<LPVOID>( this ),
                   0,
                   &ThreadId );

           if ( !ThreadHandle )
               {
               LogError( "Unable to create new worker, error %!winerr!", GetLastError() );
               Sleep( 5000 );
               continue;
               }


           LogTask( "Created new worker with a handle %p, ID %u", ThreadHandle, ThreadId );

           HANDLE WaitHandles[2] = { ThreadHandle, m_WorkerInitialized };
           DWORD dwResult =
               WaitForMultipleObjectsEx(
                   2,
                   WaitHandles,
                   FALSE,
                   INFINITE,
                   FALSE );

           switch( dwResult )
               {
               case WAIT_OBJECT_0:
                   GetExitCodeThread( ThreadHandle, &dwResult );
                   LogError( "Thread exited with code %!winerr!, sleeping", dwResult );
                   CloseHandle( ThreadHandle );
                   ThreadHandle = 0;
                   ThreadId = 0;

                   Sleep( 5000 );
                   continue;

               case WAIT_OBJECT_0 + 1:
                   break;

               default:
                   LogError( "Unexpected error, %!winerr!", dwResult );
                   ASSERT( 0 );
               }

           LogTask( "Worker signaled success" );
           m_NewWorkerGroup = NULL;
           pWorkGroup->m_Threads++;

           break;
           }
       }
}

void
TaskScheduler::KillBackgroundTasks()
{

    LogTask( "Killing background threads" );
    RTL_VERIFY( WaitForSingleObject( m_SchedulerLock, INFINITE ) == WAIT_OBJECT_0 );

    m_bShouldDie = TRUE;
    DWORD Result;

    while(1)
        {

        if ( m_WorkGroupMap.empty() )
            {
            LogTask( "No more work groups, all done" );
            RTL_VERIFY( ReleaseMutex( m_SchedulerLock ) );
            return;
            }

        TaskSchedulerWorkGroup *pGroup = (*m_WorkGroupMap.begin()).second;
        RTL_VERIFY( ReleaseSemaphore( pGroup->m_ItemAvailableSemaphore, pGroup->m_Threads, NULL ) );

        RTL_VERIFY( ReleaseMutex( m_SchedulerLock ) );

        Result = WaitForMultipleObjects( pGroup->m_Threads, pGroup->m_Thread, TRUE, INFINITE );
        // WAIT_OBJECT_0 == 0 so Result >= WAIT_OBJECT_0 is always true
        ASSERT(  Result < WAIT_OBJECT_0 + pGroup->m_Threads );

        RTL_VERIFY( WaitForSingleObject( m_SchedulerLock, INFINITE ) == WAIT_OBJECT_0 );

        for(size_t c=0; c < pGroup->m_Threads; c++ )
            {
            CloseHandle( pGroup->m_Thread[c] );
            }

        m_WorkGroupMap.erase( pGroup->m_Sid );
        delete pGroup;

        LogTask( "Killed everyone in work group %p", pGroup );

        }
}

DWORD BackgroundThreadProcFilter(
    LPEXCEPTION_POINTERS ExceptionPointers );

DWORD
TaskScheduler::WorkGroupWorkerThunk( void *pContext )
{
   __try
   {
       return
       static_cast<TaskScheduler*>( pContext )->WorkGroupWorker();
   }
    __except( BackgroundThreadProcFilter(
                  GetExceptionInformation() ) )
    {
        ASSERT( 0 );
    }
    ASSERT( 0 );

    return 0;
}

DWORD
TaskScheduler::WorkGroupWorker( )

{
    HRESULT Hr;

    LogTask( "I'm alive!" );

    Hr = CoInitializeEx( NULL, COINIT_MULTITHREADED );

    if ( FAILED( Hr ) )
        {
        LogError( "CoInitializeEx failed, %!winerr!", Hr );
        return (DWORD)(Hr);
        }

    TaskSchedulerWorkGroup *pGroup = m_NewWorkerGroup;

    ASSERT( m_WorkGroupMap.end() != m_WorkGroupMap.find( pGroup->m_Sid ) );

    RTL_VERIFY( SetEvent( m_WorkerInitialized ) );

    LogTask( "Initialization complete" );

    while(1)
        {
        TaskSchedulerWorkItem *pWorkItem = NULL;
        HANDLE Handles[] = { pGroup->m_ItemAvailableSemaphore, m_SchedulerLock };

        DWORD dwWaitResult =
           WaitForMultipleObjectsEx(
               sizeof(Handles)/sizeof(*Handles),
               Handles,
               TRUE,  // Wait for all events
               30000,
               FALSE ); // ablertable wait

        switch( dwWaitResult )
            {
            case WAIT_OBJECT_0:
            case WAIT_OBJECT_0+1:
                break;
            case WAIT_TIMEOUT:
                {
                LogInfo( "Timeout expired, check if we have something to do");
                RTL_VERIFY( WaitForSingleObject( m_SchedulerLock, INFINITE ) == WAIT_OBJECT_0 );
                if ( pGroup->m_ReadyList.empty() )
                    {
                    goto cleanup_on_timeout;
                    }
                else
                    {
                    LogTask( "Still stuff to do, stay alive" );
                    RTL_VERIFY( ReleaseMutex( m_SchedulerLock ) );
                    continue;
                    }
                }
            default:
                ASSERT(0);
            }

        if ( m_bShouldDie )
            {
            LogTask( "Ordered to die, do so" );
            goto dodie;
            }


        ASSERT( !pGroup->m_ReadyList.empty() );

        // Get first item in ready list and move
        // it over to running list.
        pWorkItem = &(*pGroup->m_ReadyList.begin());
        pGroup->m_ReadyList.erase( *pWorkItem );
        pGroup->m_RunningList.insert( *pWorkItem );
        pWorkItem->m_State = TASK_STATE_RUNNING;
        ASSERT( pGroup == pWorkItem->m_WorkGroup );

        // Mark this thread as busy
        // NOTE: This counter is needed because some
        // code marks work items as complete even though
        // the really arn't complete yet.  So we need
        // to have this to indicatate has many threads
        // are really available.
        InterlockedIncrement( &pGroup->m_BusyThreads );

        RTL_VERIFY( ReleaseMutex( m_SchedulerLock ) );

        // Now do the real dispatching

        LogTask( "dispatching %p", pWorkItem );

        RTL_VERIFY( TlsSetValue( m_WorkItemTLS, pWorkItem ) );
        pWorkItem->OnDispatch();
        if (GetCurrentWorkItem())
            CompleteWorkItem();

        // Mark this thread as free
        InterlockedDecrement( &pGroup->m_BusyThreads );

        }

cleanup_on_timeout:

    if ( 1 == pGroup->m_Threads )
        {
        // If were the last thread, destroy the workgroup

        LogTask( "We are the only thread, destroy work group %p", pGroup );

        CloseHandle( pGroup->m_Thread[0] );
        WorkGroupMapType::iterator i = m_WorkGroupMap.find( pGroup->m_Sid );
        ASSERT( m_WorkGroupMap.end() != i );
        m_WorkGroupMap.erase( i );
        delete pGroup;

        }
    else
        {

        // we were not the last thread, so remove ourselves from the list.
        // First, find the slot for this thread.

        size_t index = 0;
        for (;index < pGroup->m_Threads; index++ )
            {
            if ( GetCurrentThreadId() == pGroup->m_ThreadId[index] )
                break;
            }
        ASSERT( index < pGroup->m_Threads );

        LogTask( "We are not the only thread, remove thread in slot %u", index );

        CloseHandle( pGroup->m_Thread[index] );

        // collapse the list
        size_t slots = pGroup->m_Threads - index - 1;
        memmove( &pGroup->m_Thread[index], &pGroup->m_Thread[index+1], slots * sizeof(*pGroup->m_Thread) );
        memmove( &pGroup->m_ThreadId[index], &pGroup->m_ThreadId[index+1], slots * sizeof(*pGroup->m_ThreadId) );

        pGroup->m_Threads--;

        pGroup->m_Thread[pGroup->m_Threads] = 0;
        pGroup->m_ThreadId[pGroup->m_Threads] = 0;
        }

dodie:

    RTL_VERIFY( ReleaseMutex( m_SchedulerLock ) );

    CoUninitialize();
    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\newjob\tescape.cpp ===
#include "stdafx.h"
#include "Shellapi.h"

int _cdecl main( int argc, char*argv[] )
{

    int argcw;

    WCHAR** argvw =
        CommandLineToArgvW( GetCommandLineW(), &argcw );

    WCHAR EscapedURL[ INTERNET_MAX_URL_LENGTH ];

    HRESULT Hr =
        EscapeURL(
            EscapedURL,
            argvw[1],
            false,
            INTERNET_MAX_URL_LENGTH );

    if ( FAILED( Hr ) )
        {
        printf( "Unable to escape URL, error 0x%8.8X\n", Hr );
        return Hr; 
        }        

    printf( "%S\n", EscapedURL );

    return 0; 

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\newjob\proxy.cpp ===
#include "stdafx.h"

#if !defined(BITS_V12_ON_NT4)
#include "proxy.tmh"
#endif


HRESULT
CACHED_AUTOPROXY::Generate(
    const TCHAR Host[]
    )
{
    if (GetTickCount() - m_TimeStamp > CACHED_PROXY_LIFETIME_IN_MSEC)
        {
        m_HostName = L"";
        }

    if (0 == _tcscmp( Host, m_HostName ))
        {
        LogInfo("using existing proxy info for '%S'", Host );
        return S_OK;
        }

    LogInfo( "detecting proxy for '%S'", Host );

    //
    // Detect IE settings and look up proxy if necessary.
    // Boilerplate from Stephen Sulzer.
    //
    WINHTTP_PROXY_INFO          ProxyInfo;
    WINHTTP_AUTOPROXY_OPTIONS   AutoProxyOptions;
    WINHTTP_CURRENT_USER_IE_PROXY_CONFIG    IEProxyConfig;
    LPWSTR AutoConfigUrl = 0;
    BOOL fTryAutoProxy = FALSE;
    BOOL fSuccess = FALSE;

    ZeroMemory(&ProxyInfo, sizeof(ProxyInfo));
    ZeroMemory(&AutoProxyOptions, sizeof(AutoProxyOptions));
    ZeroMemory(&IEProxyConfig, sizeof(IEProxyConfig));

    if (WinHttpGetIEProxyConfigForCurrentUser(&IEProxyConfig))
        {
        LogInfo("got user's IE info");

        if (IEProxyConfig.fAutoDetect)
            {
            LogInfo("IE specifies auto-detect");

            AutoProxyOptions.dwFlags = WINHTTP_AUTOPROXY_AUTO_DETECT;
            AutoProxyOptions.dwAutoDetectFlags = WINHTTP_AUTO_DETECT_TYPE_DHCP |
                                                 WINHTTP_AUTO_DETECT_TYPE_DNS_A;
            fTryAutoProxy = TRUE;
            }

        if (IEProxyConfig.lpszAutoConfigUrl)
            {
            LogInfo("IE specifies auto-config URL '%S'", IEProxyConfig.lpszAutoConfigUrl ? IEProxyConfig.lpszAutoConfigUrl : NullString );

            AutoProxyOptions.dwFlags |= WINHTTP_AUTOPROXY_CONFIG_URL;
            AutoProxyOptions.lpszAutoConfigUrl = IEProxyConfig.lpszAutoConfigUrl;
            AutoConfigUrl                      = IEProxyConfig.lpszAutoConfigUrl;
            fTryAutoProxy = TRUE;
            }

        AutoProxyOptions.fAutoLogonIfChallenged = TRUE;
        }
    else
        {
        LogInfo("no user IE info: %d", GetLastError());

        // WinHttpGetIEProxyForCurrentUser failed, try autodetection anyway...
        AutoProxyOptions.dwFlags =           WINHTTP_AUTOPROXY_AUTO_DETECT;
        AutoProxyOptions.dwAutoDetectFlags = WINHTTP_AUTO_DETECT_TYPE_DHCP |
                                             WINHTTP_AUTO_DETECT_TYPE_DNS_A;
        fTryAutoProxy = TRUE;
        }

    if (fTryAutoProxy)
        {
        LogInfo("trying auto-detect...");

        fSuccess = WinHttpGetProxyForUrl( m_hInternet,
                                          Host,
                                          &AutoProxyOptions,
                                          &ProxyInfo
                                          );
        LogInfo("auto-detect returned %d (%d)", fSuccess, fSuccess ? 0 : GetLastError() );
        }

    // If we didn't do autoproxy or if it failed, see
    // if there's an explicit proxy server in the IE
    // proxy configuration...
    //
    // This is where the WinHttpGetIEProxyConfigForCurrentUser API
    // really comes in handy: in environments in which autoproxy is
    // not supported and so the user's IE browser must be
    // configured with an explicit proxy server.
    //
    if (!fTryAutoProxy || !fSuccess)
        {
        LogInfo("looking for backup ideas");

        if (IEProxyConfig.lpszProxy)
            {
            LogInfo("using named proxy '%S'", IEProxyConfig.lpszProxy ? IEProxyConfig.lpszProxy : NullString );

            ProxyInfo.dwAccessType    = WINHTTP_ACCESS_TYPE_NAMED_PROXY;
            ProxyInfo.lpszProxy       = IEProxyConfig.lpszProxy;
            ProxyInfo.lpszProxyBypass = IEProxyConfig.lpszProxyBypass;
            }
        }

    //
    // Sometimes the registry contains a single or double colon for the proxy or, oddly, bypass list.
    // SetRequestProxy rejects them.  Both cases should be treated like a NULL string.
    //
    static wchar_t SingleColon[] = L":";
    static wchar_t DoubleColon[] = L"::";

    if (ProxyInfo.lpszProxy)
        {
        if (0 == wcscmp( ProxyInfo.lpszProxy, SingleColon ) ||
            0 == wcscmp( ProxyInfo.lpszProxy, DoubleColon ))
            {
            LogWarning("suppressing invalid proxy string %S", ProxyInfo.lpszProxy );
            GlobalFree( ProxyInfo.lpszProxy );
            ProxyInfo.lpszProxy = NULL;
            }
        }

    if (ProxyInfo.lpszProxyBypass)
        {
        if (0 == wcscmp( ProxyInfo.lpszProxyBypass, SingleColon ) ||
            0 == wcscmp( ProxyInfo.lpszProxyBypass, DoubleColon ))
            {
            LogWarning("suppressing invalid bypass string %S", ProxyInfo.lpszProxyBypass );
            GlobalFree( ProxyInfo.lpszProxyBypass );
            ProxyInfo.lpszProxyBypass = NULL;
            }
        }

    LogInfo("proxy '%S'", ProxyInfo.lpszProxy ? ProxyInfo.lpszProxy : NullString );
    LogInfo("bypass list '%S'", ProxyInfo.lpszProxyBypass ? ProxyInfo.lpszProxyBypass : NullString );
    LogInfo("access type %d", ProxyInfo.dwAccessType );

    if (AutoConfigUrl)
        {
        GlobalFree( AutoConfigUrl );
        }

    Clear();

    m_ProxyInfo = ProxyInfo;
    m_HostName = Host;
    m_fValid = true;
    m_TimeStamp = GetTickCount();

    //
    // We don't have to release the proxy server and proxy bypass strings
    // because Clear() will do that.
    //

    return S_OK;
}

void
CACHED_AUTOPROXY::Clear()
{
    if (m_fValid)
        {
        m_fValid = false;
        if (m_ProxyInfo.lpszProxy)       GlobalFree(m_ProxyInfo.lpszProxy);
        if (m_ProxyInfo.lpszProxyBypass) GlobalFree(m_ProxyInfo.lpszProxyBypass);
        }

    ZeroMemory(&m_ProxyInfo, sizeof(m_ProxyInfo));
    m_HostName = NULL;
}

PROXY_SETTINGS_CONTAINER::PROXY_SETTINGS_CONTAINER(
    LPCWSTR Url,
    const PROXY_SETTINGS * ProxySettings
    ) :
    m_ProxyUsage( ProxyUsageFromJobProxyUsage( ProxySettings->ProxyUsage )),
    m_ProxyList(  NULL ),
    m_BypassList( NULL ),
    m_TokenCursor( NULL )
{
    //
    // Set up the list of proxy servers.
    //
    switch (m_ProxyUsage)
        {
        case INTERNET_OPEN_TYPE_DIRECT:
            break;

        case INTERNET_OPEN_TYPE_PROXY:
            {
            m_MasterProxyList  = ProxySettings->ProxyList;
            m_BypassList       = ProxySettings->ProxyBypassList;
            break;
            }

        case INTERNET_OPEN_TYPE_PRECONFIG:
            {
            THROW_HRESULT( g_ProxyCache->Generate( Url ));

            m_MasterProxyList  = g_ProxyCache->GetProxyList();
            m_BypassList       = g_ProxyCache->GetBypassList();
            m_AccessType = g_ProxyCache->GetAccessType();
            break;
            }

        default:
            ASSERT( 0 );
            break;
        }

    ResetCurrentProxy();
}


HRESULT
SetRequestProxy(
    HINTERNET hRequest,
    PROXY_SETTINGS_CONTAINER * ProxySettings
    )
{
    WINHTTP_PROXY_INFO ProxyInfo;

    ProxyInfo.dwAccessType    = ProxySettings->GetProxyUsage();
    ProxyInfo.lpszProxy       = const_cast<LPWSTR>( ProxySettings->GetCurrentProxy() );
    ProxyInfo.lpszProxyBypass = const_cast<LPWSTR>( ProxySettings->GetBypassList() );

    LogInfo("proxy info:");
    LogInfo("access: %d",  ProxyInfo.dwAccessType );
    LogInfo("server '%S'", ProxyInfo.lpszProxy       ? ProxyInfo.lpszProxy       : NullString );
    LogInfo("bypass '%S'", ProxyInfo.lpszProxyBypass ? ProxyInfo.lpszProxyBypass : NullString );

    if (ProxyInfo.dwAccessType == INTERNET_OPEN_TYPE_DIRECT)
        {
        LogInfo("proxy usage disabled");
        return S_OK;
        }

    if (ProxyInfo.lpszProxy == NULL)
        {
        LogInfo("null proxy");
        return S_OK;
        }

    if (ProxyInfo.dwAccessType == INTERNET_OPEN_TYPE_PRECONFIG)
        {
        LogInfo("mapping PRECONFIG to named proxy");
        ProxyInfo.dwAccessType = INTERNET_OPEN_TYPE_PROXY;
        }

    if (!WinHttpSetOption( hRequest,
                           WINHTTP_OPTION_PROXY,
                           &ProxyInfo,
                           sizeof(ProxyInfo)
                           ))
        {
        DWORD err = GetLastError();

        LogWarning( "can't set proxy option: %!winerr!", err );
        return HRESULT_FROM_WIN32( err );
        }

    return S_OK;
}

bool IsPossibleProxyFailure( DWORD err )
{
    switch (err)
        {
        case ERROR_WINHTTP_NAME_NOT_RESOLVED:
        case ERROR_WINHTTP_CANNOT_CONNECT:
        case ERROR_WINHTTP_CONNECTION_ERROR:
        case ERROR_WINHTTP_TIMEOUT:
            return true;

        default:
            return false;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\newjob\uploader.h ===
class CFile;

enum UPLOAD_STATE
{
    UPLOAD_STATE_CREATE_SESSION,
    UPLOAD_STATE_SEND_DATA,
    UPLOAD_STATE_GET_REPLY,
    UPLOAD_STATE_CLOSE_SESSION,
    UPLOAD_STATE_CLOSED,
    UPLOAD_STATE_CANCEL_SESSION,
    UPLOAD_STATE_CANCELLED
};

struct UPLOAD_DATA
{
    UPLOAD_STATE    State;
    bool            fSchedulable;
    GUID            Protocol;
    GUID            SessionId;

    StringHandle    ReplyUrl;

    StringHandle    HostId;
    DWORD           HostIdFallbackTimeout;
    FILETIME        HostIdNoProgressStartTime;

    //---------------------------

    UPLOAD_DATA();
    ~UPLOAD_DATA();

    void Serialize( HANDLE hFile );
    void Unserialize( HANDLE hFile );

    void SetUploadState( UPLOAD_STATE NewState );
};


FILE_DOWNLOAD_RESULT
CategorizeError(
    QMErrInfo  & ErrInfo
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\newjob\tasksched.h ===
/************************************************************************

Copyright (c) 2000 - 2000 Microsoft Corporation

Module Name :

    tasksched.h

Abstract :

    Header file for task manager classes and routines.

Author :

Revision History :

 ***********************************************************************/

#pragma once

#if !defined(__QMGR_TASKSCHEDULER_)
#define __QMGR_TASKSCHEDULER__

#include <set>
#include <map>
#include <clist.h>

using namespace std;

#define SYNCHRONIZED_READ
#define SYNCHRONIZED_WRITE

class TaskScheduler;
class TaskSchedulerWorkItem;
class TaskSchedulerWorkItemSorter;
class SortedWorkItemList;

enum TASK_SCHEDULER_WORK_ITEM_STATE
{
    TASK_STATE_WAITING,
    TASK_STATE_READY,
    TASK_STATE_RUNNING,
    TASK_STATE_CANCELED,
    TASK_STATE_COMPLETE,
    TASK_STATE_NOTHING
};

class TaskSchedulerWorkItem :
    public IntrusiveList<TaskSchedulerWorkItem>::Link
    {
private:

    FILETIME m_InsertionTime;
    FILETIME m_TimeToRun; // 0 if should run now.
    HANDLE m_CancelEvent; // Signaled on request to cancel.
    HANDLE m_ItemComplete; // Signaled on item complete.
    HANDLE m_ItemCanceled; // Signaled on item cancel.

    void * m_WorkGroup;
    TASK_SCHEDULER_WORK_ITEM_STATE m_State;


public:

    SortedWorkItemList * m_Container;

    //--------------------------------------------------------------------

    TaskSchedulerWorkItem( FILETIME *pTimeToRun = NULL );
    virtual ~TaskSchedulerWorkItem();

    virtual void OnDispatch() = 0;   // Called when work item is dispatched

    friend TaskScheduler;
    friend TaskSchedulerWorkItemSorter;

    void Serialize(
        HANDLE hFile
        );

    void Unserialize(
        HANDLE hFile
        );

    virtual SidHandle GetSid() = 0;

    };

class TaskSchedulerWorkItemSorter
    {
public:
    bool operator()(TaskSchedulerWorkItem *pA, TaskSchedulerWorkItem *pB ) const
    {
        // Convert all times to UINT64
        UINT64 TimeToRunA = FILETIMEToUINT64( pA->m_TimeToRun );
        UINT64 TimeToRunB = FILETIMEToUINT64( pB->m_TimeToRun );
        UINT64 InsertionTimeA = FILETIMEToUINT64( pA->m_InsertionTime );
        UINT64 InsertionTimeB = FILETIMEToUINT64( pB->m_InsertionTime );

        if ( TimeToRunA != TimeToRunB )
            return(TimeToRunA < TimeToRunB );
        if ( InsertionTimeA != InsertionTimeB )
            return(InsertionTimeA < InsertionTimeB);
        return pA < pB;
    }
    };

class SortedWorkItemList : public IntrusiveList<TaskSchedulerWorkItem>

{
    typedef IntrusiveList<TaskSchedulerWorkItem>::iterator iterator;

    TaskSchedulerWorkItemSorter m_sorter;

public:

    void insert( TaskSchedulerWorkItem & val )
    {
        for (iterator iter=begin(); iter != end(); ++iter)
            {
            if ( false == m_sorter( &(*iter), &val ))
                {
                break;
                }
            }

        IntrusiveList<TaskSchedulerWorkItem>::insert( iter, val );

        val.m_Container = this;
    }

    size_t erase(  TaskSchedulerWorkItem & val )
    {
        ASSERT( val.m_Container == NULL || val.m_Container == this );

        val.m_Container = NULL;

        return IntrusiveList<TaskSchedulerWorkItem>::erase( val );
    }
};

class TaskScheduler
    {
public:

    TaskScheduler(); //Throws an HRESULT exception on error
    virtual ~TaskScheduler();

    // Handle which is signaled when a work item may be available.
    HANDLE GetWaitableObject();

    // Gets the current work item for the current thread.
    // Returns NULL if no work item is active.
    TaskSchedulerWorkItem* GetCurrentWorkItem();

    // Gets the cancel event for current work item, else return NULL
    HANDLE GetCancelEvent();

    // Returns true if the job assigned to the current thread
    // has a requested abort. Returns false if no job is assigned.
    bool PollAbort();

    // Gets a work item off the queue if available and dispatches it.
    void DispatchWorkItem();

    // returns true if the job completed before the cancel
    // This should not happen if both the thread that does the canceling
    // and the canceler thread are holdering the writer lock.
    // If the current thread is canceling the work item, the cancel is acknowledged immediatly.
    bool CancelWorkItem( TaskSchedulerWorkItem *pWorkItem );

    // Completes the current work item.
    void CompleteWorkItem();

    // Acknoledges a cancel of the current work item
    void AcknowledgeWorkItemCancel();

    void
    InsertDelayedWorkItem(
        TaskSchedulerWorkItem *pWorkItem,
        UINT64 Delay100Nsec
        );

    void RescheduleDelayedTask( TaskSchedulerWorkItem *pWorkItem, UINT64 Delay100Nsec );


    void InsertWorkItem( TaskSchedulerWorkItem *pWorkItem, FILETIME *pTimeToRun = NULL );

    bool IsWorkItemInScheduler( TaskSchedulerWorkItem *pWorkItem );

    // returns true if current job cancelled before lock acquire
    bool LockReader();
    void UnlockReader();
    // returns true if current job cancelled before lock acquire
    bool LockWriter();
    void UnlockWriter();

    bool IsWriter()
    {
        if (m_WriterOwner == GetCurrentThreadId())
            {
            return true;
            }

        return false;
    }

    void KillBackgroundTasks();

private:

    static const size_t MAX_WORKGROUP_THREADS = 4;

    class TaskSchedulerWorkGroup
    {
    public:
        SidHandle m_Sid;
        SortedWorkItemList m_ReadyList;
        SortedWorkItemList m_RunningList;
        HANDLE m_ItemAvailableSemaphore;
        DWORD m_Threads;
        HANDLE m_Thread[MAX_WORKGROUP_THREADS];
        DWORD m_ThreadId[MAX_WORKGROUP_THREADS];
        LONG m_BusyThreads;
        TaskSchedulerWorkGroup( SidHandle Sid );
        ~TaskSchedulerWorkGroup();
    };

    bool m_bShouldDie;
    HANDLE m_SchedulerLock, m_WaitableTimer, m_ReaderLock, m_WriterSemaphore;
    LONG m_ReaderCount;
    DWORD m_WorkItemTLS;
    DWORD m_WriterOwner;

    SortedWorkItemList m_WaitingList;

    typedef map<SidHandle, TaskSchedulerWorkGroup*, CSidSorter> WorkGroupMapType;
    WorkGroupMapType m_WorkGroupMap;

    // Only used when creating a new background worker
    HANDLE m_WorkerInitialized;
    TaskSchedulerWorkGroup *m_NewWorkerGroup;

    void CompleteWorkItem( bool bCancel );
    void Reschedule();

    void AddItemToWorkGroup(
        SidHandle Sid,
        TaskSchedulerWorkItem *pWorkItem );
    static DWORD WorkGroupWorkerThunk( void *pContext );
    DWORD WorkGroupWorker( );
};


/////////////////////////////////////////////////////////////////////////////
// Simple inlined functions
/////////////////////////////////////////////////////////////////////////////

inline HANDLE
TaskScheduler::GetWaitableObject()
{
    return m_WaitableTimer;
}

inline TaskSchedulerWorkItem*
TaskScheduler::GetCurrentWorkItem()
{
    return(TaskSchedulerWorkItem*)TlsGetValue( m_WorkItemTLS );
}

inline HANDLE
TaskScheduler::GetCancelEvent()
{
    TaskSchedulerWorkItem *pWorkItem = GetCurrentWorkItem();
    return pWorkItem ? pWorkItem->m_CancelEvent : NULL;
}

inline bool
TaskScheduler::PollAbort()
{
    return( WaitForSingleObject( GetCancelEvent(), 0 ) == WAIT_OBJECT_0 );
}

inline void
TaskScheduler::CompleteWorkItem()
{
    CompleteWorkItem(false);
}

inline void
TaskScheduler::AcknowledgeWorkItemCancel()
{
    ASSERT( PollAbort() );
    CompleteWorkItem(true);
}

class HoldReaderLock
    {
    TaskScheduler * const m_TaskScheduler;
    bool                  m_Taken;

public:
    HoldReaderLock( TaskScheduler *pTaskScheduler ) :
        m_TaskScheduler( pTaskScheduler ),
        m_Taken( false )
    {
        if (false == m_TaskScheduler->IsWriter() )
            {
            RTL_VERIFY( !m_TaskScheduler->LockReader() );
            m_Taken = true;
            }
    }

    HoldReaderLock( TaskScheduler & TaskScheduler ) :
        m_TaskScheduler( &TaskScheduler ),
        m_Taken( false )
    {
        if (false == m_TaskScheduler->IsWriter() )
            {
            RTL_VERIFY( !m_TaskScheduler->LockReader() );
            m_Taken = true;
            }
    }

    ~HoldReaderLock()
    {
        if (m_Taken)
            {
            m_TaskScheduler->UnlockReader();
            }
    }
    };

class HoldWriterLock
    {
    TaskScheduler * const m_TaskScheduler;
    bool                  m_Taken;

public:
    HoldWriterLock( TaskScheduler *pTaskScheduler ) :
        m_TaskScheduler( pTaskScheduler ),
        m_Taken( false )
    {
        if (false == m_TaskScheduler->IsWriter() )
            {
            RTL_VERIFY( !m_TaskScheduler->LockWriter() );
            m_Taken = true;
            }
    }

    HoldWriterLock( TaskScheduler & TaskScheduler ) :
    m_TaskScheduler( &TaskScheduler ),
    m_Taken( false )
    {
        if (false == m_TaskScheduler->IsWriter() )
            {
            RTL_VERIFY( !m_TaskScheduler->LockWriter() );
            m_Taken = true;
            }
    }

    ~HoldWriterLock()
    {
        if (m_Taken)
            {
            m_TaskScheduler->UnlockWriter();
            }
    }
    };


template<class T, DWORD LockFlags >
class CLockedReadPointer
    {
protected:
    const T * const m_Pointer;
public:
    CLockedReadPointer( const T * Pointer) :
       m_Pointer(Pointer)
    {
        RTL_VERIFY( !g_Manager->LockReader() );
    }
    ~CLockedReadPointer()
    {
        g_Manager->UnlockReader();
    }
    HRESULT ValidateAccess()
    {
        return m_Pointer->CheckClientAccess(LockFlags);
    }
    const T * operator->() const { return m_Pointer; }
    };

template<class T, DWORD LockFlags>
class CLockedWritePointer
    {
protected:
    T * const m_Pointer;
public:
    CLockedWritePointer( T * Pointer ) :
        m_Pointer(Pointer)
    {
        RTL_VERIFY( !g_Manager->LockWriter() );
    }
    ~CLockedWritePointer()
    {
        g_Manager->UnlockWriter();
    }
    HRESULT ValidateAccess()
    {
        return m_Pointer->CheckClientAccess(LockFlags);
    }
    T * operator->() const { return m_Pointer; }
    };

#endif //__QMGR_TASKSCHEDULER__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\server\bitsoc\ocgen.cpp ===
/*
 *  Copyright (c) 2001  Microsoft Corporation
 *
 *  Module Name:
 *
 *      ocgen.cpp
 *
 *  Abstract:
 *
 *      This file handles all messages passed by the OC Manager
 *
 *  Author:
 *
 *      Michael Zoran (mzoran) Dec-2001
 *
 *  Environment:
 *
 *    User Mode
 */

#define _OCGEN_CPP_
#include <stdlib.h>
#include <assert.h>
#include <tchar.h>
#include <objbase.h>
#include <shlwapi.h>
#include <lm.h>
#include <malloc.h>
#include "ocgen.h"
#pragma hdrstop

// also referred to in ocgen.h        // forward reference

struct BITS_SUBCOMPONENT_DATA
{
   const TCHAR * SubcomponentName;
   const TCHAR * SubcomponentKeyFileName;
   UINT64 FileVersion;
   BOOL Preinstalled;
   BOOL ShouldUpgrade;
};

DWORD OnInitComponent(LPCTSTR ComponentId, PSETUP_INIT_COMPONENT psc);
DWORD_PTR OnQueryImage();
DWORD OnQuerySelStateChange(LPCTSTR ComponentId, LPCTSTR SubcomponentId, UINT state, UINT flags);
DWORD OnCalcDiskSpace(LPCTSTR ComponentId, LPCTSTR SubcomponentId, DWORD addComponent, HDSKSPC dspace);
DWORD OnQueueFileOps(LPCTSTR ComponentId, LPCTSTR SubcomponentId, HSPFILEQ queue);
DWORD OnCompleteInstallation(LPCTSTR ComponentId, LPCTSTR SubcomponentId);
DWORD OnQueryState(LPCTSTR ComponentId, LPCTSTR SubcomponentId, UINT state);
DWORD OnAboutToCommitQueue(LPCTSTR ComponentId, LPCTSTR SubcomponentId);
DWORD OnExtraRoutines(LPCTSTR ComponentId, PEXTRA_ROUTINES per);

BOOL  VerifyComponent(LPCTSTR ComponentId);
BOOL  StateInfo(LPCTSTR SubcomponentId, BOOL *state);
DWORD RegisterServers(HINF hinf, LPCTSTR component, DWORD state);
DWORD EnumSections(HINF hinf, const TCHAR *component, const TCHAR *key, DWORD index, INFCONTEXT *pic, TCHAR *name);
DWORD RegisterServices(PPER_COMPONENT_DATA cd, LPCTSTR component, DWORD state);
DWORD CleanupNetShares(PPER_COMPONENT_DATA cd, LPCTSTR component, DWORD state);
DWORD RunExternalProgram(PPER_COMPONENT_DATA cd, LPCTSTR component, DWORD state);

BITS_SUBCOMPONENT_DATA* FindSubcomponent( LPCTSTR SubcomponentId );
DWORD InitializeSubcomponentStates( );
DWORD GetFileVersion64( LPCTSTR szFullPath, ULONG64 *pVer );
DWORD GetModuleVersion64( HMODULE hDll, ULONG64 * pVer );

HRESULT StopIIS();

// for registering dlls

typedef HRESULT (__stdcall *pfn)(void);

#define KEYWORD_REGSVR       TEXT("RegSvr")
#define KEYWORD_UNREGSVR     TEXT("UnregSvr")
#define KEYWORD_UNINSTALL    TEXT("Uninstall")
#define KEYWORD_SOURCEPATH   TEXT("SourcePath")
#define KEYWORD_DELSHARE     TEXT("DelShare")
#define KEYWORD_ADDSERVICE   TEXT("AddService")
#define KEYWORD_DELSERVICE   TEXT("DelService")
#define KEYWORD_SHARENAME    TEXT("Share")
#define KEYWORD_RUN          TEXT("Run")
#define KEYVAL_SYSTEMSRC     TEXT("SystemSrc")
#define KEYWORD_COMMANDLINE  TEXT("CommandLine")
#define KEYWORD_TICKCOUNT    TEXT("TickCount")

// Services keywords/options
#define KEYWORD_SERVICENAME  TEXT("ServiceName")
#define KEYWORD_DISPLAYNAME  TEXT("DisplayName")
#define KEYWORD_SERVICETYPE  TEXT("ServiceType")
#define KEYWORD_STARTTYPE    TEXT("StartType")
#define KEYWORD_ERRORCONTROL TEXT("ErrorControl")
#define KEYWORD_IMAGEPATH    TEXT("BinaryPathName")
#define KEYWORD_LOADORDER    TEXT("LoadOrderGroup")
#define KEYWORD_DEPENDENCIES TEXT("Dependencies")
#define KEYWORD_STARTNAME    TEXT("ServiceStartName")
#define KEYWORD_PASSWORD     TEXT("Password")

#define KEYVAL_ON            TEXT("on")
#define KEYVAL_OFF           TEXT("off")
#define KEYVAL_DEFAULT       TEXT("default")

const char gszRegisterSvrRoutine[]   = "DllRegisterServer";
const char gszUnregisterSvrRoutine[] = "DllUnregisterServer";
BOOL g_fRebootNeed = FALSE;

BITS_SUBCOMPONENT_DATA g_Subcomponents[] =
{
    {
    TEXT("BITSServerExtensionsManager"),
    TEXT("bitsmgr.dll"),
    0,
    FALSE,
    FALSE
    },

    {
    TEXT("BITSServerExtensionsISAPI"),
    TEXT("bitssrv.dll"),
    0,
    FALSE,
    FALSE
    }
};

const ULONG g_NumberSubcomponents   = 2;
BOOL g_AllSubcomponentsPreinstalled = FALSE;
BOOL g_UpdateNeeded                 = FALSE;
BOOL g_IISStopped                   = FALSE;

PER_COMPONENT_DATA g_Component; 


/*
 * called by CRT when _DllMainCRTStartup is the DLL entry point
 */

BOOL
WINAPI
DllMain(
    IN HINSTANCE hinstance,
    IN DWORD     reason,
    IN LPVOID    reserved
    )
{

    BOOL b;

    UNREFERENCED_PARAMETER(reserved);

    b = true;

    switch(reason)
    {
    case DLL_PROCESS_ATTACH:
        ghinst = hinstance;
        loginit();

        // Fall through to process first thread

    case DLL_THREAD_ATTACH:
        b = true;
        break;

    case DLL_PROCESS_DETACH:
        break;

    case DLL_THREAD_DETACH:
        break;
    }

    return(b);
}


DWORD_PTR
OcEntry(
    IN     LPCTSTR ComponentId,
    IN     LPCTSTR SubcomponentId,
    IN     UINT    Function,
    IN     UINT    Param1,
    IN OUT PVOID   Param2
    )
{

    DWORD_PTR rc;

    DebugTraceOCNotification(Function, ComponentId);
    logOCNotification(Function, ComponentId);

    switch(Function)
    {

     case OC_PREINITIALIZE:
#ifdef ANSI
        rc = OCFLAG_ANSI;
#else
        rc = OCFLAG_UNICODE;
#endif
        break;

    case OC_INIT_COMPONENT:
        rc = OnInitComponent(ComponentId, (PSETUP_INIT_COMPONENT)Param2);
        break;

    case OC_EXTRA_ROUTINES:
        rc = OnExtraRoutines(ComponentId, (PEXTRA_ROUTINES)Param2);
        break;

    case OC_SET_LANGUAGE:
        rc = (DWORD_PTR)false;
        break;

    case OC_QUERY_IMAGE:
        rc = OnQueryImage();
        break;

    case OC_REQUEST_PAGES:
        rc = 0;
        break;

    case OC_QUERY_CHANGE_SEL_STATE:
        rc = OnQuerySelStateChange(ComponentId, SubcomponentId, Param1, (UINT)((UINT_PTR)Param2));
        break;

    case OC_CALC_DISK_SPACE:
        rc = OnCalcDiskSpace(ComponentId, SubcomponentId, Param1, Param2);
        break;

    case OC_QUEUE_FILE_OPS:
        rc = OnQueueFileOps(ComponentId, SubcomponentId, (HSPFILEQ)Param2);
        break;

    case OC_NOTIFICATION_FROM_QUEUE:
        rc = NO_ERROR;
        break;

    case OC_QUERY_STEP_COUNT:
        rc = 2;
        break;

    case OC_COMPLETE_INSTALLATION:
        rc = OnCompleteInstallation(ComponentId, SubcomponentId);
        break;

    case OC_CLEANUP:
        rc = NO_ERROR;
        break;

    case OC_QUERY_STATE:
        rc = OnQueryState(ComponentId, SubcomponentId, Param1);
        break;

    case OC_NEED_MEDIA:
        rc = false;
        break;

    case OC_ABOUT_TO_COMMIT_QUEUE:
        rc = OnAboutToCommitQueue(ComponentId,SubcomponentId);
        break;

    case OC_QUERY_SKIP_PAGE:
        rc = false;
        break;

    case OC_WIZARD_CREATED:
        rc = NO_ERROR;
        break;

    default:
        rc = NO_ERROR;
        break;
    }

    DebugTrace(1, TEXT("processing completed"));
    logOCNotificationCompletion();

    return rc;
}

/*-------------------------------------------------------*/
/*
 * OC Manager message handlers
 *
 *-------------------------------------------------------*/

/*
 * OnInitComponent()
 *
 * handler for OC_INIT_COMPONENT
 */

DWORD OnInitComponent(LPCTSTR ComponentId, PSETUP_INIT_COMPONENT psc)
{
    INFCONTEXT context;
    TCHAR buf[256];
    HINF hinf;
    BOOL rc;

    memset( &g_Component, 0, sizeof( g_Component ) );

    if (!VerifyComponent( ComponentId ) )
        return NO_ERROR;

    DWORD dwResult = InitializeSubcomponentStates();
    if ( ERROR_SUCCESS != dwResult )
        return dwResult;

    g_IISStopped = FALSE;

    // store component inf handle

    g_Component.hinf = (psc->ComponentInfHandle == INVALID_HANDLE_VALUE)
                        ? NULL
                        : psc->ComponentInfHandle;

    // open the inf

    if (g_Component.hinf)
        SetupOpenAppendInfFile(NULL, g_Component.hinf,NULL);

    // copy helper routines and flags

    g_Component.HelperRoutines = psc->HelperRoutines;

    g_Component.Flags = psc->SetupData.OperationFlags;

    g_Component.SourcePath = NULL;

    // play

    srand(GetTickCount());

    return NO_ERROR;
}

/*
 * OnExtraRoutines()
 *
 * handler for OC_EXTRA_ROUTINES
 */

DWORD OnExtraRoutines(LPCTSTR ComponentId, PEXTRA_ROUTINES per)
{

    if (!VerifyComponent( ComponentId ) )
        return NO_ERROR;

    memcpy(&g_Component.ExtraRoutines, per, sizeof( g_Component.ExtraRoutines ) );
    g_Component.ExtraRoutines.size = sizeof( g_Component.ExtraRoutines );

    return NO_ERROR;
}

/*
 * OnSetLanguage()
 *
 * handler for OC_SET_LANGUAGE
 */

DWORD_PTR OnQueryImage()
{
    return (DWORD_PTR)LoadBitmap(NULL,MAKEINTRESOURCE(32754));     // OBM_CLOSE
}


/*
 * OnQuerySelStateChange()
 *
 * don't let the user deselect the sam component
 */

DWORD OnQuerySelStateChange(LPCTSTR ComponentId,
                            LPCTSTR SubcomponentId,
                            UINT    state,
                            UINT    flags)
{

    DWORD rc = true;

    if ( !VerifyComponent( ComponentId ) )
        return rc;


    if ( !_tcsicmp( SubcomponentId, TEXT( "BITSServerExtensions" ) ) )
        {

        if ( state )
            {

            if ( flags & OCQ_DEPENDENT_SELECTION )
                {
                rc = false;
                }

            }
        }
    return rc;
}

/*
 * OnCalcDiskSpace()
 *
 * handler for OC_ON_CALC_DISK_SPACE
 */

DWORD OnCalcDiskSpace(LPCTSTR ComponentId,
                      LPCTSTR SubcomponentId,
                      DWORD addComponent,
                      HDSKSPC dspace)
{
    DWORD rc = NO_ERROR;
    TCHAR section[S_SIZE];

    //
    // Param1 = 0 if for removing component or non-0 if for adding component
    // Param2 = HDSKSPC to operate on
    //
    // Return value is Win32 error code indicating outcome.
    //
    // In our case the private section for this component/subcomponent pair
    // is a simple standard inf install section, so we can use the high-level
    // disk space list api to do what we want.
    //

    if (!VerifyComponent( ComponentId ) )
        return NO_ERROR;

    StringCchCopy(section, S_SIZE, SubcomponentId);

    if (addComponent)
    {
        rc = SetupAddInstallSectionToDiskSpaceList(dspace,
                                                   g_Component.hinf,
                                                   NULL,
                                                   section,
                                                   0,
                                                   0);
    }
    else
    {
        rc = SetupRemoveInstallSectionFromDiskSpaceList(dspace,
                                                        g_Component.hinf,
                                                        NULL,
                                                        section,
                                                        0,
                                                        0);
    }

    if (!rc)
        rc = GetLastError();
    else
        rc = NO_ERROR;

    return rc;
}

/*
 * OnQueueFileOps()
 *
 * handler for OC_QUEUE_FILE_OPS
 */

DWORD OnQueueFileOps(LPCTSTR ComponentId, LPCTSTR SubcomponentId, HSPFILEQ queue)
{
    BOOL                state;
    BOOL                rc;
    INFCONTEXT          context;
    TCHAR               section[256];
    TCHAR               srcpathbuf[256];
    TCHAR              *srcpath;

    if (!VerifyComponent(ComponentId))
        return NO_ERROR;

    if (!SubcomponentId || !*SubcomponentId)
        return NO_ERROR;

    g_Component.queue = queue;

    if (!StateInfo(SubcomponentId, &state))
        return NO_ERROR;

    StringCchPrintfW(section, 256, SubcomponentId);

    rc = TRUE;
    if (!state) {
        // being uninstalled. Fetch uninstall section name.
        rc = SetupFindFirstLine(g_Component.hinf,
                                SubcomponentId,
                                KEYWORD_UNINSTALL,
                                &context);

        if (rc) {
            rc = SetupGetStringField(&context,
                                     1,
                                     section,
                                     sizeof(section) / sizeof(TCHAR),
                                     NULL);
        }

        // also, unregister the dlls and kill services before deletion

        SetupInstallServicesFromInfSection(g_Component.hinf, section, 0);
        SetupInstallFromInfSection(NULL,g_Component.hinf,section,SPINST_UNREGSVR,NULL,NULL,0,NULL,NULL,NULL,NULL);        
    }

    if (rc) {
        // if uninstalling, don't use version checks
        rc = SetupInstallFilesFromInfSection(g_Component.hinf,
                                             NULL,
                                             queue,
                                             section,
                                             g_Component.SourcePath,
//                                             state ? SP_COPY_NEWER : 0);
                                             0 );
    }

    if (!rc)
        return GetLastError();

    return NO_ERROR;
}

/*
 * OnCompleteInstallation
 *
 * handler for OC_COMPLETE_INSTALLATION
 */

DWORD OnCompleteInstallation(LPCTSTR ComponentId, LPCTSTR SubcomponentId)
{
    INFCONTEXT          context;
    TCHAR               section[256];
    BOOL                state;
    BOOL                rc;
    DWORD               Error = NO_ERROR;

    // Do post-installation processing in the cleanup section.
    // This way we know all compoents queued for installation
    // have beein installed before we do our stuff.

    if (!VerifyComponent(ComponentId))
        return NO_ERROR;

    if (!SubcomponentId || !*SubcomponentId)
        return NO_ERROR;

    // if this is gui mode setup, need to regsvr just in case something
    // changed even if the files are not being replaced.

    if ( !(g_Component.Flags & SETUPOP_STANDALONE) &&
         ( ( _tcsicmp( TEXT("BITSServerExtensionsManager"), SubcomponentId ) == 0 ) ||
           ( _tcsicmp( TEXT("BITSServerExtensionsISAPI"), SubcomponentId ) == 0 ) ) )
        {

        BOOL SettingChanged = StateInfo( SubcomponentId, &state );

        if ( !SettingChanged && !state )
            return NO_ERROR; // if its not installed, leave it uninstalled.

        }

    else if ( !StateInfo( SubcomponentId, &state) )
        return NO_ERROR;

    StringCchPrintfW(section, 256, SubcomponentId);

    rc = TRUE;
    if (!state) {
        // being uninstalled. Fetch uninstall section name.
        rc = SetupFindFirstLine(g_Component.hinf,
                                SubcomponentId,
                                KEYWORD_UNINSTALL,
                                &context);

        if (rc) {
            rc = SetupGetStringField(&context,
                                     1,
                                     section,
                                     sizeof(section) / sizeof(TCHAR),
                                     NULL);
        }
    }

    if (state) { 
        //
        // installation
        //

        if (rc) {
            // process the inf file
            rc = SetupInstallFromInfSection(NULL,                                // hwndOwner
                                            g_Component.hinf,                    // inf handle
                                            section,                             // name of component
                                            SPINST_ALL & ~SPINST_FILES,
                                            NULL,                                // relative key root
                                            NULL,                                // source root path
                                            0,                                   // copy flags
                                            NULL,                                // callback routine
                                            NULL,                                // callback routine context
                                            NULL,                                // device info set
                                            NULL);                               // device info struct
    
            if (rc) {
                rc = SetupInstallServicesFromInfSection(g_Component.hinf, section, 0);
                Error = GetLastError();        
            
                if (!rc && Error == ERROR_SECTION_NOT_FOUND) {
                    rc = TRUE;
                    Error = NO_ERROR;
                }
            
                if (rc) {
                    if (Error == ERROR_SUCCESS_REBOOT_REQUIRED) {
                        g_Component.HelperRoutines.SetReboot(g_Component.HelperRoutines.OcManagerContext,TRUE);
                    }
                    Error = NO_ERROR;
                    rc = RunExternalProgram(&g_Component, section, state);            
                }
            }
        }

    } else { 
        
        //
        // uninstallation
        //
    
        if (rc)
        {

            rc = RunExternalProgram(&g_Component, section, state);

        }
        if (rc) {
            
            rc = CleanupNetShares(&g_Component, section, state);

        }
    }

    if (!rc && (Error == NO_ERROR) ) {
        Error = GetLastError( );
    }

    return Error;
}


/*
 * OnQueryState()
 *
 * handler for OC_QUERY_STATE
 */

DWORD OnQueryState(LPCTSTR ComponentId,
                   LPCTSTR SubcomponentId,
                   UINT    state)
{
    if ( !VerifyComponent( ComponentId ) )
        return SubcompUseOcManagerDefault;

    BITS_SUBCOMPONENT_DATA* SubcomponentData =
        FindSubcomponent( SubcomponentId );

    if ( !SubcomponentData )
        {

        if ( !_tcsicmp( TEXT( "BITSServerExtensions" ), SubcomponentId ) )
            {

            if ( OCSELSTATETYPE_ORIGINAL == state &&
                 g_AllSubcomponentsPreinstalled )
                return SubcompOn;
            else
                return SubcompUseOcManagerDefault;


            }
        else
            return SubcompUseOcManagerDefault;

        }

    if ( OCSELSTATETYPE_ORIGINAL == state )
        {

        return SubcomponentData->Preinstalled ? SubcompOn : SubcompOff;

        }

    return SubcompUseOcManagerDefault;
}

/*
 * OnAboutToCommitQueue()
 *
 * handler for OC_ABOUT_TO_COMMIT_QUEUE
 */

DWORD OnAboutToCommitQueue(LPCTSTR ComponentId, LPCTSTR SubcomponentId)
{
    BOOL                state;
    BOOL                rc;
    INFCONTEXT          context;
    TCHAR               section[256];
    TCHAR               srcpathbuf[256];
    TCHAR              *srcpath;

    if (!VerifyComponent( ComponentId ))
        return NO_ERROR;

    if (!SubcomponentId || !*SubcomponentId)
        return NO_ERROR;

    if (!StateInfo( SubcomponentId, &state))
        return NO_ERROR;

    if (state) {

        if ( g_UpdateNeeded )
            {

            if ( !g_IISStopped )
                {
                StopIIS();
                g_IISStopped = FALSE;
                }

            }

        return NO_ERROR;
    }

    // Fetch uninstall section name.
    rc = SetupFindFirstLine(
                    g_Component.hinf,
                    SubcomponentId,
                    KEYWORD_UNINSTALL,
                    &context);

    if (rc) {
        rc = SetupGetStringField(
                     &context,
                     1,
                     section,
                     sizeof(section) / sizeof(TCHAR),
                     NULL);
    }

    if (rc) 
        rc = SetupInstallServicesFromInfSection(g_Component.hinf, section, 0);

    if (rc) {
        rc = SetupInstallFromInfSection(
                    NULL,
                    g_Component.hinf,
                    section,
                    SPINST_ALL & ~SPINST_FILES,
                    NULL,
                    NULL,
                    0,
                    NULL,
                    NULL,
                    NULL,
                    NULL);        
    }
    
    if (rc) {
       SetLastError(NO_ERROR);
    }
    return GetLastError();

}

BOOL VerifyComponent( LPCTSTR ComponentId )
{
    if ( !_tcsicmp( ComponentId, TEXT("BITSServerExtensions") ) )
        return TRUE;
    return FALSE;
}

// loads current selection state info into "state" and
// returns whether the selection state was changed

BOOL
StateInfo(
    LPCTSTR             SubcomponentId,
    BOOL               *state
    )
{
    BOOL rc = TRUE;

    assert(state);

	// otherwise, check for a change in installation state
		
    *state = g_Component.HelperRoutines.QuerySelectionState(
        g_Component.HelperRoutines.OcManagerContext,
        SubcomponentId,
        OCSELSTATETYPE_CURRENT);

    if (*state == g_Component.HelperRoutines.QuerySelectionState(
        g_Component.HelperRoutines.OcManagerContext,
        SubcomponentId,
        OCSELSTATETYPE_ORIGINAL))
    {
        // no change
        rc = FALSE;
    }

    if ( *state )
        {

        BITS_SUBCOMPONENT_DATA* SubcomponentData = FindSubcomponent( SubcomponentId );

        if ( SubcomponentData && g_UpdateNeeded )
            rc = TRUE;

        }

    return rc;
}

/*
 * EnumSections()
 *
 * finds the name of a section for a specified keyword
 */

DWORD
EnumSections(
    HINF hinf,
    const TCHAR *component,
    const TCHAR *key,
    DWORD index,
    INFCONTEXT *pic,
    TCHAR *name
    )
{
    TCHAR section[S_SIZE];

    if (!SetupFindFirstLine(hinf, component, NULL, pic))
        return 0;

    if (!SetupFindNextMatchLine(pic, key, pic))
        return 0;

    if (index > SetupGetFieldCount(pic))
        return 0;

    if (!SetupGetStringField(pic, index, section, SBUF_SIZE, NULL))
        return 0;

    if (name)
        StringCchCopy(name, S_SIZE, section);

    return SetupFindFirstLine(hinf, section, NULL, pic);
}


DWORD
OcLog(
      LPCTSTR ComponentId,
      UINT level,
      LPCTSTR sz
      )
{
    TCHAR fmt[5000];
    PPER_COMPONENT_DATA cd;

    if (!VerifyComponent( ComponentId ) )
        return NO_ERROR;

    assert(g_Component.ExtraRoutines.LogError);
    assert(level);
    assert(sz);

    StringCchCopy(fmt, 5000, TEXT("%s: %s"));

    return g_Component.ExtraRoutines.LogError(
        g_Component.HelperRoutines.OcManagerContext,
        level,
        fmt,
        ComponentId,
        sz);
}

DWORD
CleanupNetShares(
    PPER_COMPONENT_DATA cd,
    LPCTSTR component,
    DWORD state)
{
    INFCONTEXT  ic;
    TCHAR       sname[S_SIZE];
    DWORD       section;
    TCHAR      *keyword;

    if (state) {
        return NO_ERROR;
    } else {
        keyword = KEYWORD_DELSHARE;
    }

    for (section = 1;
         EnumSections(cd->hinf, component, keyword, section, &ic, sname);
         section++)
    {
        INFCONTEXT  sic;
        NET_API_STATUS netStat;

        CHAR Temp[SBUF_SIZE];
        TCHAR ShareName[ SBUF_SIZE ];

        if (!SetupFindFirstLine(cd->hinf, sname, KEYWORD_SHARENAME, &sic))
        {
            log( TEXT("OCGEN: %s INF error - unable to find %s\r\n"), keyword, KEYWORD_SHARENAME );
            continue;
        }

        if (!SetupGetStringField(&sic, 1, ShareName, SBUF_SIZE, NULL))
        {
            log( TEXT("OCGEN: %s INF error - incorrect %s line\r\n"), keyword, KEYWORD_SHARENAME );
            continue;
        }

#ifdef UNICODE
        netStat = NetShareDel( NULL, ShareName, 0 );
#else // UNICODE
        WCHAR ShareNameW[ SBUF_SIZE ];
        mbstowcs( ShareNameW, ShareName, lstrlen(ShareName));
        netStat = NetShareDel( NULL, ShareNameW, 0 );
#endif // UNICODE
        if ( netStat != NERR_Success )
        {
            log( TEXT("OCGEN: Failed to remove %s share. Error 0x%08x\r\n"), ShareName, netStat );
            continue;
        }

        log( TEXT("OCGEN: %s share removed successfully.\r\n"), ShareName );
    }

    return TRUE;
}

DWORD
RunExternalProgram(
    PPER_COMPONENT_DATA cd,
    LPCTSTR component,
    DWORD state)
{
    INFCONTEXT  ic;
    TCHAR       sname[S_SIZE];
    DWORD       section;
    TCHAR      *keyword;

    keyword = KEYWORD_RUN;

    for (section = 1;
         EnumSections(cd->hinf, component, keyword, section, &ic, sname);
         section++)
    {
        INFCONTEXT  sic;
        TCHAR CommandLine[ SBUF_SIZE ];
        CHAR szTickCount[ SBUF_SIZE ];
        ULONG TickCount;
        BOOL b;
        STARTUPINFO startupinfo;
        PROCESS_INFORMATION process_information;
        DWORD dwErr;

        if (!SetupFindFirstLine(cd->hinf, sname, KEYWORD_COMMANDLINE , &sic))
        {
            log( TEXT("OCGEN: %s INF error - unable to find %s\r\n"), keyword, KEYWORD_COMMANDLINE );
            continue;
        }

        if (!SetupGetStringField(&sic, 1, CommandLine, SBUF_SIZE, NULL))
        {
            log( TEXT("OCGEN: %s INF error - incorrect %s line\r\n"), keyword, KEYWORD_COMMANDLINE );
            continue;
        }

        if (!SetupFindFirstLine(cd->hinf, sname, KEYWORD_TICKCOUNT, &sic))
        {
            log( TEXT("OCGEN: %s INF error - unable to find %s\r\n"), keyword, KEYWORD_TICKCOUNT );
            continue;
        }

        if (!SetupGetStringFieldA(&sic, 1, szTickCount, SBUF_SIZE, NULL))
        {
            log( TEXT("OCGEN: %s INF error - incorrect %s line\r\n"), keyword, KEYWORD_TICKCOUNT );
            continue;
        }

        TickCount = atoi( szTickCount );

        ZeroMemory( &startupinfo, sizeof(startupinfo) );
        startupinfo.cb = sizeof(startupinfo);
        startupinfo.dwFlags = STARTF_USESHOWWINDOW;
        startupinfo.wShowWindow = SW_HIDE | SW_SHOWMINNOACTIVE;

        b = CreateProcess( NULL,
                           CommandLine,
                           NULL,
                           NULL,
                           FALSE,
                           CREATE_DEFAULT_ERROR_MODE,
                           NULL,
                           NULL,
                           &startupinfo,
                           &process_information );
        if ( !b )
        {
            log( TEXT("OCGEN: failed to spawn %s process.\r\n"), CommandLine );
            continue;
        }

        dwErr = WaitForSingleObject( process_information.hProcess, TickCount * 1000 );
        if ( dwErr != NO_ERROR )
        {
            log( TEXT("OCGEN: WaitForSingleObject() failed. Error 0x%08x\r\n"), dwErr );
            TerminateProcess( process_information.hProcess, -1 );
            CloseHandle( process_information.hProcess );
            CloseHandle( process_information.hThread );
            continue;
        }

        CloseHandle( process_information.hProcess );
        CloseHandle( process_information.hThread );

        log( TEXT("OCGEN: %s successfully completed within %u seconds.\r\n"), CommandLine, TickCount );
    }

    return TRUE;
}

BITS_SUBCOMPONENT_DATA* 
FindSubcomponent( LPCTSTR SubcomponentId )
{

    for( unsigned int i = 0; i < g_NumberSubcomponents; i++ )
        {

        if ( _tcsicmp( SubcomponentId, g_Subcomponents[i].SubcomponentName ) == 0 )
            return &g_Subcomponents[i];

        }
    return NULL;

}


DWORD 
InitializeSubcomponentStates()
{
    
    // Load this module's version information
    DWORD dwResult;
    ULONG64 ThisModuleVersion;
    BOOL AllSubcomponentsPreinstalled = TRUE;
    BOOL UpdateNeeded                 = TRUE;

    dwResult = GetModuleVersion64( ghinst, &ThisModuleVersion );
    if ( ERROR_SUCCESS != dwResult )
        return dwResult;

    TCHAR SystemDirectory[ MAX_PATH * 2 ];
    GetSystemWindowsDirectory( SystemDirectory, MAX_PATH + 1 );
    StringCchCat( SystemDirectory, MAX_PATH * 2, TEXT("\\System32\\") );

    for( unsigned int i = 0; i < g_NumberSubcomponents; i++ )
        {

        TCHAR FileName[ MAX_PATH * 2 ];
        StringCchCopy( FileName, MAX_PATH * 2, SystemDirectory );
        StringCchCatW( FileName, MAX_PATH * 2, g_Subcomponents[ i ].SubcomponentKeyFileName );

        dwResult = GetFileVersion64( FileName, &g_Subcomponents[ i ].FileVersion );

        // If the file isn't found, skip it
        if ( ERROR_FILE_NOT_FOUND == dwResult ||
             ERROR_PATH_NOT_FOUND == dwResult )
            {
            AllSubcomponentsPreinstalled = FALSE;
            continue;
            }

        if ( dwResult != ERROR_SUCCESS )
            return dwResult;

        g_Subcomponents[ i ].Preinstalled = TRUE;
        g_Subcomponents[ i ].ShouldUpgrade = g_Subcomponents[ i ].FileVersion < ThisModuleVersion;

        if ( g_Subcomponents[i].ShouldUpgrade )
            UpdateNeeded = TRUE;

        }

    g_AllSubcomponentsPreinstalled = AllSubcomponentsPreinstalled;
    g_UpdateNeeded                 = TRUE;
    return ERROR_SUCCESS;

}

DWORD
GetFileVersion64(
    LPCTSTR      szFullPath,
    ULONG64 *   pVer
    )
{
    DWORD dwHandle;
    DWORD dwLen;

    *pVer = 0;

    //
    // Check to see if the file exists
    //

    DWORD dwAttributes = GetFileAttributes( szFullPath );

    if ( INVALID_FILE_ATTRIBUTES == dwAttributes )
        return GetLastError();

    //
    // Get the file version info size
    //

    if ((dwLen = GetFileVersionInfoSize( (LPTSTR)szFullPath, &dwHandle)) == 0)
        return GetLastError();

    //
    // Allocate enough size to hold version info
    //
    char * VersionInfo = new char[ dwLen ];

    if ( !VersionInfo )
        return ERROR_NOT_ENOUGH_MEMORY;

    //
    // Get the version info
    //
    if (!GetFileVersionInfo( (LPTSTR)szFullPath, dwHandle, dwLen, VersionInfo ))
        {
        DWORD Error = GetLastError();
        delete[] VersionInfo;
        return Error;
        }

    {

         VS_FIXEDFILEINFO *pvsfi;
         UINT              dwLen2;

         if ( VerQueryValue(
                  VersionInfo,
                  TEXT("\\"),
                  (LPVOID *)&pvsfi,
                  &dwLen2
                  ) )
             {
             *pVer = ( ULONG64(pvsfi->dwFileVersionMS) << 32) | (pvsfi->dwFileVersionLS);
             }

    }

    delete[] VersionInfo;
    return ERROR_SUCCESS;

}

//
// This ungainly typedef seems to have no global definition.  There are several identical
// definitions in the Windows NT sources, each of which has that bizarre bit-stripping
// on szKey.  I got mine from \nt\base\ntsetup\srvpack\update\splib\common.h.
//
typedef struct tagVERHEAD {
    WORD wTotLen;
    WORD wValLen;
    WORD wType;         /* always 0 */
    WCHAR szKey[(sizeof("VS_VERSION_INFO")+3)&~03];
    VS_FIXEDFILEINFO vsf;
} VERHEAD ;

DWORD
GetModuleVersion64(
    HMODULE hDll,
    ULONG64 * pVer
    )
{
    DWORD* pdwTranslation;
    VS_FIXEDFILEINFO* pFileInfo;
    UINT uiSize;

    *pVer = 0;

    HRSRC hrsrcVersion = FindResource(
                                hDll,
                                MAKEINTRESOURCE(VS_VERSION_INFO),
                                RT_VERSION);

    if (!hrsrcVersion) 
        return GetLastError();

    HGLOBAL hglobalVersion = LoadResource(hDll, hrsrcVersion);
    if (!hglobalVersion) 
        return GetLastError();

    VERHEAD * pVerHead = (VERHEAD *) LockResource(hglobalVersion);
    if (!pVerHead) 
        return GetLastError();

    // I stole this code from \nt\com\complus\src\shared\util\svcerr.cpp,
    // and the comment is theirs:
    //
    // VerQueryValue will write to the memory, for some reason.
    // Therefore we must make a writable copy of the version
    // resource info before calling that API.
    void *pvVersionInfo = new char[ pVerHead->wTotLen + pVerHead->wTotLen/2 ];

    if ( !pvVersionInfo )
        return ERROR_NOT_ENOUGH_MEMORY;

    memcpy(pvVersionInfo, pVerHead, pVerHead->wTotLen);

    // Retrieve file version info
    if ( VerQueryValue( pvVersionInfo,
                        L"\\",
                        (void**)&pFileInfo,
                        &uiSize) )
        {
        *pVer = (ULONG64(pFileInfo->dwFileVersionMS) << 32) | (pFileInfo->dwFileVersionLS);
        }

    delete[] pvVersionInfo;

    return ERROR_SUCCESS;
}

HRESULT
BITSGetStartupInfo( 
    LPSTARTUPINFOA lpStartupInfo )
{

    __try
    {
        GetStartupInfoA( lpStartupInfo );
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        return E_OUTOFMEMORY;
    }
    
    return S_OK;

}

HRESULT StopIIS()
{

    //
    // Restarts IIS by calling "iisreset /stop" at the commandline.
    //

    STARTUPINFOA StartupInfo;

    HRESULT Hr = BITSGetStartupInfo( &StartupInfo );

    if ( FAILED( Hr ) )
        return Hr;

    #define IISSTOP_EXE        "iisreset.exe"
    #define IISSTOP_CMDLINE    "iisreset /stop"

    PROCESS_INFORMATION ProcessInfo;
    CHAR    sApplicationPath[MAX_PATH];
    CHAR   *pApplicationName = NULL;
    CHAR    sCmdLine[MAX_PATH];
    DWORD   dwLen = MAX_PATH;
    DWORD   dwCount;

    dwCount = SearchPathA(NULL,               // Search Path, NULL is PATH
                         IISSTOP_EXE,         // Application
                         NULL,                // Extension (already specified)
                         dwLen,               // Length (char's) of sApplicationPath
                         sApplicationPath,    // Path + Name for application
                         &pApplicationName ); // File part of sApplicationPath

    if (dwCount == 0)
        {
        return HRESULT_FROM_WIN32( GetLastError() );
        }

    if (dwCount > dwLen)
        {
        return HRESULT_FROM_WIN32( ERROR_BUFFER_OVERFLOW );
        }

    StringCbCopyA(sCmdLine, MAX_PATH, IISSTOP_CMDLINE);

    BOOL RetVal = CreateProcessA(
            sApplicationPath,                          // name of executable module
            sCmdLine,                                  // command line string
            NULL,                                      // SD
            NULL,                                      // SD
            FALSE,                                     // handle inheritance option
            CREATE_NO_WINDOW,                          // creation flags
            NULL,                                      // new environment block
            NULL,                                      // current directory name
            &StartupInfo,                              // startup information
            &ProcessInfo                               // process information
        );

    if ( !RetVal )
        return HRESULT_FROM_WIN32( GetLastError() );

    WaitForSingleObject( ProcessInfo.hProcess, INFINITE );

    DWORD Status;
    GetExitCodeProcess( ProcessInfo.hProcess, &Status );

    CloseHandle( ProcessInfo.hProcess );
    CloseHandle( ProcessInfo.hThread );

    return HRESULT_FROM_WIN32( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\server\bitsenable\bitsenable.cpp ===
/************************************************************************

Copyright (c) 2000-2000 Microsoft Corporation

Module Name :

    bitsenable.cpp

Abstract :


Revision History :

Notes:

  ***********************************************************************/

#define INITGUID
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <iadmw.h>
#include <iiscnfg.h>
#include <bitssrvcfg.h>
#include <bitscfg.h>
#include <activeds.h>
#include <malloc.h>

// {A55E7D7F-D51C-4859-8D2D-E308625D908E}
DEFINE_GUID(CLSID_CBITSExtensionSetup, 
            0xa55e7d7f, 0xd51c, 0x4859, 0x8d, 0x2d, 0xe3, 0x8, 0x62, 0x5d, 0x90, 0x8e);

void PrintHelp()
{
    wprintf( 
        L"USAGE: bitsenable command\n"
        L"The following commands are available:\n" 
        L"\n"
        L"/?\n"
        L"/HELP\n"
        L"/ENABLE virtual-directory\n"
        L"/DISABLE virtual-directory\n"
        L"\n" );

    exit(0);
}

void CheckError( HRESULT Hr )
{
    if (FAILED(Hr))
        {
        wprintf(L"Error 0x%8.8X\n", Hr );
        exit(Hr);
        }
}

int _cdecl wmain( int argc, WCHAR**argv )
{

    bool Enable;

    if ( argc < 2 )
        PrintHelp();

    if ( _wcsicmp( argv[1], L"/?" ) == 0 )
        PrintHelp();

    else if ( _wcsicmp( argv[1], L"/HELP" ) == 0 )
        PrintHelp();

    else if ( _wcsicmp( argv[1], L"/ENABLE" ) == 0 )
        Enable = true;

    else if ( _wcsicmp( argv[1], L"/DISABLE" ) == 0 )
        Enable = false;

    else
        {
        wprintf( L"Unknown command.\n");
        PrintHelp();
        }

    if ( argc != 3 )
        {
        wprintf( L"Invalid number of arguments.\n");
        exit(1);
        }

    CheckError( CoInitializeEx( NULL, COINIT_MULTITHREADED ) );

    IBITSExtensionSetup *ExtensionSetup = NULL;

#if 0 
    
    BSTR TaskName = NULL;
    ITask *Task = NULL;
    LPWSTR Parameters = NULL;

    CheckError( ADsGetObject( BSTR( argv[2] ), __uuidof( *ExtensionSetup ), (void**)&ExtensionSetup ) );
   
    CheckError( ExtensionSetup->GetCleanupTaskName( &TaskName ) );
    wprintf( L"Cleanup Item name %s\n", (LPCWSTR)TaskName );

    CheckError( ExtensionSetup->GetCleanupTask( __uuidof( ITask ), (IUnknown**)&Task ) );
    wprintf( L"ITask pointer, %p\n", Task );

    if ( Task )
        {

        CheckError( Task->GetParameters( &Parameters ) );
        wprintf( L"Task parameters %s\n", Parameters );
        }

    exit(0);

#else 

    IBITSExtensionSetupFactory *ExtensionSetupFactory = NULL;

    REFIID CLSID = __uuidof( BITSExtensionSetupFactory ); // CLSID_CBITSExtensionSetup; //;

    CheckError( 
        CoCreateInstance(
            CLSID,     
            NULL,  
            CLSCTX_INPROC_SERVER,   
            __uuidof(IBITSExtensionSetupFactory),  
            (void**)&ExtensionSetupFactory ) );

    CheckError( ExtensionSetupFactory->GetObject( BSTR( argv[2] ), &ExtensionSetup ) );
   

    if ( Enable )
        {
        CheckError( ExtensionSetup->EnableBITSUploads() );
        wprintf( L"BITS upload enabled for virtual directory %s\n", argv[2] );
        }

    else
        {
        CheckError( ExtensionSetup->DisableBITSUploads() );
        wprintf( L"BITS upload disabled for virtual directory %s\n", argv[2] );
        }

    ExtensionSetup->Release();
    ExtensionSetupFactory->Release();
    exit(0);

#endif


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\server\bitsoc\resource.h ===
/*
 *  Copyright (c) 1996  Microsoft Corporation
 *
 *  Module Name:
 *
 *      resource.h
 *
 *  Abstract:
 *
 *      This file contains all resources defines for ocgen.dll
 *
 *  Author:
 *
 *      Pat Styles (patst) 21-Nov-1996
 *
 *  Environment:
 *
 *    User Mode
 */

#ifdef _RESOURCE_H_
 #error "resource.h already included!"
#else
 #define _RESOURCE_H_
#endif

#define IDS_DIALOG_CAPTION  1

// !!! WARNING !!! Don't change the resource ID, unless you
// also change the corresponding ID in the affected INF files.
// 
#define IDB_ROOT_AUTO_UPDATE                  1001      // DSIE: Bitmap ID for RootAU.INF
#define IDB_ROOT_IE                           1002
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\proxy\qmgrproxy.cxx ===
#include "qmgrlib.h"
#include <objbase.h>
#include "qmgr.h"

UpdateNotificationPointer(
    IBackgroundCopyGroup * This,
    REFCLSID clsid
    )
{
    IBackgroundCopyCallback1 * callback = NULL;

    try
        {
        THROW_HRESULT( CoCreateInstance( clsid,
                                         NULL,        // no aggregation
                                         CLSCTX_INPROC,
                                         _uuidof(IBackgroundCopyCallback1),
                                         (LPVOID *) &callback
                                         ));

        THROW_HRESULT( This->SetNotificationPointer( _uuidof(IBackgroundCopyCallback1), callback ));

        callback->Release();

        return S_OK;
        }
    catch( ComError err )
        {
        SafeRelease( callback );

        return err.Error() ;
        }
}


HRESULT
IBackgroundCopyGroup_SetProp_Proxy(
    IBackgroundCopyGroup * This,
    GROUPPROP propID,
    VARIANT *pvarVal
    )
/*
    This is the client-side proxy function that maps from SetProp (a local function)
    to InternalSetProp (a remoted function).

*/
{
    switch (propID)
        {
        case GROUPPROP_NOTIFYCLSID:
            {
            INT     flags;
            CLSID   clsid;
            VARIANT vFlags;

            RETURN_HRESULT( IBackgroundCopyGroup_InternalSetProp_Proxy( This, propID, pvarVal ));
            RETURN_HRESULT( This->GetProp( GROUPPROP_NOTIFYFLAGS, &vFlags ));
            RETURN_HRESULT( CLSIDFromString( pvarVal->bstrVal, &clsid ));

            flags = vFlags.intVal;

            if (clsid != GUID_NULL &&
                0 == (flags & QM_NOTIFY_DISABLE_NOTIFY))
                {
                RETURN_HRESULT( UpdateNotificationPointer( This, clsid ));
                }

            return S_OK;
            }

        case GROUPPROP_NOTIFYFLAGS:
            {
            INT     flags;
            CLSID   clsid;
            VARIANT vClsid;

            RETURN_HRESULT( IBackgroundCopyGroup_InternalSetProp_Proxy( This, propID, pvarVal ));
            RETURN_HRESULT( This->GetProp( GROUPPROP_NOTIFYCLSID, &vClsid ));
            RETURN_HRESULT( CLSIDFromString( vClsid.bstrVal, &clsid ));

            flags = pvarVal->intVal;

            if (clsid != GUID_NULL &&
                0 == (flags & QM_NOTIFY_DISABLE_NOTIFY))
                {
                RETURN_HRESULT( UpdateNotificationPointer( This, clsid ));
                }

            return S_OK;
            }

        default:

            return IBackgroundCopyGroup_InternalSetProp_Proxy( This, propID, pvarVal );
        }

    ASSERT( 0 );
}

HRESULT
IBackgroundCopyGroup_SetProp_Stub(
    IBackgroundCopyGroup * This,
    GROUPPROP propID,
    VARIANT *pvarVal
    )
/*
    This is the server-side stub function that maps from InternalSetProp (a remote function)
    to SetProp (a local function).

*/
{
    return This->SetProp( propID, pvarVal );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\server\bitsoc\util.cpp ===
/*
 *  Copyright (c) 1996  Microsoft Corporation
 *
 *  Module Name:
 *
 *      util.cpp
 *
 *  Abstract:
 *
 *      This file communicates with  exchange
 *
 *  Author:
 *
 *      Pat Styles (patst) 25-March-1997
 *
 *  Environment:
 *
 *    User Mode
 */

#define _UTIL_CPP_
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <assert.h>
#include <tchar.h>
#include <time.h>
#include "ocgen.h"
#pragma hdrstop

TCHAR glabel[] = TEXT("\n[OCGEN] ");

// for logging

#define gsLogFile           TEXT("%windir%\\ocgen.log")
#define gsLogCompletionMsg  TEXT(" - complete\r\n")
#define gsLogInitMsg        TEXT("\r\n\r\nInitialize setup: OCGEN.DLL %s %s\r\n")

// for trace statements

#define gsTrace             TEXT("OCGEN.DLL: Trace")

typedef enum {

    nPreInit,               // OC_PREINITIALIZE
    nInit,                  // OC_INIT_COMPONENT
    nSetLang,               // OC_SET_LANGUAGE
    nQueryImage,            // OC_QUERY_IMAGE
    nRequestPages,          // OC_REQUEST_PAGES
    nQueryChangeSel,        // OC_QUERY_CHANGE_SEL_STATE
    nCalcSpace,             // OC_CALC_DISK_SPACE
    nQueueFile,             // OC_QUEUE_FILE_OPS
    nQueueNot,              // OC_NOTIFICATION_FROM_QUEUE
    nQueryStep,             // OC_QUERY_STEP_COUNT
    nComplete,              // OC_COMPLETE_INSTALLATION
    nCleanup,               // OC_CLEANUP
    nQueryState,            // OC_QUERY_STATE
    nNeedMedia,             // OC_NEED_MEDIA
    nAboutToCommit,         // OC_ABOUT_TO_COMMIT_QUEUE
    nQuerySkip,             // OC_QUERY_SKIP_PAGE  
    nWizardCreated,         // OC_WIZARD_CREATED
    nExtraRoutines,         // OC_EXTRA_ROUTINES
    nMaximum
} notifications;

typedef struct _OcMsgs {
    DWORD  msg;
    TCHAR *desc;
} OcMsgs;

OcMsgs gMsgs[nMaximum] = {
    {OC_PREINITIALIZE,          TEXT("OC_PREINITIALIZE")},
    {OC_INIT_COMPONENT,         TEXT("OC_INIT_COMPONENT")},
    {OC_SET_LANGUAGE,           TEXT("OC_SET_LANGUAGE")},
    {OC_QUERY_IMAGE,            TEXT("OC_QUERY_IMAGE")},
    {OC_REQUEST_PAGES,          TEXT("OC_REQUEST_PAGES")},
    {OC_QUERY_CHANGE_SEL_STATE, TEXT("OC_QUERY_CHANGE_SEL_STATE")},
    {OC_CALC_DISK_SPACE,        TEXT("OC_CALC_DISK_SPACE")},
    {OC_QUEUE_FILE_OPS,         TEXT("OC_QUEUE_FILE_OPS")},
    {OC_NOTIFICATION_FROM_QUEUE,TEXT("OC_NOTIFICATION_FROM_QUEUE")},
    {OC_QUERY_STEP_COUNT,       TEXT("OC_QUERY_STEP_COUNT")},
    {OC_COMPLETE_INSTALLATION,  TEXT("OC_COMPLETE_INSTALLATION")},
    {OC_CLEANUP,                TEXT("OC_CLEANUP")},
    {OC_QUERY_STATE,            TEXT("OC_QUERY_STATE")},
    {OC_NEED_MEDIA,             TEXT("OC_NEED_MEDIA")},
    {OC_ABOUT_TO_COMMIT_QUEUE,  TEXT("OC_ABOUT_TO_COMMIT_QUEUE")},
    {OC_QUERY_SKIP_PAGE,        TEXT("OC_QUERY_SKIP_PAGE")},
    {OC_WIZARD_CREATED,         TEXT("OC_WIZARD_CREATED")},
    {OC_EXTRA_ROUTINES,         TEXT("OC_EXTRA_ROUTINES")}
};

TCHAR gUnknown[] = TEXT("Unknown Notification: ");

// determines whether or not to display debug info

DWORD gDebugLevel = (DWORD)-1;

// forward reference

TCHAR *NotificationText(DWORD msg);
BOOL  CheckLevel(DWORD level);

/*
 * DebugTrace()
 */

void DebugTrace(DWORD level, const TCHAR *text)
{
    if (!CheckLevel(level))
        return;

    OutputDebugString(text);
}

/*
 * DebugTraceNL()
 *
 * precedes a trace statement with a newline and id prefix
 */

void DebugTraceNL(DWORD level, const TCHAR *text)
{
    DebugTrace(level, glabel);
    DebugTrace(level, text);
}

/*
 * NotificationText()
 */

TCHAR *NotificationText(DWORD msg)
{
    int i;
    static TCHAR desc[S_SIZE];

    for (i = 0; i < nMaximum; i++)
    {
        if (gMsgs[i].msg == msg)
            return gMsgs[i].desc;
    }

    StringCchPrintf(desc, S_SIZE, TEXT("OC_%d: "), msg);
    return desc;
}

/*
 * DebugTraceOCNotification()
 */

void DebugTraceOCNotification(DWORD msg, const TCHAR *component)
{
    DebugTraceNL(1, NotificationText(msg));
    DebugTrace(1, TEXT(": "));
    DebugTrace(1, component);
    DebugTrace(1, TEXT(" - "));
}

/*
 * DebugTraceFileCopy()
 */

void DebugTraceFileCopy(const TCHAR *file)
{
    DebugTraceNL(5, TEXT("TreeCopy: FILE="));
    DebugTrace(5, file);
}

/*
 * DebugTraceFileCopyError()
 */

void DebugTraceFileCopyError()
{
    TCHAR buf[S_SIZE];
    
    StringCchPrintf(buf, S_SIZE, FMT(" FAILURE CODE:[%d] "), GetLastError());
    DebugTrace(5, buf);
}

/*
 * DebugTraceDirCopy()
 */

void DebugTraceDirCopy(const TCHAR *dir)
{
    DebugTraceNL(3, TEXT("TreeCopy: DIR="));
    DebugTrace(3, dir);
}


/*
 * CheckLevel()
 */

BOOL CheckLevel(DWORD level)
{
    if (gDebugLevel == (DWORD)-1)
        gDebugLevel = SysGetDebugLevel();

    return (gDebugLevel >= level);
}

/*
 * MsgBox
 *
 */

DWORD MsgBox(HWND hwnd, UINT textID, UINT type, ... )
{
    static BOOL initialize = true;
    static TCHAR caption[S_SIZE];
    TCHAR  text[S_SIZE];
    TCHAR  format[S_SIZE];
    int    len;

    va_list vaList;

    assert(hwnd && textID && type);

    if (initialize)
    {
        len = LoadString(ghinst, IDS_DIALOG_CAPTION, caption, S_SIZE);
        assert(len);
        if (!len) {
            StringCchCopy( caption, S_SIZE, TEXT("Setup"));
        }
        initialize = false;
    }

    len = LoadString(ghinst, textID, format, S_SIZE);
    assert(len);
    if (!len) {
        StringCchCopy( format, S_SIZE, TEXT("Unknown Error"));
    }

    va_start(vaList, type);
    StringCchVPrintf(text, S_SIZE, format, vaList);
    va_end(vaList);

    return MessageBox(hwnd, text, caption, type);
}

DWORD MsgBox(HWND hwnd, TCHAR *fmt, TCHAR *caption, UINT type, ... )
{
    TCHAR  text[S_SIZE];

    va_list vaList;

    assert(hwnd && text && caption && type);

    va_start(vaList, type);
    StringCchVPrintf(text, S_SIZE, fmt, vaList);
    va_end(vaList);

    return MessageBox(hwnd, text, caption, type);
}

DWORD MBox(LPCTSTR fmt, LPCTSTR caption, ... )
{
    TCHAR  text[S_SIZE];

    va_list vaList;

    assert(fmt && caption);

    va_start(vaList, caption);
    StringCchVPrintf(text, S_SIZE, fmt, vaList);
    va_end(vaList);

    return MessageBox(ghwnd, text, caption, MB_ICONINFORMATION | MB_OK);
}

DWORD TMBox(LPCTSTR fmt, ... )
{
    TCHAR  text[S_SIZE];

    va_list vaList;

    assert(fmt);

    va_start(vaList, fmt);
    StringCchVPrintf(text, S_SIZE, fmt, vaList);
    va_end(vaList);

    return MessageBox(ghwnd, text, gsTrace, MB_ICONINFORMATION | MB_OK);
}

/*
 * SysGetDebugLevel()
 */

DWORD SysGetDebugLevel()
{
    DWORD rc;
    DWORD err;
    DWORD size;
    DWORD type;
    HKEY  hkey;

    err = RegOpenKey(HKEY_LOCAL_MACHINE, 
                     TEXT("SOFTWARE\\microsoft\\windows\\currentversion\\setup"), 
                     &hkey);

    if (err != ERROR_SUCCESS)
        return 0;

    size = sizeof(DWORD);
    err = RegQueryValueEx(hkey,
                          TEXT("OCGen Debug Level"),
                          0,
                          &type,
                          (LPBYTE)&rc,
                          &size);

    if (err != ERROR_SUCCESS || type != REG_DWORD)
        rc = 0;

    RegCloseKey(hkey);

    return rc;
}

/*
 * TCharStringToAnsiString
 */

DWORD TCharStringToAnsiString(TCHAR *tsz ,char *asz)
{
    DWORD count;

    assert(tsz && asz);

#ifdef UNICODE
    count = WideCharToMultiByte(CP_ACP,
                                0,
                                tsz,
                                -1,
                                NULL,
                                0,
                                NULL,
                                NULL);

    if (!count || count > S_SIZE)
        return count;

    return WideCharToMultiByte(CP_ACP,
                               0,
                               tsz,
                               -1,
                               asz,
                               count,
                               NULL,
                               NULL);
#else
    _tcscpy(asz, tsz);
    return _tcslen(asz);
#endif
}

void logOCNotification(DWORD msg, const TCHAR *component)
{
    log(FMT("[%s - %s]"), component, NotificationText(msg));
}

void logOCNotificationCompletion()
{
    log(gsLogCompletionMsg);
}

void loginit()
{
    HANDLE hfile;
    TCHAR  logfile[MAX_PATH];
    char   fmt[S_SIZE];
    char   output[S_SIZE];
    char   time[S_SIZE];
    char   date[S_SIZE];
    DWORD  bytes;

//#ifdef DEBUG
    TCharStringToAnsiString(gsLogInitMsg, fmt);
    _strdate(date);
    _strtime(time);
    StringCchPrintfA(output, S_SIZE, fmt, date, time);

    // open the log file

    ExpandEnvironmentStrings(gsLogFile, logfile, MAX_PATH);

    hfile = CreateFile(logfile,
                       GENERIC_WRITE,
                       0,
                       NULL,
                       OPEN_EXISTING,
                       0,
                       NULL);

    if (hfile == INVALID_HANDLE_VALUE)
        hfile = CreateFile(logfile,
                           GENERIC_WRITE,
                           0,
                           NULL,
                           CREATE_ALWAYS,
                           0,
                           NULL);

    if (hfile != INVALID_HANDLE_VALUE)
    {
        SetFilePointer(hfile, 0, NULL, FILE_END);
        WriteFile(hfile, output, strlen(output) * sizeof(char), &bytes, NULL);
        CloseHandle(hfile);
    }
//#endif
}

void log(TCHAR *fmt, ...)
{
    TCHAR  logfile[MAX_PATH];
    TCHAR  text[S_SIZE];
    char   output[S_SIZE];
    DWORD  bytes;
    HANDLE hfile;

    va_list vaList;

//#ifdef DEBUG
    assert(fmt);

    // create the output string

    va_start(vaList, fmt);
    StringCchVPrintf(text, S_SIZE, fmt, vaList);
    va_end(vaList);

    TCharStringToAnsiString(text, output);

    // create the log file name in the root directory

    ExpandEnvironmentStrings(gsLogFile, logfile, MAX_PATH);

    // open the log file

    hfile = CreateFile(logfile,
                       GENERIC_WRITE,
                       0,
                       NULL,
                       OPEN_EXISTING,
                       0,
                       NULL);

    if (hfile != INVALID_HANDLE_VALUE)
    {
        SetFilePointer(hfile, 0, NULL, FILE_END);
        WriteFile(hfile, output, strlen(output) * sizeof(char), &bytes, NULL);
        CloseHandle(hfile);
    }
//#endif
}

BOOL IsNT()
{
    DWORD dwver;

    dwver = GetVersion();

    if (dwver < 0x8000000)
        return TRUE;

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\server\inc\bitssrvcfg.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    bitssrvcfg.h

Abstract:

    Header to define server configuration information.

--*/

#define BITS_COMMAND_VERBW L"BITS_POST"
#define BITS_COMMAND_VERBA "BITS_POST"

const DWORD MD_BITS_UPLOAD_ENABLED              = 0; 
const DWORD MD_BITS_CONNECTION_DIR              = 1;
const DWORD MD_BITS_MAX_FILESIZE                = 2;
const DWORD MD_BITS_NO_PROGRESS_TIMEOUT         = 3;
const DWORD MD_BITS_NOTIFICATION_URL_TYPE       = 4;
const DWORD MD_BITS_NOTIFICATION_URL            = 5;
const DWORD MD_BITS_CLEANUP_WORKITEM_KEY        = 6;
const DWORD MD_BITS_HOSTID                      = 7;
const DWORD MD_BITS_HOSTID_FALLBACK_TIMEOUT     = 8;

enum BITS_SERVER_NOTIFICATION_TYPE
{
    BITS_NOTIFICATION_TYPE_NONE         = 0,
    BITS_NOTIFICATION_TYPE_POST_BYREF   = 1,
    BITS_NOTIFICATION_TYPE_POST_BYVAL   = 2,
    BITS_NOTIFICATION_TYPE_MAX          = 2
};
                                                                       
const WCHAR * const MD_BITS_UNLIMITED_MAX_FILESIZE                          = L"18446744073709551615";
const CHAR * const MD_BITS_UNLIMITED_MAX_FILESIZEA                          = "18446744073709551615";
const UINT64 MD_BITS_UNLIMITED_MAX_FILESIZE_AS_INT64                        = 18446744073709551615;
const DWORD MD_BITS_NO_TIMEOUT                                              = 0xFFFFFFFF;

const WCHAR * const MD_DEFAULT_BITS_CONNECTION_DIR                          = L"BITS-Sessions";
const CHAR * const MD_DEFAULT_BITS_CONNECTION_DIRA                          = "BITS-Sessions";
const WCHAR * const MD_DEFAULT_BITS_MAX_FILESIZE                            = MD_BITS_UNLIMITED_MAX_FILESIZE;
const CHAR * const MD_DEFAULT_BITS_MAX_FILESIZEA                            = MD_BITS_UNLIMITED_MAX_FILESIZEA;
const UINT64 MD_DEFAULT_BITS_MAX_FILESIZE_AS_INT64                          = MD_BITS_UNLIMITED_MAX_FILESIZE_AS_INT64;
const DWORD MD_DEFAULT_NO_PROGESS_TIMEOUT                                   = 60 /*seconds*/ * 60 /* minutes */ * 24 /* hours */ * 14 /* days */;
const BITS_SERVER_NOTIFICATION_TYPE MD_DEFAULT_BITS_NOTIFICATION_URL_TYPE   = BITS_NOTIFICATION_TYPE_NONE;
const WCHAR * const MD_DEFAULT_BITS_NOTIFICATION_URL                        = L"";
const CHAR * const MD_DEFAULT_BITS_NOTIFICATION_URLA                        = "";
const WCHAR * const MD_DEFAULT_BITS_HOSTID                                  = L"";
const CHAR * const MD_DEFAULT_BITS_HOSTIDA                                  = "";
const DWORD MD_DEFAULT_HOSTID_FALLBACK_TIMEOUT                              = 60 /*seconds*/ * 60 /* minutes */ * 24 /* hours */; /* 1 day */

struct PROPERTY_ITEM
{
    WCHAR * PropertyName;
    WCHAR * ClassName;
    WCHAR * Syntax;
    DWORD UserType;
    DWORD PropertyNumber;
};

const PROPERTY_ITEM g_Properties[] =
{
    {
    L"BITSUploadEnabled",
    L"IIsWebVirtualDir",
    L"Boolean",
    IIS_MD_UT_FILE,
    0
    },

    {
    L"BITSSessionDirectory",
    L"IIsWebVirtualDir",
    L"String",
    IIS_MD_UT_FILE,
    1
    },

    {
    L"BITSMaximumUploadSize",
    L"IIsWebVirtualDir",
    L"String",
    IIS_MD_UT_FILE,    
    2
    },

    {
    L"BITSSessionTimeout",
    L"IIsWebVirtualDir",
    L"Integer",
    IIS_MD_UT_FILE,
    3
    },

    {
    L"BITSServerNotificationType",
    L"IIsWebVirtualDir",
    L"Integer",
    IIS_MD_UT_FILE,
    4
    },

    {
    L"BITSServerNotificationURL",
    L"IIsWebVirtualDir",
    L"String",
    IIS_MD_UT_FILE,
    5
    },

    {
    L"BITSCleanupWorkItemKey",
    L"IIsWebVirtualDir",
    L"String",
    IIS_MD_UT_FILE,
    6
    },

    {
    L"BITSHostId",
    L"IIsWebVirtualDir",
    L"String",
    IIS_MD_UT_FILE,
    7
    },

    {
    L"BITSHostIdFallbackTimeout",
    L"IIsWebVirtualDir",
    L"Integer",
    IIS_MD_UT_FILE,
    8
    }

};

const SIZE_T g_NumberOfProperties = sizeof(g_Properties)/sizeof(*g_Properties);

class PropertyIDManager
{

    DWORD m_PropertyIDs[ g_NumberOfProperties ];
    DWORD m_PropertyUserTypes[ g_NumberOfProperties ];

public:

    PropertyIDManager()
    {
        memset( &m_PropertyIDs, 0, sizeof( m_PropertyIDs ) );
        memset( &m_PropertyUserTypes, 0, sizeof( m_PropertyUserTypes ) );
    }

    HRESULT LoadPropertyInfo( const WCHAR *MachineName = L"LocalHost" );

    DWORD GetPropertyMetabaseID( DWORD PropID )
    {
        return m_PropertyIDs[PropID];
    }

    DWORD GetPropertyUserType( DWORD PropID )
    {
        return m_PropertyUserTypes[PropID];
    }

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\server\bitsoc\ocgen.h ===
/*
 *  Copyright (c) 1996  Microsoft Corporation
 *
 *  Module Name:
 *
 *      ocgen.h
 *
 *  Abstract:
 *
 *      This file defines oc manager generic component
 *
 *  Author:
 *
 *      Pat Styles (patst) Jan-20-1998
 *
 *  Environment:
 *
 *    User Mode
 */

#ifdef _OCGEN_H_
 #error "ocgen.h already included!"
#else
 #define _OCGEN_H_
#endif

#ifndef _WINDOWS_H_
 #include <windows.h>
#endif

#ifndef _TCHAR_H_
 #include <tchar.h>
#endif

#ifndef _SETUPAPI_H_
 #include <setupapi.h>
#endif

#ifndef _OCMANAGE_H_
 #include "ocmanage.h"
#endif

#ifndef _PRSHT_H_
 #include <prsht.h>
#endif

#include <strsafe.h>

#ifndef _RESOURCE_H_
 #include "resource.h"
#endif

/*-[ types and defines ]-----------------------------------*/

// unicode version is for NT only.

#ifdef UNICODE
 #define NT
#endif
#ifdef ANSI
 #define WIN95
#endif

// just my preference

#define true    TRUE
#define false   FALSE

// to help root out hard coded strings that don't belong

#define FMT     TEXT

#define NullString(a)   *(a) = TCHAR('\0')

// standard buffer sizes

#define S_SIZE           1024
#define SBUF_SIZE        (S_SIZE * sizeof(TCHAR))

#define OCO_COLLECT_NODEPENDENT 0x80000000

// per component data

typedef struct _PER_COMPONENT_DATA {
    struct _PER_COMPONENT_DATA *Next;
    LPCTSTR ComponentId;
    HINF hinf;
    DWORDLONG Flags;
    LANGID LanguageId;
    TCHAR *SourcePath;
    OCMANAGER_ROUTINES HelperRoutines;
    EXTRA_ROUTINES ExtraRoutines;
    HSPFILEQ queue;
    LONG UnattendedOverride;
} PER_COMPONENT_DATA, *PPER_COMPONENT_DATA;

/*-[ functions ]-------------------------------------------*/

// just for utility

#ifdef UNICODE
 #define tsscanf swscanf
 #define tvsprintf vswprintf
#else
 #define tsscanf sscanf
 #define tvsprintf vsprintf
#endif

// from util.cpp

DWORD MsgBox(HWND hwnd, UINT textID, UINT type, ... );
DWORD MsgBox(HWND hwnd, LPCTSTR fmt, LPCTSTR caption, UINT type, ... );
DWORD MBox(LPCTSTR fmt, LPCTSTR caption, ... );
DWORD TMBox(LPCTSTR fmt, ... );
#define mbox MBox
#define tmbox TMBox
void logOCNotification(DWORD msg, const TCHAR *component);
void logOCNotificationCompletion();
void loginit();
void log(TCHAR *fmt, ...);
BOOL IsNT();

#if defined(__cplusplus)
  extern "C" {
#endif

// from ocgen.cpp

BOOL  ToBeInstalled(TCHAR *component);
BOOL  WasInstalled(TCHAR *component);
DWORD SetupCurrentUser();
DWORD GetMyVersion(DWORD *major, DWORD *minor);
VOID  ReplaceExplorerStartMenuBitmap(VOID);
DWORD OcLog(LPCTSTR ComponentId, UINT level, LPCTSTR sz);

DWORD SysGetDebugLevel();

// from util.cpp

void DebugTraceNL(DWORD level, const TCHAR *text);
void DebugTrace(DWORD level, const TCHAR *text);
void DebugTraceOCNotification(DWORD msg, const TCHAR *component);
void DebugTraceFileCopy(const TCHAR *file);
void DebugTraceFileCopyError();
void DebugTraceDirCopy(const TCHAR *dir);

#if defined(__cplusplus)
  }
#endif

/*-[ global data ]-----------------------------------------*/

#ifndef _OCGEN_CPP_
#define EXTERN extern
#else
 #define EXTERN
#endif

// general stuff

EXTERN HINSTANCE  ghinst;  // app instance handle
EXTERN HWND       ghwnd;   // wizard window handle
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\server\inc\bitssrvcfgimp.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    bitssrvcfgimp.h

Abstract:

    Implementation header to define server configuration information.

--*/

HRESULT PropertyIDManager::LoadPropertyInfo( const WCHAR * MachineName )
{
    
    bool ComLoaded;
    HRESULT Hr = CoInitializeEx( NULL, COINIT_MULTITHREADED );

    if ( RPC_E_CHANGED_MODE == Hr )
        ComLoaded = false;
    else if ( FAILED(Hr) )
        return Hr;
    else
        ComLoaded = true;

    BSTR MetaIDBSTR         = NULL;
    BSTR UserTypeBSTR       = NULL;
    WCHAR *PathBuffer       = NULL;
    SIZE_T PathBufferSize   = 0;

    MetaIDBSTR      = SysAllocString( L"MetaId" );
    UserTypeBSTR    = SysAllocString( L"UserType" );

    if ( !MetaIDBSTR || !UserTypeBSTR)
        {
        Hr = E_OUTOFMEMORY;
        goto exit;
        }

    PathBuffer = (WCHAR*)HeapAlloc( GetProcessHeap(), 0, 1024 );

    if ( !PathBuffer )
        {
        Hr = E_OUTOFMEMORY;
        goto exit;
        }

    PathBufferSize          = 1024;

    for ( SIZE_T i = 0; i < g_NumberOfProperties; i++ )
        {

        WCHAR SchemaPrefix[] = L"IIS://";
        WCHAR SchemaPath[]   = L"/Schema/";
        
        SIZE_T SchemaPrefixSize = ( sizeof( SchemaPrefix ) / sizeof( WCHAR ) ) - 1;
        SIZE_T SchemaPathSize   = ( sizeof( SchemaPath ) / sizeof( WCHAR ) ) - 1;
        SIZE_T MachineNameSize  = wcslen( MachineName );
        SIZE_T PropertyNameSize = wcslen( g_Properties[i].PropertyName );

        SIZE_T PathSize = SchemaPrefixSize + SchemaPathSize +
                          MachineNameSize + PropertyNameSize + 1;
        
        if ( PathBufferSize < ( PathSize * sizeof( WCHAR ) ) )
            {
            WCHAR *NewBuffer = 
                (WCHAR*)HeapReAlloc(
                    GetProcessHeap(),
                    0,
                    PathBuffer,
                    PathSize * sizeof( WCHAR ) );

            if ( !NewBuffer )
                {
                Hr = E_OUTOFMEMORY;
                goto exit;
                }

            PathBuffer      = NewBuffer;
            PathBufferSize  = PathSize * sizeof( WCHAR );

            }

        // build schema path

        WCHAR *ObjectPath = PathBuffer;
        {
            WCHAR *TempPointer = ObjectPath;

            memcpy( TempPointer, SchemaPrefix, SchemaPrefixSize * sizeof( WCHAR ) );
            TempPointer += SchemaPrefixSize;
            memcpy( TempPointer, MachineName, MachineNameSize * sizeof( WCHAR ) );
            TempPointer += MachineNameSize;
            memcpy( TempPointer, SchemaPath, SchemaPathSize * sizeof( WCHAR ) );
            TempPointer += SchemaPathSize;
            memcpy( TempPointer, g_Properties[i].PropertyName, ( PropertyNameSize + 1 ) * sizeof( WCHAR ) );
        }

        // Open the object
        IADs *MbObject = NULL;

        Hr = ADsGetObject( 
            ObjectPath,
            __uuidof( *MbObject ),
            reinterpret_cast<void**>( &MbObject ) );

        if ( FAILED( Hr ) )
            goto exit;

        VARIANT var;
        VariantInit( &var );

        Hr = MbObject->Get( MetaIDBSTR, &var );

        if ( FAILED(Hr ) )
            {
            MbObject->Release();
            goto exit;
            }

        Hr = VariantChangeType( &var, &var, 0, VT_UI4 );

        if ( FAILED(Hr ) )
            {
            MbObject->Release();
            VariantClear( &var );
            goto exit;
            }

        m_PropertyIDs[i] = var.ulVal;

        VariantClear( &var );

        Hr = MbObject->Get( UserTypeBSTR, &var );

        if ( FAILED( Hr ) )
            {
            MbObject->Release();
            goto exit;
            }

        Hr = VariantChangeType( &var, &var, 0, VT_UI4 );

        if ( FAILED( Hr ) )
            {
            MbObject->Release();
            VariantClear( &var );
            goto exit;
            }

        m_PropertyUserTypes[i] = var.ulVal;

        VariantClear( &var );

        MbObject->Release();
        

        }
    Hr = S_OK;

exit:

    SysFreeString( MetaIDBSTR );
    SysFreeString( UserTypeBSTR );

    if ( ComLoaded )
        CoUninitialize();
    
    if ( PathBuffer )
        {
        HeapFree( GetProcessHeap(), 0, PathBuffer );
        PathBuffer      = 0;
        PathBufferSize  = 0;
        }

    return Hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\server\isapi\log.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    log.cpp

Abstract:

    This file implements the BITS server extensions logging

--*/

#include "precomp.h"
#include "sddl.h"

const DWORD g_LogLineSize = 160;
typedef char LOG_LINE_TYPE[g_LogLineSize];

CRITICAL_SECTION g_LogCs;
bool g_LogFileEnabled       = false;
bool g_LogDebuggerEnabled   = false;
UINT32 g_LogFlags = DEFAULT_LOG_FLAGS; 
HANDLE g_LogFile = INVALID_HANDLE_VALUE;
HANDLE g_LogFileMapping = NULL;
char g_LogDefaultFileName[ MAX_PATH*2 ];
char g_LogRegistryFileName[ MAX_PATH*2 ];
char *g_LogFileName = NULL;
char g_LogBuffer[512];
UINT64 g_LogSlots       = ( DEFAULT_LOG_SIZE * 1000000 ) / g_LogLineSize;
DWORD g_LogSequence     = 0;
UINT64 g_LogCurrentSlot = 1;
LOG_LINE_TYPE *g_LogFileBase = NULL;

// Allow access to system, administrators, and the creator/owner
const char g_LogSecurityString[] = "D:P(A;;GA;;;SY)(A;;GA;;;BA)(A;;GA;;;CO)";

void OpenLogFile()
{

    bool NewFile = false;

    {

        PSECURITY_DESCRIPTOR SecurityDescriptor = NULL;

        if (!ConvertStringSecurityDescriptorToSecurityDescriptor(
                g_LogSecurityString,
                SDDL_REVISION_1,
                &SecurityDescriptor,
                NULL ) )
            return;

        SECURITY_ATTRIBUTES SecurityAttributes =
        {
            sizeof( SECURITY_ATTRIBUTES ),
            SecurityDescriptor,
            FALSE
        };

        g_LogFile =
            CreateFile(
                g_LogFileName,
                GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                &SecurityAttributes,
                OPEN_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL );

        LocalFree( (HLOCAL)SecurityDescriptor );


        if ( INVALID_HANDLE_VALUE == g_LogFile )
            return;

    }

    SetFilePointer( g_LogFile, 0, NULL, FILE_BEGIN );

    LOG_LINE_TYPE FirstLine;
    DWORD dwBytesRead = 0;

    ReadFile( g_LogFile,
              FirstLine,
              g_LogLineSize,
              &dwBytesRead,
              NULL );

    DWORD LineSize;
    UINT64 LogSlots;
    if ( dwBytesRead != g_LogLineSize ||
         4 != sscanf( FirstLine, "# %u %I64u %u %I64u", &LineSize, &LogSlots, &g_LogSequence, &g_LogCurrentSlot ) ||
         LineSize != g_LogLineSize ||
         LogSlots != g_LogSlots )
        {
        
        NewFile = true;

        g_LogSequence       = 0;
        g_LogCurrentSlot    = 1;

        if ( INVALID_SET_FILE_POINTER == SetFilePointer( g_LogFile, (DWORD)g_LogSlots * g_LogLineSize, NULL, FILE_BEGIN ) )
            goto fatalerror;

        if ( !SetEndOfFile( g_LogFile ) )
            goto fatalerror;

        SetFilePointer( g_LogFile, 0, NULL, FILE_BEGIN );

        }

    g_LogFileMapping =
        CreateFileMapping(
            g_LogFile,
            NULL,
            PAGE_READWRITE,
            0,
            0,
            NULL );
    

    if ( !g_LogFileMapping )
        goto fatalerror;

    g_LogFileBase = (LOG_LINE_TYPE *)
        MapViewOfFile(
             g_LogFileMapping,              // handle to file-mapping object
             FILE_MAP_WRITE | FILE_MAP_READ,// access mode
             0,                             // high-order DWORD of offset
             0,                             // low-order DWORD of offset
             0                              // number of bytes to map
           );


    if ( !g_LogFileBase )
        goto fatalerror;

    if ( NewFile )
        {

        LOG_LINE_TYPE FillTemplate;
        memset( FillTemplate, ' ', sizeof( FillTemplate ) );
        StringCchPrintfA( 
            FillTemplate,
            g_LogLineSize,
            "# %u %I64u %u %I64u", 
            g_LogLineSize, 
            g_LogSlots, 
            g_LogSequence, 
            g_LogCurrentSlot ); 
        FillTemplate[ g_LogLineSize - 2 ] = '\r';
        FillTemplate[ g_LogLineSize - 1 ] = '\n';
        memcpy( g_LogFileBase, FillTemplate, sizeof( FillTemplate ) );


        memset( FillTemplate, '9', sizeof( FillTemplate ) );
        FillTemplate[ g_LogLineSize - 2 ] = '\r';
        FillTemplate[ g_LogLineSize - 1 ] = '\n';

        for( SIZE_T i=1; i < g_LogSlots; i++ )
            memcpy( g_LogFileBase + i, FillTemplate, sizeof( FillTemplate ) );

        }

    g_LogFileEnabled = true;
    return;

fatalerror:

    if ( g_LogFileBase )
        {
        UnmapViewOfFile( (LPCVOID)g_LogFileBase );
        g_LogFileBase = NULL;
        }

    if ( g_LogFileMapping )
        {
        CloseHandle( g_LogFileMapping );
        g_LogFileMapping = NULL;
        }

    if ( INVALID_HANDLE_VALUE != g_LogFile )
        {
        CloseHandle( g_LogFile );
        g_LogFile = INVALID_HANDLE_VALUE;
        }

}

HRESULT LogInit()
{

    if ( !InitializeCriticalSectionAndSpinCount( &g_LogCs, 0x80000000 ) )
        return HRESULT_FROM_WIN32( GetLastError() );

    if (!GetSystemDirectory( g_LogDefaultFileName, MAX_PATH ) )
        {
        HRESULT Hr = HRESULT_FROM_WIN32( GetLastError() );
        DeleteCriticalSection( &g_LogCs );
        return Hr;
        }
        
    StringCchCatA( 
        g_LogDefaultFileName, 
        MAX_PATH,
        "\\bitsserver.log" );
    g_LogFileName = g_LogDefaultFileName;

    HKEY Key = NULL;
    if ( ERROR_SUCCESS == RegOpenKey( HKEY_LOCAL_MACHINE, LOG_SETTINGS_PATH, &Key ) )
        {

        DWORD Type;
        DWORD DataSize = sizeof( g_LogRegistryFileName );
        if ( ERROR_SUCCESS == RegQueryValueEx( Key, 
                                               LOG_FILENAME_VALUE,
                                               NULL,
                                               &Type,
                                               (LPBYTE)g_LogRegistryFileName,
                                               &DataSize ) &&
             ( ( REG_EXPAND_SZ == Type ) || ( REG_SZ == Type ) ) )
            {
            g_LogFileName = g_LogRegistryFileName;
            }
          
        DWORD LogRegistryFlags;
        DataSize = sizeof( LogRegistryFlags );
        if ( ERROR_SUCCESS == RegQueryValueEx( Key, 
                                               LOG_FLAGS_VALUE,
                                               NULL,
                                               &Type,
                                               (LPBYTE)&LogRegistryFlags,
                                               &DataSize ) &&
             ( REG_DWORD == Type ) )
            {
            g_LogFlags = LogRegistryFlags;
            }

        DWORD LogSize;
        DataSize = sizeof( LogSize );
        if ( ERROR_SUCCESS == RegQueryValueEx( Key, 
                                               LOG_SIZE_VALUE,
                                               NULL,
                                               &Type,
                                               (LPBYTE)&LogSize,
                                               &DataSize ) &&
             ( REG_DWORD == Type ) )
            {
            g_LogSlots = ( LogSize * 1000000 ) / g_LogLineSize;
            }


        RegCloseKey( Key );
        Key = NULL;
        }

    if ( g_LogFlags && g_LogFileName && g_LogSlots )
        {     
        OpenLogFile();
        }

    return S_OK;

}

void LogClose()
{

    EnterCriticalSection( &g_LogCs );

    if ( g_LogFileBase )
        {

        memset( g_LogFileBase[0], ' ', sizeof( g_LogLineSize ) );
        StringCchPrintfA( 
            g_LogFileBase[0],
            g_LogLineSize,
            "# %u %I64u %u %I64u", 
            g_LogLineSize, 
            g_LogSlots, 
            g_LogSequence, 
            g_LogCurrentSlot ); 
        g_LogFileBase[0][ g_LogLineSize - 2 ] = '\r';
        g_LogFileBase[0][ g_LogLineSize - 1 ] = '\n';

        UnmapViewOfFile( (LPCVOID)g_LogFileBase );
        g_LogFileBase = NULL;
        }

    if ( g_LogFileMapping )
        {
        CloseHandle( g_LogFileMapping );
        g_LogFileMapping = NULL;
        }

    if ( INVALID_HANDLE_VALUE != g_LogFile )
        {
        CloseHandle( g_LogFile );
        g_LogFile = INVALID_HANDLE_VALUE;
        }

    DeleteCriticalSection( &g_LogCs );
}

void LogInternal( UINT32 LogFlags, char *Format, va_list arglist )
{

    if ( !g_LogFileEnabled && !g_LogDebuggerEnabled )
        return;

    DWORD LastError = GetLastError();

    EnterCriticalSection( &g_LogCs );

    DWORD ThreadId = GetCurrentThreadId();
    DWORD ProcessId = GetCurrentProcessId();

    SYSTEMTIME Time;

    GetLocalTime( &Time );
  
    StringCchVPrintfA( 
          g_LogBuffer, 
          sizeof(g_LogBuffer) - 1,
          Format, arglist );

    int CharsWritten = strlen( g_LogBuffer );

    char *BeginPointer = g_LogBuffer;
    char *EndPointer = g_LogBuffer + CharsWritten;
    DWORD MinorSequence = 0;

    while ( BeginPointer < EndPointer )
        {

        static char StaticLineBuffer[ g_LogLineSize ];
        char *LineBuffer = StaticLineBuffer;

        if ( g_LogFileBase )
            {
            LineBuffer = g_LogFileBase[ g_LogCurrentSlot ];
            g_LogCurrentSlot = ( g_LogCurrentSlot + 1 ) % g_LogSlots;

            // leave the first line alone
            if ( !g_LogCurrentSlot )
                g_LogCurrentSlot = ( g_LogCurrentSlot + 1 ) % g_LogSlots;

            }

        char *CurrentOutput = LineBuffer;

        StringCchPrintfA( 
             LineBuffer,
             g_LogLineSize,
             "%.8X.%.2X %.2u/%.2u/%.4u-%.2u:%.2u:%.2u.%.3u %.4X.%.4X %s|%s|%s|%s|%s ",
             g_LogSequence,
             MinorSequence++,
             Time.wMonth,
             Time.wDay,
             Time.wYear,
             Time.wHour,
             Time.wMinute,
             Time.wSecond,
             Time.wMilliseconds,
             ProcessId,
             ThreadId,
             ( LogFlags & LOG_INFO )        ? "I" : "-",
             ( LogFlags & LOG_WARNING )     ? "W" : "-",
             ( LogFlags & LOG_ERROR )       ? "E" : "-",
             ( LogFlags & LOG_CALLBEGIN )   ? "CB" : "--",
             ( LogFlags & LOG_CALLEND )     ? "CE" : "--" );

        int HeaderSize      = strlen( LineBuffer );
        int SpaceAvailable  = g_LogLineSize - HeaderSize - 2;  // 2 bytes for /r/n
        int OutputChars     = min( (int)( EndPointer - BeginPointer ), SpaceAvailable );
        int PadChars        = SpaceAvailable - OutputChars;
        CurrentOutput       += HeaderSize;

        memcpy( CurrentOutput, BeginPointer, OutputChars );
        CurrentOutput       += OutputChars;
        BeginPointer        += OutputChars;

        memset( CurrentOutput, ' ', PadChars );
        CurrentOutput       += PadChars;

        *CurrentOutput++    = '\r';
        *CurrentOutput++    = '\n';

        ASSERT( CurrentOutput - LineBuffer == g_LogLineSize );

        if ( g_LogDebuggerEnabled )
            {
            static char DebugLineBuffer[ g_LogLineSize + 1];
            memcpy( DebugLineBuffer, LineBuffer, g_LogLineSize );
            DebugLineBuffer[ g_LogLineSize ] = '\0';
            OutputDebugString( DebugLineBuffer );
            }

        }

    g_LogSequence++;

    LeaveCriticalSection( &g_LogCs );

    SetLastError( LastError );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\server\isapi\config.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    config.cpp

Abstract:

    This file implements metabase access routines for virtual directories.

--*/

#include "precomp.h"

VDirConfig::VDirConfig( 
    StringHandle Path, 
    IMSAdminBase *AdminBase
    ) :
    m_Refs(1)
{

    //
    // Read in all the metabase configuration for the virtual directory.
    //

    HRESULT Hr;
    METADATA_HANDLE MdVDirKey   = NULL;
    GetSystemTimeAsFileTime( &m_LastLookup );
        
    try
    {
        
        m_Path = Path;

        StringHandleW UnicodePath = Path;

        Hr = AdminBase->OpenKey(
            METADATA_MASTER_ROOT_HANDLE,
            (const WCHAR*)UnicodePath,
            METADATA_PERMISSION_READ,
            30000,
            &MdVDirKey );


        if ( FAILED(Hr) )
            throw ServerException( Hr );

        m_PhysicalPath =
            GetMetaDataString(
                AdminBase,
                MdVDirKey,
                NULL,
                MD_VR_PATH,
                "" );

        DWORD UploadEnabled =
            GetMetaDataDWORD(
                AdminBase,
                MdVDirKey,
                NULL,
                g_PropertyMan->GetPropertyMetabaseID( MD_BITS_UPLOAD_ENABLED ),
                0);

        m_UploadEnabled = UploadEnabled ? true : false;

        m_ConnectionsDir =
            GetMetaDataString(
                AdminBase,
                MdVDirKey,
                NULL,
                g_PropertyMan->GetPropertyMetabaseID( MD_BITS_CONNECTION_DIR ),
                MD_DEFAULT_BITS_CONNECTION_DIRA );


        m_NoProgressTimeout =
            GetMetaDataDWORD(
                AdminBase,
                MdVDirKey,
                NULL,
                g_PropertyMan->GetPropertyMetabaseID( MD_BITS_NO_PROGRESS_TIMEOUT ),
                MD_DEFAULT_NO_PROGESS_TIMEOUT );

        StringHandle MaxFilesizeString =
            GetMetaDataString(
                AdminBase,
                MdVDirKey,
                NULL,
                g_PropertyMan->GetPropertyMetabaseID( MD_BITS_MAX_FILESIZE ),
                MD_DEFAULT_BITS_MAX_FILESIZEA );

        if ( MaxFilesizeString.Size() == 0 )
            {
            m_MaxFileSize = 0xFFFFFFFFFFFFFFFF;
            }
        else
            {
            UINT64 MaxFileSize;
            int ScanRet = sscanf( (const char*)MaxFilesizeString, "%I64u", &MaxFileSize );

            if ( 1 != ScanRet )
                throw ServerException( E_INVALIDARG );

            m_MaxFileSize = MaxFileSize;
            }

        DWORD NotificationType =
            GetMetaDataDWORD(
                AdminBase,
                MdVDirKey,
                NULL,
                g_PropertyMan->GetPropertyMetabaseID( MD_BITS_NOTIFICATION_URL_TYPE ),
                MD_DEFAULT_BITS_NOTIFICATION_URL_TYPE );

        if ( NotificationType > BITS_NOTIFICATION_TYPE_MAX )
            throw ServerException( E_INVALIDARG );

        m_NotificationType = (BITS_SERVER_NOTIFICATION_TYPE)NotificationType;


        m_NotificationURL =
            GetMetaDataString(
                AdminBase,
                MdVDirKey,
                NULL,
                g_PropertyMan->GetPropertyMetabaseID( MD_BITS_NOTIFICATION_URL ),
                MD_DEFAULT_BITS_NOTIFICATION_URLA );


        m_HostId =
            GetMetaDataString(
                AdminBase,
                MdVDirKey,
                NULL,
                g_PropertyMan->GetPropertyMetabaseID( MD_BITS_HOSTID ),
                MD_DEFAULT_BITS_HOSTIDA );

        m_HostIdFallbackTimeout =
            GetMetaDataDWORD(
                AdminBase,
                MdVDirKey,
                NULL,
                g_PropertyMan->GetPropertyMetabaseID( MD_BITS_HOSTID_FALLBACK_TIMEOUT ),
                MD_DEFAULT_HOSTID_FALLBACK_TIMEOUT );

        m_ExecutePermissions =
            GetMetaDataDWORD(
                AdminBase,
                MdVDirKey,
                NULL,
                MD_ACCESS_PERM,
                MD_ACCESS_READ );

        AdminBase->CloseKey( MdVDirKey );

    }
    catch( ServerException Exception )
    {
        if ( MdVDirKey )
            AdminBase->CloseKey( MdVDirKey );
        throw;
    }

}

ConfigurationManager::ConfigurationManager()
{

    m_IISAdminBase = NULL;
    bool CSInitialize = false;
    
    memset( m_PathCacheEntries, 0, sizeof( m_PathCacheEntries ) );
    memset( m_MapCacheEntries, 0, sizeof( m_MapCacheEntries ) );

    HRESULT Hr =
        CoInitializeEx( NULL, COINIT_MULTITHREADED );

    if ( FAILED(Hr) )
        throw ServerException( Hr );

    try
    {
        if ( !InitializeCriticalSectionAndSpinCount( &m_CacheCS, 0x80000100 ) )
            throw ServerException( HRESULT_FROM_WIN32( GetLastError() ) );

        CSInitialize = true;

        Hr =
            CoCreateInstance(
                GETAdminBaseCLSID(TRUE),
                NULL,
                CLSCTX_SERVER,
                __uuidof( IMSAdminBase ),
                (LPVOID*)&m_IISAdminBase );

        if ( FAILED(Hr) )
            throw ServerException( Hr );

        Hr = m_IISAdminBase->GetSystemChangeNumber( &m_ChangeNumber );

        if ( FAILED(Hr))
            throw ServerException( Hr );

        CoUninitialize();
            
    }
    catch( ServerException )
    {
        if ( m_IISAdminBase )
            m_IISAdminBase->Release();
        if ( CSInitialize )
            DeleteCriticalSection( &m_CacheCS );
        CoUninitialize();
        throw;
    }

}

ConfigurationManager::~ConfigurationManager()
{
    FlushCache();
    DeleteCriticalSection( &m_CacheCS );

    if ( m_IISAdminBase )
        m_IISAdminBase->Release();

}

void
ConfigurationManager::FlushCache()
{

    for( unsigned int i = 0; i < PATH_CACHE_ENTRIES; i++ )
        {
        if ( m_PathCacheEntries[i] )
            {
            m_PathCacheEntries[i]->Release();
            m_PathCacheEntries[i] = NULL;
            }
        }
    for( unsigned int i = 0; i < MAP_CACHE_ENTRIES; i++ )
        {
        delete m_MapCacheEntries[i];
        m_MapCacheEntries[i] = NULL;
        }

}

VDirConfig*        
ConfigurationManager::Lookup( 
    StringHandle Path )
{

    VDirConfig* ReturnVal = NULL;
    for( unsigned int i=0; i < PATH_CACHE_ENTRIES; i++ )
        {

        if ( m_PathCacheEntries[i] )
            {

            if ( strcmp( (const char*)m_PathCacheEntries[i]->m_Path, (const char*)Path) == 0 )
                {

                ReturnVal = m_PathCacheEntries[i];
                GetSystemTimeAsFileTime( &ReturnVal->m_LastLookup );
                ReturnVal->AddRef();
                }
            }
        }

    return ReturnVal;
}

void  
ConfigurationManager::Insert( 
    VDirConfig *NewConfig )
{

    //
    // Insert a new virtual directory configuration into the 
    // virtual directory cache.  Expire an old entry if needed.
    //

    int BestSlot = 0;
    FILETIME WorstTime;
    memset( &WorstTime, 0xFF, sizeof( WorstTime ) );

    for( unsigned int i=0; i < PATH_CACHE_ENTRIES; i++ )
        {

        if ( !m_PathCacheEntries[i] )
            {
            BestSlot = i;
            break;
            }
        else if ( CompareFileTime( &m_PathCacheEntries[i]->m_LastLookup, &WorstTime  ) < 0 )
            {
            WorstTime = m_PathCacheEntries[i]->m_LastLookup;
            BestSlot = i;
            }

        }

    if ( m_PathCacheEntries[BestSlot] )
        m_PathCacheEntries[BestSlot]->Release();

    NewConfig->AddRef();
    m_PathCacheEntries[BestSlot] = NewConfig;

}

VDirConfig*
ConfigurationManager::Lookup( 
    StringHandle InstanceMetabasePath,
    StringHandle URL )
{

    //
    // Find the virtual directories configuration in the cache.
    //

    VDirConfig* ReturnVal = NULL;
    for( unsigned int i=0; i < MAP_CACHE_ENTRIES; i++ )
        {

        MapCacheEntry* CacheEntry = m_MapCacheEntries[i]; 

        if ( CacheEntry )
            {

            if ( ( strcmp( (const char*)CacheEntry->m_InstanceMetabasePath, 
                           (const char*)InstanceMetabasePath) == 0 ) &&
                 ( strcmp( (const char*)CacheEntry->m_URL,
                           (const char*)URL ) == 0 ) )
                {

                GetSystemTimeAsFileTime( &CacheEntry->m_LastLookup );
                ReturnVal = m_MapCacheEntries[i]->m_Config;
                ReturnVal->AddRef();
                return ReturnVal;
                }
            }
        }

    return ReturnVal;

}

VDirConfig*
ConfigurationManager::GetVDirConfig(
    StringHandle Path )
{

    VDirConfig* Config = Lookup( Path );

    if ( !Config )
        {

        try
        {

            Config = new VDirConfig( Path, m_IISAdminBase );

            Insert( Config );

        }
        catch( ServerException Exception )
        {
            if ( Config )
                Config->Release();

            throw;
        }

        }

    return Config;

}


VDirConfig*         
ConfigurationManager::Insert( 
    StringHandle InstanceMetabasePath, 
    StringHandle URL, 
    StringHandle Path )
{

    VDirConfig* Config = GetVDirConfig( Path );

    try
    {

        MapCacheEntry* CacheEntry = 
            new MapCacheEntry(
                InstanceMetabasePath,
                URL,
                Config );


        int BestSlot = 0;
        FILETIME WorstTime;
        memset( &WorstTime, 0xFF, sizeof( WorstTime ) );

        for( unsigned int i=0; i < MAP_CACHE_ENTRIES; i++ )
            {

            if ( !m_MapCacheEntries[i] )
                {
                BestSlot = i;
                break;
                }
            else if ( CompareFileTime( &m_MapCacheEntries[i]->m_LastLookup, &WorstTime  ) < 0 )
                {
                WorstTime = m_MapCacheEntries[i]->m_LastLookup;
                BestSlot = i;
                }

            }

        if ( m_MapCacheEntries[BestSlot] )
            delete m_MapCacheEntries[BestSlot];

        m_MapCacheEntries[BestSlot] = CacheEntry;
        return Config;    
    
    }
    catch( ServerException Exception )
    {
        Config->Release();
        throw;
    }

}

StringHandle        
ConfigurationManager::GetVDirPath( 
    StringHandle InstanceMetabasePath, 
    StringHandle URL )
{


    //
    // Find the virtual directory that coresponds to the URL.  
    // Do this by matching the URL up with the metabase keys.  Keep
    // pruning off the URL untill the longest metabase path is found
    // that is a virtual directory.
    //


    StringHandleW InstanceMetabasePathW = InstanceMetabasePath;
    StringHandleW URLW                  = URL;
    WCHAR *Path                         = NULL;
    METADATA_HANDLE MdVDirKey           = NULL;

    try
    {
        
        WCHAR *PathEnd      = NULL;
        WCHAR *CurrentEnd   = NULL;
        WCHAR RootString[]  = L"/Root";

        SIZE_T InstancePathSize = InstanceMetabasePathW.Size();
        SIZE_T URLSize          = URLW.Size();
        SIZE_T RootStringSize   = ( sizeof( RootString ) / sizeof( *RootString ) ) - 1;

        Path = new WCHAR[ InstancePathSize + URLSize + RootStringSize + 1 ];
        memcpy( Path, (const WCHAR*)InstanceMetabasePathW, InstancePathSize * sizeof( WCHAR ) );
        
        PathEnd = Path + InstancePathSize;
        memcpy( PathEnd, RootString, RootStringSize * sizeof( WCHAR ) );
        memcpy( PathEnd + RootStringSize, (const WCHAR*)URLW, ( URLSize + 1 )* sizeof( WCHAR ) );

        CurrentEnd = PathEnd + RootStringSize + URLSize;

        while( 1 )
            {

            HRESULT Hr =
                m_IISAdminBase->OpenKey(
                    METADATA_MASTER_ROOT_HANDLE,    //metabase handle.
                    Path,                           //path to the key, relative to hMDHandle.
                    METADATA_PERMISSION_READ,       //specifies read and write permissions.
                    5000,                           //the time, in milliseconds, before the method times out.
                    &MdVDirKey                      //receives the handle to the opened key.
                    );


            if ( SUCCEEDED( Hr ) )
                {
                
                // 
                // Check if this is a virtual directory
                // 

                WCHAR NodeName[ 255 ];
                DWORD RequiredDataLen;
                METADATA_RECORD MDRecord;
                MDRecord.dwMDIdentifier     = MD_KEY_TYPE;
                MDRecord.dwMDAttributes     = METADATA_NO_ATTRIBUTES;
                MDRecord.dwMDUserType       = IIS_MD_UT_SERVER;
                MDRecord.dwMDDataType       = STRING_METADATA;
                MDRecord.dwMDDataLen        = sizeof( NodeName );
                MDRecord.pbMDData           = (unsigned char*)NodeName;
                MDRecord.dwMDDataTag        = 0;
                    
                Hr = m_IISAdminBase->GetData(
                    MdVDirKey,
                    NULL,
                    &MDRecord,
                    &RequiredDataLen );

                if ( FAILED(Hr) && ( Hr != MD_ERROR_DATA_NOT_FOUND ) &&
                     ( Hr != HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER ) ) )
                    throw ServerException( Hr );


                if ( SUCCEEDED( Hr ) && wcscmp( L"IIsWebVirtualDir", NodeName ) == 0 )
                    {

                    // Found the path, so return the data
                    StringHandle VDirPath = Path;
                    delete[] Path;
                    m_IISAdminBase->CloseKey( MdVDirKey );

                    return VDirPath;

                    }

                }

            else if ( Hr != HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND ) ) 
                {
                throw ServerException( Hr );
                }

                
            //
            // If this is the end of the URL, then nothing else can be done
            //

            if ( CurrentEnd == PathEnd )
                throw ServerException( E_INVALIDARG );

            m_IISAdminBase->CloseKey( MdVDirKey );
            MdVDirKey = NULL;

            // Chop off the rightmost subpart
            while( CurrentEnd != PathEnd && *CurrentEnd != L'/' &&
                   *CurrentEnd != L'\\' )
                CurrentEnd--;

            if ( *CurrentEnd == L'/' || *CurrentEnd == L'\\' )
                *CurrentEnd = L'\0';

            // Attempt another round
            
            }

    }
    catch( ServerException Exception )
    {
        delete[] Path;

        if ( MdVDirKey )
            m_IISAdminBase->CloseKey( MdVDirKey );

        throw;

    }
}


bool
ConfigurationManager::HandleCacheConsistency()
{

    //
    // Handle cache consistency.  This is done my calling IIS to check the change number.
    // If the current change number is different then the change number for the last lookup,
    // then flush the cache.
    // 

    DWORD ChangeNumber;
    HRESULT Hr = m_IISAdminBase->GetSystemChangeNumber( &ChangeNumber );
    if ( FAILED(Hr) )
        {
        throw ServerException( Hr );
        }

    if ( ChangeNumber == m_ChangeNumber )
        return true; // cache is consistent

    FlushCache();
	m_ChangeNumber = ChangeNumber;
    return false; // cache was flushed.
    
}


VDirConfig* 
ConfigurationManager::GetConfig( 
    StringHandle InstanceMetabasePath, 
    StringHandle URL )
{

    //
    // Toplevel function to do everything to lookup the configuration to use for an URL.
    //

    METADATA_HANDLE MdVDirKey   = NULL;
    VDirConfig * Config         = NULL;

    HRESULT Hr =
        CoInitializeEx( NULL, COINIT_MULTITHREADED );

    if ( FAILED(Hr) )
        throw ServerException( Hr );

    HANDLE ImpersonationToken   = NULL;
    bool DidRevertToSelf        = false;

    try
    {

        EnterCriticalSection( &m_CacheCS );

        if ( HandleCacheConsistency() )
            {


            // The cache was consistent.  Chances are good
            // that the lookup will succeed

            Config = Lookup( InstanceMetabasePath, URL );

            if ( Config )
                {
                CoUninitialize();
                LeaveCriticalSection( &m_CacheCS );
                return Config;
                }

            }
        
        // Need to revert to the system process
        // to address the metabase

        if ( !OpenThreadToken(
                GetCurrentThread(),
                TOKEN_ALL_ACCESS,
                TRUE,
                &ImpersonationToken ) )
		    {
			DWORD dwError = GetLastError();

			if (dwError != ERROR_NO_TOKEN)
                throw ServerException( HRESULT_FROM_WIN32( dwError ) );
		    }
        else
		    {
            if ( !RevertToSelf() )
                throw ServerException( HRESULT_FROM_WIN32( GetLastError() ) );

            DidRevertToSelf = true;
		    }

        StringHandle Path = GetVDirPath( InstanceMetabasePath, URL );

        Config = Insert( InstanceMetabasePath, URL, Path );

		if ( DidRevertToSelf ) 
            {
            BITSSetCurrentThreadToken( ImpersonationToken );
            }

        if ( ImpersonationToken )
            CloseHandle( ImpersonationToken );

        CoUninitialize();
        LeaveCriticalSection( &m_CacheCS );
        return Config;

    }
    catch( ServerException Exception )
    {
        if ( Config )
            delete Config;

        if ( MdVDirKey )
            m_IISAdminBase->CloseKey( MdVDirKey );
        
		if ( DidRevertToSelf )
            BITSSetCurrentThreadToken( ImpersonationToken );

        if ( ImpersonationToken )
            CloseHandle( ImpersonationToken );

        CoUninitialize();
        LeaveCriticalSection( &m_CacheCS );

        throw;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\server\isapi\resource.h ===
#define IDS_EXTENSION_NAME              1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\server\isapi\precomp.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Main header for BITS server extensions

--*/

#define INITGUID
#include<nt.h>
#include<ntrtl.h>
#include<nturtl.h>
#include <windows.h>
#include <httpfilt.h>
#include <httpext.h>
#include <objbase.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <iadmw.h>
#include <iiscnfg.h>
#include <shlwapi.h>
#include <winsock2.h>
#include <iphlpapi.h>

#ifdef USE_WININET
#include <wininet.h>
#else
#include "winhttp.h"
#include "inethttp.h"
#endif

#include <activeds.h>
#include <bitsmsg.h>
#include "resource.h"

#include <strsafe.h>

#if defined(DBG)

// check build
#define BITS_MUST_SUCCEED( expr ) ASSERT( expr )

#else

// free build
#define BITS_MUST_SUCCEED( expr ) ( expr )

#endif

const UINT32 LOG_INFO       = 0x1;
const UINT32 LOG_WARNING    = 0x2;
const UINT32 LOG_ERROR      = 0x4;
const UINT32 LOG_CALLBEGIN  = 0x8;
const UINT32 LOG_CALLEND    = 0x10;

#if defined(DBG)
const UINT32 DEFAULT_LOG_FLAGS = LOG_INFO | LOG_WARNING | LOG_ERROR | LOG_CALLBEGIN | LOG_CALLEND;
#else
const UINT32 DEFAULT_LOG_FLAGS = 0;
#endif

const UINT32 DEFAULT_LOG_SIZE  = 20;

// LogSetings path under HKEY_LOCAL_MACHINE
const char * const LOG_SETTINGS_PATH = "SOFTWARE\\Microsoft\\BITSServer";

// Values
// (REG_EXPAND_SZ). Contains the full path of the log file name
const char * const LOG_FILENAME_VALUE = "LogFileName";
// (REG_DWORD) Contains the log flags
const char * const LOG_FLAGS_VALUE = "LogFlags";
// (REG_DWORD) Contains the log size in MB
const char * const LOG_SIZE_VALUE = "LogSize";

extern UINT32 g_LogFlags;

HRESULT LogInit();
void LogClose();
void LogInternal( UINT32 LogFlags, char *Format, va_list arglist );

void inline Log( UINT32 LogFlags, char *Format, ... )
{

    if ( !( g_LogFlags & LogFlags ) )
        return;

    va_list arglist;
    va_start( arglist, Format );

    LogInternal( LogFlags, Format, arglist );

}

const char *LookupHTTPStatusCodeText( DWORD HttpCode );

class ServerException
{
public:

    ServerException() :
        m_Code( 0 ),
        m_HttpCode( 0 ),
        m_Context( 0 )
    {
    }

    ServerException( HRESULT Code, DWORD HttpCode = 0, DWORD Context = 0x5 ) :
        m_Code( Code ),
        m_HttpCode( HttpCode ? HttpCode : MapStatus( Code ) ),
        m_Context( Context )
    {
    }
    HRESULT GetCode() const
    {
        return m_Code;
    }
    DWORD GetHttpCode() const
    {
        return m_HttpCode;
    }

    DWORD GetContext() const
    {
        return m_Context;
    }

    void SendErrorResponse( EXTENSION_CONTROL_BLOCK * ExtensionControlBlock ) const;
    DWORD MapStatus( HRESULT Hr ) const;

private:
    HRESULT m_Code;
    DWORD m_HttpCode;
    DWORD m_Context;
};

class CharStringRoutines
{

public:
    static int strcmp( const char *str1, const char *str2 )
    {
        return ::strcmp( str1, str2 );
    }

    static HRESULT StringCchCopy( char *str1, size_t cchDest, const char *str2 )
    {
        return ::StringCchCopyA( str1, cchDest, str2 );
    }

    static size_t strlen( const char *str )
    {
        return ::strlen( str );
    }

    static void* ConvertToInternal( SIZE_T Pad, const char *String, SIZE_T & Size )
    {
        Size = ::strlen( String );
        char *Ret = new char[ Pad + Size + 1 ];
        ::StringCchCopyA( Ret + Pad, Size + 1, String );
        return (void*)Ret;
    }

    static void* ConvertToInternal( SIZE_T Pad, const WCHAR *String, SIZE_T & Size )
    {

        int Alloc =
            WideCharToMultiByte(
                  CP_THREAD_ACP,            // code page
                  0,                        // performance and mapping flags
                  String,                   // wide-character string
                  -1,                       // number of chars in string
                  NULL,                     // buffer for new string
                  0,                        // size of buffer
                  NULL,                     // default for unmappable chars
                  NULL                      // set when default char used
                  );

        if ( !Alloc )
            throw ServerException( HRESULT_FROM_WIN32( GetLastError() ) );

        char *Ret = new char[ Pad + Alloc ];

        int Actual =
            WideCharToMultiByte(
                  CP_THREAD_ACP,            // code page
                  0,                        // performance and mapping flags
                  String,                   // wide-character string
                  -1,                       // number of chars in string
                  Ret + Pad,                // buffer for new string
                  Alloc,                    // size of buffer
                  NULL,                     // default for unmappable chars
                  NULL                      // set when default char used
                  );

        if ( !Actual )
            {
            HRESULT Hr = HRESULT_FROM_WIN32( GetLastError() );
            delete[] Ret;
            throw ServerException( Hr );
            }

        Size = Actual - 1;
        return Ret;

    }
};

class WCHARStringRoutines
{

public:
   static int strcmp( const WCHAR *str1, const WCHAR *str2 )
   {
       return ::wcscmp( str1, str2 );
   }

   static HRESULT StringCchCopy( WCHAR *str1, size_t cchDest, const WCHAR *str2 )
   {
       return ::StringCchCopyW( str1, cchDest, str2 );
   }

   static size_t strlen( const wchar_t *str )
   {
       return ::wcslen( str );
   }

   static void* ConvertToInternal( SIZE_T Pad, const WCHAR *String, SIZE_T & Size )
   {
       Size = ::wcslen( String );
       char *Ret = new char[ Pad + ( ( Size + 1 ) * sizeof(WCHAR) ) ];
       ::StringCchCopyW( (WCHAR*)(Ret + Pad), Size + 1, String );
       return (void*)Ret;
   }

   static void* ConvertToInternal( SIZE_T Pad, const char *String, SIZE_T & Size )
   {

        int Alloc =
            MultiByteToWideChar(
                CP_THREAD_ACP,         // code page
                0,                     // character-type options
                String,                // string to map
                -1,                    // number of bytes in string
                NULL,                  // wide-character buffer
                0                      // size of buffer
            );

        if ( !Alloc )
            throw ServerException( HRESULT_FROM_WIN32( GetLastError() ) );

        char *Ret = new char[ Pad + ( Alloc * sizeof(WCHAR) ) ];

        int Actual =
            MultiByteToWideChar(
                CP_THREAD_ACP,         // code page
                0,                     // character-type options
                String,                // string to map
                -1,                    // number of bytes in string
                (WCHAR*)( Ret + Pad ), // wide-character buffer
                Alloc                  // size of buffer
            );

        if ( !Actual )
            {
            HRESULT Hr = HRESULT_FROM_WIN32( GetLastError() );
            delete[] Ret;
            throw ServerException( Hr );
            }

        Size = Actual - 1;
        return Ret;

   }
};

template<class T, class CONV>
class StringHandleTemplate : private CONV
{

    struct StringData
    {
        SIZE_T          m_Count;
        long            m_Refs;
    };

    struct EmptyStringData
    {
        StringData      m_StringData;
        T               m_Data;
    };

    static EmptyStringData s_EmptyString;

    StringData *m_Value;

    void NewString( const char *String, bool ReplaceExisting = false );
    void NewString( const WCHAR *String, bool ReplaceExisting = false );

    StringData * RefIt() const
    {
        InterlockedIncrement( &m_Value->m_Refs );
        return m_Value;
    }

    void FreeIt()
    {
        if ( InterlockedDecrement( &m_Value->m_Refs ) == 0 )
            delete[] (char*)m_Value;
    }

    // Create String by concating 2 strings
    StringHandleTemplate( const StringData *LeftValue, const T *RightValue, SIZE_T RightSize );


public:

    StringHandleTemplate()
    {
        NewString( (T*)NULL );
    }

    StringHandleTemplate( const char *String )
    {
        NewString( String );
    }

    StringHandleTemplate( const WCHAR *String )
    {
        NewString( String );
    }


    StringHandleTemplate( const StringHandleTemplate & Other ) :
        m_Value( Other.RefIt() )
    {
    }

    ~StringHandleTemplate()
    {
        FreeIt();
    }

    void SetStringSize()
    {
        m_Value->m_Count = strlen( (T*)(m_Value + 1) );
    }

    T *AllocBuffer( SIZE_T Size );

    StringHandleTemplate & operator=( const StringHandleTemplate & r )
    {
        FreeIt();
        m_Value = r.RefIt();
        return *this;
    }

    StringHandleTemplate & operator=( const T * r )
    {
        NewString( r, true );
        return *this;
    }

    SIZE_T Size() const
    {
        return m_Value->m_Count;
    }

    operator const T*() const
    {
        return (const T*)(m_Value + 1);
    }

    bool operator <( const StringHandleTemplate & r ) const
    {
        if ( m_Value == r.m_Value)
            return false;
        return (strcmp( (const T*)*this, (const T*)r ) < 0);
    }

    StringHandleTemplate operator+( const StringHandleTemplate & r ) const
    {
        return StringHandleTemplate( m_Value, (T*)(r.m_Value+1), r.m_Value->m_Count );
    }

    StringHandleTemplate operator+( const T * p ) const
    {
        static const T EmptyChar = '\0';

        if ( !p )
            return StringHandleTemplate( m_Value, &EmptyChar, 0 );

        return StringHandleTemplate( m_Value, p, strlen(p) );
    }
    StringHandleTemplate & operator+=( const StringHandleTemplate & r )
    {
        return (*this = (*this + r ) );
    }
    StringHandleTemplate & operator+=( const T * p )
    {
        return (*this = (*this + p ) );
    }
};

template<class T,class CONV>
void
StringHandleTemplate<T,CONV>::NewString( const char *String, bool ReplaceExisting )
{
   if ( !String )
       {
       
       InterlockedIncrement( &s_EmptyString.m_StringData.m_Refs );
       StringData* Value = (StringData*)&s_EmptyString;
       
       if ( ReplaceExisting )
           FreeIt();
       
       m_Value = Value;
       return;
       
       }

   SIZE_T Size;
   StringData* Value = (StringData*)ConvertToInternal( sizeof(StringData), String, Size );
   Value->m_Count = Size;
   Value->m_Refs  = 1;

   if ( ReplaceExisting )
       FreeIt();

   m_Value = Value;

}

template<class T,class CONV>
void
StringHandleTemplate<T,CONV>::NewString( const WCHAR *String, bool ReplaceExisting )
{
   
   if ( !String )
       {
       InterlockedIncrement( &s_EmptyString.m_StringData.m_Refs );
       StringData* Value = (StringData*)&s_EmptyString;

       if ( ReplaceExisting )
           FreeIt();
       
       m_Value = Value;
       return;
       }

   SIZE_T Size;
   StringData* Value = (StringData*)ConvertToInternal( sizeof(StringData), String, Size );
   Value->m_Count = Size;
   Value->m_Refs  = 1;

   if ( ReplaceExisting )
       FreeIt();

   m_Value = Value;

}


// Create String by concating 2 strings
template<class T,class CONV>
StringHandleTemplate<T,CONV>::StringHandleTemplate( const StringData *LeftValue, const T *RightValue, SIZE_T RightSize )
{
   SIZE_T Size = LeftValue->m_Count + RightSize;
   m_Value = (StringData*)new char[ sizeof(StringData) + (Size*sizeof(T)) + sizeof(T) ];
   m_Value->m_Count = Size;
   m_Value->m_Refs  = 1;
   
   T *DestData = (T*)( m_Value + 1 );
   memcpy( DestData, (T*)(LeftValue + 1), sizeof(T) * LeftValue->m_Count );
   memcpy( DestData + LeftValue->m_Count, RightValue, sizeof( T ) * RightSize );
   DestData[ Size ] = 0;
}


template<class T,class CONV>
T *
StringHandleTemplate<T,CONV>::AllocBuffer( SIZE_T Size )
{
    StringData *Data = (StringData*)new T[sizeof(StringData)+(Size*sizeof(T))+sizeof(T)];
    Data->m_Count   = 0;
    Data->m_Refs    = 1;
    T *String = (T*)(Data + 1);
    String[0] = '\0';

    FreeIt(); // Free old string
    m_Value = Data;

    // Whoever fills in the string needs to call SetStringSize
    return String;

}

template<class T,class CONV>
StringHandleTemplate<T,CONV>::EmptyStringData StringHandleTemplate<T,CONV>::s_EmptyString =
    {
        0, 1, L'\0'            // Initialize with 1 ref so it is never deleted
    };

typedef StringHandleTemplate<char, CharStringRoutines> StringHandleA;
typedef StringHandleTemplate<WCHAR, WCHARStringRoutines> StringHandleW;
typedef StringHandleA StringHandle;


inline UINT64 FILETIMEToUINT64( const FILETIME & FileTime )
{
    ULARGE_INTEGER LargeInteger;
    LargeInteger.HighPart = FileTime.dwHighDateTime;
    LargeInteger.LowPart = FileTime.dwLowDateTime;
    return LargeInteger.QuadPart;
}

inline FILETIME UINT64ToFILETIME( UINT64 Int64Value )
{
    ULARGE_INTEGER LargeInteger;
    LargeInteger.QuadPart = Int64Value;

    FILETIME FileTime;
    FileTime.dwHighDateTime = LargeInteger.HighPart;
    FileTime.dwLowDateTime = LargeInteger.LowPart;

    return FileTime;
}


// API thunks

UINT64 BITSGetFileSize(
    HANDLE Handle );

UINT64 BITSSetFilePointer(
    HANDLE Handle,
    INT64 Distance,
    DWORD MoveMethod );

DWORD
BITSWriteFile(
    HANDLE Handle,
    LPCVOID Buffer,
    DWORD NumberOfBytesToWrite);

void
BITSCreateDirectory(
    LPCTSTR DirectoryName
    );

void
BITSRenameFile(
    LPCTSTR ExistingName,
    LPCTSTR NewName );

void
BITSDeleteFile(
    LPCTSTR FileName );

GUID
BITSCreateGuid();

GUID
BITSGuidFromString( const char *String );

StringHandle
BITSStringFromGuid(
    GUID Guid );


StringHandle
BITSUnicodeToStringHandle( const WCHAR *pStr );

StringHandle
BITSUrlCombine(
    const char *Base,
    const char *Relative,
    DWORD dwFlags );

StringHandle
BITSUrlCanonicalize(
    const char *URL,
    DWORD dwFlags );

void
BITSSetCurrentThreadToken(
    HANDLE hToken );

// Metadata wrappers

StringHandle
GetMetaDataString(
    IMSAdminBase        *IISAdminBase,
    METADATA_HANDLE     Handle,
    LPCWSTR             Path,
    DWORD               dwIdentifier,
    LPCSTR              DefaultValue );

DWORD
GetMetaDataDWORD(
    IMSAdminBase        *IISAdminBase,
    METADATA_HANDLE     Handle,
    LPCWSTR             Path,
    DWORD               dwIdentifier,
    DWORD               DefaultValue );

class WorkStringBufferA
{
    char *Data;

public:

    WorkStringBufferA( SIZE_T Size )
    {
        Data = new char[Size];
    }
    WorkStringBufferA( const char* String )
    {
        size_t BufferSize = strlen(String) + 1;
        Data = new char[ BufferSize ];
        memcpy( Data, String, BufferSize );
    }
    ~WorkStringBufferA()
    {
        delete[] Data;
    }

    char *GetBuffer()
    {
        return Data;
    }
};

class WorkStringBufferW
{
    WCHAR *Data;

public:

    WorkStringBufferW( SIZE_T Size )
    {
        Data = new WCHAR[Size];
    }
    WorkStringBufferW( const WCHAR* String )
    {
        size_t BufferSize = wcslen(String) + 1;
        Data = new WCHAR[ BufferSize ];
        memcpy( Data, String, BufferSize * sizeof( WCHAR ) );
    }
    ~WorkStringBufferW()
    {
        delete[] Data;
    }

    WCHAR *GetBuffer()
    {
        return Data;
    }
};


typedef WorkStringBufferA WorkStringBuffer;

const char * const BITS_CONNECTIONS_NAME_WITH_SLASH="BITS-Connections\\";
const char * const BITS_CONNECTIONS_NAME="BITS-Connections";
const UINT64 NanoSec100PerSec = 10000000;    //no of 100 nanosecs per sec
const DWORD WorkerRunInterval = 1000 * 60 /*secs*/ * 60 /*mins*/ * 12; /* hours */ /* twice a day */
const UINT64 CleanupThreshold = NanoSec100PerSec * 60 /*secs*/ * 60 /*mins*/ * 24 /* hours */ * 3; // 3 days


//
// Configuration manager
//

#include "bitssrvcfg.h"


class ConfigurationManager;
class VDirConfig
{
    friend ConfigurationManager;

    LONG                            m_Refs;
    FILETIME                        m_LastLookup;

public:
    StringHandle                    m_Path;
    StringHandle                    m_PhysicalPath;
    StringHandle                    m_ConnectionsDir;
    DWORD                           m_NoProgressTimeout;
    UINT64                          m_MaxFileSize;
    BITS_SERVER_NOTIFICATION_TYPE   m_NotificationType;
    StringHandle                    m_NotificationURL;
    bool                            m_UploadEnabled;
    StringHandle                    m_HostId;
    DWORD                           m_HostIdFallbackTimeout;
    DWORD                           m_ExecutePermissions;

    VDirConfig(
        StringHandle Path,
        IMSAdminBase *AdminBase );

    void AddRef()
    {
        InterlockedIncrement( &m_Refs );
    }

    void Release()
    {

        if (!InterlockedDecrement( &m_Refs ))
            delete this;
    }
};

class MapCacheEntry
{
    friend ConfigurationManager;

    FILETIME                        m_LastLookup;

public:

    StringHandle m_InstanceMetabasePath;
    StringHandle m_URL;
    VDirConfig   *m_Config;

    MapCacheEntry(
        StringHandle InstanceMetabasePath,
        StringHandle URL,
        VDirConfig * Config ) :
        m_InstanceMetabasePath( InstanceMetabasePath ),
        m_URL( URL ),
        m_Config( Config )
    {
        m_Config->AddRef();
        GetSystemTimeAsFileTime( &m_LastLookup );
    }

    ~MapCacheEntry()
    {
        m_Config->Release();
    }
};

class ConfigurationManager
{
public:

    ConfigurationManager();
    ~ConfigurationManager();

    VDirConfig* GetConfig( StringHandle InstanceMetabasePath, StringHandle URL );

    static const PATH_CACHE_ENTRIES = 10;
    static const MAP_CACHE_ENTRIES = 10;

private:

    IMSAdminBase        *m_IISAdminBase;
    CRITICAL_SECTION    m_CacheCS;
    DWORD               m_ChangeNumber;

    VDirConfig          *m_PathCacheEntries[ PATH_CACHE_ENTRIES ];
    MapCacheEntry       *m_MapCacheEntries[ MAP_CACHE_ENTRIES ];

    void                FlushCache();
    bool                HandleCacheConsistency();

    // L2 cache
    VDirConfig*         Lookup( StringHandle Path );
    void                Insert( VDirConfig *NewConfig );
    VDirConfig*         GetVDirConfig( StringHandle Path );

    // L1 cache
    VDirConfig*         Lookup( StringHandle InstanceMetabasePath,
                                StringHandle URL );
    VDirConfig*         Insert( StringHandle InstanceMetabasePath,
                                StringHandle URL,
                                StringHandle Path );

    StringHandle        GetVDirPath( StringHandle InstanceMetabasePath,
                                     StringHandle URL );

};

extern ConfigurationManager *g_ConfigMan;
extern HMODULE g_hinst;
extern PropertyIDManager *g_PropertyMan;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\server\isapi\dload.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    dload.cpp

Abstract:

    This file implement dload error handling

--*/

#include "precomp.h"
#include <delayimp.h>

BOOL
BITSFailureHookWinHttpAddRequestHeaders(
    IN HINTERNET hRequest,
    IN LPCWSTR lpszHeaders,
    IN DWORD dwHeadersLength,
    IN DWORD dwModifiers
    )
{

    SetLastError( ERROR_MOD_NOT_FOUND );
    return FALSE;

}

BOOL
BITSFailureHookWinHttpCloseHandle(
    IN HINTERNET hInternet
    )
{
    SetLastError( ERROR_MOD_NOT_FOUND );
    return FALSE;
}

HINTERNET
BITSFailureHookWinHttpConnect(
    IN HINTERNET hInternetSession,
    IN LPCWSTR pszServerNameW,
    IN INTERNET_PORT nServerPort,
    IN DWORD dwReserved
    )
{
    SetLastError( ERROR_MOD_NOT_FOUND );
    return NULL;
}

BOOL
BITSFailureHookWinHttpCrackUrl(
    IN LPCWSTR pszUrlW,
    IN DWORD dwUrlLengthW,
    IN DWORD dwFlags,
    IN OUT LPURL_COMPONENTS pUCW
    )
{
    SetLastError( ERROR_MOD_NOT_FOUND );
    return FALSE;
}

HINTERNET
BITSFailureHookWinHttpOpen(
    IN LPCWSTR pszAgentW,
    IN DWORD dwAccessType,
    IN LPCWSTR pszProxyW OPTIONAL,
    IN LPCWSTR pszProxyBypassW OPTIONAL,
    IN DWORD dwFlags
    )
{
    SetLastError( ERROR_MOD_NOT_FOUND );
    return NULL;
}

HINTERNET
BITSFailureHookWinHttpOpenRequest(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszVerb,
    IN LPCWSTR lpszObjectName,
    IN LPCWSTR lpszVersion,
    IN LPCWSTR lpszReferrer OPTIONAL,
    IN LPCWSTR FAR * lplpszAcceptTypes OPTIONAL,
    IN DWORD dwFlags
    )
{
    SetLastError( ERROR_MOD_NOT_FOUND );
    return NULL;
}

BOOL
BITSFailureHookWinHttpQueryHeaders(
    IN HINTERNET hRequest,
    IN DWORD dwInfoLevel,
    IN     LPCWSTR lpszName OPTIONAL, 
       OUT LPVOID  lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwIndex OPTIONAL
    )
{
    SetLastError( ERROR_MOD_NOT_FOUND );
    return FALSE;
}

BOOL
BITSFailureHookWinHttpReadData(
    IN HINTERNET hFile,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead
    )
{
    SetLastError( ERROR_MOD_NOT_FOUND );
    return FALSE;
}

BOOL
BITSFailureHookWinHttpReceiveResponse(
    IN HINTERNET hRequest,
    IN LPVOID lpBuffersOut OPTIONAL
    )
{
    SetLastError( ERROR_MOD_NOT_FOUND );
    return FALSE;
}

BOOL
BITSFailureHookWinHttpSendRequest(
    IN HINTERNET hRequest,
    IN LPCWSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional OPTIONAL,
    IN DWORD dwOptionalLength,
    IN DWORD dwTotalLength,
    IN DWORD_PTR dwContext
    )
{
    SetLastError( ERROR_MOD_NOT_FOUND );
    return FALSE;
}

BOOL
BITSFailureHookWinHttpWriteData(
    IN HINTERNET hFile,
    IN LPCVOID lpBuffer,
    IN DWORD dwNumberOfBytesToWrite,
    OUT LPDWORD lpdwNumberOfBytesWritten
    )
{
    SetLastError( ERROR_MOD_NOT_FOUND );
    return FALSE;
}

struct FailureHookTableEntry
{
    LPCSTR  pszDllName;
    LPCSTR  pszProcName;
    FARPROC pfnHandler;
};
 
FailureHookTableEntry FailureHookTable[] =
{

    {
    "winhttp.dll",
    "WinHttpAddRequestHeaders",
    (FARPROC)BITSFailureHookWinHttpAddRequestHeaders
    },

    {
    "winhttp.dll",
    "WinHttpCloseHandle",
    (FARPROC)BITSFailureHookWinHttpCloseHandle
    },

    {
    "winhttp.dll",
    "WinHttpConnect",
    (FARPROC)BITSFailureHookWinHttpConnect
    },

    {
    "winhttp.dll",
    "WinHttpCrackUrl",
    (FARPROC)BITSFailureHookWinHttpCrackUrl
    },

    {
    "winhttp.dll",
    "WinHttpOpen",
    (FARPROC)BITSFailureHookWinHttpOpen
    },

    {
    "winhttp.dll",
    "WinHttpOpenRequest",
    (FARPROC)BITSFailureHookWinHttpOpenRequest
    },

    {
    "winhttp.dll",
    "WinHttpQueryHeaders",
    (FARPROC)BITSFailureHookWinHttpQueryHeaders
    },

    {
    "winhttp.dll",
    "WinHttpReadData",
    (FARPROC)BITSFailureHookWinHttpReadData
    },

    {
    "winhttp.dll",
    "WinHttpReceiveResponse",
    (FARPROC)BITSFailureHookWinHttpReceiveResponse
    },

    {
    "winhttp.dll",
    "WinHttpSendRequest",
    (FARPROC)BITSFailureHookWinHttpSendRequest
    },

    {
    "winhttp.dll",
    "WinHttpWriteData",
    (FARPROC)BITSFailureHookWinHttpWriteData
    },

    {
    NULL,
    NULL,
    NULL
    }

};

FARPROC
LookupFailureHook(
    LPCSTR pszDllName,
    LPCSTR pszProcName
    )
{

    for ( FailureHookTableEntry *p = FailureHookTable; 
          p->pszDllName; p++ )
        {

        if ( ( lstrcmpiA( pszDllName, p->pszDllName ) == 0   ) &&
             ( lstrcmpiA( pszProcName, p->pszProcName ) == 0 )  )
            {
            return p->pfnHandler;
            }

        }
    
    ASSERT( 0 );
    return NULL;

}

FARPROC
WINAPI
BITSSERVER_DelayLoadFailureHook(
    UINT unReason,
    PDelayLoadInfo pDelayInfo
    )
{
    
    // For a failed LoadLibrary, we return a bogus HMODULE of -1 to force
    // DLOAD call again with dliFailGetProc
    
    if (dliFailLoadLib == unReason)
        {
        return (FARPROC)-1;
        }

    if (dliFailGetProc == unReason)
        {
        
        // The loader is asking us to return a pointer to a procedure.
        // Lookup the handler for this DLL/procedure and, if found, return it.
        return LookupFailureHook(pDelayInfo->szDll, pDelayInfo->dlp.szProcName);

        }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\server\mmcexts\about.cpp ===
/************************************************************************

Copyright (c) 2001 Microsoft Corporation

Module Name :

    about.cpp

Abstract :

    Handles about information for MMC snapin.

Author :

Revision History :

 ***********************************************************************/

#include "precomp.h"

CSnapinAbout::CSnapinAbout()
: m_cref(1),
m_hSmallImage( NULL ),
m_hSmallImageOpen( NULL ),
m_hLargeImage( NULL ),
m_hAppIcon( NULL )
{
    OBJECT_CREATED
}

CSnapinAbout::~CSnapinAbout()
{
    if (m_hSmallImage != NULL)
        FreeResource(m_hSmallImage);

    if (m_hLargeImage != NULL)
        FreeResource(m_hLargeImage);

    if (m_hSmallImageOpen != NULL)
        FreeResource(m_hSmallImageOpen);

    if (m_hAppIcon != NULL)
        FreeResource(m_hAppIcon);

    m_hSmallImage = NULL;
    m_hLargeImage = NULL;
    m_hSmallImageOpen = NULL;
    m_hAppIcon = NULL;

    OBJECT_DESTROYED
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CSnapinAbout::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<ISnapinAbout *>(this);
    else if (IsEqualIID(riid, IID_ISnapinAbout))
        *ppv = static_cast<ISnapinAbout *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CSnapinAbout::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CSnapinAbout::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        // we need to decrement our object count in the DLL
        delete this;
        return 0;
    }
    return m_cref;

}

///////////////////////////////
// Interface ISnapinAbout
///////////////////////////////
STDMETHODIMP CSnapinAbout::GetSnapinDescription(
                                                /* [out] */ LPOLESTR *lpDescription)
{
    return LoadStringHelper( lpDescription, IDS_BITSMGR_DESC );
}


STDMETHODIMP CSnapinAbout::GetProvider(
                                       /* [out] */ LPOLESTR *lpName)
{
    return LoadStringHelper( lpName, IDS_BITSMGR_PROVIDER );
}


STDMETHODIMP CSnapinAbout::GetSnapinVersion(
                                            /* [out] */ LPOLESTR *lpVersion)
{
    return LoadStringHelper( lpVersion, IDS_BITSMGR_VERSION_STR );
}


STDMETHODIMP CSnapinAbout::GetSnapinImage(
                                          /* [out] */ HICON *hAppIcon)
{

    if ( m_hAppIcon )
        {
        *hAppIcon = m_hAppIcon;
        return S_OK;
        }

    *hAppIcon = m_hAppIcon = 
        LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_BITSMGR));

    if ( !m_hAppIcon )
        return HRESULT_FROM_WIN32( GetLastError() );

    return S_OK;
}


STDMETHODIMP CSnapinAbout::GetStaticFolderImage(
                                                /* [out] */ HBITMAP *hSmallImage,
                                                /* [out] */ HBITMAP *hSmallImageOpen,
                                                /* [out] */ HBITMAP *hLargeImage,
                                                /* [out] */ COLORREF *cMask)
{

    HRESULT Hr = S_OK;

    if ( m_hSmallImage )
        *hSmallImage = m_hSmallImage;
    else
        {

        *hSmallImage = m_hSmallImage =
            (HBITMAP)LoadImage(
                g_hinst,
                MAKEINTRESOURCE(IDB_SMALL),
                IMAGE_BITMAP,
                0,
                0,
                LR_DEFAULTCOLOR
                );

        if ( !m_hSmallImage )
            {
            Hr = HRESULT_FROM_WIN32( GetLastError() );
            goto Fail;
            }

        }

    if ( m_hSmallImageOpen )
        *hSmallImageOpen = m_hSmallImageOpen;
    else
        {

        *hSmallImageOpen = m_hSmallImageOpen =
            (HBITMAP)LoadImage(
                g_hinst,
                MAKEINTRESOURCE(IDB_SMALL),
                IMAGE_BITMAP,
                0,
                0,
                LR_DEFAULTCOLOR
                );

        if ( !m_hSmallImageOpen )
            {
            Hr = HRESULT_FROM_WIN32( GetLastError() );
            goto Fail;
            }

        }

    
    if ( m_hLargeImage )
        *hLargeImage = m_hLargeImage;
    else
        {

        *hLargeImage = m_hLargeImage =
            (HBITMAP)LoadImage(
                g_hinst,
                MAKEINTRESOURCE(IDB_SMALL),
                IMAGE_BITMAP,
                0,
                0,
                LR_DEFAULTCOLOR
                );

        if ( !m_hLargeImage )
            {
            Hr = HRESULT_FROM_WIN32( GetLastError() );
            goto Fail;
            }

        }

    *cMask = RGB(255,0,255); // purple
    return S_OK;

Fail:
    *hSmallImage = *hSmallImageOpen = *hLargeImage = NULL;
    memset( cMask, 0, sizeof(COLORREF) );
    return Hr;

}

HRESULT	
CSnapinAbout::LoadStringHelper(
    LPOLESTR *lpDest, 
    UINT Id )
{
    *lpDest = (LPOLESTR)CoTaskMemAlloc( sizeof(WCHAR) * MAX_PATH );

    if ( !lpDest )
        return E_OUTOFMEMORY;

    int RetVal =
        LoadString( g_hinst, Id, *lpDest, MAX_PATH - 1 );

    if ( !RetVal )
        {
        HRESULT Hr = HRESULT_FROM_WIN32( GetLastError() );
        CoTaskMemFree( lpDest );
        *lpDest = NULL;
        return Hr;
        }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\server\isapi\server.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    server.cpp                         

Abstract:

    This file implements the BITS server extensions

--*/

#include "precomp.h"

#if DBG
#define CLEARASYNCBUFFERS
#endif

#if defined( USE_WININET )
typedef StringHandleA HTTPStackStringHandle;
typedef char HTTP_STRING_TYPE;
#define HTTP_STRING( X ) X
#else
typedef StringHandleW HTTPStackStringHandle;
typedef WCHAR HTTP_STRING_TYPE;
#define HTTP_STRING( X ) L ## X
#endif


const DWORD SERVER_REQUEST_SPINLOCK = 0x80000040;
const DWORD ASYNC_READER_SPINLOCK   = 0x80000040;

const char * const UPLOAD_PROTOCOL_STRING_V1 = "{7df0354d-249b-430f-820d-3d2a9bef4931}";

// packet types that are sent in the protocol
const char * const PACKET_TYPE_CREATE_SESSION   = "Create-Session";
const char * const PACKET_TYPE_FRAGMENT         = "Fragment";
const char * const PACKET_TYPE_CLOSE_SESSION    = "Close-Session";
const char * const PACKET_TYPE_CANCEL_SESSION   = "Cancel-Session";
const char * const PACKET_TYPE_PING             = "Ping";

//
// IISLogger
//
// Manages the circular debugging log.
//

class IISLogger
{
   EXTENSION_CONTROL_BLOCK *m_ExtensionControlBlock;

   void LogString( const char *String, int Size );

public:

   IISLogger( EXTENSION_CONTROL_BLOCK *ExtensionControlBlock ) :
       m_ExtensionControlBlock( ExtensionControlBlock )
   {
   }
   
   void LogError( ServerException Error );
   void LogError( const GUID & SessionID, ServerException Error );
   void LogNewSession( const GUID & SessionID );
   void LogUploadComplete( const GUID & SessionID, UINT64 FileSize );
   void LogSessionClose( const GUID & SessionID );
   void LogSessionCancel( const GUID & SessionID );
   void LogExecuteEnabled();



};

class CriticalSectionLock
{
    CRITICAL_SECTION* m_cs;
public:
    CriticalSectionLock( CRITICAL_SECTION *cs ) :
        m_cs( cs )
    {
        EnterCriticalSection( m_cs );
    }
    ~CriticalSectionLock()
    {
        LeaveCriticalSection( m_cs );
    }      
};

class AsyncReader;

//
// ServerRequest
//
// Contains all data needed to service a request.   A request is a single POST not a single 
// upload.

class ServerRequest : IISLogger
{

public:
    ServerRequest( EXTENSION_CONTROL_BLOCK * ExtensionControlBlock );
    ~ServerRequest();

    long AddRef();
    long Release();
    bool IsPending() { return m_IsPending; }

    // The do it function!
    void DispatchRequest();
    friend AsyncReader;

private:
    long m_refs;
    CRITICAL_SECTION m_cs;
    bool m_IsPending;
    EXTENSION_CONTROL_BLOCK *m_ExtensionControlBlock;
    AsyncReader *m_AsyncReader;

    // Filled in by dispatch Request
    StringHandle m_PacketType;

    // Variables filled in by CrackPhysicalPath
    StringHandle m_PhysicalPath;                 // Path part of PathTranslated
    StringHandle m_PhysicalFile;                 // File part of PathTranslated
    StringHandle m_PhysicalPathAndFile;          // All of PathTranslated
    StringHandle m_ConnectionsDirectory;         // Path of the BITS connections directory
    StringHandle m_ConnectionDirectory;          // Path of the connection directory for this connection
    StringHandle m_CacheFileDirectoryAndFile;    // Full file path of cache file
    StringHandle m_ResponseFileDirectoryAndFile; // Full file path of response file

    // Filled in by OpenCacheFile
    HANDLE m_CacheFile;

    GUID m_SessionId;
    StringHandle m_SessionIdString;

    VDirConfig *m_DirectoryConfig;

    void GetConfig();
    StringHandle GetServerVariable( char *ServerVariable );
    bool TestServerVariable( char *ServerVariable );
    StringHandle GetRequestURL();

    void ValidateProtocol();
    void CrackSessionId();
    void CrackPhysicalPath();
    void OpenCacheFile();
    void ReopenCacheFileAsSync();
    void CloseCacheFile();
    void CrackContentRange(
        UINT64 & RangeStart,
        UINT64 & RangeLength,
        UINT64 & TotalLength );
    void ScheduleAsyncOperation(
        DWORD   OperationID,
        LPVOID  Buffer,
        LPDWORD Size,
        LPDWORD DataType );
    void CloseCancelSession();

    // dispatch routines
    void CreateSession();
    void AddFragment();
    void CloseSession();
    void CancelSession();
    void Ping();


    // Response handling
    void SendResponse( char *Format, DWORD Code = 200, ... );
    void SendResponse( ServerException Exception );
    void FinishSendingResponse();
    void DrainFragmentBlockComplete( DWORD cbIO, DWORD dwError );
    static void DrainFragmentBlockCompleteWrapper(
        LPEXTENSION_CONTROL_BLOCK lpECB,
        PVOID pContext,
        DWORD cbIO,
        DWORD dwError);
    void StartDrainBlock( );
    void DrainData();

    StringHandle m_ResponseString;
    DWORD   m_ResponseCode;
    HRESULT m_ResponseHRESULT;

    UINT64  m_BytesToDrain;
    UINT64  m_ContentLength;

    // async IO handling
    void CompleteIO( AsyncReader *Reader, UINT64 TotalBytesRead );
    void HandleIOError( AsyncReader *Reader, ServerException Error, UINT64 TotalBytesRead );

    // backend notification
    char m_NotifyBuffer[ 1024 ];
    void CallServerNotification( UINT64 CacheFileSize );
    bool TestResponseHeader( HINTERNET hRequest, const HTTP_STRING_TYPE *Header );
    StringHandle GetResponseHeader( HINTERNET hRequest, const HTTP_STRING_TYPE *Header );

    // deal with chaining
    static void ForwardComplete(
        LPEXTENSION_CONTROL_BLOCK lpECB, PVOID pContext,
        DWORD cbIO, DWORD dwError );
    void ForwardToNextISAPI();

};

// AsyncReader
//
// Manages the buffering needed to handle the async read/write operations.

class AsyncReader : private OVERLAPPED
{

public:
    AsyncReader( ServerRequest *Request,
                 UINT64 BytesToDrain,
                 UINT64 BytesToWrite,
                 UINT64 WriteOffset,
                 bool IsLastBlock,
                 HANDLE WriteHandle,
                 char *PrereadBuffer,
                 DWORD PrereadSize );


    ~AsyncReader();

    UINT64 GetWriteOffset()
    {
        return m_WriteOffset;
    }

    bool IsLastBlock()
    {
        return m_IsLastBlock;
    }

private:

    ServerRequest *m_Request;
    UINT64 m_BytesToDrain;
    UINT64 m_WriteOffset;
    UINT64 m_ReadOffset;
    UINT64 m_BytesToWrite;
    UINT64 m_BytesToRead;
    bool   m_IsLastBlock;
    char * m_PrereadBuffer;
    DWORD  m_PrereadSize;
    UINT64 m_TotalBytesRead;
    HANDLE m_WriteHandle;
    HANDLE m_ThreadToken;

    char m_OperationsPending;

    DWORD m_ReadBuffer;
    DWORD m_WriteBuffer;
    DWORD m_BuffersToWrite;

    bool m_WritePending;
    bool m_ReadPending;

    bool m_ErrorValid;
    ServerException m_Error;

    const static NUMBER_OF_IO_BUFFERS = 3;
    struct IOBuffer
    {
        UINT64  m_BufferWriteOffset;
        DWORD   m_BufferUsed;
        char    m_Buffer[ 32768 ];
    } m_IOBuffers[ NUMBER_OF_IO_BUFFERS ];

    void HandleError( ServerException Error );
    void CompleteIO();
    void StartReadRequest();
    void StartWriteRequest();
    void StartupIO( );
    void WriteComplete( DWORD dwError, DWORD BytesWritten );
    void ReadComplete( DWORD dwError, DWORD BytesRead );

    static DWORD StartupIOWraper( LPVOID Context );
    static void CALLBACK WriteCompleteWraper( DWORD dwErrorCode, DWORD dwNumberOfBytesTransfered, LPOVERLAPPED lpOverlapped );
    static void WINAPI ReadCompleteWraper( LPEXTENSION_CONTROL_BLOCK, PVOID pContext, DWORD cbIO, DWORD dwError );
};

ServerRequest::ServerRequest(
    EXTENSION_CONTROL_BLOCK * ExtensionControlBlock
    ) :
    IISLogger( ExtensionControlBlock ),
    m_refs(1),
    m_IsPending( false ),
    m_ExtensionControlBlock( ExtensionControlBlock ),
    m_AsyncReader( NULL ),
    m_CacheFile( INVALID_HANDLE_VALUE ),
    m_DirectoryConfig( NULL ),
    m_ResponseCode( 0 ),
    m_ResponseHRESULT( 0 ),
    m_BytesToDrain( 0 ),
    m_ContentLength( 0 )
{
    memset( &m_SessionId, 0, sizeof(m_SessionId) );

    if ( !InitializeCriticalSectionAndSpinCount( &m_cs, SERVER_REQUEST_SPINLOCK ) )
        throw ServerException( HRESULT_FROM_WIN32( GetLastError() ) );
}


ServerRequest::~ServerRequest()
{

    // The destructor handles most of the cleanup.

    Log( LOG_CALLEND, "Connection: %p, Packet-Type: %s, Method: %s, Path %s, HTTPError: %u, HRESULT: 0x%8.8X",
         m_ExtensionControlBlock->ConnID,
         (const char*)m_PacketType,
         m_ExtensionControlBlock->lpszMethod,
         static_cast<const char*>( m_PhysicalPathAndFile ),
         m_ResponseCode,
         m_ResponseHRESULT );

    delete m_AsyncReader;

    CloseCacheFile();

    if ( m_DirectoryConfig )
        m_DirectoryConfig->Release();

    DeleteCriticalSection( &m_cs );

    if ( m_IsPending )
        {

        Log( LOG_INFO, "Ending session" );

        (*m_ExtensionControlBlock->ServerSupportFunction)
        (   m_ExtensionControlBlock->ConnID,
            HSE_REQ_DONE_WITH_SESSION,
            NULL,
            NULL,
            NULL );

        }

}

long
ServerRequest::AddRef()
{
    long Result = InterlockedIncrement( &m_refs );
    ASSERT( Result > 0 );
    return Result;
}

long
ServerRequest::Release()
{
    long Result = InterlockedDecrement( &m_refs );
    ASSERT( Result >= 0 );
    
    if ( !Result )
        delete this;

    return Result;

}


StringHandle
ServerRequest::GetServerVariable(
    char * ServerVariable )
{
    //
    // Retrive a server variable from IIS.  Throws an exception 
    // is the variable can not be retrieved.
    //

    DWORD SizeOfBuffer = 0;

    BOOL Result = (*m_ExtensionControlBlock->GetServerVariable)
        ( m_ExtensionControlBlock->ConnID,
          ServerVariable,
          NULL,
          &SizeOfBuffer );

    if ( Result )
        return StringHandle();

    if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER )
        {

        Log( LOG_ERROR, "Unable to lookup server variable %s, error %x",
             ServerVariable,
             HRESULT_FROM_WIN32( GetLastError() ) );

        throw ServerException( HRESULT_FROM_WIN32(GetLastError()) );
        }

    StringHandle WorkString;
    char *Buffer = WorkString.AllocBuffer( SizeOfBuffer );

    Result = (*m_ExtensionControlBlock->GetServerVariable)
        ( m_ExtensionControlBlock->ConnID,
          ServerVariable,
          Buffer,
          &SizeOfBuffer );

    if ( !Result )
        {
        Log( LOG_ERROR, "Unable to lookup server variable %s, error %x",
             ServerVariable,
             HRESULT_FROM_WIN32( GetLastError() ) );

        throw ServerException( HRESULT_FROM_WIN32( GetLastError() ) );
        }

    WorkString.SetStringSize();
    return WorkString;
}

bool
ServerRequest::TestServerVariable(
    char *ServerVariable )
{

    // Test for the existence of a server variable.
    // Returns true if the variable exists, and false if it doesn't.
    // throw an exception on an error.

    DWORD SizeOfBuffer = 0;

    BOOL Result = (*m_ExtensionControlBlock->GetServerVariable)
        ( m_ExtensionControlBlock->ConnID,
          ServerVariable,
          NULL,
          &SizeOfBuffer );

    if ( Result )
        return true;

    DWORD dwError = GetLastError();

    if ( ERROR_INVALID_INDEX == dwError ||
         ERROR_NO_DATA == dwError )
        return false;

    if ( ERROR_INSUFFICIENT_BUFFER == dwError )
        return true;

    Log( LOG_ERROR, "Unable to test server variable %s, error %x",
         ServerVariable,
         HRESULT_FROM_WIN32( GetLastError() ) );

    throw ServerException( HRESULT_FROM_WIN32( dwError ) );

}

StringHandle
ServerRequest::GetRequestURL()
{

    // Recreate the request URL from the information available from IIS.
    // This may not always be possible, but do the best that we can do.

    StringHandle ServerName     =   GetServerVariable("SERVER_NAME");
    StringHandle ServerPort     =   GetServerVariable("SERVER_PORT");
    StringHandle URL            =   GetServerVariable("URL");
    StringHandle HTTPS          =   GetServerVariable("HTTPS");
    StringHandle QueryString    =   GetServerVariable("QUERY_STRING");

    StringHandle RequestURL;

    if ( _stricmp( HTTPS, "on" ) == 0 )
        RequestURL = "https://";
    else
        RequestURL = "http://";

    RequestURL += ServerName;
    RequestURL += ":";
    RequestURL += ServerPort;
    RequestURL += URL;

    if ( QueryString.Size() > 0 )
        {
        RequestURL += "?";
        RequestURL += QueryString;
        }

    return BITSUrlCanonicalize( RequestURL, URL_ESCAPE_UNSAFE );
}

void
ServerRequest::FinishSendingResponse()
{

    // Completes the response.   The response is taken from the buffer and
    // sent to the client via IIS. The choice to cancel or keep-alive the
    // connection made by IIS.

    Log( LOG_INFO, "Finish sending response" );

    // Close the cache before sending the response in case the client starts a new request immediatly.

    CloseCacheFile();

    // Finish sending the response using the information
    // in m_ResponseBuffer and m_ResponseCode.

    // If an error occures, give up and force a disconnect.

    m_ExtensionControlBlock->dwHttpStatusCode = m_ResponseCode;

    BOOL Result;
    BOOL KeepConnection;

    Result =
        (m_ExtensionControlBlock->ServerSupportFunction)(
            m_ExtensionControlBlock->ConnID,
            HSE_REQ_IS_KEEP_CONN,
            &KeepConnection,
            NULL,
            NULL );

    if ( !Result )
        {
        // Error occured quering the disconnect setting.  Assume
        // a disconnect.

        KeepConnection = 0;
        }

    // IIS5.0(Win2k) has a bug where KeepConnect is returned as -1
    // to keep the connection alive.   Apparently, this confuses the
    // HSE_REQ_SEND_RESPONSE_HEADER_EX call.   Bash the value into a real bool.

    KeepConnection = KeepConnection ? 1 : 0;

    HSE_SEND_HEADER_EX_INFO HeaderInfo;
    HeaderInfo.pszStatus = LookupHTTPStatusCodeText( m_ResponseCode );
    HeaderInfo.cchStatus = strlen( HeaderInfo.pszStatus );
    HeaderInfo.pszHeader = (const char*)m_ResponseString;
    HeaderInfo.cchHeader = (DWORD)m_ResponseString.Size();
    HeaderInfo.fKeepConn = KeepConnection;

    Result =
        (m_ExtensionControlBlock->ServerSupportFunction)(
            m_ExtensionControlBlock->ConnID,
            HSE_REQ_SEND_RESPONSE_HEADER_EX,
            &HeaderInfo,
            NULL,
            NULL );

    if ( !Result )
        {

        Log( LOG_ERROR, "Unable to send response, error %x",
             HRESULT_FROM_WIN32( GetLastError() ) );

        Log( LOG_INFO, "Forcing the connection closed" );

        // Couldn't send the response, attempt to close the connection
        Result =
            (m_ExtensionControlBlock->ServerSupportFunction)(
               m_ExtensionControlBlock->ConnID,
               HSE_REQ_CLOSE_CONNECTION,
               NULL,
               NULL,
               NULL );

        if ( !Result )
            {

            // The close connection request failed.   No choice but to invoke
            // the hammer of death

            (m_ExtensionControlBlock->ServerSupportFunction)(
               m_ExtensionControlBlock->ConnID,
               HSE_REQ_ABORTIVE_CLOSE,
               NULL,
               NULL,
               NULL );

            }

        }

}

void
ServerRequest::SendResponse( char *Format, DWORD Code, ...)
{
    // Starts the sending of a response.   Unfortunatly, many HTTP
    // client stacks do not handle a response being returned while
    // data is still being sent.  To handle this, it is necessary
    // to capture the response to a buffer.  Then after all the sent data
    // is drained, finally send the response.

    va_list arglist;
    va_start( arglist, Code );

    SIZE_T ResponseBufferSize = 512;

    while( 1 )
        {
        
        char * ResponseBuffer = m_ResponseString.AllocBuffer( ResponseBufferSize );

        HRESULT Hr =
           StringCchVPrintfA( 
               ResponseBuffer,
               ResponseBufferSize,
               Format,
               arglist );

        if ( SUCCEEDED( Hr ) )
            {
            m_ResponseString.SetStringSize();
            break;
            }
        else if ( STRSAFE_E_INSUFFICIENT_BUFFER == Hr )
            ResponseBufferSize *= 2;
        else
            throw ServerException( Hr );

        if ( ResponseBufferSize >= 0xFFFFFFFF )
            throw ServerException( E_INVALIDARG );

        }


    m_ResponseCode = Code;

    // Drain data in error cases, othersize assume that
    // we already drained all the data.



    if ( Code >= 400 )
        {

        // This is an error case.  Drain the data first, then send
        // the response.

        Log( LOG_INFO, "HTTP status >= 400, draining data" );

        try
        {
            // start draining data.  DrainData() calls FinishSendingResponse
            // when it is finished.

            DrainData();
        }
        catch( ServerException Exception )
        {
            // something is very broken, and an attempt to drain excess data
            // failed.   Nothing else to do except try sending the response.

            FinishSendingResponse();
        }
        return;

        }
    else
        {

        // Just send the response since we already handled draining

        FinishSendingResponse();

        }
}

void
ServerRequest::SendResponse( ServerException Exception )
{

    // Starts the sending of a response.   Unfortunatly, many HTTP
    // client stacks do not handle a response being returned while
    // data is still being sent.  To handle this, it is necessary
    // to capture the response to a buffer.  Then after all the sent data
    // is drained, finally send the response.

    GUID NullGuid;
    memset( &NullGuid, 0, sizeof( NullGuid ) );

    if ( memcmp( &NullGuid, &m_SessionId, sizeof( NullGuid ) ) == 0 )
        LogError( Exception );
    else
        LogError( m_SessionId, Exception );

    SIZE_T ResponseBufferSize = 512;

    while( 1 )
        {
        
        char * ResponseBuffer = m_ResponseString.AllocBuffer( ResponseBufferSize );

        HRESULT Hr =
            StringCchPrintfA( 
                   ResponseBuffer,
                   ResponseBufferSize,
                   "Pragma: no-cache\r\n"
                   "BITS-packet-type: Ack\r\n"
                   "BITS-Error: 0x%8.8X\r\n"
                   "BITS-Error-Context: 0x%X\r\n"
                   "\r\n",
                   Exception.GetCode(),
                   Exception.GetContext() );

        if ( SUCCEEDED( Hr ) )
            {
            m_ResponseString.SetStringSize();
            break;
            }
        else if ( STRSAFE_E_INSUFFICIENT_BUFFER == Hr )
            ResponseBufferSize *= 2;
        else
            throw ServerException( Hr );

        if ( ResponseBufferSize >= 0xFFFFFFFF )
            throw ServerException( E_INVALIDARG );

        }

    m_ResponseCode      = Exception.GetHttpCode();
    m_ResponseHRESULT   = Exception.GetCode();

    Log( LOG_INFO, "Sending error response of HRESULT: 0x%8.8X, HTTP status: %d",
         m_ResponseHRESULT, m_ResponseCode );

    try
    {
        DrainData();
    }
    catch( ServerException Exception )
    {
        FinishSendingResponse();
    }

}


void
ServerRequest::DrainFragmentBlockComplete(
  DWORD cbIO,
  DWORD dwError )
{

    // A drain block has been completed.   If this is the last block, finish sending the response.
    // Otherwise, 

    Log( LOG_INFO, "Drain fragment complete, cbIO: %u, dwError: %u", cbIO, dwError );

    m_BytesToDrain -= cbIO;

    if ( !m_BytesToDrain || !cbIO || dwError )
        {
        FinishSendingResponse();
        return;
        }

    try
    {
        StartDrainBlock();
    }
    catch( ServerException Exception )
    {
        // An error occured while draining data, exit
        FinishSendingResponse();
    }

}


void
ServerRequest::DrainFragmentBlockCompleteWrapper(
  LPEXTENSION_CONTROL_BLOCK lpECB,
  PVOID pContext,
  DWORD cbIO,
  DWORD dwError)
{
    // Wrapper, handles critical section

    ServerRequest *This = (ServerRequest*)pContext;
    {
        CriticalSectionLock CSLock( &This->m_cs );
        This->DrainFragmentBlockComplete( cbIO, dwError );
    }
    This->Release();
}

void
ServerRequest::StartDrainBlock( )
{

    // start the next block to drain.

    BOOL Result;
    static char s_Buffer[ 32768 ];
    DWORD ReadSize  = (DWORD)min( 0xFFFFFFFF, min( m_BytesToDrain, sizeof( s_Buffer ) ) );
    DWORD Flags     = HSE_IO_ASYNC;

    Log( LOG_INFO, "Starting next drain block of %u bytes", ReadSize );

    ScheduleAsyncOperation(
        HSE_REQ_ASYNC_READ_CLIENT,
        (LPVOID)s_Buffer,
        &ReadSize,
        &Flags );

}

void
ServerRequest::DrainData()
{

    // Make the decission regarding the amount of data to drain
    // and the start the first block

    if ( m_DirectoryConfig )
        m_BytesToDrain = min( m_BytesToDrain, m_DirectoryConfig->m_MaxFileSize );
    else
        // use an internal max of 4KB
        m_BytesToDrain = min( 4096, m_BytesToDrain );

    if ( !m_BytesToDrain )
        {
        Log( LOG_INFO, "No bytes to drain, finish it" );
        FinishSendingResponse();
        return;
        }

    Log( LOG_INFO, "Starting pipe drain" );

    BOOL Result;

    Result =
        (*m_ExtensionControlBlock->ServerSupportFunction)(
            m_ExtensionControlBlock->ConnID,
            HSE_REQ_IO_COMPLETION,
            (LPVOID)DrainFragmentBlockCompleteWrapper,
            0,
            (LPDWORD)this );

    if ( !Result )
        {
        Log( LOG_ERROR, "Error settings callback, error %x",
             HRESULT_FROM_WIN32( GetLastError() ) );
        throw ServerException( HRESULT_FROM_WIN32( GetLastError() ) );
        }

    StartDrainBlock();
}


void
ServerRequest::ValidateProtocol()
{

    // Negotiate the protocol with the client.   The client sends a list of
    // supported protocols to the server and the server picks the best protocol.
    // For now, only one protocol is supported.

    StringHandle SupportedProtocolsHandle = GetServerVariable( "HTTP_BITS-SUPPORTED-PROTOCOLS" );
    WorkStringBuffer SupportedProtocolsBuffer( (const char*) SupportedProtocolsHandle );
    char *SupportedProtocols = SupportedProtocolsBuffer.GetBuffer();

    char *Protocol = strtok( SupportedProtocols, " ," );

    while( Protocol )
        {

        if ( _stricmp( Protocol, UPLOAD_PROTOCOL_STRING_V1 ) == 0 )
            {
            Log( LOG_INFO, "Detected protocol upload protocol V1" );
            return;
            }

        Protocol = strtok( NULL, " ," );
        }

    Log( LOG_INFO, "Unsupported protocols, %s", (const char*)SupportedProtocols );
    throw ServerException( E_INVALIDARG );
}

void
ServerRequest::CrackSessionId()
{
    // Convert the session ID from a string into a GUID.
    StringHandle SessionId = GetServerVariable( "HTTP_BITS-Session-Id" );

    m_SessionId         = BITSGuidFromString( SessionId );
    m_SessionIdString   = BITSStringFromGuid( m_SessionId );
}

void
ServerRequest::CrackContentRange(
    UINT64 & RangeStart,
    UINT64 & RangeLength,
    UINT64 & TotalLength )
{

    // Crack the content range header which contains the client's view of where the 
    // upload is at.

    StringHandle ContentRange = GetServerVariable( "HTTP_Content-Range" );

    UINT64 RangeEnd;

    int ReturnVal = sscanf( ContentRange, " bytes %I64u - %I64u / %I64u ",
                            &RangeStart, &RangeEnd, &TotalLength );

    if ( TotalLength > m_DirectoryConfig->m_MaxFileSize )
        {
        Log( LOG_ERROR, "Size of the upload at %I64u is greater then the maximum of %I64u",
             TotalLength, m_DirectoryConfig->m_MaxFileSize  );
        throw ServerException( BG_E_TOO_LARGE );
        }

    if ( ReturnVal != 3 )
        {
        Log( LOG_ERROR, "Range has %d elements instead of the expected number of 3", ReturnVal );
        throw ServerException( E_INVALIDARG );
        }

    if ( ( RangeStart == RangeEnd + 1 ) &&
         ( 0 == m_ContentLength ) && 
         ( RangeStart == TotalLength ) )
        {

        // Continue after a failed notification
        RangeStart  = TotalLength;
        RangeLength = 0;
        return;

        }

    if ( RangeEnd < RangeStart )
        {
        Log( LOG_ERROR, "Range start is greater then the range length, End %I64u, Start %I64u",
             RangeEnd, RangeStart );
        throw ServerException( E_INVALIDARG );
        }

    RangeLength = RangeEnd - RangeStart + 1;

    if ( m_ContentLength != RangeLength )
        {
        Log( LOG_ERROR, "The content length is different from the range length. Content %I64u, Range %I64u",
             m_ContentLength, RangeLength );
        throw ServerException( E_INVALIDARG );
        }

}

void
ServerRequest::ScheduleAsyncOperation(
    DWORD   OperationID,
    LPVOID  Buffer,
    LPDWORD Size,
    LPDWORD DataType )
{

    // start an async operation and handle all the flags and recounting required.

    BOOL Result;

    AddRef();

    Result =
        (*m_ExtensionControlBlock->ServerSupportFunction)(
            m_ExtensionControlBlock->ConnID,
            OperationID,
            Buffer,
            Size,
            DataType );

    if ( !Result )
        {
        HRESULT Hr = HRESULT_FROM_WIN32( GetLastError() );

        Log( LOG_ERROR, "Error starting async operation, error %x", Hr );

        // Operation was never scheduled, remove the callbacks refcount
        Release();
        throw ServerException( Hr );
        }

    m_IsPending = true;

}

// dispatch routines
void
ServerRequest::CreateSession()
{
   // Handles the Create-Session command from the client.
   // Create a new session and all the directories required to 
   // support that session.

   ValidateProtocol();
   m_SessionId       = BITSCreateGuid();
   m_SessionIdString = BITSStringFromGuid( m_SessionId );
   CrackPhysicalPath();

   BITSCreateDirectory( (LPCTSTR)m_ConnectionsDirectory );

   try
   {

       // Need to create directories in a loop since another thread could 
       // delete the connections directory just as we are creating the connection
       // directory.

       while( 1 )
           {

               try
               {
                   BITSCreateDirectory( m_ConnectionDirectory );
                   break;
               }
               catch( ServerException e )
               {

                   if ( e.GetCode() != HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND ) )
                       throw;

                   // Try to recreate the connections directory
                   BITSCreateDirectory( (LPCTSTR)m_ConnectionsDirectory );

               }

           }

       OpenCacheFile( );
   }
   catch( ServerException e )
   {
       RemoveDirectory( m_ConnectionDirectory );
       RemoveDirectory( m_ConnectionsDirectory );
       throw;
   }

   if ( m_DirectoryConfig->m_HostId.Size() )
       {
       
       if ( m_DirectoryConfig->m_HostIdFallbackTimeout != MD_BITS_NO_TIMEOUT )
           {

           SendResponse(
               "Pragma: no-cache\r\n"
               "BITS-Packet-Type: Ack\r\n"
               "BITS-Protocol: %s\r\n"
               "BITS-Session-Id: %s\r\n"
               "BITS-Host-Id: %s\r\n"
               "BITS-Host-Id-Fallback-Timeout: %u\r\n"
               "Content-Length: 0\r\n"
               "Accept-encoding: identity\r\n"
               "\r\n",
               200,
               UPLOAD_PROTOCOL_STRING_V1,
               (const char*)m_SessionIdString, // SessionId
               (const char*)m_DirectoryConfig->m_HostId,
               m_DirectoryConfig->m_HostIdFallbackTimeout
               );

           }
       else
           {

           SendResponse(
               "Pragma: no-cache\r\n"
               "BITS-Packet-Type: Ack\r\n"
               "BITS-Protocol: %s\r\n"
               "BITS-Session-Id: %s\r\n"
               "BITS-Host-Id: %s\r\n"
               "Content-Length: 0\r\n"
               "Accept-encoding: identity\r\n"
               "\r\n",
               200,
               UPLOAD_PROTOCOL_STRING_V1,
               (const char*)m_SessionIdString, // SessionId
               (const char*)m_DirectoryConfig->m_HostId
               );

           }

       }
   else
       {

       SendResponse(
           "Pragma: no-cache\r\n" 
           "BITS-Packet-Type: Ack\r\n"
           "BITS-Protocol: %s\r\n"
           "BITS-Session-Id: %s\r\n"
           "Content-Length: 0\r\n"
           "Accept-encoding: identity\r\n"
           "\r\n",
           200,
           UPLOAD_PROTOCOL_STRING_V1,
           (const char*)m_SessionIdString // SessionId
           );

       }


   LogNewSession( m_SessionId );

}

void
ServerRequest::AddFragment()
{

   // Handles the fragment command from the client.   Opens the cache file
   // and resumes the upload.

   CrackSessionId();
   CrackPhysicalPath();

   OpenCacheFile( );

   UINT64 CacheFileSize = BITSGetFileSize( m_CacheFile );

   UINT64 RangeStart, RangeLength, TotalLength;

   CrackContentRange( RangeStart, RangeLength, TotalLength );

   if ( CacheFileSize < RangeStart )
       {

       // Can't recover from this error on the server since we have a gap.
       // Need to get the client to backup and start again.

       Log( LOG_INFO, "Client and server are hopelessly out of sync, sending the 416 error code" );

       SendResponse(
           "Pragma: no-cache\r\n"
           "BITS-Packet-Type: Ack\r\n"
           "BITS-Received-Content-Range: %I64u\r\n"
           "\r\n",
           416,
           CacheFileSize );

       return;

       }

   if ( RangeStart + RangeLength > TotalLength )
       {
       Log( LOG_ERROR, "Range extends past end of file. Start %I64u, Length %I64u, Total %I64u",
            RangeStart, RangeLength, TotalLength );

       throw ServerException( E_INVALIDARG );
       }

   BITSSetFilePointer( m_CacheFile, 0, FILE_END );

   // Some thought cases for these formulas.
   // 1. RangeLength = 0
   //    BytesToDrain will be 0 and BytesToWrite will be 0
   // 2. RangeStart = CacheFileSize ( most common case )
   //    BytesToDrain will be 0, and BytesToWrite will be BytesToDrain
   // 3. RangeStart < CacheFileSize
   //    BytesToDrain will be nonzero, and BytesToWrite will be the remainder.


   UINT64 BytesToDrain  = min( (CacheFileSize - RangeStart), RangeLength );
   UINT64 BytesToWrite  = RangeLength - BytesToDrain;
   UINT64 WriteOffset   = CacheFileSize;

   // Start the async reader

   m_AsyncReader =
       new AsyncReader(
           this,
           BytesToDrain,
           BytesToWrite,    // bytes to write
           WriteOffset,    // write offset
           RangeStart + RangeLength == TotalLength, // if last BLOCK
           m_CacheFile,
           (char*)m_ExtensionControlBlock->lpbData,
           m_ExtensionControlBlock->cbAvailable );

}

// async IO handling

void
ServerRequest::CompleteIO( AsyncReader *Reader, UINT64 TotalBytesRead )
{

    //
    // Called by the AsyncReader when the request finished successfully.
    //

    Log( LOG_INFO, "Async IO operation complete, finishing" );

    try
    {
        if ( TotalBytesRead > m_BytesToDrain )
            m_BytesToDrain = 0; // shouldn't happen, but just in case
        else
            m_BytesToDrain -= TotalBytesRead;

        UINT64 CacheFileSize = BITSGetFileSize( m_CacheFile );

        ASSERT( Reader->GetWriteOffset() == CacheFileSize );

        if ( Reader->IsLastBlock() &&
             BITS_NOTIFICATION_TYPE_NONE != m_DirectoryConfig->m_NotificationType )
            {
            CallServerNotification( CacheFileSize );
            }
        else
            {            
            // No server notification to make

            SendResponse(
                "Pragma: no-cache\r\n"
                "BITS-Packet-Type: Ack\r\n"
                "Content-Length: 0\r\n"
                "BITS-Received-Content-Range: %I64u\r\n"
                "\r\n",
                200,
                CacheFileSize );

            }

        if ( Reader->IsLastBlock() && TotalBytesRead )
            LogUploadComplete( m_SessionId, CacheFileSize );


    }
    catch( ServerException Error )
    {
         SendResponse( Error );
    }

}

void
ServerRequest::HandleIOError( AsyncReader *Reader, ServerException Error, UINT64 TotalBytesRead )
{

    //
    // Called by AsyncReader when a fatal error occures in processing the request
    //

    Log( LOG_ERROR, "An error occured while handling the async IO" );

    if ( TotalBytesRead > m_BytesToDrain )
        m_BytesToDrain = 0; // shouldn't happen, but just in case
    else
        m_BytesToDrain -= TotalBytesRead;

    SendResponse( Error );
}

void
ServerRequest::CallServerNotification( UINT64 CacheFileSize )
{
    
    // Handles notifications and all the exciting pieces to it.


    HINTERNET hInternet = NULL;
    HINTERNET hConnect = NULL;
    HINTERNET hRequest = NULL;
    HANDLE hResponseFile = INVALID_HANDLE_VALUE;

    Log( LOG_INFO, "Calling backend notification, type %u",
         m_DirectoryConfig->m_NotificationType );

    try
    {

        if ( BITS_NOTIFICATION_TYPE_POST_BYVAL == m_DirectoryConfig->m_NotificationType )
            {

            // only create the response file if this is a byval notification

            hResponseFile =
                CreateFile(
                    m_ResponseFileDirectoryAndFile,
                    GENERIC_READ | GENERIC_WRITE,
                    0,
                    NULL,
                    CREATE_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL );

            if ( INVALID_HANDLE_VALUE == hResponseFile )
                {
                Log( LOG_ERROR, "Unable to create the response file %s, error %x",
                     (const char*)m_ResponseFileDirectoryAndFile,
                     HRESULT_FROM_WIN32( GetLastError() ) );
                throw ServerException( HRESULT_FROM_WIN32( GetLastError() ) );
                }

            }

       Log( LOG_INFO, "Connecting to backend for notification" );

#if defined(USE_WININET)
       //
       // Flush cached credentials
       //

       if (!InternetSetOption(0, INTERNET_OPTION_END_BROWSER_SESSION, NULL, 0 ))
           throw ServerException( HRESULT_FROM_WIN32( GetLastError() ) );
#endif

        hInternet =
            InternetOpen(
                HTTP_STRING( "BITS Server Extensions" ),
                INTERNET_OPEN_TYPE_PRECONFIG,
                NULL,
                NULL,
                0 );

        if ( !hInternet )
            {
            Log( LOG_ERROR, "Internet open failed, error %x", HRESULT_FROM_WIN32( GetLastError() ) );
            throw ServerException( HRESULT_FROM_WIN32( GetLastError() ), 0, 0x7 );
            }

        StringHandle RequestURL             = GetRequestURL();
        StringHandleW NotificationURL;       
         
        if ( m_DirectoryConfig->m_NotificationURL.Size() != 0 )
            {
            // if the a notification URL was set, then combine that URL with the original URL.
            // Otherwise just use the original URL.  This allows BITS to be used to call
            // many arbitrary ASP pages.

            NotificationURL = StringHandleW( 
                                  BITSUrlCombine( RequestURL, m_DirectoryConfig->m_NotificationURL, 
                                                  URL_ESCAPE_UNSAFE  ) );

            }
        else
            {
            NotificationURL = StringHandleW( RequestURL );
            }

        Log( LOG_INFO, "Request URL:      %s", (const char*)StringHandle( RequestURL ) );
        Log( LOG_INFO, "Notification URL: %s", (const char*)StringHandle( NotificationURL ) );

        //
        // Split the URL into server, path, name, and password components.
        //

        HTTPStackStringHandle HostName;
        HTTPStackStringHandle UrlPath;
        HTTPStackStringHandle UserName;
        HTTPStackStringHandle Password;


        URL_COMPONENTS  UrlComponents;
        ZeroMemory(&UrlComponents, sizeof(UrlComponents));

        UrlComponents.dwStructSize        = sizeof(UrlComponents);
        UrlComponents.lpszHostName        = HostName.AllocBuffer( INTERNET_MAX_URL_LENGTH + 1 );
        UrlComponents.dwHostNameLength    = INTERNET_MAX_URL_LENGTH + 1;
        UrlComponents.lpszUrlPath         = UrlPath.AllocBuffer( INTERNET_MAX_URL_LENGTH + 1 );
        UrlComponents.dwUrlPathLength     = INTERNET_MAX_URL_LENGTH + 1;
        UrlComponents.lpszUserName        = UserName.AllocBuffer( INTERNET_MAX_URL_LENGTH + 1 );
        UrlComponents.dwUserNameLength    = INTERNET_MAX_URL_LENGTH + 1;
        UrlComponents.lpszPassword        = Password.AllocBuffer( INTERNET_MAX_URL_LENGTH + 1 );
        UrlComponents.dwPasswordLength    = INTERNET_MAX_URL_LENGTH + 1;


        if ( !InternetCrackUrl(
              NotificationURL,
              (DWORD)NotificationURL.Size(),
              0,
              &UrlComponents ) )
            {
            Log( LOG_ERROR, "InternetCrackURL failed, error %x", HRESULT_FROM_WIN32( GetLastError() ) );
            throw ServerException( HRESULT_FROM_WIN32( GetLastError() ), 0, 0x7 );
            }

        HostName.SetStringSize();
        UrlPath.SetStringSize();
        UserName.SetStringSize();
        Password.SetStringSize();

        StringHandle QueryString = GetServerVariable( "QUERY_STRING" );

        if ( QueryString.Size() )
            {
            UrlPath += HTTPStackStringHandle( StringHandle("?") );
            UrlPath += HTTPStackStringHandle( QueryString );
            }

        if ( BITS_NOTIFICATION_TYPE_POST_BYREF == m_DirectoryConfig->m_NotificationType )
            CloseCacheFile();

        hConnect =
            InternetConnect(
                hInternet,
                HostName,
                UrlComponents.nPort,
                UserName,
                Password,
                INTERNET_SERVICE_HTTP,
                0, 0 );

        if ( !hConnect )
            {
            Log( LOG_ERROR, "InternetConnect failed, error %x", HRESULT_FROM_WIN32( GetLastError() ) );
            throw ServerException( HRESULT_FROM_WIN32( GetLastError() ), 0, 0x7 );
            }


        const HTTP_STRING_TYPE *AcceptTypes[] = { HTTP_STRING( "*/*" ), NULL };

        hRequest =
            HttpOpenRequest(
                hConnect,
                HTTP_STRING( "POST" ),
                UrlPath,
                HTTP_STRING( "HTTP/1.1" ),
                NULL,
                AcceptTypes,

#if defined( USE_WININET )
                INTERNET_FLAG_NO_UI | INTERNET_FLAG_RELOAD,
#else
                INTERNET_FLAG_NO_UI | INTERNET_FLAG_RELOAD | WINHTTP_FLAG_ESCAPE_DISABLE_QUERY,
#endif

                0 );


        if ( !hRequest )
            {
            Log( LOG_ERROR, "HttpOpenRequest failed, error %x", HRESULT_FROM_WIN32( GetLastError() ) );
            throw ServerException( HRESULT_FROM_WIN32( GetLastError() ), 0, 0x7 );
            }

        INTERNET_BUFFERS buf = {0};
        buf.dwStructSize = sizeof( INTERNET_BUFFERS );
        buf.dwBufferTotal = (DWORD)CacheFileSize;

        HTTPStackStringHandle AdditionalHeaders = HTTP_STRING( "BITS-Original-Request-URL: " );
        AdditionalHeaders += HTTPStackStringHandle( RequestURL );
        AdditionalHeaders += HTTP_STRING( "\r\n" );

        if ( BITS_NOTIFICATION_TYPE_POST_BYREF == m_DirectoryConfig->m_NotificationType )
            {

            // Add the path to the request datafile name
            AdditionalHeaders += HTTP_STRING( "BITS-Request-DataFile-Name: " );
            AdditionalHeaders += HTTPStackStringHandle( m_CacheFileDirectoryAndFile );
            AdditionalHeaders += HTTP_STRING( "\r\n" );

            // Add the path to where to place the response datafile name
            AdditionalHeaders += HTTP_STRING( "BITS-Response-DataFile-Name: " );
            AdditionalHeaders += HTTPStackStringHandle( m_ResponseFileDirectoryAndFile );
            AdditionalHeaders += HTTP_STRING( "\r\n" );

            buf.dwBufferTotal = 0;
            }

        if ( !HttpAddRequestHeaders(
                 hRequest,
                 AdditionalHeaders,
                 (DWORD)AdditionalHeaders.Size(),
                 HTTP_ADDREQ_FLAG_ADD | HTTP_ADDREQ_FLAG_REPLACE ) )
            {
            Log( LOG_ERROR, "HttpAddRequestHeaders failed error %x",
                 HRESULT_FROM_WIN32( GetLastError() ) );
            throw ServerException( HRESULT_FROM_WIN32( GetLastError() ), 0, 0x7 );
            }

        if ( buf.dwBufferTotal )
            {

            Log( LOG_INFO, "Sending data..." );

            if ( !HttpSendRequestEx(
                     hRequest,
                     &buf,
                     NULL,
                     HSR_INITIATE,
                     NULL ) )
                {
                Log( LOG_ERROR, "HttpSendRequestEx failed error %x",
                     HRESULT_FROM_WIN32( GetLastError() ) );
                throw ServerException( HRESULT_FROM_WIN32( GetLastError() ), 0, 0x7 );
                }


            ReopenCacheFileAsSync();

            SetFilePointer( m_CacheFile, 0, NULL, FILE_BEGIN );

            DWORD BytesRead;
            DWORD TotalRead = 0;
            do
                {
                BOOL b;

                if  (!(b = ReadFile (m_CacheFile,
                                     m_NotifyBuffer,
                                     sizeof(m_NotifyBuffer),
                                     &BytesRead,
                                     NULL)))
                    {
                    Log( LOG_ERROR, "ReadFile failed, error %x",
                         HRESULT_FROM_WIN32( GetLastError() ) );
                    throw ServerException( HRESULT_FROM_WIN32( GetLastError() ), 0, 0x7 );
                    }

                TotalRead += BytesRead;

                if (BytesRead > 0)
                    {

                    DWORD BytesWritten;
                    DWORD TotalWritten = 0;

                    do
                        {

                        if (!(b = InternetWriteFile( hRequest,
                                                     m_NotifyBuffer + TotalWritten,
                                                     BytesRead - TotalWritten,
                                                     &BytesWritten)))
                            {
                            Log( LOG_ERROR, "InternetWriteFile failed, error %x",
                                 HRESULT_FROM_WIN32( GetLastError() ) );
                            throw ServerException( HRESULT_FROM_WIN32( GetLastError() ), 0, 0x7 );
                            }

                        TotalWritten += BytesWritten;

                        } while( TotalWritten != BytesRead );
                    }
                }
            while ( TotalRead < buf.dwBufferTotal );

            if ( !HttpEndRequest( hRequest, NULL, 0, 0 ) )
                {
                Log( LOG_ERROR, "HttpEndRequest failed, error %x",
                     HRESULT_FROM_WIN32( GetLastError() ) );
                throw ServerException( HRESULT_FROM_WIN32( GetLastError() ), 0, 0x7 );
                }

            }
        else
            {

            if ( !HttpSendRequest(
                    hRequest,
                    NULL,
                    0,
                    NULL,
                    0 ) )
                {
                Log( LOG_ERROR, "HttpSendRequest failed, error %x",
                     HRESULT_FROM_WIN32( GetLastError() ) );
                throw ServerException( HRESULT_FROM_WIN32( GetLastError() ), 0,0x7 );
                }

            }



        //
        // Check for a BITS-Static-Response-URL. If a static response is given,
        // remove the response file and format URL
        //

        bool HasStaticResponse = TestResponseHeader( hRequest, HTTP_STRING( "BITS-Static-Response-URL" ) );

        if ( HasStaticResponse )
            {

            if ( INVALID_HANDLE_VALUE != hResponseFile )
                {
                CloseHandle( hResponseFile );
                hResponseFile = INVALID_HANDLE_VALUE;
                BITSDeleteFile( m_ResponseFileDirectoryAndFile );
                }

            }

        //
        // drain the pipe.
        //

        Log( LOG_INFO, "Processing backend response" );

        DWORD dwStatus;
        DWORD dwLength;

        dwLength = sizeof(dwStatus);
        if (! HttpQueryInfo(hRequest,
                    HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER,
                    (LPVOID)&dwStatus,
                    &dwLength,
                    NULL))
            {
            Log( LOG_ERROR, "HttpQueryInfo failed, error %x",
                 HRESULT_FROM_WIN32( GetLastError() ) );
            throw ServerException( HRESULT_FROM_WIN32( GetLastError() ), 0, 0x7 );
            }


        DWORD BytesRead;
        DWORD BytesWritten;
        do
            {

            if (!InternetReadFile( hRequest,
                                   m_NotifyBuffer,
                                   sizeof( m_NotifyBuffer ),
                                   &BytesRead
                                   ))
                {
                Log( LOG_ERROR, "InternetReadFile failed, error %x",
                     HRESULT_FROM_WIN32( GetLastError() ) );

                throw ServerException( HRESULT_FROM_WIN32( GetLastError() ), 0, 0x7 );
                }

            if ( INVALID_HANDLE_VALUE != hResponseFile )
                {

                if ( !WriteFile(
                        hResponseFile,
                        m_NotifyBuffer,
                        BytesRead,
                        &BytesWritten,
                        NULL ) )
                    {
                    Log( LOG_ERROR, "WriteFile failed, error %x",
                         HRESULT_FROM_WIN32( GetLastError() ) );
                    throw ServerException( HRESULT_FROM_WIN32( GetLastError() ), 0, 0x7 );
                    }

                }

            }
        while ( BytesRead > 0 );


        //
        // Retrieve or compute the reply URL( the default is to use self-relative form).
        //

        StringHandle ReplyURL;

        if ( HasStaticResponse )
            {
            ReplyURL = GetResponseHeader( hRequest, HTTP_STRING( "BITS-Static-Response-URL" ) );
            }
        else
            {

            if ( INVALID_FILE_ATTRIBUTES != GetFileAttributes( m_ResponseFileDirectoryAndFile ) )
                {

                ReplyURL = m_DirectoryConfig->m_ConnectionsDir;
                ReplyURL += "\\";
                ReplyURL += m_SessionIdString;
                ReplyURL += "\\";
                ReplyURL += "responsefile";

                }
            }

        if ( TestResponseHeader( hRequest, HTTP_STRING( "BITS-Copy-File-To-Destination" ) ) )
            {
            BITSRenameFile( m_CacheFileDirectoryAndFile,
                            m_PhysicalPathAndFile );
            }

        InternetCloseHandle( hRequest );
        InternetCloseHandle( hConnect );
        InternetCloseHandle( hInternet );
        hRequest = hInternet = hConnect = NULL;

        if ( INVALID_HANDLE_VALUE != hResponseFile )
            CloseHandle( hResponseFile );

        hResponseFile = INVALID_HANDLE_VALUE;

        if ( ReplyURL.Size() )
            {

            Log( LOG_INFO, "The backend supplied a response url, send client response including URL" );

            if ( 200 != dwStatus )
                {

                SendResponse(
                    "Pragma: no-cache\r\n"
                    "BITS-Packet-Type: Ack\r\n"
                    "Content-Length: 0\r\n"
                    "BITS-Received-Content-Range: %I64u\r\n"
                    "BITS-Reply-URL: %s\r\n"
                    "BITS-Error-Context: 0x7\r\n"
                    "\r\n",
                    dwStatus,
                    CacheFileSize,
                    (const char*)ReplyURL );

                }
            else
                {

                SendResponse(
                    "Pragma: no-cache\r\n"
                    "BITS-Packet-Type: Ack\r\n"
                    "Content-Length: 0\r\n"
                    "BITS-Received-Content-Range: %I64u\r\n"
                    "BITS-Reply-URL: %s\r\n"
                    "\r\n",
                    dwStatus,
                    CacheFileSize,
                    (const char*)ReplyURL );

                }

            }
        else
            {

            Log( LOG_INFO, "The backend didn't supply a response URL, sending simple client response" );

            if ( 200 != dwStatus )
                {

                SendResponse(
                    "Pragma: no-cache\r\n"
                    "BITS-Packet-Type: Ack\r\n"
                    "Content-Length: 0\r\n"
                    "BITS-Received-Content-Range: %I64u\r\n"
                    "BITS-Error-Context: 0x7\r\n"
                    "\r\n",
                    dwStatus,
                    CacheFileSize );

                }
            else
                {

                SendResponse(
                    "Pragma: no-cache\r\n"
                    "BITS-Packet-Type: Ack\r\n"
                    "Content-Length: 0\r\n"
                    "BITS-Received-Content-Range: %I64u\r\n"
                    "\r\n",
                    dwStatus,
                    CacheFileSize );

                }

            }


    }
    catch( ServerException Exception )
    {
        // cleanup

        if ( INVALID_HANDLE_VALUE != hResponseFile )
            {
            CloseHandle( hResponseFile );
            hResponseFile = INVALID_HANDLE_VALUE;
            }

        DeleteFile( m_ResponseFileDirectoryAndFile );


        if ( hRequest )
            InternetCloseHandle( hRequest );

        if ( hConnect )
            InternetCloseHandle( hConnect );

        if ( hInternet )
            InternetCloseHandle( hInternet );

        throw;
    }

}

bool
ServerRequest::TestResponseHeader(
    HINTERNET hRequest,
    const HTTP_STRING_TYPE *Header )
{

    // test for a header in the notification response.   If the header is 
    // found return true, false if not.   Throw an exception on an error.

#if defined( USE_WININET )
    SIZE_T HeaderSize = strlen(Header) + 2;
    WorkStringBufferA WorkStringBufferData( HeaderSize );
    char *HeaderDup = WorkStringBufferData.GetBuffer();
    memcpy( HeaderDup, Header, ( HeaderSize - 1 ) * sizeof( char ) );
#else
    SIZE_T HeaderSize = wcslen(Header) + 2;
    WorkStringBufferW WorkStringBufferData( HeaderSize );
    HTTP_STRING_TYPE *HeaderDup = ( HTTP_STRING_TYPE * )WorkStringBufferData.GetBuffer();
    memcpy( HeaderDup, Header, ( HeaderSize - 1 ) * sizeof( WCHAR ) );
#endif

    DWORD BufferLength = (DWORD)HeaderSize;

    BOOL Result =
        HttpQueryInfo(
            hRequest,
            HTTP_QUERY_CUSTOM,
            HeaderDup,
            &BufferLength,
            NULL );

    if ( Result )
        return true;

    DWORD dwLastError = GetLastError();

    if ( ERROR_INSUFFICIENT_BUFFER == dwLastError )
        return true;

    if ( ERROR_HTTP_HEADER_NOT_FOUND == dwLastError )
        return false;

    Log( LOG_ERROR, "Unable to test response header %s, error %x",
         (const char*) StringHandle( Header ), HRESULT_FROM_WIN32( GetLastError() ) );

    throw ServerException( HRESULT_FROM_WIN32( dwLastError ) );
}

StringHandle
ServerRequest::GetResponseHeader(
    HINTERNET hRequest,
    const HTTP_STRING_TYPE *Header )
{

    // Retrieve a header from a notification response.   If the header is not
    // found or an other error occures, throw an exception.

#if defined( USE_WININET )
    SIZE_T HeaderSize = strlen( Header );
    DWORD BufferLength = (DWORD)( ( HeaderSize + 1024 ) & ~( 1024 - 1 ) );
#else
    SIZE_T HeaderSize = wcslen( Header );
    DWORD BufferLength = (DWORD)( ( HeaderSize + 1024 ) & ~( 1024 - 1 ) );
#endif

    HTTPStackStringHandle RetVal;

    while(1)
        {

        HTTP_STRING_TYPE *Buffer = RetVal.AllocBuffer( BufferLength );

#if defined( USE_WININET )
        memcpy( Buffer, Header, ( HeaderSize + 1 ) * sizeof( char ) );
#else
        memcpy( Buffer, Header, ( HeaderSize + 1 ) * sizeof( WCHAR ) );
#endif

        BOOL Result =
            HttpQueryInfo(
                hRequest,
                HTTP_QUERY_CUSTOM,
                Buffer,
                &BufferLength,
                NULL );

        if ( Result )
            {
            RetVal.SetStringSize();
            return StringHandle( RetVal );
            }

        DWORD dwError = GetLastError();

        if ( ERROR_INSUFFICIENT_BUFFER != dwError )
            {

            Log( LOG_ERROR, "Unable to get response header %s, error %x",
                 ( const char *) StringHandle( Header ), HRESULT_FROM_WIN32( GetLastError() ) );

            throw ServerException( HRESULT_FROM_WIN32( dwError ) );
            }

        RetVal = HTTPStackStringHandle();

        }

}

void
ServerRequest::CloseSession()
{
   // Handles the Close-Session command from the client.  

   CrackSessionId();
   CrackPhysicalPath();

   if ( BITS_NOTIFICATION_TYPE_NONE == m_DirectoryConfig->m_NotificationType )
       {
       BITSRenameFile( m_CacheFileDirectoryAndFile,
                       m_PhysicalPathAndFile );
       }
   else
       {
       BITSDeleteFile( m_CacheFileDirectoryAndFile );
       }

   BITSDeleteFile( m_ResponseFileDirectoryAndFile );

   RemoveDirectory( m_ConnectionDirectory );
   RemoveDirectory( m_ConnectionsDirectory );

   SendResponse(
       "Pragma: no-cache\r\n"
       "BITS-Packet-Type: Ack\r\n"
       "Content-Length: 0\r\n"
       "\r\n" );

   LogSessionClose( m_SessionId );

}

void
ServerRequest::CancelSession()
{
    // Handles the Cancel-Session command from the client.  Deletes
    // all the temporary files, of the current state.

    CrackSessionId();
    CrackPhysicalPath();

    BITSDeleteFile( m_CacheFileDirectoryAndFile );
    BITSDeleteFile( m_ResponseFileDirectoryAndFile );
    RemoveDirectory( m_ConnectionDirectory );
    RemoveDirectory( m_ConnectionsDirectory );

    SendResponse(
        "Pragma: no-cache\r\n"
        "BITS-Packet-Type: Ack\r\n"
        "Content-Length: 0\r\n"
        "\r\n" );

    LogSessionCancel( m_SessionId );

}

void
ServerRequest::Ping()
{
    // Handles the Ping command which is essentually just a no-op.

   SendResponse(
       "Pragma: no-cache\r\n"
       "BITS-Packet-Type: Ack\r\n"
       "Content-Length: 0\r\n"
       "\r\n" );

}

void
ServerRequest::CrackPhysicalPath()
{

    // Given a physical path, compute the destination cache directory and filename.
    // The physical path is a directory, use the original name from the client.

    const CHAR *PathTranslated = m_ExtensionControlBlock->lpszPathTranslated;
    
    // perform some basic tests on the file name

    
    
    StringHandle NewPathTranslated;

    DWORD Attributes =
        GetFileAttributes( m_ExtensionControlBlock->lpszPathTranslated );

    if ( (DWORD)INVALID_FILE_ATTRIBUTES == Attributes )
        {

        if ( GetLastError() != ERROR_FILE_NOT_FOUND )
            {

            Log( LOG_ERROR, "Unable to get the file attributes for %s, error 0x%8.8X",
                 m_ExtensionControlBlock->lpszPathTranslated, HRESULT_FROM_WIN32( GetLastError() ) );
            throw ServerException( HRESULT_FROM_WIN32( GetLastError() ) );

            }

        }
    else
        {

        // file exists, check if its a directory

        if ( FILE_ATTRIBUTE_DIRECTORY & Attributes )
            {
            Log( LOG_ERROR, "Uploading to directories are not supported" );
            throw ServerException( E_INVALIDARG );
            }

        }

    DWORD Result =
        GetFullPathNameA(
            PathTranslated,
            0,
            NULL,
            NULL );

    if ( !Result )
        {
        Log( LOG_ERROR, "Unable to get full path name for %s, error 0x%8.8X",
             m_ExtensionControlBlock->lpszPathTranslated, HRESULT_FROM_WIN32( GetLastError() ) );

        throw ServerException( HRESULT_FROM_WIN32( GetLastError() ) );
        }

    DWORD RequiredBufferSize = Result;

    WorkStringBuffer WorkCrackBuffer( RequiredBufferSize + 1 );
    char *CrackBuffer = WorkCrackBuffer.GetBuffer();
    char *FilePart = NULL;

    Result =
        GetFullPathNameA(
            PathTranslated,
            RequiredBufferSize,
            CrackBuffer,
            &FilePart );

    if ( !Result )
        {
        DWORD Error = GetLastError();
        Log( LOG_ERROR, "Unable to get full path name for %s, error 0x%8.8X",
             m_ExtensionControlBlock->lpszPathTranslated, HRESULT_FROM_WIN32( Error ) );
        throw ServerException( HRESULT_FROM_WIN32( Error ) );

        }

    if ( Result > RequiredBufferSize )
        {
        Log( LOG_ERROR, "Unable to get full path name for %s since the required buffer size changed.",
             m_ExtensionControlBlock->lpszPathTranslated );

        throw ServerException( E_OUTOFMEMORY );
        }

    if ( !FilePart ||
         *FilePart == '\0' ||
         FilePart == CrackBuffer )
        {
        Log( LOG_ERROR, "Request for %s is invalid since it doesn't contain both a file and a directory.",
             m_ExtensionControlBlock->lpszPathTranslated );

        throw ServerException( E_INVALIDARG );
        }

    // validate that the physical path is below the virtual directory root
    {

        SIZE_T VDirPathSize = m_DirectoryConfig->m_PhysicalPath.Size();

        if ( _strnicmp( m_DirectoryConfig->m_PhysicalPath, CrackBuffer, VDirPathSize ) != 0 )
            {
            Log( LOG_ERROR, "Path is not below the virtual directory root, error" );
            throw ServerException( E_INVALIDARG );
            }
    }

    m_PhysicalPathAndFile = CrackBuffer;
    m_PhysicalFile = FilePart;
    *FilePart = '\0';
    m_PhysicalPath = CrackBuffer;

    m_ConnectionsDirectory          = m_PhysicalPath + m_DirectoryConfig->m_ConnectionsDir + "\\";
    m_ConnectionDirectory           = m_ConnectionsDirectory + m_SessionIdString + "\\";
    m_CacheFileDirectoryAndFile     = m_ConnectionDirectory + "requestfile";
    m_ResponseFileDirectoryAndFile  = m_ConnectionDirectory + "responsefile";

}

void
ServerRequest::OpenCacheFile( )
{

    // Open the cache file.

    m_CacheFile =
        CreateFile(
            m_CacheFileDirectoryAndFile,
            GENERIC_READ | GENERIC_WRITE,
            0,
            NULL,
            OPEN_ALWAYS,
            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
            NULL );

    if ( INVALID_HANDLE_VALUE == m_CacheFile )
        {
        Log( LOG_ERROR, "Unable to open cache file %s, error 0x%8.8X",
             (const char*)m_CacheFileDirectoryAndFile,
             HRESULT_FROM_WIN32( GetLastError() ) );

        if (GetLastError() == ERROR_PATH_NOT_FOUND)
            {
            throw ServerException( BG_E_SESSION_NOT_FOUND );
            }

        throw ServerException( HRESULT_FROM_WIN32( GetLastError() ) );
        }

}

void
ServerRequest::ReopenCacheFileAsSync()
{

    // reopen the cache file as async so that it can be spooled synchronously over
    // to the backend.

    CloseCacheFile();

    m_CacheFile =
        CreateFile(
            m_CacheFileDirectoryAndFile,
            GENERIC_READ | GENERIC_WRITE,
            0,
            NULL,
            OPEN_ALWAYS,
            FILE_ATTRIBUTE_NORMAL,
            NULL );

    if ( INVALID_HANDLE_VALUE == m_CacheFile )
        {
        Log( LOG_ERROR, "Unable to reopen cache file %s, error 0x%8.8X",
             (const char*)m_CacheFileDirectoryAndFile,
             HRESULT_FROM_WIN32( GetLastError() ) );

        if (GetLastError() == ERROR_PATH_NOT_FOUND)
            {
            throw ServerException( BG_E_SESSION_NOT_FOUND );
            }

        throw ServerException( HRESULT_FROM_WIN32( GetLastError() ) );
        }
}

void
ServerRequest::CloseCacheFile()
{

    // Close the cache file, if it isn't already closed.

    if ( INVALID_HANDLE_VALUE != m_CacheFile )
        {
        if ( CloseHandle( m_CacheFile ) )
            m_CacheFile = INVALID_HANDLE_VALUE;

        }
}


void
ServerRequest::ForwardComplete(
  LPEXTENSION_CONTROL_BLOCK lpECB,
  PVOID pContext,
  DWORD cbIO,
  DWORD dwError)
{

    // A do nothing callback for forwarding the request.

    ServerRequest *This = (ServerRequest*)pContext;
    This->Release( );
}

void
ServerRequest::ForwardToNextISAPI()
{

    // IIS6 has changed behavior where the limit on * entries are ignored.
    // To work around this problem, it is necessary to send the request back
    // to IIS.


    BOOL Result;

    Result =
        (*m_ExtensionControlBlock->ServerSupportFunction)(
                m_ExtensionControlBlock->ConnID,
                HSE_REQ_IO_COMPLETION,
                (LPVOID)ForwardComplete,
                0,
                (LPDWORD)this );

    if ( !Result )
        {
        Log( LOG_ERROR, "Unable to set callback to ForwardComplete, error %x",
             HRESULT_FROM_WIN32( GetLastError() ) );
        throw ServerException( HRESULT_FROM_WIN32( GetLastError() ) );
        }


    HSE_EXEC_URL_INFO ExecInfo;
    memset( &ExecInfo, 0, sizeof( ExecInfo ) );

#define HSE_EXEC_URL_IGNORE_CURRENT_INTERCEPTOR     0x04
    ExecInfo.dwExecUrlFlags = HSE_EXEC_URL_IGNORE_CURRENT_INTERCEPTOR;

    ScheduleAsyncOperation(
        HSE_REQ_EXEC_URL,
        (LPVOID)&ExecInfo,
        NULL,
        NULL );

    return;

}

void
ServerRequest::GetConfig()
{

    // Looks up the configuration to use for this request.  

    StringHandle InstanceMetaPath   = GetServerVariable( "INSTANCE_META_PATH" );
    StringHandle URL                = GetServerVariable( "URL" );

    m_DirectoryConfig = g_ConfigMan->GetConfig( InstanceMetaPath, URL );

}

void
ServerRequest::DispatchRequest()
{

    //
    // The main do it function,  parse what kind of request the client is sending and
    // dispatch it to the appropiate handler routines. 
    //

    // This critical section is needed because IIS callbacks can happen on any time.
    // The lock is needed to prevent a callback from happening while the dispatch
    // routine is still running.

    CriticalSectionLock CSLock( &m_cs );

    try
    {

        if ( _stricmp( m_ExtensionControlBlock->lpszMethod, BITS_COMMAND_VERBA ) != 0 )
            {
            Log( LOG_CALLBEGIN, "Connection %p, Packet-Type: %s, Method: %s, Path %s",
                                m_ExtensionControlBlock->ConnID,
                                (const char*)"UNKNOWN",
                                m_ExtensionControlBlock->lpszMethod,
                                m_ExtensionControlBlock->lpszPathTranslated );

            ForwardToNextISAPI();
            return;
            }

        m_PacketType            = GetServerVariable( "HTTP_BITS-PACKET-TYPE" );

        Log( LOG_CALLBEGIN, "Connection %p, Packet-Type: %s, Method: %s, Path %s",
                            m_ExtensionControlBlock->ConnID,
                            (const char*)m_PacketType,
                            m_ExtensionControlBlock->lpszMethod,
                            m_ExtensionControlBlock->lpszPathTranslated );

        GetConfig();

        if ( !m_DirectoryConfig->m_UploadEnabled )
            {
            Log( LOG_ERROR, "BITS uploads are not enabled" );
            throw ServerException( E_ACCESSDENIED, 501 );
            }

        if ( m_DirectoryConfig->m_ExecutePermissions & ( MD_ACCESS_EXECUTE | MD_ACCESS_SCRIPT ) )
            {
            Log( LOG_ERROR, "BITS uploads are disable because execute or script access is enabled" );
            LogExecuteEnabled();
            throw ServerException( E_ACCESSDENIED, 403 );
            }

        StringHandle ContentLength = GetServerVariable( "HTTP_Content-Length" );
        if ( 1 != sscanf( (const char*)ContentLength, "%I64u", &m_ContentLength ) )
            {
            Log( LOG_ERROR, "The content length is broken" );
            throw ServerException( E_INVALIDARG );
            }


        if ( m_ContentLength < m_ExtensionControlBlock->cbAvailable )
            throw ServerException( E_INVALIDARG );

        m_BytesToDrain = m_ContentLength - m_ExtensionControlBlock->cbAvailable;


        //
        // Dispatch to the correct method
        //
        // Create-session
        // fragment
        // Get-Reply-Url
        // Close-Session
        // Cancel-Session
        // Ping ( Is server alive )

        // keep this list ordered by frequency

        if ( _stricmp( m_PacketType, PACKET_TYPE_FRAGMENT ) == 0 )
            AddFragment();
        else if ( _stricmp( m_PacketType, PACKET_TYPE_PING ) == 0 )
            Ping();
        else if ( _stricmp( m_PacketType, PACKET_TYPE_CREATE_SESSION ) == 0 )
            CreateSession();
        else if ( _stricmp( m_PacketType, PACKET_TYPE_CLOSE_SESSION ) == 0 )
            CloseSession();
        else if ( _stricmp( m_PacketType, PACKET_TYPE_CANCEL_SESSION ) == 0 )
            CancelSession();
        else
            {

            Log( LOG_ERROR, "Received unknown BITS packet type %s",
                 (const char*)m_PacketType );

            throw ServerException( E_INVALIDARG );

            }


    }

    catch( ServerException Exception )
    {
         SendResponse( Exception );
    }

}

//
// IIS Logger functions
//

void IISLogger::LogString( const char *String, int Size )
{
   DWORD StringSize = Size + 1;

   (*m_ExtensionControlBlock->ServerSupportFunction)
   (
       m_ExtensionControlBlock->ConnID,
       HSE_APPEND_LOG_PARAMETER,
       (LPVOID)String,
       &StringSize,
       NULL
   );

}

void IISLogger::LogError( ServerException Error )
{

   char OutputStr[ 255 ];

   StringCbPrintfA( 
        OutputStr,
        sizeof( OutputStr ),
        "(bits_error:,%u,0x%8.8X)", 
        Error.GetHttpCode(),
        Error.GetCode() );

   LogString( OutputStr, strlen( OutputStr ) );

}

void IISLogger::LogError( const GUID & SessionID, ServerException Error )
{

   WCHAR GuidStr[ 50 ];
   char OutputStr[ 255 ];

   StringFromGUID2( SessionID, GuidStr, 50 );

   StringCchPrintfA( 
        OutputStr,
        sizeof( OutputStr ),
        "(bits_error:%S,%u,0x%8.8X)",
        GuidStr,
        Error.GetHttpCode(),
        Error.GetCode() );

   LogString( OutputStr, strlen( OutputStr ) );

}

void IISLogger::LogNewSession( const GUID & SessionID )
{

    WCHAR GuidStr[ 50 ];
    char OutputStr[ 255 ];

    StringFromGUID2( SessionID, GuidStr, 50 );
    StringCbPrintfA( 
        OutputStr, 
        sizeof( OutputStr ),
        "(bits_new_session:%S)", 
        GuidStr );

    LogString( OutputStr, strlen( OutputStr ) );

}

void IISLogger::LogUploadComplete( const GUID & SessionID, UINT64 FileSize )
{

    WCHAR GuidStr[ 50 ];
    char OutputStr[ 255 ];

    StringFromGUID2( SessionID, GuidStr, 50 );

    StringCbPrintfA( 
        OutputStr, 
        sizeof( OutputStr ),
        "(bits_upload_complete:%S,%I64u)", 
        GuidStr, 
        FileSize );
    LogString( OutputStr, strlen( OutputStr ) );

}

void IISLogger::LogSessionClose( const GUID & SessionID )
{

    WCHAR GuidStr[ 50 ];
    char OutputStr[ 255 ];

    StringFromGUID2( SessionID, GuidStr, 50 );

    StringCbPrintfA( 
        OutputStr, 
        sizeof( OutputStr ),
        "(bits_close_session:%S)",
        GuidStr );
    LogString( OutputStr, strlen( OutputStr ) );

}

void IISLogger::LogSessionCancel( const GUID & SessionID )
{
    WCHAR GuidStr[ 50 ];
    char OutputStr[ 255 ];

    StringFromGUID2( SessionID, GuidStr, 50 );
    StringCbPrintfA( 
        OutputStr, 
        sizeof( OutputStr ),
        "(bits_cancel_session:%S)", 
        GuidStr );
    LogString( OutputStr, strlen( OutputStr ) );
}

void IISLogger::LogExecuteEnabled()
{
    char OutputStr[ 255 ];

    StringCchPrintfA( 
        OutputStr, 
        sizeof( OutputStr ),
        "(bits_execute_enabled)" );

    LogString( OutputStr, strlen( OutputStr ) );
}

ServerRequest *g_LastRequest = NULL;

//
// AsyncReader functions
//

AsyncReader::AsyncReader(
    ServerRequest *Request,
    UINT64 BytesToDrain,
    UINT64 BytesToWrite,
    UINT64 WriteOffset,
    bool   IsLastBlock,
    HANDLE WriteHandle,
    char *PrereadBuffer,
    DWORD PrereadSize ) :
m_Request( Request ),
m_BytesToDrain( BytesToDrain ),
m_BytesToWrite( BytesToWrite ),
m_WriteOffset( WriteOffset ),
m_ReadOffset( WriteOffset ),
m_IsLastBlock( IsLastBlock ),
m_WriteHandle( WriteHandle ),
m_BytesToRead( BytesToWrite ),
m_PrereadBuffer( PrereadBuffer ),
m_PrereadSize( PrereadSize ),
m_OperationsPending( 0 ),
m_ReadBuffer( 0 ),
m_WriteBuffer( 0 ),
m_BuffersToWrite( 0 ),
m_Error( S_OK ),
m_WritePending( false ),
m_ReadPending( false ),
m_TotalBytesRead( 0 ),
m_ThreadToken( NULL ),
m_ErrorValid( false )
{

#if defined CLEARASYNCBUFFERS

    for ( int i = 0; i < NUMBER_OF_IO_BUFFERS; i++ )
        {
        memset( m_IOBuffers + i, i, sizeof( *m_IOBuffers ) );
        }

#endif

    if ( !OpenThreadToken( GetCurrentThread(), TOKEN_ALL_ACCESS, TRUE, &m_ThreadToken ) )
        {
        Log( LOG_ERROR, "Unable to retrieve the current thread token, error %x",
             HRESULT_FROM_WIN32( GetLastError() ) );
        throw ServerException( HRESULT_FROM_WIN32( GetLastError() ) );
        }

    if ( m_BytesToDrain && m_PrereadSize )
        {
        
        Log( LOG_INFO, "Have both a Preread and bytes to drain, deal with it." );
        Log( LOG_INFO, "BytesToDrain: %I64u, PrereadSize: %u", m_BytesToDrain, m_PrereadSize );

        DWORD DrainBytesInPreread = (DWORD)min( m_BytesToDrain, PrereadSize );
        m_PrereadBuffer += DrainBytesInPreread;
        m_PrereadSize   -= DrainBytesInPreread;
        m_BytesToDrain  -= DrainBytesInPreread;

        Log( LOG_INFO, "Bytes to drain from preread, %u", DrainBytesInPreread );

        }

    ASSERT( !( m_BytesToDrain && m_PrereadSize ) );
    m_BytesToRead = m_BytesToRead + m_BytesToDrain - m_PrereadSize;
    m_ReadOffset  = m_ReadOffset - m_BytesToDrain + m_PrereadSize;

    if ( m_BytesToRead )
        {

        // Setup the read completion callback

        BOOL Result =
            (*m_Request->m_ExtensionControlBlock->ServerSupportFunction)(
                    m_Request->m_ExtensionControlBlock->ConnID,
                    HSE_REQ_IO_COMPLETION,
                    (LPVOID)ReadCompleteWraper,
                    0,
                    (LPDWORD)this );

        if ( !Result )
            {
            Log( LOG_ERROR, "Unable to set callback to ReadCompleteWraper, error %x",
                 HRESULT_FROM_WIN32( GetLastError() ) );
            throw ServerException( HRESULT_FROM_WIN32( GetLastError() ) );
            }

        }

    if ( INVALID_HANDLE_VALUE != m_WriteHandle )
        {

        BOOL Result =
            BindIoCompletionCallback(
                m_WriteHandle,                                          // handle to file
                (LPOVERLAPPED_COMPLETION_ROUTINE)WriteCompleteWraper,   // callback
                0                                                       // reserved
                );

        if ( !Result )
            {
            Log( LOG_ERROR, "Unable to set write completion routing, error %x",
                 HRESULT_FROM_WIN32( GetLastError() ) );
            throw ServerException( HRESULT_FROM_WIN32( GetLastError() ) );
            }

        }
        
    // Queue the IO to a thread pool work item.

    BOOL bResult =
        QueueUserWorkItem( StartupIOWraper, this, WT_EXECUTEDEFAULT );

    if ( !bResult )
        {
        Log( LOG_ERROR, "QueueUserWorkItem failed, error %x",
             HRESULT_FROM_WIN32( GetLastError() ) );
        throw ServerException( 500, HRESULT_FROM_WIN32( GetLastError() ) );
        }

    m_OperationsPending++;
    Request->m_IsPending = true;
    Request->AddRef();

}

AsyncReader::~AsyncReader()
{
    if ( m_ThreadToken )
        CloseHandle( m_ThreadToken );
}

void
AsyncReader::HandleError( ServerException Error )
{
    m_ErrorValid    = true;
    m_Error         = Error;

    if ( m_OperationsPending )
        return; // Continue to wait for operations to exit.

    m_Request->HandleIOError( this, Error, m_TotalBytesRead );
    return; 
}

void
AsyncReader::CompleteIO()
{
    m_Request->CompleteIO( this, m_TotalBytesRead );
    return; 
}

void
AsyncReader::StartReadRequest()
{
    // start a new IIS read request
    DWORD BytesToRead;
    IOBuffer *Buffer = m_IOBuffers + m_ReadBuffer;

    if ( m_BytesToDrain )
        {
        Buffer->m_BufferWriteOffset = 0;
        Buffer->m_BufferUsed        = 0;
        BytesToRead = (DWORD)min( m_BytesToDrain, sizeof( Buffer->m_Buffer ) );
        }
    else
        {
        Buffer->m_BufferWriteOffset = m_ReadOffset;
        Buffer->m_BufferUsed = 0;
        BytesToRead = (DWORD)min( m_BytesToRead, sizeof( Buffer->m_Buffer ) );
        }


    Log( LOG_INFO, "Start Async Read, Connection %p, Buffer %u, Offset %I64u, Length %u",
         m_Request->m_ExtensionControlBlock->ConnID,
         m_ReadBuffer,
         m_ReadOffset,
         BytesToRead );
    
    DWORD Flags = HSE_IO_ASYNC;
    BOOL Result =
        (*m_Request->m_ExtensionControlBlock->ServerSupportFunction)
        (
            m_Request->m_ExtensionControlBlock->ConnID,
            HSE_REQ_ASYNC_READ_CLIENT,
            Buffer->m_Buffer,
            &BytesToRead,
            &Flags
        );

    if ( !Result )
        {
        DWORD Error = GetLastError();
        Log( LOG_ERROR, "HSE_REQ_ASYNC_READ_CLIENT failed, error 0x%8.8", Error );
        throw ServerException( HRESULT_FROM_WIN32( Error ) );
        }

    m_OperationsPending++;
    m_ReadPending = true;
    m_Request->AddRef();
}

void
AsyncReader::StartWriteRequest()
{
    // Start a new filesystem write request

    OVERLAPPED *OverLapped = (OVERLAPPED*)this;
    memset( OverLapped, 0, sizeof(*OverLapped) );

    LPCVOID WriteBuffer;
    DWORD BytesToWrite;

    if ( m_PrereadSize )
        {

        // IIS preread data is handled seperatly.  Drain it first.

        WriteBuffer             = m_PrereadBuffer;
        BytesToWrite            = m_PrereadSize;
        }
    else
        {
        IOBuffer *Buffer        = m_IOBuffers + m_WriteBuffer;
        ASSERT( m_WriteOffset == Buffer->m_BufferWriteOffset );
        WriteBuffer             = Buffer->m_Buffer;
        BytesToWrite            = Buffer->m_BufferUsed;
        }

    OverLapped->Offset      = (DWORD)(m_WriteOffset & 0xFFFFFFFF);
    OverLapped->OffsetHigh  = (DWORD)((m_WriteOffset >> 32) & 0xFFFFFFFF);

    Log( LOG_INFO, "Start Async Write, Connection %p, Buffer %u, Offset %I64u, Length %u",
         m_Request->m_ExtensionControlBlock->ConnID,
         m_WriteBuffer,
         m_WriteOffset,
         BytesToWrite );

    BOOL Result =
        WriteFile(
            m_WriteHandle,
            WriteBuffer,
            BytesToWrite,
            NULL,
            OverLapped );

    if ( !Result && GetLastError() != ERROR_IO_PENDING )
        {
        DWORD Error = GetLastError();
        Log( LOG_ERROR, "WriteFileEx failed, error 0x%8.8X", GetLastError() );
        throw ServerException( HRESULT_FROM_WIN32( Error ) );
        }

    m_OperationsPending++;
    m_WritePending = true;
    m_Request->AddRef();
}

void
AsyncReader::StartupIO( )
{

    // Startup the necessary IO operations based on the 
    // buffer states. returns true if the upload operation should continue. 

    try
    {
        if ( m_ErrorValid )
            throw ServerException( m_Error );

        bool ScheduledIO = false;

        if ( m_BytesToDrain )
            {
            StartReadRequest();
            ScheduledIO = true;
            }
        else
            {

            if ( !m_BytesToWrite && !m_BytesToDrain )
                return CompleteIO();

            if ( !m_WritePending )
                {
                if ( m_PrereadSize )
                    {
                    StartWriteRequest();
                    ScheduledIO = true;
                    }
                else if ( m_BuffersToWrite )
                    {
                    StartWriteRequest();
                    ScheduledIO = true;
                    }
                }

            if ( !m_ReadPending && m_BytesToRead && ( NUMBER_OF_IO_BUFFERS - m_BuffersToWrite ) )
                {
                StartReadRequest();
                ScheduledIO = true;
                }

            }

        if ( !ScheduledIO )
            Log( LOG_INFO, "No IO scheduled" );
    }
    catch( ServerException Error )
    {
        HandleError( Error );
    }

    return; 

}

void
AsyncReader::WriteComplete( DWORD dwError, DWORD BytesWritten )
{
    // Called when a write is completed.   Determine the next buffer to use and startup the correct IO operations.
    // returns true is more operations are necessary.

    try
    {
        Log( LOG_INFO, "Complete Async Write, Connection %p, Buffer %u, Offset %I64u, Length %u, Error %u",
             m_Request->m_ExtensionControlBlock->ConnID,
             m_WriteBuffer,
             m_WriteOffset,
             BytesWritten,
             dwError );

        if ( m_ErrorValid )
            throw ServerException( m_Error );

        m_WritePending = false;

        if ( dwError )
            throw ServerException( HRESULT_FROM_WIN32( dwError ) );

        m_BytesToWrite -= BytesWritten;

        if ( m_PrereadSize )
            {
            m_PrereadSize -= BytesWritten;
            m_PrereadBuffer += BytesWritten;
            m_WriteOffset += BytesWritten;
            }
        else
            {
            IOBuffer *Buffer        = m_IOBuffers + m_WriteBuffer;
            ASSERT( BytesWritten == Buffer->m_BufferUsed );
            m_WriteOffset += Buffer->m_BufferUsed;
            m_BuffersToWrite--;

#if defined CLEARASYNCBUFFERS
            memset( Buffer, m_WriteBuffer, sizeof(*Buffer) );
#endif
            m_WriteBuffer = (m_WriteBuffer + 1 ) % NUMBER_OF_IO_BUFFERS;

            }

        return StartupIO();
    }
    catch( ServerException Error )
    {
        Log( LOG_ERROR, "Error in write complete" );
        HandleError( Error );
    }

}

void
AsyncReader::ReadComplete( DWORD dwError, DWORD BytesRead )
{
    // Called when a read operation is complete. determines if more operations should start or to 
    // complete the operation.
    // returns true if more operations are operations are needed to complete the upload

    try
    {

        Log( LOG_INFO, "Complete Async Read, Connection %p, Buffer %u, Offset %I64u, Length %u, Error %u",
             m_Request->m_ExtensionControlBlock->ConnID,
             m_ReadBuffer,
             m_ReadOffset,
             BytesRead,
             dwError );

        m_TotalBytesRead += BytesRead;

        if ( m_ErrorValid )
            throw ServerException( m_Error );

        m_ReadPending = false;

        if ( dwError )
            throw ServerException( HRESULT_FROM_WIN32( dwError ) );

        IOBuffer *Buffer = m_IOBuffers + m_ReadBuffer;
        Buffer->m_BufferUsed = BytesRead;

        m_BytesToRead   -= BytesRead;
        m_ReadOffset    += BytesRead;

        bool ScheduledIO = false;

        if ( m_BytesToDrain )
            m_BytesToDrain -= BytesRead;
        else
            {
            m_BuffersToWrite++;
            m_ReadBuffer = (m_ReadBuffer + 1 ) % NUMBER_OF_IO_BUFFERS;
            }

        StartupIO(); // Continue IO

    }
    catch( ServerException Error )
    {
        Log( LOG_ERROR, "Error in read complete" );

        HandleError( Error );
    }
}

DWORD
AsyncReader::StartupIOWraper( LPVOID Context )
{
    AsyncReader *Reader = (AsyncReader*)Context;
    
    {
        CriticalSectionLock CSLock( &Reader->m_Request->m_cs );
        Reader->m_OperationsPending--;

        // Thread pool threads should start and end with no token

        BITSSetCurrentThreadToken( Reader->m_ThreadToken );
        Reader->StartupIO();
    }
    Reader->m_Request->Release();

    // revert to previous impersonation.

    BITSSetCurrentThreadToken( NULL );

    return 0;
}

void CALLBACK
AsyncReader::WriteCompleteWraper(
    DWORD dwErrorCode,
    DWORD dwNumberOfBytesTransfered,
    LPOVERLAPPED lpOverlapped )
{

    // Wrapper around write completions

    Log( LOG_INFO, "WriteCompleteWraper begin" );
    AsyncReader *Reader = (AsyncReader*)lpOverlapped;
    {
        CriticalSectionLock CSLock( &Reader->m_Request->m_cs );
        Reader->m_OperationsPending--;

        // Thread pool threads should start and end with no token

        BITSSetCurrentThreadToken( Reader->m_ThreadToken );
        Reader->WriteComplete( dwErrorCode, dwNumberOfBytesTransfered );
    }
    Reader->m_Request->Release();

    // revert to previous security
    BITSSetCurrentThreadToken( NULL );
}

void WINAPI
AsyncReader::ReadCompleteWraper(
    LPEXTENSION_CONTROL_BLOCK,
    PVOID pContext,
    DWORD cbIO,
    DWORD dwError )
{

    // wrapper around read completions

    Log( LOG_INFO, "ReadCompleteWraper begin" );
    AsyncReader *Reader = (AsyncReader*)pContext;
    
    {
        CriticalSectionLock CSLock( &Reader->m_Request->m_cs );
        Reader->m_OperationsPending--;

    #if defined( DBG )
        {

        HANDLE ThreadToken = NULL;
        ASSERT( OpenThreadToken( GetCurrentThread(), TOKEN_ALL_ACCESS, TRUE, &ThreadToken ) );

        if ( ThreadToken )
            CloseHandle( ThreadToken );

        }

    #endif

        Reader->ReadComplete( dwError, cbIO );
    }
    
    Reader->m_Request->Release();

}

bool g_ExtensionRunning = false;

class ConfigurationManager *g_ConfigMan = NULL;
class PropertyIDManager *g_PropertyMan = NULL;

BOOL WINAPI
GetExtensionVersion(
    OUT HSE_VERSION_INFO * pVer
    )
{

    // IIS calls this to start everything up.

    HRESULT Hr = S_OK;

    ASSERT( !g_ExtensionRunning );

    pVer->dwExtensionVersion = MAKELONG( HSE_VERSION_MINOR,
                                         HSE_VERSION_MAJOR );

    StringCbCopyA( 
        pVer->lpszExtensionDesc,
        sizeof( pVer->lpszExtensionDesc ),
        "BITS Server Extensions" );

    if ( g_ExtensionRunning )
        return true;

    Hr = LogInit();

    if ( FAILED( Hr ) )
        {
        SetLastError( Hr );
        return false;
        }

    Log( LOG_INFO, "GetExtensionVersion called,  starting init" );

    try
    {

        Log( LOG_INFO, "Initializing Property Manager..." );

        g_PropertyMan = new PropertyIDManager();
        
        HRESULT Hr2 =
            g_PropertyMan->LoadPropertyInfo();

        if ( FAILED(Hr2) )
            throw ServerException( Hr2 );

        Log( LOG_INFO, "Initializing Configuration Manager..." );

        g_ConfigMan = new ConfigurationManager();

    }
    catch( ServerException Exception )
    {

        Log( LOG_ERROR, "Error during initialization, 0x%8.8X", Exception.GetCode() );

        delete g_ConfigMan;
        delete g_PropertyMan;

        LogClose();

        SetLastError( Exception.GetCode() );

        return false;
    }

    g_ExtensionRunning = true;
    Log( LOG_INFO, "Initialization complete!" );
    return true;
}

BOOL WINAPI
TerminateExtension(
    IN DWORD dwFlags
)
{

    //
    // IIS calls this to shut everything down.
    //

    if ( !g_ExtensionRunning )
        return true;

    Log( LOG_INFO, "Shuting down config manager..." );

    delete g_ConfigMan;
    g_ConfigMan = NULL;

    Log( LOG_INFO, "Shuting down property manager..." );

    delete g_PropertyMan;
    g_PropertyMan = NULL;

    Log( LOG_INFO, "Closing logging, goodbye" );

    LogClose();

    g_ExtensionRunning = false;

    return true;

}

DWORD WINAPI
HttpExtensionProc(
    IN EXTENSION_CONTROL_BLOCK * pECB
)
{

    //
    // IIS calls this function for each request that is forwarded by the filter.
    //

    DWORD Result            = HSE_STATUS_ERROR;
    ServerRequest *Request  = NULL;

    try
    {
       g_LastRequest = Request = new ServerRequest( pECB );
       Request->DispatchRequest();
       Result = Request->IsPending() ? HSE_STATUS_PENDING : HSE_STATUS_SUCCESS;
    }
    catch( ServerException Exception )
    {
       IISLogger Logger( pECB );
       Logger.LogError( Exception );
       Result  = HSE_STATUS_ERROR;
    }

    if ( Request )
        Request->Release();

    return Result;

}

HMODULE g_hinst;

BOOL WINAPI
DllMain(
    IN HINSTANCE hinstDll,
    IN DWORD dwReason,
    IN LPVOID lpvContext
)
/*++
Function :  DllMain

Description:

    The initialization function for this DLL.

Arguments:

    hinstDll - Instance handle of the DLL
    dwReason - Reason why NT called this DLL
    lpvContext - Reserved parameter for future use

Return Value:

    Returns TRUE if successfull; otherwise FALSE.

--*/
{
    // Note that appropriate initialization and termination code
    // would be written within the switch statement below.  Because
    // this example is very simple, none is currently needed.

    switch( dwReason ) {
    case DLL_PROCESS_ATTACH:
        g_hinst = hinstDll;
        break;

    case DLL_PROCESS_DETACH:
        break;
    }

    return(TRUE);
}


#include "bitssrvcfgimp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\server\isapi\thunks.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    thunks.cpp

Abstract:

    This file implements the API thunks for the BITS server extensions

--*/

#include "precomp.h"

// API thunks

UINT64 BITSGetFileSize(
    HANDLE Handle )
{

    LARGE_INTEGER FileSize;

    if (!GetFileSizeEx( Handle, &FileSize ) )
        throw ServerException( HRESULT_FROM_WIN32( GetLastError() ) );

    return (UINT64)FileSize.QuadPart;

}

UINT64 BITSSetFilePointer(
    HANDLE Handle,
    INT64 Distance,
    DWORD MoveMethod )
{
    LARGE_INTEGER DistanceToMove;
    DistanceToMove.QuadPart = (LONGLONG)Distance;

    LARGE_INTEGER NewFilePointer;

    BOOL Result =
        SetFilePointerEx(
            Handle,
            DistanceToMove,
            &NewFilePointer,
            MoveMethod );

    if ( !Result )
        {
        throw ServerException( HRESULT_FROM_WIN32( GetLastError() ) );
        }

    return (UINT64)NewFilePointer.QuadPart;

}

DWORD
BITSWriteFile(
    HANDLE Handle,
    LPCVOID Buffer,
    DWORD NumberOfBytesToWrite)
{

    DWORD BytesWritten;

    BOOL Result =
        WriteFile(
            Handle,
            Buffer,
            NumberOfBytesToWrite,
            &BytesWritten,
            NULL );

    if ( !Result )
        throw ServerException( HRESULT_FROM_WIN32( GetLastError() ) );

    return BytesWritten;

}

void
BITSCreateDirectory(
    LPCTSTR DirectoryName
    )
{

    BOOL Result =
        CreateDirectory( DirectoryName, NULL );

    if ( Result )
        return;

    DWORD Status = GetLastError();

    // ignore the error if the directory already exists

    if ( ERROR_ALREADY_EXISTS == Status )
        return;

    throw ServerException( HRESULT_FROM_WIN32( Status ) );
}

void
BITSRenameFile(
    LPCTSTR ExistingName,
    LPCTSTR NewName )
{

    BOOL Result =
        MoveFileEx( ExistingName, NewName, MOVEFILE_REPLACE_EXISTING );

    if ( !Result )
        throw ServerException( HRESULT_FROM_WIN32( GetLastError() ) );

}

void
BITSDeleteFile(
    LPCTSTR FileName )
{

    BOOL Result =
        DeleteFile( FileName );

    if ( Result )
        return;

    DWORD Status = GetLastError();

    if ( ERROR_FILE_NOT_FOUND == Status ||
         ERROR_PATH_NOT_FOUND == Status )
        return;

    throw ServerException( HRESULT_FROM_WIN32( GetLastError() ) );

}

GUID
BITSCreateGuid()
{
    GUID guid;
    HRESULT Hr = CoCreateGuid( &guid );

    if ( FAILED( Hr ) )
        throw ServerException( Hr );

    return guid;
}

GUID
BITSGuidFromString( const char *String )
{

   // 38 chars {c200e360-38c5-11ce-ae62-08002b2b79ef} 

   if ( 38 != strlen( String ) )
       throw ServerException( E_INVALIDARG );

   WCHAR StringW[ 80 ];
   StringCbPrintfW(
       StringW,
       sizeof( StringW ),
       L"%S", 
       String );

   GUID Guid;
   HRESULT Hr =
        IIDFromString( StringW, &Guid );

   if ( FAILED( Hr ) )
       throw ServerException( Hr ); 

   return Guid; 
}

StringHandle
BITSStringFromGuid(
    GUID Guid )
{
    WCHAR StringW[ 80 ];
    StringFromGUID2( Guid, StringW, 80 );

    StringHandle WorkString;
    
    char *WorkBuffer = WorkString.AllocBuffer( 80 );
    
    StringCbPrintfA( 
        WorkBuffer,
        sizeof( StringW ),
        "%S", 
        StringW );

    WorkString.SetStringSize();
    return WorkString;
}

void
BITSSetCurrentThreadToken(
    HANDLE hToken )
{

    if ( !SetThreadToken( NULL, hToken ) )
        {

        for( unsigned int i = 0; i < 100; i ++ )
            {

            Sleep( 10 );

            if ( SetThreadToken( NULL, hToken ) )
                return;

            }
        
        ASSERT( 0 );
        TerminateProcess( NULL, GetLastError() ); 

        }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\server\isapi\utils.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    utils.cpp

Abstract:

    Utilities for the BITS server extensions

--*/

#include "precomp.h"

const char *LookupHTTPStatusCodeText(
    DWORD HttpCode
    )
{
    switch( HttpCode )
        {
        case 100:   return "100 Continue";
        case 101:   return "101 Switching Protocols";
        case 200:   return "200 OK";
        case 201:   return "201 Created";
        case 202:   return "202 Accepted";
        case 203:   return "203 Non-Authoritative Information";
        case 204:   return "204 No Content";
        case 205:   return "205 Reset Content";
        case 206:   return "206 Partial Content";
        case 300:   return "300 Multiple Choices";
        case 301:   return "301 Moved Permanently";
        case 302:   return "302 Found";
        case 303:   return "303 See Other";
        case 304:   return "304 Not Modified";
        case 305:   return "305 Use Proxy";
        case 306:   return "306 (Unused)";
        case 307:   return "307 Temporary Redirect";
        case 400:   return "400 Bad Request";
        case 401:   return "401 Unauthorized";
        case 402:   return "402 Payment Required";
        case 403:   return "403 Forbidden";
        case 404:   return "404 Not Found";
        case 405:   return "405 Method Not Allowed";
        case 406:   return "406 Not Acceptable";
        case 407:   return "407 Proxy Authentication Required";
        case 408:   return "408 Request Timeout";
        case 409:   return "409 Conflict";
        case 410:   return "410 Gone";
        case 411:   return "411 Length Required";
        case 412:   return "412 Precondition Failed";
        case 413:   return "413 Request Entity Too Large";
        case 414:   return "414 Request-URI Too Long";
        case 415:   return "415 Unsupported Media Type";
        case 416:   return "416 Requested Range Not Satisfiable";
        case 417:   return "417 Expectation Failed";
        case 500:   return "500 Internal Server Error";
        case 501:   return "501 Not Implemented";
        case 502:   return "502 Bad Gateway";
        case 503:   return "503 Service Unavailable";
        case 504:   return "504 Gateway Timeout";
        case 505:   return "505 HTTP Version Not Supported";

        default:
            return "";

        }

}

void
ServerException::SendErrorResponse(
    EXTENSION_CONTROL_BLOCK * ExtensionControlBlock
    ) const
{

    char Headers[255];
    StringCbPrintfA( 
        Headers,
        sizeof( Headers ),
        "Pragma: no-cache\r\n"
        "BITS-packet-type: Ack\r\n"
        "BITS-Error: 0x%8.8X\r\n"
        "\r\n", 
        m_Code );

    ExtensionControlBlock->dwHttpStatusCode = m_HttpCode;

    BOOL Result;
    BOOL KeepConnection;

    Result =
        (ExtensionControlBlock->ServerSupportFunction)(
            ExtensionControlBlock->ConnID,
            HSE_REQ_IS_KEEP_CONN,
            &KeepConnection,
            NULL,
            NULL );

    if ( !Result )
        throw ServerException( HRESULT_FROM_WIN32( GetLastError() ) );

    // IIS5.0(Win2k) has a bug where KeepConnect is returned as -1
    // to keep the connection alive.   Apparently, this confuses the
    // HSE_REQ_SEND_RESPONSE_HEADER_EX call.   Bash the value into a real bool.

    KeepConnection = KeepConnection ? 1 : 0;

    HSE_SEND_HEADER_EX_INFO HeaderInfo;
    HeaderInfo.pszStatus = LookupHTTPStatusCodeText( m_HttpCode );
    HeaderInfo.cchStatus = strlen( HeaderInfo.pszStatus );
    HeaderInfo.pszHeader = Headers;
    HeaderInfo.cchHeader = strlen( Headers );
    HeaderInfo.fKeepConn = KeepConnection;

    Result =
        (ExtensionControlBlock->ServerSupportFunction)(
            ExtensionControlBlock->ConnID,
            HSE_REQ_SEND_RESPONSE_HEADER_EX,
            &HeaderInfo,
            NULL,
            NULL );

    if ( !Result )
        throw ServerException( HRESULT_FROM_WIN32( GetLastError() ) );

}

DWORD
ServerException::MapStatus( HRESULT Hr ) const
{
    switch( Hr )
        {
        case E_INVALIDARG:                                  return 400;
        // case HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER ): return 400;
        case HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND ):    return 404;
        case HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND ):    return 404;
        case HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED ):     return 403;
        // case E_ACCESSDENIED:                                return 401;
        default:                                            return 500;
        }
}

void * _cdecl ::operator new( size_t Size )
{
    void *Memory = HeapAlloc( GetProcessHeap(), 0, Size );
    if ( !Memory )
        {
        Log( LOG_ERROR, "Out of memory!\n" ); 
        throw ServerException( ERROR_NOT_ENOUGH_MEMORY );        
        }
    return Memory;
}

void _cdecl ::operator delete( void *Memory )
{
    if ( !Memory )
        return;

    HeapFree( GetProcessHeap(), 0, Memory );
}


StringHandle 
GetMetaDataString(
    IMSAdminBase        *IISAdminBase,
    METADATA_HANDLE     Handle,
    LPCWSTR             Path,
    DWORD               dwIdentifier,
    LPCSTR              DefaultValue )
{
    HRESULT Hr;
    DWORD BufferRequired = 0;

    StringHandleW Data;

    METADATA_RECORD MdRecord;
    MdRecord.dwMDAttributes = METADATA_INHERIT;
    MdRecord.dwMDUserType   = ALL_METADATA;
    MdRecord.dwMDDataType   = STRING_METADATA;
    MdRecord.dwMDIdentifier = dwIdentifier;
    MdRecord.dwMDDataLen    = 0;
    MdRecord.pbMDData       = (PBYTE)NULL;
    MdRecord.dwMDDataTag    = 0;

    Hr =
        IISAdminBase->GetData(
            Handle,
            Path,
            &MdRecord,
            &BufferRequired );

    if ( SUCCEEDED( Hr ) )
        return (StringHandle)Data;

    if ( MD_ERROR_DATA_NOT_FOUND == Hr ||
        HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND ) == Hr )
        return (StringHandle)DefaultValue;

    if ( Hr != HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER ) )
        throw ServerException( Hr );

    MdRecord.pbMDData        = (PBYTE)Data.AllocBuffer( BufferRequired / 2 );
    MdRecord.dwMDDataLen     = BufferRequired;

    Hr =
        IISAdminBase->GetData(
            Handle,
            Path,
            &MdRecord,
            &BufferRequired );

    if ( FAILED( Hr ) )
        throw ServerException( Hr );

    Data.SetStringSize();
    return (StringHandle)Data;

}

DWORD 
GetMetaDataDWORD(
    IMSAdminBase        *IISAdminBase,
    METADATA_HANDLE     Handle,
    LPCWSTR             Path,
    DWORD               dwIdentifier,
    DWORD               DefaultValue )
{

    DWORD BufferRequired;
    DWORD MetabaseValue;

    METADATA_RECORD MdRecord;
    memset( &MdRecord, 0, sizeof( MdRecord ) );

    MdRecord.dwMDAttributes = METADATA_INHERIT;
    MdRecord.dwMDUserType   = ALL_METADATA;
    MdRecord.dwMDDataType   = DWORD_METADATA;
    MdRecord.dwMDIdentifier = dwIdentifier;
    MdRecord.dwMDDataLen    = sizeof(MetabaseValue);
    MdRecord.pbMDData       = (PBYTE)&MetabaseValue;

    HRESULT Hr =
        IISAdminBase->GetData(
            Handle,
            Path,
            &MdRecord,
            &BufferRequired );
    
    if ( MD_ERROR_DATA_NOT_FOUND == Hr ||
         HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND ) == Hr )
        return DefaultValue;

	if ( FAILED( Hr ) )
		throw ServerException( Hr );

    return MetabaseValue;
}

StringHandle
BITSUnicodeToStringHandle( const WCHAR *pStr )
{

    StringHandle RetValString;

    int RetVal =
        WideCharToMultiByte(
            CP_ACP,
            0,
            pStr,
            -1,
            NULL,
            0,
            NULL,
            NULL );

    if ( !RetVal )
        throw ServerException( HRESULT_FROM_WIN32( GetLastError() ) );

    char *pRetBuffer = RetValString.AllocBuffer( RetVal );

    RetVal =
        WideCharToMultiByte(
                CP_ACP,
                0,
                pStr,
                -1,
                pRetBuffer,
                RetVal,
                NULL,
                NULL );

    if ( !RetVal )
        throw ServerException( HRESULT_FROM_WIN32( GetLastError() ) );

    RetValString.SetStringSize();

    return RetValString;
}

StringHandle
BITSUrlCombine(
    const char *Base,
    const char *Relative,
    DWORD dwFlags )
{

    DWORD dwCombined = 0;

    HRESULT Hr =
        UrlCombine(
            Base,
            Relative,
            NULL,
            &dwCombined,
            dwFlags );

    if ( FAILED(Hr) && ( Hr != E_POINTER ) )
        throw ServerException( Hr );

    StringHandle RetVal;
    char *Buffer = RetVal.AllocBuffer( dwCombined + 1 );

    Hr = 
        UrlCombine(
            Base,
            Relative,
            Buffer,
            &dwCombined,
            dwFlags );

    if ( FAILED(Hr) )
        throw ServerException( Hr );

    RetVal.SetStringSize();

    return RetVal;

}

StringHandle
BITSUrlCanonicalize(
    const char *URL,
    DWORD dwFlags )
{

    return 
        BITSUrlCombine(
            "",
            URL,
            dwFlags );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\server\isapi\setup.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    setup.cpp

Abstract:

    Setup code called from regsvr32 

--*/

#include "precomp.h"

BSTR g_PropertyBSTR                     = NULL;
BSTR g_SyntaxBSTR                       = NULL;
BSTR g_UserTypeBSTR                     = NULL;
BSTR g_InheritBSTR                      = NULL;
BSTR g_ClassBSTR                        = NULL;
BSTR g_IsapiRestrictionListBSTR         = NULL;
BSTR g_RestrictionListCustomDescBSTR    = NULL;
BSTR g_FilterLoadOrderBSTR              = NULL;
BSTR g_IIsFilterBSTR                    = NULL;
BSTR g_InProcessIsapiAppsBSTR           = NULL;
BSTR g_bitsserverBSTR                   = NULL;
BSTR g_bitserverBSTR                    = NULL;

HRESULT 
InitializeSetup()
{

    g_PropertyBSTR                  = SysAllocString( L"Property" );
    g_SyntaxBSTR                    = SysAllocString( L"Syntax" );
    g_UserTypeBSTR                  = SysAllocString( L"UserType" );
    g_InheritBSTR                   = SysAllocString( L"Inherit" );
    g_ClassBSTR                     = SysAllocString( L"Class" );
    g_IsapiRestrictionListBSTR      = SysAllocString( L"IsapiRestrictionList" );
    g_RestrictionListCustomDescBSTR = SysAllocString( L"RestrictionListCustomDesc" );
    g_FilterLoadOrderBSTR           = SysAllocString( L"FilterLoadOrder" );
    g_IIsFilterBSTR                 = SysAllocString( L"IIsFilter" );
    g_InProcessIsapiAppsBSTR        = SysAllocString( L"InProcessIsapiApps" );
    g_bitsserverBSTR                = SysAllocString( L"bitsserver" );
    g_bitserverBSTR                 = SysAllocString( L"bitserver" );

    if ( !g_PropertyBSTR || !g_SyntaxBSTR || !g_UserTypeBSTR || 
         !g_InheritBSTR | !g_ClassBSTR || !g_IsapiRestrictionListBSTR || 
         !g_RestrictionListCustomDescBSTR || !g_FilterLoadOrderBSTR || !g_IIsFilterBSTR ||
         !g_InProcessIsapiAppsBSTR || !g_bitsserverBSTR || !g_bitserverBSTR )
        {

        SysFreeString( g_PropertyBSTR );
        SysFreeString( g_SyntaxBSTR );
        SysFreeString( g_UserTypeBSTR );
        SysFreeString( g_InheritBSTR );
        SysFreeString( g_ClassBSTR );
        SysFreeString( g_IsapiRestrictionListBSTR );
        SysFreeString( g_RestrictionListCustomDescBSTR );
        SysFreeString( g_FilterLoadOrderBSTR );
        SysFreeString( g_IIsFilterBSTR );
        SysFreeString( g_InProcessIsapiAppsBSTR );
        SysFreeString( g_bitsserverBSTR );
        SysFreeString( g_bitserverBSTR );

        g_PropertyBSTR = g_SyntaxBSTR = g_UserTypeBSTR = 
            g_InheritBSTR = g_ClassBSTR = g_IsapiRestrictionListBSTR = 
                g_RestrictionListCustomDescBSTR = g_FilterLoadOrderBSTR = g_IIsFilterBSTR = 
                    g_InProcessIsapiAppsBSTR = g_bitsserverBSTR = g_bitserverBSTR = NULL;

        return E_OUTOFMEMORY;

        }

    return S_OK;

}

void
CleanupSetup()
{

    SysFreeString( g_PropertyBSTR );
    SysFreeString( g_SyntaxBSTR );
    SysFreeString( g_UserTypeBSTR );
    SysFreeString( g_InheritBSTR );
    SysFreeString( g_ClassBSTR );
    SysFreeString( g_IsapiRestrictionListBSTR );
    SysFreeString( g_RestrictionListCustomDescBSTR );
    SysFreeString( g_FilterLoadOrderBSTR );
    SysFreeString( g_IIsFilterBSTR );
    SysFreeString( g_InProcessIsapiAppsBSTR );
    SysFreeString( g_bitsserverBSTR );
    SysFreeString( g_bitserverBSTR );

    g_PropertyBSTR = g_SyntaxBSTR = g_UserTypeBSTR = 
        g_InheritBSTR = g_ClassBSTR = g_IsapiRestrictionListBSTR =
            g_RestrictionListCustomDescBSTR = g_FilterLoadOrderBSTR = g_IIsFilterBSTR = 
                g_InProcessIsapiAppsBSTR = g_bitsserverBSTR = NULL;

}

void RemoveFilterHelper(
    WCHAR * Buffer,
    const WCHAR * const ToRemove )
{

    WCHAR *ToReplace;
    SIZE_T FragmentLength = wcslen( ToRemove );

    while( ToReplace = wcsstr( Buffer, ToRemove ) )
        {
        WCHAR *Next = ToReplace + FragmentLength;
        memmove( ToReplace, Next, sizeof(WCHAR) * ( wcslen( Next ) + 1 ) );  
        Buffer = ToReplace;
        }

}

DWORD
BITSGetStartupInfoFilter(
    DWORD Status )
{

    //
    // The following exceptions are documented 
    // to be thrown by GetStartupInfoA
    //

    switch( Status )
        {

        case STATUS_NO_MEMORY:
        case STATUS_INVALID_PARAMETER_2:
        case STATUS_BUFFER_OVERFLOW:
            return EXCEPTION_EXECUTE_HANDLER;

        default:
            return EXCEPTION_CONTINUE_SEARCH;
        
        }

}

HRESULT
BITSGetStartupInfo( 
    LPSTARTUPINFO lpStartupInfo )
{

    __try
    {
        GetStartupInfoA( lpStartupInfo );
    }
    __except( BITSGetStartupInfoFilter( GetExceptionCode() ) )
    {
        return E_OUTOFMEMORY;
    }
    
    return S_OK;

}

HRESULT RestartIIS()
{

    //
    // Restarts IIS by calling "iisreset /restart" at the commandline.
    //

    STARTUPINFO StartupInfo;

    HRESULT Hr = BITSGetStartupInfo( &StartupInfo );

    if ( FAILED( Hr ) )
        return Hr;

    #define IISRESET_EXE        "iisreset.exe"
    #define IISRESET_CMDLINE    "iisreset /RESTART"

    PROCESS_INFORMATION ProcessInfo;
    CHAR    sApplicationPath[MAX_PATH];
    CHAR   *pApplicationName = NULL;
    CHAR    sCmdLine[MAX_PATH];
    DWORD   dwLen = MAX_PATH;
    DWORD   dwCount;

    dwCount = SearchPath(NULL,                // Search Path, NULL is PATH
                         IISRESET_EXE,        // Application
                         NULL,                // Extension (already specified)
                         dwLen,               // Length (char's) of sApplicationPath
                         sApplicationPath,    // Path + Name for application
                         &pApplicationName ); // File part of sApplicationPath

    if (dwCount == 0)
        {
        return HRESULT_FROM_WIN32( GetLastError() );
        }

    if (dwCount > dwLen)
        {
        return HRESULT_FROM_WIN32( ERROR_BUFFER_OVERFLOW );
        }

    StringCbCopyA(sCmdLine, MAX_PATH, IISRESET_CMDLINE);

    BOOL RetVal = CreateProcess(
            sApplicationPath,                          // name of executable module
            sCmdLine,                                  // command line string
            NULL,                                      // SD
            NULL,                                      // SD
            FALSE,                                     // handle inheritance option
            CREATE_NO_WINDOW,                          // creation flags
            NULL,                                      // new environment block
            NULL,                                      // current directory name
            &StartupInfo,                              // startup information
            &ProcessInfo                               // process information
        );

    if ( !RetVal )
        return HRESULT_FROM_WIN32( GetLastError() );

    WaitForSingleObject( ProcessInfo.hProcess, INFINITE );

    DWORD Status;
    GetExitCodeProcess( ProcessInfo.hProcess, &Status );

    CloseHandle( ProcessInfo.hProcess );
    CloseHandle( ProcessInfo.hThread );

    return HRESULT_FROM_WIN32( Status );
}

HRESULT InstallPropertySchema( )
{

    //
    // Installs the ADSI schema with the new metabase properties. 
    //

    HRESULT Hr;
    
    VARIANT var;
    VariantInit( &var );
    
    IADsContainer *MbSchemaContainer = NULL;

    Hr = ADsGetObject( 
             L"IIS://LocalHost/Schema", 
             __uuidof( *MbSchemaContainer), 
             reinterpret_cast<void**>( &MbSchemaContainer ) );

    if ( FAILED( Hr ) )
        return Hr;

    BSTR PropertyNameBSTR   = NULL;
    BSTR PropertyClassBSTR  = NULL;

    IDispatch *Dispatch = NULL;
    IADs *MbProperty = NULL;
    IADsClass *MbClass = NULL;

    for ( SIZE_T i = 0; i < g_NumberOfProperties; i++ )
    {
        PropertyNameBSTR    = SysAllocString( g_Properties[i].PropertyName );
        PropertyClassBSTR   = SysAllocString( g_Properties[i].ClassName );

        Hr = MbSchemaContainer->Create(
            g_PropertyBSTR,
            PropertyNameBSTR,
            &Dispatch );

        if ( Hr == E_ADS_OBJECT_EXISTS )
            continue;

        if ( FAILED( Hr ) )
            goto failed;

        Hr = Dispatch->QueryInterface( __uuidof( *MbProperty ), 
                                       reinterpret_cast<void**>( &MbProperty ) );

        if ( FAILED( Hr ) )
            goto failed;

        Dispatch->Release();
        Dispatch = NULL;

        var.bstrVal = SysAllocString( g_Properties[i].Syntax );
        var.vt = VT_BSTR;

        if ( !var.bstrVal )
            {
            Hr = E_OUTOFMEMORY;
            goto failed;
            }

        Hr = MbProperty->Put( g_SyntaxBSTR, var );

        if ( FAILED(Hr) )
            goto failed;

        VariantClear( &var );

        var.ulVal = g_Properties[i].UserType;
        var.vt = VT_UI4;

        Hr = MbProperty->Put( g_UserTypeBSTR, var );

        if ( FAILED( Hr ) )
            goto failed;

        var.boolVal = true;
        var.vt = VT_BOOL;

        Hr = MbProperty->Put( g_InheritBSTR, var );
        if ( FAILED(Hr) )
            goto failed;

        Hr = MbProperty->SetInfo();

        if ( FAILED(Hr) )
            goto failed;

        VariantClear( &var );
        
        MbProperty->Release();
        MbProperty = NULL;

        Hr = MbSchemaContainer->GetObject( g_ClassBSTR, PropertyClassBSTR, &Dispatch );

        if ( FAILED(Hr) )
            goto failed;

        Hr = Dispatch->QueryInterface( __uuidof( *MbClass ), 
                                       reinterpret_cast<void**>( &MbClass ) );

        if ( FAILED( Hr ) )
            goto failed;

        Dispatch->Release();
        Dispatch = NULL;

        Hr = MbClass->get_OptionalProperties( &var );

        if ( FAILED( Hr ) )
            goto failed;

        SAFEARRAY* Array = var.parray;
        long LBound;
        long UBound;

        Hr = SafeArrayGetLBound( Array, 1, &LBound );
        if ( FAILED( Hr ) )
            goto failed;

        Hr = SafeArrayGetUBound( Array, 1, &UBound );
        if ( FAILED( Hr ) )
            goto failed;

        UBound++; // Add one to the upper bound
        
        SAFEARRAYBOUND SafeBounds;
        SafeBounds.lLbound = LBound;
        SafeBounds.cElements = UBound - LBound + 1;

        Hr = SafeArrayRedim( Array, &SafeBounds );
        if ( FAILED( Hr ) )
            goto failed;

        VARIANT bstrvar;
        VariantInit( &bstrvar );
        bstrvar.vt = VT_BSTR;
        bstrvar.bstrVal = SysAllocString( g_Properties[i].PropertyName );
        
        if ( !bstrvar.bstrVal )
            {
            Hr = E_OUTOFMEMORY;
            goto failed;
            }

        long Dim = (long)UBound;
        Hr = SafeArrayPutElement( Array, &Dim, &bstrvar );
        
        VariantClear( &bstrvar );

        if ( FAILED(Hr) )
            goto failed;

        Hr = MbClass->put_OptionalProperties( var );

        if ( FAILED(Hr) )
            goto failed;

        Hr = MbClass->SetInfo();

        if ( FAILED(Hr) )
            goto failed;

        MbClass->Release();
        MbClass = NULL;

        SysFreeString( PropertyNameBSTR );
        SysFreeString( PropertyClassBSTR );
        PropertyNameBSTR = PropertyClassBSTR = NULL;

    }

    Hr = S_OK;

failed:

    VariantClear( &var );

    if ( Dispatch )
        Dispatch->Release();

    if ( MbProperty )
        MbProperty->Release();

    if ( MbClass )
        MbClass->Release();

    if ( MbSchemaContainer )
        MbSchemaContainer->Release();

    SysFreeString( PropertyNameBSTR );
    SysFreeString( PropertyClassBSTR );
    return Hr;

}

HRESULT RemovePropertySchema( )
{

    // Removes our properties from the metabase schema

    HRESULT Hr;
    
    VARIANT var;
    VariantInit( &var );

    IADsContainer *MbSchemaContainer = NULL;

    Hr = ADsGetObject( 
             L"IIS://LocalHost/Schema", 
             __uuidof( *MbSchemaContainer ), 
             reinterpret_cast<void**>( &MbSchemaContainer ) );

    if ( FAILED( Hr ) )
        return Hr;

    BSTR        PropertyNameBSTR    = NULL;
    BSTR        PropertyClassBSTR   = NULL;
    IDispatch   *Dispatch           = NULL;
    IADsClass   *MbClass            = NULL;
    IADs        *Object             = NULL;

    for ( SIZE_T i = 0; i < g_NumberOfProperties; i++ )
    {

        PropertyNameBSTR    = SysAllocString( g_Properties[i].PropertyName );
        PropertyClassBSTR   = SysAllocString( g_Properties[i].ClassName );

        if ( !PropertyNameBSTR || !PropertyClassBSTR )
            {
            Hr = E_OUTOFMEMORY;
            goto failed;
            }

        MbSchemaContainer->Delete( g_PropertyBSTR, PropertyNameBSTR );
        
        Hr = MbSchemaContainer->QueryInterface( __uuidof(*Object), reinterpret_cast<void**>( &Object ) );

        if ( FAILED( Hr ) )
            goto failed;

        Object->SetInfo();

        Object->Release();
        Object = NULL;

        Hr = MbSchemaContainer->GetObject( g_ClassBSTR, PropertyClassBSTR, &Dispatch );

        if ( FAILED( Hr ) )
            goto failed;

        Hr = Dispatch->QueryInterface( __uuidof( *MbClass ), reinterpret_cast<void**>( &MbClass ) );

        if ( FAILED( Hr ) )
            goto failed;

        Dispatch->Release();
        Dispatch = NULL;
        
        if ( FAILED( Hr ) )
            goto failed;
            
        Hr = MbClass->get_OptionalProperties( &var );

        SAFEARRAY* Array = var.parray;
        Hr = SafeArrayLock( Array );

        if ( FAILED( Hr ) )
            goto failed;

        ULONG  NewSize = 0;
        SIZE_T j = Array->rgsabound[0].lLbound;
        SIZE_T k = Array->rgsabound[0].lLbound + Array->rgsabound[0].cElements;
        
        while( j < k )
            {

            VARIANT & JElem = ((VARIANT*)Array->pvData)[j];

            // This element is fine, keep it
            if ( 0 != _wcsicmp( (WCHAR*)JElem.bstrVal, BSTR( g_Properties[i].PropertyName ) ) )
                {
                NewSize++;
                j++;
                }

            else
                {

                // find a suitable element to replace the bad element with
                while( j < --k )
                    {
                    VARIANT & KElem = ((VARIANT*)Array->pvData)[k];
                    if ( 0 != _wcsicmp( (WCHAR*)KElem.bstrVal, BSTR( g_Properties[i].PropertyName ) ) )
                        {
                        // found element. move it
                        VARIANT temp = JElem;
                        JElem = KElem;
                        KElem = temp;
                        break;
                        }
                    }
                }
            }

        SAFEARRAYBOUND ArrayBounds;
        ArrayBounds = Array->rgsabound[0];
        ArrayBounds.cElements = NewSize;

        SafeArrayUnlock( Array );

        Hr = SafeArrayRedim( Array, &ArrayBounds );

        if ( FAILED( Hr ) )
            goto failed;

        Hr = MbClass->put_OptionalProperties( var );

        if ( FAILED( Hr ) )
            goto failed;

        Hr = MbClass->SetInfo();

        if ( FAILED( Hr ) )
            goto failed;

        MbClass->Release();
        MbClass = NULL;

        VariantClear( &var );
        continue;

        failed:

        SysFreeString( PropertyNameBSTR );
        SysFreeString( PropertyClassBSTR );
        PropertyNameBSTR = PropertyClassBSTR = NULL;

        if ( MbClass )
            {
            MbClass->Release();
            MbClass = NULL;
            }

        if ( Dispatch )
            {
            Dispatch->Release();
            Dispatch = NULL;
            }

        if ( Object )
            {
            Object->Release();
            Object = NULL;
            }

        VariantClear( &var );

    }

    return S_OK;

}

HRESULT InstallDefaultValues( )
{

    //
    // Install default values for the configuration.  Do this at the top and let inheritance deal with it.
    //

    HRESULT Hr = S_OK;
    METADATA_RECORD mdr;
    METADATA_HANDLE mdHandle = NULL;
    DWORD Value;

    IMSAdminBase * IISAdminBase = NULL;
    class PropertyIDManager *PropertyMan = 
        new PropertyIDManager();

    if ( !PropertyMan )
        return E_OUTOFMEMORY;

    Hr = PropertyMan->LoadPropertyInfo();
    
    if ( FAILED(Hr) )
        goto error;

    Hr = CoCreateInstance(
             GETAdminBaseCLSID(TRUE),
             NULL,
             CLSCTX_SERVER,
             __uuidof( *IISAdminBase ),
             (LPVOID*)&IISAdminBase );

    if ( FAILED(Hr) )
        goto error;

    Hr = IISAdminBase->OpenKey(
        METADATA_MASTER_ROOT_HANDLE,
        L"/LM/W3SVC",
        METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
        10000, // 10 seconds
        &mdHandle );

    if ( FAILED(Hr) )
        goto error;

    mdr.dwMDIdentifier  = PropertyMan->GetPropertyMetabaseID( MD_BITS_CONNECTION_DIR );
    mdr.dwMDAttributes  = METADATA_INHERIT;
    mdr.dwMDUserType    = PropertyMan->GetPropertyUserType( MD_BITS_CONNECTION_DIR );
    mdr.dwMDDataType    = STRING_METADATA;
    mdr.pbMDData        = (PBYTE)MD_DEFAULT_BITS_CONNECTION_DIR;
    mdr.dwMDDataLen     = sizeof(WCHAR) * ( wcslen( MD_DEFAULT_BITS_CONNECTION_DIR ) + 1 );
    mdr.dwMDDataTag     = 0;

    Hr = IISAdminBase->SetData(
        mdHandle,
        NULL,
        &mdr );

    if ( FAILED(Hr) )
        goto error;

    mdr.dwMDIdentifier  = PropertyMan->GetPropertyMetabaseID( MD_BITS_MAX_FILESIZE );
    mdr.dwMDAttributes  = METADATA_INHERIT;
    mdr.dwMDUserType    = PropertyMan->GetPropertyUserType( MD_BITS_MAX_FILESIZE );
    mdr.dwMDDataType    = STRING_METADATA;
    mdr.pbMDData        = (PBYTE)MD_DEFAULT_BITS_MAX_FILESIZE;
    mdr.dwMDDataLen     = sizeof(WCHAR) * ( wcslen( MD_DEFAULT_BITS_MAX_FILESIZE ) + 1 );
    mdr.dwMDDataTag     = 0;

    Hr = IISAdminBase->SetData(
        mdHandle,
        NULL,
        &mdr );

    if ( FAILED(Hr) )
        goto error;

    Value = MD_DEFAULT_NO_PROGESS_TIMEOUT;
    mdr.dwMDIdentifier  = PropertyMan->GetPropertyMetabaseID( MD_BITS_NO_PROGRESS_TIMEOUT );
    mdr.dwMDAttributes  = METADATA_INHERIT;
    mdr.dwMDUserType    = PropertyMan->GetPropertyUserType( MD_BITS_NO_PROGRESS_TIMEOUT );
    mdr.dwMDDataType    = DWORD_METADATA;
    mdr.pbMDData        = (PBYTE)&Value;
    mdr.dwMDDataLen     = sizeof(Value);
    mdr.dwMDDataTag     = 0;

    Hr = IISAdminBase->SetData(
        mdHandle,
        NULL,
        &mdr );

    if ( FAILED(Hr) )
        goto error;

    Value = (DWORD)MD_DEFAULT_BITS_NOTIFICATION_URL_TYPE;
    mdr.dwMDIdentifier  = PropertyMan->GetPropertyMetabaseID( MD_BITS_NOTIFICATION_URL_TYPE );
    mdr.dwMDAttributes  = METADATA_INHERIT;
    mdr.dwMDUserType    = PropertyMan->GetPropertyUserType( MD_BITS_NOTIFICATION_URL_TYPE );
    mdr.dwMDDataType    = DWORD_METADATA;
    mdr.pbMDData        = (PBYTE)&Value;
    mdr.dwMDDataLen     = sizeof(Value);
    mdr.dwMDDataTag     = 0;

    Hr = IISAdminBase->SetData(
        mdHandle,
        NULL,
        &mdr );

    if ( FAILED(Hr) )
        goto error;

    mdr.dwMDIdentifier  = PropertyMan->GetPropertyMetabaseID( MD_BITS_NOTIFICATION_URL );
    mdr.dwMDAttributes  = METADATA_INHERIT;
    mdr.dwMDUserType    = PropertyMan->GetPropertyUserType( MD_BITS_NOTIFICATION_URL );
    mdr.dwMDDataType    = STRING_METADATA;
    mdr.pbMDData        = (PBYTE)MD_DEFAULT_BITS_NOTIFICATION_URL;
    mdr.dwMDDataLen     = sizeof(WCHAR) * ( wcslen( MD_DEFAULT_BITS_NOTIFICATION_URL ) + 1 );;
    mdr.dwMDDataTag     = 0;

    Hr = IISAdminBase->SetData(
        mdHandle,
        NULL,
        &mdr );

    if ( FAILED(Hr) )
        goto error;

    mdr.dwMDIdentifier  = PropertyMan->GetPropertyMetabaseID( MD_BITS_HOSTID );
    mdr.dwMDAttributes  = METADATA_INHERIT;
    mdr.dwMDUserType    = PropertyMan->GetPropertyUserType( MD_BITS_HOSTID );
    mdr.dwMDDataType    = STRING_METADATA;
    mdr.pbMDData        = (PBYTE)MD_DEFAULT_BITS_HOSTID;
    mdr.dwMDDataLen     = sizeof(WCHAR) * ( wcslen( MD_DEFAULT_BITS_HOSTID ) + 1 );
    mdr.dwMDDataTag     = 0;

    Hr = IISAdminBase->SetData(
        mdHandle,
        NULL,
        &mdr );

    if ( FAILED(Hr) )
        goto error;

    Value = MD_DEFAULT_HOSTID_FALLBACK_TIMEOUT;
    mdr.dwMDIdentifier  = PropertyMan->GetPropertyMetabaseID( MD_BITS_HOSTID_FALLBACK_TIMEOUT );
    mdr.dwMDAttributes  = METADATA_INHERIT;
    mdr.dwMDUserType    = PropertyMan->GetPropertyUserType( MD_BITS_HOSTID_FALLBACK_TIMEOUT );
    mdr.dwMDDataType    = DWORD_METADATA;
    mdr.pbMDData        = (PBYTE)&Value;
    mdr.dwMDDataLen     = sizeof(Value);
    mdr.dwMDDataTag     = 0;

    Hr = IISAdminBase->SetData(
        mdHandle,
        NULL,
        &mdr );

    if ( FAILED(Hr) )
        goto error;

error:

    if ( PropertyMan )
        delete PropertyMan;

    if ( mdHandle )
        IISAdminBase->CloseKey( mdHandle );

    if ( IISAdminBase )
        IISAdminBase->Release();

    return Hr;

}

HRESULT
AddDllToIISList(
    SAFEARRAY* Array )
{

    //
    // Add the ISAPI to the IIS list.   
    //

    HRESULT Hr;
    WCHAR ExtensionPath[ MAX_PATH ];

    DWORD dwRet = 
        GetModuleFileNameW(
            g_hinst,
            ExtensionPath,
            MAX_PATH );

    if ( !dwRet )
        return HRESULT_FROM_WIN32( GetLastError() );

    // Search for the DLL.  If its already in the list, do nothing

    Hr = SafeArrayLock( Array );
    if ( FAILED( Hr ) )
        return Hr;

    for ( unsigned int i = Array->rgsabound[0].lLbound; 
         i < Array->rgsabound[0].lLbound + Array->rgsabound[0].cElements; i++ )
        {

        VARIANT & IElem = ((VARIANT*)Array->pvData)[i];

        if ( _wcsicmp( (WCHAR*)IElem.bstrVal, ExtensionPath ) == 0 )
            {
            SafeArrayUnlock( Array );
            return S_OK;
            }

        }

    // Need to add the DLL

    SAFEARRAYBOUND SafeBounds;
    SafeBounds.lLbound      = Array->rgsabound[0].lLbound;
    SafeBounds.cElements    = Array->rgsabound[0].cElements+1;

    SafeArrayUnlock( Array );

    Hr = SafeArrayRedim( Array, &SafeBounds );
    if ( FAILED( Hr ) )
        return Hr;

    VARIANT bstrvar;
    VariantInit( &bstrvar );
    bstrvar.vt = VT_BSTR;
    bstrvar.bstrVal = SysAllocString( ExtensionPath );
    long Index = SafeBounds.lLbound + SafeBounds.cElements - 1;

    Hr = SafeArrayPutElement( Array, &Index, (void*)&bstrvar );
    
    VariantClear( &bstrvar );
    if ( FAILED( Hr ) )
        return Hr;

    return S_OK;
    
}

HRESULT
RemoveDllFromIISList(
    SAFEARRAY *Array )
{

    // Remove the DLL from the IIS list

    HRESULT Hr;
    WCHAR ExtensionPath[ MAX_PATH ];

    DWORD dwRet = 
        GetModuleFileNameW(
            g_hinst,
            ExtensionPath,
            MAX_PATH );

    if ( !dwRet )
        return HRESULT_FROM_WIN32( GetLastError() );

    Hr = SafeArrayLock( Array );
    if ( FAILED( Hr ) )
        return Hr;

    ULONG  NewSize = 0;
    SIZE_T j = Array->rgsabound[0].lLbound;
    SIZE_T k = Array->rgsabound[0].lLbound + Array->rgsabound[0].cElements;
    
    while( j < k )
        {

        VARIANT & JElem = ((VARIANT*)Array->pvData)[j];

        // This element is fine, keep it
        if ( 0 != _wcsicmp( (WCHAR*)JElem.bstrVal, ExtensionPath ) )
            {
            NewSize++;
            j++;
            }

        else
            {

            // find a suitable element to replace the bad element with
            while( j < --k )
                {
                VARIANT & KElem = ((VARIANT*)Array->pvData)[k];
                if ( 0 != _wcsicmp( (WCHAR*)KElem.bstrVal,  ExtensionPath ) )
                    {
                    // found element. move it
                    VARIANT temp = JElem;
                    JElem = KElem;
                    KElem = temp;
                    break;
                    }
                }
            }
        }

    SAFEARRAYBOUND ArrayBounds;
    ArrayBounds = Array->rgsabound[0];
    ArrayBounds.cElements = NewSize;

    SafeArrayUnlock( Array );

    Hr = SafeArrayRedim( Array, &ArrayBounds );

    if ( FAILED( Hr ) )
        return Hr;

    return S_OK;
}

HRESULT
ModifyLockdownList( bool Add )
{

    // Toplevel function to modify the IIS lockdown list.
    // If Add is 1, then the ISAPI is added.  If Add is 0, then the ISAPI is removed.

    HRESULT Hr;
    IADs *Service       = NULL;
    SAFEARRAY* Array    = NULL;
    bool ArrayLocked    = false;

    VARIANT var;
    VariantInit( &var );

    Hr = ADsGetObject( BSTR( L"IIS://LocalHost/W3SVC" ), __uuidof( IADs ), (void**)&Service );
    if ( FAILED( Hr ) )
        return Hr;

    Hr = Service->Get( g_IsapiRestrictionListBSTR, &var );
    if ( FAILED(Hr) )
        {
        // This property doesn't exist on IIS5 or IIS5.1 don't install it
        Hr = S_OK;
        goto cleanup;
        }

    Array = var.parray;

    Hr = SafeArrayLock( Array );
    if ( FAILED( Hr ) )
        goto cleanup;
    
    ArrayLocked = true;

    if ( !Array->rgsabound[0].cElements )
        {
        // The array has no elements which means no restrictions.
        Hr = S_OK;
        goto cleanup;
        }

    VARIANT & FirstElem = ((VARIANT*)Array->pvData)[ Array->rgsabound[0].lLbound ];
    if ( _wcsicmp(L"0", (WCHAR*)FirstElem.bstrVal ) == 0 )
        {

        // 
        // According to the IIS6 spec, a 0 means that all ISAPIs are denied except
        // those that are explicitly listed.  
        // 
        // If installing:   add to the list. 
        // If uninstalling: remove from the list
        //

        SafeArrayUnlock( Array );
        ArrayLocked = false;

        if ( Add )
            Hr = AddDllToIISList( Array );
        else
            Hr = RemoveDllFromIISList( Array );

        if ( FAILED( Hr ) )
            goto cleanup;

        }
    else if ( _wcsicmp( L"1", (WCHAR*)FirstElem.bstrVal ) == 0 )
        {

        //
        // According to the IIS6 spec, a 1 means that all ISAPIs are allowed except
        // those that are explicitly denied. 
        //
        // If installing:   remove from the list
        // If uninstalling: Do nothing
        //

        SafeArrayUnlock( Array );
        ArrayLocked = false;

        if ( Add )
            {
            Hr = RemoveDllFromIISList( Array );

            if ( FAILED( Hr ) )
                goto cleanup;
            }

        }
    else
        {
        Hr = E_FAIL;
        goto cleanup;
        }

    Hr = Service->Put( g_IsapiRestrictionListBSTR, var );
    if ( FAILED( Hr ) )
        goto cleanup;

    Hr = Service->SetInfo();
    if ( FAILED( Hr ) )
        goto cleanup;

    Hr = S_OK;
    
cleanup:

    if ( Array && ArrayLocked )
        SafeArrayUnlock( Array );

    if ( Service )
        Service->Release();
    
    VariantClear( &var );

    return Hr;
}

HRESULT
AddToLockdownListDisplayPutString( 
    SAFEARRAY *Array,
    unsigned long Position,
    const WCHAR *String )
{

    HRESULT Hr;
    VARIANT Var;

    VariantInit( &Var );
    Var.vt          =   VT_BSTR;
    Var.bstrVal     =   SysAllocString( String );

    if ( !Var.bstrVal )
        return E_OUTOFMEMORY;

    long Index = (unsigned long)Position;
    Hr = SafeArrayPutElement( Array, &Index, (void*)&Var );

    VariantClear( &Var );
    return Hr;

}

HRESULT
AddToLockdownListDisplay( SAFEARRAY *Array )
{

    HRESULT Hr;
    WCHAR FilterPath[ MAX_PATH ];

    DWORD dwRet = 
        GetModuleFileNameW(
            g_hinst,
            FilterPath,
            MAX_PATH );

    if ( !dwRet )
        return HRESULT_FROM_WIN32( GetLastError() );

    WCHAR ExtensionName[ MAX_PATH ];
    if (! LoadStringW(g_hinst,              // handle to resource module
                      IDS_EXTENSION_NAME,   // resource identifier
                      ExtensionName,        // resource buffer
                      MAX_PATH ) )          // size of buffer
        return HRESULT_FROM_WIN32( GetLastError() );


    //
    //  Check to see if the ISAPI is already in the list.  If it is, don't modify 
    //  list.
    //

    Hr = SafeArrayLock( Array );

    if ( FAILED( Hr ) )
        return Hr;

    for( unsigned long i = Array->rgsabound[0].lLbound;
         i < Array->rgsabound[0].lLbound + Array->rgsabound[0].cElements;
         i++ )
        {

        VARIANT & CurrentElement = ((VARIANT*)Array->pvData)[ i ];
        BSTR BSTRString = CurrentElement.bstrVal;

        if ( _wcsicmp( (WCHAR*)BSTRString, FilterPath ) == 0 )
            {
            // ISAPI is already in the list, don't do anything
            SafeArrayUnlock( Array );
            return S_OK;
            }

        }

     
    SAFEARRAYBOUND SafeArrayBound = Array->rgsabound[0];
    unsigned long OldSize = SafeArrayBound.cElements;
    SafeArrayBound.cElements += 3;
    SafeArrayUnlock( Array );

    Hr = SafeArrayRedim( Array, &SafeArrayBound );
    if ( FAILED( Hr ) )
        return Hr;

    Hr = AddToLockdownListDisplayPutString( Array, OldSize, L"1" );
    if ( FAILED( Hr ) )
        return Hr;

    Hr = AddToLockdownListDisplayPutString( Array, OldSize + 1, FilterPath );
    if ( FAILED( Hr ) )
        return Hr;

    Hr = AddToLockdownListDisplayPutString( Array, OldSize + 2, ExtensionName );
    if ( FAILED( Hr ) )
        return Hr;

    return S_OK;
}

HRESULT
SafeArrayRemoveSlice(
    SAFEARRAY *Array,
    unsigned long lBound,
    unsigned long uBound )
{

    // Remove a slice of an array.

    SIZE_T ElementsToRemove = uBound - lBound + 1;
    
    HRESULT Hr = SafeArrayLock( Array );

    if ( FAILED( Hr ) )
        return Hr;

    if ( uBound + 1 < Array->rgsabound[0].cElements )
        {
        // At least one element exists above this element

        // Step 1, move slice to temp storage

        VARIANT *Temp = (VARIANT*)new BYTE[ sizeof(VARIANT) * ElementsToRemove ];

        if ( !Temp )
            {
            SafeArrayUnlock( Array );
            return E_OUTOFMEMORY;
            }

        memcpy( Temp, &((VARIANT*)Array->pvData)[ lBound ], sizeof(VARIANT)*ElementsToRemove );

		// Step 2, collapse hole left by slice
        memmove( &((VARIANT*)Array->pvData)[ lBound ],
                 &((VARIANT*)Array->pvData)[ uBound + 1 ],
                 sizeof(VARIANT) * ( Array->rgsabound[0].cElements - ( uBound + 1 ) ) );

		// Step 3, move slice to end of array
		memcpy( &((VARIANT*)Array->pvData)[ Array->rgsabound[0].cElements - ElementsToRemove ],
			    Temp,
				sizeof(VARIANT)*ElementsToRemove );

        }

    SAFEARRAYBOUND SafeArrayBound = Array->rgsabound[0];
    SafeArrayBound.cElements -= (ULONG)ElementsToRemove;

    SafeArrayUnlock( Array );

    return SafeArrayRedim( Array, &SafeArrayBound );

}

HRESULT
RemoveFromLockdownListDisplay(
    SAFEARRAY *Array )
{

    HRESULT Hr;
    WCHAR FilterPath[ MAX_PATH ];

    DWORD dwRet = 
        GetModuleFileNameW(
            g_hinst,
            FilterPath,
            MAX_PATH );

    if ( !dwRet )
        return HRESULT_FROM_WIN32( GetLastError() );

    Hr = SafeArrayLock( Array );

    if ( FAILED( Hr ) )
        return Hr;

    for( unsigned int i = Array->rgsabound[0].lLbound;
         i < Array->rgsabound[0].lLbound + Array->rgsabound[0].cElements;
         i++ )
        {

        VARIANT & CurrentElement = ((VARIANT*)Array->pvData)[ i ];
        BSTR BSTRString = CurrentElement.bstrVal;

        if ( _wcsicmp( (WCHAR*)BSTRString, FilterPath ) == 0 )
            {
            // ISAPI is in the list, remove it

            Hr = SafeArrayUnlock( Array );
            
            if ( FAILED( Hr ) )
                return Hr;

            Hr = SafeArrayRemoveSlice( 
                Array,
                (i == 0) ? 0 : i - 1,
                min( i + 1, Array->rgsabound[0].cElements - 1 ) );

            return Hr;

            }

        }

    // ISAPI wasn't found. Nothing to do.

    SafeArrayUnlock( Array );
    return S_OK;

}

HRESULT
ModifyLockdownListDisplay( bool Add )
{
 
    HRESULT Hr;
    SAFEARRAY* Array    = NULL;
    IADs *Service       = NULL;

    VARIANT var;
    VariantInit( &var );

    Hr = ADsGetObject( BSTR( L"IIS://LocalHost/W3SVC" ), __uuidof( IADs ), (void**)&Service );
    if ( FAILED( Hr ) )
        return Hr;

    Hr = Service->Get( g_RestrictionListCustomDescBSTR, &var );
    if ( FAILED(Hr) )
        {
        // This property doesn't exist on IIS5 or IIS5.1 don't install or uninstall it
        Hr = S_OK;
        goto cleanup;
        }

    Array = var.parray;

    if ( Add )
        Hr = AddToLockdownListDisplay( Array );
    else 
        Hr = RemoveFromLockdownListDisplay( Array );

    if ( FAILED( Hr ) )
        goto cleanup;

    Hr = Service->Put( g_RestrictionListCustomDescBSTR, var );
    if ( FAILED( Hr ) )
        goto cleanup;

    Hr = Service->SetInfo();
    if ( FAILED( Hr ) )
        goto cleanup;

cleanup:
    VariantClear( &var );
    if ( Service )
        Service->Release();

    return Hr;
}

HRESULT
RemoveFilterIfNeeded()
{
    HRESULT Hr;
    
    VARIANT var;
    VariantInit( &var );

    WCHAR *LoadOrder = NULL;

    IADsContainer *MbFiltersContainer = NULL;
    IADs *Object = NULL;

    Hr = ADsGetObject( BSTR( L"IIS://LocalHost/W3SVC/Filters" ), __uuidof( IADsContainer), (void**)&MbFiltersContainer );
    if ( FAILED( Hr ) )
        return Hr;

    // Remove bits from the load path

    Hr = MbFiltersContainer->QueryInterface( __uuidof(*Object), (void**)&Object );

    if ( FAILED( Hr ) )
        goto failed;

    Hr = Object->Get( g_FilterLoadOrderBSTR, &var );

    if ( FAILED( Hr ) )
        goto failed;

    Hr = VariantChangeType( &var, &var, 0, VT_BSTR );

    if ( FAILED( Hr ) )
        goto failed;

    SIZE_T LoadOrderLength = wcslen( (WCHAR*)var.bstrVal ) + 1;
    LoadOrder = new WCHAR[ LoadOrderLength ];

    if ( !LoadOrder )
        {
        Hr = E_OUTOFMEMORY;
        goto failed;
        }

    memcpy( LoadOrder, (WCHAR*)var.bstrVal, LoadOrderLength * sizeof( WCHAR ) );
    
    // remove any old bitsserver entries
    RemoveFilterHelper( LoadOrder, L",bitsserver" );
    RemoveFilterHelper( LoadOrder, L"bitsserver," );
    RemoveFilterHelper( LoadOrder, L"bitsserver" );
    RemoveFilterHelper( LoadOrder, L",bitserver" );
    RemoveFilterHelper( LoadOrder, L"bitserver," );
    RemoveFilterHelper( LoadOrder, L"bitserver" );

    VariantClear( &var );
    var.vt = VT_BSTR;
    var.bstrVal = SysAllocString( LoadOrder );

    if ( !var.bstrVal )
        goto failed;

    Hr = Object->Put( g_FilterLoadOrderBSTR, var );

    if ( FAILED( Hr ) )
        goto failed;

    Hr = Object->SetInfo();

    if ( FAILED( Hr ) )
        goto failed;

    MbFiltersContainer->Delete( g_IIsFilterBSTR, g_bitsserverBSTR );
    MbFiltersContainer->Delete( g_IIsFilterBSTR, g_bitserverBSTR );
    Object->SetInfo();
      
    Hr = S_OK;

failed:

    if ( MbFiltersContainer )
        {
        MbFiltersContainer->Release();
        MbFiltersContainer = NULL;
        }

    if ( Object )
        {
        Object->Release();
        Object = NULL;      
        }

    return Hr;
}

HRESULT
ModifyInProcessList( bool Add )
{

    // Toplevel function to modify the IIS inprocess list.
    // If Add is 1, then the ISAPI is added.  If Add is 0, then the ISAPI is removed.

    HRESULT Hr;
    IADs *Service       = NULL;

    VARIANT var;
    VariantInit( &var );

    Hr = ADsGetObject( BSTR( L"IIS://LocalHost/W3SVC" ), __uuidof( IADs ), (void**)&Service );
    if ( FAILED( Hr ) )
        return Hr;

    Hr = Service->Get( g_InProcessIsapiAppsBSTR, &var );
    if ( FAILED(Hr) )
        {
        goto cleanup;
        }

    if ( Add )
        Hr = AddDllToIISList( var.parray );
    else
        Hr = RemoveDllFromIISList( var.parray );

    Hr = Service->Put( g_InProcessIsapiAppsBSTR, var );
    if ( FAILED( Hr ) )
        goto cleanup;

    Hr = Service->SetInfo();
    if ( FAILED( Hr ) )
        goto cleanup;

    Hr = S_OK;
    
cleanup:

    if ( Service )
        Service->Release();
    
    VariantClear( &var );

    return Hr;

}

HRESULT
StartupMSTask()
{
    HRESULT Hr;
    SC_HANDLE   hSC     = NULL;
    SC_HANDLE   hSchSvc = NULL;
    BYTE* ConfigBuffer  = NULL;
    DWORD BytesNeeded   = 0;

    hSC = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    if (hSC == NULL)
       {
       Hr = HRESULT_FROM_WIN32( GetLastError() );
       goto exit;
       }
    
    hSchSvc = OpenService(hSC,
                          "Schedule",
                          SERVICE_ALL_ACCESS );
    
    if ( !hSchSvc )
        {
        Hr = HRESULT_FROM_WIN32( GetLastError() );
        goto exit;
        }
    
    SERVICE_STATUS SvcStatus;
    
    if (QueryServiceStatus(hSchSvc, &SvcStatus) == FALSE)
        {
        Hr = HRESULT_FROM_WIN32( GetLastError() );
        goto exit;
        }
    
    if (SvcStatus.dwCurrentState == SERVICE_RUNNING)
        {
        // Service is already running
        Hr = S_OK;
        goto exit;
        }

    SetLastError( ERROR_SUCCESS );

    QueryServiceConfig(
        hSchSvc,
        NULL,
        0,
        &BytesNeeded );

    if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER )
        {
        Hr = HRESULT_FROM_WIN32( GetLastError() );
        goto exit;
        }

    ConfigBuffer = new BYTE[ BytesNeeded ];

    if ( !ConfigBuffer )
        {
        Hr = E_OUTOFMEMORY;
        goto exit;
        }

    if ( !QueryServiceConfig(
            hSchSvc,
            (LPQUERY_SERVICE_CONFIG)ConfigBuffer,
            BytesNeeded,
            &BytesNeeded ) )
        {
        Hr = HRESULT_FROM_WIN32( GetLastError() );
        goto exit;
        }

    if ( ((LPQUERY_SERVICE_CONFIG)ConfigBuffer)->dwStartType != SERVICE_AUTO_START )
        {
        
        if ( !ChangeServiceConfig(
                 hSchSvc,
                 SERVICE_NO_CHANGE,          // type of service
                 SERVICE_AUTO_START,         // when to start service
                 SERVICE_NO_CHANGE,          // severity of start failure
                 NULL,                       // service binary file name
                 NULL,                       // load ordering group name
                 NULL,                       // tag identifier
                 NULL,                       // array of dependency names
                 NULL,                       // account name
                 NULL,                       // account password
                 NULL                        // display name
                 ) )
            {
            Hr = HRESULT_FROM_WIN32( GetLastError() );
            goto exit;
            }

        }

    if ( StartService(hSchSvc, 0, NULL) == FALSE )
        {

        Hr = HRESULT_FROM_WIN32( GetLastError() );
        goto exit;
        }
      

    // Poll for the service to enter the running or error state

    Hr = S_OK;

    while( 1 )
        {

        if (QueryServiceStatus(hSchSvc, &SvcStatus) == FALSE)
            {
            Hr = HRESULT_FROM_WIN32( GetLastError() );
            goto exit;
            }

        if ( SvcStatus.dwCurrentState == SERVICE_STOPPED ||
             SvcStatus.dwCurrentState == SERVICE_PAUSED )
            {
            // Service is already running
            Hr = HRESULT_FROM_WIN32( SvcStatus.dwCurrentState );
            goto exit;
            }

        if ( SvcStatus.dwCurrentState == SERVICE_RUNNING )
            {
            Hr = S_OK;
            goto exit;
            }

        }

exit:

    if ( ConfigBuffer )
        delete[] ConfigBuffer;

    if ( hSchSvc )
        CloseServiceHandle( hSC );

    if ( hSC )
        CloseServiceHandle( hSchSvc );

    return Hr;
}

#if 0

HRESULT
ProcessVerbsInIniSection(
    WCHAR *Section,
    WCHAR *Verb,
    WCHAR *FileName,
    bool Add )
{

    HRESULT Hr = S_OK;
    WCHAR *SectionData = (WCHAR*)new WCHAR[ 32768 ];

    if ( !SectionData )
        return E_OUTOFMEMORY;

    WCHAR *NewSectionData = (WCHAR*)new WCHAR[ 32768 * 2 ];
    if ( !NewSectionData )
        {
        Hr = E_OUTOFMEMORY;
        goto exit;
        }

    DWORD Result =
        GetPrivateProfileSectionW(
            Section,                  // section name
            SectionData,              // return buffer
            32768,                    // size of return buffer
            FileName                  // initialization file name
            );


    if ( Result == 32768 - 2 )
        {
        // The buffer is not large enough.  Interestingly,
        // even urlscan is not capable of handing a section this
        // large so just assume the file is corrupt and ignore it.
        Hr = S_OK;
        goto exit;
        }

    if ( Add )
        {

        // Loop through the list copying it to the new buffer.
        // Stop if the verb has already been added.

        WCHAR *OriginalVerb     = SectionData;
        WCHAR *NewVerb          = NewSectionData;

        while( *OriginalVerb )
            {

            if ( wcscmp( OriginalVerb, Verb ) == 0 )
                {
                // verb already found, no more processing needed
                Hr = S_OK;
                goto exit;
                }

            SIZE_T VerbSize = wcslen( OriginalVerb ) + 1;
            memcpy( NewVerb, OriginalVerb, sizeof( WCHAR ) * VerbSize );
            OriginalVerb  += VerbSize;
            NewVerb       += VerbSize;
            }

        // add the verb since it hasn't been added
        SIZE_T VerbSize = wcslen( Verb ) + 1;
        memcpy( NewVerb, Verb, sizeof( WCHAR ) * VerbSize );
        NewVerb[ VerbSize ] = '\0'; // end the list

        }
    else
        {

        // Loop though the list copying all nonmatching verbs to the new buffer
        // Keep track if list changes
        
        bool ListChanged = false;
        WCHAR *OriginalVerb     = SectionData;
        WCHAR *NewVerb          = NewSectionData;

        while( *OriginalVerb )
            {

            if ( wcscmp( OriginalVerb, Verb ) == 0 )
                {
                // verb to remove, skip it
                OriginalVerb += wcslen( OriginalVerb ) + 1;
                ListChanged = true;
                }
            else
                {
                // copy the verb
                SIZE_T VerbSize = wcslen( OriginalVerb ) + 1;
                memcpy( NewVerb, OriginalVerb, sizeof( WCHAR ) * VerbSize );
                OriginalVerb  += VerbSize;
                NewVerb       += VerbSize;
                }

            }

        if ( !ListChanged )
            {
            Hr = S_OK;
            goto exit;
            }

        *NewVerb = '\0'; // end the list

        }

    if ( !WritePrivateProfileSectionW(
            Section,            // section name
            NewSectionData,     // data
            FileName            // file name
            ) )
        {
        Hr = HRESULT_FROM_WIN32( GetLastError() );
        goto exit;
        }

    Hr = S_OK;


exit:

    delete[] SectionData;
    delete[] NewSectionData;

    return Hr;
}

HRESULT ModifyURLScanFiles(
    bool Add )
{

    // Loop though the list of filters and find valid copies of urlscan.ini

    HRESULT Hr = S_OK;

    IADsContainer *MbFiltersContainer   = NULL;
    IEnumVARIANT  *EnumVariant          = NULL;
    IADs          *Filter               = NULL;
    IUnknown      *Unknown              = NULL;
    VARIANT Var;

    VariantInit( &Var );

    Hr = ADsGetObject( BSTR( L"IIS://LocalHost/W3SVC/Filters" ), __uuidof( IADsContainer), (void**)&MbFiltersContainer );
    if ( FAILED( Hr ) )
        goto exit;

    
    Hr = MbFiltersContainer->get__NewEnum( &Unknown );
    if ( FAILED( Hr ) )
        goto exit;

    Hr = Unknown->QueryInterface( __uuidof( *EnumVariant ), (void**)&EnumVariant );
    if ( FAILED( Hr ) )
        goto exit;

    Unknown->Release();
    Unknown = NULL;

    while( 1 )
        {

        ULONG NumberFetched;

        Hr = EnumVariant->Next( 1, &Var, &NumberFetched ); 

        if ( FAILED( Hr ) )
            goto exit;

        if ( S_FALSE == Hr )
            {
            // All the filters were looped though.
            Hr = S_OK;
            goto exit;
            }

        Hr = VariantChangeType( &Var, &Var, 0, VT_UNKNOWN );

        if ( FAILED( Hr ) )
            goto exit;

        Hr = Var.punkVal->QueryInterface( __uuidof( *Filter ), (void**)&Filter );

        if ( FAILED( Hr ) )
            goto exit;

        VariantClear( &Var );

        Hr = Filter->Get( (BSTR)L"FilterPath", &Var );

        if ( FAILED( Hr ) )
            goto exit;

        Filter->Release();
        Filter = NULL;

        Hr = VariantChangeType( &Var, &Var, 0, VT_BSTR );

        if ( FAILED( Hr ) )
            goto exit;

        // Test if this is UrlScan and bash the filepart 
        WCHAR * FilterPathString     = (WCHAR*)Var.bstrVal;
        SIZE_T FilterPathStringSize  = wcslen( FilterPathString );
        const WCHAR UrlScanDllName[] = L"urlscan.dll";
        const WCHAR UrlScanIniName[] = L"urlscan.ini";
        const SIZE_T UrlScanNameSize = sizeof( UrlScanDllName ) / sizeof( *UrlScanDllName );

        if ( FilterPathStringSize < UrlScanNameSize )
            continue;

        WCHAR * FilterPathStringFilePart = FilterPathString + FilterPathStringSize - UrlScanNameSize;

        if ( _wcsicmp( FilterPathStringFilePart, UrlScanDllName ) != 0 )
            continue;

        // this is an urlscan.dll filter, bash the filename to get the ini file name

        wcscpy( FilterPathStringFilePart, UrlScanIniName );

        WCHAR *IniFileName = FilterPathString;

        UINT AllowVerbs =
            GetPrivateProfileIntW( 
                L"options",
                L"UseAllowVerbs",
                -1,
                IniFileName );

        if ( AllowVerbs != 0 && AllowVerbs != 1 )
            continue; // missing or broken ini file

        if ( AllowVerbs )
            Hr = ProcessVerbsInIniSection( L"AllowVerbs", L"BITS_POST", IniFileName, Add );
        else
            Hr = ProcessVerbsInIniSection( L"DenyVerbs", L"BITS_POST", IniFileName, !Add );

        }

    Hr = S_OK;

exit:

    if ( MbFiltersContainer )
        MbFiltersContainer->Release();

    if ( EnumVariant )
        EnumVariant->Release();

    if ( Filter )
        Filter->Release();

    if ( Unknown )
        Unknown->Release();

    VariantClear( &Var );

    return Hr;
}

#endif

STDAPI DllRegisterServer()
{

    //
    // Main entry point for setup
    //

    HRESULT Hr = InitializeSetup();
    
    if ( FAILED( Hr ) )
        return Hr;

    Hr = RemoveFilterIfNeeded();

    if ( FAILED( Hr ) )
        return Hr;

    Hr = StartupMSTask();

    if ( FAILED( Hr ) )
        return Hr;

    Hr = InstallPropertySchema();

    if ( FAILED( Hr ) )
        return Hr;

    Hr = InstallDefaultValues();

    if ( FAILED( Hr ) )
        return Hr;

    Hr = ModifyLockdownList( true );

    if ( FAILED( Hr ) )
        return Hr;

    Hr = ModifyLockdownListDisplay( true );

    if ( FAILED( Hr ) )
        return Hr;

    Hr = ModifyInProcessList( true );

    if ( FAILED( Hr ) )
        return Hr;

#if 0

    Hr = ModifyURLScanFiles( true );

    if ( FAILED( Hr ) )
        return Hr;

#endif

    Hr = RestartIIS();
    
    CleanupSetup();
    
    return Hr;

}

STDAPI DllUnregisterServer()
{                                   
    //
    // Main entry point for setup unregistration
    //

    HRESULT Hr = RemovePropertySchema();

    if ( FAILED(Hr) )
        return Hr;
    
    Hr = ModifyLockdownList( false );

    if ( FAILED( Hr ) )
        goto failed;

    Hr = ModifyLockdownListDisplay( false );

    if ( FAILED( Hr ) )
        goto failed;

    Hr = ModifyInProcessList( false );

    if ( FAILED( Hr ) )
        return Hr;

    Hr = RestartIIS();
    return Hr;

failed:
    
    return Hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\server\mmcexts\bitsext.cpp ===
/************************************************************************

Copyright (c) 2001 Microsoft Corporation

Module Name :

    bitsext.cpp

Abstract :

    Main snapin code.

Author :

Revision History :

 ***********************************************************************/


#include "precomp.h"

bool    CPropSheetExtension::s_bStaticInitialized = false;
UINT    CPropSheetExtension::s_cfDisplayName;
UINT    CPropSheetExtension::s_cfSnapInCLSID;
UINT    CPropSheetExtension::s_cfNodeType;
UINT    CPropSheetExtension::s_cfSnapInMetapath;
UINT    CPropSheetExtension::s_cfSnapInMachineName;

const UINT CPropSheetExtension::s_MaxUploadUnits[] =
{
    IDS_BYTES,
    IDS_KILOBYTES,
    IDS_MEGABYTES,
    IDS_GIGABYTES,
    IDS_TERABYTES

};
const UINT CPropSheetExtension::s_NumberOfMaxUploadUnits = 
    sizeof(CPropSheetExtension::s_MaxUploadUnits)/
        sizeof(*CPropSheetExtension::s_MaxUploadUnits);

const UINT64 CPropSheetExtension::s_MaxUploadUnitsScales[] =
{
    1,
    1024,
    1048576,
    1073741824,
    1099511627776
};
const UINT CPropSheetExtension::s_NumberOfMaxUploadUnitsScales =
    sizeof(CPropSheetExtension::s_MaxUploadUnitsScales)/
        sizeof(*CPropSheetExtension::s_MaxUploadUnitsScales);


const UINT64 CPropSheetExtension::s_MaxUploadLimits[] =
{
    18446744073709551615, //bytes
    18014398509481983,    //kilobytes
    17592186044415,       //megabytes
    17179869183,          //gigabytes
    16777215              //terabytes

};

const UINT CPropSheetExtension::s_NumberOfMaxUploadLimits=
    sizeof(CPropSheetExtension::s_MaxUploadLimits)/
        sizeof(*CPropSheetExtension::s_MaxUploadLimits);

const UINT CPropSheetExtension::s_TimeoutUnits[] =
{
    IDS_SECONDS,
    IDS_MINUTES,
    IDS_HOURS,
    IDS_DAYS
};
const UINT CPropSheetExtension::s_NumberOfTimeoutUnits = 
    sizeof(CPropSheetExtension::s_TimeoutUnits)/
        sizeof(*CPropSheetExtension::s_TimeoutUnits);


const DWORD CPropSheetExtension::s_TimeoutUnitsScales[] =
{
    1,
    60,
    60*60,
    24*60*60
};
const UINT CPropSheetExtension::s_NumberOfTimeoutUnitsScales =
    sizeof(CPropSheetExtension::s_TimeoutUnitsScales)/
        sizeof(*CPropSheetExtension::s_TimeoutUnitsScales);
    
const UINT64 CPropSheetExtension::s_TimeoutLimits[] =
{
    4294967295, // seconds
    71582788,   // minutes
    1193046,    // hours
    49710       // days
};
    
const UINT CPropSheetExtension::s_NumberOfTimeoutLimits =
    sizeof(CPropSheetExtension::s_TimeoutLimits)/
        sizeof(*CPropSheetExtension::s_TimeoutLimits);


const UINT CPropSheetExtension::s_NotificationTypes[] =
{
    IDS_BYREF_POST_NOTIFICATION,
    IDS_BYVAL_POST_NOTIFICATION
    
};

const UINT CPropSheetExtension::s_NumberOfNotificationTypes =
    sizeof(CPropSheetExtension::s_NotificationTypes)/
        sizeof(*CPropSheetExtension::s_NotificationTypes);

HRESULT CPropSheetExtension::InitializeStatic()
{

    if ( s_bStaticInitialized )
        return S_OK;

    if ( !( s_cfDisplayName         =   RegisterClipboardFormat(L"CCF_DISPLAY_NAME") )      ||
         !( s_cfNodeType            =   RegisterClipboardFormat(L"CCF_NODETYPE") )          ||
         !( s_cfSnapInCLSID         =   RegisterClipboardFormat(L"CCF_SNAPIN_CLASSID") )    ||
         !( s_cfSnapInMetapath      =   RegisterClipboardFormat(L"ISM_SNAPIN_META_PATH") )  ||
         !( s_cfSnapInMachineName   =   RegisterClipboardFormat(L"ISM_SNAPIN_MACHINE_NAME") ) )
        return HRESULT_FROM_WIN32( GetLastError() );

    s_bStaticInitialized = true;
    return S_OK;
}

CPropSheetExtension::InheritedValues::InheritedValues() :
MaxUploadSize(0),
SessionTimeout(0),
NotificationType( BITS_NOTIFICATION_TYPE_NONE ),
NotificationURL( NULL ),
HostId( NULL ),
FallbackTimeout( 0 )
{
}

CPropSheetExtension::InheritedValues::~InheritedValues()
{
   delete NotificationURL;
   delete HostId;
}

CPropSheetExtension::CPropSheetExtension() : 
m_cref(1),
m_MetabasePath( NULL ),
m_MetabaseParent( NULL ),
m_ComputerName( NULL ),
m_UNCComputerName( NULL ),
m_IISAdminBase( NULL ),
m_IBITSSetup( NULL ),
m_PropertyMan( NULL ),
m_hwnd( NULL ),
m_SettingsChanged( false ),
m_EnabledSettingChanged( false ),
m_TaskSched( NULL ),
m_CleanupTask( NULL ),
m_CleanupInProgress( false ),
m_CleanupCursor( NULL ),
m_CleanupMinWaitTimerFired( false )
{
    OBJECT_CREATED
}

CPropSheetExtension::~CPropSheetExtension()
{
    CloseCleanupItems(); // Close m_TaskSched and m_CleanupTask

    delete m_MetabasePath;
    delete m_MetabaseParent;
    delete m_ComputerName;
    delete m_UNCComputerName;

    if ( m_IBITSSetup )
        m_IBITSSetup->Release();

    if ( m_IISAdminBase )
        m_IISAdminBase->Release();
    
    delete m_PropertyMan;
    
    OBJECT_DESTROYED
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CPropSheetExtension::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IExtendPropertySheet *>(this);
    else if (IsEqualIID(riid, IID_IExtendPropertySheet))
        *ppv = static_cast<IExtendPropertySheet *>(this);
    
    if (*ppv) 
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }
    
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CPropSheetExtension::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CPropSheetExtension::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        // we need to decrement our object count in the DLL
        delete this;
        return 0;
    }
    
    return m_cref;
}


HRESULT 
CPropSheetExtension::ExtractData( 
    IDataObject* piDataObject,
    CLIPFORMAT   cfClipFormat,
    BYTE*        pbData,
    DWORD        cbData )
{
    HRESULT hr = S_OK;
    
    FORMATETC formatetc = {cfClipFormat, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM stgmedium = {TYMED_HGLOBAL, NULL};
    
    stgmedium.hGlobal = ::GlobalAlloc(GPTR, cbData);
    do // false loop
    {
        if (NULL == stgmedium.hGlobal)
        {
            hr = E_OUTOFMEMORY;
            break;
        }
        hr = piDataObject->GetDataHere( &formatetc, &stgmedium );
        if ( FAILED(hr) )
        {
            break;
        }
        
        BYTE* pbNewData = reinterpret_cast<BYTE*>(stgmedium.hGlobal);
        if (NULL == pbNewData)
        {
            hr = E_UNEXPECTED;
            break;
        }
        ::memcpy( pbData, pbNewData, cbData );
    } while (FALSE); // false loop
    
    if (NULL != stgmedium.hGlobal)
    {
        ::GlobalFree(stgmedium.hGlobal);
    }
    return hr;
}



HRESULT 
CPropSheetExtension::ExtractSnapInString( IDataObject * piDataObject,
                                          WCHAR * & String,
                                          UINT Format )
{

    HRESULT Hr = S_OK;

    if ( String )
        return S_OK;

    FORMATETC formatetc = {(CLIPFORMAT)Format, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM stgmedium = {TYMED_HGLOBAL, NULL };

    stgmedium.hGlobal = GlobalAlloc( GMEM_MOVEABLE, 0 );
    if ( !stgmedium.hGlobal )
        return E_OUTOFMEMORY;

    Hr = piDataObject->GetDataHere(&formatetc, &stgmedium);

    if (FAILED(Hr))
        {
        ReleaseStgMedium(&stgmedium);
        return Hr;
        }

    WCHAR* pRetData = (WCHAR*)GlobalLock( stgmedium.hGlobal );

    SIZE_T StringLength = wcslen( pRetData ) + 1;

    String = new WCHAR[ StringLength ];
    
    if ( !String )
        {
        GlobalUnlock( pRetData );
        ReleaseStgMedium( &stgmedium );
        return E_OUTOFMEMORY;
        }

    StringCchCopyW( String, StringLength, pRetData );

    GlobalUnlock( pRetData );
    ReleaseStgMedium( &stgmedium );

    return S_OK;

}

HRESULT 
CPropSheetExtension::ExtractSnapInGUID( 
    IDataObject * piDataObject,
    GUID & Guid,
    UINT Format )
{

    HRESULT Hr = S_OK;

    FORMATETC formatetc = {(CLIPFORMAT)Format, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM stgmedium = {TYMED_HGLOBAL, NULL };

    stgmedium.hGlobal = GlobalAlloc( GMEM_MOVEABLE, 0 );
    if ( !stgmedium.hGlobal )
        return E_OUTOFMEMORY;

    Hr = piDataObject->GetDataHere(&formatetc, &stgmedium);

    if (FAILED(Hr))
        {
        ReleaseStgMedium(&stgmedium);
        return Hr;
        }

    GUID * pRetData = (GUID*)GlobalLock( stgmedium.hGlobal );

    Guid = *pRetData;
    GlobalUnlock( pRetData );
    ReleaseStgMedium( &stgmedium );

    return S_OK;

}


void 
CPropSheetExtension::AddComboBoxItems( 
    UINT Combo, 
    const UINT *Items, 
    UINT NumberOfItems )
{
    HWND hwndBox = GetDlgItem( m_hwnd, Combo );

    SendMessage( hwndBox, CB_RESETCONTENT, 0, 0 );
    for( unsigned int i = 0; i < NumberOfItems; i++ )
        {

        WCHAR ItemText[MAX_PATH];

        LoadString( g_hinst, Items[i], ItemText, MAX_PATH-1 );
        SendMessage( hwndBox, CB_ADDSTRING, 0, (LPARAM)ItemText );
        }
}


void
CPropSheetExtension::UpdateMaxUploadGroupState(
    bool IsEnabled )
{
    EnableWindow( GetDlgItem( m_hwnd, IDC_CHECK_LIMIT_MAX_UPLOAD ), IsEnabled );

    bool SubgroupEnabled = IsEnabled && ( BST_CHECKED == IsDlgButtonChecked( m_hwnd, IDC_CHECK_LIMIT_MAX_UPLOAD ) );
    EnableWindow( GetDlgItem( m_hwnd, IDC_EDIT_MAX_UPLOAD ), SubgroupEnabled );
    EnableWindow( GetDlgItem( m_hwnd, IDC_COMBO_MAX_UPLOAD_UNITS ), SubgroupEnabled );
}

void
CPropSheetExtension::UpdateTimeoutGroupState(
    bool IsEnabled )
{

    EnableWindow( GetDlgItem( m_hwnd, IDC_DELETE_FILES ), IsEnabled );

    bool SubgroupEnabled = IsEnabled && ( BST_CHECKED == IsDlgButtonChecked( m_hwnd, IDC_DELETE_FILES ) );
    EnableWindow( GetDlgItem( m_hwnd, IDC_EDIT_SESSION_TIMEOUT ), SubgroupEnabled );
    EnableWindow( GetDlgItem( m_hwnd, IDC_COMBO_SESSION_TIMEOUT_UNITS ), SubgroupEnabled );
}

void
CPropSheetExtension::UpdateNotificationsGroupState(
    bool IsEnabled )
{

    EnableWindow( GetDlgItem( m_hwnd, IDC_CHECK_ENABLE_NOTIFICATIONS ), IsEnabled );

    bool SubgroupEnabled = IsEnabled && ( BST_CHECKED == IsDlgButtonChecked( m_hwnd, IDC_CHECK_ENABLE_NOTIFICATIONS ) );
    EnableWindow( GetDlgItem( m_hwnd, IDC_STATIC_NOTIFICATION_TYPE ), SubgroupEnabled );
    EnableWindow( GetDlgItem( m_hwnd, IDC_COMBO_NOTIFICATION_TYPE ), SubgroupEnabled );
    EnableWindow( GetDlgItem( m_hwnd, IDC_STATIC_NOTIFICATION_URL ), SubgroupEnabled );
    EnableWindow( GetDlgItem( m_hwnd, IDC_EDIT_NOTIFICATION_URL ), SubgroupEnabled );
}

void
CPropSheetExtension::UpdateServerFarmFallbackGroupState( 
    bool IsEnabled )
{

    EnableWindow( GetDlgItem( m_hwnd, IDC_CHECK_FALLBACK_TIMEOUT ), IsEnabled );
    
    bool SubgroupEnabled = IsEnabled && ( BST_CHECKED == IsDlgButtonChecked( m_hwnd, IDC_CHECK_FALLBACK_TIMEOUT ) );
    EnableWindow( GetDlgItem( m_hwnd, IDC_EDIT_FALLBACK_TIMEOUT ), SubgroupEnabled );
    EnableWindow( GetDlgItem( m_hwnd, IDC_COMBO_FALLBACK_TIMEOUT_UNITS ), SubgroupEnabled );

}

void
CPropSheetExtension::UpdateServerFarmGroupState(
    bool IsEnabled )
{

    EnableWindow( GetDlgItem( m_hwnd, IDC_ENABLE_SERVER_FARM ), IsEnabled );

    bool SubgroupEnabled = IsEnabled && ( BST_CHECKED == IsDlgButtonChecked( m_hwnd, IDC_ENABLE_SERVER_FARM ) );
    EnableWindow( GetDlgItem( m_hwnd, IDC_STATIC_RECONNECT ), SubgroupEnabled );
    EnableWindow( GetDlgItem( m_hwnd, IDC_EDIT_HOSTID ), SubgroupEnabled );
    UpdateServerFarmFallbackGroupState( SubgroupEnabled );


}

void
CPropSheetExtension::UpdateConfigGroupState(
    bool IsEnabled )
{

    EnableWindow( GetDlgItem( m_hwnd, IDC_RADIO_USE_INHERITED_CONFIG ), IsEnabled );
    EnableWindow( GetDlgItem( m_hwnd, IDC_RADIO_USE_CUSTOM_CONFIG ), IsEnabled );

    bool UseCustomConfig = false;

    if ( BST_CHECKED == IsDlgButtonChecked( m_hwnd, IDC_RADIO_USE_CUSTOM_CONFIG ) )
        UseCustomConfig = true;

    bool SubgroupEnabled = IsEnabled && UseCustomConfig;
    EnableWindow( GetDlgItem( m_hwnd, IDC_STATIC_CUSTOM_CONFIG ), SubgroupEnabled );
    UpdateMaxUploadGroupState( SubgroupEnabled );
    UpdateTimeoutGroupState( SubgroupEnabled );
    UpdateServerFarmGroupState( SubgroupEnabled );
    UpdateNotificationsGroupState( SubgroupEnabled );

}

void
CPropSheetExtension::UpdateUploadGroupState()
{

    EnableWindow( GetDlgItem( m_hwnd, IDC_CHECK_BITS_UPLOAD ), true );

    bool IsUploadEnabled = ( BST_CHECKED == IsDlgButtonChecked( m_hwnd, IDC_CHECK_BITS_UPLOAD ) );

    UpdateConfigGroupState( IsUploadEnabled );
 
}

void
CPropSheetExtension::UpdateCleanupState()
{
    
    bool IsEnabled = ( BST_CHECKED == IsDlgButtonChecked( m_hwnd, IDC_CHECK_BITS_UPLOAD ) );
    HRESULT Hr;

    if ( IsEnabled )
        {
        
        if ( !m_TaskSched )
            {

            Hr = ConnectToTaskScheduler( m_UNCComputerName, &m_TaskSched );

            if ( FAILED( Hr ) )
                {
                DisplayError( IDS_CANT_CONNECT_TO_TASKSCHED, Hr );
                IsEnabled = false;
                goto setstate;
                }

            }

        if ( !m_CleanupTask )
            {

            WCHAR KeyPath[ 255 ];
            DWORD BufferDataLength;

            METADATA_RECORD mdr;
            mdr.dwMDIdentifier  = m_PropertyMan->GetPropertyMetabaseID( MD_BITS_CLEANUP_WORKITEM_KEY );
            mdr.dwMDAttributes  = METADATA_NO_ATTRIBUTES;
            mdr.dwMDUserType    = ALL_METADATA;
            mdr.dwMDDataType    = STRING_METADATA;
            mdr.pbMDData        = (PBYTE)KeyPath;
            mdr.dwMDDataLen     = sizeof(KeyPath);
            mdr.dwMDDataTag     = 0;

            Hr = m_IISAdminBase->GetData(
                METADATA_MASTER_ROOT_HANDLE,
                m_MetabasePath,
                &mdr,
                &BufferDataLength );


            if ( FAILED( Hr ) )
                {
                DisplayError( IDS_CANT_CONNECT_TO_TASKSCHED, Hr );
                IsEnabled = false;
                goto setstate;
                }

            Hr = FindWorkItemForVDIR(
                m_TaskSched,
                KeyPath,
                &m_CleanupTask,
                NULL );

            if ( FAILED( Hr ) )
                {
                DisplayError( IDS_CANT_CONNECT_TO_TASKSCHED, Hr );
                IsEnabled = false;
                goto setstate;
                }

            }
        
        }

setstate:

    if ( !IsEnabled )
        CloseCleanupItems();

    EnableWindow( GetDlgItem( m_hwnd, IDC_BUTTON_SCHEDULE_CLEANUP ), IsEnabled );
    EnableWindow( GetDlgItem( m_hwnd, IDC_BUTTON_CLEANUP_NOW ), IsEnabled );

}

void 
CPropSheetExtension::CloseCleanupItems()
{
    if ( m_TaskSched )
        {
        m_TaskSched->Release();
        m_TaskSched = NULL;
        }

    if ( m_CleanupTask )
        {
        m_CleanupTask->Release();
        m_CleanupTask = NULL;
        }
}

void
CPropSheetExtension::ScheduleCleanup()
{

    //
    // Since the task scheduler caches most of the information,
    // its necessary to close the task item and reopen it to refresh it.
    // Do that now.
    //

    if ( m_CleanupTask )
        {
        m_CleanupTask->Release();
        m_CleanupTask = NULL;
        UpdateCleanupState();
        }

    if ( !m_CleanupTask )
        return;

    HRESULT Hr;
    IProvideTaskPage *PropTaskPage = NULL;

    const int NumberOfPages = 2;
    TASKPAGE PageTypes[2]   = { TASKPAGE_SCHEDULE, TASKPAGE_SETTINGS };
    HPROPSHEETPAGE Pages[2] = { NULL, NULL };

    Hr = m_CleanupTask->QueryInterface(
        __uuidof(*PropTaskPage),
        (void **)&PropTaskPage );

    if ( FAILED( Hr ) )
        goto error;

    for( int i = 0; i < NumberOfPages; i++ )
        {

        Hr = PropTaskPage->GetPage( PageTypes[i], TRUE, Pages + i );

        if ( FAILED( Hr ) )
            goto error;

        }

    PropTaskPage->Release();
    PropTaskPage = NULL;

    // 
    // Build TITLE for property page.
    // 

    WCHAR TitleFormat[ MAX_PATH ];
    WCHAR Title[ METADATA_MAX_NAME_LEN + MAX_PATH ]; 
    const WCHAR *VDirName;

    // Find last component of the metabase path.
    // It should be the virtual directory name.

    for ( VDirName = m_MetabasePath + wcslen( m_MetabasePath );
          VDirName != m_MetabasePath && L'/' != *VDirName && L'\\' != *VDirName;
          VDirName-- );

    if ( VDirName != m_MetabasePath )
        VDirName++;

    LoadString( g_hinst, IDS_WORK_ITEM_PROPERTY_PAGE_TITLE, TitleFormat, MAX_PATH-1 );

    DWORD FormatResult =
        FormatMessage(
            FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
            (LPCVOID)TitleFormat,   
            0,  
            0, 
            (LPTSTR)Title,
            ( sizeof(Title) / sizeof(*Title) ) - 1,  
            (va_list*)&VDirName );


    if ( !FormatResult )
        {
        Hr = HRESULT_FROM_WIN32( GetLastError() );
        goto error;
        }


    PROPSHEETHEADER psh;
    memset( &psh, 0, sizeof( psh ) );
    psh.dwSize      = sizeof(PROPSHEETHEADER);
    psh.dwFlags     = PSH_DEFAULT | PSH_NOAPPLYNOW;
    psh.phpage      = Pages;
    psh.nPages      = NumberOfPages;
    psh.hwndParent  = GetParent( m_hwnd );
    psh.pszCaption  = Title;

    INT_PTR Result = PropertySheet(&psh);

    if ( -1 == Result )
        {
        Hr = HRESULT_FROM_WIN32( GetLastError() );
        goto error;
        }

    return;

error:

    for( int i = 0; i < NumberOfPages; i++ )
        {
        DestroyPropertySheetPage( Pages[i] );
        }

    if ( PropTaskPage )
        PropTaskPage->Release();

    DisplayError( IDS_CANT_START_CLEANUP_SCHEDULE, Hr );
    return;

}

void
CPropSheetExtension::CleanupNow()
{

    HRESULT Hr;
    HRESULT Status;

    if ( m_CleanupInProgress )
        return;

    Hr = m_CleanupTask->GetStatus( &Status );

    if ( FAILED(Hr) )
        goto error;
    
    SYSTEMTIME MostRecentRunTime;
    Hr = m_CleanupTask->GetMostRecentRunTime( &MostRecentRunTime );

    if ( FAILED( Hr ) )
        goto error;

    SYSTEMTIME EmptyTime;
    memset( &EmptyTime, 0, sizeof(EmptyTime) );

    if ( memcmp( &EmptyTime, &MostRecentRunTime, sizeof( EmptyTime ) ) == 0 )
        {
        // Job Has never been run 
        memset( &m_PrevCleanupStartTime, 0, sizeof(EmptyTime) );
        }
    else
        {

        if ( !SystemTimeToFileTime( &MostRecentRunTime, &m_PrevCleanupStartTime ) )
            {
            Hr = HRESULT_FROM_WIN32( GetLastError() );
            goto error;
            }

        }

    if ( SCHED_S_TASK_RUNNING  != Status )
        {

        Hr = m_CleanupTask->Run();

        if ( FAILED( Hr ) )
            goto error;

        }

    m_CleanupMinWaitTimerFired = false;
    if ( !SetTimer( m_hwnd, s_CleanupMinWaitTimerID, s_CleanupMinWaitTimerInterval, NULL ) )
        {
        Hr = HRESULT_FROM_WIN32( GetLastError() );
        goto error;
        }
    
    if ( !SetTimer( m_hwnd, s_CleanupPollTimerID, s_CleanupMinWaitTimerInterval, NULL ) )
        {
        Hr = HRESULT_FROM_WIN32( GetLastError() );
        goto error;
        }

    m_CleanupInProgress     = true;
    m_CleanupCursor         = LoadCursor( NULL, (LPWSTR)IDC_WAIT );
    SetCursor( m_CleanupCursor );
    return;

error:

    KillTimer( m_hwnd, s_CleanupMinWaitTimerID );
    KillTimer( m_hwnd, s_CleanupPollTimerID );
    SetCursor( (HCURSOR)GetClassLongPtr( m_hwnd, GCLP_HCURSOR ) );
    DisplayError( IDS_CANT_START_CLEANUP, Hr );

}

void 
CPropSheetExtension::CleanupTimer( 
    UINT TimerID )
{

    HRESULT Hr;

    if ( s_CleanupMinWaitTimerID != TimerID &&
         s_CleanupPollTimerID != TimerID )
        return;

    if ( s_CleanupMinWaitTimerID )
        {
        m_CleanupMinWaitTimerFired = true;
        KillTimer( m_hwnd, s_CleanupMinWaitTimerID );
        }

    if ( !m_CleanupMinWaitTimerFired )
        return; // keep cursor active for minimum time period

    //
    // Since the task scheduler caches most of the information,
    // its necessary to close the task item and reopen it to refresh it.
    // Do that now.
    //

    if ( m_CleanupTask )
        {
        m_CleanupTask->Release();
        m_CleanupTask = NULL;
        UpdateCleanupState();
        }

    if ( !m_CleanupTask )
        {
        // shut down the polling
        KillTimer( m_hwnd, s_CleanupPollTimerID );
        SetCursor( (HCURSOR)GetClassLongPtr( m_hwnd, GCLP_HCURSOR ) );
        m_CleanupInProgress = false;
        return;
        }


    HRESULT Status;
    if ( FAILED( m_CleanupTask->GetStatus( &Status ) ) )
        return;

    if ( Status == SCHED_S_TASK_RUNNING )
        return; // Not done yet, keep checking

    DWORD ExitCode;
    Hr = m_CleanupTask->GetExitCode( &ExitCode );

    if ( Hr == SCHED_S_TASK_HAS_NOT_RUN )
        return; // The task probably hasn't run yet

    if ( FAILED(Hr) )
        {
        // If this API fails it returns the error
        // that MSTASK received when starting the job.

        KillTimer( m_hwnd, s_CleanupPollTimerID );
        SetCursor( (HCURSOR)GetClassLongPtr( m_hwnd, GCLP_HCURSOR ) );
        m_CleanupInProgress = false;
        DisplayError( IDS_CANT_START_CLEANUP, Hr );        
        return;
        }

    SYSTEMTIME MostRecentRunTime;
    if ( FAILED( m_CleanupTask->GetMostRecentRunTime( &MostRecentRunTime ) ) )
        return;

    FILETIME MostRecentRunTimeAsFileTime;


    if ( !SystemTimeToFileTime(&MostRecentRunTime, &MostRecentRunTimeAsFileTime ) )
        return; 

    if ( CompareFileTime( &MostRecentRunTimeAsFileTime, &m_PrevCleanupStartTime ) < 0 )
        return; // task may not have scheduled yet, keep checking

    //
    // At this point we know the following:
    // 1. The cursor was help in the wait state for the minimum time
    // 2. The task is not running
    // 3. The task started sometime after our time mark
    //
    // So, cleanup timers and revert back to the original icon
    //

    KillTimer( m_hwnd, s_CleanupPollTimerID );
    SetCursor( (HCURSOR)GetClassLongPtr( m_hwnd, GCLP_HCURSOR ) );
    m_CleanupInProgress = false;
}

bool
CPropSheetExtension::DisplayWarning(
    UINT StringId )
{

    WCHAR ErrorString[ MAX_PATH * 2 ];
    WCHAR BITSSettings[ MAX_PATH ];
    
    LoadString( g_hinst, StringId, ErrorString, MAX_PATH*2-1 );
    LoadString( g_hinst, IDS_BITS_EXT, BITSSettings, MAX_PATH-1 );

    return ( IDOK == MessageBox( m_hwnd, ErrorString, BITSSettings, MB_OKCANCEL | MB_ICONWARNING ) ); 

}

void 
CPropSheetExtension::DisplayError( 
    UINT StringId )
{

    WCHAR ErrorString[ MAX_PATH * 2 ];
    WCHAR BITSSettings[ MAX_PATH ];
    
    LoadString( g_hinst, StringId, ErrorString, MAX_PATH*2-1 );
    LoadString( g_hinst, IDS_BITS_EXT, BITSSettings, MAX_PATH-1 );

    MessageBox( m_hwnd, ErrorString, BITSSettings, MB_OK | MB_ICONWARNING ) ; 

}

void
CPropSheetExtension::DisplayError(
    UINT StringId,
    HRESULT Hr )
{
    WCHAR ErrorString[ MAX_PATH * 2 ];
    WCHAR BITSSettings[ MAX_PATH ];
    
    LoadString( g_hinst, StringId, ErrorString, MAX_PATH*2-1 );
    LoadString( g_hinst, IDS_BITS_EXT, BITSSettings, MAX_PATH-1 );

    WCHAR * SystemMessage = NULL;
    DWORD ReturnValue =
        FormatMessage( 
            FORMAT_MESSAGE_ALLOCATE_BUFFER | 
            FORMAT_MESSAGE_FROM_SYSTEM | 
            FORMAT_MESSAGE_IGNORE_INSERTS,
            NULL,
            (DWORD)Hr,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
            (LPTSTR) &SystemMessage,
            0,
            NULL 
            );

    if ( !ReturnValue )
        MessageBox( m_hwnd, ErrorString, BITSSettings, MB_OK | MB_ICONWARNING );
    else
        {

        WCHAR CombinedErrorString[ MAX_PATH * 4 ];

        StringCbPrintfW( 
            CombinedErrorString, 
            sizeof( CombinedErrorString ), 
            L"%s\r\n\r\n%s", 
            ErrorString, 
            SystemMessage );

        MessageBox( m_hwnd, CombinedErrorString, BITSSettings, MB_OK | MB_ICONWARNING );

        LocalFree( SystemMessage );

        }

}

bool
CPropSheetExtension::GetDlgItemTextAsInteger(
    UINT Id,
    UINT MaxString,
    UINT64 & Value )
{

    WCHAR *DlgString    = NULL;
    WCHAR *p            = NULL;
    Value = 0;

    DlgString = new WCHAR[ MaxString + 1 ];

    if ( !DlgString )
        goto failed;

    GetDlgItemText( m_hwnd, Id, DlgString, MaxString );

    if ( L'\0' == *DlgString )
		return false;

    int CharsRequired =
        FoldString( 
            MAP_FOLDDIGITS,
            DlgString,
            -1,
            NULL,
            0 );

    if ( !CharsRequired )
        return false;

    p = new WCHAR[ CharsRequired + 1 ];

    if ( !p )
        goto failed;

    CharsRequired =
        FoldString(
            MAP_FOLDDIGITS,
            DlgString,
            -1,
            p,
            CharsRequired );

    if ( !CharsRequired )
        return false;

    // accumulate value
    while(L'\0' != *p )
        {

        UINT64 ExtendedValue = Value * 10;
        if ( ExtendedValue / 10 != Value )
            return false;

        Value = ExtendedValue;

        if ( *p < L'0' || *p > L'9' )
            return false;


        UINT64 ValueToAdd = *p - L'0';

        if ( 0xFFFFFFFFFFFFFFFF - ValueToAdd < Value )
            return false; //overflow

        Value += ValueToAdd;
        p++;

        }

    delete[] DlgString;
    delete[] p;
    
    return true;

failed:
    
    delete[] DlgString;
    delete[] p;
    return false;

}

void
CPropSheetExtension::SetDlgItemTextAsInteger( 
    UINT Id, 
    UINT64 Value )
{

    WCHAR RawString[ 25 ]; // 18446744073709551615

    WCHAR *p = RawString + 25 - 1;
    *p-- = L'\0';

	if ( !Value )
	    {
		*p = L'0';
	    }
	else
    	{

        do
            {
            UINT64 Remainder = Value % 10;
            Value = Value / 10;
            *p-- = ( L'0' + (WCHAR)Remainder );
            } while( Value );

    	p++;

    	}

    NUMBERFMT Format;
    memset( &Format, 0, sizeof(Format) );
    Format.lpDecimalSep = L"";
    Format.lpThousandSep = L"";

    int CharsRequired =
        GetNumberFormat(
            NULL,
            0,
            p,
            &Format,  
            NULL,
            0 );

    if ( !CharsRequired )
        return;

    WCHAR *ConvertedString = new WCHAR[ CharsRequired ];  

    if ( !ConvertedString )
        return;

    CharsRequired =
        GetNumberFormat(
            NULL,
            0,
            p,
            &Format,
            ConvertedString,
            CharsRequired );


    if ( CharsRequired )
        SetDlgItemText( m_hwnd, Id, ConvertedString );

    delete[] ConvertedString;

}

bool
CPropSheetExtension::ValidateValues( )
{

    // Validate the maximum upload

    if ( BST_CHECKED == IsDlgButtonChecked( m_hwnd, IDC_CHECK_LIMIT_MAX_UPLOAD ) ) 
        {
        
        LRESULT MaxUploadUnit = SendDlgItemMessage( m_hwnd, IDC_COMBO_MAX_UPLOAD_UNITS, CB_GETCURSEL, 0, 0 );
        
        UINT64 MaxUpload;

        if (!GetDlgItemTextAsInteger( IDC_EDIT_MAX_UPLOAD, MAX_PATH, MaxUpload ) ||
             MaxUpload > s_MaxUploadLimits[MaxUploadUnit] )
            {
            DisplayError( IDS_MAX_UPLOAD_INVALID );
            return false;
            }
        }

    // Validate the session timeout

    if ( BST_CHECKED == IsDlgButtonChecked( m_hwnd, IDC_DELETE_FILES ) )
        {

        LRESULT SessionTimeoutUnit =
            SendDlgItemMessage( m_hwnd, IDC_COMBO_SESSION_TIMEOUT_UNITS, CB_GETCURSEL, 0, 0 );

        UINT64 SessionTimeout;

        if ( !GetDlgItemTextAsInteger( IDC_EDIT_SESSION_TIMEOUT, MAX_PATH, SessionTimeout ) ||
             SessionTimeout > s_TimeoutLimits[SessionTimeoutUnit] )
            {
            DisplayError( IDS_SESSION_TIMEOUT_INVALID );
            return false;
            }

        }


    // Validate the server farm settings

    if ( BST_CHECKED == IsDlgButtonChecked( m_hwnd, IDC_ENABLE_SERVER_FARM ) )
        {

        LRESULT HostIdLength =
            SendDlgItemMessage( m_hwnd, IDC_EDIT_HOSTID, WM_GETTEXTLENGTH, 0, 0 );

        if ( !HostIdLength )
            {
            DisplayError( IDS_HOST_ID_INVALID );
            return false;
            }

        if ( BST_CHECKED == IsDlgButtonChecked( m_hwnd, IDC_CHECK_FALLBACK_TIMEOUT ) )
            {

            LRESULT FallbackTimeoutUnit =
                SendDlgItemMessage( m_hwnd, IDC_COMBO_FALLBACK_TIMEOUT_UNITS, CB_GETCURSEL, 0, 0 );

            UINT64 FallbackTimeout;

            if ( !GetDlgItemTextAsInteger( IDC_EDIT_FALLBACK_TIMEOUT, MAX_PATH, FallbackTimeout ) ||
                 FallbackTimeout > s_TimeoutLimits[ FallbackTimeoutUnit ] )
                {
                DisplayError( IDS_FALLBACK_TIMEOUT_INVALID );
                return false;
                }

            }

        }

    // Validate the notification settings

    if ( BST_CHECKED == IsDlgButtonChecked( m_hwnd, IDC_CHECK_ENABLE_NOTIFICATIONS ) )
        {

        LRESULT NotificationURLLength =
            SendDlgItemMessage( m_hwnd, IDC_EDIT_NOTIFICATION_URL, WM_GETTEXTLENGTH, 0, 0 );

        if ( !NotificationURLLength )
            {
            DisplayError( IDS_NOTIFICATION_URL_INVALID );
            return false;
            }

        }


    return WarnAboutAccessFlags();
}

bool 
CPropSheetExtension::WarnAboutAccessFlags()
{
  
    if ( m_EnabledSettingChanged &&
         ( BST_CHECKED == IsDlgButtonChecked( m_hwnd, IDC_CHECK_BITS_UPLOAD ) ) )
        {

        HRESULT Hr = S_OK;
        DWORD BufferRequired = 0;
        DWORD AccessFlags = 0;

        METADATA_RECORD mdr;
        mdr.dwMDIdentifier  = MD_ACCESS_PERM;
        mdr.dwMDAttributes  = METADATA_INHERIT;
        mdr.dwMDUserType    = ALL_METADATA;
        mdr.dwMDDataType    = DWORD_METADATA;
        mdr.pbMDData        = (unsigned char*)&AccessFlags;
        mdr.dwMDDataLen     = sizeof( AccessFlags );
        mdr.dwMDDataTag     = 0;

        Hr = m_IISAdminBase->GetData(
            METADATA_MASTER_ROOT_HANDLE,
            m_MetabasePath,
            &mdr,
            &BufferRequired );

        if ( FAILED( Hr ) )
            {
            DisplayError( IDS_CANT_ACCESS_METABASE, Hr );
            return false;
            }

        if ( AccessFlags & ( MD_ACCESS_EXECUTE | MD_ACCESS_SCRIPT ) )
            {
            return DisplayWarning( IDS_ACCESS_PERMISSION_WARNING );
            }

        }
    

    return true;
}


HRESULT
CPropSheetExtension::LoadInheritedDWORD(
    METADATA_HANDLE mdHandle,
    WCHAR * pKeyName,
    DWORD PropId,
    DWORD * pReturn )
{

    METADATA_RECORD mdr;
    DWORD BufferRequired;
    HRESULT Hr;

    mdr.dwMDIdentifier  = m_PropertyMan->GetPropertyMetabaseID( PropId );
    mdr.dwMDAttributes  = METADATA_INHERIT | METADATA_PARTIAL_PATH;
    mdr.dwMDUserType    = ALL_METADATA;
    mdr.dwMDDataType    = DWORD_METADATA;
    mdr.pbMDData        = (PBYTE)pReturn;
    mdr.dwMDDataLen     = sizeof(*pReturn);
    mdr.dwMDDataTag     = 0;

    Hr = m_IISAdminBase->GetData(
        mdHandle,
        pKeyName,
        &mdr,
        &BufferRequired );

    return Hr;

}

HRESULT
CPropSheetExtension::LoadInheritedString(
    METADATA_HANDLE mdHandle,
    WCHAR * pKeyName,
    DWORD PropId,
    WCHAR ** pReturn )
{

    *pReturn = NULL;
    METADATA_RECORD mdr;
    DWORD BufferRequired;
    HRESULT Hr;

    mdr.dwMDIdentifier  = m_PropertyMan->GetPropertyMetabaseID( PropId );
    mdr.dwMDAttributes  = METADATA_INHERIT | METADATA_PARTIAL_PATH;
    mdr.dwMDUserType    = ALL_METADATA;
    mdr.dwMDDataType    = STRING_METADATA;
    mdr.pbMDData        = (PBYTE)NULL;
    mdr.dwMDDataLen     = 0;
    mdr.dwMDDataTag     = 0;

    Hr = m_IISAdminBase->GetData(
             mdHandle,
             pKeyName,
             &mdr,
             &BufferRequired );

    if ( FAILED( Hr ) && HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER ) != Hr )
        return Hr;

    *pReturn = new WCHAR[ BufferRequired ];

    if ( !*pReturn )
        return E_OUTOFMEMORY;

    mdr.dwMDDataLen     = BufferRequired;
    mdr.pbMDData        = (BYTE*)*pReturn;

    Hr = m_IISAdminBase->GetData(
             mdHandle,
             pKeyName,
             &mdr,
             &BufferRequired );

    if ( FAILED( Hr ) )
        {
        delete *pReturn;
        *pReturn = NULL;
        return Hr;
        }

    return Hr;
}

void
CPropSheetExtension::LoadInheritedValues()
{

    HRESULT Hr;
    METADATA_RECORD mdr;
    METADATA_HANDLE mdHandle = NULL;
    DWORD BufferRequired;

    m_InheritedValues.NotificationURL   = NULL;
    m_InheritedValues.HostId            = NULL;

    //
    // A huge trick is used here to obtain the inherited properties.  
    // The idea is to take a key which probably doesn't exit at the same
    // level as the key for the virtual directory.  A guid looks
    // like a good key name to use that probably doesn't exist.
    //

    GUID guid;
    WCHAR unusedkey[50]; 
    
    CoCreateGuid( &guid );
    StringFromGUID2( guid, unusedkey, 49 );

    Hr = m_IISAdminBase->OpenKey(
        METADATA_MASTER_ROOT_HANDLE,
        m_MetabaseParent,
        METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
        10000, // 10 seconds
        &mdHandle );

    if ( FAILED( Hr ) )
        goto error;

    // Load the maximum upload size


    {
        WCHAR *MaximumUploadSize = NULL;

        if ( FAILED( 
            Hr = LoadInheritedString(
                mdHandle,
                unusedkey,
                MD_BITS_MAX_FILESIZE,
                &MaximumUploadSize ) ) )
                goto error;
    
        if ( wcscmp( MaximumUploadSize, MD_BITS_UNLIMITED_MAX_FILESIZE) == 0 )
            m_InheritedValues.MaxUploadSize = MD_BITS_UNLIMITED_MAX_FILESIZE_AS_INT64;
        else
            swscanf( MaximumUploadSize, L"%I64u", &m_InheritedValues.MaxUploadSize );

        delete MaximumUploadSize;


    }


    // Load the session timeout

    if ( FAILED( 
            Hr = LoadInheritedDWORD(
                mdHandle,
                unusedkey,
                MD_BITS_NO_PROGRESS_TIMEOUT,
                &m_InheritedValues.SessionTimeout ) ) )
        goto error;

    // Load the notification settings

    if ( FAILED( 
        Hr = LoadInheritedDWORD(
            mdHandle,
            unusedkey,
            MD_BITS_NOTIFICATION_URL_TYPE,
            (DWORD*)&m_InheritedValues.NotificationType ) ) )
        goto error;

    if ( FAILED( 
        Hr = LoadInheritedString(
            mdHandle,
            unusedkey,
            MD_BITS_NOTIFICATION_URL,
            &m_InheritedValues.NotificationURL ) ) )
        goto error;


    // Load the web farm settings

    if ( FAILED( 
        Hr = LoadInheritedString(
            mdHandle,
            unusedkey,
            MD_BITS_HOSTID,
            &m_InheritedValues.HostId ) ) )
        goto error;

    if ( FAILED( 
        Hr = LoadInheritedDWORD(
            mdHandle,
            unusedkey,
            MD_BITS_HOSTID_FALLBACK_TIMEOUT,
            (DWORD*)&m_InheritedValues.FallbackTimeout ) ) )
        goto error;


    m_IISAdminBase->CloseKey( mdHandle );
    mdHandle = NULL;

    return;

error:

    if ( mdHandle )
        m_IISAdminBase->CloseKey( mdHandle );

    // use default values
    m_InheritedValues.MaxUploadSize     = MD_DEFAULT_BITS_MAX_FILESIZE_AS_INT64;
    m_InheritedValues.SessionTimeout    = MD_DEFAULT_NO_PROGESS_TIMEOUT;
    m_InheritedValues.NotificationType  = MD_DEFAULT_BITS_NOTIFICATION_URL_TYPE;

    delete m_InheritedValues.NotificationURL;
    m_InheritedValues.NotificationURL   = NULL;

    delete m_InheritedValues.HostId;
    m_InheritedValues.HostId            = NULL;

    DisplayError( IDS_CANT_LOAD_INHERITED_VALUES, Hr );

}

void 
CPropSheetExtension::LoadMaxUploadValue( UINT64 MaxValue )
{

    if ( MaxValue == MD_BITS_UNLIMITED_MAX_FILESIZE_AS_INT64 )
        {
        SendDlgItemMessage(m_hwnd, IDC_COMBO_MAX_UPLOAD_UNITS, CB_SETCURSEL, 0, 0 );
        SetDlgItemText( m_hwnd, IDC_EDIT_MAX_UPLOAD, L"" );
        CheckDlgButton( m_hwnd, IDC_CHECK_LIMIT_MAX_UPLOAD, BST_UNCHECKED );
        return;
        }
    
    int Scale = s_NumberOfMaxUploadUnitsScales-1; 
    while ( MaxValue % s_MaxUploadUnitsScales[Scale] )
        Scale--;


    SendDlgItemMessage(m_hwnd, IDC_COMBO_MAX_UPLOAD_UNITS, CB_SETCURSEL, Scale, 0 );
    SetDlgItemTextAsInteger( IDC_EDIT_MAX_UPLOAD, MaxValue / s_MaxUploadUnitsScales[Scale] );
    CheckDlgButton( m_hwnd, IDC_CHECK_LIMIT_MAX_UPLOAD, BST_CHECKED );

}

void
CPropSheetExtension::LoadTimeoutValue(
    DWORD CheckId,
    DWORD EditId,
    DWORD UnitId,
    DWORD Value )
{

    if ( MD_BITS_NO_TIMEOUT == Value )
        {
        SendDlgItemMessage( m_hwnd, UnitId, CB_SETCURSEL, 0, 0 );
        SetDlgItemText( m_hwnd, EditId, L"");
        CheckDlgButton( m_hwnd, CheckId, BST_UNCHECKED );
        return;        
        }

    int Scale = s_NumberOfTimeoutUnitsScales-1; 
    while ( Value % s_TimeoutUnitsScales[Scale] )
        Scale--;

    SendDlgItemMessage( m_hwnd, UnitId, CB_SETCURSEL, Scale, 0 );
    SetDlgItemTextAsInteger( EditId, 
                             Value / s_TimeoutUnitsScales[Scale] );
    CheckDlgButton( m_hwnd, CheckId, BST_CHECKED );


}

void
CPropSheetExtension::LoadTimeoutValue( DWORD SessionTimeout )
{

    LoadTimeoutValue(
        IDC_DELETE_FILES,                   // check id
        IDC_EDIT_SESSION_TIMEOUT,           // edit id
        IDC_COMBO_SESSION_TIMEOUT_UNITS,    // unit id
        SessionTimeout );

}

void
CPropSheetExtension::LoadNotificationValues( 
    BITS_SERVER_NOTIFICATION_TYPE NotificationType,
    WCHAR *NotificationURL )
{

    if ( BITS_NOTIFICATION_TYPE_NONE == NotificationType )
        {
        SetDlgItemText( m_hwnd, IDC_EDIT_NOTIFICATION_URL, L"" );
        SendDlgItemMessage( m_hwnd, IDC_COMBO_NOTIFICATION_TYPE, CB_SETCURSEL, 0, 0 );
        CheckDlgButton( m_hwnd, IDC_CHECK_ENABLE_NOTIFICATIONS, BST_UNCHECKED );
        return;
        }

    SendDlgItemMessage( m_hwnd, IDC_COMBO_NOTIFICATION_TYPE, CB_SETCURSEL, 
                        (WPARAM)NotificationType - BITS_NOTIFICATION_TYPE_POST_BYREF, 0 ); 
    SetDlgItemText( m_hwnd, IDC_EDIT_NOTIFICATION_URL, NotificationURL );
    CheckDlgButton( m_hwnd, IDC_CHECK_ENABLE_NOTIFICATIONS, BST_CHECKED );
}

void
CPropSheetExtension::LoadServerFarmSettings( 
    WCHAR *HostId,
    DWORD FallbackTimeout )
{

    if ( !HostId || !*HostId )
        {
        SetDlgItemText( m_hwnd, IDC_EDIT_HOSTID, L"" );
        CheckDlgButton( m_hwnd, IDC_ENABLE_SERVER_FARM, BST_UNCHECKED );

        LoadTimeoutValue(
            IDC_CHECK_FALLBACK_TIMEOUT,
            IDC_EDIT_FALLBACK_TIMEOUT,
            IDC_COMBO_FALLBACK_TIMEOUT_UNITS,
            FallbackTimeout );
        return;
        }

    SetDlgItemText( m_hwnd, IDC_EDIT_HOSTID, HostId );
    CheckDlgButton( m_hwnd, IDC_ENABLE_SERVER_FARM, BST_CHECKED );
    
    LoadTimeoutValue(
        IDC_CHECK_FALLBACK_TIMEOUT,
        IDC_EDIT_FALLBACK_TIMEOUT,
        IDC_COMBO_FALLBACK_TIMEOUT_UNITS,
        FallbackTimeout );

}

void 
CPropSheetExtension::LoadValues( )
{

    HRESULT Hr;
    HRESULT LastError = S_OK;
    BOOL IsBitsEnabled = FALSE;

    m_SettingsChanged = m_EnabledSettingChanged = false;

    Hr = IsBITSEnabledOnVDir(
        m_PropertyMan,
        m_IISAdminBase,
        m_MetabasePath,
        &IsBitsEnabled );

    if ( IsBitsEnabled )
        CheckDlgButton( m_hwnd, IDC_CHECK_BITS_UPLOAD, BST_CHECKED );
    else
        CheckDlgButton( m_hwnd, IDC_CHECK_BITS_UPLOAD, BST_UNCHECKED );

    if ( FAILED(Hr) )
        LastError = Hr;

    bool AllDefaults = true;

    METADATA_RECORD mdr;
    DWORD BufferRequired;

    // Load the maximum upload size
    WCHAR MaximumUploadSize[MAX_PATH];

    mdr.dwMDIdentifier  = m_PropertyMan->GetPropertyMetabaseID( MD_BITS_MAX_FILESIZE );
	mdr.dwMDAttributes  = METADATA_INHERIT | METADATA_ISINHERITED;
	mdr.dwMDUserType    = ALL_METADATA;
	mdr.dwMDDataType    = STRING_METADATA;
    mdr.pbMDData        = (PBYTE)MaximumUploadSize;
	mdr.dwMDDataLen     = sizeof(MaximumUploadSize);
    mdr.dwMDDataTag     = 0;

    Hr = m_IISAdminBase->GetData(
        METADATA_MASTER_ROOT_HANDLE,
        m_MetabasePath,
        &mdr,
        &BufferRequired );

    if ( FAILED( Hr ) )
        {
        LastError = Hr;
        LoadMaxUploadValue( m_InheritedValues.MaxUploadSize );
        }
    else
        {
                                          
        if ( !( mdr.dwMDAttributes & METADATA_ISINHERITED ) )
            AllDefaults = false;

        UINT64 MaximumUploadSizeInt;
        swscanf( MaximumUploadSize, L"%I64u", &MaximumUploadSizeInt );

        LoadMaxUploadValue( MaximumUploadSizeInt ); 
        
        }

    // Load the session timeout
    DWORD SessionTimeout = m_InheritedValues.SessionTimeout;
        
    mdr.dwMDIdentifier  = m_PropertyMan->GetPropertyMetabaseID( MD_BITS_NO_PROGRESS_TIMEOUT );
    mdr.dwMDAttributes  = METADATA_INHERIT | METADATA_ISINHERITED;
    mdr.dwMDUserType    = ALL_METADATA;
    mdr.dwMDDataType    = DWORD_METADATA;
    mdr.pbMDData        = (PBYTE)&SessionTimeout;
    mdr.dwMDDataLen     = sizeof(SessionTimeout);
    mdr.dwMDDataTag     = 0;

    Hr = m_IISAdminBase->GetData(
        METADATA_MASTER_ROOT_HANDLE,
        m_MetabasePath,
        &mdr,
        &BufferRequired );

    if ( FAILED( Hr ) )
        { 
        LastError = Hr;
        LoadTimeoutValue( m_InheritedValues.SessionTimeout ); 
        }
    else
        {
        
        if ( !( mdr.dwMDAttributes & METADATA_ISINHERITED ) )
            AllDefaults = false;

        LoadTimeoutValue( SessionTimeout );
        }

    // Load the notification settings
    DWORD NotificationType;
    mdr.dwMDIdentifier  = m_PropertyMan->GetPropertyMetabaseID( MD_BITS_NOTIFICATION_URL_TYPE );
    mdr.dwMDAttributes  = METADATA_INHERIT | METADATA_ISINHERITED;
    mdr.dwMDUserType    = ALL_METADATA;
    mdr.dwMDDataType    = DWORD_METADATA;
    mdr.pbMDData        = (PBYTE)&NotificationType;
    mdr.dwMDDataLen     = sizeof(NotificationType);
    mdr.dwMDDataTag     = 0;

    Hr = m_IISAdminBase->GetData(
        METADATA_MASTER_ROOT_HANDLE,
        m_MetabasePath,
        &mdr,
        &BufferRequired );

    if ( FAILED( Hr ) )
        {
        LastError = Hr;
        LoadNotificationValues( m_InheritedValues.NotificationType, m_InheritedValues.NotificationURL );
        }
    else 
        {
        
        if ( !( mdr.dwMDAttributes & METADATA_ISINHERITED ) )
            AllDefaults = false;

        if ( BITS_NOTIFICATION_TYPE_NONE == NotificationType )
            LoadNotificationValues( BITS_NOTIFICATION_TYPE_NONE, L"" );
        else
            {
            mdr.dwMDIdentifier  = m_PropertyMan->GetPropertyMetabaseID( MD_BITS_NOTIFICATION_URL );
            mdr.dwMDAttributes  = METADATA_INHERIT | METADATA_ISINHERITED;
            mdr.dwMDUserType    = ALL_METADATA;
            mdr.dwMDDataType    = STRING_METADATA;
            mdr.pbMDData        = (PBYTE)NULL;
            mdr.dwMDDataLen     = 0;
            mdr.dwMDDataTag     = 0;

            Hr = m_IISAdminBase->GetData(
                     METADATA_MASTER_ROOT_HANDLE,
                     m_MetabasePath,
                     &mdr,
                     &BufferRequired );

            if ( FAILED( Hr ) && HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER ) != Hr )
                {
                LastError = Hr;
                LoadNotificationValues( (BITS_SERVER_NOTIFICATION_TYPE)NotificationType, L"" );
                }

            else
                {

                BYTE *URL = new BYTE[ BufferRequired ];
                
                if ( !URL )
                    Hr = E_OUTOFMEMORY;
                
                mdr.dwMDDataLen     = BufferRequired;
                mdr.pbMDData        = URL;

                if ( BufferRequired )
                    {
                    
                    Hr = m_IISAdminBase->GetData(
                             METADATA_MASTER_ROOT_HANDLE,
                             m_MetabasePath,
                             &mdr,
                             &BufferRequired );

                    }


                if ( FAILED( Hr ) )
                    {
                    LastError = Hr;
                    LoadNotificationValues( (BITS_SERVER_NOTIFICATION_TYPE)NotificationType, L"" );
                    }
                else
                    {
                    if ( !( mdr.dwMDAttributes & METADATA_ISINHERITED ) )
                        AllDefaults = false;
                    LoadNotificationValues( (BITS_SERVER_NOTIFICATION_TYPE)NotificationType, (WCHAR*)URL );

                    }

                delete[] URL;

                }
            }
        }

    // Load the HostId
    {

        WCHAR *HostIdString     = m_InheritedValues.HostId;
        DWORD  FallbackTimeout  = m_InheritedValues.FallbackTimeout;

        mdr.dwMDIdentifier  = m_PropertyMan->GetPropertyMetabaseID( MD_BITS_HOSTID_FALLBACK_TIMEOUT );
        mdr.dwMDAttributes  = METADATA_INHERIT | METADATA_ISINHERITED;
        mdr.dwMDUserType    = ALL_METADATA;
        mdr.dwMDDataType    = DWORD_METADATA;
        mdr.pbMDData        = (PBYTE)&FallbackTimeout;
        mdr.dwMDDataLen     = sizeof( FallbackTimeout );
        mdr.dwMDDataTag     = 0;

        Hr = m_IISAdminBase->GetData(
                 METADATA_MASTER_ROOT_HANDLE,
                 m_MetabasePath,
                 &mdr,
                 &BufferRequired );

        if ( FAILED( Hr ) )
            FallbackTimeout = m_InheritedValues.FallbackTimeout;
        else
            {

            if ( !( mdr.dwMDAttributes & METADATA_ISINHERITED ) )
                AllDefaults = false;

            }

        mdr.dwMDIdentifier  = m_PropertyMan->GetPropertyMetabaseID( MD_BITS_HOSTID );
        mdr.dwMDAttributes  = METADATA_INHERIT | METADATA_ISINHERITED;
        mdr.dwMDUserType    = ALL_METADATA;
        mdr.dwMDDataType    = STRING_METADATA;
        mdr.pbMDData        = (PBYTE)NULL;
        mdr.dwMDDataLen     = 0;
        mdr.dwMDDataTag     = 0;

        Hr = m_IISAdminBase->GetData(
                 METADATA_MASTER_ROOT_HANDLE,
                 m_MetabasePath,
                 &mdr,
                 &BufferRequired );

        BYTE *HostId = NULL;

        if ( SUCCEEDED( Hr ) || ( Hr == HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER ) ) )
            {

            HostId				= new BYTE[ BufferRequired ];
            mdr.dwMDDataLen     = BufferRequired;
            mdr.pbMDData        = HostId;

            if ( !HostId )
                Hr = E_OUTOFMEMORY;

            else
                {

                Hr = m_IISAdminBase->GetData(
                         METADATA_MASTER_ROOT_HANDLE,
                         m_MetabasePath,
                         &mdr,
                         &BufferRequired );

                }


            if ( SUCCEEDED( Hr ) )
                {

                if ( !( mdr.dwMDAttributes & METADATA_ISINHERITED ) )
                     AllDefaults = false;

                HostIdString = (WCHAR*)HostId;

                }
            }

        LoadServerFarmSettings( HostIdString, FallbackTimeout );
        delete[] HostId;

    }

    CheckDlgButton( m_hwnd, IDC_CHECK_BITS_UPLOAD, IsBitsEnabled ? BST_CHECKED : BST_UNCHECKED );

    CheckRadioButton( m_hwnd, IDC_RADIO_USE_INHERITED_CONFIG, IDC_RADIO_USE_CUSTOM_CONFIG,
                      AllDefaults ? IDC_RADIO_USE_INHERITED_CONFIG : IDC_RADIO_USE_CUSTOM_CONFIG );
    UpdateUploadGroupState( );

    if ( FAILED( LastError ) )
        DisplayError( IDS_CANT_LOAD_VALUES, LastError );

    UpdateCleanupState( );
}
    
HRESULT 
CPropSheetExtension::SaveMetadataString(
    METADATA_HANDLE mdHandle,
    DWORD PropId,
    WCHAR *Value )
{

    
    METADATA_RECORD mdr;
    mdr.dwMDIdentifier  = m_PropertyMan->GetPropertyMetabaseID( PropId );
 	mdr.dwMDAttributes  = METADATA_INHERIT;
 	mdr.dwMDUserType    = m_PropertyMan->GetPropertyUserType( PropId );
 	mdr.dwMDDataType    = STRING_METADATA;
    mdr.pbMDData        = (PBYTE)Value;
 	mdr.dwMDDataLen     = sizeof(WCHAR) * ( wcslen( Value ) + 1 );
    mdr.dwMDDataTag     = 0;

    HRESULT Hr = m_IISAdminBase->SetData(
        mdHandle,
        NULL,
        &mdr );

    return Hr;

}

HRESULT
CPropSheetExtension::SaveMetadataDWORD(
    METADATA_HANDLE mdHandle,
    DWORD PropId,
    DWORD Value )
{

   METADATA_RECORD mdr;

   mdr.dwMDIdentifier  = m_PropertyMan->GetPropertyMetabaseID( PropId );
   mdr.dwMDAttributes  = METADATA_INHERIT;
   mdr.dwMDUserType    = m_PropertyMan->GetPropertyUserType( PropId );
   mdr.dwMDDataType    = DWORD_METADATA;
   mdr.pbMDData        = (PBYTE)&Value;
   mdr.dwMDDataLen     = sizeof(DWORD);
   mdr.dwMDDataTag     = 0;

   HRESULT Hr = m_IISAdminBase->SetData(
       mdHandle,
       NULL,
       &mdr );

   return Hr;

}

void
CPropSheetExtension::MergeError(
    HRESULT Hr,
    HRESULT * LastHr )
{

    if ( FAILED( Hr ) )
        *LastHr = Hr;

}

HRESULT
CPropSheetExtension::SaveSimpleString(
    METADATA_HANDLE mdHandle,
    DWORD PropId,
    DWORD EditId )
{

    LRESULT StringLength = 
        SendDlgItemMessage( m_hwnd, EditId, WM_GETTEXTLENGTH, 0, 0 ); 

    WCHAR *String = new WCHAR[ StringLength + 1 ];

    if ( !String )
        return E_OUTOFMEMORY;

    GetDlgItemText( m_hwnd, EditId, String, (DWORD)(StringLength + 1));

    HRESULT Hr =   
        SaveMetadataString(
            mdHandle,
            PropId,
            String );

    delete[] String;
    return Hr;

}

HRESULT
CPropSheetExtension::SaveTimeoutValue(
    METADATA_HANDLE mdHandle,
    DWORD PropId,
    DWORD CheckId,
    DWORD EditId,
    DWORD UnitId )
{


    if ( BST_UNCHECKED == IsDlgButtonChecked( m_hwnd, CheckId ) )
        {
    
        return
            SaveMetadataDWORD(
                mdHandle,
                PropId,
                MD_BITS_NO_TIMEOUT );
        
        }

    LRESULT TimeoutUnitsSelect = 
        SendDlgItemMessage( m_hwnd, UnitId, CB_GETCURSEL, 0, 0 );

    UINT64 Timeout64;
    GetDlgItemTextAsInteger( EditId, MAX_PATH, Timeout64 );
    Timeout64 *= s_TimeoutUnitsScales[ TimeoutUnitsSelect ];
    DWORD Timeout = (DWORD)Timeout64;

    return
        SaveMetadataDWORD(
            mdHandle,
            PropId,
            Timeout );

}


void 
CPropSheetExtension::SetValues( )
{ 

    HRESULT Hr;
    HRESULT LastError = S_OK;
    METADATA_HANDLE mdHandle = NULL;
    
    if ( m_EnabledSettingChanged )
        {
        
        UINT BitsUploadButton = IsDlgButtonChecked( m_hwnd, IDC_CHECK_BITS_UPLOAD );

        if ( BST_CHECKED == BitsUploadButton )
            {
            Hr = m_IBITSSetup->EnableBITSUploads();
            }
        else
            {
            Hr = m_IBITSSetup->DisableBITSUploads();
            }
        
        if ( FAILED( Hr ) )
            {
            LastError = Hr;
            goto error;
            }
        }


    Hr = m_IISAdminBase->OpenKey(
        METADATA_MASTER_ROOT_HANDLE,
        m_MetabasePath,
        METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
        10000, // 10 seconds
        &mdHandle );

    if ( FAILED( Hr ) )
        {
        LastError = Hr;
        goto error;
        }


    if ( BST_CHECKED == IsDlgButtonChecked( m_hwnd, IDC_RADIO_USE_INHERITED_CONFIG ) )
        {

        // delete all the configuration properties

        DWORD IdsToDelete[] =
        {
            MD_BITS_MAX_FILESIZE,
            MD_BITS_NO_PROGRESS_TIMEOUT,
            MD_BITS_NOTIFICATION_URL_TYPE,
            MD_BITS_NOTIFICATION_URL,
            MD_BITS_HOSTID,
            MD_BITS_HOSTID_FALLBACK_TIMEOUT
        };

        for ( DWORD i=0; i < ( sizeof(IdsToDelete) / sizeof(*IdsToDelete) ); i++ )
            {

            Hr = m_IISAdminBase->DeleteData(
                mdHandle,
                NULL,
                m_PropertyMan->GetPropertyMetabaseID( IdsToDelete[i] ),
                ALL_METADATA );

            if ( FAILED( Hr ) && Hr != HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND ) && 
                 Hr != MD_ERROR_DATA_NOT_FOUND )
                LastError = Hr;

            }

        }

    else
        {


        {

        // save the maximum upload size
        WCHAR MaxUploadSizeString[ MAX_PATH ];

        LRESULT MaxUploadUnitsSelect =
            SendDlgItemMessage( m_hwnd, IDC_COMBO_MAX_UPLOAD_UNITS, CB_GETCURSEL, 0, 0 );

        if ( BST_UNCHECKED == IsDlgButtonChecked( m_hwnd, IDC_CHECK_LIMIT_MAX_UPLOAD ) )
            {                            
            StringCchCopyW( MaxUploadSizeString, MAX_PATH, MD_BITS_UNLIMITED_MAX_FILESIZE );
            }
        else
            {
            UINT64 MaxUploadSize;
            GetDlgItemTextAsInteger( IDC_EDIT_MAX_UPLOAD, MAX_PATH, MaxUploadSize );            
            MaxUploadSize *= s_MaxUploadUnitsScales[ MaxUploadUnitsSelect ];
            StringCchPrintfW( MaxUploadSizeString, MAX_PATH, L"%I64u", MaxUploadSize );
            }

        MergeError( 
            SaveMetadataString(
                mdHandle,
                MD_BITS_MAX_FILESIZE,
                MaxUploadSizeString ), &LastError );
        }

        MergeError( 
            SaveTimeoutValue(
                mdHandle,
                MD_BITS_NO_PROGRESS_TIMEOUT,
                IDC_DELETE_FILES,
                IDC_EDIT_SESSION_TIMEOUT,
                IDC_COMBO_SESSION_TIMEOUT_UNITS ), &LastError );

        // Save the notification settings

        if ( BST_UNCHECKED == IsDlgButtonChecked( m_hwnd, IDC_CHECK_ENABLE_NOTIFICATIONS ) )
            {

            MergeError( 
                SaveMetadataDWORD(
                    mdHandle,
                    MD_BITS_NOTIFICATION_URL_TYPE,
                    BITS_NOTIFICATION_TYPE_NONE ), &LastError );

            MergeError(
                SaveMetadataString(
                    mdHandle,
                    MD_BITS_NOTIFICATION_URL,
                    L"" ), &LastError );

            }
        else
            {

            LRESULT NotificationTypeSelect = 
                SendDlgItemMessage( m_hwnd, IDC_COMBO_NOTIFICATION_TYPE, CB_GETCURSEL, 0, 0 );

            BITS_SERVER_NOTIFICATION_TYPE NotificationType = 
                (BITS_SERVER_NOTIFICATION_TYPE)( NotificationTypeSelect + BITS_NOTIFICATION_TYPE_POST_BYREF );

            MergeError( 
                SaveMetadataDWORD(
                    mdHandle,
                    MD_BITS_NOTIFICATION_URL_TYPE,
                    NotificationType ), &LastError );

            MergeError(
                SaveSimpleString(
                    mdHandle,
                    MD_BITS_NOTIFICATION_URL,
                    IDC_EDIT_NOTIFICATION_URL ), &LastError );

            }


        // Save the webfarm settings
        if ( BST_UNCHECKED == IsDlgButtonChecked( m_hwnd, IDC_ENABLE_SERVER_FARM ) )
            {

            MergeError(
                SaveMetadataString(
                    mdHandle,
                    MD_BITS_HOSTID,
                    L"" ), &LastError );

            MergeError(
                SaveMetadataDWORD(
                    mdHandle,
                    MD_BITS_HOSTID_FALLBACK_TIMEOUT,
                    MD_BITS_NO_TIMEOUT ), &LastError );

            }
        else
            {

            MergeError(
                SaveSimpleString(
                    mdHandle,
                    MD_BITS_HOSTID,
                    IDC_EDIT_HOSTID ), &LastError );

            MergeError(
                SaveTimeoutValue(
                    mdHandle,
                    MD_BITS_HOSTID_FALLBACK_TIMEOUT,
                    IDC_CHECK_FALLBACK_TIMEOUT,
                    IDC_EDIT_FALLBACK_TIMEOUT,
                    IDC_COMBO_FALLBACK_TIMEOUT_UNITS ), &LastError );

            }

        }

error:

    if ( mdHandle )
        m_IISAdminBase->CloseKey( mdHandle );

    mdHandle = NULL;

    if ( FAILED( LastError ) )
        DisplayError( IDS_CANT_SAVE_VALUES, LastError );    

}

void CPropSheetExtension::DisplayHelp( )
{

    WCHAR HelpTopic[MAX_PATH];
    LoadString( g_hinst, IDS_HELPFILE, HelpTopic, MAX_PATH-1); 

    HtmlHelp( NULL,  
              HelpTopic,
              HH_DISPLAY_TOPIC,
              0 );

}

INT_PTR CPropSheetExtension::DialogProc(
    UINT uMsg,     // message
    WPARAM wParam, // first message parameter
    LPARAM lParam  // second message parameter
    )
{

    switch (uMsg) {
    
    case WM_SETCURSOR:
        if ( m_CleanupInProgress )
            {
            // set the cursor for this dialog and its children.
            SetCursor( m_CleanupCursor );
            SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, TRUE );
            return TRUE;
            }
        break;

    case WM_TIMER:
        CleanupTimer( (UINT)wParam );
        return TRUE;

    case WM_INITDIALOG:

        SendDlgItemMessage( m_hwnd, IDC_EDIT_SESSION_DIRECTORY, EM_LIMITTEXT, MAX_PATH-1, 0 );   
        AddComboBoxItems( IDC_COMBO_MAX_UPLOAD_UNITS,
                          &s_MaxUploadUnits[0], s_NumberOfMaxUploadUnits );
        AddComboBoxItems( IDC_COMBO_SESSION_TIMEOUT_UNITS,
                          &s_TimeoutUnits[0], s_NumberOfTimeoutUnits );
        AddComboBoxItems( IDC_COMBO_NOTIFICATION_TYPE,
                          &s_NotificationTypes[0], s_NumberOfNotificationTypes );
        AddComboBoxItems( IDC_COMBO_FALLBACK_TIMEOUT_UNITS,
                          &s_TimeoutUnits[0], s_NumberOfTimeoutUnits );

        LoadInheritedValues();
        LoadValues( ); 
        break;
        
    case WM_COMMAND:
        if ( HIWORD(wParam) == EN_CHANGE ||
             HIWORD(wParam) == CBN_SELCHANGE )
            {
            m_SettingsChanged = true;
            SendMessage(GetParent(m_hwnd), PSM_CHANGED, (WPARAM)m_hwnd, 0);
            }

        else if ( HIWORD(wParam) == BN_CLICKED )
            {

            WORD ButtonID = LOWORD(wParam);
            
            if ( IDC_BUTTON_SCHEDULE_CLEANUP != ButtonID &&
                 IDC_BUTTON_CLEANUP_NOW != ButtonID )
                {
                m_SettingsChanged = true;
                SendMessage(GetParent(m_hwnd), PSM_CHANGED, (WPARAM)m_hwnd, 0);
                }

            switch( LOWORD(wParam) )
                {
                case IDC_CHECK_BITS_UPLOAD:
                    m_EnabledSettingChanged = true;
                    UpdateUploadGroupState( );
                    break;

                case IDC_RADIO_USE_INHERITED_CONFIG:
                    LoadMaxUploadValue( m_InheritedValues.MaxUploadSize );
                    LoadTimeoutValue( m_InheritedValues.SessionTimeout );
                    LoadServerFarmSettings( m_InheritedValues.HostId, m_InheritedValues.FallbackTimeout );       
                    LoadNotificationValues( m_InheritedValues.NotificationType, 
                                            m_InheritedValues.NotificationURL );
                    
                // Intentional fallthrough
                case IDC_RADIO_USE_CUSTOM_CONFIG:
                    UpdateConfigGroupState( true );
                    break;

                case IDC_CHECK_LIMIT_MAX_UPLOAD:
                    UpdateMaxUploadGroupState( true );
                    break;

                case IDC_DELETE_FILES:
                    UpdateTimeoutGroupState( true );
                    break;

                case IDC_CHECK_ENABLE_NOTIFICATIONS:
                    UpdateNotificationsGroupState( true );
                    break;

                case IDC_ENABLE_SERVER_FARM:
                    UpdateServerFarmGroupState( true );
                    break;

                case IDC_CHECK_FALLBACK_TIMEOUT:
                    UpdateServerFarmFallbackGroupState( true );
                    break;

                case IDC_BUTTON_SCHEDULE_CLEANUP:
                    ScheduleCleanup();
                    break;

                case IDC_BUTTON_CLEANUP_NOW:
                    CleanupNow();
                    break;

                }
            }

        break;
        
    case WM_DESTROY:
        // we don't free the notify handle for property sheets
        // MMCFreeNotifyHandle(pThis->m_ppHandle);
        break;
        
   case WM_NOTIFY:
        switch (((NMHDR *) lParam)->code) 
            {
        
            case PSN_KILLACTIVE:
                SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, !ValidateValues( ) );
                return TRUE;

            case PSN_APPLY:
                // don't notify the primary snap-in that Apply
                // has been hit...
                // MMCPropertyChangeNotify(pThis->m_ppHandle, (long)pThis);
                
                if ( m_SettingsChanged )
                    {
                    CloseCleanupItems();
                    SetValues( );
                    UpdateCleanupState( );

                    // all changes are flushed now
                    m_SettingsChanged = m_EnabledSettingChanged = false;
                    }

                SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, PSNRET_NOERROR );
                return TRUE;

            case PSN_HELP:
                DisplayHelp( );
                return TRUE;
            }
        break;

    case WM_HELP:
        DisplayHelp( );
        return TRUE;

    }
    
    return FALSE;
}

HRESULT
CPropSheetExtension::ComputeMetabaseParent()
{

    //
    // Hack the metabase path to get the key parent  
    //
    
    SIZE_T MetabaseParentSize = wcslen( m_MetabasePath ) + 1;
    m_MetabaseParent = new WCHAR[ MetabaseParentSize ];
    
    if ( !m_MetabaseParent )
        return E_OUTOFMEMORY;

    StringCchCopy( m_MetabaseParent, MetabaseParentSize, m_MetabasePath );

    {

        WCHAR *p = m_MetabaseParent + wcslen( m_MetabaseParent );
        while( ( L'/' != *p ) && ( p != m_MetabaseParent ) )
            p--;

        *p = L'\0';
    }

    return S_OK;
}

HRESULT
CPropSheetExtension::ComputeUNCComputerName()
{

    //
    //
    // The task scheduler expects the name of the computer to have
    // double slashes in front of it just like UNC names.  Do the
    // conversion here.
    //
    SIZE_T ComputerNameSize = wcslen( m_ComputerName );
    m_UNCComputerName = new WCHAR[ ComputerNameSize + 3 ]; // add

    if ( !m_UNCComputerName )
        return E_OUTOFMEMORY;

    WCHAR *StringDest;

    if ( L'\\' == m_ComputerName[0] )
        {

        if ( L'\\' == m_ComputerName[1] )
            {
            // No slashes are needed
            StringDest = m_UNCComputerName;
            }
        else
            {
            // need one slash
            m_UNCComputerName[0] = L'\\';
            StringDest = m_UNCComputerName + 1;
            }

        }
    else
        {
        // need two slashes
        m_UNCComputerName[0]    = m_UNCComputerName[1]      = L'\\';
        StringDest              = m_UNCComputerName + 2;
        }

    memcpy( StringDest, m_ComputerName, ( ComputerNameSize + 1 ) * sizeof( WCHAR ) );

    return S_OK;

}

HRESULT
CPropSheetExtension::OpenSetupInterface()
{

    HRESULT Hr;
    WCHAR *ADSIPath = NULL;
    WCHAR *ConvertedMetabasePath = m_MetabasePath;

    try
        {

        if ( _wcsnicmp( m_MetabasePath, L"/LM/", wcslen(L"/LM/") ) == 0 ||
             _wcsnicmp( m_MetabasePath, L"LM/", wcslen(L"LM/" ) ) == 0 )
            {

            //
            // Only do the fixup if we're not managing the local computer
            //

            WCHAR ComputerName[ MAX_COMPUTERNAME_LENGTH  + 1 ];

            DWORD BufferLength = MAX_COMPUTERNAME_LENGTH + 1; 
            if ( !GetComputerName( ComputerName, &BufferLength ) )
                return HRESULT_FROM_WIN32( GetLastError() );

            if ( _wcsicmp( m_ComputerName, ComputerName ) != 0 )
                {

                SIZE_T ConvertedPathSize    = wcslen( m_ComputerName ) + wcslen( m_MetabasePath ) + 1;
                ConvertedMetabasePath       = new WCHAR[ ConvertedPathSize ];

                if ( !ConvertedMetabasePath )
                    return E_OUTOFMEMORY;

                StringCchCopyW( ConvertedMetabasePath, ConvertedPathSize, L"/" );
                StringCchCatW( ConvertedMetabasePath, ConvertedPathSize, m_ComputerName );
                size_t MetabaseOffset = 
                    m_MetabasePath[0] == L'/' ?
                    wcslen(L"/LM") : wcslen( L"LM" );
                StringCchCatW( ConvertedMetabasePath, ConvertedPathSize, m_MetabasePath + MetabaseOffset );

                }
            }


        ADSIPath = ConvertObjectPathToADSI( ConvertedMetabasePath );
        THROW_COMERROR( ADsGetObject( ADSIPath, __uuidof(*m_IBITSSetup), (void**)&m_IBITSSetup ) );
        
        if ( ConvertedMetabasePath != m_MetabasePath)
            delete[] ConvertedMetabasePath;
        
        ConvertedMetabasePath = NULL;
        delete ADSIPath;
        ADSIPath = NULL;

        }
    catch( ComError Error )
        {
        delete ADSIPath;

        if ( ConvertedMetabasePath != m_MetabasePath )
            delete[] ConvertedMetabasePath;

        return Error.m_Hr;
        }
    return S_OK;

}

///////////////////////////////
// Interface IExtendPropertySheet
///////////////////////////////
HRESULT CPropSheetExtension::CreatePropertyPages( 
    /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
    /* [in] */ LONG_PTR handle,
    /* [in] */ LPDATAOBJECT lpIDataObject)
{

    HRESULT Hr = E_FAIL;
   
    Hr = ExtractSnapInString( (IDataObject*)lpIDataObject, m_MetabasePath, s_cfSnapInMetapath );

    if ( FAILED(Hr) )
        return Hr;    

    Hr = ExtractSnapInString( (IDataObject*)lpIDataObject, m_ComputerName, s_cfSnapInMachineName );

    if ( FAILED(Hr) )
        return Hr;

    Hr = ComputeUNCComputerName();

    if ( FAILED(Hr) )
        return Hr;

    Hr = ExtractSnapInGUID( (IDataObject*)lpIDataObject, m_NodeGuid, s_cfNodeType ); 

    if ( FAILED(Hr) )
        return Hr;

    Hr = ComputeMetabaseParent();

    if ( FAILED(Hr) )
        return Hr;

    Hr = OpenSetupInterface();

    if ( FAILED(Hr) )
        return Hr;


    if ( !m_IISAdminBase )
        {
                    
        COSERVERINFO coinfo;
        coinfo.dwReserved1  = 0;
        coinfo.dwReserved2  = 0;
        coinfo.pAuthInfo    = NULL;
        coinfo.pwszName     = m_ComputerName;

        GUID guid = __uuidof( IMSAdminBase );
        MULTI_QI mqi;
        mqi.hr              = S_OK;
        mqi.pIID            = &guid;
        mqi.pItf            = NULL;

        Hr = 
            CoCreateInstanceEx(
                GETAdminBaseCLSID(TRUE),
                NULL,
                CLSCTX_SERVER,
                &coinfo,
                1,
                &mqi );

        if ( FAILED( Hr ) )
            return Hr;

        if ( FAILED( mqi.hr ) )
            return mqi.hr;

        m_IISAdminBase = (IMSAdminBase*)mqi.pItf;
            
        }

    METADATA_RECORD mdr;
    DWORD BufferRequired;
    memset( &mdr, 0, sizeof(mdr) );

    mdr.dwMDIdentifier = MD_KEY_TYPE;
	mdr.dwMDAttributes = METADATA_NO_ATTRIBUTES;
	mdr.dwMDUserType = ALL_METADATA;
	mdr.dwMDDataType = ALL_METADATA;
	mdr.dwMDDataLen = sizeof(m_NodeTypeName);
    mdr.pbMDData = (PBYTE) m_NodeTypeName;

    Hr = m_IISAdminBase->GetData(
        METADATA_MASTER_ROOT_HANDLE,
        m_MetabasePath,
        &mdr,
        &BufferRequired );

    // Out of buffer isn't really an error, its just that the
    // node type is bigger then what we are looking for.
    if ( Hr == HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER ) )
        return S_FALSE;

    if ( FAILED(Hr) )
        return Hr;

    // Do not display pages for nodes that are not virtual directories
    if ( 0 != wcscmp( L"IIsWebVirtualDir", m_NodeTypeName ) )
        return S_FALSE;

    // Create property manager

    m_PropertyMan = new PropertyIDManager();

    if ( !m_PropertyMan )
        return E_OUTOFMEMORY;

    Hr = m_PropertyMan->LoadPropertyInfo( m_ComputerName );

    if ( FAILED( Hr ) )
        return Hr;

    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hPage = NULL;
    
    // we don't cache this handle like in a primary snap-in
    // the handle value here is always 0
    // m_ppHandle = handle;
   

    memset( &psp, 0, sizeof(psp) );
    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_HASHELP;
    psp.hInstance = g_hinst;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_PROPPAGE_LARGE);
    psp.pfnDlgProc = DialogProcExternal;
    psp.lParam = reinterpret_cast<LPARAM>(this);
    psp.pszTitle = MAKEINTRESOURCE(IDS_BITS_EXT);
    
    hPage = CreatePropertySheetPage(&psp);
    _ASSERT(hPage);
    
    Hr = lpProvider->AddPage(hPage);
    return Hr;
}

HRESULT CPropSheetExtension::QueryPagesFor( 
                                           /* [in] */ LPDATAOBJECT lpDataObject)
{
    return S_OK;
}


void * _cdecl ::operator new( size_t Size )
{
    return HeapAlloc( GetProcessHeap(), 0, Size );
}

void _cdecl ::operator delete( void *Memory )
{
    if ( !Memory )
        return;

    HeapFree( GetProcessHeap(), 0, Memory );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\server\mmcexts\basesnap.cpp ===
/************************************************************************

Copyright (c) 2001 Microsoft Corporation

Module Name :

    basesnap.cpp

Abstract :

    Handles low level COM functions.

Author :

Revision History :

 ***********************************************************************/

#include "precomp.h"

// our globals
HINSTANCE g_hinst;
ULONG g_uObjects = 0;
ULONG g_uSrvLock = 0;

class CClassFactory : public IClassFactory
{
private:
    ULONG	m_cref;
    
public:
    enum FACTORY_TYPE {CONTEXTEXTENSION = 0, ABOUT = 1, ADSI = 2, ADSIFACTORY = 3};
    
    CClassFactory(FACTORY_TYPE factoryType);
    ~CClassFactory();
    
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
    STDMETHODIMP LockServer(BOOL);
    
private:
    FACTORY_TYPE m_factoryType;
};


BOOL WINAPI DllMain(HINSTANCE hinstDLL, 
                    DWORD fdwReason, 
                    void* lpvReserved)
{
    
    if (fdwReason == DLL_PROCESS_ATTACH) {
        g_hinst = hinstDLL;
        DisableThreadLibraryCalls( g_hinst );
    }
    
    return TRUE;
}


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj)
{

    if ((rclsid != CLSID_CPropSheetExtension) && (rclsid != CLSID_CSnapinAbout) && (rclsid != CLSID_CBITSExtensionSetup) && 
		(rclsid != __uuidof(BITSExtensionSetupFactory) ) )
        return CLASS_E_CLASSNOTAVAILABLE;
    
    
    if (!ppvObj)
        return E_FAIL;
    
    *ppvObj = NULL;
    
    // We can only hand out IUnknown and IClassFactory pointers.  Fail
    // if they ask for anything else.
    if (!IsEqualIID(riid, IID_IUnknown) && !IsEqualIID(riid, IID_IClassFactory))
        return E_NOINTERFACE;
    
    CClassFactory *pFactory = NULL;
    
    // make the factory passing in the creation function for the type of object they want
    if (rclsid == CLSID_CPropSheetExtension)
        pFactory = new CClassFactory(CClassFactory::CONTEXTEXTENSION);
    else if (rclsid == CLSID_CSnapinAbout)
        pFactory = new CClassFactory(CClassFactory::ABOUT);
    else if (rclsid == CLSID_CBITSExtensionSetup)
        pFactory = new CClassFactory(CClassFactory::ADSI);
    else if (rclsid == __uuidof(BITSExtensionSetupFactory) ) 
        pFactory = new CClassFactory( CClassFactory::ADSIFACTORY );
    
    if (NULL == pFactory)
        return E_OUTOFMEMORY;
    
    HRESULT hr = pFactory->QueryInterface(riid, ppvObj);
    
    return hr;
}

STDAPI DllCanUnloadNow(void)
{
    if (g_uObjects == 0 && g_uSrvLock == 0)
        return S_OK;
    else
        return S_FALSE;
}


CClassFactory::CClassFactory(FACTORY_TYPE factoryType)
: m_cref(0), m_factoryType(factoryType)
{
    OBJECT_CREATED
}

CClassFactory::~CClassFactory()
{
    OBJECT_DESTROYED
}

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IClassFactory *>(this);
    else
        if (IsEqualIID(riid, IID_IClassFactory))
            *ppv = static_cast<IClassFactory *>(this);
        
        if (*ppv)
        {
            reinterpret_cast<IUnknown *>(*ppv)->AddRef();
            return S_OK;
        }
        
        return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;
}


STDMETHODIMP CClassFactory::CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID * ppvObj )
{

    HRESULT  hr;
    void* pObj;
    
    if (!ppvObj)
        return E_FAIL;
    
    *ppvObj = NULL;
    
    if ( ADSI == m_factoryType )
        {

        if ( !pUnkOuter )
            return E_FAIL;

        if ( pUnkOuter && ( riid != __uuidof(IUnknown) ) )
            return CLASS_E_NOAGGREGATION;

        pObj = new CBITSExtensionSetup( pUnkOuter, NULL );
         
        if (!pObj)
            return E_OUTOFMEMORY;

        if ( pUnkOuter )
            {
            *ppvObj = ((CBITSExtensionSetup*)pObj)->GetNonDelegationIUknown();
            return S_OK;
            }

        }
    else
        {

        // Our object does does not support aggregation, so we need to
        // fail if they ask us to do aggregation.
        if (pUnkOuter)
            return CLASS_E_NOAGGREGATION;

        if (CONTEXTEXTENSION == m_factoryType ) {

            hr = CPropSheetExtension::InitializeStatic();
            if ( FAILED( hr ) )
                return hr;

            pObj = new CPropSheetExtension();

        } else if ( ADSIFACTORY == m_factoryType ) 
            {
            pObj = new CBITSExtensionSetupFactory();
            }
        else {
            pObj = new CSnapinAbout();
        }

        }
    
    if (!pObj)
        return E_OUTOFMEMORY;
    
    // QueryInterface will do the AddRef() for us, so we do not
    // do it in this function
    hr = ((LPUNKNOWN)pObj)->QueryInterface(riid, ppvObj);
    ((LPUNKNOWN)pObj)->Release();

    if (FAILED(hr))
        delete pObj;
    
    return hr;
}

STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement((LONG *)&g_uSrvLock);
    else
        InterlockedDecrement((LONG *)&g_uSrvLock);
    
    return S_OK;
}

HRESULT
RegisterADSIExtension()
{

    HRESULT Hr;
    HKEY hKey = NULL;
    DWORD dwDisposition;

    // Register the class.
    LONG Result = RegCreateKeyEx( 
    HKEY_LOCAL_MACHINE,
     _T("SOFTWARE\\Microsoft\\ADs\\Providers\\IIS\\Extensions\\IIsApp\\{A55E7D7F-D51C-4859-8D2D-E308625D908E}"),
     0,
     NULL,
     REG_OPTION_NON_VOLATILE,
     KEY_WRITE,
     NULL,
     &hKey,
     &dwDisposition );

    if ( ERROR_SUCCESS != Result )
        return HRESULT_FROM_WIN32( GetLastError() );

    // Register the Interface.
    const TCHAR szIf[] = _T("{29cfbbf7-09e4-4b97-b0bc-f2287e3d8eb3}");
    Result = RegSetValueEx( hKey, _T("Interfaces"), 0, REG_MULTI_SZ, (const BYTE *) szIf, sizeof(szIf) );
    
    if ( ERROR_SUCCESS != Result )
        return HRESULT_FROM_WIN32( GetLastError() );
    
    RegCloseKey(hKey);
    return S_OK;
}
    
HRESULT
UnregisterADSIExtension()
{
    LONG Result =
        RegDeleteKey( 
            HKEY_LOCAL_MACHINE,
            _T("SOFTWARE\\Microsoft\\ADs\\Providers\\IIS\\Extensions\\IIsApp\\{A55E7D7F-D51C-4859-8D2D-E308625D908E}") );

    if ( ERROR_SUCCESS != Result )
        return HRESULT_FROM_WIN32( GetLastError() );

    return S_OK;

}

HRESULT
RegisterEventLog()
{

    HKEY EventLogKey = NULL;
    DWORD Disposition;

    LONG Result =
        RegCreateKeyEx(
            HKEY_LOCAL_MACHINE,                         // handle to open key
            EVENT_LOG_KEY_NAME,                         // subkey name
            0,                                          // reserved
            NULL,                                       // class string
            0,                                          // special options
            KEY_ALL_ACCESS,                             // desired security access
            NULL,                                       // inheritance
            &EventLogKey,                               // key handle 
            &Disposition                                // disposition value buffer
            );

    if ( Result )
        return HRESULT_FROM_WIN32( Result );

    DWORD Value = 1;

    Result =
        RegSetValueEx(
            EventLogKey,            // handle to key
            L"CategoryCount",       // value name
            0,                      // reserved
            REG_DWORD,              // value type
            (BYTE*)&Value,          // value data
            sizeof(Value)           // size of value data
            );

    if ( Result )
        goto error;

    const WCHAR MessageFileName[] = L"%SystemRoot%\\system32\\bitsmgr.dll";
    const DWORD MessageFileNameSize = sizeof( MessageFileName );

    Result =
        RegSetValueEx(
            EventLogKey,                    // handle to key
            L"CategoryMessageFile",         // value name
            0,                              // reserved
            REG_EXPAND_SZ,                  // value type
            (const BYTE*)MessageFileName,   // value data
            MessageFileNameSize             // size of value data
            );

    if ( Result )
        goto error;

    Result =
        RegSetValueEx(
            EventLogKey,                    // handle to key
            L"EventMessageFile",            // value name
            0,                              // reserved
            REG_EXPAND_SZ,                  // value type
            (const BYTE*)MessageFileName,   // value data
            MessageFileNameSize             // size of value data
            );

    if ( Result )
        goto error;

    Value = EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | EVENTLOG_INFORMATION_TYPE;
    Result =
        RegSetValueEx(
            EventLogKey,            // handle to key
            L"TypesSupported",      // value name
            0,                      // reserved
            REG_DWORD,              // value type
            (BYTE*)&Value,          // value data
            sizeof(Value)           // size of value data
            );

    if ( Result )
        goto error;

    RegCloseKey( EventLogKey );
    EventLogKey = NULL;
    return S_OK;

error:

    if ( EventLogKey )
        {
        RegCloseKey( EventLogKey );
        EventLogKey = NULL;
        }

    if ( REG_CREATED_NEW_KEY == Disposition )
        {
        RegDeleteKey( 
            HKEY_LOCAL_MACHINE,
            EVENT_LOG_KEY_NAME );
        }

    return HRESULT_FROM_WIN32( Result );

}

HRESULT
UnRegisterEventLog()
{

    RegDeleteKey( 
        HKEY_LOCAL_MACHINE,
        EVENT_LOG_KEY_NAME );

    return S_OK;

}

//////////////////////////////////////////////////////////
//
// Exported functions
//


//
// Server registration
//
STDAPI DllRegisterServer()
{

    DWORD Result;
    HRESULT hr = S_OK;
    
    _TCHAR szName[256];
    _TCHAR szSnapInName[256];
    
    LoadString(g_hinst, IDS_NAME, szName, sizeof(szName) / sizeof(*szName) );
    LoadString(g_hinst, IDS_SNAPINNAME, szSnapInName, 
               sizeof(szSnapInName) / sizeof(*szSnapInName) );
    
    _TCHAR szAboutName[256];
    
    LoadString(g_hinst, IDS_ABOUTNAME, szAboutName, 
               sizeof(szAboutName) / sizeof(*szAboutName) );
    
    _TCHAR DllName[ MAX_PATH ];    

    Result = 
        GetModuleFileName(
            (HMODULE)g_hinst,
            DllName,
            MAX_PATH - 1 );

    if ( !Result )
        hr = HRESULT_FROM_WIN32( GetLastError() );
    
    ITypeLib*  TypeLib = NULL;

    if (SUCCEEDED(hr))
        hr = LoadTypeLibEx(
            DllName, // DllName,
            REGKIND_REGISTER,
            &TypeLib );

    TypeLib->Release();
    TypeLib = NULL;
    
    // register our CoClasses
    if (SUCCEEDED(hr))
        hr = RegisterServer(g_hinst, 
            CLSID_CPropSheetExtension, 
            szName);
    
    if SUCCEEDED(hr)
        hr = RegisterServer(g_hinst, 
        CLSID_CSnapinAbout, 
        szAboutName);

    if SUCCEEDED(hr)
        hr = RegisterServer(g_hinst,
        CLSID_CBITSExtensionSetup,
        _T("BITS server setup ADSI extension"),
        _T("Both"));

    if (SUCCEEDED(hr))
        hr = RegisterServer(g_hinst,
        __uuidof(BITSExtensionSetupFactory),
        _T("BITS server setup ADSI extension factory"),
        _T("Apartment"),
        true,
        _T("O:SYG:BAD:(A;;CC;;;SY)(A;;CC;;;BA)S:") );

    if SUCCEEDED(hr)
        hr = RegisterADSIExtension();

    // place the registry information for SnapIns
    if SUCCEEDED(hr)
        hr = RegisterSnapin(CLSID_CPropSheetExtension, szSnapInName, CLSID_CSnapinAbout);
    
    if SUCCEEDED(hr)
        hr = RegisterEventLog();

    return hr;
}

// {B0937B9C-D66D-4d9b-B741-49C6D66A1CD5}
DEFINE_GUID(LIBID_BITSExtensionSetup, 
0xb0937b9c, 0xd66d, 0x4d9b, 0xb7, 0x41, 0x49, 0xc6, 0xd6, 0x6a, 0x1c, 0xd5);


STDAPI DllUnregisterServer()
{
    DWORD Result;

    if ( !( ( UnregisterServer(CLSID_CPropSheetExtension) == S_OK ) &&
            ( UnregisterSnapin(CLSID_CPropSheetExtension) == S_OK ) &&
            ( UnregisterServer(CLSID_CSnapinAbout) == S_OK ) &&
            ( UnregisterServer(CLSID_CBITSExtensionSetup) == S_OK ) &&
            ( UnregisterServer(__uuidof(BITSExtensionSetupFactory)) == S_OK ) &&
            ( UnregisterADSIExtension() == S_OK ) &&
            ( UnRegisterTypeLib( LIBID_BITSExtensionSetup, 1, 0, LANG_NEUTRAL, SYS_WIN32) == S_OK ) && 
            ( UnRegisterEventLog( ) == S_OK ) ) )
        return E_FAIL;
    else
        return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\server\mmcexts\globals.h ===
/************************************************************************

Copyright (c) 2001 Microsoft Corporation

Module Name :

    globals.h

Abstract :

    Global variables

Author :

Revision History :

 ***********************************************************************/

#ifndef _MMC_GLOBALS_H
#define _MMC_GLOBALS_H

#include <tchar.h>

#ifndef STRINGS_ONLY
        #define IDM_BUTTON1    0x100
        #define IDM_BUTTON2    0x101

        extern HINSTANCE g_hinst;
        extern ULONG g_uObjects;

        #define OBJECT_CREATED InterlockedIncrement((long *)&g_uObjects);
        #define OBJECT_DESTROYED InterlockedDecrement((long *)&g_uObjects);

#endif

#endif // _MMC_GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\server\mmcexts\bitsext.h ===
/************************************************************************

Copyright (c) 2001 Microsoft Corporation

Module Name :

    bitsext.h

Abstract :

    Main file for snapin.
Author :

Revision History :

 ***********************************************************************/

#ifndef _BITSEXT_H_
#define _BITSEXT_H_

class ComError
{

public:
    const HRESULT m_Hr;

    ComError( HRESULT Hr ) :
        m_Hr( Hr )
    {
    }
};

inline void THROW_COMERROR( HRESULT Hr )
{
    if ( FAILED( Hr ) )
        throw ComError( Hr );
}

// Event Log Source
const WCHAR * const EVENT_LOG_SOURCE_NAME=L"BITS Extensions";
const WCHAR * const EVENT_LOG_KEY_NAME=L"SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\BITS Extensions";

#include "beventlog.h"

// IIS MMC node types
const GUID g_IISInstanceNode = {0xa841b6c7, 0x7577, 0x11d0, {0xbb, 0x1f, 0x00, 0xa0, 0xc9, 0x22, 0xe7, 0x9c}};
const GUID g_IISChildNode    = {0xa841b6c8, 0x7577, 0x11d0, {0xbb, 0x1f, 0x00, 0xa0, 0xc9, 0x22, 0xe7, 0x9c}};

class CBITSExtensionSetup;
class CNonDelegatingIUnknown : public IUnknown
{

    ULONG   m_cref;
    CBITSExtensionSetup *m_DelegatingIUnknown;

public:

    CNonDelegatingIUnknown( CBITSExtensionSetup * DelegatingIUnknown );

    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObject);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void); 
    
};

class CBITSExtensionSetup : public IBITSExtensionSetup, public IADsExtension 
{

private:
    IUnknown*   m_pOuter;
    IDispatch*  m_OuterDispatch;
    ITypeInfo*  m_TypeInfo;
    IUnknown*   m_pObject;
    BSTR        m_ADSIPath;
    IBITSExtensionSetup* m_RemoteInterface;
    WCHAR *     m_Path;

    bool        m_InitComplete;
    CNonDelegatingIUnknown m_DelegationIUnknown;
    PropertyIDManager* m_PropertyMan;
    LONG        m_Lock;

    HRESULT LoadPath();
    HRESULT ConnectToRemoteExtension();
    HRESULT LoadTypeInfo();

public:
    CBITSExtensionSetup( IUnknown *Outer, IUnknown *Object );
    virtual ~CBITSExtensionSetup();
    
    IUnknown *GetNonDelegationIUknown()
    {
        return &m_DelegationIUnknown;
    }

    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IADsExtension methods

    STDMETHOD(Operate)(ULONG dwCode, VARIANT varData1, VARIANT varData2, VARIANT varData3);

    STDMETHOD(PrivateGetIDsOfNames)( 
        REFIID riid,  
        OLECHAR FAR* FAR* rgszNames, 
        unsigned int cNames, 
        LCID lcid, 
        DISPID FAR* 
        rgDispId );

    STDMETHOD(PrivateGetTypeInfo)( 
        unsigned int iTInfo, 
        LCID lcid, 
        ITypeInfo FAR* FAR* ppTInfo );

    STDMETHOD(PrivateGetTypeInfoCount)( 
        unsigned int FAR* pctinfo );

    STDMETHOD(PrivateInvoke)( 
        DISPID dispIdMember, 
        REFIID riid, LCID lcid, 
        WORD wFlags, 
        DISPPARAMS FAR* pDispParams, 
        VARIANT FAR* pVarResult, 
        EXCEPINFO FAR* pExcepInfo, 
        unsigned int FAR* puArgErr );

    // IDispatch Methods

    STDMETHOD(GetIDsOfNames)( 
        REFIID riid,  
        OLECHAR FAR* FAR* rgszNames, 
        unsigned int cNames, 
        LCID lcid, 
        DISPID FAR* 
        rgDispId );

    STDMETHOD(GetTypeInfo)( 
        unsigned int iTInfo, 
        LCID lcid, 
        ITypeInfo FAR* FAR* ppTInfo );

    STDMETHOD(GetTypeInfoCount)( 
        unsigned int FAR* pctinfo );

    STDMETHOD(Invoke)( 
        DISPID dispIdMember, 
        REFIID riid, LCID lcid, 
        WORD wFlags, 
        DISPPARAMS FAR* pDispParams, 
        VARIANT FAR* pVarResult, 
        EXCEPINFO FAR* pExcepInfo, 
        unsigned int FAR* puArgErr );

    // IBITSExtensionSetup methods

    STDMETHODIMP EnableBITSUploads();
    STDMETHODIMP DisableBITSUploads();
    STDMETHODIMP GetCleanupTaskName( BSTR *pTaskName );
    STDMETHODIMP GetCleanupTask( REFIID riid, IUnknown **ppUnk );
         
};

class CBITSExtensionSetupFactory : public IBITSExtensionSetupFactory
{

    long m_cref;
    ITypeInfo *m_TypeInfo;

public:
    
    CBITSExtensionSetupFactory();
    virtual ~CBITSExtensionSetupFactory();

    HRESULT LoadTypeInfo();

    STDMETHODIMP GetObject( BSTR Path, IBITSExtensionSetup **ppExtensionSetup );

    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    STDMETHOD(GetIDsOfNames)( 
        REFIID riid,  
        OLECHAR FAR* FAR* rgszNames, 
        unsigned int cNames, 
        LCID lcid, 
        DISPID FAR* 
        rgDispId );

    STDMETHOD(GetTypeInfo)( 
        unsigned int iTInfo, 
        LCID lcid, 
        ITypeInfo FAR* FAR* ppTInfo );

    STDMETHOD(GetTypeInfoCount)( 
        unsigned int FAR* pctinfo ); 

    STDMETHOD(Invoke)( 
        DISPID dispIdMember, 
        REFIID riid, LCID lcid, 
        WORD wFlags, 
        DISPPARAMS FAR* pDispParams, 
        VARIANT FAR* pVarResult, 
        EXCEPINFO FAR* pExcepInfo, 
        unsigned int FAR* puArgErr );

    STDMETHODIMP EnableBITSUploads();
    STDMETHODIMP DisableBITSUploads();
         
};

class CPropSheetExtension : public IExtendPropertySheet
{
    
private:
    ULONG   m_cref;
    
    // clipboard format
    static bool s_bStaticInitialized;
    static UINT s_cfDisplayName;
    static UINT s_cfSnapInCLSID;
    static UINT s_cfNodeType;
    static UINT s_cfSnapInMetapath;
    static UINT s_cfSnapInMachineName;

    static const UINT s_MaxUploadUnits[];
    static const UINT s_NumberOfMaxUploadUnits;
    static const UINT64 s_MaxUploadUnitsScales[];
    static const UINT s_NumberOfMaxUploadUnitsScales;
    static const UINT64 s_MaxUploadLimits[];
    static const UINT s_NumberOfMaxUploadLimits;

    static const UINT s_TimeoutUnits[];
    static const UINT s_NumberOfTimeoutUnits;
    static const DWORD s_TimeoutUnitsScales[];
    static const UINT s_NumberOfTimeoutUnitsScales;
    static const UINT64 s_TimeoutLimits[];
    static const UINT s_NumberOfTimeoutLimits;

    static const UINT s_NotificationTypes[];
    static const UINT s_NumberOfNotificationTypes;

public:
    CPropSheetExtension();
    ~CPropSheetExtension();
    static HRESULT InitializeStatic();    
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // Interface IExtendPropertySheet
    ///////////////////////////////
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreatePropertyPages( 
        /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
        /* [in] */ LONG_PTR handle,
        /* [in] */ LPDATAOBJECT lpIDataObject);
        
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryPagesFor( 
        /* [in] */ LPDATAOBJECT lpDataObject);
        
private:
    TCHAR *         m_MetabasePath;
    TCHAR *         m_MetabaseParent;
    TCHAR *         m_ComputerName;
    TCHAR *         m_UNCComputerName;
    GUID            m_NodeGuid;
    IMSAdminBase*   m_IISAdminBase;
    IBITSExtensionSetup* m_IBITSSetup;
    WCHAR           m_NodeTypeName[MAX_PATH];
    PropertyIDManager* m_PropertyMan;

    HWND            m_hwnd;
    bool            m_SettingsChanged;       // true if any settings changed
    bool            m_EnabledSettingChanged; // true if the vdir was enabled or disabled

    struct InheritedValues
    {
        UINT64 MaxUploadSize;
        DWORD  SessionTimeout;
        BITS_SERVER_NOTIFICATION_TYPE NotificationType;
        WCHAR  * NotificationURL;
        WCHAR  * HostId;
        DWORD  FallbackTimeout;

        InheritedValues();
        ~InheritedValues();
    } m_InheritedValues;

    ITaskScheduler* m_TaskSched;
    ITask*          m_CleanupTask;
    bool            m_CleanupInProgress;
    FILETIME        m_PrevCleanupStartTime;
    HCURSOR         m_CleanupCursor;
    bool            m_CleanupMinWaitTimerFired;

    static const UINT s_CleanupMinWaitTimerID           = 1;
    static const UINT s_CleanupPollTimerID              = 2;
    static const UINT s_CleanupMinWaitTimerInterval     = 2000; // two seconds
    static const UINT s_CleanupPollTimerInterval        = 1000; // one second

    static INT_PTR CALLBACK DialogProcExternal(
        HWND hwndDlg,  // handle to dialog box
        UINT uMsg,     // message
        WPARAM wParam, // first message parameter
        LPARAM lParam  // second message parameter
        )
    {

        CPropSheetExtension *pThis;
         
        if ( WM_INITDIALOG == uMsg )
            {
            pThis = reinterpret_cast<CPropSheetExtension *>(reinterpret_cast<PROPSHEETPAGE *>(lParam)->lParam);
            SetWindowLongPtr( hwndDlg, DWLP_USER, reinterpret_cast<LONG_PTR>( pThis ) );
            }
        else
            {
            pThis = reinterpret_cast<CPropSheetExtension*>( GetWindowLongPtr( hwndDlg, DWLP_USER ) );
            }

         if ( !pThis )
			return FALSE;       

        pThis->m_hwnd = hwndDlg;

        return pThis->DialogProc(
            uMsg,
            wParam,
            lParam );

    }

    INT_PTR DialogProc(
        UINT uMsg,     // message
        WPARAM wParam, // first message parameter
        LPARAM lParam  // second message parameter
        );   
    
    HRESULT ComputeMetabaseParent();
    HRESULT ComputeUNCComputerName();
    HRESULT OpenSetupInterface();

    HRESULT LoadInheritedDWORD(
        METADATA_HANDLE mdHandle,
        WCHAR * pKeyName,
        DWORD PropId,
        DWORD * pReturn );

    HRESULT LoadInheritedString(
        METADATA_HANDLE mdHandle,
        WCHAR * pKeyName,
        DWORD PropId,
        WCHAR ** pReturn );

    void LoadInheritedValues( );
    void LoadValues( );

    void MergeError( HRESULT Hr, HRESULT * LastHr );
    HRESULT SaveSimpleString( METADATA_HANDLE mdHandle, DWORD PropId, DWORD EditId );
    HRESULT SaveTimeoutValue(
        METADATA_HANDLE mdHandle,
        DWORD PropId,
        DWORD CheckId,
        DWORD EditId,
        DWORD UnitId );

    void SetValues( );
    bool ValidateValues( );
    bool WarnAboutAccessFlags( );

    void AddComboBoxItems( UINT Combo, const UINT *Items, UINT NumberOfItems );
    void DisplayError( UINT StringId );
    void DisplayError( UINT StringId, HRESULT Hr );
    bool DisplayWarning( UINT StringId );
    void SetDlgItemTextAsInteger( UINT Id, UINT64 Value );
    bool GetDlgItemTextAsInteger( UINT Id, UINT MaxString, UINT64 & Value );
    void DisplayHelp( );

    void UpdateMaxUploadGroupState( bool IsEnabled );
    void UpdateTimeoutGroupState( bool IsEnabled );
    void UpdateNotificationsGroupState( bool IsEnabled );
    void UpdateConfigGroupState( bool IsEnabled );
    void UpdateServerFarmFallbackGroupState( bool IsEnabled );
    void UpdateServerFarmGroupState( bool IsEnabled );
    void UpdateUploadGroupState( );

    void UpdateCleanupState( );
    void CloseCleanupItems();
    void ScheduleCleanup();
    void CleanupNow();
    void CleanupTimer( UINT TimerID );

    void LoadMaxUploadValue( UINT64 MaxValue );
    void LoadTimeoutValue(
        DWORD CheckId,
        DWORD EditId,
        DWORD UnitId,
        DWORD Value );

    void LoadTimeoutValue( DWORD SessionTimeout );
    void LoadNotificationValues( BITS_SERVER_NOTIFICATION_TYPE NotificationType, WCHAR *NotificationURL );
    void LoadServerFarmSettings( WCHAR *HostId, DWORD FallbackTimeout );

    HRESULT ExtractData( 
        IDataObject* piDataObject,
        CLIPFORMAT   cfClipFormat,
        BYTE*        pbData,
        DWORD        cbData );
    
    HRESULT ExtractString( IDataObject *piDataObject,
        CLIPFORMAT   cfClipFormat,
        _TCHAR       *pstr,
        DWORD        cchMaxLength)
    {
        return ExtractData( piDataObject, cfClipFormat, (PBYTE)pstr, cchMaxLength );
    }
    
    HRESULT ExtractSnapInCLSID( IDataObject* piDataObject, CLSID* pclsidSnapin )
    {
        return ExtractData( piDataObject, (CLIPFORMAT)s_cfSnapInCLSID, (PBYTE)pclsidSnapin, sizeof(CLSID) );
    }
    
    HRESULT ExtractObjectTypeGUID( IDataObject* piDataObject, GUID* pguidObjectType )
    {
        return ExtractData( piDataObject, (CLIPFORMAT)s_cfNodeType, (PBYTE)pguidObjectType, sizeof(GUID) );
    }
    
    HRESULT ExtractSnapInString( IDataObject * piDataObject,
                                 WCHAR * & String,
                                 UINT Format );

    HRESULT ExtractSnapInGUID( IDataObject * piDataObject,
                               GUID & Guid,
                               UINT Format );

    HRESULT SaveMetadataString(
        METADATA_HANDLE mdHandle,
        DWORD PropId,
        WCHAR *Value );

    HRESULT SaveMetadataDWORD(
        METADATA_HANDLE mdHandle,
        DWORD PropId,
        DWORD Value );


};

class CSnapinAbout : public ISnapinAbout
{
private:
    ULONG				m_cref;
    HBITMAP				m_hSmallImage;
    HBITMAP				m_hLargeImage;
    HBITMAP				m_hSmallImageOpen;
    HICON				m_hAppIcon;
    
public:
    CSnapinAbout();
    ~CSnapinAbout();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // Interface ISnapinAbout
    ///////////////////////////////
    STDMETHODIMP GetSnapinDescription( 
    /* [out] */ LPOLESTR *lpDescription);
    
    STDMETHODIMP GetProvider( 
    /* [out] */ LPOLESTR *lpName);
    
    STDMETHODIMP GetSnapinVersion( 
    /* [out] */ LPOLESTR *lpVersion);
    
    STDMETHODIMP GetSnapinImage( 
    /* [out] */ HICON *hAppIcon);
    
    STDMETHODIMP GetStaticFolderImage( 
    /* [out] */ HBITMAP *hSmallImage,
    /* [out] */ HBITMAP *hSmallImageOpen,
    /* [out] */ HBITMAP *hLargeImage,
    /* [out] */ COLORREF *cMask);
        
    ///////////////////////////////
    // Private Interface 
    ///////////////////////////////
private:
    HRESULT	LoadStringHelper(
        LPOLESTR *lpDest, 
        UINT Id );
};

WCHAR *
ConvertObjectPathToADSI( 
    const WCHAR *ObjectPath );

HRESULT
ConnectToTaskScheduler(
    LPWSTR ComputerName, 
    ITaskScheduler ** TaskScheduler );

HRESULT
FindWorkItemForVDIR( 
    ITaskScheduler *TaskScheduler,
    LPCWSTR Key,
    ITask   **ReturnedTask,
    LPWSTR  *ReturnedTaskName );

HRESULT 
IsBITSEnabledOnVDir(
    PropertyIDManager *PropertyManager,
    IMSAdminBase *IISAdminBase,
    LPWSTR VirtualDirectory,
    BOOL *IsEnabled );

HRESULT
EnableBITSForVDIR(
    PropertyIDManager   *PropertyManager,
    IMSAdminBase        *IISAdminBase,
    LPCWSTR             Path );

HRESULT
DisableBITSForVDIR(
    PropertyIDManager   *PropertyManager,
    IMSAdminBase        *IISAdminBase,
    LPCWSTR             Path,
    bool                DisableForEnable );

void CleanupForRemoval( LPCWSTR Path );

#endif _BITSEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\server\mmcexts\precomp.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Main header for BITS server extensions MMC snapin

--*/

#ifndef _PRECOMP_H_
#define _PRECOMP_H_

#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <objbase.h>
#include <olectl.h>
#include <initguid.h>
#include <tchar.h>
#include <mmc.h>
#include <iadmw.h>
#include <iiscnfg.h>
#include "bitssrvcfg.h"
#include <htmlhelp.h>
#include "bitscfg.h"
#include <activeds.h>
#include <iads.h>
#include <crtdbg.h>
#include <malloc.h>
#include <assert.h>
#include <mstask.h>
#include <shellapi.h>
#include <strsafe.h>

void * _cdecl ::operator new( size_t Size );
void _cdecl ::operator delete( void *Memory );
    
#include "resource.h"
#include "guids.h"
#include "globals.h"
#include "registry.h"
#include "bitsext.h"

#endif //_PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\server\mmcexts\config.cpp ===
/************************************************************************

Copyright (c) 2002 Microsoft Corporation

Module Name :

    config.cpp

Abstract :

    Configuration APIs

Author :

Revision History :

 ***********************************************************************/

#include "precomp.h"

#pragma warning( disable : 4355 )

WCHAR *
ConvertObjectPathToADSI( 
    const WCHAR *ObjectPath )
{

    WCHAR * ReturnPath      = NULL;
    SIZE_T ReturnPathSize   = 0;

    if ( _wcsnicmp( L"IIS://", (WCHAR*)ObjectPath, wcslen( L"IIS://") ) == 0 )
        {
        // already have an adsi path
        ReturnPathSize  = wcslen( ObjectPath ) + 1;
        ReturnPath      = new WCHAR[ ReturnPathSize ];

        if ( !ReturnPath )
            throw ComError( E_OUTOFMEMORY );

        memcpy( ReturnPath, ObjectPath, ReturnPathSize * sizeof( WCHAR ) );
        }
    else if ( _wcsnicmp( L"/LM/", (WCHAR*)ObjectPath, wcslen( L"/LM/" ) ) == 0 )
        {
        //metabase path to local machine
        ReturnPathSize  = wcslen( (WCHAR*)ObjectPath ) + wcslen( L"IIS://LocalHost/" ) + 1;
        ReturnPath      = new WCHAR[ ReturnPathSize  ];
        
        if ( !ReturnPath )
            throw ComError( E_OUTOFMEMORY );

        StringCchCopyW( ReturnPath, ReturnPathSize, L"IIS://LocalHost/" );
        StringCchCatW( ReturnPath, ReturnPathSize, ObjectPath + wcslen( L"/LM/" ) );
        }
    else if ( _wcsnicmp( L"LM/", (WCHAR*)ObjectPath, wcslen( L"LM/" ) ) == 0 )
        {
        //metabase path to local machine
        ReturnPathSize  = wcslen( (WCHAR*)ObjectPath ) + wcslen( L"IIS://LocalHost/" ) + 1;
        ReturnPath      = new WCHAR[ ReturnPathSize ];
        
        if ( !ReturnPath )
            throw ComError( E_OUTOFMEMORY );

        StringCchCopyW( ReturnPath, ReturnPathSize, L"IIS://LocalHost/" );
        StringCchCatW( ReturnPath, ReturnPathSize, ObjectPath + wcslen( L"LM/" ) );
        }
    else 
        {
        //metabase path to another server
        ReturnPathSize  = wcslen( (WCHAR*)ObjectPath ) + wcslen( L"IIS://" ) + 1;
        ReturnPath      = new WCHAR[ ReturnPathSize ];

        if ( !ReturnPath )
            throw ComError( E_OUTOFMEMORY );

        if ( '/' == *(WCHAR*)ObjectPath )
            StringCchCopyW( ReturnPath, ReturnPathSize, L"IIS:/" );
        else
            StringCchCopyW( ReturnPath, ReturnPathSize, L"IIS://" );

        StringCchCatW( ReturnPath, ReturnPathSize, (WCHAR*)ObjectPath );

        }

    return ReturnPath;
}

HRESULT 
GetTypeInfo( 
    const GUID & guid, 
    ITypeInfo **TypeInfo )
{

    DWORD Result;
    HRESULT hr;
    WCHAR DllName[ MAX_PATH ];

    

    Result = 
        GetModuleFileName(
            g_hinst,
            DllName,
            MAX_PATH - 1 );

    if ( !Result )
        return HRESULT_FROM_WIN32( GetLastError() );

    ITypeLib *TypeLib;

    hr = LoadTypeLibEx( 
        DllName, 
        REGKIND_NONE,  
        &TypeLib );

    if ( FAILED( hr ) )
        return hr;

    hr = TypeLib->GetTypeInfoOfGuid(
            guid,
            TypeInfo );

    TypeLib->Release();

    return hr;
}

void 
FreeReturnedWorkItems(
    ULONG NamesReturned,
    LPWSTR **ItemNamesPtr )
{

    LPWSTR *ItemNames = *ItemNamesPtr;

    if ( ItemNames )
        {

        for( ULONG i = 0; i < NamesReturned; i++ )
            {
            CoTaskMemFree( ItemNames[i] );
            }

        CoTaskMemFree( ItemNames );

        *ItemNamesPtr = NULL;

        }

}

HRESULT
FindWorkItemForVDIR( 
    ITaskScheduler *TaskScheduler,
    LPCWSTR Key,
    ITask   **ReturnedTask,
    LPWSTR  *ReturnedTaskName )
{

    HRESULT Hr;
    SIZE_T KeyLength = sizeof(WCHAR) * ( wcslen( Key ) + 1 );
    WORD DataLength;
    
    if ( ReturnedTask )
        *ReturnedTask = NULL;

    if ( ReturnedTaskName )
        *ReturnedTaskName = NULL;

    ITask *Task = NULL;
    IEnumWorkItems *EnumWorkItems = NULL;
    LPWSTR *ItemNames = NULL;
    BYTE *ItemData = NULL;
    ULONG NamesReturned = 0;

    try
    {
        THROW_COMERROR( TaskScheduler->Enum( &EnumWorkItems ) );
        
        while( 1 )
            {

            THROW_COMERROR( EnumWorkItems->Next( 255, &ItemNames, &NamesReturned ) );

            if ( !NamesReturned )
                throw ComError( HRESULT_FROM_WIN32( ERROR_NOT_FOUND ) );

            for ( ULONG i = 0; i < NamesReturned; i++ )
                {

                THROW_COMERROR( TaskScheduler->Activate( ItemNames[i], __uuidof( *Task ), (IUnknown**)&Task ) );
                THROW_COMERROR( Task->GetWorkItemData( &DataLength, &ItemData ) );

                if ( KeyLength == DataLength && 
                     ( wcscmp( Key, (WCHAR*)ItemData ) == 0 ) )
                    {

                    // Found the item, cleanup and return

                    if ( ReturnedTask )
                        *ReturnedTask = Task;
                    else
                        Task->Release();

                    if ( ReturnedTaskName )
                        {
                        *ReturnedTaskName = ItemNames[i];
                        ItemNames[i] = NULL;
                        }

                    FreeReturnedWorkItems(
                        NamesReturned,
                        &ItemNames );

                    EnumWorkItems->Release();
                    CoTaskMemFree( ItemData );
                    return S_OK;
                    }

                Task->Release();
                Task = NULL;

                CoTaskMemFree( ItemData );
                ItemData = NULL;

                }

            FreeReturnedWorkItems(
                NamesReturned,
                &ItemNames );
            NamesReturned = 0;


            }
        

    }
    catch( ComError Error )
    {
        if ( EnumWorkItems )
            EnumWorkItems->Release();

        if ( Task )
            Task->Release();

        FreeReturnedWorkItems(
           NamesReturned,
           &ItemNames );
        
        CoTaskMemFree( ItemData );

        return Error.m_Hr;
    }

}

HRESULT
CreateWorkItemForVDIR(
    ITaskScheduler *TaskScheduler,
    LPCWSTR Path, 
    LPCWSTR Key )
{
    
    WORD KeySize = sizeof(WCHAR) * ( wcslen( Key ) + 1 );

    WCHAR ItemNameFormat[ MAX_PATH ];
    WCHAR ItemName[ MAX_PATH * 4 ];
    WCHAR Parameters[ MAX_PATH * 4];

    LoadString( g_hinst, IDS_WORK_ITEM_NAME, ItemNameFormat, MAX_PATH - 1 );

    // Use the last part of the path for the description
    const WCHAR *ShortPath = Path + wcslen( Path );

    while( *ShortPath != L'/' &&
           *ShortPath != L'\\' &&
           ShortPath != Path )
        ShortPath--;

    if ( *ShortPath == L'/' ||
         *ShortPath == L'\\' )
        ShortPath++;

    DWORD Result;
    void* InsertArray[2] = { (void*)ShortPath, (void*)Key };
    
    Result = FormatMessage(
        FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
        (LPCVOID)ItemNameFormat,
        0,
        0,
        ItemName,
        MAX_PATH * 4,
        (va_list*)InsertArray );


    if ( !Result )
        return HRESULT_FROM_WIN32( GetLastError() );

    StringCbPrintfW( 
        Parameters, 
        sizeof( Parameters ), 
        L"bitsmgr.dll,Cleanup_RunDLL %s \"%s\" %s", Path, ItemName, Key );

    WORD TriggerNumber;
    ITask *Task = NULL;
    ITaskTrigger *TaskTrigger = NULL;
    IPersistFile *PersistFile = NULL;

    try
    {
        HRESULT Hr;

        Hr = FindWorkItemForVDIR( TaskScheduler, Key, &Task, NULL );

        if ( SUCCEEDED( Hr ) )
            {
            // The work item already exists
            Task->Release();
            return S_OK;
            }

        if ( FAILED(Hr) && HRESULT_FROM_WIN32( ERROR_NOT_FOUND ) != Hr )
            THROW_COMERROR( Hr );

        THROW_COMERROR( TaskScheduler->NewWorkItem( ItemName, CLSID_CTask, __uuidof( *Task ), (IUnknown**)&Task ) );

        // Set basic task data
        THROW_COMERROR( Task->SetApplicationName( L"%SystemRoot%\\system32\\rundll32.exe" ) );
        THROW_COMERROR( Task->SetMaxRunTime( INFINITE ) );
        THROW_COMERROR( Task->SetParameters( Parameters ) );
        THROW_COMERROR( Task->SetPriority( IDLE_PRIORITY_CLASS  ) );
        THROW_COMERROR( Task->SetAccountInformation( L"", NULL ) ); //Run as localsystem
        THROW_COMERROR( Task->SetFlags( TASK_FLAG_RUN_ONLY_IF_LOGGED_ON | TASK_FLAG_HIDDEN  ) );
        THROW_COMERROR( Task->SetWorkItemData( KeySize, (BYTE*)Key ) );

        // set trigger information.  Set start time to now, with a default
        // interval of once a day.
        THROW_COMERROR( Task->CreateTrigger( &TriggerNumber, &TaskTrigger ) );

        SYSTEMTIME LocalTime;
        GetLocalTime( &LocalTime );
        
        TASK_TRIGGER Trigger;
        memset( &Trigger, 0, sizeof( Trigger ) );
        Trigger.cbTriggerSize               = sizeof(Trigger);
        Trigger.wBeginYear                  = LocalTime.wYear;
        Trigger.wBeginMonth                 = LocalTime.wMonth;
        Trigger.wBeginDay                   = LocalTime.wDay;
        Trigger.wStartHour                  = LocalTime.wHour;
        Trigger.wStartMinute                = LocalTime.wMinute;
        Trigger.TriggerType                 = TASK_TIME_TRIGGER_DAILY;
        Trigger.MinutesDuration             = 24 * 60; // 24 hours per day 
        Trigger.MinutesInterval             = 12 * 60; // twice per day
        Trigger.Type.Daily.DaysInterval     = 1;
        
        THROW_COMERROR( TaskTrigger->SetTrigger( &Trigger ) );

        // Commit the changes to disk.
        THROW_COMERROR( Task->QueryInterface( __uuidof( IPersistFile ), (void**)&PersistFile ) );
        THROW_COMERROR( PersistFile->Save( NULL, TRUE ) );

        PersistFile->Release();
        TaskTrigger->Release();
        Task->Release();

        return S_OK;
    }
    catch( ComError Error )
    {
        if ( TaskTrigger )
            TaskTrigger->Release();

        if ( Task )
            Task->Release();

        if ( PersistFile )
            PersistFile->Release();

        TaskScheduler->Delete( ItemName );

        return Error.m_Hr;
    }
    
}

HRESULT
DeleteWorkItemForVDIR(
    ITaskScheduler *TaskScheduler,
    LPWSTR Key )
{
    
    HRESULT Hr;
    LPWSTR TaskName = NULL;



    Hr = FindWorkItemForVDIR( TaskScheduler, Key, NULL, &TaskName );

    if ( HRESULT_FROM_WIN32( ERROR_NOT_FOUND ) == Hr )
        return S_OK;

    if ( FAILED( Hr ) )
        return Hr;

    Hr = TaskScheduler->Delete( TaskName );

    CoTaskMemFree( TaskName );
    return Hr;

}

HRESULT
ConnectToTaskScheduler(
    LPWSTR ComputerName, 
    ITaskScheduler ** TaskScheduler )
{

     HRESULT Hr;

     Hr = CoCreateInstance(
         CLSID_CTaskScheduler,
         NULL,
         CLSCTX_INPROC_SERVER,
         __uuidof( **TaskScheduler ),
         (void **) TaskScheduler );

     if ( FAILED( Hr ) )
         return Hr;

     Hr = (*TaskScheduler)->SetTargetComputer( ComputerName );

     if ( FAILED( Hr ) )
         {
         (*TaskScheduler)->Release();
         (*TaskScheduler) = NULL;
         return Hr;
         }

     return S_OK;

}

HRESULT 
IsBITSEnabledOnVDir(
    PropertyIDManager *PropertyManager,
    IMSAdminBase *IISAdminBase,
    LPWSTR VirtualDirectory,
    BOOL *IsEnabled )
{

    HRESULT Hr;
    DWORD BufferRequired;

    *IsEnabled = false;

    DWORD IsEnabledVal;
    METADATA_RECORD MdRecord;
    memset( &MdRecord, 0, sizeof( MdRecord ) );
    
    MdRecord.dwMDDataType   = DWORD_METADATA;
    MdRecord.dwMDIdentifier = PropertyManager->GetPropertyMetabaseID( MD_BITS_UPLOAD_ENABLED );
    MdRecord.dwMDDataLen    = sizeof(IsEnabled);
    MdRecord.pbMDData       = (PBYTE)&IsEnabledVal;

    Hr =
        IISAdminBase->GetData(
            METADATA_MASTER_ROOT_HANDLE,
            VirtualDirectory,
            &MdRecord,
            &BufferRequired );

    if ( MD_ERROR_DATA_NOT_FOUND == Hr ||
         HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND ) == Hr )
        return S_OK;

    if ( FAILED( Hr ) )
        return Hr;
    
    *IsEnabled = IsEnabledVal ? true : false;
    return S_OK;
}

HRESULT
EnableBITSForVDIR(
    PropertyIDManager   *PropertyManager,
    IMSAdminBase        *IISAdminBase,
    LPCWSTR             Path )
{

    HRESULT Hr;
    METADATA_HANDLE MdVDirKey       = NULL;
    LPWSTR NewScriptMapBuffer       = NULL;
    ITaskScheduler* TaskScheduler   = NULL;

    try
    {

        Hr = DisableBITSForVDIR(
                PropertyManager,
                IISAdminBase,
                Path,
                true );

        if ( FAILED( Hr ) )
            throw ComError( Hr );

        // build the string to add to the scriptmap
        WCHAR SystemDir[ MAX_PATH + 1 ];

        if (!GetSystemDirectoryW( SystemDir, MAX_PATH ) )
            throw ComError( HRESULT_FROM_WIN32( GetLastError() ) );

        WCHAR ScriptMapString[ MAX_PATH * 2 + 1 ];

        StringCbPrintfW( 
            ScriptMapString,
            sizeof( ScriptMapString ),
            L"*,%s\\bitssrv.dll,1," BITS_COMMAND_VERBW,
            SystemDir );

        int RetChars = wcslen( ScriptMapString );
        ScriptMapString[ RetChars ] = L'\0';
        ScriptMapString[ RetChars + 1] = L'\0';

        RetChars += 2;  // ScriptMapScript is now double NULL terminated

        Hr =
        IISAdminBase->OpenKey(
            METADATA_MASTER_ROOT_HANDLE,
            Path,
            METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
            30000,
            &MdVDirKey );

        if (FAILED(Hr))
            throw ComError(Hr);

        DWORD IsEnabled;

        DWORD BufferRequired;
        METADATA_RECORD MdRecord;

        DWORD AccessFlags;
        MdRecord.dwMDIdentifier = MD_ACCESS_PERM;
        MdRecord.dwMDAttributes = METADATA_INHERIT;
        MdRecord.dwMDUserType   = IIS_MD_UT_FILE;
        MdRecord.dwMDDataType   = DWORD_METADATA;
        MdRecord.dwMDDataLen    = sizeof( AccessFlags );
        MdRecord.pbMDData       = (unsigned char*)&AccessFlags;
        MdRecord.dwMDDataTag    = 0;

        Hr =
            IISAdminBase->GetData(
                MdVDirKey,
                NULL,
                &MdRecord,
                &BufferRequired );

        if ( MD_ERROR_DATA_NOT_FOUND == Hr ||
             HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND ) == Hr )
            {
            AccessFlags = 0;
            }
        else if ( FAILED( Hr ) )
            {
            throw ComError( Hr );
            }

        if ( AccessFlags & ( MD_ACCESS_SCRIPT | MD_ACCESS_EXECUTE ) )
            {
            
            AccessFlags &= ~( MD_ACCESS_SCRIPT | MD_ACCESS_EXECUTE );
            MdRecord.dwMDAttributes &= ~METADATA_ISINHERITED;

            Hr = 
                IISAdminBase->SetData(
                    MdVDirKey,
                    NULL,
                    &MdRecord );


            if ( FAILED( Hr ) )
                throw ComError( Hr );

            }

        MdRecord.dwMDIdentifier = PropertyManager->GetPropertyMetabaseID( MD_BITS_UPLOAD_ENABLED );
        MdRecord.dwMDAttributes = METADATA_NO_ATTRIBUTES;
        MdRecord.dwMDUserType   = ALL_METADATA;
        MdRecord.dwMDDataType   = DWORD_METADATA;
        MdRecord.dwMDDataLen    = sizeof(IsEnabled);
        MdRecord.pbMDData       = (PBYTE)&IsEnabled;
        MdRecord.dwMDDataTag    = 0;

        Hr =
            IISAdminBase->GetData(
                MdVDirKey,
                NULL,
                &MdRecord,
                &BufferRequired );
    
        if ( FAILED( Hr ) )
            {
            if ( !( MD_ERROR_DATA_NOT_FOUND == Hr ||
                    HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND ) == Hr ) )
                {
                IISAdminBase->CloseKey( MdVDirKey );
                return S_OK;
                }
            }
        else if ( IsEnabled )
            {
            IISAdminBase->CloseKey( MdVDirKey );
            return S_OK;
            }


        // 
        //  retrieve the current scriptmap adding room to the allocated memory
        //

        memset( &MdRecord, 0, sizeof( MdRecord ) );

        MdRecord.dwMDDataType   = MULTISZ_METADATA;
        MdRecord.dwMDAttributes = METADATA_INHERIT;
        MdRecord.dwMDUserType   = IIS_MD_UT_FILE;
        MdRecord.dwMDIdentifier = MD_SCRIPT_MAPS;
        MdRecord.dwMDDataLen    = 0;
        MdRecord.pbMDData       = (PBYTE)NULL;

        Hr = 
            IISAdminBase->GetData(
                MdVDirKey,
                NULL,
                &MdRecord,
                &BufferRequired );

        if ( MD_ERROR_DATA_NOT_FOUND == Hr ||
             HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND ) == Hr )
            {
            // The Current key doesn't exist.
            MdRecord.pbMDData       = (PBYTE)ScriptMapString;
            MdRecord.dwMDDataLen    = RetChars * sizeof(WCHAR); 
            }
        else if ( HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER ) == Hr )
            {

            NewScriptMapBuffer      = new WCHAR[ ( BufferRequired / sizeof(WCHAR) ) + RetChars ];
            MdRecord.pbMDData       = (PBYTE)NewScriptMapBuffer;
            MdRecord.dwMDDataLen    = BufferRequired + ( RetChars * sizeof(WCHAR) );

            Hr =
                IISAdminBase->GetData(
                    MdVDirKey,
                    NULL,
                    &MdRecord,
                    &BufferRequired );

            if ( FAILED(Hr) )
                throw ComError( Hr );

            // append script entry at the end

            for( WCHAR *p = NewScriptMapBuffer; *p != 0; p += ( wcslen( p ) + 1 ) );
            memcpy( p, ScriptMapString, RetChars * sizeof(WCHAR) );

            MdRecord.pbMDData        = (PBYTE)NewScriptMapBuffer;
            MdRecord.dwMDDataLen     = (DWORD)( ( (char*)p - (char*)NewScriptMapBuffer ) +
                                                ( RetChars * sizeof(WCHAR) ) );
            }
        else
            throw ComError( Hr );

        // Write out the new values starting with ScriptMap

        Hr = 
            IISAdminBase->SetData(
                MdVDirKey,
                NULL,
                &MdRecord );

        if ( FAILED( Hr ) )
            throw ComError( Hr );
         
        // Set the enabled property

        DWORD EnableData = 1;
        memset( &MdRecord, 0, sizeof( MdRecord ) );
        MdRecord.dwMDAttributes = METADATA_NO_ATTRIBUTES;
        MdRecord.dwMDDataType   = DWORD_METADATA;
        MdRecord.dwMDUserType   = PropertyManager->GetPropertyUserType( MD_BITS_UPLOAD_ENABLED );
        MdRecord.dwMDIdentifier = PropertyManager->GetPropertyMetabaseID( MD_BITS_UPLOAD_ENABLED );
        MdRecord.dwMDDataLen    = sizeof(EnableData);
        MdRecord.pbMDData       = (PBYTE)&EnableData;        

        Hr =
            IISAdminBase->SetData(
                MdVDirKey,
                NULL,
                &MdRecord );

        if ( FAILED( Hr ) )
            throw ComError( Hr );

        delete[] NewScriptMapBuffer;

        // Create the task scheduler cleanup work item

        WCHAR GuidString[ 255 ];

        // first try looking up the guid

        MdRecord.dwMDAttributes = METADATA_NO_ATTRIBUTES;
        MdRecord.dwMDDataType   = STRING_METADATA;
        MdRecord.dwMDUserType   = PropertyManager->GetPropertyUserType( MD_BITS_CLEANUP_WORKITEM_KEY );
        MdRecord.dwMDIdentifier = PropertyManager->GetPropertyMetabaseID( MD_BITS_CLEANUP_WORKITEM_KEY );
        MdRecord.dwMDDataLen    = sizeof( GuidString );
        MdRecord.pbMDData       = (PBYTE)GuidString;
        MdRecord.dwMDDataTag    = 0;
       
        Hr = IISAdminBase->GetData(
                MdVDirKey,
                NULL,
                &MdRecord,
                &BufferRequired );

        if ( MD_ERROR_DATA_NOT_FOUND == Hr ||
             HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND ) == Hr )
            {

            // create a new guid and save it away

            GUID guid;
        
            THROW_COMERROR( CoCreateGuid( &guid ) );
            StringFromGUID2( guid, GuidString, 254 );
            
            MdRecord.dwMDDataLen    = sizeof(WCHAR) * ( wcslen(GuidString) + 1 );
            MdRecord.pbMDData       = (PBYTE)GuidString;

            THROW_COMERROR( 
                IISAdminBase->SetData(
                    MdVDirKey,
                    NULL,
                    &MdRecord ) );

            }

        else if ( FAILED( Hr ) )
            throw ComError( Hr );


        THROW_COMERROR( ConnectToTaskScheduler( NULL, &TaskScheduler ) );
        THROW_COMERROR( CreateWorkItemForVDIR( TaskScheduler, Path, GuidString ) );

        TaskScheduler->Release();
        IISAdminBase->CloseKey( MdVDirKey );
        return S_OK;
    }
    
    catch( ComError Exception )
    {
        if ( TaskScheduler )
            TaskScheduler->Release();

        DisableBITSForVDIR(
            PropertyManager,
            IISAdminBase,
            Path,
            false );

        delete[] NewScriptMapBuffer;
        if ( MdVDirKey )
            IISAdminBase->CloseKey( MdVDirKey );
        return Exception.m_Hr;
    }

}

HRESULT
DisableBITSForVDIR(
    PropertyIDManager   *PropertyManager,
    IMSAdminBase        *IISAdminBase,
    LPCWSTR             Path,
    bool                DisableForEnable )
{

    HRESULT Hr;
    METADATA_HANDLE MdVDirKey           = NULL;
    LPWSTR          OriginalScriptMap   = NULL;
    LPWSTR          NewScriptMap        = NULL;
    ITaskScheduler* TaskScheduler       = NULL;

    try
    {

        if ( !DisableForEnable )
            CleanupForRemoval( Path );

        // build the string to add to the scriptmap
        WCHAR SystemDir[ MAX_PATH + 1 ];

        if (!GetSystemDirectoryW( SystemDir, MAX_PATH ) )
            throw ComError( HRESULT_FROM_WIN32( GetLastError() ) );

        WCHAR ScriptMapString[ MAX_PATH * 2 + 1 ];

        StringCchPrintfW( 
            ScriptMapString,
            MAX_PATH * 2 + 1,
            L"*,%s\\bitssrv.dll,1,BITS_COMMAND",
            SystemDir );

        int RetChars = wcslen( ScriptMapString );
        ScriptMapString[ RetChars ] = L'\0';
        ScriptMapString[ RetChars + 1] = L'\0';

        // ScriptMapScript is now double NULL terminated

        WCHAR ScriptMapString2[ MAX_PATH * 2 + 1];

        StringCbPrintfW( 
            ScriptMapString2,
            sizeof( ScriptMapString2 ),
            L"*,%\\bitsserver.dll,1,BITS_COMMAND",
            SystemDir );

        RetChars = wcslen( ScriptMapString2 );
        ScriptMapString2[ RetChars ] = L'\0';
        ScriptMapString2[ RetChars + 1 ] = L'\0';

        // ScriptMapScript2 is not double NULL terminated


        WCHAR ScriptMapString3[ MAX_PATH * 2 + 1 ];

        StringCbPrintfW( 
            ScriptMapString3,
            sizeof( ScriptMapString3 ),
            L"*,%s\\bitssrv.dll,1," BITS_COMMAND_VERBW,
            SystemDir );
        
        RetChars = wcslen( ScriptMapString3 );
        ScriptMapString3[ RetChars ] = L'\0';
        ScriptMapString3[ RetChars + 1] = L'\0';

        // ScriptMapScript3 is now double NULL terminated

        THROW_COMERROR( 
            IISAdminBase->OpenKey(
                METADATA_MASTER_ROOT_HANDLE,
                Path,
                METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
                30000,
                &MdVDirKey ) );

        // 
        //  retrieve the current scriptmap adding room to the allocated memory
        //

        DWORD BufferRequired;

        METADATA_RECORD MdRecord;
        memset( &MdRecord, 0, sizeof( MdRecord ) );

        MdRecord.dwMDDataType   = MULTISZ_METADATA;
        MdRecord.dwMDAttributes = METADATA_INHERIT;
        MdRecord.dwMDUserType   = IIS_MD_UT_FILE;
        MdRecord.dwMDIdentifier = MD_SCRIPT_MAPS;
        MdRecord.dwMDDataLen    = 0;
        MdRecord.pbMDData       = (PBYTE)NULL;

        Hr = 
            IISAdminBase->GetData(
                MdVDirKey,
                NULL,
                &MdRecord,
                &BufferRequired );

        if ( HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER ) != Hr )
            throw ComError( Hr );

        OriginalScriptMap = new WCHAR[ BufferRequired / 2 + 2 ];
        NewScriptMap      = new WCHAR[ BufferRequired / 2 + 2 ];

        OriginalScriptMap[0] = OriginalScriptMap[1] = L'\0';

        MdRecord.dwMDDataLen    = BufferRequired;
        MdRecord.pbMDData       = (PBYTE)OriginalScriptMap;

        Hr = 
            IISAdminBase->GetData(
                MdVDirKey,
                NULL,
                &MdRecord,
                &BufferRequired );


        if ( FAILED(Hr) )
            throw ComError( Hr );

        // Copy the orignal Scriptmap to the new scriptmap
        // removing bits goo in the process.

        LPWSTR CurrentOriginalItem = OriginalScriptMap;
        LPWSTR CurrentNewItem      = NewScriptMap;

        for( ;L'\0' != *CurrentOriginalItem;
             CurrentOriginalItem += ( wcslen( CurrentOriginalItem ) + 1 )  )
            {

            if ( _wcsicmp( CurrentOriginalItem, ScriptMapString ) == 0 )
                continue; //remove this item

            if ( _wcsicmp( CurrentOriginalItem, ScriptMapString2 ) == 0 )
                continue;

            if ( _wcsicmp( CurrentOriginalItem, ScriptMapString3 ) == 0 )
                continue;

            SIZE_T CurrentOriginalItemSize = wcslen( CurrentOriginalItem ) + 1;
            memcpy( CurrentNewItem, CurrentOriginalItem, CurrentOriginalItemSize * sizeof( WCHAR ) );
            CurrentNewItem += CurrentOriginalItemSize;

            }

        // Add the extra 0
        *CurrentNewItem++ = L'\0';

        MdRecord.dwMDDataLen    = (DWORD)( (char*)CurrentNewItem - (char*)NewScriptMap );
        MdRecord.pbMDData       = (PBYTE)NewScriptMap;

        // Set the is enabled property first
        DWORD EnableData = 0;
        METADATA_RECORD MdEnabledRecord;
        memset( &MdEnabledRecord, 0, sizeof( MdEnabledRecord ) );

        MdEnabledRecord.dwMDAttributes = METADATA_NO_ATTRIBUTES;
        MdEnabledRecord.dwMDDataType   = DWORD_METADATA;
        MdEnabledRecord.dwMDUserType   = PropertyManager->GetPropertyUserType( MD_BITS_UPLOAD_ENABLED );
        MdEnabledRecord.dwMDIdentifier = PropertyManager->GetPropertyMetabaseID( MD_BITS_UPLOAD_ENABLED );
        MdEnabledRecord.dwMDDataLen    = sizeof(EnableData);
        MdEnabledRecord.pbMDData       = (PBYTE)&EnableData;

        Hr =
            IISAdminBase->SetData(
                MdVDirKey,
                NULL,
                &MdEnabledRecord );

        if ( FAILED( Hr ) )
            throw ComError( Hr );

        // set the new scriptmap

        Hr = 
            IISAdminBase->SetData(
                MdVDirKey,
                NULL,
                &MdRecord );

        if ( FAILED( Hr ) )
            throw ComError( Hr );

        WCHAR GuidString[ 255 ];
        memset( &MdRecord, 0, sizeof( MdRecord ) );

        MdRecord.dwMDDataType   = STRING_METADATA;
        MdRecord.dwMDAttributes = METADATA_NO_ATTRIBUTES;
        MdRecord.dwMDUserType   = PropertyManager->GetPropertyUserType( MD_BITS_CLEANUP_WORKITEM_KEY );
        MdRecord.dwMDIdentifier = PropertyManager->GetPropertyMetabaseID( MD_BITS_CLEANUP_WORKITEM_KEY );
        MdRecord.dwMDDataLen    = sizeof( GuidString );
        MdRecord.pbMDData       = (PBYTE)GuidString;

        Hr =
            IISAdminBase->GetData(
                MdVDirKey,
                NULL,
                &MdRecord,
                &BufferRequired );

        if ( FAILED( Hr ) && Hr != MD_ERROR_DATA_NOT_FOUND )
            throw ComError( Hr );

        if ( SUCCEEDED( Hr ) && !DisableForEnable )
            {
            
            THROW_COMERROR( ConnectToTaskScheduler( NULL, &TaskScheduler ) );
            THROW_COMERROR( DeleteWorkItemForVDIR( TaskScheduler, GuidString ) );
            TaskScheduler->Release();

            THROW_COMERROR( 
                IISAdminBase->DeleteData(
                    MdVDirKey,
                    NULL,
                    PropertyManager->GetPropertyMetabaseID( MD_BITS_CLEANUP_WORKITEM_KEY ),
                    ALL_METADATA ) );

            }

        delete[] OriginalScriptMap;
        delete[] NewScriptMap;

        IISAdminBase->CloseKey( MdVDirKey );
        MdVDirKey = NULL;
        return S_OK;

    }
    catch( ComError Exception )
    {
        if ( TaskScheduler )
            TaskScheduler->Release();

        delete[] OriginalScriptMap;
        delete[] NewScriptMap;
        if ( MdVDirKey )
            IISAdminBase->CloseKey( MdVDirKey );
        return Exception.m_Hr;
    }

}

HRESULT
FindWorkItemForVDIR( 
    PropertyIDManager   *PropertyManager,
    IMSAdminBase        *AdminBase,
    LPCWSTR             Path,
    LPWSTR              *ReturnedTaskName )
{

    if ( ReturnedTaskName )
        *ReturnedTaskName = NULL;

    WCHAR GuidString[ 255 ];
    DWORD BufferRequired;
    METADATA_RECORD MdRecord;
    HRESULT Hr;

    MdRecord.dwMDDataType   = STRING_METADATA;
    MdRecord.dwMDAttributes = METADATA_NO_ATTRIBUTES;
    MdRecord.dwMDUserType   = PropertyManager->GetPropertyUserType( MD_BITS_CLEANUP_WORKITEM_KEY );
    MdRecord.dwMDIdentifier = PropertyManager->GetPropertyMetabaseID( MD_BITS_CLEANUP_WORKITEM_KEY );
    MdRecord.dwMDDataLen    = sizeof( GuidString );
    MdRecord.pbMDData       = (PBYTE)GuidString;
    MdRecord.dwMDDataTag    = 0;

    Hr =
        AdminBase->GetData(
            METADATA_MASTER_ROOT_HANDLE,
            Path,
            &MdRecord,
            &BufferRequired );

    if ( MD_ERROR_DATA_NOT_FOUND == Hr )
        return S_FALSE;

    ITaskScheduler* TaskScheduler = NULL;
    Hr = ConnectToTaskScheduler( NULL, &TaskScheduler );

    if ( FAILED( Hr ) )
        return Hr;

    Hr = FindWorkItemForVDIR( TaskScheduler, GuidString, NULL, ReturnedTaskName );

    // simply return NULL if the task item isn't found.
    if ( HRESULT_FROM_WIN32( ERROR_NOT_FOUND ) == Hr )
        Hr = S_FALSE;

    TaskScheduler->Release();

    return Hr;
}

CBITSExtensionSetupFactory::CBITSExtensionSetupFactory() :
m_cref(1),
m_TypeInfo(NULL)
{
    OBJECT_CREATED
}
    
CBITSExtensionSetupFactory::~CBITSExtensionSetupFactory()
{
    if ( m_TypeInfo )
        m_TypeInfo->Release();

    OBJECT_DESTROYED
}

STDMETHODIMP CBITSExtensionSetupFactory::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IUnknown *>(this);
    else if (IsEqualIID(riid, __uuidof(IBITSExtensionSetupFactory)))
        *ppv = static_cast<IBITSExtensionSetupFactory *>(this);
    
    if (*ppv) 
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }
    
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CBITSExtensionSetupFactory::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CBITSExtensionSetupFactory::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        // we need to decrement our object count in the DLL
        delete this;
        return 0;
    }
    
    return m_cref;
}

HRESULT
CBITSExtensionSetupFactory::LoadTypeInfo()
{

   if ( m_TypeInfo )
       return S_OK;

   return ::GetTypeInfo( __uuidof( IBITSExtensionSetupFactory ), &m_TypeInfo ); 

}

STDMETHODIMP 
CBITSExtensionSetupFactory::GetIDsOfNames( 
    REFIID,  
    OLECHAR FAR* FAR* rgszNames, 
    unsigned int cNames, 
    LCID, 
    DISPID FAR* rgDispId )
{

    HRESULT Hr;
    Hr = LoadTypeInfo();

    if ( FAILED( Hr ) )
        return Hr;

    return DispGetIDsOfNames( m_TypeInfo, rgszNames, cNames, rgDispId);


}

STDMETHODIMP 
CBITSExtensionSetupFactory::GetTypeInfo( 
    unsigned int iTInfo, 
    LCID lcid, 
    ITypeInfo FAR* FAR* ppTInfo )
{


   *ppTInfo = NULL;

   if(iTInfo != 0)
      return ResultFromScode(DISP_E_BADINDEX);

   HRESULT Hr;
   Hr = LoadTypeInfo();

   if ( FAILED( Hr ) )
       return Hr;

   m_TypeInfo->AddRef();      
   *ppTInfo = m_TypeInfo;

   return NOERROR;
}

STDMETHODIMP 
CBITSExtensionSetupFactory::GetTypeInfoCount( 
    unsigned int FAR* pctinfo )
{
    *pctinfo = 1;
    return NOERROR;
}

STDMETHODIMP 
CBITSExtensionSetupFactory::Invoke( 
    DISPID dispIdMember, 
    REFIID, 
    LCID, 
    WORD wFlags, 
    DISPPARAMS FAR* pDispParams, 
    VARIANT FAR* pVarResult, 
    EXCEPINFO FAR* pExcepInfo, 
    unsigned int FAR* puArgErr )
{

    HRESULT Hr;
    Hr = LoadTypeInfo();

    if ( FAILED( Hr ) )
        return Hr;


   return
       DispInvoke(
           this, 
           m_TypeInfo,
           dispIdMember, 
           wFlags, 
           pDispParams,
           pVarResult, 
           pExcepInfo, 
           puArgErr); 

}


STDMETHODIMP CBITSExtensionSetupFactory::GetObject( 
    BSTR Path, 
    IBITSExtensionSetup **ppExtensionSetup )
{

    WCHAR *ObjectPath = NULL;
    IUnknown *Object = NULL;

    try
    {
        if ( !Path || !ppExtensionSetup )
            throw ComError( E_INVALIDARG );

        *ppExtensionSetup = NULL;
        ObjectPath = ConvertObjectPathToADSI( (WCHAR*)Path );

        THROW_COMERROR( ADsGetObject( BSTR( ObjectPath ), __uuidof( IUnknown ), (void**)&Object ) );

        delete ObjectPath;
        ObjectPath = NULL;

        CBITSExtensionSetup *SetupObj = new CBITSExtensionSetup( NULL, Object );

        if ( !SetupObj )
            throw ComError( E_OUTOFMEMORY );

        Object = NULL;
        *ppExtensionSetup = static_cast<IBITSExtensionSetup*>( SetupObj );
        return S_OK;
    }
    catch( ComError Error )
    {
        delete ObjectPath;
        if ( Object )
            Object->Release();
        return Error.m_Hr;
    }

}


STDMETHODIMP CNonDelegatingIUnknown::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;

    if ( riid == __uuidof(IUnknown) )
        *ppv = static_cast<IUnknown *>(this);
    else if ( riid == __uuidof(IDispatch) )
        *ppv = static_cast<IDispatch*>(m_DelegatingIUnknown);
    else if ( riid == __uuidof(IBITSExtensionSetup) )
        *ppv = static_cast<IBITSExtensionSetup *>(m_DelegatingIUnknown);
    else if ( riid == __uuidof(IADsExtension) )
        *ppv = static_cast<IADsExtension *>(m_DelegatingIUnknown);

    if (*ppv) 
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }
    
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CNonDelegatingIUnknown::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CNonDelegatingIUnknown::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        // we need to decrement our object count in the DLL
        delete m_DelegatingIUnknown;
        return 0;
    }
    
    return m_cref;
}

CNonDelegatingIUnknown::CNonDelegatingIUnknown( CBITSExtensionSetup * DelegatingIUnknown ) :
m_DelegatingIUnknown( DelegatingIUnknown ),
m_cref(1)
{
}

CBITSExtensionSetup::CBITSExtensionSetup( IUnknown *Outer, IUnknown *Object ) :
m_pOuter( Outer ),
m_pObject( Object ),
m_OuterDispatch( NULL ),
m_TypeInfo( NULL ),
m_ADSIPath( NULL ),
m_Path( NULL ),
m_PropertyMan( NULL ),
m_DelegationIUnknown( this ),
m_RemoteInterface( NULL ),
m_InitComplete( false ),
m_Lock( 0 )
{

    if ( m_pOuter )
        {

        HRESULT Hr = m_pOuter->QueryInterface( __uuidof( IDispatch ), (void**)&m_OuterDispatch );

        if ( FAILED( Hr ) )
            m_OuterDispatch = NULL;

        }

    OBJECT_CREATED
}

CBITSExtensionSetup::~CBITSExtensionSetup()
{
    if ( m_pObject )
        {
        m_pObject->Release();
        m_pObject = NULL;
        }

    if ( m_OuterDispatch )
        m_OuterDispatch->Release();

    if ( m_TypeInfo )
        m_TypeInfo->Release();

    delete[] m_Path; // Noop on NULL
    m_Path = NULL;

    if ( m_RemoteInterface )
        m_RemoteInterface->Release();

    delete m_PropertyMan;

    SysFreeString( m_ADSIPath );

    OBJECT_DESTROYED
}

STDMETHODIMP CBITSExtensionSetup::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if ( m_pOuter )
        return m_pOuter->QueryInterface( riid, ppv );
    else
        return m_DelegationIUnknown.QueryInterface( riid, ppv );
}

STDMETHODIMP_(ULONG) CBITSExtensionSetup::AddRef()
{
    
    if ( m_pOuter )
        return m_pOuter->AddRef();
    else
        return m_DelegationIUnknown.AddRef();
}

STDMETHODIMP_(ULONG) CBITSExtensionSetup::Release()
{
    if ( m_pOuter )
        return m_pOuter->AddRef();
    else
        return m_DelegationIUnknown.AddRef();
}

HRESULT
CBITSExtensionSetup::LoadTypeInfo()
{

   if ( m_TypeInfo )
       return S_OK;

   // Lock object
   while( InterlockedExchange( &m_Lock, 1 ) )
       Sleep( 0 );

   HRESULT Hr = ::GetTypeInfo( __uuidof( IBITSExtensionSetup ), &m_TypeInfo ); 

   // Unlock the object
   InterlockedExchange( &m_Lock, 0 );
   return Hr;

}

STDMETHODIMP 
CBITSExtensionSetup::Operate(
    ULONG dwCode, 
    VARIANT varData1, 
    VARIANT varData2, 
    VARIANT varData3)
{

   return E_NOTIMPL;         

}

STDMETHODIMP 
CBITSExtensionSetup::PrivateGetIDsOfNames( 
    REFIID,  
    OLECHAR FAR* FAR* rgszNames, 
    unsigned int cNames, 
    LCID, 
    DISPID FAR* rgDispId )
{

    HRESULT Hr;
    Hr = LoadTypeInfo();

    if ( FAILED( Hr ) )
        return Hr;

    return DispGetIDsOfNames( m_TypeInfo, rgszNames, cNames, rgDispId);


}

STDMETHODIMP 
CBITSExtensionSetup::PrivateGetTypeInfo( 
    unsigned int iTInfo, 
    LCID lcid, 
    ITypeInfo FAR* FAR* ppTInfo )
{


   *ppTInfo = NULL;

   if(iTInfo != 0)
      return ResultFromScode(DISP_E_BADINDEX);

   HRESULT Hr;
   Hr = LoadTypeInfo();

   if ( FAILED( Hr ) )
       return Hr;

   m_TypeInfo->AddRef();      
   *ppTInfo = m_TypeInfo;

   return NOERROR;
}

STDMETHODIMP 
CBITSExtensionSetup::PrivateGetTypeInfoCount( 
    unsigned int FAR* pctinfo )
{
    *pctinfo = 1;
    return NOERROR;
}

STDMETHODIMP 
CBITSExtensionSetup::PrivateInvoke( 
    DISPID dispIdMember, 
    REFIID, 
    LCID, 
    WORD wFlags, 
    DISPPARAMS FAR* pDispParams, 
    VARIANT FAR* pVarResult, 
    EXCEPINFO FAR* pExcepInfo, 
    unsigned int FAR* puArgErr )
{

    HRESULT Hr;
    Hr = LoadTypeInfo();

    if ( FAILED( Hr ) )
        return Hr;


   return
       DispInvoke(
           static_cast<IBITSExtensionSetup*>(this), 
           m_TypeInfo,
           dispIdMember, 
           wFlags, 
           pDispParams,
           pVarResult, 
           pExcepInfo, 
           puArgErr); 

}

STDMETHODIMP 
CBITSExtensionSetup::GetIDsOfNames( 
    REFIID riid,  
    OLECHAR FAR* FAR* rgszNames, 
    unsigned int cNames, 
    LCID lcid, 
    DISPID FAR* rgDispId )
{

    if ( m_OuterDispatch )
        return m_OuterDispatch->GetIDsOfNames( 
            riid,
            rgszNames,
            cNames,
            lcid,
            rgDispId );
    
    return PrivateGetIDsOfNames( 
        riid,
        rgszNames,
        cNames,
        lcid,
        rgDispId );


}

STDMETHODIMP 
CBITSExtensionSetup::GetTypeInfo( 
    unsigned int iTInfo, 
    LCID lcid, 
    ITypeInfo FAR* FAR* ppTInfo )
{


   if ( m_OuterDispatch )
       return m_OuterDispatch->GetTypeInfo(
           iTInfo,
           lcid,
           ppTInfo );

   return 
       PrivateGetTypeInfo(
           iTInfo,
           lcid,
           ppTInfo );

}

STDMETHODIMP 
CBITSExtensionSetup::GetTypeInfoCount( 
    unsigned int FAR* pctinfo )
{

    if ( m_OuterDispatch )
        return m_OuterDispatch->GetTypeInfoCount( pctinfo );

    return PrivateGetTypeInfoCount( pctinfo );

}

STDMETHODIMP 
CBITSExtensionSetup::Invoke( 
    DISPID dispIdMember, 
    REFIID riid, 
    LCID lcid, 
    WORD wFlags, 
    DISPPARAMS FAR* pDispParams, 
    VARIANT FAR* pVarResult, 
    EXCEPINFO FAR* pExcepInfo, 
    unsigned int FAR* puArgErr )
{

    if ( m_OuterDispatch )
        return m_OuterDispatch->Invoke( 
            dispIdMember,
            riid,
            lcid,
            wFlags,
            pDispParams,
            pVarResult,
            pExcepInfo,
            puArgErr );


    return 
        PrivateInvoke( 
            dispIdMember,
            riid,
            lcid,
            wFlags,
            pDispParams,
            pVarResult,
            pExcepInfo,
            puArgErr );

}

HRESULT
CBITSExtensionSetup::ConnectToRemoteExtension()
{
    WCHAR *HostName                     = NULL;
    WCHAR *NewPath                      = NULL;
    BSTR NewPathBSTR                    = NULL;
    IBITSExtensionSetupFactory* Factory = NULL;

    try
    {

        // Extract out the host part of the path

        const SIZE_T PrefixSize = sizeof(L"IIS://")/sizeof(WCHAR) - 1;
        if ( _wcsnicmp( (WCHAR*)m_ADSIPath, L"IIS://", PrefixSize ) != 0 ) 
            throw ComError( E_INVALIDARG );

        WCHAR *HostNameStart = ((WCHAR*)m_ADSIPath) + PrefixSize;

        WCHAR *p = HostNameStart;

        while( L'/' != *p )
            {
            if ( L'\0' == *p )
                throw ComError( E_INVALIDARG );

			p++;
            }

        SIZE_T HostNameSize = (char*)p - (char*)HostNameStart + sizeof(L'\0');
        HostName = new WCHAR[ HostNameSize / sizeof(WCHAR) ];
        if ( !HostName )
            throw ComError( E_OUTOFMEMORY );

        
        memcpy( HostName, HostNameStart, HostNameSize - sizeof(WCHAR) );
        HostName[ ( HostNameSize - sizeof(WCHAR) ) / sizeof(WCHAR) ] = L'\0';

        if ( L'\0' == *++p )
            throw ComError( E_INVALIDARG );

        SIZE_T NewPathSize = wcslen( L"IIS://LocalHost/" ) + wcslen( p ) + 1;
        NewPath = new WCHAR[ NewPathSize ];

        if ( !NewPath )
            throw ComError( E_OUTOFMEMORY );

        StringCchCopyW( NewPath, NewPathSize, L"IIS://LocalHost/" );
        StringCchCatW( NewPath, NewPathSize, p );

        NewPathBSTR = SysAllocString( NewPath );

        if ( !NewPathBSTR )
            throw ComError( E_OUTOFMEMORY );

        COSERVERINFO coinfo;
        coinfo.dwReserved1  = 0;
        coinfo.dwReserved2  = 0;
        coinfo.pAuthInfo    = NULL;
        coinfo.pwszName     = HostName;

        GUID guid = __uuidof( IBITSExtensionSetupFactory );
        MULTI_QI mqi;
        mqi.hr              = S_OK;
        mqi.pIID            = &guid;
        mqi.pItf            = NULL;

        THROW_COMERROR( 
            CoCreateInstanceEx(
                __uuidof(BITSExtensionSetupFactory),
                NULL,
                CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER,
                &coinfo,
                1,
                &mqi ) );
        THROW_COMERROR( mqi.hr );

        Factory     = (IBITSExtensionSetupFactory*)mqi.pItf;
        mqi.pItf    = NULL;

        THROW_COMERROR( Factory->GetObject( NewPathBSTR, &m_RemoteInterface ) );

        Factory->Release();

        SysFreeString( NewPathBSTR );
        delete[] NewPath;
        delete[] HostName;

        return S_OK;
    }
    catch( ComError Error )
    {
        SysFreeString( NewPathBSTR ); 
        delete[] HostName;
        delete[] NewPath;

        if ( Factory )
            Factory->Release();

        return Error.m_Hr;
    }


}

HRESULT CBITSExtensionSetup::LoadPath()
{

    HRESULT Hr;

    if ( m_InitComplete )
        return S_OK;

    // Lock object
    while( InterlockedExchange( &m_Lock, 1 ) )
        Sleep( 0 );

    if ( !m_PropertyMan )
        {

        m_PropertyMan = new PropertyIDManager();

        if ( !m_PropertyMan )
            {
            Hr = E_OUTOFMEMORY;
            goto error;
            }

        Hr = m_PropertyMan->LoadPropertyInfo();

        if ( FAILED(Hr) )
            {
            delete m_PropertyMan;
            m_PropertyMan = NULL;
            goto error;
            }
        
        }

    if ( !m_ADSIPath )
        {
        
        IADs *ObjectADS = NULL;

        if ( m_pObject )
            Hr = m_pObject->QueryInterface( __uuidof(*ObjectADS), (void**) &ObjectADS );
        else
            Hr = m_pOuter->QueryInterface( __uuidof(*ObjectADS), (void**) &ObjectADS );

        if ( FAILED( Hr ) )
            goto error;

        Hr = ObjectADS->get_ADsPath( &m_ADSIPath );

        ObjectADS->Release();
        ObjectADS = NULL;

        if ( FAILED( Hr ) )
            goto error;

        }


    if ( !m_Path && !m_RemoteInterface )
        {

        if ( _wcsnicmp( (WCHAR*)m_ADSIPath, L"IIS://LocalHost/", wcslen( L"IIS://LocalHost/" ) ) == 0 )
            {
            SIZE_T PathSize = wcslen( (WCHAR*)m_ADSIPath ) + 1; 
            m_Path = new WCHAR[ PathSize ]; 
        
            if ( !m_Path )
                {
                Hr = E_OUTOFMEMORY;
                goto error;
                }

            StringCchCopyW( m_Path, PathSize, L"/LM/" );
            StringCchCatW( m_Path, PathSize, reinterpret_cast<WCHAR*>( m_ADSIPath ) + wcslen( L"IIS://LocalHost/" ) );
            }
        
        else
            {
            
            Hr = ConnectToRemoteExtension( );


            if ( FAILED( Hr ) )
                goto error;

            }

        }

    m_InitComplete = true;
    // unlock 
    InterlockedExchange( &m_Lock, 0 );
    return S_OK;

error:
    // unlock 
    InterlockedExchange( &m_Lock, 0 );
    return Hr;

}

STDMETHODIMP CBITSExtensionSetup::EnableBITSUploads()
{

    HRESULT Hr = LoadPath();

    if ( FAILED(Hr) )
        return Hr;

    if ( m_RemoteInterface )
        return m_RemoteInterface->EnableBITSUploads();

    IMSAdminBase *AdminBase = NULL;

    Hr =
        CoCreateInstance(
            GETAdminBaseCLSID(TRUE),
            NULL,
            CLSCTX_SERVER,
            __uuidof( IMSAdminBase ),
            (LPVOID*)&AdminBase );

    if ( FAILED( Hr ) )
        return Hr;

    Hr = EnableBITSForVDIR( m_PropertyMan, AdminBase, m_Path );

    AdminBase->Release();
    
    return Hr;
}

STDMETHODIMP CBITSExtensionSetup::DisableBITSUploads()
{

    HRESULT Hr = LoadPath();

    if ( FAILED(Hr) )
        return Hr;

    if ( m_RemoteInterface )
        return m_RemoteInterface->DisableBITSUploads();

    IMSAdminBase *AdminBase = NULL;

    Hr =
        CoCreateInstance(
            GETAdminBaseCLSID(TRUE),
            NULL,
            CLSCTX_SERVER,
            __uuidof( IMSAdminBase ),
            (LPVOID*)&AdminBase );

    if ( FAILED( Hr ) )
        return Hr;

    Hr = DisableBITSForVDIR( m_PropertyMan, AdminBase, m_Path, false );

    AdminBase->Release();
    
    return Hr;


}

STDMETHODIMP 
CBITSExtensionSetup::GetCleanupTaskName( BSTR *pTaskName )
{

    *pTaskName = NULL;

    HRESULT Hr = LoadPath();

    if ( FAILED(Hr) )
        return Hr;

    if ( m_RemoteInterface )
        return m_RemoteInterface->GetCleanupTaskName( pTaskName );

    IMSAdminBase *AdminBase = NULL;

    Hr =
        CoCreateInstance(
            GETAdminBaseCLSID(TRUE),
            NULL,
            CLSCTX_SERVER,
            __uuidof( IMSAdminBase ),
            (LPVOID*)&AdminBase );

    if ( FAILED( Hr ) )
        return Hr;

    LPWSTR TaskName = NULL;
    Hr = FindWorkItemForVDIR( m_PropertyMan, AdminBase, m_Path, &TaskName );

    if ( SUCCEEDED( Hr ) && TaskName )
        {

        *pTaskName = SysAllocString( TaskName );
        if ( !*pTaskName )
            Hr = E_OUTOFMEMORY;

        CoTaskMemFree( TaskName );
        TaskName = NULL;

        }

    AdminBase->Release();
    
    return Hr;

}


STDMETHODIMP 
CBITSExtensionSetup::GetCleanupTask( 
    [in] REFIID riid, 
    [out,retval] IUnknown **ppUnk )
{

    HRESULT Hr = S_OK;
    ITaskScheduler *TaskScheduler = NULL;
    BSTR ItemName                 = NULL;
    WCHAR *HostName               = NULL;
    
    if ( ppUnk )
        *ppUnk = NULL;

    try
    {

        THROW_COMERROR( LoadPath() );

        //
        // Build the taskscheduler form of the host name
        //
        
        const SIZE_T PrefixSize = sizeof(L"IIS://")/sizeof(WCHAR) - 1;
        if ( _wcsnicmp( (WCHAR*)m_ADSIPath, L"IIS://", PrefixSize ) != 0 ) 
            throw ComError( E_INVALIDARG );

        WCHAR *HostNameStart = ((WCHAR*)m_ADSIPath) + PrefixSize;
        WCHAR *p = HostNameStart;

        while( L'/' != *p )
            {
            if ( L'\0' == *p )
                throw ComError( E_INVALIDARG );

			p++;
            }

        SIZE_T HostNameSize = (char*)p - (char*)HostNameStart + sizeof(L'\0');
        HostName = new WCHAR[ ( HostNameSize / sizeof(WCHAR) ) + 2 ];
        if ( !HostName )
            throw ComError( E_OUTOFMEMORY );

        HostName[0] = HostName[1] = L'\\';
        memcpy( HostName + 2, HostNameStart, HostNameSize - sizeof(WCHAR) );
        HostName[ ( ( HostNameSize - sizeof(WCHAR) ) / sizeof(WCHAR) ) + 2 ] = L'\0';

        if ( _wcsicmp( HostName, L"\\\\LocalHost" ) == 0 )
            {
            delete[] HostName;
            HostName = NULL;
            }

        THROW_COMERROR( ConnectToTaskScheduler( HostName, &TaskScheduler ) );
        THROW_COMERROR( GetCleanupTaskName( &ItemName ) );

        if ( ItemName )
            THROW_COMERROR( TaskScheduler->Activate( (LPCWSTR)ItemName, riid, ppUnk ) );
        else
            Hr = S_FALSE;

    }
    catch( ComError Error )
    {
        Hr = Error.m_Hr;
    }

    if ( TaskScheduler )
        TaskScheduler->Release();

    SysFreeString( ItemName ); 
    delete[] HostName;

    return Hr;

}


#include "bitssrvcfgimp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\server\mmcexts\cleanup.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    cleanup.cpp

Abstract:

    This file implements the BITS server extensions cleanup worker

--*/

#include "precomp.h"

const UINT64 NanoSec100PerSec = 10000000;    //no of 100 nanosecs per second

inline UINT64 FILETIMEToUINT64( const FILETIME & FileTime )
{
    ULARGE_INTEGER LargeInteger;
    LargeInteger.HighPart = FileTime.dwHighDateTime;
    LargeInteger.LowPart = FileTime.dwLowDateTime;
    return LargeInteger.QuadPart;
};

class PollKillError : public ComError
{
public:
    PollKillError( HRESULT Hr ) : 
        ComError( Hr )
    {
    }
};

class CleanupWorker
{

public:
    CleanupWorker( BOOL DeleteAll, HWND hwnd, const WCHAR* Path, 
                   const WCHAR *WorkItemName, const WCHAR *GuidString );
    ~CleanupWorker();
    void DoIt();

private:

    BOOL          m_DeleteAll;
    HWND          m_hwnd;
    const WCHAR * m_Path;
    const WCHAR * m_WorkItemName;
    const WCHAR * m_GuidString;
    const WCHAR * m_ADSIPath;
    IADs        * m_VDir;
    BSTR          m_VDirPath;
    BSTR          m_SessionDirectory;
    BSTR          m_UNCUsername;
    BSTR          m_UNCPassword;
    UINT64        m_CleanupThreshold;
    
    VARIANT       m_vt;
    HANDLE        m_FindHandle;

    HANDLE        m_UserToken;
    HANDLE        m_EventLog;

    BSTR          m_BITSCleanupWorkItemKeyBSTR;
    BSTR          m_BITSUploadEnabledBSTR;
    BSTR          m_BITSSessionTimeoutBSTR;
    BSTR          m_PathBSTR;
    BSTR          m_BITSSessionDirectoryBSTR;
    BSTR          m_UNCUserNameBSTR;
    BSTR          m_UNCPasswordBSTR;

    WCHAR * BuildPath( const WCHAR * Dir, const WCHAR *Sub );
    BSTR    GetBSTRProp( BSTR PropName );
    void  LogonIfRequired();
    void PollKill();

    void RemoveConnectionsFromTree( 
        const WCHAR * DirectoryPath,
        bool IsConnectionDirectory,
        const WCHAR * FileSystemPath = NULL );

    void RemoveConnection( const WCHAR * ConnectionDirectory, const WCHAR *FilesystemPath,
                           const WCHAR * SessionGuid );

    void LogDeletedJob( const WCHAR *Path, const WCHAR *SessionGuid );
    void LogUnexpectedError( HRESULT Hr );
    void LogUnableToRemoveSession( const WCHAR *Path, const WCHAR *SessionGuid, HRESULT Hr );
    void LogUnableToScanDirectory( const WCHAR *Path, HRESULT Hr );

};

void
BITSSetCurrentThreadToken(
    HANDLE hToken )
{

    if ( !SetThreadToken( NULL, hToken ) )
        {

        for( unsigned int i = 0; i < 100; i ++ )
            {

            Sleep( 10 );

            if ( SetThreadToken( NULL, hToken ) )
                return;

            }
        
        TerminateProcess( NULL, GetLastError() ); 

        }

}

CleanupWorker::CleanupWorker(
    BOOL DeleteAll,
    HWND hwnd, 
    const WCHAR* Path, 
    const WCHAR* WorkItemName,
    const WCHAR* GuidString ) :
m_DeleteAll( DeleteAll ),
m_hwnd( hwnd ),
m_Path( Path ),
m_WorkItemName( WorkItemName ),
m_GuidString( GuidString ),
m_ADSIPath( NULL ),
m_VDir( NULL ),
m_VDirPath( NULL ),
m_SessionDirectory( NULL ),
m_CleanupThreshold( 0 ),
m_UNCUsername( NULL ),
m_UNCPassword( NULL ),
m_UserToken( NULL ),
m_EventLog( NULL ),
m_BITSCleanupWorkItemKeyBSTR( NULL ),
m_BITSUploadEnabledBSTR( NULL ),
m_BITSSessionTimeoutBSTR( NULL ),
m_PathBSTR( NULL ),
m_BITSSessionDirectoryBSTR( NULL ),
m_UNCUserNameBSTR( NULL ),
m_UNCPasswordBSTR( NULL )
{
    VariantInit( &m_vt );

    m_BITSCleanupWorkItemKeyBSTR    = SysAllocString( L"BITSCleanupWorkItemKey" );
    m_BITSUploadEnabledBSTR         = SysAllocString( L"BITSUploadEnabled" );
    m_BITSSessionTimeoutBSTR        = SysAllocString( L"BITSSessionTimeout" );
    m_PathBSTR                      = SysAllocString( L"Path" );
    m_BITSSessionDirectoryBSTR      = SysAllocString( L"BITSSessionDirectory" );
    m_UNCUserNameBSTR               = SysAllocString( L"UNCUserName" );
    m_UNCPasswordBSTR               = SysAllocString( L"UNCPassword" );

    if ( !m_BITSCleanupWorkItemKeyBSTR || !m_BITSUploadEnabledBSTR || !m_BITSSessionTimeoutBSTR ||
         !m_PathBSTR || !m_BITSSessionDirectoryBSTR || !m_UNCUserNameBSTR || !m_UNCPasswordBSTR )
        {
        
        SysFreeString( m_BITSCleanupWorkItemKeyBSTR );
        SysFreeString( m_BITSUploadEnabledBSTR );
        SysFreeString( m_BITSSessionTimeoutBSTR );
        SysFreeString( m_PathBSTR );
        SysFreeString( m_BITSSessionDirectoryBSTR );
        SysFreeString( m_UNCUserNameBSTR );
        SysFreeString( m_UNCPasswordBSTR );
        
        throw ComError( E_OUTOFMEMORY ); 
        }


    m_EventLog = 
        RegisterEventSource(
            NULL,                       // server name
            EVENT_LOG_SOURCE_NAME       // source name
            );

    if ( !m_EventLog )
        throw ComError( HRESULT_FROM_WIN32( GetLastError() ) );
    
}

CleanupWorker::~CleanupWorker()
{

    if ( m_EventLog )
        DeregisterEventSource( m_EventLog );

    if ( m_UserToken )
        {
        BITSSetCurrentThreadToken( NULL );
        CloseHandle( m_UserToken );
        }

    delete m_ADSIPath;
    SysFreeString( m_VDirPath );
    SysFreeString( m_SessionDirectory );
    SysFreeString( m_UNCUsername );
    SysFreeString( m_UNCPassword );

    // Free hardcoded strings
    SysFreeString( m_BITSCleanupWorkItemKeyBSTR );
    SysFreeString( m_BITSUploadEnabledBSTR );
    SysFreeString( m_BITSSessionTimeoutBSTR );
    SysFreeString( m_PathBSTR );
    SysFreeString( m_BITSSessionDirectoryBSTR );
    SysFreeString( m_UNCUserNameBSTR );
    SysFreeString( m_UNCPasswordBSTR );

}


void 
CleanupWorker::RemoveConnection( const WCHAR * ConnectionDirectory, const WCHAR *FilesystemPath,
                                 const WCHAR * SessionGuid )
{
   UINT64 LatestTime = 0; 
   HANDLE FindHandle = INVALID_HANDLE_VALUE;
   WCHAR *SearchPath = NULL;
   WCHAR *FileName   = NULL;

   try
   {

       SearchPath = BuildPath( ConnectionDirectory, L"*" );
       
       WIN32_FIND_DATA FindData;

       FindHandle =
            FindFirstFile(
                SearchPath,
                &FindData
                );

       if ( INVALID_HANDLE_VALUE == FindHandle )
           throw ComError( HRESULT_FROM_WIN32( GetLastError() ) );

       bool FoundFile = false;
       do
           {

           if ( FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
               continue;

           FoundFile = true;
           UINT64 CreationTime      = FILETIMEToUINT64( FindData.ftCreationTime );
           UINT64 LastWriteTime     = FILETIMEToUINT64( FindData.ftLastWriteTime ); 
           LatestTime = max( LatestTime, max( CreationTime, LastWriteTime ) );
           }
       while ( FindNextFile( FindHandle, &FindData ) );

       FindClose( FindHandle );
       FindHandle = INVALID_HANDLE_VALUE;

       FILETIME ftCurrentTime;
       GetSystemTimeAsFileTime( &ftCurrentTime );
       UINT64 CurrentTime = FILETIMEToUINT64( ftCurrentTime );

       if ( FoundFile &&
            ( 0xFFFFFFFF - LatestTime > m_CleanupThreshold ) && 
            ( LatestTime + m_CleanupThreshold < CurrentTime ) )
           {
           
           FindHandle =
                FindFirstFile(
                    SearchPath,
                    &FindData
                    );

           if ( INVALID_HANDLE_VALUE == FindHandle )
               throw ComError( HRESULT_FROM_WIN32( GetLastError() ) );

           do
               {

               if ( FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
                   continue;

               FileName = BuildPath( ConnectionDirectory, FindData.cFileName );
               DeleteFile( FileName );

               delete FileName;
               FileName = NULL;

               }
           while ( FindNextFile( FindHandle, &FindData ) );

           FindClose( FindHandle );
           FindHandle = INVALID_HANDLE_VALUE;
                      
           }

       if ( !RemoveDirectory( ConnectionDirectory ) )
           throw ComError( HRESULT_FROM_WIN32( GetLastError() ) );
       
       LogDeletedJob( FilesystemPath, SessionGuid );

   }

   catch( PollKillError Error )
   {
       if ( INVALID_HANDLE_VALUE != FindHandle )
           FindClose( FindHandle );

       delete SearchPath;
       delete FileName;
       throw;
   }
   catch( ComError Error )
   {
       LogUnableToRemoveSession( FilesystemPath, SessionGuid, Error.m_Hr );
   }    

   if ( INVALID_HANDLE_VALUE != FindHandle )
       FindClose( FindHandle );

   delete SearchPath;
   delete FileName;

}


void 
CleanupWorker::RemoveConnectionsFromTree(
    const WCHAR * DirectoryPath,
    bool IsConnectionDirectory,
    const WCHAR * FileSystemPath )
{
    WCHAR *ConnectionDir    = NULL;
    HANDLE FindHandle       = INVALID_HANDLE_VALUE;
    WCHAR *SearchString     = NULL;
    WCHAR *NextSearchPath   = NULL;

    try
    {
        // Look for BITS-Sessions directory in connection tree

        SearchString = BuildPath( DirectoryPath, L"*" );
        
        WIN32_FIND_DATA FindData;


        FindHandle =
            FindFirstFile(
                SearchString,
                &FindData );


        if ( INVALID_HANDLE_VALUE == FindHandle )
            return;

        do
            {

            PollKill();

            if ( !(FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) )
                continue;

            if ( _wcsicmp( L".", FindData.cFileName ) == 0 )
                continue;

            if ( _wcsicmp( L"..", FindData.cFileName ) == 0 )
                continue;

            if ( IsConnectionDirectory )
                {

                GUID Guid;
                if (SUCCEEDED( IIDFromString( FindData.cFileName, &Guid ) ) )
                    {

                    NextSearchPath = BuildPath( DirectoryPath, FindData.cFileName );

                    RemoveConnection( NextSearchPath, FileSystemPath, FindData.cFileName );

                    delete NextSearchPath;
                    NextSearchPath = NULL;
                    }

                }
            else
                {

                if ( _wcsicmp( m_SessionDirectory, FindData.cFileName ) == 0 )
                    {

                    NextSearchPath = BuildPath( DirectoryPath, FindData.cFileName );

                    RemoveConnectionsFromTree( NextSearchPath, true, DirectoryPath );

                    // Mark this as the connection directory so it
                    // will be closed after the search handles are closed.
                    ConnectionDir = NextSearchPath;
                    NextSearchPath = NULL;

                    }
                else
                    {

                    // just another directory to recurse into

                    NextSearchPath = BuildPath( DirectoryPath, FindData.cFileName );

                    RemoveConnectionsFromTree( NextSearchPath, false );

                    delete NextSearchPath;
                    NextSearchPath = NULL;

                    }

                }

                
            }
        while( FindNextFile( FindHandle, &FindData ) );

        if ( INVALID_HANDLE_VALUE != FindHandle )
            {
            FindClose( FindHandle );
            FindHandle = INVALID_HANDLE_VALUE;
            }

        delete SearchString;
        delete NextSearchPath;
        SearchString = NextSearchPath = NULL;

        if ( ConnectionDir )
            {
            // The attempt to remove the directory will fail if 
            // the directory still has valid connections 
            RemoveDirectory( ConnectionDir );
            delete ConnectionDir;
            ConnectionDir = NULL;
            }

    }
    catch( PollKillError Error )
    {
        if ( INVALID_HANDLE_VALUE != FindHandle )
            FindClose( FindHandle );
        delete SearchString;
        delete NextSearchPath;
        delete ConnectionDir;

        throw;

    }
    catch( ComError Error )
    {
       LogUnableToScanDirectory( DirectoryPath, Error.m_Hr );
    }
    
    if ( INVALID_HANDLE_VALUE != FindHandle )
        FindClose( FindHandle );
    delete SearchString;
    delete NextSearchPath;
    delete ConnectionDir;

}

void 
CleanupWorker::PollKill()
{

    if ( m_hwnd )
        {

        MSG msg;

        while( PeekMessage(
                   &msg,
                   m_hwnd,
                   0,
                   0,
                   PM_REMOVE ) )
            {

            if ( WM_QUIT == msg.message )
                throw PollKillError( (HRESULT)msg.wParam );

            TranslateMessage( &msg );
            DispatchMessage( &msg );

            }

        }


}

WCHAR * 
CleanupWorker::BuildPath( 
    const WCHAR *Dir, 
    const WCHAR *Sub )
{
    
    SIZE_T DirLen = wcslen( Dir );
    SIZE_T SubLen = wcslen( Sub );
    SIZE_T MaxStringSize = DirLen + SubLen + 2; // one slash, one terminator
    WCHAR *RetString = new WCHAR[ MaxStringSize ];

    if ( !RetString )
        throw ComError( E_OUTOFMEMORY );

    memcpy( RetString, Dir, sizeof(WCHAR) * (DirLen + 1) );
    WCHAR *p = RetString + DirLen;
    
    if ( p != RetString && *(p - 1) != L'\\' && *(p - 1) != L'/' )
        *p++ = L'\\';

    memcpy( p, Sub, sizeof(WCHAR) * ( SubLen + 1 ) );
    
    return RetString;
}

BSTR
CleanupWorker::GetBSTRProp( BSTR PropName )
{

  BSTR Retval;

  THROW_COMERROR( m_VDir->Get( PropName, &m_vt ) );
  THROW_COMERROR( VariantChangeType( &m_vt, &m_vt, 0, VT_BSTR ) );
  Retval = m_vt.bstrVal;
  m_vt.bstrVal = NULL;
  VariantClear( &m_vt );

  return Retval;

}

void
CleanupWorker::LogonIfRequired()
{

    // Don't logon if the path isn't a UNC path
    // or the user name is blank

    if ( ((WCHAR*)m_VDirPath)[0] != L'\\' ||
         ((WCHAR*)m_VDirPath)[1] != L'\\' ||
         *(WCHAR*)m_UNCUsername == L'\0' )
        return; // no logon required

    // crack the user name into a user and domain
    
    WCHAR *UserName     = (WCHAR*)m_UNCUsername;
    WCHAR *DomainName   = NULL;

    WCHAR *p = UserName;
    while(*p != L'\0')
    {
        if(*p == L'\\')
        {
            *p = L'\0';
            p++;
            //
            // first part is domain
            // second is user.
            //
            DomainName  = UserName;
            UserName    = p;
            break;
        }
        p++;
    }

    if ( !LogonUser(
            UserName,
            DomainName,
            (WCHAR*)m_UNCPassword,
            LOGON32_LOGON_BATCH,
            LOGON32_PROVIDER_DEFAULT,
            &m_UserToken ) )
        {

        if ( GetLastError() == ERROR_LOGON_TYPE_NOT_GRANTED )
            {


            if ( !LogonUser(
                    UserName,
                    DomainName,
                    (WCHAR*)m_UNCPassword,
                    LOGON32_LOGON_INTERACTIVE,
                    LOGON32_PROVIDER_DEFAULT,
                    &m_UserToken ) )
                {

                throw ComError( HRESULT_FROM_WIN32( GetLastError() ) );

                }

             }

        }


    if ( !ImpersonateLoggedOnUser( m_UserToken ) )
        throw ComError( HRESULT_FROM_WIN32( GetLastError() ) );

    
}

void 
CleanupWorker::DoIt()
{

    try
    {

        m_ADSIPath = ConvertObjectPathToADSI( m_Path );

        try
        {
            THROW_COMERROR( ADsGetObject( m_ADSIPath, __uuidof(*m_VDir), (void**)&m_VDir ) );

            if ( m_GuidString )
               {

               BSTR BSTRGuid = GetBSTRProp( m_BITSCleanupWorkItemKeyBSTR );
               int Result = wcscmp( (LPWSTR)BSTRGuid, m_GuidString );

               SysFreeString( BSTRGuid );

               if ( Result != 0 )
                  throw ComError( E_ADS_UNKNOWN_OBJECT );

               }

        }
        catch( ComError Error )
        {

            if ( ( Error.m_Hr == E_ADS_UNKNOWN_OBJECT ) ||
                 ( Error.m_Hr == HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND ) ) ||
              ( Error.m_Hr == E_ADS_PROPERTY_NOT_FOUND ) )
                {
                // Somehow the virtual directory was deleted, but the 
                // task scheduler work item wasn't.  Try to delete it now.

                if ( m_WorkItemName )
                    {

                    ITaskScheduler *TaskScheduler;
                    if ( SUCCEEDED( ConnectToTaskScheduler( NULL, &TaskScheduler ) ) )
                        {
                        TaskScheduler->Delete( m_WorkItemName );
                        TaskScheduler->Release();
                        }

                    }


                }

            throw;
        }

        THROW_COMERROR( m_VDir->Get( m_BITSUploadEnabledBSTR, &m_vt ) );
        THROW_COMERROR( VariantChangeType( &m_vt, &m_vt, 0, VT_BOOL ) );

        if ( !m_vt.boolVal ) // Uploads arn't enabled on this directory
            return;

        if ( !m_DeleteAll )
            {

            THROW_COMERROR( m_VDir->Get( m_BITSSessionTimeoutBSTR, &m_vt ) );
            THROW_COMERROR( VariantChangeType( &m_vt, &m_vt, 0, VT_BSTR ) );

            if ( L'-' == *m_vt.bstrVal )
                return; // do not run cleanup in this directory since cleanup has been disabled 

            UINT64 CleanupSeconds;
            if ( 1 != swscanf( (WCHAR*)m_vt.bstrVal, L"%I64u", &CleanupSeconds ) )
                return;

            if (  CleanupSeconds > ( 0xFFFFFFFFFFFFFFFF / NanoSec100PerSec ) )
                m_CleanupThreshold = 0xFFFFFFFFFFFFFFFF; // overflow case
            else
                m_CleanupThreshold = CleanupSeconds * NanoSec100PerSec;

            }
        else 
            m_CleanupThreshold = 0;


        m_VDirPath          = GetBSTRProp( m_PathBSTR );
        m_SessionDirectory  = GetBSTRProp( m_BITSSessionDirectoryBSTR );
        m_UNCUsername       = GetBSTRProp( m_UNCUserNameBSTR );
        m_UNCPassword       = GetBSTRProp( m_UNCPasswordBSTR );

        LogonIfRequired();

        RemoveConnectionsFromTree( (WCHAR*)m_VDirPath, false );

    }
    catch( PollKillError Error )
    {
        throw;
    }
    catch( ComError Error )
    {
        LogUnexpectedError( Error.m_Hr );
        throw;
    }


}

void
CleanupWorker::LogDeletedJob( 
    const WCHAR *Path, 
    const WCHAR *SessionGuid )
{

    if ( m_EventLog )
        {

        const WCHAR *Strings[] = { Path, SessionGuid };

        ReportEvent(
            m_EventLog,                         // handle to event log
            EVENTLOG_INFORMATION_TYPE,          // event type
            BITSRV_EVENTLOG_CLEANUP_CATAGORY,   // event category
            BITSSRV_EVENTLOG_DELETED_SESSION,   // event identifier
            NULL,                               // user security identifier
            2,                                  // number of strings to merge
            0,                                  // size of binary data
            Strings,                            // array of strings to merge
            NULL                                // binary data buffer
            );

        }

}

void
CleanupWorker::LogUnableToRemoveSession( 
    const WCHAR *Path, 
    const WCHAR *SessionGuid, 
    HRESULT Hr )
{

    if ( m_EventLog )
        {

        const WCHAR *Strings[] = { Path, SessionGuid };

        ReportEvent(
            m_EventLog,                                 // handle to event log
            EVENTLOG_ERROR_TYPE,                        // event type
            BITSRV_EVENTLOG_CLEANUP_CATAGORY,           // event category
            BITSSRV_EVENTLOG_CANT_REMOVE_SESSION,       // event identifier
            NULL,                                       // user security identifier
            2,                                          // number of strings to merge
            sizeof(Hr),                                 // size of binary data
            Strings,                                    // array of strings to merge
            &Hr                                         // binary data buffer
            );

        }

}

void 
CleanupWorker::
LogUnableToScanDirectory( 
    const WCHAR *Path, 
    HRESULT Hr )
{

    if ( m_EventLog )
        {

        const WCHAR *Strings[] = { Path };

        ReportEvent(
            m_EventLog,                                 // handle to event log
            EVENTLOG_ERROR_TYPE,                        // event type
            BITSRV_EVENTLOG_CLEANUP_CATAGORY,           // event category
            BITSSRV_EVENTLOG_CANT_SCAN_DIRECTORY,       // event identifier
            NULL,                                       // user security identifier
            1,                                          // number of strings to merge
            sizeof(Hr),                                 // size of binary data
            Strings,                                    // array of strings to merge
            &Hr                                         // binary data buffer
            );

        }

}


void
CleanupWorker::LogUnexpectedError( 
    HRESULT Hr )
{

    if ( m_EventLog )
        {

        const WCHAR *Strings[] = { m_Path };

        ReportEvent(
            m_EventLog,                         // handle to event log
            EVENTLOG_ERROR_TYPE,                // event type
            BITSRV_EVENTLOG_CLEANUP_CATAGORY,   // event category
            BITSSRV_EVENTLOG_UNEXPECTED_ERROR,  // event identifier
            NULL,                               // user security identifier
            1,                                  // number of strings to merge
            sizeof( Hr ),                       // size of binary data
            Strings,                            // array of strings to merge
            &Hr                                 // binary data buffer
            );

        }

}

void Cleanup_RunDLLW(HWND hwndStub, HINSTANCE hAppInstance, LPWSTR lpszCmdLine, int nCmdShow )
{
    int NumArgs;

    LPWSTR * CommandArgs =
        CommandLineToArgvW(
            lpszCmdLine,
            &NumArgs );

    if ( !CommandArgs )
        return;


    if ( FAILED( CoInitializeEx( NULL, COINIT_MULTITHREADED ) ) )
        return;

    if ( NumArgs != 2 && NumArgs != 3 )
        return;

    LPWSTR Path         = CommandArgs[0];
    LPWSTR WorkItemName = CommandArgs[1];
    LPWSTR GuidString   = NumArgs == 3 ? CommandArgs[2] : NULL;

    try
    {
        CleanupWorker Worker( FALSE, hwndStub, Path, WorkItemName, GuidString );
        Worker.DoIt();
    }
    catch( ComError Error )
    {
    }

    CoUninitialize( );
    GlobalFree( CommandArgs );

}

void CleanupForRemoval( LPCWSTR Path )
{

    HANDLE hToken = NULL;

    try
    {
        if (!OpenThreadToken( GetCurrentThread(), TOKEN_ALL_ACCESS, TRUE, &hToken ) )
            {
            if ( GetLastError() != ERROR_NO_TOKEN )
                return;
            }

        CleanupWorker Worker( TRUE, NULL, Path, NULL, NULL );
        Worker.DoIt();
    }
    catch( ComError Error )
    {
    }

    if ( hToken )
        BITSSetCurrentThreadToken( hToken );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\server\mmcexts\guids.h ===
/************************************************************************

Copyright (c) 2001 Microsoft Corporation

Module Name :

    guids.h

Abstract :

    GUIDS

Author :

Revision History :

 ***********************************************************************/

// {4589A47E-6EC1-4476-BA77-CC9DD1125933}
DEFINE_GUID(CLSID_CPropSheetExtension, 
           0x4589a47e, 0x6ec1, 0x4476, 0xba, 0x77, 0xcc, 0x9d, 0xd1, 0x12, 0x59, 0x33);
// {210E66FB-B00B-4d16-9DE5-6E9241D58225}
DEFINE_GUID(CLSID_CSnapinAbout, 
            0x210e66fb, 0xb00b, 0x4d16, 0x9d, 0xe5, 0x6e, 0x92, 0x41, 0xd5, 0x82, 0x25);

// {A55E7D7F-D51C-4859-8D2D-E308625D908E}
DEFINE_GUID(CLSID_CBITSExtensionSetup, 
            0xa55e7d7f, 0xd51c, 0x4859, 0x8d, 0x2d, 0xe3, 0x8, 0x62, 0x5d, 0x90, 0x8e);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\server\mmcexts\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define IDS_HELPFILE                    1
#define IDS_BITSMGR_DESC                2
#define IDS_NAME                        3
#define IDS_SNAPINNAME                  4
#define IDS_ABOUTNAME                   5
#define IDD_PROPPAGE_LARGE              6
#define IDS_BITS_EXT                    7
#define IDS_NEVER                       8
#define IDS_SECONDS                     9
#define IDS_MINUTES                     10
#define IDS_HOURS                       11
#define IDS_DAYS                        12
#define IDS_UNLIMITED                   13
#define IDS_BYTES                       14
#define IDS_KILOBYTES                   15
#define IDS_MEGABYTES                   16
#define IDS_GIGABYTES                   17
#define IDS_TERABYTES                   18
#define IDS_SESSION_TIMEOUT_INVALID     19
#define IDS_MAX_UPLOAD_INVALID          20
#define IDS_BITSMGR_PROVIDER            21
#define IDS_BITSMGR_VERSION_STR         22
#define IDS_NO_NOTIFICATION             23
#define IDS_BYREF_POST_NOTIFICATION     24
#define IDS_BYVAL_POST_NOTIFICATION     25
#define IDS_NOTIFICATION_URL_INVALID    26
#define IDI_BITSMGR                     27
#define IDS_CANT_LOAD_INHERITED_VALUES  27
#define IDB_SMALL                       28
#define IDS_CANT_SAVE_VALUES            28
#define IDB_LARGE                       29
#define IDS_CANT_LOAD_VALUES            29
#define IDC_CHECK_BITS_UPLOAD           30
#define IDS_CANT_CONNECT_TO_TASKSCHED   30
#define IDC_METABASE_PATH               31
#define IDS_CANT_START_CLEANUP          31
#define IDC_STATIC_SESSION_DIRECTORY    32
#define IDS_CANT_START_CLEANUP_SCHEDULE 32
#define IDC_STATIC_MAX_UPLOAD           33
#define IDS_WORK_ITEM_PROPERTY_PAGE_TITLE 33
#define IDC_STATIC_SESSION_TIMEOUT      34
#define IDS_WORK_ITEM_NAME              34
#define IDC_CHECK_SESSION_DIRECTORY_DEFAULT 35
#define IDS_HOST_ID_INVALID             35
#define IDC_EDIT_SESSION_DIRECTORY      36
#define IDS_FALLBACK_TIMEOUT_INVALID    36
#define IDC_EDIT_MAX_UPLOAD             37
#define IDS_CANT_ACCESS_METABASE        37
#define IDC_CHECK_MAX_UPLOAD_DEFAULT    38
#define IDS_ACCESS_PERMISSION_WARNING   38
#define IDC_EDIT_SESSION_TIMEOUT        39
#define IDC_CHECK_SESSION_TIMEOUT_DEFAULT 40
#define IDC_EDIT_FALLBACK_TIMEOUT       40
#define IDC_COMBO_SESSION_TIMEOUT_UNITS 41
#define IDC_COMBO_MAX_UPLOAD_UNITS      42
#define IDC_STATIC_NOTIFICATION_TYPE    43
#define IDC_COMBO_NOTIFICATION_TYPE     44
#define IDC_CHECK_NOTIFICATION_TYPE_DEFAULT 45
#define IDC_COMBO_FALLBACK_TIMEOUT_UNITS 45
#define IDC_STATIC_NOTIFICATION_URL     46
#define IDC_EDIT_NOTIFICATION_URL       47
#define IDC_RADIO_USE_INHERITED_CONFIG  48
#define IDC_RADIO_USE_CUSTOM_CONFIG     49
#define IDC_STATIC_NOTIFICATION         50
#define IDC_CHECK_LIMIT_MAX_UPLOAD      51
#define IDC_DELETE_FILES                52
#define IDC_BUTTON_CLEANUP_NOW          53
#define IDC_STATIC_CUSTOM_CONFIG        54
#define IDC_CHECK_ENABLE_NOTIFICATIONS  55
#define IDC_BUTTON_SCHEDULE_CLEANUP     56
#define IDC_EDIT_HOSTID                 57
#define IDC_STATIC_NOTIFICATION2        58
#define IDC_ENABLE_SERVER_FARM          59
#define IDC_STATIC_RECONNECT            60
#define IDC_CHECK_FALL                  61
#define IDC_CHECK_FALLBACK_TIMEOUT      61

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        57
#define _APS_NEXT_COMMAND_VALUE         40032
#define _APS_NEXT_CONTROL_VALUE         63
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\server\mmcexts\registry.h ===
/************************************************************************

Copyright (c) 2001 Microsoft Corporation

Module Name :

    registry.h

Abstract :

    GUIDS

Author :

Revision History :

 ***********************************************************************/


#ifndef __Registry_H__
#define __Registry_H__

#include <tchar.h>

struct EXTENSION_NODE
{
    GUID	GUID;
    _TCHAR	szDescription[256];
};

enum EXTENSION_TYPE
{
    NameSpaceExtension,
        ContextMenuExtension, 
        ToolBarExtension,
        PropertySheetExtension,
        TaskExtension,
        DynamicExtension,
        DummyExtension
};

struct EXTENDER_NODE
{
    EXTENSION_TYPE	eType;
    GUID			guidNode;
    GUID			guidExtension;
    _TCHAR			szDescription[256];
};

// This function will register a component in the Registry.
// The component calls this function from its DllRegisterServer function.
HRESULT RegisterServer(HMODULE hModule, 
                       const CLSID& clsid, 
                       const _TCHAR* szFriendlyName,
                       const _TCHAR* szThreadingModel = _T("Apartment"),
                       bool Remoteable = false,
                       const _TCHAR* SecurityString = NULL ) ;

// This function will unregister a component.  Components
// call this function from their DllUnregisterServer function.
HRESULT UnregisterServer(const CLSID& clsid) ;


// This function will register a Snap-In component.  Components
// call this function from their DllRegisterServer function.
HRESULT RegisterSnapin(const CLSID& clsid,         // Class ID
                       const _TCHAR* szNameString,   // NameString
                       const CLSID& clsidAbout);		// Class Id for About Class


HRESULT UnregisterSnapin(const CLSID& clsid);         // Class ID

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\server-setup\bitsrvc\bitsrvc.cpp ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <objbase.h>
#include <stdio.h>
#include <msiquery.h>

typedef HRESULT (*CallFunc)( void );

UINT RegisterDLL( MSIHANDLE hInstall, const char *DllName )
{

#if 0
    CHAR DbgMessage[ MAX_PATH ];
    sprintf( DbgMessage, "ProcessId %u, ThreadId %u", GetCurrentProcessId(), GetCurrentThreadId() );
    MessageBoxA( NULL, DbgMessage, NULL, MB_OK );
#endif

    ASSERT( MsiGetMode( hInstall, MSIRUNMODE_SCHEDULED ) ||
            MsiGetMode( hInstall, MSIRUNMODE_ROLLBACK ) );

    HRESULT CoInitHr;

    CoInitHr = CoInitialize( NULL );

    if ( FAILED( CoInitHr ) && ( RPC_E_CHANGED_MODE != CoInitHr ) )
        return (UINT)CoInitHr;

    HMODULE hModule     = NULL;
    HRESULT Hr          = S_OK;

    hModule = LoadLibrary( DllName );

    if ( !hModule )
        {
        Hr = HRESULT_FROM_WIN32( GetLastError() );
        goto exit;
        }


    CallFunc RegisterFunc = (CallFunc)GetProcAddress( hModule, "DllRegisterServer" );
    
    Hr = (*RegisterFunc)();

    FreeLibrary( hModule );
    hModule = NULL;

exit:

    if ( RPC_E_CHANGED_MODE != CoInitHr )
        CoUninitialize();
    
    SetLastError( Hr );
    return SUCCEEDED(Hr) ? ERROR_SUCCESS : ERROR_INSTALL_FAILURE;

}

UINT UnregisterDLL( MSIHANDLE hInstall, char *DllName )
{

    ASSERT( MsiGetMode( hInstall, MSIRUNMODE_SCHEDULED ) ||
            MsiGetMode( hInstall, MSIRUNMODE_ROLLBACK ) );

    HRESULT CoInitHr;

    CoInitHr = CoInitialize( NULL );

    if ( FAILED( CoInitHr ) && ( RPC_E_CHANGED_MODE != CoInitHr ) )
        return (UINT)CoInitHr;

    HMODULE hModule     = NULL;
    HRESULT Hr          = S_OK;


    hModule = LoadLibrary( DllName );

    if ( !hModule )
        {
        DbgPrint( "Unable to load %s, error 0x%8.8X", DllName, GetLastError() );
        }
    else
        {

        CallFunc RegisterFunc = (CallFunc)GetProcAddress( hModule, "DllUnregisterServer" );

        if ( !RegisterFunc )
            {
            DbgPrint( "Unable to load %s!DllRegisterServer, error 0x%8.8X", DllName, GetLastError() );
            }
        else
            {

            Hr = (*RegisterFunc)();

            FreeLibrary( hModule );
            hModule = NULL;

            if ( FAILED( Hr ) )
                goto exit;

            }

        }
    
    FreeLibrary( hModule );
    hModule = NULL;

exit:

    if ( RPC_E_CHANGED_MODE == CoInitHr )
        return Hr;

    CoUninitialize();
    return SUCCEEDED(Hr) ? ERROR_SUCCESS : ERROR_INSTALL_FAILURE;

}

UINT DllInstallBITSMgr( MSIHANDLE hInstall )
{
    return RegisterDLL( hInstall, "bitsmgr.dll" );
}

UINT DllUninstallBITSMgr( MSIHANDLE hInstall )
{
    return UnregisterDLL( hInstall, "bitsmgr.dll" );
}

UINT DllInstallBITSIsapi( MSIHANDLE hInstall )
{
    return RegisterDLL( hInstall, "bitssrv.dll" );
}

UINT DllUninstallBITSIsapi( MSIHANDLE hInstall )
{
    return UnregisterDLL( hInstall, "bitssrv.dll" );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\server\mmcexts\registry.cpp ===
/************************************************************************

Copyright (c) 2001 Microsoft Corporation

Module Name :

    registry.cpp

Abstract :

    Handles registering and unregistering the snapin.

Author :

Revision History :

 ***********************************************************************/

#include "precomp.h"
#include "sddl.h"

// if not standalone comment out next line
//#define STANDALONE

// list all nodes that are extendable here
// List the GUID and then the description
// terminate with a NULL, NULL set.
EXTENSION_NODE _ExtendableNodes[] = {
    {NULL, NULL}
};

// list all of the nodes that we extend
EXTENDER_NODE _NodeExtensions[] = {

    // IIS instance node
    {PropertySheetExtension,
    {0xa841b6c7, 0x7577, 0x11d0, {0xbb, 0x1f, 0x00, 0xa0, 0xc9, 0x22, 0xe7, 0x9c}}, //g_IISInstanceNode,
    {0x4589a47e, 0x6ec1, 0x4476, {0xba, 0x77, 0xcc, 0x9d, 0xd1, 0x12, 0x59, 0x33}},
    _T("BITS server MMC extension")},

    // IIS child node
    {PropertySheetExtension,
    {0xa841b6c8, 0x7577, 0x11d0, {0xbb, 0x1f, 0x00, 0xa0, 0xc9, 0x22, 0xe7, 0x9c}}, // g_IISChildNode,
    {0x4589a47e, 0x6ec1, 0x4476, {0xba, 0x77, 0xcc, 0x9d, 0xd1, 0x12, 0x59, 0x33}},
    _T("BITS server MMC extension")},

    {DummyExtension,
    NULL,
    NULL,
    NULL}
};

////////////////////////////////////////////////////////
//
// Internal helper functions prototypes
//

// Set the given key and its value.
BOOL setKeyAndValue(const _TCHAR* pszPath,
                    const _TCHAR* szSubkey,
                    const _TCHAR* szValue) ;

// Set the given key and its value in the MMC Snapin location
BOOL setSnapInKeyAndValue(const _TCHAR* szKey,
                          const _TCHAR* szSubkey,
                          const _TCHAR* szName,
                          const _TCHAR* szValue);

// Set the given valuename under the key to value
BOOL setValue(const _TCHAR* szKey,
              const _TCHAR* szValueName,
              const _TCHAR* szValue);

BOOL setBinaryValue(
              const _TCHAR* szKey,
              const _TCHAR* szValueName,
              void * Data,
              ULONG DataSize );


BOOL setSnapInExtensionNode(const _TCHAR* szSnapID,
                            const _TCHAR* szNodeID,
                            const _TCHAR* szDescription);

// Delete szKeyChild and all of its descendents.
LONG recursiveDeleteKey(HKEY hKeyParent, const _TCHAR* szKeyChild) ;

////////////////////////////////////////////////////////
//
// Constants
//

// Size of a CLSID as a string
//const int CLSID_STRING_SIZE = 39 ;

#if defined( UNICODE ) || defined( _UNICODE )
const DWORD MAX_GUID_CHARS = 50;
#else
const DWORD MAX_GUID_CHARS = 50 * 8; // worst encoding
#endif

/////////////////////////////////////////////////////////
//
// Public function implementation
//

//
// Register the component in the registry.
//

#if defined ( UNICODE ) || defined( _UNICODE )

HRESULT
StringFromGUIDInternal(
    const CLSID& clsid,
    _TCHAR * szGuidString
     )
{

    return StringFromGUID2( clsid, szGuidString, MAX_GUID_CHARS );

}

#else
#error Provide a unicode to DBCS thunk version
#endif

HRESULT RegisterServer(HMODULE hModule,            // DLL module handle
                       const CLSID& clsid,         // Class ID
                       const _TCHAR* szFriendlyName,
                       const _TCHAR* ThreadingModel,
                       bool  Remoteable,
                       const _TCHAR* SecurityString )       //   IDs
{
    // Get server location.
    _TCHAR szModule[512] ;
    DWORD dwResult =
        ::GetModuleFileName(hModule,
        szModule,
        sizeof(szModule)/sizeof(_TCHAR)) ;

    if ( !dwResult )
        {
        assert(dwResult != 0) ;
        return HRESULT_FROM_WIN32( GetLastError() );
        }

    // Get CLSID
    _TCHAR szCLSID[ MAX_GUID_CHARS ];
    HRESULT Hr = StringFromGUIDInternal( clsid, szCLSID );

    if ( FAILED( Hr ) )
        {
        assert( 0 );
        return Hr;
        }

    // Build the key CLSID\\{...}
    _TCHAR szKey[64] ;
    StringCbCopy(szKey, sizeof(szKey), _T("CLSID\\")) ;
    StringCbCat(szKey, sizeof(szKey), szCLSID) ;

    // Add the CLSID to the registry.
    setKeyAndValue(szKey, NULL, szFriendlyName) ;

    if ( Remoteable )
        setValue( szKey, _T("AppID"), szCLSID );

    // Add the server filename subkey under the CLSID key.
    setKeyAndValue(szKey, _T("InprocServer32"), szModule) ;

    // set the threading model
    StringCbCat(szKey, sizeof(szKey), _T("\\InprocServer32"));
    setValue(szKey, _T("ThreadingModel"), ThreadingModel);


    if ( Remoteable )
        {
        
        PSECURITY_DESCRIPTOR  SecurityDescriptor = NULL;
        ULONG   DescriptorSize;

        // build the key name  
        StringCbCopy(szKey, sizeof(szKey), _T("AppId\\")) ;
        StringCbCat(szKey, sizeof(szKey), szCLSID) ;

        setKeyAndValue(szKey, NULL, szFriendlyName) ;
        setValue(szKey, _T("DllSurrogate"), _T("") );

        if ( !ConvertStringSecurityDescriptorToSecurityDescriptor(
            SecurityString,
            SDDL_REVISION_1,
            &SecurityDescriptor,
            &DescriptorSize
            ) )
            return HRESULT_FROM_WIN32( GetLastError() );

        setBinaryValue( szKey, _T("LaunchPermission"), SecurityDescriptor, DescriptorSize );
        setBinaryValue( szKey, _T("AccessPermission"), SecurityDescriptor, DescriptorSize );

        LocalFree( (HLOCAL)SecurityDescriptor );

        }

    return S_OK ;
}

//
// Remove the component from the registry.
//
LONG UnregisterServer(const CLSID& clsid)       //   IDs
{
    // Get CLSID
    _TCHAR szCLSID[ MAX_GUID_CHARS ];
    HRESULT Hr = StringFromGUIDInternal( clsid, szCLSID );

    if ( FAILED( Hr ) )
        {
        assert( 0 );
        return Hr;
        }


    // Build the key CLSID\\{...}
    _TCHAR szKey[64] ;
    StringCbCopy( szKey, sizeof(szKey), _T("CLSID\\") );
    StringCbCat( szKey, sizeof(szKey), szCLSID );

    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;
    assert((lResult == ERROR_SUCCESS) ||
               (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

    StringCbCopy(szKey, sizeof(szKey), _T("AppId\\"));
    StringCbCat(szKey, sizeof(szKey), szCLSID );
    lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey); 

    return S_OK;
}

//
// Register the snap-in in the registry.
//
HRESULT RegisterSnapin(const CLSID& clsid,         // Class ID
                       const _TCHAR* szNameString,   // NameString
                       const CLSID& clsidAbout)         // Class Id for About Class

{
    // Get CLSID
    _TCHAR szCLSID[ MAX_GUID_CHARS ];
    _TCHAR szAboutCLSID[ MAX_GUID_CHARS ];

    EXTENSION_NODE *pExtensionNode;
    EXTENDER_NODE *pNodeExtension;
    _TCHAR szKeyBuf[1024] ;
    HKEY hKey;

    HRESULT Hr = StringFromGUIDInternal(clsid, szCLSID);

    if ( FAILED( Hr ) )
        {
        assert( 0 );
        return Hr;
        }

    if (IID_NULL != clsidAbout)
        Hr = StringFromGUIDInternal(clsidAbout, szAboutCLSID);

    if ( FAILED( Hr ) )
        {
        assert( 0 );
        return Hr;
        }

    // Add the CLSID to the registry.
    setSnapInKeyAndValue(szCLSID, NULL, _T("NameString"), szNameString) ;

#ifdef STANDALONE
    setSnapInKeyAndValue(szCLSID, _T("StandAlone"), NULL, NULL);
#endif

    if (IID_NULL != clsidAbout)
        setSnapInKeyAndValue(szCLSID, NULL, _T("About"), szAboutCLSID);

    // register each of the node types in _ExtendableNodes as an extendable node
    for (pExtensionNode = &(_ExtendableNodes[0]);*pExtensionNode->szDescription;pExtensionNode++)
    {
        _TCHAR szExtendCLSID[ MAX_GUID_CHARS ];
        Hr = StringFromGUIDInternal(pExtensionNode->GUID, szExtendCLSID);

        if ( FAILED( Hr ) )
            {
            assert( 0 );
            return Hr;
            }

        setSnapInExtensionNode(szCLSID, szExtendCLSID, pExtensionNode->szDescription);
    }

    // register each of the node extensions
    for (pNodeExtension = &(_NodeExtensions[0]);*pNodeExtension->szDescription;pNodeExtension++)
    {

        _TCHAR szExtendCLSID[ MAX_GUID_CHARS ];

        Hr = StringFromGUIDInternal(pNodeExtension->guidNode, szExtendCLSID);

        if ( FAILED( Hr ) )
            {
            assert(0);
            return Hr;
            }

        StringCbCopy(szKeyBuf, sizeof( szKeyBuf ), _T("SOFTWARE\\Microsoft\\MMC\\NodeTypes\\"));
        StringCbCat(szKeyBuf, sizeof( szKeyBuf), szExtendCLSID);

        switch (pNodeExtension->eType) {
        case NameSpaceExtension:
            StringCbCat( szKeyBuf, sizeof( szKeyBuf ), _T("\\Extensions\\NameSpace") );
            break;
        case ContextMenuExtension:
            StringCbCat( szKeyBuf, sizeof( szKeyBuf ), _T("\\Extensions\\ContextMenu") );
            break;
        case ToolBarExtension:
            StringCbCat(szKeyBuf, sizeof( szKeyBuf ), _T("\\Extensions\\ToolBar"));
            break;
        case PropertySheetExtension:
            StringCchCat(szKeyBuf, sizeof( szKeyBuf ), _T("\\Extensions\\PropertySheet"));
            break;
        case TaskExtension:
            StringCchCat(szKeyBuf, sizeof( szKeyBuf ), _T("\\Extensions\\Task"));
            break;
        case DynamicExtension:
            StringCbCat(szKeyBuf, sizeof( szKeyBuf ), _T("\\Dynamic Extensions"));
        default:
            break;
        }

        // Create and open key and subkey.
        long lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE ,
            szKeyBuf,
            0, NULL, REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS, NULL,
            &hKey, NULL) ;

        if (lResult != ERROR_SUCCESS)
        {
            return FALSE ;
        }

        _TCHAR szNodeCLSID[ MAX_GUID_CHARS ];
        Hr = StringFromGUIDInternal(pNodeExtension->guidExtension, szNodeCLSID);
        
        if ( FAILED(Hr) )
            {
            assert( 0 );
            return Hr;
            }
        
        // Set the Value.
        if (pNodeExtension->szDescription != NULL)
        {
            RegSetValueEx(hKey, szNodeCLSID, 0, REG_SZ,
                (BYTE *)pNodeExtension->szDescription,
                (_tcslen(pNodeExtension->szDescription)+1)*sizeof(_TCHAR)) ;
        }

        RegCloseKey(hKey);

    }

    return S_OK;
}

//
// Unregister the snap-in in the registry.
//
HRESULT UnregisterSnapin(const CLSID& clsid)         // Class ID
{
    _TCHAR szKeyBuf[1024];
    _TCHAR szCLSID[ MAX_GUID_CHARS ];

    // Get CLSID
    HRESULT Hr = StringFromGUIDInternal(clsid, szCLSID);

    if ( FAILED( Hr ) )
        {
        assert( 0 );
        return Hr;
        }

    // Load the buffer with the Snap-In Location
    StringCbCopy(szKeyBuf, sizeof( szKeyBuf ), _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"));

    // Copy keyname into buffer.
    StringCbCat(szKeyBuf, sizeof( szKeyBuf ), _T("\\"));
    StringCchCat(szKeyBuf, sizeof( szKeyBuf ), szCLSID);

    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_LOCAL_MACHINE, szKeyBuf);
    assert((lResult == ERROR_SUCCESS) ||
               (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

    return S_OK;
}

//
// Delete a key and all of its descendents.
//
LONG recursiveDeleteKey(HKEY hKeyParent,           // Parent of key to delete
                        const _TCHAR* lpszKeyChild)  // Key to delete
{
    // Open the child.
    HKEY hKeyChild ;
    LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyChild, 0,
        KEY_ALL_ACCESS, &hKeyChild) ;
    if (lRes != ERROR_SUCCESS)
    {
        return lRes ;
    }

    // Enumerate all of the decendents of this child.
    FILETIME time ;
    _TCHAR szBuffer[256] ;
    DWORD dwSize = 256 ;
    while (RegEnumKeyEx(hKeyChild, 0, szBuffer, &dwSize, NULL,
        NULL, NULL, &time) == S_OK)
    {
        // Delete the decendents of this child.
        lRes = recursiveDeleteKey(hKeyChild, szBuffer) ;
        if (lRes != ERROR_SUCCESS)
        {
            // Cleanup before exiting.
            RegCloseKey(hKeyChild) ;
            return lRes;
        }
        dwSize = 256 ;
    }

    // Close the child.
    RegCloseKey(hKeyChild) ;

    // Delete this child.
    return RegDeleteKey(hKeyParent, lpszKeyChild) ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setKeyAndValue(const _TCHAR* szKey,
                    const _TCHAR* szSubkey,
                    const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Copy keyname into buffer.
    StringCbCopy(szKeyBuf, sizeof( szKeyBuf ), szKey) ;

    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        StringCbCat(szKeyBuf, sizeof( szKeyBuf ), _T("\\")) ;
        StringCchCat(szKeyBuf, sizeof( szKeyBuf ), szSubkey ) ;
    }

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, NULL, 0, REG_SZ,
            (BYTE *)szValue,
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}

//
// Open a key value and set it
//
BOOL setValue(const _TCHAR* szKey,
              const _TCHAR* szValueName,
              const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Copy keyname into buffer.
    StringCbCopy(szKeyBuf, sizeof( szKeyBuf ), szKey) ;

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szValueName, 0, REG_SZ,
            (BYTE *)szValue,
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}

//
// Open a key value and set it
//
BOOL setBinaryValue(
              const _TCHAR* szKey,
              const _TCHAR* szValueName,
              void * Data,
              ULONG DataSize )
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Copy keyname into buffer.
    StringCbCopy(szKeyBuf, sizeof( szKeyBuf ), szKey) ;

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    RegSetValueEx(hKey, szValueName, 0, REG_BINARY,
        (BYTE *)Data,
        DataSize ) ;

    RegCloseKey(hKey) ;
    return TRUE ;
}


//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setSnapInKeyAndValue(const _TCHAR* szKey,
                          const _TCHAR* szSubkey,
                          const _TCHAR* szName,
                          const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Load the buffer with the Snap-In Location
    StringCbCopy(szKeyBuf, sizeof( szKeyBuf ), _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"));

    // Copy keyname into buffer.
    StringCbCat(szKeyBuf, sizeof( szKeyBuf ), _T("\\")) ;
    StringCbCat(szKeyBuf, sizeof( szKeyBuf ), szKey) ;

    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        StringCbCat( szKeyBuf, sizeof( szKeyBuf ), _T("\\") ) ;
        StringCbCat( szKeyBuf, sizeof( szKeyBuf ), szSubkey ) ;
    }

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szName, 0, REG_SZ,
            (BYTE *)szValue,
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}

BOOL setSnapInExtensionNode(const _TCHAR* szSnapID,
                            const _TCHAR* szNodeID,
                            const _TCHAR* szDescription)
{
    HKEY hKey;
    _TCHAR szSnapNodeKeyBuf[1024] ;
    _TCHAR szMMCNodeKeyBuf[1024];

    // Load the buffer with the Snap-In Location
    StringCbCopy(szSnapNodeKeyBuf, sizeof(szSnapNodeKeyBuf), _T("SOFTWARE\\Microsoft\\MMC\\SnapIns\\"));
    // add in the clisid into buffer.
    StringCbCat(szSnapNodeKeyBuf, sizeof(szSnapNodeKeyBuf), szSnapID) ;
    StringCbCat(szSnapNodeKeyBuf, sizeof(szSnapNodeKeyBuf), _T("\\NodeTypes\\"));
    StringCbCat(szSnapNodeKeyBuf, sizeof(szSnapNodeKeyBuf), szNodeID) ;

    // Load the buffer with the NodeTypes Location
    StringCbCopy(szMMCNodeKeyBuf, sizeof( szMMCNodeKeyBuf ), _T("SOFTWARE\\Microsoft\\MMC\\NodeTypes\\"));
    StringCchCat(szMMCNodeKeyBuf, sizeof( szMMCNodeKeyBuf ), szNodeID) ;

    // Create and open the Snapin Key.
    long lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE ,
        szSnapNodeKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szDescription != NULL)
    {
        RegSetValueEx(hKey, NULL, 0, REG_SZ,
            (BYTE *)szDescription,
            (_tcslen(szDescription)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;

    // Create and open the NodeTypes Key.
    lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE ,
        szMMCNodeKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szDescription != NULL)
    {
        RegSetValueEx(hKey, NULL, 0, REG_SZ,
            (BYTE *)szDescription,
            (_tcslen(szDescription)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;

    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\service\resource.h ===
/************************************************************************

Copyright (c) 2000 - 2000 Microsoft Corporation

Module Name :

    resource.h

Abstract :

    Localized strings

Author :

Revision History :

 ***********************************************************************/
//
// 100-199 - globals
// 200-299 - QMgr
// 300-399 - service
// 400-499 - logon
// 500-599 - progdl
//
// 1000-1099 - HTTP protocol
// 1100-1199 - SMB  protocol
// 1200-1299 - multicast protocol
//

#define IDS_SERVICE_NAME                101
#define IDS_SERVICE_DESCRIPTION         102

//
// Registry data for CLogonSubscriber
//
#define IDR_LOGONSUB                    401

//
// Registry data for CLogon2Subscriber
//
#define IDR_LOGON2SUB                   402

//
// subscription strings for CLogonMonitor
//
#define IDS_LOGON_SUB_NAME              403
#define IDS_LOGON_SUB_DESCRIPTION       404
#define IDS_LOGOFF_SUB_NAME             405
#define IDS_LOGOFF_SUB_DESCRIPTION      406
#define IDS_DISCONNECT_SUB_NAME         407
#define IDS_DISCONNECT_SUB_DESCRIPTION  408
#define IDS_RECONNECT_SUB_NAME          409
#define IDS_RECONNECT_SUB_DESCRIPTION   410
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\service\memory.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1990 - 1999

Module Name:

    memory.cxx

Abstract:

    This file contains the new and delete routines for memory management in
    the Bits runtime.  Rather than using the memory management provided by the
    C++ system we'll use the system allocator.

Revision History:

    mikemon    ??-??-??    Beginning of time (at least for this file).
    mikemon    12-31-90    Upgraded the comments.
    mariogo    04-24-96    Rewrite to unify platforms, behavior and performance.

--*/

#include <qmgrlib.h>

#if !defined(BITS_V12_ON_NT4)
#include <memory.tmh>
#endif

HANDLE hBitsHeap = 0;
unsigned int DebugFlags = 0;

#define  NO_HEAP_SLOWDOWN


///////////////////////////////////////////////////////////////////////////
//
//  Default allocators
//
///////////////////////////////////////////////////////////////////////////

#if !defined(DBG)

void * _cdecl operator new(size_t nSize)
{
    void *pNewMemory = HeapAlloc( hBitsHeap, 0, nSize );

    if ( !pNewMemory )
        {
        LogError( "Unable to allocate memory block of size, %X\n", nSize );
        throw ComError( E_OUTOFMEMORY );
        }

    return pNewMemory;
}

void _cdecl operator delete(void *pMemory)
{
    if (!pMemory)
        return;

    if (!HeapFree( hBitsHeap, 0, pMemory ))
        {
        LogError( "Error occured freeing memory at %p, error %!winerr!\n",
                  pMemory, GetLastError() );
        }
}

int fHeapInitialized = 0;

int InitializeBitsAllocator(void)
{
#if 1

    if (0 == fHeapInitialized)
        {
        if (0 == hBitsHeap)
            {
            hBitsHeap = RtlCreateHeap(  HEAP_GROWABLE
                                     | HEAP_FREE_CHECKING_ENABLED
                                     | HEAP_CLASS_1,
                                     0,
                                     16 * 1024 - 512,
                                     0,
                                     0,
                                     0
                                     );
            }

        if (hBitsHeap)
            {
            fHeapInitialized = 1;
            }

        if (0 == fHeapInitialized )
            {
            return(ERROR_NOT_ENOUGH_MEMORY);
            }
        }

    return(0);


#else

    hBitsHeap = RtlProcessHeap();

    return(0);

#endif
}

int
BitspCheckHeap (
    void
    )
// Allow some checked compenents to be linked into a free memory.cxx.
{
    return 0;
}


#else // ******************** DEBUG ********************

#ifdef NO_HEAP_SLOWDOWN
int fMemoryCheck = 0;
#else
int fMemoryCheck = 1;
#endif

int fHeapInitialized = 0;

CRITICAL_SECTION BitsHeapLock;

typedef NTSYSAPI
USHORT
(NTAPI RTLCAPTURESTACKBACKTRACE)(
   IN ULONG FramesToSkip,
   IN ULONG FramesToCapture,
   OUT PVOID *BackTrace,
   OUT PULONG BackTraceHash OPTIONAL
   );

typedef RTLCAPTURESTACKBACKTRACE * PRTLCAPTURESTACKBACKTRACE;

PRTLCAPTURESTACKBACKTRACE g_RtlCaptureStackBackTrace;

int InitializeBitsAllocator(void)
/*++

Routine Description:

    Called during Bits initialization. This function must can by one
    thread at a time.  Sets the heap handle for debugging.

    Maybe called more then once if this (or a later step) of Bits
    initialization fails.

--*/
{
    if (0 == fHeapInitialized)
        {
        if (0 == hBitsHeap)
            {
            hBitsHeap = RtlCreateHeap(  HEAP_GROWABLE
                                     | HEAP_TAIL_CHECKING_ENABLED
                                     | HEAP_FREE_CHECKING_ENABLED
                                     | HEAP_CLASS_1,
                                     0,
                                     16 * 1024 - 512,
                                     0,
                                     0,
                                     0
                                     );
            }

        if (hBitsHeap)
            {
            if (0 == RtlInitializeCriticalSection(&BitsHeapLock))
                {
                fHeapInitialized = 1;
                }
            }

        if (0 == fHeapInitialized )
            {
            return(ERROR_NOT_ENOUGH_MEMORY);
            }

        HMODULE hModule = GetModuleHandle( L"kernel32" );
        if (hModule)
            {
            g_RtlCaptureStackBackTrace = (PRTLCAPTURESTACKBACKTRACE) GetProcAddress( hModule, "RtlCaptureStackBacktrace" );

            // ignore error, because it's just a debugging aid and is not available in Win2000
            }
        }

    return(0);
}

#define Bits_GUARD 0xA1

typedef struct _Bits_MEMORY_BLOCK
{
    // First,forward and backward links to other Bits heap allocations.
    // These are first allow easy debugging with the dl command
    struct _Bits_MEMORY_BLOCK *next;
    struct _Bits_MEMORY_BLOCK *previous;

    // Specifies the size of the block of memory in bytes.
    unsigned long size;

    // Thread id of allocator
    unsigned long tid;

    void *          AllocStackTrace[4];

    // (Pad to make header 0 mod 8) 0 when allocated, 0xF0F0F0F0 when freed.
    unsigned long free;

    // Reserve an extra 4 bytes as the front guard of each block.
    unsigned char frontguard[4];

    // Data will appear here.  Note that the header must be 0 mod 8.

    // Reserve an extra 4 bytes as the rear guard of each block.
    unsigned char rearguard[4];

} Bits_MEMORY_BLOCK;

//
// Compile-time test to ensure that Bits_MEMORY_BLOCK.rearguard is aligned on
// natural boundary.
//

#if defined(_WIN64)
C_ASSERT( (FIELD_OFFSET( Bits_MEMORY_BLOCK, rearguard ) % 16) == 0 );
#else
C_ASSERT( (FIELD_OFFSET( Bits_MEMORY_BLOCK, rearguard ) % 8) == 0 );
#endif

Bits_MEMORY_BLOCK * AllocatedBlocks = 0;
unsigned long BlockCount = 0;

int
CheckMemoryBlock (
    Bits_MEMORY_BLOCK * block
    )
{
    if (   block->frontguard[0] != Bits_GUARD
        || block->frontguard[1] != Bits_GUARD
        || block->frontguard[2] != Bits_GUARD
        || block->frontguard[3] != Bits_GUARD )
        {
        LogError("BAD BLOCK (front) @ %p\n", block);
        ASSERT(0);
        return(1);
        }

    if (   block->rearguard[block->size]   != Bits_GUARD
        || block->rearguard[block->size+1] != Bits_GUARD
        || block->rearguard[block->size+2] != Bits_GUARD
        || block->rearguard[block->size+3] != Bits_GUARD )
        {
        LogError("BAD BLOCK (rear) @ %p (%p)\n",block, &block->rearguard[block->size]);
        ASSERT(0);
        return(1);
        }

    ASSERT(block->free == 0);

    if ( block->next != 0)
       {
       ASSERT(block->next->previous == block);
       }

    if ( block->previous != 0)
       {
       ASSERT(block->previous->next == block);
       }

    return(0);
}

int
BitsValidateHeapList(
    void
    )
// Called with BitsHeapLock held.
{
    Bits_MEMORY_BLOCK * block;
    unsigned Blocks = 0;

    // Under stress this check causes performance to drop too much.
    // Compile with -DNO_HEAP_SLOWDOWN or ed the flag in memory
    // to speed things up.

    if (fMemoryCheck == 0)
        {
        return(0);
        }

    block = AllocatedBlocks;

    while (block != 0)
        {
        if (CheckMemoryBlock(block))
            {
            return(1);
            }
        block = block->next;
        Blocks++;
        }

    ASSERT(Blocks == BlockCount);

    return(0);
}

int
BitspCheckHeap (
    void
    )
// Returns 0 if the heap appears to be okay.
{
    if (fMemoryCheck == 0)
        {
        return(0);
        }

    EnterCriticalSection(&BitsHeapLock);

    int ret = BitsValidateHeapList();

    LeaveCriticalSection(&BitsHeapLock);

    return(ret);
}

void * __cdecl
operator new(
    size_t size
    )
{
    Bits_MEMORY_BLOCK * block;

    EnterCriticalSection(&BitsHeapLock);

    ASSERT( ("You allocated a negative amount",
            size < (size + sizeof(Bits_MEMORY_BLOCK))) );

    BitsValidateHeapList();

    block = (Bits_MEMORY_BLOCK *) HeapAlloc( hBitsHeap, 0, size + sizeof(Bits_MEMORY_BLOCK));
    if ( block == 0 )
        {
        LeaveCriticalSection(&BitsHeapLock);

        LogError( "Unable to allocate memory block of size %X\n", size );
        throw ComError( E_OUTOFMEMORY );
        }

    block->size = size;
    block->tid = GetCurrentThreadId();
    block->free = 0;

    if (AllocatedBlocks != 0)
        AllocatedBlocks->previous = block;

    block->next = AllocatedBlocks;
    block->previous = 0;
    AllocatedBlocks = block;
    BlockCount++;

    block->frontguard[0] = Bits_GUARD;
    block->frontguard[1] = Bits_GUARD;
    block->frontguard[2] = Bits_GUARD;
    block->frontguard[3] = Bits_GUARD;

    #if i386

    if (g_RtlCaptureStackBackTrace)
        {
        ULONG ignore;

        g_RtlCaptureStackBackTrace(
                                 2,
                                 4,
                                 (void **) &block->AllocStackTrace,
                                 &ignore);
        }
    #endif


    block->rearguard[size]   = Bits_GUARD;
    block->rearguard[size+1] = Bits_GUARD;
    block->rearguard[size+2] = Bits_GUARD;
    block->rearguard[size+3] = Bits_GUARD;

    LeaveCriticalSection(&BitsHeapLock);

    return(&(block->rearguard[0]));
}

void __cdecl
operator delete (
    IN void * obj
    )
{
    Bits_MEMORY_BLOCK * block;

    if (obj == 0)
        return;

    EnterCriticalSection(&BitsHeapLock);

    block = (Bits_MEMORY_BLOCK *) (((unsigned char *) obj)
                    - FIELD_OFFSET(Bits_MEMORY_BLOCK, rearguard));

    // Validate block being freed.

    CheckMemoryBlock(block);

    if (block->next != 0)
        {
        CheckMemoryBlock(block->next);
        }

    if (block->previous != 0)
        {
        CheckMemoryBlock(block->previous);
        }

    // Remove the block from the list

    if (block == AllocatedBlocks)
        AllocatedBlocks = block->next;

    if (block->next != 0)
        block->next->previous = block->previous;

    if (block->previous != 0)
        block->previous->next = block->next;

    // Mark this block as free
    block->free = 0xF0F0F0F0;

    // Validate other Bits allocations.
    BlockCount-- ;
    BitsValidateHeapList();

    LeaveCriticalSection(&BitsHeapLock);

    if (!HeapFree( hBitsHeap, 0, block ))
        {
        LogError( "Error occured freeing memory at %p, error %!winerr!\n",
                  block, GetLastError() );
        }
}

#endif // not debug
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\utils\cfreg.cpp ===
/************************************************************************

Copyright (c) 2000 - 2000 Microsoft Corporation

Module Name :

    cfreg.cpp

Abstract :

    Registry wrapper functions.

Author :

Revision History :

 ***********************************************************************/
#include "qmgrlibp.h"

#if !defined(BITS_V12_ON_NT4)
#include "cfreg.tmh"
#endif

////////////////////////////////////////////////////////////////////////////
//
// Public Function  GetRegStringValue()
//                  Read the registry value of timestamp for last detection
// Input:   Name of value
// Output:  SYSTEMTIME structure contains the time
// Return:  HRESULT flag indicating the success of this function
//
////////////////////////////////////////////////////////////////////////////
HRESULT GetRegStringValue(LPCTSTR lpszValueName, LPTSTR lpszBuffer, int iBufferSize)
{
    HKEY        hKey;
    DWORD       dwType = REG_SZ;
    DWORD       dwSize = iBufferSize;
    DWORD       dwRet;

    if (lpszValueName == NULL || lpszBuffer == NULL)
    {
        return E_INVALIDARG;
    }

    //
    // query the last timestamp value
    //
    dwRet = RegQueryValueEx(
                    g_GlobalInfo->m_QmgrRegistryRoot,
                    lpszValueName,
                    NULL,
                    &dwType,
                    (LPBYTE)lpszBuffer,
                    &dwSize);

    if (dwRet == ERROR_SUCCESS && dwType == REG_SZ)
    {
        return S_OK;
    }

    return E_FAIL;

}


////////////////////////////////////////////////////////////////////////////
//
// Public Function  SetRegStringValue()
//                  Set the registry value of timestamp as current system local time
// Input:   name of the value to set. pointer to the time structure to set time. if null,
//          we use current system time.
// Output:  None
// Return:  HRESULT flag indicating the success of this function
//
////////////////////////////////////////////////////////////////////////////
HRESULT SetRegStringValue(LPCTSTR lpszValueName, LPCTSTR lpszNewValue)
{
    HKEY        hKey;
    HRESULT     hRet = E_FAIL;
    DWORD       dwResult;

    if (lpszValueName == NULL || lpszNewValue == NULL)
    {
        return E_INVALIDARG;
    }


    //
    // set the time to the lasttimestamp value
    //
    hRet = (RegSetValueEx(                                   //SEC: REVIEWED 2002-03-28
                    g_GlobalInfo->m_QmgrRegistryRoot,
                    lpszValueName,
                    0,
                    REG_SZ,
                    (const unsigned char *)lpszNewValue,
                    lstrlen(lpszNewValue) + 1                // SEC: REVIEWED 2002-03-28
                    ) == ERROR_SUCCESS) ? S_OK : E_FAIL;

    return hRet;
}



////////////////////////////////////////////////////////////////////////////
//
// Public Function  DeleteRegStringValue()
//                  Delete the registry value entry
// Input:   name of the value to entry,
// Output:  None
// Return:  HRESULT flag indicating the success of this function
//
////////////////////////////////////////////////////////////////////////////
HRESULT DeleteRegStringValue(LPCTSTR lpszValueName)
{
    HKEY        hKey;
    HRESULT     hRet = E_FAIL;
    DWORD       dwResult;

    if (lpszValueName == NULL)
    {
        return E_INVALIDARG;
    }


    //
    // set the time to the lasttimestamp value
    //
    hRet = (RegDeleteValue(
                    g_GlobalInfo->m_QmgrRegistryRoot,
                    lpszValueName
                    ) == ERROR_SUCCESS) ? S_OK : E_FAIL;

    return hRet;

}

////////////////////////////////////////////////////////////////////////////
//
// Public Function  GetRegDWordValue()
//                  Get a DWORD from specified regustry value name
// Input:   name of the value to retrieve value
// Output:  pointer to the retrieved value
// Return:  HRESULT flag indicating the success of this function
//
////////////////////////////////////////////////////////////////////////////
HRESULT GetRegDWordValue(LPCTSTR lpszValueName, LPDWORD pdwValue)
{
    HKEY        hKey;
    int         iRet;
    DWORD       dwType = REG_DWORD, dwSize = sizeof(DWORD);

    if (lpszValueName == NULL)
    {
        return E_INVALIDARG;
    }

    //
    // open critical fix key
    //
    iRet = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    C_QMGR_REG_KEY,
                    0,
                    KEY_READ,
                    &hKey);

    if (iRet == ERROR_SUCCESS)
        {

        //
        // query the last timestamp value
        //
        iRet = RegQueryValueEx(          //SEC: REVIEWED 2002-03-28
                        hKey,
                        lpszValueName,
                        NULL,
                        &dwType,
                        (LPBYTE)pdwValue,
                        &dwSize);
        RegCloseKey(hKey);

        if (iRet == ERROR_SUCCESS)
            {
            if (dwType == REG_DWORD)
                {
                return S_OK;
                }

            return E_FAIL;
            }
        }

    return HRESULT_FROM_WIN32( iRet );
}


////////////////////////////////////////////////////////////////////////////
//
// Public Function  SetRegDWordValue()
//                  Set the registry value as a DWORD
// Input:   name of the value to set. value to set
// Output:  None
// Return:  HRESULT flag indicating the success of this function
//
////////////////////////////////////////////////////////////////////////////
HRESULT SetRegDWordValue(LPCTSTR lpszValueName, DWORD dwValue)
{
    HKEY        hKey;
    HRESULT     hRet = E_FAIL;
    DWORD       dwResult;

    if (lpszValueName == NULL)
    {
        return E_INVALIDARG;
    }

    //
    // open the key
    //
    if (RegCreateKeyEx(                               //SEC: REVIEWED 2002-03-28
                    HKEY_LOCAL_MACHINE,         // root key
                    C_QMGR_REG_KEY,     // subkey
                    0,                          // reserved
                    NULL,                       // class name
                    REG_OPTION_NON_VOLATILE,    // option
                    KEY_WRITE,                  // security
                    NULL,                       // security attribute
                    &hKey,
                    &dwResult) == ERROR_SUCCESS)
    {

        //
        // set the time to the lasttimestamp value
        //
        hRet = (RegSetValueEx(          //SEC: REVIEWED 2002-03-28
                        hKey,
                        lpszValueName,
                        0,
                        REG_DWORD,
                        (LPBYTE)&dwValue,
                        sizeof(DWORD)
                        ) == ERROR_SUCCESS) ? S_OK : E_FAIL;
        RegCloseKey(hKey);
    }
    return hRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\service\service.cxx ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    service.cxx

Abstract:

    Process init and service controller interaction

Author:

    Mario Goertzel    [MarioGo]

Revision History:

    MarioGo    06-14-95    Cloned RPCSS from the old endpoint mapper.
    jroberts   06-29-00    Cloned BITS from RPCSS
--*/

#include "qmgrlib.h"

#if !defined(BITS_V12_ON_NT4)
#include "service.tmh"
#endif

#define CHECK_DLL_VERSION 1

//
// We delay the expensive setup tasks for a few minutes, to avoid slowing the
// boot or logon process.  The delay time is expressed in milliseconds.
//
// #define STARTUP_DELAY (5 * 60 * 1000)
#define STARTUP_DELAY (5 * 1000)

// Array of service status blocks and pointers to service control
// functions for each component service.

#define SERVICE_NAME _T("BITS")
#define DEVICE_PREFIX   _T("\\\\.\\")

VOID WINAPI ServiceMain(DWORD, LPTSTR*);
VOID UpdateState(DWORD dwNewState);

extern BOOL CatalogDllMain (
    HINSTANCE hInst,
    DWORD dwReason,
    LPVOID lpReserved
);
SERVICE_TABLE_ENTRY gaServiceEntryTable[] = {
    { SERVICE_NAME, (LPSERVICE_MAIN_FUNCTION)ServiceMain},
    { NULL, NULL }
    };

HINSTANCE g_hInstance;

SERVICE_STATUS        gServiceStatus;
SERVICE_STATUS_HANDLE ghServiceHandle;

// This event is set when we receive a SERVICE_CONTROL_STOP/SHUTDOWN
HANDLE g_hServiceStopEvent = NULL;

//
// When TRUE, the process is running outside the service controller.
//
BOOL g_fVisible = FALSE;

typedef SERVICE_STATUS_HANDLE (*PREGISTER_FUNC)(
    LPCTSTR lpServiceName,
    LPHANDLER_FUNCTION_EX lpHandlerProc,
    LPVOID lpContext );

typedef VOID (*PSERVICE_MAIN_FUNC)(
    DWORD argc,
    LPTSTR *lpszArgv,
    PREGISTER_FUNC RegisterFunc );

extern "C"
VOID
BITSServiceMain(
    DWORD argc,
    LPTSTR *argv,
    PREGISTER_FUNC lpRegisterFunc
    );


#if CHECK_DLL_VERSION

BOOL
GetModuleVersion64(
    HMODULE hDll,
    ULONG64 * pVer
    );

BOOL
GetFileVersion64(
    LPTSTR      szFullPath,
    ULONG64 *   pVer
    );
#endif


LPHANDLER_FUNCTION_EX g_RealHandler = NULL;
HINSTANCE g_RealLibrary = NULL;
LONG g_RealLibraryRefs = 0;

ULONG
ServiceHandlerThunk(
    DWORD dwCode,
    DWORD dwEventType,
    PVOID EventData,
    PVOID pData )
{
    InterlockedIncrement( &g_RealLibraryRefs );

    ULONG Result =
        g_RealHandler( dwCode, dwEventType, EventData, pData );

    if (!InterlockedDecrement( &g_RealLibraryRefs ) )
        {
        FreeLibrary( g_RealLibrary );
        g_RealLibrary = NULL;
        }

    return Result;
}

SERVICE_STATUS_HANDLE
RegisterServiceHandlerThunk(
    LPCTSTR lpServiceName,
    LPHANDLER_FUNCTION_EX lpHandlerProc,
    LPVOID lpContext )
{
    g_RealHandler = lpHandlerProc;

    return
    RegisterServiceCtrlHandlerEx( lpServiceName,
                                  ServiceHandlerThunk,
                                  lpContext
                                  );
}

bool
JumpToRealDLL(
    DWORD argc,
    LPTSTR *argv )
{
    #define MAX_DLLNAME (MAX_PATH+1)

    HKEY BitsKey = NULL;

    LONG Result =
        RegOpenKey( HKEY_LOCAL_MACHINE, C_QMGR_REG_KEY, &BitsKey );

    if ( Result )
        goto noload;

    static TCHAR DLLName[MAX_DLLNAME];
    DWORD Type;
    DWORD NameSize = sizeof(DLLName);

    Result = RegQueryValueEx(
        BitsKey,
        C_QMGR_SERVICEDLL,
        NULL,
        &Type,
        (LPBYTE)DLLName,
        &NameSize );

    if ( Result ||
         (( Type != REG_SZ ) && (Type != REG_EXPAND_SZ)) )
        {
        goto noload;
        }

    RegCloseKey( BitsKey );
    BitsKey = NULL;

    if (Type == REG_EXPAND_SZ)
        {
        static TCHAR ExpandedDLLName[MAX_DLLNAME];

        DWORD size = ExpandEnvironmentStrings( DLLName, ExpandedDLLName, MAX_DLLNAME );

        if (size == 0)
            {
            // out of resources
            return true;
            }

        HRESULT hr;
        hr = StringCchCopy( DLLName, RTL_NUMBER_OF(DLLName), ExpandedDLLName );
        if (FAILED(hr))
            {
            // too long; must be badly formatted.  Ignore it.
            goto noload;
            }
        }

#if CHECK_DLL_VERSION
    //
    // At this point, we know that the registry specifies an alternate DLL.
    // See whether it has a later version than the current one.
    //
    ULONG64 AlternateDllVersion = 0;
    ULONG64 MyDllVersion = 0;

    if (!QMgrFileExists( DLLName ))
        {
        goto noload;
        }

    if (!GetFileVersion64( DLLName, &AlternateDllVersion ))
        {
        // can't ascertain the version.  Don't start the service at all.
        return true;
        }

    if (!GetModuleVersion64( g_hInstance, &MyDllVersion ))
        {
        // can't ascertain the version.  Don't start the service at all.
        return true;
        }

    if (MyDllVersion >= AlternateDllVersion)
        {
        goto noload;
        }
#endif

    g_RealLibrary = LoadLibrary( DLLName );

    if ( !g_RealLibrary )
        goto noload;

    PSERVICE_MAIN_FUNC ServiceMainFunc =
        (PSERVICE_MAIN_FUNC)GetProcAddress( g_RealLibrary, "BITSServiceMain" );

    if ( !ServiceMainFunc )
        goto noload;

    g_RealLibraryRefs = 1;

    // Ok to call into real library now.

    ( *ServiceMainFunc ) ( argc, argv, RegisterServiceHandlerThunk );

    if (!InterlockedDecrement( &g_RealLibraryRefs ) )
        {
        FreeLibrary( g_RealLibrary );
        g_RealLibrary = NULL;
        }

    return true;

noload:
    if ( BitsKey )
        RegCloseKey( BitsKey );
    if ( g_RealLibrary )
        FreeLibrary( g_RealLibrary );
    return false;
}

VOID WINAPI
ServiceMain(
    DWORD argc,
    LPTSTR *argv
    )
/*++

Routine Description:

    Callback by the service controller when starting this service.

Arguments:

    argc - number of arguments, usually 1

    argv - argv[0] is the name of the service.
           argv[>0] are arguments passed to the service.

Return Value:

    None

--*/
{

    volatile static LONG ThreadRunning = 0;

    if ( InterlockedCompareExchange( &ThreadRunning, 1, 0 ) == 1 )
        {

        // A thread is already running ServiceMain, just exit.
        // The service controller has a bug where it can create multiple
        // threads to call ServiceMain in high stress conditions.

        return;
        }


    if (!JumpToRealDLL( argc, argv) )
        {

        BITSServiceMain(
            argc,
            argv,
            RegisterServiceCtrlHandlerEx );

        }

    ThreadRunning = 0;

}

DWORD g_LastServiceControl;


ULONG WINAPI
BITSServiceHandler(
    DWORD   dwCode,
    DWORD dwEventType,
    PVOID EventData,
    PVOID pData
    )
/*++

Routine Description:

    Lowest level callback from the service controller to
    cause this service to change our status.  (stop, start, pause, etc).

Arguments:

    opCode - One of the service "Controls" value.
            SERVICE_CONTROL_{STOP, PAUSE, CONTINUE, INTERROGATE, SHUTDOWN}.

Return Value:

    None

--*/
{
    switch(dwCode)
        {
        case SERVICE_CONTROL_STOP:
            {
            LogService( "STOP request" );

            //
            // only relevant in running state; damaging if we are stopping
            // and g_hServiceStopEvent is deleted.
            //
            if (gServiceStatus.dwCurrentState == SERVICE_RUNNING)
                {
                g_LastServiceControl = dwCode;

                UpdateState( SERVICE_STOP_PENDING );
                SetEvent( g_hServiceStopEvent );
                }

            break;
            }

        case SERVICE_CONTROL_INTERROGATE:
            // Service controller wants us to call SetServiceStatus.

            LogService( "INTERROGATE request" );
            UpdateState(gServiceStatus.dwCurrentState);
            break ;

        case SERVICE_CONTROL_SHUTDOWN:
            // The machine is shutting down.  We'll be killed once we return.

            LogService( "SHUTDOWN request" );

            g_LastServiceControl = dwCode;

            UpdateState( SERVICE_STOP_PENDING );
            SetEvent( g_hServiceStopEvent );

            while (gServiceStatus.dwCurrentState == SERVICE_STOP_PENDING)
                {
                LogService( "service pending; sleeping..." );
                Sleep(100);
                }
            break;

#if !defined( BITS_V12_ON_NT4 )
        case SERVICE_CONTROL_DEVICEEVENT:
            return DeviceEventCallback( dwEventType, EventData );
#endif

        case SERVICE_CONTROL_SESSIONCHANGE:
            {
             WTSSESSION_NOTIFICATION* pswtsi = (WTSSESSION_NOTIFICATION*) EventData;
            DWORD dwSessionId = pswtsi->dwSessionId;

            switch (dwEventType)
                {
                case WTS_SESSION_LOGON:
                    {
                    LogService("logon at session %d", dwSessionId);

                    SessionLogonCallback( dwSessionId );
                    break;
                    }

                case WTS_SESSION_LOGOFF:
                    {
                    LogService("logoff at session %d", dwSessionId);

                    SessionLogoffCallback( dwSessionId );
                    break;
                    }

                default:    //Is there a default?
                    break;
                }

            break;
            }

        default:
            LogError( "%!ts!: Unexpected service control message %d.\n", SERVICE_NAME, dwCode);
            return ERROR_CALL_NOT_IMPLEMENTED;
        }

    return NO_ERROR;
}

bool
IsServiceShuttingDown()
{
    return (gServiceStatus.dwCurrentState == SERVICE_STOP_PENDING);
}


VOID
UpdateState(
    DWORD dwNewState
    )
/*++

Routine Description:

    Updates this services state with the service controller.

Arguments:

    dwNewState - The next start for this service.  One of
            SERVICE_START_PENDING
            SERVICE_RUNNING

Return Value:

    None

--*/
{
    DWORD status = ERROR_SUCCESS;

    LogService("state change: old %d  new %d", gServiceStatus.dwCurrentState, dwNewState );

    switch (dwNewState)
        {

        case SERVICE_RUNNING:
        case SERVICE_STOPPED:
              gServiceStatus.dwCheckPoint = 0;
              gServiceStatus.dwWaitHint = 0;
              break;

        case SERVICE_START_PENDING:
        case SERVICE_STOP_PENDING:
              ++gServiceStatus.dwCheckPoint;
              gServiceStatus.dwWaitHint = 30000L;
              break;

        default:
              ASSERT(0);
              status = ERROR_INVALID_SERVICE_CONTROL;
              break;
        }

   if (status == ERROR_SUCCESS)
       {
       gServiceStatus.dwCurrentState = dwNewState;
       if (!SetServiceStatus(ghServiceHandle, &gServiceStatus))
           {
           status  = GetLastError();
           }
       }

   if (status != ERROR_SUCCESS)
       {
       LogError( "%!ts!: Failed to update service state: %d\n", SERVICE_NAME, status);
       }

   // We could return a status but how would we recover?  Ignore it, the
   // worst thing is that services will kill us and there's nothing
   // we can about it if this call fails.

   LogInfo( "Finished updating service state to %u", dwNewState );

   return;
}


extern "C"
VOID
BITSServiceMain(
    DWORD argc,
    LPTSTR *argv,
    PREGISTER_FUNC lpRegisterFunc
    )
/*++

Routine Description:

    Callback by the service controller when starting this service.

Arguments:

    argc - number of arguments, usually 1

    argv - argv[0] is the name of the service.
           argv[>0] are arguments passed to the service.

Return Value:

    None

--*/
{
    BOOL f = FALSE;
    HRESULT hr = S_OK;

    bool bGlobals = false;
    bool bQmgr = false;

    try
        {
        DWORD status = ERROR_SUCCESS;

        FILETIME ftStartTime;
        GetSystemTimeAsFileTime( &ftStartTime );

        Log_Init();
        Log_StartLogger();

        LogInfo("Service started at %!TIMESTAMP!", FILETIMEToUINT64( ftStartTime ) );

        //
        // Set up for service notifications.
        //
        gServiceStatus.dwServiceType             = SERVICE_WIN32_SHARE_PROCESS;
        gServiceStatus.dwCurrentState            = SERVICE_START_PENDING;
        gServiceStatus.dwControlsAccepted        = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SHUTDOWN;

        // The SESSIONCHANGE notification is only available on WindowsXP
        // and the service controller will become confused if this is given on windows 2000

        if ( WINDOWSXP_PLATFORM == g_PlatformVersion )
            gServiceStatus.dwControlsAccepted    |= SERVICE_ACCEPT_SESSIONCHANGE;

        gServiceStatus.dwWin32ExitCode           = 0;
        gServiceStatus.dwServiceSpecificExitCode = 0;
        gServiceStatus.dwCheckPoint              = 0;

        gServiceStatus.dwWaitHint                = 30000L;

        ghServiceHandle = (*lpRegisterFunc)( SERVICE_NAME,
                                             BITSServiceHandler,
                                             0
                                             );
        if (0 == ghServiceHandle)
            {
            status = GetLastError();
            ASSERT(status != ERROR_SUCCESS);

            LogError( "RegisterServiceCtrlHandlerEx failed %!winerr!", status);

            hr = HRESULT_FROM_WIN32( status );
            }

        UpdateState(SERVICE_START_PENDING);

        // Set up an event that will be signaled when the service is
        // stopped or shutdown.

        g_hServiceStopEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
        if( NULL == g_hServiceStopEvent )
            {
            status = GetLastError();
            LogError( "CreateEvent failed %!winerr!", status );

            THROW_HRESULT( HRESULT_FROM_WIN32( status ));
            }

#if defined( BITS_V12_ON_NT4 )
        if ( WINDOWS2000_PLATFORM == g_PlatformVersion ||
             NT4_PLATFORM == g_PlatformVersion )
#else
        if ( WINDOWS2000_PLATFORM == g_PlatformVersion )
#endif
            {

            HRESULT Hr;
            bool CoInitCalled = false;

            Hr = CoInitializeEx( NULL, COINIT_MULTITHREADED );

            if ( FAILED( Hr ) &&
                 ( Hr != RPC_E_CHANGED_MODE  ) )
                THROW_HRESULT( Hr );

            CoInitCalled = true;

            Hr =
                CoInitializeSecurity(
                    NULL,                       // pSecDesc
                    -1,                         // cAuthSvc
                    NULL,                       // asAuthSvc
                    NULL,                       // pReserved
                    RPC_C_AUTHN_LEVEL_PKT,      // dwAuthnLevel
                    RPC_C_IMP_LEVEL_IDENTIFY,   // dwImpLevel
                    NULL,                       // pReserved2

#if defined( BITS_V12_ON_NT4 )
                    0,
#else
                    EOAC_NO_CUSTOM_MARSHAL |    // dwCapabilities
                    EOAC_DISABLE_AAA |
                    EOAC_STATIC_CLOAKING,
#endif
                    NULL );                     // pReserved3

            if ( FAILED( Hr ) &&
                 ( Hr != RPC_E_TOO_LATE ) )
                {
                LogError( "Unable to initialize security on Win2k, error %!winerr!", Hr );

                if ( CoInitCalled )
                    CoUninitialize();

                THROW_HRESULT( Hr );
                }

            }

        LogInfo( "Initializing globalinfo\n" );
        THROW_HRESULT( GlobalInfo::Init() );

        bGlobals = true;

        LogInfo( "Initializing qmgr\n" );
        THROW_HRESULT( InitQmgr() );

        bQmgr = true;

        LogInfo( "Setting service to running.");

        //
        // Allow service controller to resume other duties.
        //
        UpdateState(SERVICE_RUNNING);

        //
        // wait for the stop signal.
        //

        if( WAIT_OBJECT_0 != WaitForSingleObject( g_hServiceStopEvent, INFINITE ))
            {
            status = GetLastError();
            LogError( "ServiceMain failed waiting for stop signal %!winerr!", status);

            hr = HRESULT_FROM_WIN32( status );
            }

        hr = S_OK;
        }
    catch ( ComError exception )
        {
        hr = exception.Error();
        }

    if (bQmgr)
        {
        HRESULT hr2 = UninitQmgr();
        if (FAILED(hr2))
            {
            LogError( "uninit Qmgr failed %!winerr!", hr2);
            }
        }

    if (bGlobals)
        {
        HRESULT hr2 = GlobalInfo::Uninit();
        if (FAILED(hr2))
            {
            LogError( "uninit GlobalInfo failed %!winerr!", hr2);
            }
        }

    if (g_hServiceStopEvent)
        {
        CloseHandle( g_hServiceStopEvent );
        g_hServiceStopEvent = NULL;
        }

    if (FAILED(hr))
        {
        gServiceStatus.dwWin32ExitCode = ERROR_SERVICE_SPECIFIC_ERROR;
        gServiceStatus.dwServiceSpecificExitCode = hr;
        }

    LogService( "ServiceMain returning, hr = %x", hr );
    Log_Close();

    UpdateState(SERVICE_STOPPED);


}

enum
{
    STARTUP_UNKNOWN,
    STARTUP_DEMAND,
    STARTUP_AUTO
}
g_ServiceStartupState = STARTUP_UNKNOWN;

HRESULT
SetServiceStartup( bool bAutoStart )
{

    LogService( "Setting startup to %s", bAutoStart ? ("Auto") : ("Demand") );
    HRESULT Hr = S_OK;

    //
    // Changing the service state is expensive, so avoid it if possible.
    //
    // No need to monitor external changes to the startup state, though:
    //
    //    If the admin changes our state from AUTO to DEMAND or DISABLED, then
    //    the consequent lack of progress is his fault, and admins should know that.
    //
    //    If the admin changes our state from DEMAND to AUTO, then we will
    //    start more often but the result is otherwise harmless.
    //
    if ((g_ServiceStartupState == STARTUP_DEMAND && bAutoStart == FALSE) ||
        (g_ServiceStartupState == STARTUP_AUTO && bAutoStart == TRUE))
        {
        LogService( "startup state is already correct" );
        return S_OK;
        }

    if (gServiceStatus.dwCurrentState != SERVICE_RUNNING)
        {
        LogService("can't change startup state in state %d", gServiceStatus.dwCurrentState);
        return S_OK;
        }

    SC_HANDLE hServiceManager = NULL;
    SC_HANDLE hService = NULL;
    try
    {
        try
        {
            hServiceManager =
                OpenSCManager( NULL,
                               NULL,
                               SC_MANAGER_ALL_ACCESS );

            if ( !hServiceManager ) throw (DWORD)GetLastError();

            hService =
                OpenService( hServiceManager,
                             SERVICE_NAME,
                             SERVICE_CHANGE_CONFIG );
            if ( !hService ) throw (DWORD)GetLastError();

            BOOL bResult =
                ChangeServiceConfig( hService,          // service handle
                                     SERVICE_NO_CHANGE, // dwServiceType
                                     bAutoStart ? SERVICE_AUTO_START : SERVICE_DEMAND_START, // dwStartType
                                     SERVICE_NO_CHANGE, // dwErrorControl
                                     NULL,              // lpBinaryPathName
                                     NULL,              // lpLoadOrderGroup
                                     NULL,              // lpdwTagId
                                     NULL,              // lpDependencies
                                     NULL,              // lpServiceStartName
                                     NULL,              // lpPassword
                                     NULL);             // lpDisplayName

            if ( !bResult ) throw (DWORD)GetLastError();

            if (bAutoStart)
                {
                g_ServiceStartupState = STARTUP_AUTO;
                }
            else
                {
                g_ServiceStartupState = STARTUP_DEMAND;
                }
        }
        catch( DWORD dwException )
        {
            throw (HRESULT)HRESULT_FROM_WIN32( dwException );
        }

    }
    catch (HRESULT HrException)
    {
        Hr = HrException;
        LogError( "An error occurred setting service startup, %!winerr!", Hr );
    }

    if ( hService )
        {
        CloseServiceHandle( hService );
        }

    if ( hServiceManager )
        {
        CloseServiceHandle( hServiceManager );
        }

    LogService( " HR: %!winerr!", Hr );
    return Hr;
}

int InitializeBitsAllocator();

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{

    if (dwReason == DLL_PROCESS_ATTACH)
        {
        g_hInstance = hInstance;
        DisableThreadLibraryCalls(hInstance);

        if (!InitCompilerLibrary())
            {
            return FALSE;
            }

        if ( !DetectProductVersion() )
            {
            UninitCompilerLibrary();
            return FALSE;
            }

        if (0 != InitializeBitsAllocator())
            {
            UninitCompilerLibrary();
            return FALSE;
            }
        }
    else if ( dwReason == DLL_PROCESS_DETACH )
        {
        UninitCompilerLibrary();
        }

    return TRUE;    // ok
}

#if CHECK_DLL_VERSION

//
// This ungainly typedef seems to have no global definition.  There are several identical
// definitions in the Windows NT sources, each of which has that bizarre bit-stripping
// on szKey.  I got mine from \nt\base\ntsetup\srvpack\update\splib\common.h.
//
typedef struct tagVERHEAD {
    WORD wTotLen;
    WORD wValLen;
    WORD wType;         /* always 0 */
    WCHAR szKey[(sizeof("VS_VERSION_INFO")+3)&~03];
    VS_FIXEDFILEINFO vsf;
} VERHEAD ;

/*
**  Purpose:
**      Gets the file version values from the given file and sets the
**      given ULONG64 variable.
**  Arguments:
**      szFullPath: a zero terminated character string containing the fully
**          qualified path (including disk drive) to the file.
**  Returns:
**      fTrue if file and file version resource found and retrieved,
**      fFalse if not.
+++
**  Implementation:
**************************************************************************/
BOOL
GetFileVersion64(
    LPTSTR      szFullPath,
    ULONG64 *   pVer
    )
{
    BOOL  fRet = false;
    DWORD dwHandle;
    DWORD InfoSize;

    try
        {
        //
        // Get the file version info size
        //

        if ((InfoSize = GetFileVersionInfoSize( szFullPath, &dwHandle)) == 0)
            {
            return (fRet);
            }

        //
        // Allocate enough size to hold version info
        //
        auto_ptr<TCHAR> lpData ( LPTSTR(new byte[ InfoSize ]));

        //
        // Get the version info
        //
        fRet = GetFileVersionInfo( szFullPath, dwHandle, InfoSize, lpData.get());

        if (fRet)
            {
            UINT dwLen;
            VS_FIXEDFILEINFO *pvsfi;

            fRet = VerQueryValue(
                       lpData.get(),
                       L"\\",
                       (LPVOID *)&pvsfi,
                       &dwLen
                       );

            //
            // Convert two DWORDs into a 64-bit integer.
            //
            if (fRet)
                {
                *pVer = ( ULONG64(pvsfi->dwFileVersionMS) << 32) | (pvsfi->dwFileVersionLS);
                }
            }

        return (fRet);
        }
    catch ( ComError err )
        {
        return false;
        }
}

BOOL
GetModuleVersion64(
    HMODULE hDll,
    ULONG64 * pVer
    )
{
    DWORD* pdwTranslation;
    VS_FIXEDFILEINFO* pFileInfo;
    UINT uiSize;

    HRSRC hrsrcVersion = FindResource(
                                hDll,
                                MAKEINTRESOURCE(VS_VERSION_INFO),
                                RT_VERSION);

    if (!hrsrcVersion) return false;

    HGLOBAL hglobalVersion = LoadResource(hDll, hrsrcVersion);
    if (!hglobalVersion) return false;

    VERHEAD * pVerHead = (VERHEAD *) LockResource(hglobalVersion);
    if (!pVerHead) return false;

    // I stole this code from \nt\com\complus\src\shared\util\svcerr.cpp,
    // and the comment is theirs:
    //
    // VerQueryValue will write to the memory, for some reason.
    // Therefore we must make a writable copy of the version
    // resource info before calling that API.
    auto_ptr<char> pvVersionInfo ( new char[pVerHead->wTotLen + pVerHead->wTotLen/2] );

    memcpy(pvVersionInfo.get(), pVerHead, pVerHead->wTotLen); // SEC: REVIEWED 2002-03-28

    // Retrieve file version info
    BOOL fRet = VerQueryValue( pvVersionInfo.get(),
                               L"\\",
                               (void**)&pFileInfo,
                               &uiSize);
    if (fRet)
        {
        *pVer = (ULONG64(pFileInfo->dwFileVersionMS) << 32) | (pFileInfo->dwFileVersionLS);
        }

    return fRet;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\utils\log.cpp ===
/************************************************************************

Copyright (c) 2000 - 2000 Microsoft Corporation

Module Name :

    log.cpp

Abstract :

    Log controller functions.

Author :

Revision History :

 ***********************************************************************/


#include "qmgrlibp.h"
#include <wmistr.h>
#include <initguid.h>
#include <guiddef.h>
#include <evntrace.h>

#if !defined(BITS_V12_ON_NT4)
#include "log.tmh"
#endif

TRACEHANDLE hTraceSessionHandle = NULL;
EVENT_TRACE_PROPERTIES *pTraceProperties = NULL;

LPCTSTR BITSLoggerName = _T("BITS");
LPCTSTR BITSLogFileName = _T("BITS.log");
LPCTSTR BITSLogFileNameBackup = _T("BITS.bak");
const ULONG MAX_STRLEN = 1024;
ULONG BITSMaxLogSize    = C_QMGR_LOGFILE_SIZE_DEFAULT; // Size in MB
ULONG BITSFlags         = C_QMGR_LOGFILE_FLAGS_DEFAULT;
ULONG BITSLogMinMemory  = C_QMGR_LOGFILE_MINMEMORY_DEFAULT; // Size in MB
const ULONG BITSDefaultLevel = 0;
const ULONG BITSLogFileMode = EVENT_TRACE_FILE_MODE_CIRCULAR |
                                 EVENT_TRACE_USE_LOCAL_SEQUENCE;

#if !defined(BITS_V12_ON_NT4)

// Compatibility wrappers since these arn't in WIN2k

ULONG
BITSStopTrace(
    TRACEHANDLE TraceHandle,
    LPCWSTR InstanceName,
    PEVENT_TRACE_PROPERTIES Properties
    )
{
    return
        ControlTraceW(
            TraceHandle,
            InstanceName,
            Properties,
            EVENT_TRACE_CONTROL_STOP
            );
}

ULONG
BITSQueryTrace(
    TRACEHANDLE TraceHandle,
    LPCWSTR InstanceName,
    PEVENT_TRACE_PROPERTIES Properties
    )
{
    return
        ControlTraceW(
            TraceHandle,
            InstanceName,
            Properties,
            EVENT_TRACE_CONTROL_QUERY
            );
}

#endif

bool Log_LoadSetting()
{
    // returns true is a logger should be
    // started if it isn't already started

    HKEY hBITSKey;

    LONG lResult = RegOpenKey( HKEY_LOCAL_MACHINE, C_QMGR_REG_KEY, &hBITSKey );

    if ( ERROR_SUCCESS == lResult )
        {

        BITSMaxLogSize    =
            GlobalInfo::RegGetDWORD( hBITSKey,
                                     C_QMGR_LOGFILE_SIZE,
                                     C_QMGR_LOGFILE_SIZE_DEFAULT );

        BITSFlags         =
            GlobalInfo::RegGetDWORD( hBITSKey,
                                     C_QMGR_LOGFILE_FLAGS,
                                     C_QMGR_LOGFILE_FLAGS_DEFAULT );

        BITSLogMinMemory  =
            GlobalInfo::RegGetDWORD( hBITSKey,
                                     C_QMGR_LOGFILE_MINMEMORY,
                                     C_QMGR_LOGFILE_MINMEMORY_DEFAULT );

        RegCloseKey( hBITSKey );

        }

    // Determine if the settings justify starting the logger

    if ( !BITSMaxLogSize || !BITSFlags)
        return false; // 0 size or no flags

    MEMORYSTATUS MemoryStatus;
    GlobalMemoryStatus( &MemoryStatus );

    SIZE_T MemorySize = MemoryStatus.dwTotalPhys / 0x100000;
    if ( MemorySize < BITSLogMinMemory )
        return false;

    return true; //enable the logger if it isn't already started
}

#if !defined(BITS_V12_ON_NT4)

void Log_StartLogger()
{
    try
        {
        if (!Log_LoadSetting())
            {
            return;
            }

        // Allocate trace properties
        ULONG SizeNeeded =
           sizeof(EVENT_TRACE_PROPERTIES) +
           (2 * MAX_STRLEN * sizeof(TCHAR));

        pTraceProperties = (PEVENT_TRACE_PROPERTIES) new char[SizeNeeded];

        memset( pTraceProperties, 0, SizeNeeded ); // SEC: REVIEWED 2002-03-28
        pTraceProperties->LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES);
        pTraceProperties->LogFileNameOffset =
            sizeof(EVENT_TRACE_PROPERTIES) + (MAX_STRLEN * sizeof(TCHAR));
        pTraceProperties->Wnode.BufferSize = SizeNeeded;
        pTraceProperties->Wnode.Flags = WNODE_FLAG_TRACED_GUID;

        // Setup trace session properties
        TCHAR *LoggerName = (LPTSTR)((char*)pTraceProperties + pTraceProperties->LoggerNameOffset);
        TCHAR *LogFileName = (LPTSTR)((char*)pTraceProperties + pTraceProperties->LogFileNameOffset);

        THROW_HRESULT( StringCchCopy( LoggerName, MAX_STRLEN, BITSLoggerName ));

        _tfullpath(LogFileName, BITSLogFileName, MAX_STRLEN);

        pTraceProperties->LogFileMode |= BITSLogFileMode;
        pTraceProperties->MaximumFileSize = BITSMaxLogSize;

        ULONG Status;

        // if an existing session is started, if so just use that
        // session unmodified
        Status =
            BITSQueryTrace(
                NULL,
                LoggerName,
                pTraceProperties);

        if ( ERROR_SUCCESS == Status)
            {
            LogInfo("Using existing BITS logger session");
            return;
            }

        MoveFileEx( BITSLogFileName, BITSLogFileNameBackup, MOVEFILE_REPLACE_EXISTING );

        Status =
            StartTrace(
                &hTraceSessionHandle,
                LoggerName,
                pTraceProperties);

        if ( ERROR_SUCCESS != Status )
            {
            hTraceSessionHandle = NULL;
            return;
            }

        Status = EnableTrace(
            TRUE,
            BITSFlags,
            BITSDefaultLevel,
            &BITSCtrlGuid,
            hTraceSessionHandle);

        LogInfo("Started new logger session");
        LogInfo("Max log size is %u MB", BITSMaxLogSize );
        LogInfo("Log Flags %x", BITSFlags );
        LogInfo("Min Memory settings %u MB", BITSLogMinMemory );
        }
    catch ( ComError err )
        {
        delete[] pTraceProperties;
        pTraceProperties = NULL;
        }
}

void Log_StopLogger()
{
    if ( !pTraceProperties )
        return;

    if ( hTraceSessionHandle )
        {
        BITSStopTrace(
            hTraceSessionHandle,
            NULL,
            pTraceProperties);
        hTraceSessionHandle = NULL;

        }

    delete[] pTraceProperties;
    pTraceProperties = NULL;
}

BOOL
Log_Init(void)
{

    WPP_INIT_TRACING(L"Microsoft\\BITS");
    return TRUE;
}

void
Log_Close()
{
    Log_StopLogger();
    WPP_CLEANUP();
}

#endif

#if defined(BITS_V12_ON_NT4)


#define MAX_LOG_STRING 4000
#define MAX_REPLACED_FORMAT 256

CRITICAL_SECTION g_LogCs;
static HANDLE g_LogFile = INVALID_HANDLE_VALUE;
static bool g_LogInitialized = false;

struct FormatReplaceElement
{
    DWORD SearchSize;
    const char *SearchString;
    DWORD ReplacementSize;
    const char *ReplacementString;
};

// sort table first by size, then by string
FormatReplaceElement g_FormatReplaceElements[] =
{
    { 5,    "%!ts!",        3, "%ls" },
    { 6,    "%!sid!",       2, "%p"  },
    { 7,    "%!guid!",      2, "%p"  },
    { 7,    "%!tstr!",      3, "%ls" },
    { 9,    "%!winerr!",    7, "0x%8.8X" },
    { 10,   "%!netrate!",   2, "%G"  },
    { 12,   "%!timestamp!", 9, "0x%16.16X" }
};

const DWORD NumberOfFormatReplaceElements =
    sizeof( g_FormatReplaceElements ) / sizeof( *g_FormatReplaceElements );

int __cdecl FormatReplaceElementComparison( const void *elem1, const void *elem2 )
{

    const FormatReplaceElement *felem1 = (const FormatReplaceElement*)elem1;
    const FormatReplaceElement *felem2 = (const FormatReplaceElement*)elem2;

    if ( felem1->SearchSize != felem2->SearchSize )
        return felem1->SearchSize - felem2->SearchSize;

    return _stricmp( felem1->SearchString, felem2->SearchString );

}

void
LogGenerateNewFormat(
    char *NewFormat,
    const char *Format,
    DWORD BufferSize )
{

    if ( !BufferSize )
        return;

    BufferSize--; // Dont count the terminating NULL

    while( 1 )
        {

        if ( !BufferSize || !*Format )
            {
            *NewFormat = '\0';
            return;
            }

        if ( '%' == Format[0] &&
             '!' == Format[1] )
            {

            const char *Begin   = Format;
            const char *End     = Format + 2;

            while( *End != '!' )
                {

                if ( '\0' == *End++ )
                    goto NormalChar;

                }

            FormatReplaceElement Key = { (DWORD)(End - Begin) + 1, Begin, (DWORD)(End - Begin) + 1, Begin };

            FormatReplaceElement *Replacement = (FormatReplaceElement*)
                bsearch( &Key,
                         &g_FormatReplaceElements,
                         NumberOfFormatReplaceElements,
                         sizeof( *g_FormatReplaceElements ),
                         &FormatReplaceElementComparison );

            if ( !Replacement )
                goto NormalChar;

            if ( Replacement->ReplacementSize > BufferSize )
                {
                *NewFormat = '\0';
                return;
                }

            memcpy( NewFormat, Replacement->ReplacementString,
                    sizeof( char ) * Replacement->ReplacementSize );
            NewFormat   += Replacement->ReplacementSize;
            BufferSize  -= Replacement->ReplacementSize;
            Format      = End + 1;

            }
        else
            {
NormalChar:
            *NewFormat++ = *Format++;
            BufferSize--;
            }

        }

}


void
Log(const CHAR *Prefix,
    const CHAR *Format,
    va_list ArgList )
{

    if ( !g_LogInitialized)
        return;

    EnterCriticalSection( &g_LogCs );

    if ( !g_LogInitialized)
        return;

    static char OutputString[ MAX_LOG_STRING ];

    DWORD ThreadId = GetCurrentThreadId();
    DWORD ProcessId = GetCurrentProcessId();

    SYSTEMTIME Time;

    GetSystemTime( &Time );

    int CharsWritten =
    _snprintf( OutputString,
               sizeof( OutputString ) - 3,
               "%.2u/%.2u/%.4u-%.2u:%.2u:%.2u.%.3u %X.%X ",
               Time.wMonth,
               Time.wDay,
               Time.wYear,
               Time.wHour,
               Time.wMinute,
               Time.wSecond,
               Time.wMilliseconds,
               ProcessId,
               ThreadId );

    if ( -1 != CharsWritten )
        {

        int CharsWritten2 =
            _snprintf( OutputString + CharsWritten,
                       sizeof( OutputString ) - CharsWritten - 3,
                       "%s",
                       Prefix );


        if ( -1 == CharsWritten2 )
            goto overflow;

        CharsWritten += CharsWritten2;

        char NewFormat[ MAX_REPLACED_FORMAT ];

        LogGenerateNewFormat(
            NewFormat,
            Format,
            MAX_REPLACED_FORMAT );

        int CharsWritten3 =
            _vsnprintf( OutputString + CharsWritten,
                        sizeof( OutputString ) - CharsWritten - 3,
                        NewFormat,
                        ArgList );

        if ( -1 == CharsWritten3 )
            goto overflow;

        CharsWritten += CharsWritten3;
        OutputString[ CharsWritten++ ] = '\r';
        OutputString[ CharsWritten++ ] = '\n';
        OutputString[ CharsWritten++ ] = '\0';

        }
    else
        {
overflow:
        OutputString[ sizeof( OutputString ) - 3 ] = '\r';
        OutputString[ sizeof( OutputString ) - 2 ] = '\n';
        OutputString[ sizeof( OutputString ) - 1 ] = '\0';
        CharsWritten = sizeof( OutputString );
        }

    if ( INVALID_HANDLE_VALUE != g_LogFile )
        {
        DWORD BytesWritten;

        WriteFile(
            g_LogFile,
            OutputString,
            CharsWritten,
            &BytesWritten,
            NULL );

        }

#if defined( DBG )
    OutputDebugStringA( OutputString );
#endif

    LeaveCriticalSection( &g_LogCs );

}

void
Log_StartLogger()
{

    if (!Log_LoadSetting())
        return;

    if ( BITSLogFileName && BITSFlags )
        {

        g_LogFile = CreateFile(
            BITSLogFileName,
            GENERIC_WRITE,
            FILE_SHARE_READ,
            NULL,
            CREATE_ALWAYS,   // overwrite any existing file
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );

        }

}


void
Log_StopLogger()
{
   if ( g_LogFile )
       {
       CloseHandle( g_LogFile );
       }
   g_LogInitialized = true;
}

BOOL
Log_Init(void)
{
    if ( !InitializeCriticalSectionAndSpinCount( &g_LogCs, 0x80000000 ) )
        return FALSE;

    g_LogInitialized = true;
    return TRUE;
}

void
Log_Close()
{
    EnterCriticalSection( &g_LogCs );
    Log_StopLogger();
    g_LogInitialized = false;
    DeleteCriticalSection( &g_LogCs );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\utils\qmgrlibp.h ===
/************************************************************************

Copyright (c) 2000 - 2000 Microsoft Corporation

Module Name :

    qmgrlibp.h

Abstract :

    Private header file for the utils.

Author :

Revision History :

 ***********************************************************************/

#ifndef __QMGRLIBP_H__
#define __QMGRLIBP_H__

#include<nt.h>
#include<ntrtl.h>
#include<nturtl.h>
#include <windows.h>
#include <tchar.h>
#include <wchar.h>
#include <limits.h>
#include <ole2.h>
#include <initguid.h>
#include <setupapi.h>
#include <inseng.h>
#include <aclapi.h>
#include <shlobj.h>
#include <shfolder.h>
#include <limits.h>
#include <winsock2.h>
#include <iphlpapi.h>
#include "qmgrlib.h"

#endif // __QMGRLIBP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\utils\locks.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1995 - 1999

Module Name:

    Locks.cxx

Abstract:

    Out of line methods for some of the syncronization classes
    defined in locks.hxx.

Author:

    Mario Goertzel    [MarioGo]

Revision History:

    MarioGo     03-14-95    Moved from misc.cxx.
    MarioGo     01-27-96    Changed from busy (Sleep(0)) wait to event

--*/

#include "qmgrlibp.h"
#include <locks.hxx>

BOOL BITSInitializeCriticalSectionInternal( LPCRITICAL_SECTION lpCriticalSection )
{
   __try
       {
       InitializeCriticalSection( lpCriticalSection ); // SEC: REVIEWED 2002-03-28
       }
   __except( ( GetExceptionCode() == STATUS_NO_MEMORY ) ?
             EXCEPTION_EXECUTE_HANDLER  : EXCEPTION_CONTINUE_SEARCH )
       {
       return FALSE;
       }
   return TRUE;
}

void BITSIntializeCriticalSection( LPCRITICAL_SECTION lpCriticalSection )
{
   if (!BITSInitializeCriticalSectionInternal( lpCriticalSection ) )
       throw ComError( E_OUTOFMEMORY );
}

//
// CShareLock methods
//

CSharedLock::CSharedLock()
{
    exclusive_owner = 0;
    writers = 0;
    hevent = INVALID_HANDLE_VALUE;  // Flag in the d'tor

    BITSIntializeCriticalSection( &lock );

    hevent = CreateEvent(0, FALSE, FALSE, 0); // SEC: REVIEWED 2002-03-28
    if (0 == hevent)
        {
        DeleteCriticalSection(&lock);
        throw ComError( E_OUTOFMEMORY );
        }
}

CSharedLock::~CSharedLock()
{
    if (hevent != INVALID_HANDLE_VALUE)
        {
        DeleteCriticalSection(&lock);

        if (hevent) CloseHandle(hevent);
        }
}

void
CSharedLock::LockShared()
{
    readers++;

    if (writers)
        {
        if ((readers--) == 0)
            {
            SetEvent(hevent);
            }

        EnterCriticalSection(&lock);
        readers++;
        LeaveCriticalSection(&lock);
        }

    exclusive_owner = 0;
}

void
CSharedLock::UnlockShared(void)
{
    ASSERT((LONG)readers > 0);
    ASSERT(exclusive_owner == 0);

    if ( (readers--) == 0 && writers)
        {
        SetEvent(hevent);
        }
}

void
CSharedLock::LockExclusive(void)
{
    EnterCriticalSection(&lock);

    writers++;
    while(readers)
        {
        WaitForSingleObject(hevent, INFINITE);
        }
    ASSERT(writers);
    exclusive_owner = GetCurrentThreadId();
}

void
CSharedLock::UnlockExclusive(void)
{
    ASSERT(HeldExclusive());
    ASSERT(writers);
    writers--;
    exclusive_owner = 0;
    LeaveCriticalSection(&lock);
}

void
CSharedLock::Unlock()
{
    // Either the lock is held exclusively by this thread or the thread
    // has a shared lock. (or the caller has a bug).

    if (HeldExclusive())
        {
        UnlockExclusive();
        }
    else
        {
        UnlockShared();
        }
}

void
CSharedLock::ConvertToExclusive(void)
{
    ASSERT((LONG)readers > 0);
    ASSERT(exclusive_owner == 0);

    if ( (readers--) == 0 && writers )
        SetEvent(hevent);

    EnterCriticalSection(&lock);
    writers++;
    while(readers)
        {
        WaitForSingleObject(hevent, INFINITE);
        }
    ASSERT(writers);
    exclusive_owner = GetCurrentThreadId();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\utils\helpers.cpp ===
/************************************************************************

Copyright (c) 2000 - 2000 Microsoft Corporation

Module Name :

    helpers.cpp

Abstract :

    General helper functions.

Author :

Revision History :

 ***********************************************************************/

#include "qmgrlibp.h"
#include <bitsmsg.h>
#include <sddl.h>
#include <shlwapi.h>

#if !defined(BITS_V12_ON_NT4)
#include "helpers.tmh"
#endif

FILETIME GetTimeAfterDelta( UINT64 uDelta )
{
    FILETIME ftCurrentTime;
    GetSystemTimeAsFileTime( &ftCurrentTime );
    UINT64 uCurrentTime = FILETIMEToUINT64( ftCurrentTime );
    uCurrentTime += uDelta;

    return UINT64ToFILETIME( uCurrentTime );
}


//---------------------------------------------------------------------
//  QmgrFileExists
//      Checks if a file exists.
//
//  Returns:  TRUE if false exists, FALSE otherwise
//---------------------------------------------------------------------
BOOL QMgrFileExists(LPCTSTR szFile)
{
    DWORD dwAttr = GetFileAttributes(szFile);

    if (dwAttr == 0xFFFFFFFF)   //failed
        return FALSE;

    return (BOOL)(!(dwAttr & FILE_ATTRIBUTE_DIRECTORY));
}

//
// Class for managing global static data that is different per installation
//

class GlobalInfo *g_GlobalInfo = NULL;

GlobalInfo::GlobalInfo( TCHAR * QmgrDirectory,
                        LARGE_INTEGER PerformanceCounterFrequency,
                        HKEY QmgrRegistryRoot,
                        UINT64 JobInactivityTimeout,
                        UINT64 TimeQuantaLength,
                        UINT32 DefaultNoProgressTimeout,
                        UINT32 DefaultMinimumRetryDelay,
                        SECURITY_DESCRIPTOR *MetadataSecurityDescriptor,
                        DWORD MetadataSecurityDescriptorLength,
                        SidHandle AdministratorsSid,
                        SidHandle LocalSystemSid,
                        SidHandle NetworkUsersSid
                        ) :
    m_QmgrDirectory( QmgrDirectory ),
    m_PerformanceCounterFrequency( PerformanceCounterFrequency ),
    m_QmgrRegistryRoot( QmgrRegistryRoot ),
    m_JobInactivityTimeout( JobInactivityTimeout ),
    m_TimeQuantaLength( TimeQuantaLength ),
    m_DefaultNoProgressTimeout( DefaultNoProgressTimeout ),
    m_DefaultMinimumRetryDelay( DefaultMinimumRetryDelay ),
    m_MetadataSecurityDescriptor( MetadataSecurityDescriptor ),
    m_MetadataSecurityDescriptorLength( MetadataSecurityDescriptorLength ),
    m_AdministratorsSid( AdministratorsSid ),
    m_LocalSystemSid( LocalSystemSid ),
    m_NetworkUsersSid( NetworkUsersSid )
{
}

GlobalInfo::~GlobalInfo()
{
    delete[] (TCHAR*)m_QmgrDirectory;
    delete (SECURITY_DESCRIPTOR*)m_MetadataSecurityDescriptor;

    if ( m_QmgrRegistryRoot )
       CloseHandle( m_QmgrRegistryRoot );
}

DWORD
GlobalInfo::RegGetDWORD(
    HKEY hKey,
    const TCHAR * pValue,
    DWORD dwDefault )
{
    DWORD dwValue;
    DWORD dwType = REG_DWORD;
    DWORD dwSize = sizeof(dwValue);

    LONG lResult =
        RegQueryValueEx(  //SEC: REVIEWED 2002-03-28
            hKey,
            pValue,
            NULL,
            &dwType,
            (LPBYTE)&dwValue,
            &dwSize );

    if ( ERROR_SUCCESS != lResult ||
         dwType != REG_DWORD ||
         dwSize != sizeof(dwValue)
         )
        {
        LogWarning( "Unable to read the registry value %!ts!, using default value of %u",
                    pValue, dwDefault );
        return dwDefault;
        }

    LogInfo( "Retrieved registry value %u from key value %!ts!",
             dwValue, pValue );
    return dwValue;
}

SidHandle
BITSAllocateAndInitializeSid(
    BYTE nSubAuthorityCount,                        // count of subauthorities
    DWORD dwSubAuthority0,                          // subauthority 0
    DWORD dwSubAuthority1 )                         // subauthority 1
{

    ASSERT( nSubAuthorityCount <= 2 );

    SID_IDENTIFIER_AUTHORITY Authority = SECURITY_NT_AUTHORITY;
    PSID pSid = NULL;

    if(! AllocateAndInitializeSid( //SEC: REVIEWED 2002-03-28
             &Authority,
             nSubAuthorityCount,
             dwSubAuthority0,
             dwSubAuthority1,
             0, 0, 0, 0, 0, 0,
             &pSid) )
        {
        HRESULT hResult = HRESULT_FROM_WIN32(GetLastError());
        LogError( "AllocateAndInitializeSid failed, error %!winerr!\n" , hResult );
        throw ComError( hResult );
        }

    SidHandle NewSid( DuplicateSid( pSid ) );
    FreeSid( pSid );
    pSid = NULL;

    if ( !NewSid.get())
        {
        LogError( "Unable to duplicate sid, error %!winerr!\n" , E_OUTOFMEMORY );
        throw ComError( E_OUTOFMEMORY );
        }

    return NewSid;
}

StringHandle
BITSSHGetFolderPath(
    HWND hwndOwner,
    int nFolder,
    HANDLE hToken,
    DWORD dwFlags )
{

    auto_ptr<WCHAR> Folder( new WCHAR[ MAX_PATH ] );

    HRESULT hResult =
        SHGetFolderPath(
                    hwndOwner,
                    nFolder,
                    hToken,
                    dwFlags,
                    Folder.get() );

    if (FAILED(hResult))
        {
        LogError( "SHGetFolderPathFailed, error %!winerr!", hResult );
        throw ComError( hResult );
        }

    return StringHandle( Folder.get() );
}


HRESULT GlobalInfo::Init()
/*
    Initialize the global info for BITS.
*/

{
    GlobalInfo *pGlobalInfo = NULL;
    HKEY hQmgrKey = NULL;
    HKEY hQmgrPolicyKey = NULL;
    PACL pDacl = NULL;

    LogInfo( "Starting init of global info\n" );

    try
        {
        DWORD dwResult;
        HRESULT hResult = E_FAIL;
        DWORD dwReturnLength;

        LARGE_INTEGER PerformanceCounterFrequency;
        BOOL bResult = QueryPerformanceFrequency( &PerformanceCounterFrequency );
        if ( !bResult )
            throw ComError( E_FAIL );

        SidHandle AdministratorsSid =
            BITSAllocateAndInitializeSid(
                 2,
                 SECURITY_BUILTIN_DOMAIN_RID,
                 DOMAIN_ALIAS_RID_ADMINS );

        SidHandle LocalSystemSid =
            BITSAllocateAndInitializeSid(
                1,
                SECURITY_LOCAL_SYSTEM_RID, 0 );


        SidHandle NetworkUsersSid =
            BITSAllocateAndInitializeSid(
                1,
                SECURITY_NETWORK_RID, 0);

        // initialize the metadata's security descriptor.

        auto_ptr<char> TempSDDataPtr( new char[SECURITY_DESCRIPTOR_MIN_LENGTH] );
        PSECURITY_DESCRIPTOR pTempSD = (PSECURITY_DESCRIPTOR)TempSDDataPtr.get();
        InitializeSecurityDescriptor(pTempSD, SECURITY_DESCRIPTOR_REVISION);   //SEC: REVIEWED 2002-03-28

        auto_ptr<EXPLICIT_ACCESS> ExplicitAccessPtr( new EXPLICIT_ACCESS[2] );
        EXPLICIT_ACCESS *ExplicitAccess = ExplicitAccessPtr.get();
        memset( ExplicitAccess, 0, sizeof(EXPLICIT_ACCESS) * 2);  //SEC: REVIEWED 2002-03-28

        ExplicitAccess[0].grfAccessPermissions  = GENERIC_ALL;
        ExplicitAccess[0].grfAccessMode         = SET_ACCESS;
        ExplicitAccess[0].grfInheritance        = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
        ExplicitAccess[0].Trustee.TrusteeForm   = TRUSTEE_IS_SID;
        ExplicitAccess[0].Trustee.TrusteeType   = TRUSTEE_IS_GROUP;
        ExplicitAccess[0].Trustee.ptstrName     = (LPTSTR) AdministratorsSid.get();

        ExplicitAccess[1].grfAccessPermissions  = GENERIC_ALL;
        ExplicitAccess[1].grfAccessMode         = SET_ACCESS;
        ExplicitAccess[1].grfInheritance        = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
        ExplicitAccess[1].Trustee.TrusteeForm   = TRUSTEE_IS_SID;
        ExplicitAccess[1].Trustee.TrusteeType   = TRUSTEE_IS_USER;
        ExplicitAccess[1].Trustee.ptstrName     = (LPTSTR) LocalSystemSid.get();

        dwResult = SetEntriesInAcl( //SEC: REVIEWED 2002-03-28
            2,
            ExplicitAccess,
            NULL,
            &pDacl );

        if ( ERROR_SUCCESS != dwResult )
            {
            hResult = HRESULT_FROM_WIN32( dwResult );
            LogError( "SetEntiesInAcl, error %!winerr!\n", hResult );
            throw ComError( hResult );
            }

        if (!SetSecurityDescriptorDacl( //SEC: REVIEWED 2002-03-28
            pTempSD,
            TRUE,     // fDaclPresent flag
            pDacl,
            FALSE))   // not a default DACL
        {
            hResult = HRESULT_FROM_WIN32( GetLastError() );
            LogError( "SetSecurityDescriptorDacl, error %!winerr!", hResult );
            throw ComError( hResult );
        }

        DWORD dwRequiredSecurityDescriptorLength = 0;
        MakeSelfRelativeSD( pTempSD, NULL, &dwRequiredSecurityDescriptorLength );

        auto_ptr<SECURITY_DESCRIPTOR> pMetadataSecurityDescriptor(
            (SECURITY_DESCRIPTOR*)new char[dwRequiredSecurityDescriptorLength] );

        if (!pMetadataSecurityDescriptor.get())
            {
            throw ComError( E_OUTOFMEMORY );
            }

        if (!MakeSelfRelativeSD( pTempSD, pMetadataSecurityDescriptor.get(), &dwRequiredSecurityDescriptorLength ) )
        {
           hResult = HRESULT_FROM_WIN32(GetLastError());
           LogError( "MakeSelfRelativeSD, error %!winerr!", hResult );
           throw ComError( hResult );
        }

        LocalFree( pDacl );
        pDacl = NULL;

        SECURITY_ATTRIBUTES MetadataSecurityAttributes;
        MetadataSecurityAttributes.nLength = sizeof(MetadataSecurityAttributes);
        MetadataSecurityAttributes.lpSecurityDescriptor = pMetadataSecurityDescriptor.get();
        MetadataSecurityAttributes.bInheritHandle = FALSE;

        // Build path where the metadata will be stored.

#if defined( BITS_V12_ON_NT4 )

        size_t Length = MAX_PATH * 2 + 1;
        auto_ptr<TCHAR> QmgrDirectory( new TCHAR[ Length ] );

        dwResult = (DWORD)GetWindowsDirectory( //SEC: REVIEWED 2002-03-28
            QmgrDirectory.get(),  // buffer for Windows directory
            MAX_PATH+1            // size of directory buffer
            );

        if ( !dwResult || dwResult > MAX_PATH+1 )
            {
            HRESULT Error = GetLastError();
            LogError( "Unable to lookup windows directory, error %!winerr!", Error );
            throw ComError( Error );
            }

        THROW_HRESULT( StringCchCat( QmgrDirectory.get(), Length,  _T("\\System32\\BITS") ));

#else

        StringHandle AllUsersDirectory =
            BITSSHGetFolderPath(
                NULL,
                CSIDL_COMMON_APPDATA,
                NULL,
                SHGFP_TYPE_CURRENT );

        size_t Length = lstrlen( AllUsersDirectory ) + lstrlen(C_QMGR_DIRECTORY) + 1; //SEC: REVIEWED 2002-03-28

        auto_ptr<TCHAR> QmgrDirectory( new TCHAR[ Length ] );

        THROW_HRESULT( StringCchCopy( QmgrDirectory.get(), Length, AllUsersDirectory ));
        THROW_HRESULT( StringCchCat( QmgrDirectory.get(), Length, C_QMGR_DIRECTORY ));

        // Create the BITS directory if needed.
        dwResult = GetFileAttributes( QmgrDirectory.get() );
        if ( (-1 == dwResult) || !(dwResult & FILE_ATTRIBUTE_DIRECTORY))
            {
            LogError( "BITS directory doesn't exist, attempt to create %!ts!.\n", QmgrDirectory.get() );

            bResult = CreateDirectory(QmgrDirectory.get(), &MetadataSecurityAttributes); //SEC: REVIEWED 2002-03-28
            if ( !bResult )
                {
                hResult = HRESULT_FROM_WIN32( GetLastError() );
                LogError( "Unable to create BITS directory, error %!winerr!\n", hResult );
                throw ComError( hResult );
                }
            }

#endif

        // Open the main policy registry key
        dwResult =
            (DWORD)RegOpenKey(
                HKEY_LOCAL_MACHINE,
                C_QMGR_POLICY_REG_KEY,
                &hQmgrPolicyKey);

        if ( ERROR_SUCCESS != dwResult )
            {
            LogWarning("Unable to open the main policy registry key\n");
            }

        // Open the main qmgr registry key
        dwResult =
            (DWORD)RegCreateKeyEx(
                HKEY_LOCAL_MACHINE,         // root key
                C_QMGR_REG_KEY,             // subkey
                0,                          // reserved
                NULL,                       // class name
                REG_OPTION_NON_VOLATILE,    // option
                KEY_ALL_ACCESS,             // security  // SEC: REVIEWED 2002-03-28
                &MetadataSecurityAttributes,// security attribute
                &hQmgrKey,
                NULL);

        if ( ERROR_SUCCESS != dwResult )
            {
            hResult = HRESULT_FROM_WIN32( dwResult );
            LogError( "Unable to open main BITS key, error %!winerr!\n", hResult );
            throw ComError( hResult );
            }

        UINT64 JobInactivityTimeout;
        // Get the inactivity timeout value for job;
        {
           DWORD dwValue;
           DWORD dwType = REG_DWORD;
           DWORD dwSize = sizeof(dwValue);

           LONG lResult;

           if ( hQmgrPolicyKey )
               {
               lResult =
               RegQueryValueEx(    //SEC: REVIEWED 2002-03-28
                   hQmgrPolicyKey,
                   C_QMGR_JOB_INACTIVITY_TIMEOUT,
                   NULL,
                   &dwType,
                   (LPBYTE)&dwValue,
                   &dwSize );
               }

           if ( !hQmgrPolicyKey ||
                ERROR_SUCCESS != lResult ||
                dwType != REG_DWORD ||
                dwSize != sizeof(dwValue)
                )
               {
               JobInactivityTimeout =
                   RegGetDWORD( hQmgrKey, C_QMGR_JOB_INACTIVITY_TIMEOUT, C_QMGR_JOB_INACTIVITY_TIMEOUT_DEFAULT);
               JobInactivityTimeout *= NanoSec100PerSec;

               }
           else
               {
               LogInfo("Retrieved job inactivity timeout of %u days from policy", dwValue );
               JobInactivityTimeout = dwValue * NanoSec100PerSec * 60/*secs per min*/ * 60/*mins per hour*/ * 24 /* hours per day*/;
               }
        }

        UINT64 TimeQuantaLength =
            RegGetDWORD( hQmgrKey, C_QMGR_TIME_QUANTA_LENGTH, C_QMGR_TIME_QUANTA_LENGTH_DEFAULT );
        TimeQuantaLength *= NanoSec100PerSec;

        UINT32 DefaultNoProgressTimeout = // global data is in seconds.
            RegGetDWORD( hQmgrKey, C_QMGR_NO_PROGRESS_TIMEOUT, C_QMGR_NO_PROGRESS_TIMEOUT_DEFAULT );

        UINT32 DefaultMinimumRetryDelay = // global data is in seconds
            RegGetDWORD( hQmgrKey, C_QMGR_MINIMUM_RETRY_DELAY, C_QMGR_MINIMUM_RETRY_DELAY_DEFAULT );

        pGlobalInfo =
            new GlobalInfo( QmgrDirectory.get(),
                            PerformanceCounterFrequency,
                            hQmgrKey,
                            JobInactivityTimeout,
                            TimeQuantaLength,
                            DefaultNoProgressTimeout,
                            DefaultMinimumRetryDelay,
                            pMetadataSecurityDescriptor.get(),
                            dwRequiredSecurityDescriptorLength,
                            AdministratorsSid,
                            LocalSystemSid,
                            NetworkUsersSid
                            );

        if ( !pGlobalInfo )
            throw ComError( E_OUTOFMEMORY );

        QmgrDirectory.release();
        pMetadataSecurityDescriptor.release();
        if ( hQmgrPolicyKey )
            CloseHandle( hQmgrPolicyKey );
        }

    catch( ComError Error )
        {
        LogError( "An exception occured creating global info, error %!winerr!", Error.Error() );

        if ( hQmgrKey )
            CloseHandle( hQmgrKey );
        hQmgrKey = NULL;

        if ( hQmgrPolicyKey )
            CloseHandle( hQmgrPolicyKey );
        hQmgrPolicyKey = NULL;

        // LocalFree has if guard
        LocalFree( pDacl );

        return Error.Error();
        }

    LogInfo( "Finished init of global info" );
    g_GlobalInfo = pGlobalInfo;
    return S_OK;
}

HRESULT GlobalInfo::Uninit()
{
    delete g_GlobalInfo;
    g_GlobalInfo = NULL;
    return S_OK;
}

LONG
ExternalFuncExceptionFilter(
    struct _EXCEPTION_POINTERS *ExceptionInfo
    )
{
    // This function is called by the exception filter that wraps external functions.
    // The purpose is to treat unhandled exceptions as unhandled instead of propagating
    // across the network

    // If this exception is a MSVCRT exception, bash the exception code
    // so that MSVCRT won't call ExitProcess.

    if ( ExceptionInfo &&
         ExceptionInfo->ExceptionRecord &&
         ('msc' | 0xE0000000) == ExceptionInfo->ExceptionRecord->ExceptionCode )
    {
        ExceptionInfo->ExceptionRecord->ExceptionCode = ('BIT' | 0xE0000000);
    }

    LONG Result = UnhandledExceptionFilter( ExceptionInfo );

    if ( EXCEPTION_CONTINUE_SEARCH == Result )
        {
        // Need to act like the dispatcher.  Call kernel again specifying second change semantics
        NtRaiseException( ExceptionInfo->ExceptionRecord, ExceptionInfo->ContextRecord, FALSE );
        }
    // exception handler returns RPC_E_SERVERFAULT
    return EXCEPTION_EXECUTE_HANDLER;
}

SidHandle & SidHandle::operator=( const SidHandle & r )
{
    if (m_pValue == r.m_pValue )
        {
        return *this;
        }

    if (InterlockedDecrement(m_pRefs) == 0)
        {
        delete m_pRefs;
        delete m_pValue;
        }

    m_pValue = r.m_pValue;
    m_pRefs  = r.m_pRefs;

    InterlockedIncrement(m_pRefs);

    return *this;
}

StringHandle::StringData StringHandle::s_EmptyString =
    {
        0, 1, { L'\0' }     // Initialize with 1 ref so it is never deleted
    };

bool
CSidSorter::operator()(
    const SidHandle & handle1,
    const SidHandle & handle2
    ) const
{
    const PSID psid1 = handle1.get();
    const PSID psid2 = handle2.get();

    if ( !psid1 || !psid2 )
        return (INT_PTR)psid1 < (INT_PTR)psid2;

    if (*GetSidSubAuthorityCount( psid1 ) < *GetSidSubAuthorityCount( psid2 ))
        {
        return true;
        }

    // at this point, we known psd1 is >= psd2.   // Stop if psid1 is
    // longer so that the preceding for loop doesn't overstep the sid
    // array on psd2.
    if ( *GetSidSubAuthorityCount( psid1 ) > *GetSidSubAuthorityCount( psid2 ) )
        return false;

    // arrays have equal length

    for (UCHAR i=0; i < *GetSidSubAuthorityCount( psid1 ); ++i)
        {
        if (*GetSidSubAuthority( psid1, i ) < *GetSidSubAuthority( psid2, i ))
            return true; // sid1 is less then sid2
        else if ( *GetSidSubAuthority( psid1, i ) > *GetSidSubAuthority( psid2, i ) )
            return false; // sid1 is greater then sid2

        // subauthorities are the same, move on to the next subauthority
        }

    // arrays are identical
    return false;
}

//------------------------------------------------------------------------

PSID DuplicateSid( PSID _Sid )
/*++

Routine Description:

    Clones a SID.  The new SID is allocated using the global operator new.

At entry:

    _Sid is the SID to clone.

At exit:

    the return is NULL if an error occurs, otherwise a pointer to the new SID.

--*/
{
    DWORD Length = GetLengthSid( _Sid );
    SID * psid;

    try
    {
        psid = (SID *) new char[Length];
    }
    catch( ComError Error )
    {
        return NULL;
    }

    if (!CopySid( Length, psid, _Sid )) // SEC: REVIEWED 2002-03-28
        {

        delete[] psid;
        return NULL;
        }

    return psid;
}

LPCWSTR
TruncateString( LPCWSTR String, SIZE_T MaxLength, auto_ptr<WCHAR> & AutoPointer )
{
    if ( wcslen( String ) <= MaxLength ) // SEC: REVIEWED 2002-03-28
        return String;

    AutoPointer = auto_ptr<WCHAR>( new WCHAR[ MaxLength + 1 ] );
    wcsncpy( AutoPointer.get(), String, MaxLength ); // SEC: REVIEWED 2002-03-28
    AutoPointer.get()[ MaxLength ] = L'\0';
    return AutoPointer.get();

}

PLATFORM_PRODUCT_VERSION g_PlatformVersion;
bool bIsWin9x;

BOOL DetectProductVersion()
{

   OSVERSIONINFO VersionInfo;
   VersionInfo.dwOSVersionInfoSize = sizeof( VersionInfo );

   if ( !GetVersionEx( &VersionInfo ) )
       return FALSE;

   switch( VersionInfo.dwPlatformId )
       {

       case VER_PLATFORM_WIN32_WINDOWS:
           g_PlatformVersion = ( VersionInfo.dwMajorVersion > 0 ) ?
               WIN98_PLATFORM : WIN95_PLATFORM;
           bIsWin9x = true;
           return TRUE;

       case VER_PLATFORM_WIN32_NT:
           bIsWin9x = false;

#if defined( BITS_V12_ON_NT4 )

           if ( VersionInfo.dwMajorVersion < 4 )
              return FALSE;

           if ( 4 == VersionInfo.dwMajorVersion )
               {
               g_PlatformVersion = NT4_PLATFORM;
               return TRUE;
               }

#else

           if ( VersionInfo.dwMajorVersion < 5 )
              return FALSE;

#endif

           if ( VersionInfo.dwMajorVersion > 5 )
               {
               g_PlatformVersion = WINDOWSXP_PLATFORM;
               return TRUE;
               }

           g_PlatformVersion = ( VersionInfo.dwMinorVersion > 0 ) ?
               WINDOWSXP_PLATFORM : WINDOWS2000_PLATFORM;

           return TRUE;

       default:
           return FALSE;

       }
}


StringHandle
CombineUrl(
    LPCWSTR BaseUrl,
    LPCWSTR RelativeUrl,
    DWORD Flags
    )
{
    DWORD Length = 0;
    HRESULT hr;

    hr = UrlCombine( BaseUrl,
                     RelativeUrl,
                     0,
                     &Length,
                     Flags
                     );

    if (hr != E_POINTER)
        {
        ASSERT( FAILED(hr) );

        throw ComError( hr );
        }

    auto_ptr<WCHAR> AbsoluteUrl ( new WCHAR[ Length ] );

    THROW_HRESULT( UrlCombine( BaseUrl,
                               RelativeUrl,
                               AbsoluteUrl.get(),
                               &Length,
                               Flags
                               ));

    //
    // The string handle constructor clones the auto_ptr.
    //
    return AbsoluteUrl.get();
}

bool IsAnyDebuggerPresent()
{
    if (IsDebuggerPresent())
        {
        return true;
        }

    SYSTEM_KERNEL_DEBUGGER_INFORMATION KdInfo = { 0 };

    NtQuerySystemInformation(
            SystemKernelDebuggerInformation,
            &KdInfo,
            sizeof(KdInfo),
            NULL);

    if (KdInfo.KernelDebuggerEnabled)
        {
        return true;
        }

    return false;
}

LPWSTR MidlCopyString( LPCWSTR source, size_t Length )
{
    if (Length == -1)
        {
        Length = 1+wcslen( source ); // SEC: REVIEWED 2002-03-28
        }

    LPWSTR copy = reinterpret_cast<LPWSTR>( CoTaskMemAlloc( Length * sizeof( wchar_t )));
    if (!copy)
        {
        return NULL;
        }

    if (FAILED(StringCchCopy( copy, Length, source )))
        {
        CoTaskMemFree( copy );
        return NULL;
        }

    return copy;
}

LPWSTR CopyString( LPCWSTR source, size_t Length )
{
    if (Length == -1)
        {
        Length = 1+wcslen( source ); // SEC: REVIEWED 2002-03-28
        }

    CAutoString copy( new wchar_t[ Length ]);

    THROW_HRESULT( StringCchCopy( copy.get(), Length, source ));

    return copy.release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\at\atacct.h ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    atacct.h

Abstract:

    Prototypes for the private net scheduler API.

Revision History:

--*/

#ifndef _ATACCT_H_
#define _ATACCT_H_

#ifdef __cplusplus
extern "C" {
#endif

STDAPI
GetNetScheduleAccountInformation(
    IN    LPCWSTR pwszServerName,
    OUT   DWORD ccAccount,
    OUT   WCHAR wszAccount[]
    );

STDAPI
SetNetScheduleAccountInformation(
    IN    LPCWSTR pwszServerName,
    IN    LPCWSTR pwszAccount,
    IN    LPCWSTR pwszPassword
    );

#ifdef __cplusplus
}
#endif

#endif // _ATACCT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\at\atacct.cxx ===
//+----------------------------------------------------------------------------
//
//  Scheduling Agent Service
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       atacct.cxx
//
//  Classes:    None.
//
//  Functions:  SetNetScheduleAccountInformation
//              GetNetScheduleAccountInformation
//
//  History:    13-Aug-96   MarkBl  Created.
//
//-----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop

#include "..\inc\debug.hxx"
#include "atacct.h"
#include "SASecRPC.h"       // SASetNSAccountInformation RPC definition.
#include <misc.hxx>         // SchedMapRpcError

//+----------------------------------------------------------------------------
//
//  Function:   SetNetScheduleAccountInformation
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
STDAPI
SetNetScheduleAccountInformation(
    LPCWSTR pwszServerName,
    LPCWSTR pwszAccount,
    LPCWSTR pwszPassword)
{
    HRESULT hr;

    RpcTryExcept
    {
        hr = SASetNSAccountInformation(pwszServerName,
                                       pwszAccount,
                                       pwszPassword);
    }
    RpcExcept(1)
    {
        DWORD Status = RpcExceptionCode();
        schDebugOut((DEB_ERROR,
            "SASetNSAccountInformation exception(0x%x)\n",
            Status));
        hr = SchedMapRpcError(Status);
    }
    RpcEndExcept;

    return(hr);
}

//+----------------------------------------------------------------------------
//
//  Function:   GetNetScheduleAccountInformation
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
STDAPI
GetNetScheduleAccountInformation(
    LPCWSTR pwszServerName,
    DWORD   ccAccount,
    WCHAR   wszAccount[])
{
    HRESULT hr;

    RpcTryExcept
    {
        hr = SAGetNSAccountInformation(pwszServerName, ccAccount, wszAccount);
    }
    RpcExcept(1)
    {
        DWORD Status = RpcExceptionCode();
        schDebugOut((DEB_ERROR,
            "SAGetNSAccountInformation exception(0x%x)\n",
            Status));
        hr = SchedMapRpcError(Status);
    }
    RpcEndExcept;

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\daytona.inc ===
#+----------------------------------------------------------------------------
#
# Microsoft Windows
# Copyright (C) Microsoft Corporation, 1992 - 1996.
#
# Job Scheduler service common make macros for the NT target binaries
#
# 11/14/95 EricB - created
# 11/14/00 Dgrube - added     $(SDK_LIB_PATH)\mpr.lib \ for WNET apis'
#
#-----------------------------------------------------------------------------

MAJORCOMP=mgt
MINORCOMP=schedule

C_DEFINES=    \
              $(C_DEFINES)          \
              -DFLAT                \
              -DWIN32=100           \
              -DINC_OLE2            \
              -DNOEXCEPTIONS        \
              -D_NT1X_=100          \
              -DUNICODE             \
              -D_UNICODE



USE_MSVCRT=1

SCHEDBASE=$(PROJECT_ROOT)\services\sched

INCLUDES=       $(SCHEDBASE)\inc;    \
                $(SCHEDBASE)\pch;    \
                $(SHELL_INC_PATH);   \
                $(WINDOWS_INC_PATH); \
                $(BASE_INC_PATH); \
                $(INCLUDES)


LINKLIBS=\
    $(SDK_LIB_PATH)\mpr.lib \
    $(PROJECT_ROOT)\services\smdebug\$(O)\smdebug.lib

TARGETLIBS=\
    $(SDK_LIB_PATH)\mstask.lib   \
    $(SDK_LIB_PATH)\advapi32.lib \
    $(SDK_LIB_PATH)\shlwapi.lib  \
    $(SHELL_LIB_PATH)\shell32p.lib \
    $(SDK_LIB_PATH)\comctl32.lib \
    $(SDK_LIB_PATH)\uuid.lib     \
    $(SDK_LIB_PATH)\kernel32.lib \
    $(SDK_LIB_PATH)\ntdll.lib    \
    $(SDK_LIB_PATH)\user32.lib   \
    $(SDK_LIB_PATH)\rpcrt4.lib   \
    $(SDK_LIB_PATH)\rpcutil.lib  \
    $(SDK_LIB_PATH)\gdi32.lib    \
    $(SDK_LIB_PATH)\comdlg32.lib \
    $(SDK_LIB_PATH)\userenv.lib  \
    $(SDK_LIB_PATH)\version.lib  \
    $(SDK_LIB_PATH)\wtsapi32.lib \
    $(TARGETLIBS)

!ifndef NTNOPCH
PRECOMPILED_INCLUDE=$(SCHEDBASE)\pch\headers.hxx
PRECOMPILED_OPTION=/Fp$(SCHEDBASE)\pch\daytona\$(O)\headers.pch
PRECOMPILED_TARGET=$(SCHEDBASE)\pch\daytona\$(O)\headers.pch
PRECOMPILED_OBJ=$(SCHEDBASE)\pch\daytona\$(O)\headers.obj
PRECOMPILED_CXX=1
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\utils\nt4thunks.cpp ===
/************************************************************************

Copyright (c) 2000 - 2001 Microsoft Corporation

Module Name :

    nt4thunks.cpp

Abstract :

    General helper functions to get BITS to work on NT4

Author :

Revision History :

 ***********************************************************************/

#include "qmgrlibp.h"
#include <bitsmsg.h>
#include <sddl.h>
#include <shlwapi.h>

#if !defined(BITS_V12_ON_NT4)
#include "nt4thunks.tmh"
#endif

#if defined( BITS_V12_ON_NT4 )

BOOL
BITSAltGetFileSizeEx(
   HANDLE hFile,              // handle to file
   PLARGE_INTEGER lpFileSize  // file size
   )
{

    DWORD HighPart;

    DWORD Result =
        GetFileSize( hFile, &HighPart );

    if ( INVALID_FILE_SIZE == Result &&
         GetLastError() != NO_ERROR )
        return FALSE;

    lpFileSize->HighPart = (LONG)HighPart;
    lpFileSize->LowPart  = Result;
    return TRUE;

}

BOOL
BITSAltSetFilePointerEx(
    HANDLE hFile,                    // handle to file
    LARGE_INTEGER liDistanceToMove,  // bytes to move pointer
    PLARGE_INTEGER lpNewFilePointer, // new file pointer
    DWORD dwMoveMethod               // starting point
    )
{


    LONG  DistanceToMoveHigh = liDistanceToMove.HighPart;
    DWORD DistanceToMoveLow  = liDistanceToMove.LowPart;

    DWORD Result =
        SetFilePointer(
            hFile,
            (LONG)DistanceToMoveLow,
            &DistanceToMoveHigh,
            dwMoveMethod );

    if ( INVALID_SET_FILE_POINTER == Result &&
         NO_ERROR != GetLastError() )
        return FALSE;

    if ( lpNewFilePointer )
        {
        lpNewFilePointer->HighPart = DistanceToMoveHigh;
        lpNewFilePointer->LowPart  = (DWORD)DistanceToMoveLow;
        }

    return TRUE;

}

//
// Local macros
//
#define STRING_GUID_LEN 36
#define STRING_GUID_SIZE  ( STRING_GUID_LEN * sizeof( WCHAR ) )
#define SDDL_LEN_TAG( tagdef )  ( sizeof( tagdef ) / sizeof( WCHAR ) - 1 )
#define SDDL_SIZE_TAG( tagdef )  ( wcslen( tagdef ) * sizeof( WCHAR ) )
#define SDDL_SIZE_SEP( sep ) (sizeof( WCHAR ) )

#define SDDL_VALID_DACL  0x00000001
#define SDDL_VALID_SACL  0x00000002

ULONG
BITSAltSetLastNTError(
    IN NTSTATUS Status
    )
{
    ULONG dwErrorCode;

    dwErrorCode = RtlNtStatusToDosError( Status );
    SetLastError( dwErrorCode );
    return( dwErrorCode );
}


BOOL
BITSAltConvertSidToStringSidW(
    IN  PSID     Sid,
    OUT LPWSTR  *StringSid
    )
/*++

Routine Description:

    This routine converts a SID into a string representation of a SID, suitable for framing or
    display

Arguments:

    Sid - SID to be converted.

    StringSid - Where the converted SID is returned.  Allocated via LocalAlloc and needs to
        be freed via LocalFree.


Return Value:

    TRUE    -   Success
    FALSE   -   Failure

    Extended error status is available using GetLastError.

--*/
{
    NTSTATUS Status;
    UNICODE_STRING UnicodeStringSid;

    if ( NULL == Sid || NULL == StringSid ) {
        //
        // invalid parameter
        //
        SetLastError( ERROR_INVALID_PARAMETER );
        return( FALSE );
    }

    //
    // Convert using the Rtl functions
    //
    Status = RtlConvertSidToUnicodeString( &UnicodeStringSid, Sid, TRUE );

    if ( !NT_SUCCESS( Status ) ) {

        BITSAltSetLastNTError( Status );
        return( FALSE );
    }

    //
    // Convert it to the proper allocator
    //
    *StringSid = (LPWSTR)LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                                     UnicodeStringSid.Length + sizeof( WCHAR ) );

    if ( *StringSid == NULL ) {

        RtlFreeUnicodeString( &UnicodeStringSid );

        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return( FALSE );

    }

    RtlCopyMemory( *StringSid, UnicodeStringSid.Buffer, UnicodeStringSid.Length );
    RtlFreeUnicodeString( &UnicodeStringSid );

    SetLastError(ERROR_SUCCESS);
    return( TRUE );
}

//
// Private functions
//
BOOL
LocalConvertStringSidToSid (
    IN  PWSTR       StringSid,
    OUT PSID       *Sid,
    OUT PWSTR      *End
    )
/*++

Routine Description:

    This routine will convert a string representation of a SID back into
    a sid.  The expected format of the string is:
                "S-1-5-32-549"
    If a string in a different format or an incorrect or incomplete string
    is given, the operation is failed.

    The returned sid must be free via a call to LocalFree


Arguments:

    StringSid - The string to be converted

    Sid - Where the created SID is to be returned

    End - Where in the string we stopped processing


Return Value:

    TRUE - Success.

    FALSE - Failure.  Additional information returned from GetLastError().  Errors set are:

            ERROR_SUCCESS indicates success

            ERROR_NOT_ENOUGH_MEMORY indicates a memory allocation for the ouput sid
                                    failed
            ERROR_INVALID_SID indicates that the given string did not represent a sid

--*/
{
    DWORD Err = ERROR_SUCCESS;
    UCHAR Revision, Subs;
    SID_IDENTIFIER_AUTHORITY IDAuth;
    PULONG SubAuth = NULL;
    PWSTR CurrEnd, Curr, Next;
    WCHAR Stub, *StubPtr = NULL;
    ULONG Index;
    INT gBase=10;
    INT lBase=10;
    ULONG Auto;

    if ( NULL == StringSid || NULL == Sid || NULL == End ) {

        SetLastError( ERROR_INVALID_PARAMETER );
        return( FALSE );

    }

//    if ( wcslen( StringSid ) < 2 || ( *StringSid != L'S' && *( StringSid + 1 ) != L'-' ) ) {

    //
    // no need to check length because StringSid is NULL
    // and if the first char is NULL, it won't access the second char
    //
    if ( (*StringSid != L'S' && *StringSid != L's') ||
         *( StringSid + 1 ) != L'-' ) {
        //
        // string sid should always start with S-
        //
        SetLastError( ERROR_INVALID_SID );
        return( FALSE );
    }


    Curr = StringSid + 2;

    if ( (*Curr == L'0') &&
         ( *(Curr+1) == L'x' ||
           *(Curr+1) == L'X' ) ) {

        gBase = 16;
    }

    Revision = ( UCHAR )wcstol( Curr, &CurrEnd, gBase );

    if ( CurrEnd == Curr || *CurrEnd != L'-' || *(CurrEnd+1) == L'\0' ) {
        //
        // no revision is provided, or invalid delimeter
        //
        SetLastError( ERROR_INVALID_SID );
        return( FALSE );
    }

    Curr = CurrEnd + 1;

    //
    // Count the number of characters in the indentifer authority...
    //
    Next = wcschr( Curr, L'-' );
/*
    Length = 6 doesn't mean each digit is a id authority value, could be 0x...

    if ( Next != NULL && (Next - Curr == 6) ) {

        for ( Index = 0; Index < 6; Index++ ) {

//            IDAuth.Value[Index] = (UCHAR)Next[Index];  what is this ???
            IDAuth.Value[Index] = (BYTE) (Curr[Index]-L'0');
        }

        Curr +=6;

    } else {
*/
        if ( (*Curr == L'0') &&
             ( *(Curr+1) == L'x' ||
               *(Curr+1) == L'X' ) ) {

            lBase = 16;
        } else {
            lBase = gBase;
        }

        Auto = wcstoul( Curr, &CurrEnd, lBase );

         if ( CurrEnd == Curr || *CurrEnd != L'-' || *(CurrEnd+1) == L'\0' ) {
             //
             // no revision is provided, or invalid delimeter
             //
             SetLastError( ERROR_INVALID_SID );
             return( FALSE );
         }

         IDAuth.Value[0] = IDAuth.Value[1] = 0;
         IDAuth.Value[5] = ( UCHAR )Auto & 0xFF;
         IDAuth.Value[4] = ( UCHAR )(( Auto >> 8 ) & 0xFF );
         IDAuth.Value[3] = ( UCHAR )(( Auto >> 16 ) & 0xFF );
         IDAuth.Value[2] = ( UCHAR )(( Auto >> 24 ) & 0xFF );
         Curr = CurrEnd;
//    }

    //
    // Now, count the number of sub auths, at least one sub auth is required
    //
    Subs = 0;
    Next = Curr;

    //
    // We'll have to count our sub authoritys one character at a time,
    // since there are several deliminators that we can have...
    //

    while ( Next ) {

        if ( *Next == L'-' && *(Next-1) != L'-') {

            //
            // do not allow two continuous '-'s
            // We've found one!
            //
            Subs++;

            if ( (*(Next+1) == L'0') &&
                 ( *(Next+2) == L'x' ||
                   *(Next+2) == L'X' ) ) {
                //
                // this is hex indicator
                //
                Next += 2;

            }

        } else if ( *Next == SDDL_SEPERATORC || *Next  == L'\0' ||
                    *Next == SDDL_ACE_ENDC || *Next == L' ' ||
                    ( *(Next+1) == SDDL_DELIMINATORC &&
                      (*Next == L'G' || *Next == L'O' || *Next == L'S')) ) {
            //
            // space is a terminator too
            //
            if ( *( Next - 1 ) == L'-' ) {
                //
                // shouldn't allow a SID terminated with '-'
                //
                Err = ERROR_INVALID_SID;
                Next--;

            } else {
                Subs++;
            }

            *End = Next;
            break;

        } else if ( !iswxdigit( *Next ) ) {

            Err = ERROR_INVALID_SID;
            *End = Next;
//            Subs++;
            break;

        } else {

            //
            // Note: SID is also used as a owner or group
            //
            // Some of the tags (namely 'D' for Dacl) fall under the category of iswxdigit, so
            // if the current character is a character we care about and the next one is a
            // delminiator, we'll quit
            //
            if ( *Next == L'D' && *( Next + 1 ) == SDDL_DELIMINATORC ) {

                //
                // We'll also need to temporarily truncate the string to this length so
                // we don't accidentally include the character in one of the conversions
                //
                Stub = *Next;
                StubPtr = Next;
                *StubPtr = UNICODE_NULL;
                *End = Next;
                Subs++;
                break;
            }

        }

        Next++;

    }

    if ( Err == ERROR_SUCCESS ) {

        if ( Subs != 0 ) Subs--;

        if ( Subs != 0 ) {

            Curr++;

            SubAuth = ( PULONG )LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, Subs * sizeof( ULONG ) );

            if ( SubAuth == NULL ) {

                Err = ERROR_NOT_ENOUGH_MEMORY;

            } else {

                for ( Index = 0; Index < Subs; Index++ ) {

                    if ( (*Curr == L'0') &&
                         ( *(Curr+1) == L'x' ||
                           *(Curr+1) == L'X' ) ) {

                        lBase = 16;
                    } else {
                        lBase = gBase;
                    }

                    SubAuth[Index] = wcstoul( Curr, &CurrEnd, lBase );
                    Curr = CurrEnd + 1;
                }
            }

        } else {

            Err = ERROR_INVALID_SID;
        }
    }

    //
    // Now, create the SID
    //
    if ( Err == ERROR_SUCCESS ) {

        *Sid = ( PSID )LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                                   sizeof( SID ) + Subs * sizeof( ULONG ) );

        if ( *Sid == NULL ) {

            Err = ERROR_NOT_ENOUGH_MEMORY;

        } else {

            PISID ISid = ( PISID )*Sid;
            ISid->Revision = Revision;
            ISid->SubAuthorityCount = Subs;
            RtlCopyMemory( &( ISid->IdentifierAuthority ), &IDAuth,
                           sizeof( SID_IDENTIFIER_AUTHORITY ) );
            RtlCopyMemory( ISid->SubAuthority, SubAuth, Subs * sizeof( ULONG ) );
        }
    }

    LocalFree( SubAuth );

    //
    // Restore any character we may have stubbed out
    //
    if ( StubPtr ) {

        *StubPtr = Stub;
    }

    SetLastError( Err );

    return( Err == ERROR_SUCCESS );
}

BOOL
BITSAltConvertStringSidToSidW(
    IN LPCWSTR  StringSid,
    OUT PSID   *Sid
    )

/*++

Routine Description:

    This routine converts a stringized SID into a valid, functional SID

Arguments:

    StringSid - SID to be converted.

    Sid - Where the converted SID is returned.  Buffer is allocated via LocalAlloc and should
        be free via LocalFree.


Return Value:

    TRUE    -   Success
    FALSE   -   Failure

    Extended error status is available using GetLastError.

        ERROR_INVALID_PARAMETER - A NULL name was given

        ERROR_INVALID_SID - The format of the given sid was incorrect

--*/

{
    PWSTR End = NULL;
    BOOL ReturnValue = FALSE;
    PSID pSASid=NULL;
    ULONG Len=0;
    DWORD SaveCode=0;
    DWORD Err=0;

    if ( StringSid == NULL || Sid == NULL )
        {
        SetLastError( ERROR_INVALID_PARAMETER );
        return ReturnValue;
        }

    ReturnValue = LocalConvertStringSidToSid( ( PWSTR )StringSid, Sid, &End );

    if ( !ReturnValue )
        {
        SetLastError( ERROR_INVALID_PARAMETER );
        return ReturnValue;
        }

    if ( ( ULONG )( End - StringSid ) != wcslen( StringSid ) ) {

        SetLastError( ERROR_INVALID_SID );
        LocalFree( *Sid );
        *Sid = FALSE;
        ReturnValue = FALSE;

        } else {
            SetLastError(ERROR_SUCCESS);
        }

    return ReturnValue;

}

BOOL
BITSAltCheckTokenMembership(
    IN HANDLE TokenHandle OPTIONAL,
    IN PSID SidToCheck,
    OUT PBOOL IsMember
    )
/*++

Routine Description:

    This function checks to see whether the specified sid is enabled in
    the specified token.

Arguments:

    TokenHandle - If present, this token is checked for the sid. If not
        present then the current effective token will be used. This must
        be an impersonation token.

    SidToCheck - The sid to check for presence in the token

    IsMember - If the sid is enabled in the token, contains TRUE otherwise
        false.

Return Value:

    TRUE - The API completed successfully. It does not indicate that the
        sid is a member of the token.

    FALSE - The API failed. A more detailed status code can be retrieved
        via GetLastError()


--*/
{
    HANDLE ProcessToken = NULL;
    HANDLE EffectiveToken = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    PISECURITY_DESCRIPTOR SecDesc = NULL;
    ULONG SecurityDescriptorSize;
    GENERIC_MAPPING GenericMapping = {
        STANDARD_RIGHTS_READ,
        STANDARD_RIGHTS_EXECUTE,
        STANDARD_RIGHTS_WRITE,
        STANDARD_RIGHTS_ALL };
    //
    // The size of the privilege set needs to contain the set itself plus
    // any privileges that may be used. The privileges that are used
    // are SeTakeOwnership and SeSecurity, plus one for good measure
    //

    BYTE PrivilegeSetBuffer[sizeof(PRIVILEGE_SET) + 3*sizeof(LUID_AND_ATTRIBUTES)];
    PPRIVILEGE_SET PrivilegeSet = (PPRIVILEGE_SET) PrivilegeSetBuffer;
    ULONG PrivilegeSetLength = sizeof(PrivilegeSetBuffer);
    ACCESS_MASK AccessGranted = 0;
    NTSTATUS AccessStatus = 0;
    PACL Dacl = NULL;

#define MEMBER_ACCESS 1

    *IsMember = FALSE;

    //
    // Get a handle to the token
    //

    if (ARGUMENT_PRESENT(TokenHandle))
    {
        EffectiveToken = TokenHandle;
    }
    else
    {
        Status = NtOpenThreadToken(
                    NtCurrentThread(),
                    TOKEN_QUERY,
                    FALSE,              // don't open as self
                    &EffectiveToken
                    );

        //
        // if there is no thread token, try the process token
        //

        if (Status == STATUS_NO_TOKEN)
        {
            Status = NtOpenProcessToken(
                        NtCurrentProcess(),
                        TOKEN_QUERY | TOKEN_DUPLICATE,
                        &ProcessToken
                        );
            //
            // If we have a process token, we need to convert it to an
            // impersonation token
            //

            if (NT_SUCCESS(Status))
            {
                BOOL Result;
                Result = DuplicateToken(
                            ProcessToken,
                            SecurityImpersonation,
                            &EffectiveToken
                            );

                CloseHandle(ProcessToken);
                if (!Result)
                {
                    return(FALSE);
                }
            }
        }

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

    }

    //
    // Construct a security descriptor to pass to access check
    //

    //
    // The size is equal to the size of an SD + twice the length of the SID
    // (for owner and group) + size of the DACL = sizeof ACL + size of the
    // ACE, which is an ACE + length of
    // ths SID.
    //

    SecurityDescriptorSize = sizeof(SECURITY_DESCRIPTOR) +
                                sizeof(ACCESS_ALLOWED_ACE) +
                                sizeof(ACL) +
                                3 * RtlLengthSid(SidToCheck);

    SecDesc = (PISECURITY_DESCRIPTOR) LocalAlloc(LMEM_ZEROINIT, SecurityDescriptorSize );
    if (SecDesc == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    Dacl = (PACL) (SecDesc + 1);

    RtlCreateSecurityDescriptor(
        SecDesc,
        SECURITY_DESCRIPTOR_REVISION
        );

    //
    // Fill in fields of security descriptor
    //

    RtlSetOwnerSecurityDescriptor(
        SecDesc,
        SidToCheck,
        FALSE
        );
    RtlSetGroupSecurityDescriptor(
        SecDesc,
        SidToCheck,
        FALSE
        );

    Status = RtlCreateAcl(
                Dacl,
                SecurityDescriptorSize - sizeof(SECURITY_DESCRIPTOR),
                ACL_REVISION
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    Status = RtlAddAccessAllowedAce(
                Dacl,
                ACL_REVISION,
                MEMBER_ACCESS,
                SidToCheck
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Set the DACL on the security descriptor
    //

    Status = RtlSetDaclSecurityDescriptor(
                SecDesc,
                TRUE,   // DACL present
                Dacl,
                FALSE   // not defaulted
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = NtAccessCheck(
                SecDesc,
                EffectiveToken,
                MEMBER_ACCESS,
                &GenericMapping,
                PrivilegeSet,
                &PrivilegeSetLength,
                &AccessGranted,
                &AccessStatus
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // if the access check failed, then the sid is not a member of the
    // token
    //

    if ((AccessStatus == STATUS_SUCCESS) && (AccessGranted == MEMBER_ACCESS))
    {
        *IsMember = TRUE;
    }




Cleanup:
    if (!ARGUMENT_PRESENT(TokenHandle) && (EffectiveToken != NULL))
    {
        (VOID) NtClose(EffectiveToken);
    }

    if (SecDesc != NULL)
    {
        LocalFree(SecDesc);
    }

    if (!NT_SUCCESS(Status))
    {
        BITSAltSetLastNTError(Status);
        return(FALSE);
    }
    else
    {
        return(TRUE);
    }
}

LPHANDLER_FUNCTION_EX g_BITSAltRegisterServiceFunc = NULL;
typedef SERVICE_STATUS_HANDLE (*REGISTER_FUNC_TYPE)(LPCTSTR, LPHANDLER_FUNCTION_EX, LPVOID lpContext);

VOID WINAPI
BITSAltRegisterServiceThunk(
  DWORD dwControl   // requested control code
)
{

    (*g_BITSAltRegisterServiceFunc)( dwControl, 0, NULL, NULL );
    return;

}

SERVICE_STATUS_HANDLE
BITSAltRegisterServiceCtrlHandlerExW(
  LPCTSTR lpServiceName,                // name of service
  LPHANDLER_FUNCTION_EX lpHandlerProc,  // handler function
  LPVOID lpContext                      // user data
)
{

    // First check if RegisterServerCtrlHandlerEx if available and use
    // it, otherwise thunk the call.

    HMODULE AdvapiHandle = LoadLibraryW( L"advapi32.dll" );

    if ( !AdvapiHandle )
        {
        // Something is messed up, every machine should have this DLL.
        return NULL;
        }


    SERVICE_STATUS_HANDLE ReturnValue;
    FARPROC RegisterFunc = GetProcAddress( AdvapiHandle, "RegisterServiceCtrlHandlerExW" );

    if ( RegisterFunc )
        {
        ReturnValue = (*(REGISTER_FUNC_TYPE)RegisterFunc)( lpServiceName, lpHandlerProc, lpContext );
        }
    else
        {

        if ( g_BITSAltRegisterServiceFunc || lpContext )
            {
            ReturnValue = 0;
            SetLastError( ERROR_INVALID_PARAMETER );
            }
        else
            {
            g_BITSAltRegisterServiceFunc = lpHandlerProc;
            ReturnValue = RegisterServiceCtrlHandler( lpServiceName, BITSAltRegisterServiceThunk );

            if ( !ReturnValue)
                g_BITSAltRegisterServiceFunc = NULL;
            }

        }

    DWORD OldError = GetLastError();
    FreeLibrary( AdvapiHandle );
    SetLastError( OldError );

    return ReturnValue;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\atcmd\makefile.inc ===
lmatmsg.rc: msg00001.bin

lmatmsg.h msg00001.bin: lmatmsg.mc
    mc -v lmatmsg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\cab\ie4\dummy.cxx ===
#include <windows.h>

void Dummy(void)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\at\atconv.cxx ===
//+----------------------------------------------------------------------------
//
//  Scheduling Agent Service
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       atconv.cxx
//
//  Classes:    None.
//
//  Functions:  ConvertAtJobsToTasks
//
//  History:    13-Jun-96   EricB   Created.
//
//-----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop

#include <sch_cls.hxx>
#include <job_cls.hxx>
#include "..\inc\debug.hxx"

//
// The constants and types below taken from net\svcdlls\at\server\at.h
//
#define AT_REGISTRY_PATH    L"System\\CurrentControlSet\\Services\\Schedule"
#define AT_SCHEDULE_NAME    L"Schedule"
#define AT_COMMAND_NAME     L"Command"

#define MAXIMUM_COMMAND_LENGTH  (MAX_PATH - 1)  // == 259, cmd.exe uses this
#define MAXIMUM_JOB_TIME    (24 * 60 * 60 * 1000 - 1)
#define DAYS_OF_WEEK        0x7F                    // 7 bits for 7 days
#define DAYS_OF_MONTH       0x7FFFFFFF              // 31 bits for 31 days

#define AT_KEY_BUF_LEN      20  //  9 would suffice, but this is safer

typedef struct _AT_SCHEDULE {
    DWORD       JobTime;        //  time of day to run, in seconds from midnight
    DWORD       DaysOfMonth;    //  bitmask for days of month to run
    UCHAR       DaysOfWeek;     //  bitmask for days of week to run
    UCHAR       Flags;          //  see lmat.h
    WORD        Reserved;       //  padding, since registry pads them as well
} AT_SCHEDULE;

//+----------------------------------------------------------------------------
//
//  Function:   ConvertAtJobsToTasks
//
//  Synopsis:   At setup time, read the AT service jobs out of the registry
//              and convert them to Scheduling Agent Tasks.
//
//-----------------------------------------------------------------------------
STDAPI_(void)
ConvertAtJobsToTasks(void)
{
    struct KEYNAME {
        KEYNAME *   pNext;
        WCHAR       wszName[AT_KEY_BUF_LEN];
    };

    CSchedule * pSch = new CSchedule;
    if (pSch == NULL)
    {
        ERR_OUT("ConvertAtJobsToTasks, new pSch", E_OUTOFMEMORY);
        return;
    }
    HRESULT hr = pSch->Init();
    if (FAILED(hr))
    {
        pSch->Release();
        ERR_OUT("ConvertAtJobsToTasks, pSch->Init", hr);
        return;
    }

    HKEY        hKeySvc, hKey;
    DWORD       index;
    WCHAR       wszNameBuffer[AT_KEY_BUF_LEN];
    FILETIME    lastWriteTime;
    WCHAR       wszCommand[MAXIMUM_COMMAND_LENGTH + 1];
    AT_SCHEDULE Schedule;
    DWORD       Length;
    DWORD       type;
    DWORD       NameSize;
    DWORD       CommandSize;
    KEYNAME *   pDeleteList = NULL;

    long lRet;

    //
    // Open the AT service registry tree.
    //
    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        AT_REGISTRY_PATH,
                        0,
                        KEY_READ,
                        &hKeySvc);
    if (lRet != ERROR_SUCCESS)
    {
        ERR_OUT("ConvertAtJobsToTasks: open hKeySvc", lRet);
        pSch->Release();
        return;
    }

    for (index = 0;  ; index++)
    {
        //
        //  Regedit can sometimes display other keys in addition to keys
        //  found here.  Also, it often fails to display last character in
        //  the Command and after a refresh it may not display some of the
        //  spurious keys.
        //
        Length = sizeof(wszNameBuffer) / sizeof(wszNameBuffer[0]);
        lRet = RegEnumKeyEx(hKeySvc,
                            index,
                            wszNameBuffer,             // lpName
                            &Length,                // lpcbName
                            0,                      // lpReserved
                            NULL,                   // lpClass
                            NULL,                   // lpcbClass
                            &lastWriteTime);
        if (lRet != ERROR_SUCCESS)
        {
            if (lRet != ERROR_NO_MORE_ITEMS)
            {
                ERR_OUT("ConvertAtJobsToTasks: RegEnumKeyEx", lRet);
            }
            //
            // The only exit point from this loop
            //
            break;
        }

        //
        //  Length returned is the number of characters in a UNICODE string
        //  representing the key name (not counting the terminating NULL
        //  character which is also supplied).
        //
        NameSize = (Length + 1) * sizeof(WCHAR);
        lRet = RegOpenKeyEx(hKeySvc,
                            wszNameBuffer,
                            0,
                            KEY_READ,
                            &hKey);
        if (lRet != ERROR_SUCCESS)
        {
            ERR_OUT("ConvertAtJobsToTasks: RegOpenKeyEx", lRet);
            continue;
        }

        Length = sizeof(Schedule);
        lRet = RegQueryValueEx(hKey,
                               AT_SCHEDULE_NAME,
                               NULL,
                               &type,
                               (LPBYTE)&Schedule,
                               &Length);
        if (lRet != ERROR_SUCCESS)
        {
            ERR_OUT("ConvertAtJobsToTasks: RegQueryValueEx(AT_SCHEDULE_NAME)",
                    lRet);
            RegCloseKey(hKey);
            continue;
        }
        if (type != REG_BINARY                           ||
            Length != sizeof(AT_SCHEDULE)                ||
            (Schedule.DaysOfWeek & ~DAYS_OF_WEEK) != 0   ||
            (Schedule.DaysOfMonth & ~DAYS_OF_MONTH) != 0 ||
            Schedule.JobTime >= MAXIMUM_JOB_TIME )
        {
            schDebugOut((DEB_ERROR,"ConvertAtJobsToTasks: RegQueryValueEx invalid data: "
                         "type=%lu, Length=%lu, DOW=%#x, DOM=%#lx, Time=%lu\n",
                         type, Length, Schedule.DaysOfWeek, Schedule.DaysOfMonth,
                         Schedule.JobTime));
            RegCloseKey(hKey);
            continue;
        }

        Length = sizeof(wszCommand);
        lRet = RegQueryValueEx(hKey,
                               AT_COMMAND_NAME,
                               NULL,
                               &type,
                               (LPBYTE)wszCommand,
                               &Length);

        RegCloseKey(hKey);

        if (lRet != ERROR_SUCCESS)
        {
            ERR_OUT("ConvertAtJobsToTasks: RegQueryValueEx(AT_COMMAND_NAME)",
                    lRet);
            continue;
        }

        if (type != REG_SZ)
        {
            ERR_OUT("ConvertAtJobsToTasks: Command is not of REG_SZ type", 0);
            continue;
        }

        AT_INFO At;

        At.Command     = wszCommand;
        At.JobTime     = Schedule.JobTime;
        At.DaysOfMonth = Schedule.DaysOfMonth;
        At.DaysOfWeek  = Schedule.DaysOfWeek;
        At.Flags       = Schedule.Flags;

        hr = pSch->AddAtJob(At, NULL);

        if (SUCCEEDED(hr))
        {
            //
            // If the job was successfully converted, then add it to the
            // list of jobs to delete from the registry.  Don't delete it
            // right away, because that would mess up the operation of
            // RegEnumKeyEx.
            //
            KEYNAME * pKey = new KEYNAME;
            if (pKey == NULL)
            {
                ERR_OUT("ConvertAtJobsToTasks: new KEYNAME", GetLastError());
                RegDeleteKey(hKeySvc, wszNameBuffer);
                break;
            }

            pKey->pNext = pDeleteList;
            pDeleteList = pKey;

            wcscpy(pKey->wszName, wszNameBuffer);
        }
#if DBG == 1
        else
        {
            ERR_OUT("ConvertAtJobsToTasks: AddAtJob", hr);
        }
#endif
    }

    //
    // Delete the reg keys for all jobs that were successfully converted
    //
    KEYNAME * pNext;
    for ( ; pDeleteList != NULL; pDeleteList = pNext)
    {
        RegDeleteKey(hKeySvc, pDeleteList->wszName);
        pNext = pDeleteList->pNext;
        delete pDeleteList;
    }


    RegCloseKey(hKeySvc);
    pSch->Release();

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\atcmd\atcmd.c ===
/*++

Copyright (c) 1987-1992  Microsoft Corporation

Module Name:

    atcmd.c

Abstract:

    Code for AT command, to be used with SCHEDULE service on Windows NT.

    The module was taken from LanManager\at.c and then modified considerably
    to work with NT Schedule service.

Author:

    Vladimir Z. Vulovic     (vladimv)       06 - November - 1992

Environment:

    User Mode - Win32

Revision History:

    06-Nov-1992     vladimv
        Created

    20-Feb-1993     yihsins
        Get rid of hard coded strings and parse/print time according
        to user profile

    25-May-1993     RonaldM
        Convert strings to OEM before printing to the console, since
        the console doesn't yet support unicode.

    28-Jun-1993     RonaldM
        Added the "confirm" yes and no strings, which are meant to be
        localised.  The original yes and no strings cannot be localised,
        because this would create batch file incompatibilities.

    07-Jul-1994     vladimv
        Added support for interactive switch.  Replaced "confirm" strings
        with APE2_GEN_* strings - to eliminate redundancy.  The rule is
        that switches are not internationalizable while switch values are.

--*/

#include <nt.h>                 //  DbgPrint prototype
#include <ntrtl.h>              //  DbgPrint
#include <nturtl.h>             //  Needed by winbase.h

#include <windows.h>
#include <winnls.h>
#include <shellapi.h>

#include <lmcons.h>             //  NET_API_STATUS
#include <lmerr.h>              //  NetError codes
#include <icanon.h>             //  NetpNameValidate

#include "lmatmsg.h"            //  private AT error codes & messages
#include <lmat.h>               //  AT_INFO
#include <stdlib.h>             //  exit()
#include <stdio.h>              //  printf
#include <wchar.h>              //  wcslen
#include <apperr.h>             //  APE_AT_USAGE
#include <apperr2.h>            //  APE2_GEN_MONDAY + APE2_*
#include <lmapibuf.h>           //  NetApiBufferFree
#include <timelib.h>            //  NetpGetTimeFormat
#include <luidate.h>            //  LUI_ParseTimeSinceStartOfDay


#define YES_FLAG                0
#define NO_FLAG                 1
#define INVALID_FLAG            -1

#define DUMP_ALL                0
#define DUMP_ID                 1
#define ADD_TO_SCHEDULE         2
#define ADD_ONETIME             3
#define DEL_ID                  4
#define DEL_ALL                 5
#define ACTION_USAGE            6
#define MAX_COMMAND_LEN         128
#define MAX_SCHED_FIELD_LENGTH  24


#define PutNewLine()            GenOutput( TEXT("\n"))
#define PutNewLine2()           GenOutput( TEXT("\n\n"))

#define MAX_MSG_BUFFER      1024

WCHAR   ConBuf[MAX_MSG_BUFFER];

#define GenOutput(fmt)      \
    {wcscpy(ConBuf, fmt);   \
     ConsolePrint(ConBuf, wcslen(ConBuf));}

#define GenOutputArg(fmt, a1)       \
    {wsprintf(ConBuf, fmt, a1); \
     ConsolePrint(ConBuf, wcslen(ConBuf));}
//
//  Formats used by printf.
//
#define DUMP_FMT1       TEXT("%-7.7ws")

//
//  DUMP_FMT2 is chosen so that the most common case (id numbers less than 100)
//  looks good:  two spaces for a number, three spaces for blanks.
//  Larger numbers just like in LM21 will result to shifted display.
//
#define DUMP_FMT2       TEXT("%2d   ")
#define MAX_TIME_FIELD_LENGTH  14
#define DUMP_FMT3       TEXT("%ws")       // for printing JobTime

#define NULLC           L'\0'
#define BLANK           L' '
#define SLASH           L'/'
#define BACKSLASH       L'\\'
#define ELLIPSIS        L"..."

#define QUESTION_SW     L"/?"
#define QUESTION_SW_TOO L"-?"
#define SCHED_TOK_DELIM L","    // string of valid delimiters for days & dates
#define ARG_SEP_CHR     L':'

typedef struct _SEARCH_LIST {
    WCHAR *     String;
    DWORD       MessageId;
    DWORD       Value;
} SEARCH_LIST, *PSEARCH_LIST, *LPSEARCH_LIST;

//
//  All of the values below must be bitmasks.  MatchString() depends on that!
//
#define AT_YES_VALUE         0x0001
#define AT_DELETE_VALUE      0x0002
#define AT_EVERY_VALUE       0x0004
#define AT_NEXT_VALUE        0x0008
#define AT_NO_VALUE          0x0010
#define AT_CONFIRM_YES_VALUE 0x0020
#define AT_CONFIRM_NO_VALUE  0x0040
#define AT_INTERACTIVE       0x0080

SEARCH_LIST    GlobalListTable[] = {
    { NULL,    IDS_YES,         AT_YES_VALUE},
    { NULL,    IDS_DELETE,      AT_DELETE_VALUE},
    { NULL,    IDS_EVERY,       AT_EVERY_VALUE},
    { NULL,    IDS_NEXT,        AT_NEXT_VALUE},
    { NULL,    IDS_NO,          AT_NO_VALUE},
    { NULL,    APE2_GEN_YES,    AT_CONFIRM_YES_VALUE},
    { NULL,    APE2_GEN_NO,     AT_CONFIRM_NO_VALUE},
    { NULL,    IDS_INTERACTIVE, AT_INTERACTIVE},
    { NULL,    0,               0 }
};

SEARCH_LIST    DaysOfWeekSearchList[] = {
    { NULL,    APE2_GEN_MONDAY_ABBREV,     0},
    { NULL,    APE2_GEN_TUESDAY_ABBREV,    1},
    { NULL,    APE2_GEN_WEDNSDAY_ABBREV,   2},
    { NULL,    APE2_GEN_THURSDAY_ABBREV,   3},
    { NULL,    APE2_GEN_FRIDAY_ABBREV,     4},
    { NULL,    APE2_GEN_SATURDAY_ABBREV,   5},
    { NULL,    APE2_TIME_SATURDAY_ABBREV2, 5},
    { NULL,    APE2_GEN_SUNDAY_ABBREV,     6},
    { NULL,    APE2_GEN_MONDAY,            0},
    { NULL,    APE2_GEN_TUESDAY,           1},
    { NULL,    APE2_GEN_WEDNSDAY,          2},
    { NULL,    APE2_GEN_THURSDAY,          3},
    { NULL,    APE2_GEN_FRIDAY,            4},
    { NULL,    APE2_GEN_SATURDAY,          5},
    { NULL,    APE2_GEN_SUNDAY,            6},
    { NULL,    APE2_GEN_NONLOCALIZED_MONDAY_ABBREV,     0},
    { NULL,    APE2_GEN_NONLOCALIZED_TUESDAY_ABBREV,    1},
    { NULL,    APE2_GEN_NONLOCALIZED_WEDNSDAY_ABBREV,   2},
    { NULL,    APE2_GEN_NONLOCALIZED_THURSDAY_ABBREV,   3},
    { NULL,    APE2_GEN_NONLOCALIZED_FRIDAY_ABBREV,     4},
    { NULL,    APE2_GEN_NONLOCALIZED_SATURDAY_ABBREV,   5},
    { NULL,    APE2_GEN_NONLOCALIZED_SATURDAY_ABBREV2,  5},
    { NULL,    APE2_GEN_NONLOCALIZED_SUNDAY_ABBREV,     6},
    { NULL,    APE2_GEN_NONLOCALIZED_MONDAY,            0},
    { NULL,    APE2_GEN_NONLOCALIZED_TUESDAY,           1},
    { NULL,    APE2_GEN_NONLOCALIZED_WEDNSDAY,          2},
    { NULL,    APE2_GEN_NONLOCALIZED_THURSDAY,          3},
    { NULL,    APE2_GEN_NONLOCALIZED_FRIDAY,            4},
    { NULL,    APE2_GEN_NONLOCALIZED_SATURDAY,          5},
    { NULL,    APE2_GEN_NONLOCALIZED_SUNDAY,            6},
    { NULL,    0,             0 }
    };

BOOL
AreYouSure(
    VOID
    );
BOOL
ArgIsServerName(
    WCHAR *     string
    );
BOOL
ArgIsTime(
    IN      WCHAR *     timestr,
    OUT     PDWORD      pJobTime
    );
BOOL
ArgIsDecimalString(
    IN  WCHAR *  pDecimalString,
    OUT PDWORD   pNumber
    );
DWORD
ConsolePrint(
    IN      LPWSTR  pch,
    IN      int     cch
    );
int
FileIsConsole(
    int     fh
    );
BOOL
IsDayOfMonth(
    IN      WCHAR *     pToken,
    OUT     PDWORD      pDay
    );
BOOL
IsDayOfWeek(
    IN      WCHAR *     pToken,
    OUT     PDWORD      pDay
    );
NET_API_STATUS
JobAdd(
    VOID
    );
NET_API_STATUS
JobEnum(
    VOID
    );
NET_API_STATUS
JobGetInfo(
    VOID
    );
DWORD
MatchString(
    WCHAR *     name,
    DWORD       mask
    );
DWORD
MessageGet(
    IN      DWORD       MessageId,
    IN      LPWSTR      *buffer,
    IN      DWORD       Size
    );
DWORD
MessagePrint(
    IN      DWORD       MessageId,
    ...
    );
BOOL
ParseJobIdArgs(
    WCHAR   **  argv,
    int         argc,
    int         argno,
    PBOOL       pDeleteFound
    );
BOOL
ParseTimeArgs(
    WCHAR **    argv,
    int         argc,
    int         argno,
    int *       pargno
    );
VOID
PrintDay(
    int         type,
    DWORD       DaysOfMonth,
    UCHAR       DaysOfWeek,
    UCHAR       Flags
    );
VOID
PrintLine(
    VOID
    );
VOID
PrintTime(
    DWORD       JobTime
    );
BOOL
TraverseSearchList(
    PWCHAR          String,
    PSEARCH_LIST    SearchList,
    PDWORD          pValue
    );
VOID
Usage(
    BOOL    GoodCommand
    );
BOOL
ValidateCommand(
    IN  int         argc,
    IN  WCHAR **    argv,
    OUT int *       pCommand
    );

VOID
GetTimeString(
    DWORD Time,
    WCHAR *Buffer,
    int BufferLength
    );

BOOL
InitList(
    PSEARCH_LIST  SearchList
    );

VOID
TermList(
    PSEARCH_LIST  SearchList
    );

DWORD
GetStringColumn(
    WCHAR *
    );

AT_INFO     GlobalAtInfo;           //  buffer for scheduling new jobs
WCHAR       GlobalAtInfoCommand[ MAX_COMMAND_LEN + 1];

DWORD       GlobalJobId;            //  id of job in question
PWSTR       GlobalServerName;
HANDLE      GlobalMessageHandle;
BOOL        GlobalYes;
BOOL        GlobalDeleteAll;
BOOL        GlobalErrorReported;
BOOL        bDBCS;

CHAR **     GlobalCharArgv;         // keeps original input

NET_TIME_FORMAT GlobalTimeFormat = {0};

//  In OS/2 it used to be OK to call "exit()" with a negative number.  In
//  NT however, "exit()" should be called with a positive number only (a
//  valid windows error code?!).  Note that OS/2 AT command used to call
//  exit(+1) for bad user input, and exit(-1) where -1 would get mapped to
//  255 for other errors.  To keep things simple and to avoid calling exit()
//  with a negative number, NT AT command calls exit(+1) for all possible
//  errors.

#define     AT_GENERIC_ERROR        1


VOID __cdecl
main(
    int         argc,
    CHAR **     charArgv
    )
/*++

Routine Description:

    Main module.  Note that strings (for now) arrive as asciiz even
    if you compile app for UNICODE.

Arguments:

    argc        -   argument count
    charArgv    -   array of ascii strings

Return Value:

    None.

--*/
{
    NET_API_STATUS      status = NERR_Success;
    int                 command;    // what to do
    WCHAR **            argv;
    DWORD               cp;
    CPINFO              CurrentCPInfo;

    GlobalYes = FALSE;
    GlobalDeleteAll = FALSE;
    GlobalErrorReported = FALSE;
    GlobalCharArgv = charArgv;

    /*
       Added for bilingual message support.  This is needed for FormatMessage
       to work correctly.  (Called from DosGetMessage).
       Get current CodePage Info.  We need this to decide whether
       or not to use half-width characters.
    */


    GetCPInfo(cp=GetConsoleOutputCP(), &CurrentCPInfo);
    switch ( cp ) {
	case 932:
	case 936:
	case 949:
	case 950:
	    SetThreadLocale(
		MAKELCID(
		    MAKELANGID(
			    PRIMARYLANGID(GetSystemDefaultLangID()),
			    SUBLANG_ENGLISH_US ),
		    SORT_DEFAULT
		    )
		);
        bDBCS = TRUE;
	    break;

	default:
	    SetThreadLocale(
		MAKELCID(
		    MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US ),
		    SORT_DEFAULT
		    )
		);
        bDBCS = FALSE;
	    break;
	}

    GlobalMessageHandle = LoadLibrary( L"netmsg.dll");
    if ( GlobalMessageHandle == NULL) {
        MessagePrint( IDS_LOAD_LIBRARY_FAILURE, GetLastError());
        exit( AT_GENERIC_ERROR);
    }

    if ( ( argv = CommandLineToArgvW( GetCommandLineW(), &argc)) == NULL) {
        MessagePrint( IDS_UNABLE_TO_MAP_TO_UNICODE );
        exit( AT_GENERIC_ERROR);
    }

    if ( ValidateCommand( argc, argv, &command) == FALSE) {
        Usage( FALSE);
        exit( AT_GENERIC_ERROR);
    }

    switch( command) {

    case DUMP_ALL:
        status = JobEnum();
        break;

    case DUMP_ID:
        status = JobGetInfo();
        break;

    case ADD_TO_SCHEDULE:
        status = JobAdd();
        break;

    case DEL_ALL:
        if ( AreYouSure() == FALSE) {
            break;
        }
        status = NetScheduleJobDel(
                GlobalServerName,
                0,
                (DWORD)-1
                );
        if ( status == NERR_Success || status == APE_AT_ID_NOT_FOUND) {
            break;
        }
        MessagePrint( status );
        break;

    case DEL_ID:
        status = NetScheduleJobDel(
                GlobalServerName,
                GlobalJobId,
                GlobalJobId
                );
        if ( status == NERR_Success) {
            break;
        }
        MessagePrint( status );
        break;

    case ACTION_USAGE:
        Usage( TRUE);
        status = NERR_Success;
        break;
    }

    TermList( GlobalListTable);
    TermList( DaysOfWeekSearchList);
    LocalFree( GlobalTimeFormat.AMString );
    LocalFree( GlobalTimeFormat.PMString );
    LocalFree( GlobalTimeFormat.DateFormat );
    LocalFree( GlobalTimeFormat.TimeSeparator );
    exit( status == NERR_Success ? ERROR_SUCCESS : AT_GENERIC_ERROR);
}



BOOL
AreYouSure(
    VOID
    )
/*++

Routine Description:

    Make sure user really wants to delete all jobs.

Arguments:

    None.

Return Value:

    TRUE    if user really wants to go ahead.
    FALSE   otherwise.

--*/
{
    register int            retries = 0;
    WCHAR                   rbuf[ 16];
    WCHAR *                 smallBuffer = NULL;
    DWORD                   Value;
    int             cch;
    int             retc;

    if ( GlobalYes == TRUE) {
        return( TRUE);
    }

    if ( MessagePrint( APE2_AT_DEL_WARNING ) == 0) {
        exit( AT_GENERIC_ERROR);
    }

    for ( ; ;) {

        if ( MessageGet(
                    APE2_GEN_DEFAULT_NO,            //  MessageId
                    &smallBuffer,                   //  lpBuffer
                    0
                    ) == 0) {
            exit( AT_GENERIC_ERROR);
        }

        if ( MessagePrint( APE_OkToProceed, smallBuffer) == 0) {
            exit( AT_GENERIC_ERROR);
        }

        LocalFree( smallBuffer );

        if (FileIsConsole(STD_INPUT_HANDLE)) {
            retc = ReadConsole(GetStdHandle(STD_INPUT_HANDLE),rbuf,16,&cch,0);
            if (retc) {
                //
                // Get rid of cr/lf
                //
                if (wcschr(rbuf, TEXT('\r')) == NULL) {
                    if (wcschr(rbuf, TEXT('\n')))
                    *wcschr(rbuf, TEXT('\n')) = NULLC;
                }
                else
                    *wcschr(rbuf, TEXT('\r')) = NULLC;
            }
        }
        else {
            CHAR oemBuf[ 16 ];

            retc = (int)gets(oemBuf);
#if DBG
            fprintf(stderr, "got >%s<\n", oemBuf);
#endif
            cch = 0;
            if (retc || strlen(oemBuf)+1 > 16)
            cch = MultiByteToWideChar(CP_OEMCP, MB_PRECOMPOSED,
                        oemBuf, strlen(oemBuf)+1, rbuf, 16);
        }

#if DBG
        fprintf(stderr, "cch = %d, retc = %d\n", cch, retc);
#endif
        if (!retc || cch == 0)
            return( FALSE);
#if DBG
        fprintf(stderr, "converted to >%ws<\n", rbuf);
#endif

        Value = MatchString(_wcsupr(rbuf), AT_CONFIRM_NO_VALUE | AT_CONFIRM_YES_VALUE);

        if ( Value == AT_CONFIRM_NO_VALUE) {
            return( FALSE);
        } else if ( Value == AT_CONFIRM_YES_VALUE) {
            break;
        }

        if ( ++retries >= 3) {
            MessagePrint( APE_NoGoodResponse );
            return( FALSE);
        }

        if ( MessagePrint( APE_UtilInvalidResponse ) == 0) {
            exit( AT_GENERIC_ERROR);
        }
    }
    return( TRUE);
}



BOOL
ArgIsServerName(
    WCHAR *     string
    )
/*++

Routine Description:

    Checks if string is a server name.  Validation is really primitive, eg
    strings like "\\\threeslashes" pass the test.

Arguments:

    string  -   pointer to string that may represent a server name

Return Value:

    TRUE    -   string is (or might be) a valid server name
    FALSE   -   string is not a valid server name

--*/
{

    NET_API_STATUS ApiStatus;

    if (string[0] == BACKSLASH && string[1] == BACKSLASH && string[2] != 0) {
        ApiStatus = NetpNameValidate(
                NULL,               // no server name.
                &string[2],         // name to validate
                NAMETYPE_COMPUTER,
                LM2X_COMPATIBLE);       // flags
        if (ApiStatus != NO_ERROR) {
            return (FALSE);
        }
        GlobalServerName = string;
        return( TRUE);
    }

    return( FALSE); // GlobalServerName is NULL at load time
}



BOOL
ArgIsTime(
    IN      WCHAR *     timestr,
    OUT     PDWORD      pJobTime
    )
/*++

Routine Description:

    Determines whether string is a time or not.  Validates that string
    passed into it is in the form of HH:MM.  It searches the string for
    a ":" and then validates that the preceeding data is numeric & in a
    valid range for hours.  It then validates the string after the ":"
    is numeric & in a validate range for minutes.  If all the tests are
    passed the TRUE is returned.

Arguments:

    timestr     -   string to check whether it is a time
    JobTime     -   ptr to number of miliseconds

Return Value:

    TRUE        -   timestr was a time in HH:MM format
    FALSE       -   timestr wasn't at time

--*/
{
    CHAR        buffer[MAX_TIME_SIZE];
    USHORT      ParseLen;
    BOOL        fDummy;

    if ( timestr == NULL )
        return FALSE;

    if (  !WideCharToMultiByte( CP_ACP,
                                0,
                                timestr,
                                -1,
                                buffer,
                                sizeof( buffer )/sizeof(CHAR),
                                NULL,
                                &fDummy ))
    {
        return FALSE;
    }

    if ( LUI_ParseTimeSinceStartOfDay( buffer, pJobTime, &ParseLen, 0) )
        return FALSE;

    // LUI_ParseTimeSinceStartOfDay returns the time in seconds.
    // Hence, we need to convert it to microseconds.
    *pJobTime *= 1000;

    return( TRUE);
}



BOOL
ArgIsDecimalString(
    IN  WCHAR *     pDecimalString,
    OUT PDWORD      pNumber
    )
/*++

Routine Description:

    This routine converts a string into a DWORD if it possibly can.
    The conversion is successful if string is decimal numeric and
    does not lead to an overflow.

Arguments:

    pDecimalString      ptr to decimal string
    pNumber             ptr to number

Return Value:

    FALSE       invalid number
    TRUE        valid number

--*/
{
    DWORD           Value;
    DWORD           OldValue;
    DWORD           digit;

    if ( pDecimalString == NULL  ||  *pDecimalString == 0) {
        return( FALSE);
    }

    Value = 0;

    while ( (digit = *pDecimalString++) != 0) {

        if ( digit < L'0' || digit > L'9') {
            return( FALSE);     //  not a decimal string
        }

        OldValue = Value;
        Value = digit - L'0' + 10 * Value;
        if ( Value < OldValue) {
            return( FALSE);     //  overflow
        }
    }

    *pNumber = Value;
    return( TRUE);
}



BOOL
IsDayOfMonth(
    IN      WCHAR *     pToken,
    OUT     PDWORD      pDay
    )
/*++

Routine Description:

    Converts a string into a number for the day of the month, if it can
    possibly do so.  Note that "first" == 1, ...

Arguments:

    pToken      pointer to schedule token for the day of the month
    pDay        pointer to index of day in a month

Return Value:

    TRUE        if a valid schedule token
    FALSE       otherwise

--*/
{
    return ( ArgIsDecimalString( pToken, pDay) == TRUE  &&  *pDay >= 1
                &&  *pDay <= 31);
}



BOOL
IsDayOfWeek(
    WCHAR *     pToken,
    PDWORD      pDay
    )
/*++

Routine Description:

    This routine converts a string day of the week into a integer
    offset into the week if it possibly can.  Note that Monday==0,
    ..., Sunday == 6.

Arguments:

    pToken      pointer to schedule token for the day of a week
    pDay        pointer to index of day in a month

Return Value:

    TRUE        if a valid schedule token
    FALSE       otherwise

--*/
{
    if ( !InitList( DaysOfWeekSearchList ) )
    {
        // Error already reported
        exit( -1 );
    }

    return( TraverseSearchList(
                pToken,
                DaysOfWeekSearchList,
                pDay
                ));
}



NET_API_STATUS
JobAdd(
    VOID
    )
/*++

Routine Description:

    Adds a new item to schedule.

Arguments:

    None.  Uses globals.

Return Value:

    NET_API_STATUS return value of remote api call

--*/
{
    NET_API_STATUS          status;

    for ( ; ; ) {
        status = NetScheduleJobAdd(
                GlobalServerName,
                (LPBYTE)&GlobalAtInfo,
                &GlobalJobId
                );
        if ( status == ERROR_INVALID_PARAMETER  &&
                GlobalAtInfo.Flags & JOB_NONINTERACTIVE) {
            //
            //  We may have failed because we are talking to a down level
            //  server that does not know about JOB_NONINTERACTIVE bit.
            //  Clear the bit, and try again.
            //  A better approach would be to check the version of the
            //  server before making NetScheduleJobAdd() call, adjust the
            //  bit appropriately and only then call NetScheduleJobAdd().
            //
            GlobalAtInfo.Flags &= ~JOB_NONINTERACTIVE;
        } else {
            break;
        }

    }
    if ( status == NERR_Success) {
        MessagePrint( IDS_ADD_NEW_JOB, GlobalJobId );
    } else {
        if ( MessagePrint( status ) == 0) {
            exit( AT_GENERIC_ERROR);
        }
    }

    return( status);
}



NET_API_STATUS
JobEnum(
    VOID
    )
/*++

Routine Description:

    This does all of the processing necessary to dump out the entire
    schedule file.  It loops through on each record and formats its
    information for printing and then goes to the next.

Arguments:

    None.  Uses globals.

Return Value:

    ERROR_SUCCESS                       if everything enumerated OK
    error returned by remote api        otherwise

--*/
{
    BOOL            first = TRUE;
    DWORD           ResumeJobId = 0;
    NET_API_STATUS  status = NERR_Success;
    PAT_ENUM        pAtEnum;
    DWORD           EntriesRead;
    DWORD           TotalEntries;
    LPVOID          EnumBuffer;
    DWORD           length;
    WCHAR *         smallBuffer = NULL;

    for ( ; ;) {

        status = NetScheduleJobEnum(
                GlobalServerName,
                (LPBYTE *)&EnumBuffer,
                (DWORD)-1,
                &EntriesRead,
                &TotalEntries,
                &ResumeJobId
                );

        if ( status != ERROR_SUCCESS  &&  status != ERROR_MORE_DATA) {
            length = MessagePrint( status );
            if ( length == 0) {
                exit( AT_GENERIC_ERROR);
            }
            return( status);
        }

        ASSERT( status == ERROR_SUCCESS ? TotalEntries == EntriesRead
                    : TotalEntries > EntriesRead);

        if ( TotalEntries == 0) {
            break;  //  no items found
        }

        if ( first == TRUE) {
            length = MessagePrint( APE2_AT_DUMP_HEADER );
            if ( length == 0) {
                exit( AT_GENERIC_ERROR);
            }
            PrintLine();    //  line across screen
            first = FALSE;
        }

        for ( pAtEnum = EnumBuffer;  EntriesRead-- > 0;  pAtEnum++) {
            if ( pAtEnum->Flags & JOB_EXEC_ERROR) {
                if ( MessageGet( APE2_GEN_ERROR, &smallBuffer, 0 ) == 0) {
                    // error reported already
                    exit( AT_GENERIC_ERROR);
                }
                GenOutputArg( DUMP_FMT1, smallBuffer );
                LocalFree( smallBuffer );
            } else {
                GenOutputArg( DUMP_FMT1, L"");
            }
            GenOutputArg( DUMP_FMT2, pAtEnum->JobId);
            PrintDay( DUMP_ALL, pAtEnum->DaysOfMonth, pAtEnum->DaysOfWeek,
                            pAtEnum->Flags);
            PrintTime( pAtEnum->JobTime);
            GenOutputArg( TEXT("%ws\n"), pAtEnum->Command);
        }

        if ( EnumBuffer != NULL) {
            (VOID)NetApiBufferFree( (LPVOID)EnumBuffer);
            EnumBuffer = NULL;
        }

        if ( status == ERROR_SUCCESS) {
            break;  //  we have read & displayed all the items
        }
    }

    if ( first == TRUE) {
        MessagePrint( APE_EmptyList );
    }

    return( ERROR_SUCCESS);
}



NET_API_STATUS
JobGetInfo(
    VOID
    )
/*++

Routine Description:

    This prints out the schedule of an individual items schedule.

Arguments:

    None.  Uses globals.

Return Value:

    NET_API_STATUS value returned by remote api

--*/

{
    PAT_INFO                pAtInfo = NULL;
    NET_API_STATUS          status;

    status = NetScheduleJobGetInfo(
            GlobalServerName,
            GlobalJobId,
            (LPBYTE *)&pAtInfo
            );
    if ( status != NERR_Success) {
        MessagePrint( status );
        return( status);
    }

    PutNewLine();
    MessagePrint( APE2_AT_DI_TASK );
    GenOutputArg( TEXT("%d"), GlobalJobId);
    PutNewLine();

    MessagePrint( APE2_AT_DI_STATUS );
    MessagePrint( (pAtInfo->Flags & JOB_EXEC_ERROR) != 0 ?
                  APE2_GEN_ERROR : APE2_GEN_OK );
    PutNewLine();

    MessagePrint( APE2_AT_DI_SCHEDULE );
    PrintDay( DUMP_ID, pAtInfo->DaysOfMonth, pAtInfo->DaysOfWeek,
                    pAtInfo->Flags);
    PutNewLine();

    MessagePrint( APE2_AT_DI_TIMEOFDAY );
    PrintTime( pAtInfo->JobTime);
    PutNewLine();

    MessagePrint( APE2_AT_DI_INTERACTIVE);
    MessagePrint( (pAtInfo->Flags & JOB_NONINTERACTIVE) == 0 ?
                  APE2_GEN_YES : APE2_GEN_NO );
    PutNewLine();

    MessagePrint( APE2_AT_DI_COMMAND );
    GenOutputArg( TEXT("%ws\n"), pAtInfo->Command);
    PutNewLine2();

    (VOID)NetApiBufferFree( (LPVOID)pAtInfo);

    return( NERR_Success);
}



DWORD
MatchString(
    WCHAR *     name,
    DWORD       Values
    )
/*++
Routine Description:

    Parses switch string and returns NULL for an invalid switch,
    and -1 for an ambiguous switch.

Arguments:

    name    -   pointer to string we need to examine
    Values  -   bitmask of values of interest

Return Value:

    Pointer to command, or NULL or -1.
--*/
{
    WCHAR *         String;
    PSEARCH_LIST    pCurrentList;
    WCHAR *         CurrentString;
    DWORD           FoundValue;
    int             nmatches;
    int             longest;

    if ( !InitList( GlobalListTable ) )
    {
        // Error already reported
        exit( -1 );
    }

    for ( pCurrentList = GlobalListTable,
          longest = nmatches = 0,
          FoundValue = 0;
                (CurrentString = pCurrentList->String) != NULL;
                        pCurrentList++) {

        if ( (Values & pCurrentList->Value) == 0) {
            continue; // skip this List
        }

        for ( String = name; *String == *CurrentString++; String++) {
            if ( *String == 0) {
                return( pCurrentList->Value); // exact match
            }
        }

        if ( !*String) {

            if ( String - name > longest) {

                longest = String - name;
                nmatches = 1;
                FoundValue = pCurrentList->Value;

            } else if ( String - name == longest) {

                nmatches++;
            }
        }
    }

    //  0 corresponds to no match at all (invalid List)
    //  while -1 corresponds to multiple match (ambiguous List).

    if ( nmatches != 1) {
        return ( (nmatches == 0) ? 0 : -1);
    }

    return( FoundValue);
}


DWORD
MessageGet(
    IN      DWORD        MessageId,
    OUT     LPWSTR      *buffer,
    IN      DWORD        Size
    )
/*++

Routine Description:

    Fills in the unicode message corresponding to a given message id,
    provided that a message can be found and that it fits in a supplied
    buffer.

Arguments:

    MessageId   -   message id
    buffer      -   pointer to caller supplied buffer
    Size        -   size (always in bytes) of supplied buffer,
                    If size is 0, buffer will be allocated by FormatMessage.

Return Value:

    Count of characters, not counting the terminating null character,
    returned in the buffer.  Zero return value indicates failure.

--*/
{
    DWORD               length;
    LPVOID              lpSource;
    DWORD               dwFlags;

    if ( MessageId < NERR_BASE) {
        //
        //  Get message from system.
        //
        lpSource = NULL; // redundant step according to FormatMessage() spec
        dwFlags = FORMAT_MESSAGE_FROM_SYSTEM;

    } else if (  ( MessageId >= APE2_AT_DEL_WARNING
                    &&  MessageId <= APE2_AT_DI_INTERACTIVE)
              || ( MessageId >= IDS_LOAD_LIBRARY_FAILURE
                    &&  MessageId <= IDS_INTERACTIVE )) {
        //
        //  Get message from this module.
        //
        lpSource = NULL;
        dwFlags = FORMAT_MESSAGE_FROM_HMODULE;

    } else {
        //
        //  Get message from netmsg.dll.
        //
        lpSource = GlobalMessageHandle;
        dwFlags = FORMAT_MESSAGE_FROM_HMODULE;
    }

    if ( Size == 0 )
        dwFlags |= FORMAT_MESSAGE_ALLOCATE_BUFFER;

    length = FormatMessage(
            dwFlags,                        //  dwFlags
            lpSource,                       //  lpSource
            MessageId,                      //  MessageId
            0,                              //  dwLanguageId
            (LPWSTR) buffer,                //  lpBuffer
            Size,                           //  nSize
            NULL                            //  lpArguments
            );

    if ( length == 0) {
        MessagePrint( IDS_MESSAGE_GET_ERROR, MessageId, GetLastError());
    }
    return( length);

} // MessageGet()



int
FileIsConsole(
    int     fh
    )
{
    unsigned htype ;

    htype = GetFileType(GetStdHandle(fh));
    htype &= ~FILE_TYPE_REMOTE;
    return htype == FILE_TYPE_CHAR;
}



DWORD
ConsolePrint(
    LPWSTR  pch,
    int     cch
    )
{
    int     cchOut=0;
    int     err;
    CHAR    *pchOemBuffer;

    if (FileIsConsole(STD_OUTPUT_HANDLE)) {
    err = WriteConsole(
            GetStdHandle(STD_OUTPUT_HANDLE),
            pch, cch,
            &cchOut, NULL);
    if (!err || cchOut != cch)
        goto try_again;
    }
    else if ( cch != 0) {
try_again:
    cchOut = WideCharToMultiByte(CP_OEMCP, 0, pch, cch, NULL, 0, NULL,NULL);
    if (cchOut == 0)
        return 0;

    if ((pchOemBuffer = (CHAR *)malloc(cchOut)) != NULL) {
        WideCharToMultiByte(CP_OEMCP, 0, pch, cch,
            pchOemBuffer, cchOut, NULL, NULL);
        WriteFile(GetStdHandle(STD_OUTPUT_HANDLE),
            pchOemBuffer, cchOut, &cch, NULL);
        free(pchOemBuffer);
    }
    }
    return cchOut;
}



DWORD
MessagePrint(
    IN      DWORD       MessageId,
    ...
    )
/*++

Routine Description:

    Finds the unicode message corresponding to the supplied message id,
    merges it with caller supplied string(s), and prints the resulting
    string.

Arguments:

    MessageId       -   message id

Return Value:

    Count of characters, not counting the terminating null character,
    printed by this routine.  Zero return value indicates failure.

--*/
{
    va_list             arglist;
    WCHAR *             buffer = NULL;
    DWORD               length;
    LPVOID              lpSource;
    DWORD               dwFlags = FORMAT_MESSAGE_ALLOCATE_BUFFER;


    va_start( arglist, MessageId );

    if ( MessageId < NERR_BASE) {
        //
        //  Get message from system.
        //
        lpSource = NULL; // redundant step according to FormatMessage() spec
        dwFlags |= FORMAT_MESSAGE_FROM_SYSTEM;

    } else if (  ( MessageId >= APE2_AT_DEL_WARNING
                    &&  MessageId <= APE2_AT_DI_INTERACTIVE)
              || ( MessageId >= IDS_LOAD_LIBRARY_FAILURE
                    &&  MessageId <= IDS_INTERACTIVE )) {
        //
        //  Get message from this module.
        //
        lpSource = NULL;
        dwFlags |= FORMAT_MESSAGE_FROM_HMODULE;

    } else {
        //
        //  Get message from netmsg.dll.
        //
        lpSource = GlobalMessageHandle;
        dwFlags |= FORMAT_MESSAGE_FROM_HMODULE;
    }

    length = FormatMessage(
            dwFlags,                                          //  dwFlags
            lpSource,                                         //  lpSource
            MessageId,                                        //  MessageId
            0L,                                               //  dwLanguageId
            (LPTSTR)&buffer,                                  //  lpBuffer
            0,                                                //  size
            &arglist                                          //  lpArguments
            );

    length = ConsolePrint(buffer, length);

    LocalFree(buffer);

    return( length);

} // MessagePrint()



BOOL
ParseJobIdArgs(
    WCHAR   **  argv,
    int         argc,
    int         argno,
    PBOOL       pDeleteFound
    )
/*++

Routine Description:

    Parses arguments for commands containing JobId (these can be JobGetInfo
    and JobDel commands).  It loops through JobId arguments making sure that
    we have at most one "yes-no" switch and at most one "delete" switch and
    nothing else.

Arguments:

    argv            argument list
    argc            number of arguments to parse
    argno           index of argument to begin parsing from
    pDeleteFound    did we find a delete switch or not

Return Value:

    FALSE          invalid argument found
    TRUE           valid arguments

--*/
{
    BOOL        FoundDeleteSwitch;

    for (  FoundDeleteSwitch = FALSE;  argno < argc;  argno++) {

        WCHAR *     argp;
        DWORD       length;
        DWORD       Value;

        argp = argv[ argno];

        if ( *argp++ != SLASH) {
            return( FALSE);     //  not a switch
        }

        _wcsupr( argp);
        length = wcslen( argp);

        Value = MatchString( argp, AT_YES_VALUE | AT_DELETE_VALUE);

        if ( Value == AT_YES_VALUE) {

            if ( GlobalYes == TRUE) {
                return( FALSE);        // multiple instances of yes switch
            }

            GlobalYes = TRUE;
            continue;
        }

        if ( Value == AT_DELETE_VALUE) {

            if ( FoundDeleteSwitch == TRUE) {
                return( FALSE);     //  duplicate delete switch
            }
            FoundDeleteSwitch = TRUE;
            continue;
        }

        return( FALSE);     // an unknown switch
    }

    *pDeleteFound = FoundDeleteSwitch;
    return( TRUE);
} // ParseJobIdArgs()



BOOL
ParseTimeArgs(
    WCHAR **    argv,
    int         argc,
    int         argno,
    int *       pargno
    )
/*++

Routine Description:

    Parses arguments for command addition.

Arguments:

    argv    argument list
    argc    count of args
    argno   index of the first arg to validate
    pargno  ptr to the index of the first non-switch arg

Return Value:

    TRUE            all arguments are valid
    FALSE           otherwise

--*/
{
    DWORD       day_no;             //  day number for scheduling
    DWORD       NextCount = 0;      //  count of next switches
    DWORD       EveryCount = 0;     //  count of every switches
    WCHAR *     argp;               //  ptr to arg string
    WCHAR *     schedp;             //  work ptr to arg string
    DWORD       Value;              //  bitmask

    for (  NOTHING;  argno < argc;  argno++) {

        argp = argv[ argno];

        if ( *argp++ != SLASH) {
            break; // found non-switch, we are done
        }


        schedp = wcschr( argp, ARG_SEP_CHR);

        if ( schedp == NULL) {
            return( FALSE);
        }

        _wcsupr( argp); // upper case entire input, not just the switch name

        *schedp = 0;

        Value = MatchString( argp, AT_NEXT_VALUE | AT_EVERY_VALUE);

        if ( Value == AT_NEXT_VALUE) {

            NextCount++;

        } else if ( Value == AT_EVERY_VALUE) {

            EveryCount++;
            GlobalAtInfo.Flags |= JOB_RUN_PERIODICALLY;

        } else {

            return( FALSE); // an unexpected switch
        }

        if ( NextCount + EveryCount > 1) {
            return( FALSE); // repeated switch option
        }

        *schedp++ = ARG_SEP_CHR;

        schedp = wcstok( schedp, SCHED_TOK_DELIM);

        if ( schedp == NULL) {
            GlobalAtInfo.Flags |= JOB_ADD_CURRENT_DATE;
            continue;
        }

        while( schedp != NULL) {

            if ( IsDayOfMonth( schedp, &day_no) == TRUE) {

                GlobalAtInfo.DaysOfMonth |= (1 << (day_no - 1));

            } else if ( IsDayOfWeek( schedp, &day_no) == TRUE) {

                GlobalAtInfo.DaysOfWeek |= (1 << day_no);

            } else {
                MessagePrint( APE_InvalidSwitchArg );
                GlobalErrorReported = TRUE;
                return( FALSE);
            }

            schedp = wcstok( NULL, SCHED_TOK_DELIM);
        }
    }

    if ( argno == argc) {
        return( FALSE); // all switches, no command
    }

    *pargno = argno;
    return( TRUE);
}



BOOL
ParseInteractiveArg(
    IN  OUT     WCHAR *     argp
    )
/*++

Routine Description:

    Returns TRUE if argp is an interactive switch.

--*/
{
    DWORD       Value;              //  bitmask

    if ( *argp++ != SLASH) {
        return( FALSE);     // not a switch
    }

    _wcsupr( argp); // all AT command switches can be safely uppercased

    Value = MatchString( argp, AT_INTERACTIVE);

    if ( Value == AT_INTERACTIVE) {
        GlobalAtInfo.Flags &= ~JOB_NONINTERACTIVE;  // clear noninteractive flag
        return( TRUE);
    }

    return( FALSE); // some other switch
}



VOID
PrintDay(
    int         type,
    DWORD       DaysOfMonth,
    UCHAR       DaysOfWeek,
    UCHAR       Flags
    )
/*++

Routine Description:

    Print out schedule days.  This routine converts a schedule bit map
    to the literals that  represent the schedule.

Arguments:

    type            whether this is for JobEnum or not
    DaysOfMonth     bitmask for days of month
    DaysOfWeek      bitmaks for days of week
    Flags           extra info about the job

Return Value:

    None.

--*/
{
    int             i;
    WCHAR           Buffer[ 128];
    DWORD           BufferLength;
    DWORD           Length;
    DWORD           TotalLength = 0;
    DWORD           TotalColumnLength = 0;
    WCHAR *         LastSpace;
    DWORD           MessageId;
    BOOL            OverFlow = TRUE;
    static int      Ape2GenWeekdayLong[] = {
        APE2_GEN_MONDAY,
        APE2_GEN_TUESDAY,
        APE2_GEN_WEDNSDAY,
        APE2_GEN_THURSDAY,
        APE2_GEN_FRIDAY,
        APE2_GEN_SATURDAY,
        APE2_GEN_SUNDAY
    };
    static int      Ape2GenWeekdayAbbrev[] = {
        APE2_GEN_MONDAY_ABBREV,
        APE2_GEN_TUESDAY_ABBREV,
        APE2_GEN_WEDNSDAY_ABBREV,
        APE2_GEN_THURSDAY_ABBREV,
        APE2_GEN_FRIDAY_ABBREV,
        APE2_GEN_SATURDAY_ABBREV,
        APE2_GEN_SUNDAY_ABBREV
    };

    //
    //  Subtract 4 to guard against days of week or days of month overflow.
    //
    BufferLength = sizeof( Buffer)/ sizeof( WCHAR) - 4;
    if ( type == DUMP_ALL  &&  BufferLength > MAX_SCHED_FIELD_LENGTH) {
        BufferLength = MAX_SCHED_FIELD_LENGTH;
    }

    //
    //  First do the descriptive bit (eg. EACH, NEXT, etc) with the days.
    //

    if ( Flags & JOB_RUN_PERIODICALLY) {

        MessageId = APE2_AT_EACH;

    } else if ( (DaysOfWeek != 0) || (DaysOfMonth != 0)) {

        MessageId = APE2_AT_NEXT;

    } else if ( Flags & JOB_RUNS_TODAY) {

        MessageId = APE2_AT_TODAY;

    } else {

        MessageId = APE2_AT_TOMORROW;
    }

    Length = MessageGet(
            MessageId,
            (LPWSTR *) &Buffer[TotalLength],
            BufferLength
            );
    if ( Length == 0) {
        goto PrintDay_exit; // Assume this is due to lack of space
    }
    TotalColumnLength = GetStringColumn( &Buffer[TotalLength] );
    TotalLength = Length;

    if ( DaysOfWeek != 0) {

        for ( i = 0; i < 7; i++) {

            if ( ( DaysOfWeek & (1 << i)) != 0) {

                if( bDBCS ) {
                    Length = MessageGet(
                                Ape2GenWeekdayLong[ i],
                                (LPWSTR *) &Buffer[TotalLength],
                                BufferLength - TotalLength
                                );
                } else {
                    Length = MessageGet(
                                Ape2GenWeekdayAbbrev[ i],
                                (LPWSTR *) &Buffer[TotalLength],
                                BufferLength - TotalLength
                                );
                }
                if ( Length == 0) {
                    //
                    //  Not enough room for WeekDay symbol
                    //
                    goto PrintDay_exit;

                }
                //
                // Get how many columns will be needed for display.
                //
                TotalColumnLength += GetStringColumn( &Buffer[TotalLength] );

                if ( TotalColumnLength >= BufferLength) {
                    //
                    //  Not enough room for space following WeekDay symbol
                    //
                    goto PrintDay_exit;
                }
                TotalLength +=Length;
                Buffer[ TotalLength++] = BLANK;
                TotalColumnLength++;
            }
        }
    }

    if ( DaysOfMonth != 0) {

        for ( i = 0; i < 31; i++) {

            if ( ( DaysOfMonth & (1L << i)) != 0) {

                Length = swprintf(
                        &Buffer[ TotalLength],
                        L"%d ",
                        i + 1
                        );
                if ( TotalLength + Length > BufferLength) {
                    //
                    //  Not enough room for MonthDay symbol followed by space
                    //
                    goto PrintDay_exit;
                }
                TotalLength +=Length;
                TotalColumnLength +=Length;
            }
        }
    }

    OverFlow = FALSE;

PrintDay_exit:

    Buffer[ TotalLength] = NULLC;

    if ( OverFlow == TRUE) {

        if ( TotalLength > 0  &&  Buffer[ TotalLength - 1] == BLANK) {
            //
            //  Eliminate trailing space if there is one.
            //
            Buffer[ TotalLength - 1] = NULLC;
        }

        //
        //  Then get rid of the rightmost token (or even whole thing).
        //

        LastSpace = wcsrchr( Buffer, BLANK);

        wcscpy( LastSpace != NULL ? LastSpace : Buffer, ELLIPSIS);

        TotalLength = wcslen( Buffer);

    }

    if ( type == DUMP_ALL) {
        while( TotalColumnLength++ < MAX_SCHED_FIELD_LENGTH) {
            Buffer[ TotalLength++] = BLANK;
        }
        Buffer[ TotalLength] = UNICODE_NULL;
    }

    GenOutputArg( TEXT("%ws"), Buffer);
}


VOID
PrintLine(
    VOID
    )
/*++

Routine Description:

    Prints a line accross screen.

Arguments:

    None.

Return Value:

    None.

Note:

    BUGBUG  Is this treatment valid for UniCode?  See also LUI_PrintLine()
    BUGBUG  in ui\common\src\lui\lui\border.c

--*/
#define SINGLE_HORIZONTAL       L'\x02d'
#define SCREEN_WIDTH            79
{
    WCHAR       string[ SCREEN_WIDTH + 1];
    DWORD       offset;


    for (  offset = 0;  offset < SCREEN_WIDTH;  offset++) {
        string[ offset] = SINGLE_HORIZONTAL;
    }

    string[ SCREEN_WIDTH] = NULLC;
    GenOutputArg(TEXT("%ws\n"), string);
}


VOID
PrintTime(
    DWORD       JobTime
    )
/*++

Routine Description:

    Prints time of a job in HH:MM{A,P}M format.

Arguments:

    JobTime     -   time in miliseconds (measured from midnight)

Return Value:

    None.

Note:

    BUGBUG      this does not make sure that JobTime is within the bounds.
    BUGBUG      Also, there is nothing unicode about printing this output.

--*/
{
    WCHAR       Buffer[15];

    GetTimeString( JobTime, Buffer, sizeof( Buffer)/sizeof( WCHAR) );
    GenOutputArg( DUMP_FMT3, Buffer );
}



BOOL
TraverseSearchList(
    IN      PWCHAR          String,
    IN      PSEARCH_LIST    SearchList,
    OUT     PDWORD          pValue
    )
/*++

Routine Description:

    Examines search list until it find the correct entry, then returns
    the value corresponding to this entry.

Arguments:

    String          -   string to match
    SearchList      -   array of entries containing valid strings
    pValue          -   value corresponding to a matching valid string

Return Value:

    TRUE        a matching entry was found
    FALSE       otherwise

--*/
{
    if ( SearchList != NULL) {

        for ( NOTHING;  SearchList->String != NULL;  SearchList++) {

            if ( _wcsicmp( String, SearchList->String) == 0) {
                *pValue = SearchList->Value;
                return( TRUE) ;
            }
        }
    }
    return( FALSE) ;
}



VOID
Usage(
    BOOL    GoodCommand
    )
/*++

Routine Description:

    Usage of AT command.

Arguments:

    GoodCommand -   TRUE if we have a good command input (request for help)
                    FALSE if we have a bad command input

Return Value:

    None.

--*/
{
    if ( GlobalErrorReported == TRUE) {
        PutNewLine();
    } else if ( GoodCommand == FALSE) {
        MessagePrint( IDS_INVALID_COMMAND );
    }

    MessagePrint( IDS_USAGE );
}

#define REG_SCHEDULE_PARMS TEXT("System\\CurrentControlSet\\Services\\Schedule\\Parameters")

#define REG_SCHEDULE_USE_OLD TEXT("UseOldParsing")

BOOL
UseOldParsing()
/*++

Routine Description:

    Checks the registry for

    HKLM\CurrentControlSet\Services\Schedule\parameters\UseOldParsing

    If present and equal to 1, then revert to 3.51 level of command line
    parsing.  Spaces in filenames will not work with this option.  This is
    intended as a migration path for customers who cannot change all their
    command scripts that use AT.EXE right away. 

--*/
{
    BOOL fUseOld = FALSE;
    LONG err = 0;

    do { // Error breakout loop

        HKEY hkeyScheduleParms;
        DWORD dwType;
        DWORD dwData = 0;
        DWORD cbData = sizeof(dwData);

        // Break out on any error and use the default, FALSE.

        if (err = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                               REG_SCHEDULE_PARMS,
                               0,
                               KEY_READ,
                               &hkeyScheduleParms))
        {
            break;
        }
        if (err = RegQueryValueEx(hkeyScheduleParms,
                                  REG_SCHEDULE_USE_OLD,
                                  NULL,
                                  &dwType,
                                  (LPBYTE)&dwData,
                                  &cbData ))
        {
            RegCloseKey( hkeyScheduleParms );
            break;
        }

        if ( dwType == REG_DWORD && dwData == 1 )
        {
            fUseOld = TRUE;
        }

        RegCloseKey( hkeyScheduleParms );
                                

    } while (FALSE) ;

    return fUseOld;
    
}



BOOL
ValidateCommand(
    IN  int         argc,
    IN  WCHAR **    argv,
    OUT int *       pCommand
    )
/*++

Routine Description:

    Examines command line to see what to do.  This validates the command
    line passed into the AT command processor.  If this routine finds any
    invalid data, the program exits with an appropriate error message.

Arguments:

    pCommand    -   pointer to command
    argc        -   count of arguments
    argv        -   pointer to table of arguments

Return Value:

    FALSE    -     if failure, i.e. command will not be executed
    TRUE     -     if success

Comment:

    Parsing assumes:

    non-switch (positional) parameters come first and order among these
        parameters is important

    switch parameters come second and order among these parameters is
        NOT important

    command (if present) comes last

--*/
{
    int     i;                  //  loop index
    int     next;               //  index of Time or JobId argument
    int     argno;              //  where to start in arg string
    BOOL    DeleteFound;        //  did we find a delete switch
    WCHAR * recdatap;           //  ptr used to build atr_command
    DWORD   recdata_len;        //  len of arg to put in atr_command
    DWORD   JobTime;
    WCHAR   wszTmp[MAX_COMMAND_LEN];
    BOOL    fUseOldParsing = FALSE;

    if (argc == 1) {
       *pCommand = DUMP_ALL;
       return( TRUE);
    }

    //  First look for a help switch on the command line.

    for ( i = 1; i < argc; i++ ) {

        if ( !_wcsicmp( argv[i], QUESTION_SW)
                    ||  !_wcsicmp( argv[i], QUESTION_SW_TOO)) {

            *pCommand = ACTION_USAGE;
            return( TRUE);
        }
    }

    next = ( ArgIsServerName( argv[ 1]) == TRUE) ? 2 : 1;
    if ( argc == next) {
       *pCommand = DUMP_ALL;
       return( TRUE);
    }

    if ( (ArgIsDecimalString( argv[ next], &GlobalJobId)) == TRUE) {

        if ( argc == next + 1) {
            *pCommand = DUMP_ID;
            return( TRUE);
        }

        if ( ParseJobIdArgs( argv, argc, next + 1, &DeleteFound) == FALSE) {
            return( FALSE);     // an invalid argument
        }

        *pCommand = (DeleteFound == FALSE) ? DUMP_ID : DEL_ID;
        return( TRUE);
    }

    //
    //  Try some variation of "AT [\\ServerName [/DELETE]"
    //
    if ( ParseJobIdArgs( argv, argc, next, &DeleteFound) == TRUE) {
        *pCommand = (DeleteFound == FALSE) ? DUMP_ALL : DEL_ALL;
        return( TRUE);
    }

    if ( ArgIsTime( argv[ next], &JobTime) == TRUE) {

        *pCommand = ADD_TO_SCHEDULE;

        if ( argc < next + 2) {
            return( FALSE); // need something to do, not just time
        }

        memset( (PBYTE)&GlobalAtInfo, '\0', sizeof(GlobalAtInfo));    // initialize
        GlobalAtInfo.Flags |= JOB_NONINTERACTIVE;   //  the default

        if ( ParseInteractiveArg( argv[ next + 1])) {
            next++;
        }
        if ( argc < next + 2) {
            return( FALSE); // once more with feeling
        }

        if ( ParseTimeArgs( argv, argc, next + 1, &argno) == FALSE) {
            return( FALSE);
        }

        //  Copy argument strings to record.

        recdatap = GlobalAtInfo.Command = GlobalAtInfoCommand;
        recdata_len = 0;
        
        fUseOldParsing = UseOldParsing();

        for ( i = argno; i < argc; i++) {

            DWORD temp;

            //
            // Fix for bug 22068 "AT command does not handle filenames with
            // spaces." The command processor takes a quoted command line arg
            // and puts everything between the quotes into one argv string.
            // The quotes are stripped out. Thus, if any of the string args
            // contain whitespace, then they must be requoted before being
            // concatonated into the command value.
            //
            if (!fUseOldParsing && wcschr(argv[i], L' ') != NULL)
            {
                wcscpy(wszTmp, L"\"");
                wcscat(wszTmp, argv[i]);
                wcscat(wszTmp, L"\"");
            }
            else
            {
                wcscpy(wszTmp, argv[i]);
            }

            temp = wcslen(wszTmp) + 1;

            recdata_len += temp;

            if ( recdata_len > MAX_COMMAND_LEN) {
                MessagePrint( APE_AT_COMMAND_TOO_LONG );
                return( FALSE);
            }

            wcscpy( recdatap, wszTmp);
            recdatap += temp;

            //  To construct lpszCommandLine argument to CreateProcess call
            //  we replace nuls with spaces.

            *(recdatap - 1) = BLANK;

        }

        //  Reset space back to null on last argument in string.

        *(recdatap - 1) = NULLC;
        GlobalAtInfo.JobTime = JobTime;
        return( TRUE);
    }

    return( FALSE);
}


VOID
GetTimeString(
    DWORD  Time,
    WCHAR *Buffer,
    int    BufferLength
    )
/*++

Routine Description:

    This function converts a dword time to an ASCII string.

Arguments:

    Time         - Time difference in dword from start of the day (i.e. 12am
                   midnight ) in milliseconds

    Buffer       - Pointer to the buffer to place the ASCII representation.

    BufferLength - The length of buffer in bytes.

Return Value:

    None.

--*/
#define MINUTES_IN_HOUR       60
#define SECONDS_IN_MINUTE     60
{
    WCHAR szTimeString[MAX_TIME_SIZE];
    WCHAR *p = &szTimeString[1];
    DWORD seconds, minutes, hours;
    int numChars;
    DWORD flags;
    SYSTEMTIME st;

    GetSystemTime(&st);
    *p = NULLC;

    // Check if the time format is initialized. If not, initialize it.
    if ( GlobalTimeFormat.AMString == NULL )
        NetpGetTimeFormat( &GlobalTimeFormat );

    // Convert the time to hours, minutes, seconds
    seconds = (Time/1000);
    hours   = seconds / (MINUTES_IN_HOUR * SECONDS_IN_MINUTE );
    seconds -= hours * MINUTES_IN_HOUR * SECONDS_IN_MINUTE;
    minutes = seconds / SECONDS_IN_MINUTE;
    seconds -= minutes * SECONDS_IN_MINUTE;

    st.wHour   = (WORD)(hours);
    st.wMinute = (WORD)(minutes);
    st.wSecond = (WORD)(seconds);
    st.wMilliseconds = 0;

    flags = TIME_NOSECONDS;
    if (!GlobalTimeFormat.TwelveHour)
    flags |= TIME_FORCE24HOURFORMAT;

    numChars = GetTimeFormatW(GetThreadLocale(),
        flags, &st, NULL, p, MAX_TIME_SIZE-1);

    if ( numChars > BufferLength )
        numChars = BufferLength;

    if (*(p+1) == ARG_SEP_CHR && GlobalTimeFormat.LeadingZero) {
    *(--p) = TEXT('0');
    numChars++;
    }
    wcsncpy( Buffer, p, numChars );
    // Append spece for align print format. column based.
    {
        DWORD ColumnLength;

        // character counts -> array index.
        numChars--;

        ColumnLength = GetStringColumn( Buffer );

        while( ColumnLength++ < MAX_TIME_FIELD_LENGTH) {
            Buffer[ numChars++] = BLANK;
        }
        Buffer[ numChars] = UNICODE_NULL;
    }
}


BOOL
InitList( PSEARCH_LIST SearchList )
{
    if ( SearchList != NULL) {

        if ( SearchList->String != NULL ) // Already initialized
            return TRUE;

        for ( NOTHING;  SearchList->MessageId != 0;  SearchList++) {
             if ( MessageGet( SearchList->MessageId,
                              &SearchList->String,
                              0 ) == 0 )
             {
                 return FALSE;
             }
        }
    }

    return TRUE;
}


VOID
TermList( PSEARCH_LIST SearchList )
{
    if ( SearchList != NULL) {

        if ( SearchList->String == NULL ) // Not initialized
            return;

        for ( NOTHING;  SearchList->String != NULL;  SearchList++) {
             LocalFree( SearchList->String );
        }
    }
}


DWORD
GetStringColumn( WCHAR *lpwstr )
{
    int cchNeed;

    cchNeed = WideCharToMultiByte( GetConsoleOutputCP() , 0 ,
                                   lpwstr , -1 ,
                                   NULL , 0 ,
                                   NULL , NULL );

    return( (DWORD) cchNeed - 1 ); // - 1 : remove NULL
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\cab\ie4\makefile.inc ===
TARGET_EXE=$(PROJECT_ROOT)\services\sched\cab\ie4\$(O)\sasetup.exe

!if "$(BUILD_DEFAULT_TARGETS)"=="-386"
$(TARGET_EXE): ..\..\service\chicago\$(O)\mstask.exe ..\..\client\chicago\$(O)\mstask.dll ..\..\setup\chicago\$(O)\mstinit.exe ..\..\sage\chicago\dll\$(O)\sage.dll ..\..\sage\chicago\exe\$(O)\sage.exe ..\..\sage\chicago\sysagent\$(O)\sysagent.exe ..\..\service\daytona\$(O)\mstask.exe ..\..\client\daytona\$(O)\mstask.dll ..\..\setup\daytona\$(O)\mstinit.exe ..\..\help\user\mstask.hlp ..\mstask.ini mstask.inf x86.cdf
    copy ..\..\service\chicago\$(O)\mstask.exe $(O)\mstwin.exe
    copy ..\..\client\chicago\$(O)\mstask.dll $(O)\mstwin.dll
    copy ..\..\setup\chicago\$(O)\mstinit.exe $(O)\stswin.exe
    copy ..\..\sage\chicago\dll\$(O)\sage.dll $(O)
    copy ..\..\sage\chicago\exe\$(O)\sage.exe $(O)
    copy ..\..\sage\chicago\sysagent\$(O)\sysagent.exe $(O)
    copy ..\..\service\daytona\$(O)\mstask.exe $(O)\mstnt.exe
    copy ..\..\client\daytona\$(O)\mstask.dll $(O)\mstnt.dll
    copy ..\..\setup\daytona\$(O)\mstinit.exe $(O)\stsnt.exe
    copy ..\..\help\user\mstask.hlp $(O)
    copy ..\..\help\user\mstask.cnt $(O)
    copy ..\mstask.ini $(O)
    copy mstask.inf $(O)
    copy x86.cdf $(O)
    echo SourceFiles0=$(O)\ >> $(O)\x86.cdf
    iexpress /Q /N $(O)\x86.cdf
    copy sasetup.exe $(O)
    copy ~cabpack.cab $(O)\sasetup.cab
    del sasetup.exe
    del ~cabpack.cab
!else
$(TARGET_EXE): ..\..\service\daytona\$(O)\mstask.exe ..\..\client\daytona\$(O)\mstask.dll ..\..\setup\daytona\$(O)\mstinit.exe ..\..\help\user\mstask.hlp ..\mstask.ini mstask.inf risc.cdf
    copy ..\..\service\daytona\$(O)\mstask.exe $(O)\mstnt.exe
    copy ..\..\client\daytona\$(O)\mstask.dll $(O)\mstnt.dll
    copy ..\..\setup\daytona\$(O)\mstinit.exe $(O)\stsnt.exe
    copy ..\..\help\user\mstask.hlp $(O)
    copy ..\..\help\user\mstask.cnt $(O)
    copy ..\mstask.ini $(O)
    copy mstask.inf $(O)
    copy risc.cdf $(O)
    echo SourceFiles0=$(O)\ >> $(O)\risc.cdf
    iexpress /Q /N $(O)\risc.cdf
    copy sasetup.exe $(O)
    copy ~cabpack.cab $(O)\sasetup.cab
    del sasetup.exe
    del ~cabpack.cab
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\cab\ie5\nt\makefile.inc ===
TARGET_CAB=$(PROJECT_ROOT)\services\sched\cab\ie5\nt\$(O)\sasetup.cab

!if "$(PASS0ONLY)"=="1"
$(TARGET_CAB): $(_NTTREE)\mstask.exe $(_NTTREE)\mstask.dll $(_NTTREE)\mstinit.exe ..\..\..\help\user\mstask.hlp ..\..\mstask.ini mstask.inf
    copy $(_NTTREE)\mstask.exe   $(O)
    copy $(_NTTREE)\mstask.dll   $(O)
    copy $(_NTTREE)\mstinit.exe  $(O)
    copy ..\..\..\help\user\mstask.hlp $(O)
    copy ..\..\..\help\user\mstask.chm $(O)
    copy ..\..\mstask.ini        $(O)
    copy mstask.inf              $(O)
    copy *.sed $(O)
    echo SourceFiles0=$(O)\ >> $(O)\ntcab.sed
    echo SourceFiles0=$(O)\ >> $(O)\ntexe.sed
    iexpress /Q /N $(O)\ntcab.sed
    iexpress /Q /N $(O)\ntexe.sed
    move sasetup.exe $(O)
    move sasetup.cab $(O)
    copy $(O)\sasetup.exe $(_NTTREE)
    copy $(O)\sasetup.cab $(_NTTREE)
!else
$(TARGET_CAB):
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\client\jobedit.cxx ===
//+----------------------------------------------------------------------------
//
//  Job Scheduler Service
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       jobedit.cxx
//
//  Contents:   EditJob method.
//
//  Notes:      The job scheduler DLL, schedulr.dll, contains the code for the
//              scheduler UI. The folder and property sheet UI run as Explorer
//              extensions. The job property sheet UI can also be invoked by
//              programatic clients who call ITask::EditJob. This file
//              contains the implementation of EditJob. Since the scheduler
//              service, mstask.exe, does not post any UI, it statically links
//              only with those component libs of schedulr.dll that don't
//              contain any UI code.
//
//  History:    14-Mar-96 EricB created
//
//-----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop

#include "job_cls.hxx"

HRESULT
DisplayJobProperties(
    LPTSTR  pszJob,
    ITask * pITask);


//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::EditJob
//
//  Synopsis:   Invoke the edit job property sheet.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::EditJob(HWND hParent, DWORD dwReserved)
{
    if (m_ptszFileName != NULL && m_ptszFileName[0] != TEXT('\0'))
    {
        return DisplayJobProperties(m_ptszFileName, (ITask *)this);
    }

    return STG_E_NOTFILEBASEDSTORAGE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\client\daytona\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    makefile.inc.

!ENDIF

$(NTTARGETFILE0):	..\..\idl\$(O)\$(@F)
    copy ..\..\idl\$(O)\$(@F) $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\client\dllmisc.cxx ===
//+----------------------------------------------------------------------------
//
//  Job Schedule Application Job Object Handler
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       dllmisc.cxx
//
//  Contents:   job scheduler class objects handler DLL fcns
//
//  History:    25-Sep-95 EricB created
//              23-Feb-01 JBenton added code to clean up debug crit sections
//
//-----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop

DECLARE_INFOLEVEL(Sched);

#include <job_cls.hxx>
#include <sch_cls.hxx>
#include <dynload.hxx>
#include <debug.hxx>

//
//  JobFolder related stuff
//

BOOL JFOnProcessAttach(void);
HRESULT JFGetClassObject(REFCLSID cid, REFIID riid, LPVOID *ppvObj);
HRESULT AllocFolderCFs(void);
void FreeFolderCFs(void);


//+----------------------------------------------------------------------------
//
//      DLL functions
//
//-----------------------------------------------------------------------------

//+----------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   Provide a DllMain for Win32
//
//  Arguments:  hInstance - HANDLE to this dll
//              dwReason  - Reason this function was called. Can be
//                          Process/Thread Attach/Detach.
//
//  Returns:    BOOL - TRUE if no error, FALSE otherwise
//
//  History:    24-May-95 EricB created.
//
//-----------------------------------------------------------------------------
extern "C" BOOL
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            schDebugOut((DEB_ITRACE, "DllMain: DLL_PROCESS_ATTACH\n"));

            //
            // Get instance handle
            //

            g_hInstance = hInstance;

            //
            // Disable thread notification from OS
            //

            DisableThreadLibraryCalls(hInstance);

            HRESULT hr;

            //
            // Init the folder class factory objects.
            //

            hr = AllocFolderCFs();
            if (FAILED(hr))
            {
                ERR_OUT("AllocFolderCFs", hr);
                return FALSE;
            }

            //
            // Initialize the global service values.  These are globals that 
            // live in common\globals.cxx, and are used in both the service 
            // (mstask.exe) and client (mstask.dll). 
            //

            hr = InitGlobals();
            if (FAILED(hr))
            {
                ERR_OUT("InitGlobals", hr);
                return FALSE;
            }

            //
            //  Init job folder stuff
            //

            if (JFOnProcessAttach() == FALSE)
            {
                return FALSE;
            }

            break;

        case DLL_PROCESS_DETACH:
            schDebugOut((DEB_ITRACE, "DllMain: DLL_PROCESS_DETACH\n"));
#if DBG == 1
			CleanUpDebugging();
#endif
            FreeGlobals();
            FreeFolderCFs();
            FreeDynLoadLibs();
            break;
    }
    return(TRUE);
}

//+----------------------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Creates a class factory for the requested object.
//
//  Arguments:  [cid]    - the requested class object
//              [iid]    - the requested interface
//              [ppvObj] - returned pointer to class object
//
//  Returns:    HRESULTS
//
//-----------------------------------------------------------------------------
STDAPI
DllGetClassObject(REFCLSID cid, REFIID iid, void **ppvObj)
{
    IUnknown *pUnk = NULL;
    HRESULT hr = S_OK;

    if (CLSID_CTask == cid)
    {
        pUnk = CJobCF::Create();
        if (pUnk != NULL)
        {
            hr = pUnk->QueryInterface(iid, ppvObj);
            pUnk->Release();
        }
        else
        {
            return E_OUTOFMEMORY;
        }
    }
    else if (CLSID_CTaskScheduler == cid)
    {
        pUnk = CScheduleCF::Create();
        if (pUnk != NULL)
        {
            hr = pUnk->QueryInterface(iid, ppvObj);
            pUnk->Release();
        }
        else
        {
            return E_OUTOFMEMORY;
        }
    }
    else
    {
        return JFGetClassObject(cid, iid, ppvObj);
    }
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   DllCanUnloadNow
//
//  Synopsis:   Indicates whether the DLL can be removed if there are no
//              objects in existence.
//
//  Returns:    S_OK or S_FALSE
//
//-----------------------------------------------------------------------------
STDAPI
DllCanUnloadNow(void)
{
    return CDll::CanUnloadNow();
}


#if !defined(_CHICAGO_)

//+----------------------------------------------------------------------------
//
//  Function:   AddAtJobWithHash
//
//  Synopsis:   Client-side stub for this API to make things compile.  Only
//              supported/called on the server side
//
//  Returns:    E_NOTIMPL
//
//-----------------------------------------------------------------------------
STDAPI
CSchedule::AddAtJobWithHash(
    const AT_INFO &At,
    DWORD * pID)
{
    return E_NOTIMPL;
}

#endif  // !defined(_CHICAGO_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\client\job.cxx ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       job.cxx
//
//  Contents:
//
//  Classes:    None.
//
//  Functions:
//
//  History:    14-Mar-96 EricB  created
//              21-Jun-96 MarkBl Renamed from jobedit.cxx since now Save() &
//                               Get/SetAccountInformation members require
//                               client-side rpc. Their implementations must
//                               reside here so we don't have to include the
//                               client-side RPC in the service. Also added
//                               Get/SetAccountInformation members.
//
//  Notes:      Disabled security code completely for Win95. This will be
//              enabled in the next release of the scheduling agent.
//
//              BUGBUG : The classes should be split into a core base class,
//                       then have an OLE-supporting class inherit from it.
//                       The core class would exist in the service. The sub-
//                       class in the dll.
//
//____________________________________________________________________________

#include "..\pch\headers.hxx"
#pragma hdrstop

#if !defined(_CHICAGO_)
#include "network.hxx"
#endif // !defined(_CHICAGO_)
#include "misc.hxx"
#include "job_cls.hxx"
#include "debug.hxx"
#if !defined(_CHICAGO_)
#include "defines.hxx"
#endif // !defined(_CHICAGO_)
#if !defined(_CHICAGO_)
#include "SASecRPC.h"     // Get/SetAccountInformation RPC definition.
#endif // !defined(_CHICAGO_)

#if !defined(_CHICAGO_)
typedef DWORD (WINAPI * PWNETGETUNIVERSALNAMEW)(LPCWSTR, DWORD, LPVOID,
                                                    LPDWORD);

PWNETGETUNIVERSALNAMEW  gpWNetGetUniversalNameW = NULL;
#endif // !defined(_CHICAGO_)

HRESULT DisplayJobProperties(LPTSTR, ITask *);
//
// This operation is not supported locally on Win95, and for the first
// release of the scheduling agent, neither remotely from Win95 to NT.
//

#if !defined(_CHICAGO_)
void    ResetAccountInfo(PJOB_ACCOUNT_INFO pAccountInfo);
#endif // !defined(_CHICAGO_)


//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::EditWorkItem
//
//  Synopsis:   Invoke the edit job property sheet.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::EditWorkItem(HWND hParent, DWORD dwReserved)
{
    if (m_ptszFileName != NULL && m_ptszFileName[0] != TEXT('\0'))
    {
        return DisplayJobProperties(m_ptszFileName, (ITask *)this);
    }

    return STG_E_NOTFILEBASEDSTORAGE;
}

//+----------------------------------------------------------------------------
//
//      CJob::IProvideTaskPage::GetPage method
//
//-----------------------------------------------------------------------------

STDMETHODIMP
I_GetTaskPage(
    ITask              * pITask,
    TASKPAGE             tpType,
    BOOL                 fPersistChanges,
    HPROPSHEETPAGE    *  phPage);


STDMETHODIMP
CJob::GetPage(
    TASKPAGE            tpType,
    BOOL                fPersistChanges,
    HPROPSHEETPAGE    * phPage)
{
    return I_GetTaskPage((ITask *)this, tpType, fPersistChanges, phPage);
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::SetAccountInformation
//
//  Synopsis:   Set the name and password of the account to be used for running
//              this job.
//
//  Arguments:  [pwszAccountName] -- Account name.
//              [pwszPassword]    -- Account password.
//
//  Returns:    S_OK
//              E_INVALIDARG
//              E_OUTOFMEMORY
//
//  Notes:      Both strings are caller allocated and freed.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::SetAccountInformation(LPCWSTR pwszAccountName,
                            LPCWSTR pwszPassword)
{
    TRACE(CJob, SetAccountInformation)

	if( NULL == pwszAccountName )
	{
		return E_INVALIDARG;
	}
    //
    // This operation is not supported locally on Win95, and for the first
    // release of the scheduling agent, neither remotely from Win95 to NT.
    //

#if !defined(_CHICAGO_)
    HRESULT hr;

    //
    // Need to allocate the private data member structure containing copies
    // of the account arguments.
    //
    // Note, could allocate everything within a single buffer, but since
    // this operation is performed so rarely, it really isn't worth it.
    //

    PJOB_ACCOUNT_INFO pAccountInfo = new JOB_ACCOUNT_INFO;

    if (pAccountInfo == NULL)
    {
        return(E_OUTOFMEMORY);
    }

    pAccountInfo->pwszPassword = NULL;
    pAccountInfo->pwszAccount  = new WCHAR[wcslen(pwszAccountName) + 1];

    if (pAccountInfo->pwszAccount != NULL)
    {
        wcscpy(pAccountInfo->pwszAccount, pwszAccountName);
    }
    else
    {
        hr = E_OUTOFMEMORY;
        goto ErrorExit;
    }

    if (pwszPassword != NULL)
    {
        pAccountInfo->pwszPassword = new WCHAR[wcslen(pwszPassword) + 1];

        if (pAccountInfo->pwszPassword != NULL)
        {
            wcscpy(pAccountInfo->pwszPassword, pwszPassword);
        }
        else
        {
            hr = E_OUTOFMEMORY;
            goto ErrorExit;
        }
    }

    if (m_pAccountInfo != NULL)
    {
        ResetAccountInfo(m_pAccountInfo);
        delete m_pAccountInfo;
    }
    m_pAccountInfo = pAccountInfo;

    //
    // Setting this flag will result in the RPC call to set the account
    // information on object save (IPersistFile::Save()).
    //

    this->SetFlag(JOB_I_FLAG_SET_ACCOUNT_INFO);

    return(S_OK);

ErrorExit:
    if (pAccountInfo != NULL)
    {
        ResetAccountInfo(pAccountInfo);
        delete pAccountInfo;
    }

    return(hr);
#else

    return(SCHED_E_NO_SECURITY_SERVICES);

#endif // !defined(_CHICAGO)
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::GetAccountInformation
//
//  Synopsis:   Get the name of the account to be used for this job.
//
//  Arguments:  [ppwszAccountName] - the returned string buffer
//
//  Returns:    HRESULTS
//
//  Notes:      The string is callee allocated and caller freed with
//              CoTaskMemFree.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::GetAccountInformation(LPWSTR * ppwszAccountName)
{
    TRACE3(CJob, GetAccountInformation)

    //
    // This operation is not supported locally on Win95, and for the first
    // release of the scheduling agent, neither remotely from Win95 to NT.
    //

#if !defined(_CHICAGO_)
    HRESULT hr;

    //
    // Unexpected, but possible should the caller CoCreateInstance a new
    // job, then call this member w/o IPersistFile::Load/Save.
    //

    if (m_ptszFileName == NULL)
    {
        schDebugOut((DEB_ERROR,
                     "GetAccountInformation called with no filename\n"));
        return(E_UNEXPECTED);
    }

    //
    // Return cached account name. If it hasn't been obtained, we'll
    // need to RPC to the server to get it.
    //

    WCHAR   wszAccountName[MAX_USERNAME + 1];
    WCHAR * pwszAccountName = NULL;

    if (m_pAccountInfo == NULL)
    {
        //
        // RPC to the server local to this job to fetch the account name
        // associated with this job.
        //
        // First, figure out if this is a remote job. If so, fetch the server
        // name on which the job resides.
        //

        WCHAR   wszFileName[MAX_PATH + 1] = L"";
        WCHAR   wszUNCPath[MAX_PATH + 1];
        WCHAR * pwszFileName;
        WCHAR * pwszServerName;

#if !defined(UNICODE)
        HRESULT hr = AnsiToUnicode(wszFileName, m_ptszFileName, MAX_PATH+1);

        if (FAILED(hr))
        {
            return E_INVALIDARG;
        }
        pwszFileName = wszFileName;
#else
        pwszFileName = m_ptszFileName;
#endif // UNICODE

        //
        // Fetch the server name associated with the network path. If the path
        // is local, the server name returned will be NULL.
        //

        hr = GetServerNameFromPath(pwszFileName,
                                   (MAX_PATH + 1) * sizeof(WCHAR),
                                   wszUNCPath,
                                   &pwszServerName);

        if (FAILED(hr))
        {
            return(hr);
        }

#if defined(_CHICAGO_)
        //
        // Local security operations are not supported on Win95.
        //

        if (pwszServerName == NULL)
        {
            return(SCHED_E_NO_SECURITY_SERVICES);
        }
#endif // _CHICAGO_

        //
        // RPC to the service to fetch the account name.
        //
        // First, isolate the relative job name from the remaining path.
        //

        WCHAR * pwszRelativeFileName;

        if (pwszFileName != NULL)
        {
            pwszRelativeFileName = wcsrchr(pwszFileName, L'\\');

            if (pwszRelativeFileName != NULL)
            {
                pwszRelativeFileName++;
            }
            else
            {
                pwszRelativeFileName = pwszFileName;
            }
        }

        DWORD ccAccountName = MAX_USERNAME;

        RpcTryExcept
        {
            hr = SAGetAccountInformation(pwszServerName,
                                         pwszRelativeFileName,
                                         ccAccountName,
                                         wszAccountName);
        }
        RpcExcept(1)
        {
            DWORD Status = RpcExceptionCode();
            schDebugOut((DEB_ERROR,
                "GetAccountInformation exception(0x%x)\n",
                Status));
            hr = SchedMapRpcError(Status);
        }
        RpcEndExcept;

        if (SUCCEEDED(hr))
        {
            pwszAccountName = wszAccountName;
        }
    }
    else
    {
        schAssert(m_pAccountInfo->pwszAccount != NULL);
        pwszAccountName = m_pAccountInfo->pwszAccount;
        hr = S_OK;
    }

    //
    // Allocate returned name.
    //

    if (pwszAccountName != NULL)
    {
        LPWSTR pwszAccountNameCopy;

        pwszAccountNameCopy = (LPWSTR)CoTaskMemAlloc(
                        (s_wcslen(pwszAccountName) + 1) * sizeof(WCHAR));

        if (pwszAccountNameCopy == NULL)
        {
            return(E_OUTOFMEMORY);
        }

        s_wcscpy(pwszAccountNameCopy, pwszAccountName);
        *ppwszAccountName = pwszAccountNameCopy;
    }

    return(hr);
#else

    return(SCHED_E_NO_SECURITY_SERVICES);

#endif // !defined(_CHICAGO)
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::IPersistFile::Save
//
//  Synopsis:   Save job properties to the job object. Upon successful save,
//              if account credentials have been specified, set them via
//              RPC to the service.
//
//  Arguments:  [pwszFileName] - if null, save to the previously loaded file.
//              [fRemember]    - if TRUE, the object becomes associated with
//                               the new filename.
//
//  Notes:      This member must now be split into two versions with the
//              addition of security: one for the .dll in
//              sched\client\job.cxx, and for the .exe in
//              sched\svc_core\job.cxx. This was necessary as Save now
//              includes client-side rpc code. A single version of this
//              member would require the client-side rpc code to be included
//              in the service.
//
//              All OLE32 strings are UNICODE, including the filename passed
//              in the IPersistFile methods. On Win9x, all file names must
//              be in ANSI strings, thus the conversion and call to SaveP.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::Save(LPCOLESTR pwszFileName, BOOL fRemember)
{
    HRESULT hr = S_OK;

#if defined(UNICODE)

    //
    // Always save fixed and variable length data, but Never alter the running
    // instance count from the COM interface method.
    //

    hr = SaveP(pwszFileName, fRemember, SAVEP_VARIABLE_LENGTH_DATA);

#else

    CHAR szFileName[MAX_PATH + 1];

    if (pwszFileName != NULL)   // If filename non-null, convert to ANSI
    {
        hr = UnicodeToAnsi(szFileName, pwszFileName, MAX_PATH + 1);

        if (FAILED(hr))
        {
            return STG_E_INVALIDNAME;
        }
    }

    hr = SaveP(pwszFileName != NULL ? szFileName : NULL,
               fRemember,
               SAVEP_VARIABLE_LENGTH_DATA);
#endif

    if (FAILED(hr))
    {
        return(hr);
    }

    //
    // If nested folders are allowed in the future, add code something
    // like this:
    //
    //
    // if (hr == HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND))
    // {
    //     //
    //     // Create folders as needed
    //     //
    //     hr = CreateFolders(pwszFileName, TRUE);
    //     if (FAILED(hr))
    //     {
    //         ERR_OUT("CJob::Save: CreateFolders", hr);
    //         return hr;
    //     }
    //     //
    //     // Try again
    //     //
    //     hr = pJob->SaveP(pwszFileName, fRemember, SAVEP_VARIABLE_LENGTH_DATA);
    // }
    //

    //
    // This operation is not supported locally on Win95, and for the first
    // release of the scheduling agent, neither remotely from Win95 to NT.
    //

#if !defined(_CHICAGO_)
    //
    // Now that job changes are completely saved, set security information,
    // if specified. This order is important as the application name is tied
    // to the credentials for security reasons. If the application changes,
    // the existing credentials are invalidated.
    //
    // ** Important ** Maintain file save, security setting order!
    //

    if (IsFlagSet(JOB_I_FLAG_SET_ACCOUNT_INFO))
    {
        //
        // RPC to the server local to this job to fetch the account name
        // associated with this job.
        //
        // First, figure out if this is a remote job. If so, fetch the server
        // name on which the job resides.
        //
        // Also, if this code is executing on Win95, and the file name passed
        // is NULL, the ANSI private filename data must be converted to
        // unicode. Note, CJob::SaveP checks if m_ptszFileName is NULL. The
        // member fails if this is the case.
        //

        WCHAR   wszUNCPath[MAX_PATH + 1];
        WCHAR * pwszFileNameLocal;
        WCHAR * pwszServerName;
#if !defined(UNICODE)
        WCHAR   wszFileName[MAX_PATH + 1] = L"";
#endif // UNICODE

        if (pwszFileName == NULL)
        {
#if !defined(UNICODE)
            hr = AnsiToUnicode(wszFileName, m_ptszFileName, MAX_PATH + 1);

            if (FAILED(hr))
            {
                return(hr);
            }
            pwszFileNameLocal = wszFileName;
#else
            pwszFileNameLocal = m_ptszFileName;
#endif // UNICODE
        }
        else
        {
            pwszFileNameLocal = (WCHAR *)pwszFileName;
        }

        //
        // Fetch the server name associated with the network path. If the path
        // is local, the server name returned will be NULL.
        //

        hr = GetServerNameFromPath(pwszFileNameLocal,
                                   (MAX_PATH + 1) * sizeof(WCHAR),
                                   wszUNCPath,
                                   &pwszServerName);

        if (FAILED(hr))
        {
            return(hr);
        }

#if defined(_CHICAGO_)
        //
        // Local security operations are not supported on Win95.
        //

        if (pwszServerName == NULL)
        {
            return(SCHED_E_NO_SECURITY_SERVICES);
        }
#endif // _CHICAGO_

        //
        // RPC to the service to set the account information.
        //
        // First, isolate the relative job name from the remaining path.
        //

        WCHAR * pwszRelativeFileName;

        if (pwszFileNameLocal != NULL)
        {
            pwszRelativeFileName = wcsrchr(pwszFileNameLocal, L'\\');

            if (pwszRelativeFileName != NULL)
            {
                pwszRelativeFileName++;
            }
            else
            {
                pwszRelativeFileName = pwszFileNameLocal;
            }
        }

        RpcTryExcept
        {
            //
            // Note:  We pass the flags via RPC in order to let
            // the server side do the access checks for the NULL
            // password case.  These checks could technically be
            // done on the client side, but it's more convenient
            // (and smaller codesize) to do it this way
            //
            hr = SASetAccountInformation(pwszServerName,
                                         pwszRelativeFileName,
                                         m_pAccountInfo->pwszAccount,
                                         m_pAccountInfo->pwszPassword,
                                         m_rgFlags);
        }
        RpcExcept(1)
        {
            DWORD Status = RpcExceptionCode();
            schDebugOut((DEB_ERROR,
                "SetAccountInformation exception(0x%x)\n",
                Status));
            hr = SchedMapRpcError(Status);
        }
        RpcEndExcept;

        this->ClearFlag(JOB_I_FLAG_SET_ACCOUNT_INFO);

        //
        // NB : After successful save of the security information, the
        //      cached values are reset.
        //

        ResetAccountInfo(m_pAccountInfo);
        delete m_pAccountInfo;
        m_pAccountInfo = NULL;
    }
#endif // !defined(_CHICAGO_)

    return hr;
}

//
// This operation is not supported locally on Win95, and for the first
// release of the scheduling agent, neither remotely from Win95 to NT.
//

#if !defined(_CHICAGO_)
//+----------------------------------------------------------------------------
//
//  Function:   ResetAccountInfo
//
//  Synopsis:   Simple helper to zero the password and deallocate struct
//              JOB_ACCOUNT_INFO fields.
//
//  Arguments:  [pAccountInfo] -- Account info struct to reset.
//
//  Returns:    None.
//
//  Notes:      None.
//
//-----------------------------------------------------------------------------
void
ResetAccountInfo(PJOB_ACCOUNT_INFO pAccountInfo)
{
    delete pAccountInfo->pwszAccount;
    pAccountInfo->pwszAccount = NULL;

    if (pAccountInfo->pwszPassword != NULL)
    {
        ZERO_PASSWORD(pAccountInfo->pwszPassword);
        delete pAccountInfo->pwszPassword;
        pAccountInfo->pwszPassword = NULL;
    }
}
#endif // !defined(_CHICAGO_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\client\rpc.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       rpc.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    10-Nov-95   MarkBl  Created.
//
//----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "debug.hxx"

#if !defined(_CHICAGO_)
#include "atsvc.h"
#endif // !defined(_CHICAGO_)
#include "SASecRPC.h"

typedef HRESULT (* BindFunction)(LPWSTR, RPC_BINDING_HANDLE *);

RPC_STATUS BindNetBIOSOverNetBEUI(LPWSTR, RPC_BINDING_HANDLE *);
RPC_STATUS BindNetBIOSOverTCP(LPWSTR, RPC_BINDING_HANDLE *);
RPC_STATUS BindNetBIOSOverIPX(LPWSTR, RPC_BINDING_HANDLE *);
RPC_STATUS BindNamedPipe(LPWSTR, RPC_BINDING_HANDLE *);
RPC_STATUS BindSPX(LPWSTR, RPC_BINDING_HANDLE *);
RPC_STATUS BindTCPIP(LPWSTR, RPC_BINDING_HANDLE *);
RPC_STATUS BindViaProtocol(LPTSTR , LPWSTR , RPC_BINDING_HANDLE * );
extern "C" handle_t GenericBind(LPCWSTR, RPC_IF_HANDLE);
extern "C" void     GenericUnbind(LPCWSTR, RPC_BINDING_HANDLE);

BindFunction grgProtocolBindFuncs[] = {
    BindNamedPipe,
    BindTCPIP,
    BindSPX,
    NULL
};

RPC_BINDING_HANDLE gRpcHandle = NULL;

#if !defined(_CHICAGO_)
//+---------------------------------------------------------------------------
//
//  Function:   ATSVC_HANDLE_bind
//
//  Synopsis:   Called from RPC on auto bind.
//
//  Arguments:  [ServerName] -- Server to bind to.
//
//  Returns:    RPC_STATUS code
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
extern "C" handle_t
ATSVC_HANDLE_bind(ATSVC_HANDLE ServerName)
{
    return(GenericBind(ServerName, atsvc_ClientIfHandle));
}

//+---------------------------------------------------------------------------
//
//  Function:   ATSVC_HANDLE_unbind
//
//  Synopsis:   Unbind. Free the handle.
//
//  Arguments:  [ServerName]    -- Unused.
//              [BindingHandle] -- Binding handle to free.
//
//  Returns:    RPC_STATUS code
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
extern "C" void
ATSVC_HANDLE_unbind(ATSVC_HANDLE ServerName, RPC_BINDING_HANDLE BindingHandle)
{
    GenericUnbind(ServerName, BindingHandle);
}
#endif // !defined(_CHICAGO_)

//+---------------------------------------------------------------------------
//
//  Function:   SASEC_HANDLE_bind
//
//  Synopsis:   Called from RPC on auto bind.
//
//  Arguments:  [ServerName] -- Server to bind to.
//
//  Returns:    RPC_STATUS code
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
extern "C" handle_t
SASEC_HANDLE_bind(SASEC_HANDLE ServerName)
{
    RPC_BINDING_HANDLE BindingHandle;
    RPC_STATUS         RpcStatus;

    if ((BindingHandle = GenericBind(ServerName,
                                     sasec_ClientIfHandle)) != NULL)
    {
        //
        // Set the connection to be authenticated and all arguments encrypted.
        //

        RpcStatus = RpcBindingSetAuthInfo(BindingHandle,
                                          NULL,
                                          RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                                          RPC_C_AUTHN_WINNT,
                                          NULL,
                                          RPC_C_AUTHZ_NONE);

        //
        // Refuse the bind, if the requested authentication failed.
        //

        if (RpcStatus != RPC_S_OK)
        {
            GenericUnbind(ServerName, BindingHandle);
            CHECK_HRESULT(HRESULT_FROM_WIN32(RpcStatus));
            return(NULL);
        }
    }

    return(BindingHandle);
}

//+---------------------------------------------------------------------------
//
//  Function:   SASEC_HANDLE_unbind
//
//  Synopsis:   Unbind. Free the handle.
//
//  Arguments:  [ServerName]    -- Unused.
//              [BindingHandle] -- Binding handle to free.
//
//  Returns:    RPC_STATUS code
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
extern "C" void
SASEC_HANDLE_unbind(SASEC_HANDLE ServerName, RPC_BINDING_HANDLE BindingHandle)
{
    GenericUnbind(ServerName, BindingHandle);
}

//+---------------------------------------------------------------------------
//
//  Function:   GenericBind
//
//  Synopsis:
//
//  Arguments:  [ServerName]     -- Server to bind to.
//              [ClientIfHandle] -- Specific interface.
//  Returns:
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
extern "C" handle_t
GenericBind(LPCWSTR ServerName, RPC_IF_HANDLE ClientIfHandle)
{
    RPC_BINDING_HANDLE BindingHandle = NULL;
    RPC_STATUS         RpcStatus;

    //
    // If local, use LRPC. Otherwise, try multiple protocols.
    //

    if (ServerName == NULL)
    {
        RpcStatus = BindViaProtocol(TEXT("ncalrpc"), NULL, &BindingHandle);
        CHECK_HRESULT(HRESULT_FROM_WIN32(RpcStatus));

        if (RpcStatus == RPC_S_OK)
        {
            RpcStatus = RpcEpResolveBinding(BindingHandle, ClientIfHandle);
            CHECK_HRESULT(HRESULT_FROM_WIN32(RpcStatus));
        }
    }
    else
    {
        BindFunction pBindFunc;

        pBindFunc = grgProtocolBindFuncs[0];

        int i = 0;

        //
        // Iterate through the protocols until we find one that can connect.
        //

        do
        {
            RpcStatus = pBindFunc((LPWSTR)ServerName, &BindingHandle);

            if (RpcStatus == RPC_S_OK)
            {
                //
                // For the named pipes protocol, we use a static endpoint,
                // so the call to RpcEpResolveBinding is not needed.
                //
                // BUGBUG : review the above. Also, should we be specifying
                //          authentication info?
                //

                if (pBindFunc != BindNamedPipe)
                {
                    RpcStatus = RpcEpResolveBinding(BindingHandle,
                                                    ClientIfHandle);
                    CHECK_HRESULT(HRESULT_FROM_WIN32(RpcStatus));
                }
            }
            else if (RpcStatus == RPC_S_PROTSEQ_NOT_SUPPORTED)
            {
                //
                // If the protocol is not on this computer, then rearrange
                // the list so it is not tried anymore.
                //

                CopyMemory(&grgProtocolBindFuncs[i],
                           &grgProtocolBindFuncs[i + 1],
                           sizeof(grgProtocolBindFuncs) -
                    (&grgProtocolBindFuncs[i + 1] - &grgProtocolBindFuncs[0]));
                i--;
            }

            //
            // Try the next protocol's connection function.
            //

            if (RpcStatus != RPC_S_OK)
            {
                i++;
                pBindFunc = grgProtocolBindFuncs[i];
            }

        } while (!((RpcStatus == RPC_S_OK) || (pBindFunc == NULL)));
    }

    return(BindingHandle);
}

//+---------------------------------------------------------------------------
//
//  Function:   GenericUnbind
//
//  Synopsis:
//
//  Arguments:  [ServerName] -- Server to bind to.
//
//  Returns:
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
extern "C" void
GenericUnbind(LPCWSTR ServerName, RPC_BINDING_HANDLE BindingHandle)
{
    UNREFERENCED_PARAMETER(ServerName);

    if (BindingHandle != NULL) {
        RPC_STATUS RpcStatus = RpcBindingFree(&BindingHandle);
        schAssert(RpcStatus == RPC_S_OK);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   BindingFromStringBinding
//
//  Synopsis:   Bind then free the string binding passed.
//
//  Arguments:  [StringBinding]  -- Target string binding.
//              [pBindingHandle] -- Returned binding handle.
//
//  Returns:    RPC_STATUS code
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
RPC_STATUS
BindingFromStringBinding(
    LPTSTR *             StringBinding,
    RPC_BINDING_HANDLE * pBindingHandle)
{
    RPC_STATUS RpcStatus;

#if defined(UNICODE)
    RpcStatus = RpcBindingFromStringBinding(*StringBinding, pBindingHandle);
    RpcStringFree(StringBinding);
#else
    RpcStatus = RpcBindingFromStringBinding((UCHAR *)*StringBinding,
                                            pBindingHandle);
    RpcStringFree((UCHAR **)StringBinding);
#endif // defined(UNICODE)

    if (RpcStatus != RPC_S_OK)
    {
        *pBindingHandle = NULL;
    }

    return(RpcStatus);
}

//+---------------------------------------------------------------------------
//
//  Function:   BindViaProtocol
//
//  Synopsis:   Bind via the specified protocol.
//
//  Arguments:  [ServerName]     -- Server name to bind to.
//              [pBindingHandle] -- Returned binding handle.
//
//  Returns:    RPC_STATUS code
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
RPC_STATUS
BindViaProtocol(
    LPTSTR               rpc_protocol,
    LPWSTR               ServerName,
    RPC_BINDING_HANDLE * pBindingHandle)
{
    TCHAR      tszServerName[SA_MAX_COMPUTERNAME_LENGTH + 3]; // plus 3 for "\\" and NULL
    RPC_STATUS RpcStatus;
    LPTSTR     StringBinding;
    LPTSTR     PlainServerName;

    *pBindingHandle = NULL;

    schDebugOut((DEB_ITRACE,
        "Attempting RPC bind via protocol \"%ws\"\n",
        rpc_protocol));
    if (ServerName != NULL)
    {
        wcscpy(tszServerName, ServerName);
    }

    //
    // Ignore leading "\\"
    //

    if (ServerName != NULL && ServerName[0] == L'\\' &&
                ServerName[1] == L'\\')
    {
        PlainServerName = &tszServerName[2];
    }
    else
    {
        PlainServerName = ServerName != NULL ? tszServerName : NULL;
    }

    RpcStatus = RpcStringBindingCompose(NULL,
                                        rpc_protocol,
                                        PlainServerName,
                                        NULL,               // endpoint
                                        NULL,
                                        &StringBinding);

    if (RpcStatus != RPC_S_OK)
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(RpcStatus));
        return(RpcStatus);
    }

    return(BindingFromStringBinding(&StringBinding, pBindingHandle));
}

//+---------------------------------------------------------------------------
//
//  Function:   BindNetBIOSOverNetBEUI
//
//  Synopsis:   Attempt to bind via netbeui.
//
//  Arguments:  [ServerName]     -- Server name to bind to.
//              [pBindingHandle] -- Returned binding handle.
//
//  Returns:    RPC_STATUS code
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
RPC_STATUS
BindNetBIOSOverNetBEUI(LPWSTR ServerName, RPC_BINDING_HANDLE * pBindingHandle)
{
    return(BindViaProtocol(TEXT("ncacn_nb_nb"),
                           ServerName,
                           pBindingHandle));
}

//+---------------------------------------------------------------------------
//
//  Function:   BindNetBIOSOverTCP
//
//  Synopsis:   Attempt to bind via tcp over netbios.
//
//  Arguments:  [ServerName]     -- Server name to bind to.
//              [pBindingHandle] -- Returned binding handle.
//
//  Returns:    RPC_STATUS code
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
RPC_STATUS
BindNetBIOSOverTCP(LPWSTR ServerName, RPC_BINDING_HANDLE * pBindingHandle)
{
    return(BindViaProtocol(TEXT("ncacn_nb_tcp"),
                           ServerName,
                           pBindingHandle));
}

//+---------------------------------------------------------------------------
//
//  Function:   BindNetBIOSOverIPX
//
//  Synopsis:   Attempt to bind via ipx over netbios.
//
//  Arguments:  [ServerName]     -- Server name to bind to.
//              [pBindingHandle] -- Returned binding handle.
//
//  Returns:    RPC_STATUS code
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
RPC_STATUS
BindNetBIOSOverIPX(LPWSTR ServerName, RPC_BINDING_HANDLE * pBindingHandle)
{
    return(BindViaProtocol(TEXT("ncacn_nb_ipx"),
                           ServerName,
                           pBindingHandle));
}

//+---------------------------------------------------------------------------
//
//  Function:   BindNamedPipe
//
//  Synopsis:   Attempt to bind via named pipes.
//
//  Arguments:  [ServerName]     -- Server name to bind to.
//              [pBindingHandle] -- Returned binding handle.
//
//  Returns:    ERROR_INVALID_COMPUTERNAME
//              RPC_STATUS code
//
//  Notes:      Server side *not* supported in Win95.
//
//----------------------------------------------------------------------------
RPC_STATUS
BindNamedPipe(LPWSTR ServerName, RPC_BINDING_HANDLE * pBindingHandle)
{
    RPC_STATUS  RpcStatus;
    LPTSTR      StringBinding;
    LPWSTR      SlashServerName;
    WCHAR       Buffer[SA_MAX_COMPUTERNAME_LENGTH + 3];   // plus 3 for '\\' and NULL
    int         have_slashes;
    ULONG       NameLen;

    *pBindingHandle = NULL;

    if (ServerName[1] == L'\\')
    {
        have_slashes = 1;
    }
    else
    {
        have_slashes = 0;
    }

    //
    // Be nice and prepend slashes if not supplied.
    //

    NameLen = wcslen(ServerName);

    if ((!have_slashes) && (NameLen > 0))
    {
        if ((NameLen + 2) >= sizeof(Buffer))
        {
            return(ERROR_INVALID_COMPUTERNAME);
        }

        Buffer[0] = L'\\';
        Buffer[1] = L'\\';

        wcscpy(&Buffer[2], ServerName);

        SlashServerName = Buffer;
    }
    else
    {
        SlashServerName = ServerName;
    }

    RpcStatus = RpcStringBindingCompose(0,
                                        TEXT("ncacn_np"),
                                        SlashServerName,
                                        TEXT("\\PIPE\\atsvc"),
                                        NULL,
                                        &StringBinding);

    if (RpcStatus != RPC_S_OK)
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(RpcStatus));
        return(RpcStatus);
    }

    return(BindingFromStringBinding(&StringBinding, pBindingHandle));
}

//+---------------------------------------------------------------------------
//
//  Function:   BindSPX
//
//  Synopsis:   Attempt to bind over SPX.
//
//  Arguments:  [ServerName]     -- Server name to bind to.
//              [pBindingHandle] -- Returned binding handle.
//
//  Returns:    RPC_STATUS code
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
RPC_STATUS
BindSPX(LPWSTR ServerName, RPC_BINDING_HANDLE * pBindingHandle)
{
    return(BindViaProtocol(TEXT("ncacn_spx"),
                           ServerName,
                           pBindingHandle));
}

//+---------------------------------------------------------------------------
//
//  Function:   BindTCPIP
//
//  Synopsis:   Attempt to bind over TCP/IP.
//
//  Arguments:  [ServerName]     -- Server name to bind to.
//              [pBindingHandle] -- Returned binding handle.
//
//  Returns:    RPC_STATUS code
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
RPC_STATUS
BindTCPIP(LPWSTR ServerName, RPC_BINDING_HANDLE * pBindingHandle)
{
    return(BindViaProtocol(TEXT("ncacn_ip_tcp"),
                           ServerName,
                           pBindingHandle));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\clientpublish\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 2002

Module Name:

    makefile.inc.

!ENDIF

$(NTTARGETFILE1):
    lib /OUT:$(O)\mstask.lib ..\client\daytona\$(O)\mstask.lib ..\types\uuid\$(O)\guids.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\common\cdlink.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992.
//
//  File:       cdlink.cxx
//
//  Contents:
//
//  Classes:    CDlink
//
//  History:    16-Oct-91  KevinRo Created
//
//--------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "debug.hxx"

//+-------------------------------------------------------------------------
//
// Member:      CDLink::LinkAfter
//
// Purpose:     Links this after dlPrev and before dlPrev->_dlNext
//
// Returns:     this
//
// Note:        None.
//
//--------------------------------------------------------------------------
VOID CDLink::LinkAfter(CDLink * dlPrev)
{
    _dlPrev = dlPrev;

    if(dlPrev != NULL)
    {
        _dlNext = dlPrev->_dlNext;
        dlPrev->_dlNext = this;

        if(_dlNext != NULL) {
            _dlNext->_dlPrev = this;
        }
    }
    else
    {
        _dlNext = NULL;
    }
}
//+-------------------------------------------------------------------------
//
// Member:      CDLink::LinkBefore
//
// Purpose:     Links this Before dlNext and after dlNext->_dlPrev
//
// Returns:     this
//
//--------------------------------------------------------------------------
VOID CDLink::LinkBefore(CDLink * dlNext)
{
    _dlNext = dlNext;

    if(dlNext != NULL)
    {
        _dlPrev = dlNext->_dlPrev;

        dlNext->_dlPrev = this;

        if(_dlPrev != NULL) {
            _dlPrev->_dlNext = this;
        }
    }
    else
    {
        _dlPrev = NULL;
    }
}

//+-------------------------------------------------------------------------
//
// Member:      CDLink::Unlink()
//
// Purpose:     Removes this from double linked list
//
// Returns:     this
//
//--------------------------------------------------------------------------
VOID CDLink::UnLink()
{
    if(_dlNext != NULL) {
        _dlNext->_dlPrev = _dlPrev;
    }
    if(_dlPrev != NULL) {
        _dlPrev->_dlNext = _dlNext;
    }
    _dlNext = _dlPrev = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\common\debug.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       debug.cxx
//
//  Contents:   Message routines.
//
//  Functions:  SchMsg and SchError.
//
//  History:    09-Sep-95   EricB   Created.
//              01-Dec-95   MarkBl  Split from util.cxx.
//              29-Feb-01	JBenton Prefix Bug 294884
//
//----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop

#include "..\inc\resource.h"
#include "..\inc\common.hxx"
#include "..\inc\debug.hxx"

#define ARRAYLEN(a) (sizeof(a) / sizeof((a)[0]))

//+----------------------------------------------------------------------------
//
//      Message and error reporting functions
//
//-----------------------------------------------------------------------------

//+----------------------------------------------------------------------------
//
//  Function:   SchMsg
//
//  Synopsis:   Display a message.
//
//  Arguments:  [ptszMsg]   - a string message
//              [iStringID] - a string resource ID
//              [...]       - optional params
//
//  Notes:      Either a string or a string ID must be supplied, but not both.
//              If there are optional params, it is assumed that the string has
//              type conversion placeholders so that the string can be used as
//              a formating string.
//-----------------------------------------------------------------------------
void
SchMsg(TCHAR * ptszMsg, int iStringID, ...)
{
    TCHAR tszFmt[SCH_BIGBUF_LEN], tszMsg[SCH_XBIGBUF_LEN];
    if (iStringID != 0)
    {
        if (!LoadString(g_hInstance, iStringID, tszFmt, SCH_BIGBUF_LEN - 1))
        {
            lstrcpy(tszMsg,
                    TEXT("unknown error (failed to load string resource)"));
        }
    }
    else
    {
        if (lstrlen(ptszMsg) >= SCH_BIGBUF_LEN)
        {
            lstrcpyn(tszFmt, ptszMsg, SCH_BIGBUF_LEN - 1);
            tszFmt[SCH_BIGBUF_LEN - 1] = L'\0';
        }
        else
        {
            lstrcpy(tszFmt, ptszMsg);
        }
    }
    va_list va;
    va_start(va, iStringID);
    wvsprintf(tszMsg, tszFmt, va);
    va_end(va);

#if DBG == 1
#ifdef UNICODE
    char szMsg[SCH_XBIGBUF_LEN];
    ZeroMemory(szMsg, ARRAYLEN(szMsg));
    (void) UnicodeToAnsi(szMsg, tszMsg, SCH_XBIGBUF_LEN);
    lstrcatA(szMsg, "\n");    // TODO: length checking
    schDebugOut((DEB_ITRACE, szMsg));
#else
    lstrcat(tszMsg, "\n");
    schDebugOut((DEB_ITRACE, tszMsg));
#endif
#endif

    MessageBox(NULL, tszMsg, TEXT("Scheduling Agent Service"),
               MB_ICONINFORMATION); // TODO: string resource
}

//+----------------------------------------------------------------------------
//
//  Function:   SchError
//
//  Synopsis:   error reporting
//
//  Arguments:  [iStringID] - a string resource ID
//              [iParam]    - an optional error value
//
//  Notes:      If iParam is non-zero, it is assumed that the string has a
//              type conversion placeholder so that the string can be used as
//              a formating string.
//-----------------------------------------------------------------------------
void
SchError(int iStringID, int iParam)
{
    TCHAR tszMsg[SCH_DB_BUFLEN + 1], tszFormat[SCH_DB_BUFLEN + 1],
          tszTitle[SCH_MEDBUF_LEN + 1];

    const TCHAR tszErr[] = TEXT("ERROR: ");
    WORD cch;

    cch = (WORD)LoadString(g_hInstance, IDS_ERRMSG_PREFIX, tszMsg, SCH_DB_BUFLEN);
    if (cch == 0)
    {
        // Use literal if the string resource load failed.
        //
        lstrcpy(tszMsg, tszErr);
        cch = (WORD)lstrlen(tszErr);
    }

    if (!LoadString(g_hInstance, iStringID, tszMsg + cch,
                    SCH_DB_BUFLEN - cch))
    {
        wcsncpy(tszMsg + cch,
                TEXT("unknown error (failed to load string resource)"),
				SCH_DB_BUFLEN - cch);
		tszMsg[SCH_DB_BUFLEN] = '\0';
        iParam = 0;
    }

    if (iParam != 0)
    {
        lstrcpy(tszFormat, tszMsg);
        //
        // Note that there is no length checking below...
        //
        wsprintf(tszMsg, tszFormat, iParam);
    }

    if (!LoadString(g_hInstance, IDS_SCHEDULER_NAME, tszTitle, SCH_MEDBUF_LEN))
    {
        lstrcpy(tszTitle, TEXT("Scheduling Agent"));
    }

#if DBG == 1
#ifdef UNICODE
    char szMsg[SCH_DB_BUFLEN];
    ZeroMemory(szMsg, ARRAYLEN(szMsg));
    (void) UnicodeToAnsi(szMsg, tszMsg, SCH_DB_BUFLEN);
    lstrcatA(szMsg, "\n");    // TODO: length checking
    schDebugOut((DEB_ERROR, szMsg));
#else
    lstrcat(tszMsg, "\n");
    schDebugOut((DEB_ITRACE, tszMsg));
#endif
#endif

    MessageBox(NULL, tszMsg, tszTitle, MB_ICONEXCLAMATION);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\common\globals.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       globals.cxx
//
//  Contents:   Service global data.
//
//  Classes:    None.
//
//  Functions:  None.
//
//  History:    09-Sep-95   EricB   Created.
//              01-Dec-95   MarkBl  Split from util.cxx.
//
//----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop

#include "..\inc\resource.h"
#include "..\inc\common.hxx"
#include "..\inc\debug.hxx"
#include "..\inc\misc.hxx"

#if !defined(_CHICAGO_)
void
GetRootPath(
    LPCWSTR pwszPath,
    WCHAR   wszRootPath[]);
#endif // !defined(_CHICAGO_)

TasksFolderInfo g_TasksFolderInfo            = { NULL, FILESYSTEM_FAT };
TCHAR           g_tszSrvcName[]              = SCHED_SERVICE_NAME;
BOOL            g_fNotifyMiss;               // = 0 by loader
HINSTANCE       g_hInstance;                 // = NULL by loader
ULONG           CDll::s_cObjs;               // = 0 by loader
ULONG           CDll::s_cLocks;              // = 0 by loader

#if !defined(_CHICAGO_)
WCHAR           g_wszAtJobSearchPath[MAX_PATH];
#endif // !defined(_CHICAGO_)

#define DEFAULT_FOLDER_PATH     TEXT("%WinDir%\\Tasks")
#define TASKS_FOLDER            TEXT("\\Tasks")

//
// BUGBUG: global __int64 initialization is not working without the CRT.
// BUG # 37752.
//
__int64 FILETIMES_PER_DAY;

//+----------------------------------------------------------------------------
//
//  Function:   InitGlobals
//
//  Synopsis:   constructs global strings including the folder path strings and,
//              if needed, creates the folders
//
//  Returns:    HRESULTS
//
//  Notes:      This function is called in exactly two places, once for each
//              binary: in dllmisc.cxx for the DLL and in svc_core.cxx for the
//              service.
//-----------------------------------------------------------------------------
HRESULT
InitGlobals(void)
{
    HRESULT hr = S_OK;

    //
    // Open the schedule agent key
    //
    long lErr;
    HKEY hSchedKey = NULL;
    lErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, SCH_AGENT_KEY, 0, KEY_READ,
                        &hSchedKey);
    if (lErr != ERROR_SUCCESS)
    {
        ERR_OUT("RegOpenKeyEx of Scheduler key", lErr);
        //
        // The scheduler key is missing, create it.
        //
        DWORD disp = 0;
        lErr = RegCreateKeyEx(HKEY_LOCAL_MACHINE, SCH_AGENT_KEY, 0, NULL, 0,
                              KEY_SET_VALUE, NULL, &hSchedKey, &disp);
        if (lErr != ERROR_SUCCESS)
        {
            ERR_OUT("RegCreateKeyEx of Scheduler key", lErr);
            hSchedKey = NULL;
        }
    }

    TCHAR tszFolder[MAX_PATH + 1] = TEXT("");

    // Ensure null termination (registry doesn't guarantee this if not string data)
    tszFolder[MAX_PATH] = TEXT('\0');

    if (hSchedKey != NULL)
    {
        //
        // Get the jobs folder location
        //
        DWORD cb = MAX_PATH * sizeof(TCHAR);

        lErr = RegQueryValueEx(hSchedKey, SCH_FOLDER_VALUE, NULL, NULL,
                               (LPBYTE)tszFolder, &cb);

        if (lErr != ERROR_SUCCESS)
        {
            ERR_OUT("RegQueryValueEx of Scheduler TasksFolder value", lErr);
            //
            // The task folder value is missing, create it.
            //
            // Reopen the key with write access.
            //
            RegCloseKey(hSchedKey);

            lErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, SCH_AGENT_KEY, 0,
                                KEY_SET_VALUE, &hSchedKey);
            if (lErr != ERROR_SUCCESS)
            {
                ERR_OUT("RegOpenKeyEx of Scheduler key", lErr);
                hSchedKey = NULL;
            }
            else
            {
                //
                // Default to the windows root.
                //
                lErr = RegSetValueEx(hSchedKey,
                                     SCH_FOLDER_VALUE,
                                     0,
                                     REG_EXPAND_SZ,
                                     (const BYTE *) DEFAULT_FOLDER_PATH,
                                     sizeof(DEFAULT_FOLDER_PATH));

                if (lErr != ERROR_SUCCESS)
                {
                    ERR_OUT("RegSetValueEx of Scheduler TasksFolder value",
                            lErr);
                }
            }
        }

        //
        // Read the "NotifyOnTaskMiss" value.  Default value is 0.
        //
        cb = sizeof g_fNotifyMiss;
        lErr = RegQueryValueEx(hSchedKey, SCH_NOTIFYMISS_VALUE, NULL, NULL,
                               (LPBYTE) &g_fNotifyMiss, &cb);
        if (lErr != ERROR_SUCCESS)
        {
            if (lErr != ERROR_FILE_NOT_FOUND)
            {
                ERR_OUT("RegQueryValueEx of NotifyOnTaskMiss value", lErr);
            }
            g_fNotifyMiss = 0;
        }
        schDebugOut((DEB_TRACE, "Notification of missed runs is %s\n",
                     g_fNotifyMiss ? "enabled" : "disabled"));

        if (hSchedKey != NULL)
        {
            RegCloseKey(hSchedKey);
        }
    }

    if (lstrlen(tszFolder) == 0)
    {
        //
        // Use a default if the value is missing.
        //
        lstrcpy(tszFolder, DEFAULT_FOLDER_PATH);
    }

    //
    // The ExpandEnvironmentStrings character counts include the terminating
    // null.
    //
    TCHAR tszDummy[1];
    DWORD cch = ExpandEnvironmentStrings(tszFolder, tszDummy, 1);
    if (!cch)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ERR_OUT("ExpandEnvironmentStrings", hr);
        return hr;
    }

    g_TasksFolderInfo.ptszPath = new TCHAR[cch];
    if (g_TasksFolderInfo.ptszPath == NULL)
    {
        ERR_OUT("Tasks Folder name buffer allocation", E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }

    cch = ExpandEnvironmentStrings(tszFolder, g_TasksFolderInfo.ptszPath,
                                        cch);
    if (!cch)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ERR_OUT("ExpandEnvironmentStrings", hr);
        return hr;
    }
    //
    // if the Jobs folder doesn't exist, create it
    //
    hr = CreateFolders(g_TasksFolderInfo.ptszPath, FALSE);
    if (FAILED(hr))
    {
        ERR_OUT("InitGlobals, CreateFolders", hr);
        return hr;
    }

    //
    // Initialize the file system type global task folder info field.
    // Always FAT on Win95.
    //

#if defined(_CHICAGO_)
    g_TasksFolderInfo.FileSystemType = FILESYSTEM_FAT;

#else
    hr = GetFileSystemTypeFromPath(g_TasksFolderInfo.ptszPath,
                                   &g_TasksFolderInfo.FileSystemType);

    if (FAILED(hr))
    {
        return hr;
    }
#endif // defined(_CHICAGO_)

    schDebugOut((DEB_ITRACE,
                 "Path to local sched folder: \"" FMT_TSTR "\"\n",
                 g_TasksFolderInfo.ptszPath));

#if !defined(_CHICAGO_)
    //
    // Create the AT task FindFirstFile filespec
    //

    ULONG cchAtJobSearchPath;

    cchAtJobSearchPath = lstrlen(g_TasksFolderInfo.ptszPath) +
                         ARRAY_LEN(TSZ_AT_JOB_PREFIX) - 1 +
                         ARRAY_LEN(TSZ_DOTJOB) - 1 +
                         3; // backslash, start, and nul terminator

    if (cchAtJobSearchPath > ARRAY_LEN(g_wszAtJobSearchPath))
    {
        schDebugOut((DEB_ERROR,
                    "InitGlobals: At job search path is %u chars but dest buffer is %u\n",
                    cchAtJobSearchPath,
                    ARRAY_LEN(g_wszAtJobSearchPath)));
        return E_FAIL;
    }

    lstrcpy(g_wszAtJobSearchPath, g_TasksFolderInfo.ptszPath);
    lstrcat(g_wszAtJobSearchPath, L"\\" TSZ_AT_JOB_PREFIX L"*" TSZ_DOTJOB);
#endif // !defined(_CHICAGO_)

    //
    // BUGBUG: This is temporary until global __int64 initialization is working
    // without the CRT:
    //
    FILETIMES_PER_DAY = (__int64)FILETIMES_PER_MINUTE *
                        (__int64)JOB_MINS_PER_HOUR *
                        (__int64)JOB_HOURS_PER_DAY;
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   FreeGlobals
//
//  Synopsis:   frees dynamically allocated globals
//
//  Notes:      This function is called in exactly two places, once for each
//              binary: in dllmisc.cxx for the DLL and in svc_core.cxx for the
//              service.
//-----------------------------------------------------------------------------
void
FreeGlobals(void)
{
    if (g_TasksFolderInfo.ptszPath != NULL)
    {
        delete g_TasksFolderInfo.ptszPath;
        g_TasksFolderInfo.ptszPath = NULL;
    }
}


//+----------------------------------------------------------------------------
//
//  Function:   ReadLastTaskRun
//
//  Synopsis:   Reads the last task run time from the registry.
//
//  Returns:    TRUE if successful, FALSE if unsuccessful
//
//  Notes:
//
//-----------------------------------------------------------------------------
BOOL
ReadLastTaskRun(SYSTEMTIME * pstLastRun)
{
    HKEY hSchedKey;
    LONG lErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, SCH_AGENT_KEY, 0, KEY_READ,
                             &hSchedKey);
    if (lErr != ERROR_SUCCESS)
    {
        ERR_OUT("RegOpenKeyEx of Sched key", lErr);
        return FALSE;
    }

    DWORD cb = sizeof SYSTEMTIME;
    DWORD dwType;
    lErr = RegQueryValueEx(hSchedKey, SCH_LASTRUN_VALUE, NULL, &dwType,
                           (LPBYTE)pstLastRun, &cb);

    RegCloseKey(hSchedKey);

    if (lErr != ERROR_SUCCESS || dwType != REG_BINARY || cb != sizeof SYSTEMTIME)
    {
        schDebugOut((DEB_ERROR, "RegQueryValueEx of LastRunTime value failed, "
                                "error %ld, dwType = %lu, cb = %lu\n",
                                lErr, dwType, cb));
        return FALSE;
    }

    return TRUE;
}


//+----------------------------------------------------------------------------
//
//  Function:   WriteLastTaskRun
//
//  Synopsis:   Writes the last task run time to the registry.
//
//  Returns:    TRUE if successful, FALSE if unsuccessful
//
//  Notes:
//
//-----------------------------------------------------------------------------
void WriteLastTaskRun(const SYSTEMTIME * pstLastRun)
{
    HKEY hSchedKey;
    LONG lErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, SCH_AGENT_KEY, 0, KEY_WRITE,
                             &hSchedKey);
    if (lErr != ERROR_SUCCESS)
    {
        ERR_OUT("RegOpenKeyEx of Sched key for write", lErr);
        return;
    }

    lErr = RegSetValueEx(hSchedKey, SCH_LASTRUN_VALUE, 0, REG_BINARY,
                         (const BYTE *) pstLastRun, sizeof SYSTEMTIME);

    if (lErr != ERROR_SUCCESS)
    {
        schDebugOut((DEB_ERROR, "RegSetValueEx of LastRunTime value failed %ld\n",
                                lErr));
    }

    RegCloseKey(hSchedKey);
}


#if !defined(_CHICAGO_)
//+---------------------------------------------------------------------------
//
//  Function:   GetFileSystemTypeFromPath
//
//  Synopsis:   Determine the file system type, either FAT or NTFS, from
//              the path passed.
//
//  Arguments:  [pwszPath]     -- Input path.
//              [wszRootPath]  -- Returned root path.
//
//  Returns:    S_OK
//              GetVolumeInformation HRESULT error code.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
GetFileSystemTypeFromPath(LPCWSTR pwszPath, FILESYSTEMTYPE * pFileSystemType)
{
#define FS_NTFS             L"NTFS"
#define FS_NAME_BUFFER_SIZE (sizeof(FS_NTFS) * 2)

    //
    // Obtain the root path (eg: "r:\", "\\fido\scratch\", etc.) from the
    // path.
    //

    LPWSTR pwszRootPath = new WCHAR[wcslen(pwszPath) + 2];
    if (pwszRootPath == NULL)
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        return E_OUTOFMEMORY;
    }

    GetRootPath(pwszPath, pwszRootPath);

    //
    // Retrieve the file system name.
    //

    WCHAR wszFileSystemName[FS_NAME_BUFFER_SIZE + 1];
    DWORD dwMaxCompLength, dwFileSystemFlags;

    if (!GetVolumeInformation(pwszRootPath,         // Root path name.
                              NULL,                 // Ignore name.
                              0,
                              NULL,                 // Ignore serial no.
                              &dwMaxCompLength,     // Unused.
                              &dwFileSystemFlags,   // Unused.
                              wszFileSystemName,    // "FAT"/"NTFS".
                              FS_NAME_BUFFER_SIZE)) // name buffer size.
    {
        HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
        CHECK_HRESULT(hr);
        delete [] pwszRootPath;
        return hr;
    }

    delete [] pwszRootPath;

    //
    // Check if the volume is NTFS.
    // If not NTFS, assume FAT.
    //

    if (_wcsicmp(wszFileSystemName, FS_NTFS) == 0)
    {
        *pFileSystemType = FILESYSTEM_NTFS;
    }
    else
    {
        *pFileSystemType = FILESYSTEM_FAT;
    }

    return(S_OK);
}
#endif // !defined(_CHICAGO_)

#if !defined(_CHICAGO_)
//+---------------------------------------------------------------------------
//
//  Function:   GetRootPath
//
//  Synopsis:   Return the root portion of the path indicated. eg: return
//                  "r:\" from "r:\foo\bar"
//                   "\\fido\scratch\", from "\\fido\scratch\bar\foo"
//
//  Arguments:  [pwszPath]     -- Input path.
//              [wszRootPath]  -- Returned root path.
//
//  Returns:    None.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
void
GetRootPath(LPCWSTR pwszPath, WCHAR wszRootPath[])
{
    LPCWSTR pwsz = pwszPath;

    if (*pwsz == L'\\')
    {
        if (*(++pwsz) == L'\\')
        {
            //
            // UNC path. GetVolumeInformation requires the trailing '\'
            // on the UNC path. eg: \\server\share\.
            //

            DWORD i;
            for (i = 0, pwsz++; *pwsz && i < 2; i++, pwsz++)
            {
                for ( ; *pwsz && *pwsz != L'\\'; pwsz++) ;
            }
            if (i == 2)
            {
                pwsz--;
            }
            else
            {
                goto ErrorExit;
            }
        }
        else
        {
            //
            // Path is "\".  Not an error, but handled the same way
            //
            goto ErrorExit;
        }
    }
    else
    {
        for ( ; *pwsz && *pwsz != L'\\'; pwsz++) ;
    }

    if (*pwsz == L'\\')
    {
        DWORD cbLen = (DWORD)((BYTE *)pwsz - (BYTE *)pwszPath) + sizeof(L'\\');
        CopyMemory((LPWSTR)wszRootPath, (LPWSTR)pwszPath, cbLen);
        wszRootPath[cbLen / sizeof(WCHAR)] = L'\0';
        return;
    }
    else
    {
        //
        // Fall through.
        //
    }

ErrorExit:
    //
    // Return '\' in error cases.
    //

    wszRootPath[0] = L'\\';
    wszRootPath[1] = L'\0';
}
#endif // !defined(_CHICAGO_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\common\network.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       network.cxx
//
//  Contents:   Network-related helper routines.
//
//  Classes:    None.
//
//  Functions:  None.
//
//  History:    08-Jul-96   MarkBl  Created
//
//----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "..\inc\debug.hxx"
#include "..\inc\network.hxx"

typedef DWORD (WINAPI * PWNETGETUNIVERSALNAMEW)(
                                    LPCWSTR,
                                    DWORD,
                                    LPVOID,
                                    LPDWORD);


//+----------------------------------------------------------------------------
//
//  Function:   GetServerNameFromPath
//
//  Synopsis:   Return the server name, in UNC form, to which the path
//              resolves. If the path resolves locally, the server name
//              returned is NULL.
//
//  Arguments:  [pwszPath]        -- Drive-based or UNC path.
//              [cbUNCPath]       -- Caller allocated buffer size.
//              [wszUNCPath]      -- Caller allocated buffer to temporarilly
//                                   store the full UNC path. A terminating
//                                   character will be written following the
//                                   server name, so don't expect to use
//                                   the UNC path afterward.
//              [ppwszServerName] -- Server name ptr. If non-NULL, it indexes
//                                   wszBuffer.
//
//  Returns:    S_OK - The path was local or the server name was obtained
//                  sucessfully from the remote path.
//              E_FAIL - Something unexpected occurred (should never happen).
//              WNetGetUniversalName error (HRESULT) - When the path is a
//                  remote path and this call fails for some reason.
//
//-----------------------------------------------------------------------------
HRESULT
GetServerNameFromPath(
    LPCWSTR  pwszPath,
    DWORD    cbBufferSize,
    WCHAR    wszBuffer[],
    WCHAR ** ppwszServerName)
{
#define MPR_DLL             TEXT("MPR.DLL")
#define WNET_GET_UNIVERSAL  "WNetGetUniversalNameW"

    schAssert(pwszPath != NULL);

    static TCHAR            wszDoubleBackslash[] = TEXT("\\\\");
    PWNETGETUNIVERSALNAMEW  pWNetGetUniversalNameW = NULL;
    WCHAR *                 pwszServerName;
    DWORD                   cbBufferSizeLocal = cbBufferSize;
    DWORD                   Status;
    HMODULE                 hMod;

    //
    // Is the path provided already a UNC path?
    //

    if (pwszPath[1] == L'\\')
    {
        wcscpy(wszBuffer, pwszPath);
        goto ParseServerName;
    }

    //
    // Dynamically load/unload mpr.dll to save memory in Win95. Yes, we'll
    // take a time hit, but we don't want mpr.dll loaded long-term.
    //

    hMod = LoadLibrary(MPR_DLL);

    if (hMod == NULL)
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        return(HRESULT_FROM_WIN32(GetLastError()));
    }
    else
    {
        pWNetGetUniversalNameW = (PWNETGETUNIVERSALNAMEW)
                                            GetProcAddress(
                                                        hMod,
                                                        WNET_GET_UNIVERSAL);

        if (pWNetGetUniversalNameW == NULL)
        {
            FreeLibrary(hMod);
            CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
            return(HRESULT_FROM_WIN32(GetLastError()));
        }
    }

    Status = pWNetGetUniversalNameW(pwszPath,
                                    UNIVERSAL_NAME_INFO_LEVEL,
                                    wszBuffer,
                                    &cbBufferSizeLocal);

    FreeLibrary(hMod);

    if (Status == NO_ERROR)
    {
ParseServerName:

        pwszServerName = wszBuffer;

        if (cbBufferSizeLocal > sizeof(wszDoubleBackslash))
        {
            //
            // Isolate server name from full UNC resource path.
            //

            pwszServerName += (sizeof(wszDoubleBackslash) /
                                                    sizeof(WCHAR)) - 1;

            for (WCHAR * pwsz = pwszServerName; *pwsz; pwsz++)
            {
                if (*pwsz == L'\\')
                {
                    *pwsz = L'\0';
                    break;
                }
            }

            *ppwszServerName = pwszServerName;
        }
        else
        {
            //
            // This should *never* occur.
            //

            schAssert(cbBufferSizeLocal > sizeof(wszDoubleBackslash));
            return(E_FAIL);
        }
    }
    else if (Status == ERROR_NOT_CONNECTED)
    {
        *ppwszServerName = NULL;
    }
    else
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(Status));
        return(HRESULT_FROM_WIN32(Status));
    }

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\common\misc.cxx ===
//+---------------------------------------------------------------------------
//
//  Scheduling Agent Service
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       misc.cxx
//
//  Contents:   Miscellaneous helper functions
//
//  Classes:    None.
//
//  Functions:  StringFromTrigger, CreateFolders, GetDaysOfWeekString,
//              GetExitCodeString, GetSageExitCodeString
//
//  History:    08-Dec-95   EricB   Created.
//
//----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include <regstr.h> // for app path reg key constant

#include "..\inc\resource.h"
#include "..\inc\misc.hxx"
#include "..\inc\debug.hxx"

const TCHAR PATH_ENV_VAR[] = TEXT("PATH");

static const CHAR gszJobScheduler[] = "SOFTWARE\\Microsoft\\SchedulingAgent";

static LCID sg_lcid = GetUserDefaultLCID();

HRESULT GetMonthsString(WORD rgfMonths, LPTSTR ptszBuf, UINT cchBuf);




//+---------------------------------------------------------------------------
//
//  Function:   UnicodeToAnsi
//
//  Synopsis:   Convert unicode string [pwsz] to multibyte in buffer [sz].
//
//  Arguments:  [szTo]     - destination buffer
//              [pwszFrom] - source string
//              [cbTo]     - size of destination buffer, in bytes
//
//  Returns:    S_OK               - conversion succeeded
//              HRESULT_FROM_WIN32 - WideCharToMultiByte failed
//
//  Modifies:   *[szTo]
//
//  History:    10-29-96   DavidMun   Created
//
//  Notes:      The string in [szTo] will be NULL terminated even on
//              failure.
//
//----------------------------------------------------------------------------

HRESULT
UnicodeToAnsi(
    LPSTR   szTo,
    LPCWSTR pwszFrom,
    ULONG   cbTo)
{
    HRESULT hr = S_OK;
    ULONG   cbWritten;

    cbWritten = WideCharToMultiByte(CP_ACP,
                                    0,
                                    pwszFrom,
                                    -1,
                                    szTo,
                                    cbTo,
                                    NULL,
                                    NULL);

    if (!cbWritten)
    {
        szTo[cbTo - 1] = '\0'; // ensure NULL termination

        hr = HRESULT_FROM_WIN32(GetLastError());
        schDebugOut((DEB_ERROR,
                     "UnicodeToAnsi: WideCharToMultiByte hr=0x%x\n",
                     hr));
    }
    return hr;
}




//+---------------------------------------------------------------------------
//
//  Function:   AnsiToUnicode
//
//  Synopsis:   Convert ANSI string [szFrom] to Unicode string in buffer
//              [pwszTo].
//
//  Arguments:  [pwszTo] - destination buffer
//              [szFrom] - source string
//              [cchTo]  - size of destination buffer, in WCHARS
//
//  Returns:    S_OK               - conversion succeeded
//              HRESULT_FROM_WIN32 - MultiByteToWideChar failed
//
//  Modifies:   *[pwszTo]
//
//  History:    10-29-96   DavidMun   Created
//
//  Notes:      The string in [pwszTo] will be NULL terminated even on
//              failure.
//
//----------------------------------------------------------------------------

HRESULT
AnsiToUnicode(
    LPWSTR pwszTo,
    LPCSTR szFrom,
    LONG   cchTo)
{
    HRESULT hr = S_OK;
    ULONG   cchWritten;

    cchWritten = MultiByteToWideChar(CP_ACP, 0, szFrom, -1, pwszTo, cchTo);

    if (!cchWritten)
    {
        pwszTo[cchTo - 1] = L'\0';  // ensure NULL termination

        hr = HRESULT_FROM_WIN32(GetLastError());
        schDebugOut((DEB_ERROR,
                     "AnsiToUnicode: MultiByteToWideChar hr=0x%x\n",
                     hr));
    }
    return hr;
}




//+----------------------------------------------------------------------------
//
//  Function:   StringFromTrigger
//
//  Synopsis:   Returns the string representation of the passed in trigger
//              data structure.
//
//  Arguments:  [pTrigger]     - the TASK_TRIGGER struct
//              [ppwszTrigger] - the returned string
//              [lpDetails]    - the SHELLDETAILS struct
//
//  Returns:    HRESULTS
//
//  Notes:      The string is allocated by this function with CoTaskMemAlloc
//              and is caller freed with CoTaskMemFree.
//
//              A non-event trigger string is composed of three parts: the
//              daily portion (tszDaily) which states when during the day the
//              trigger will fire, a trigger type portion (tszTrigType) which
//              states what days the trigger will fire, and the calendar
//              bracketing portion (tszStartDate and optionally tszEndDate).
//-----------------------------------------------------------------------------
HRESULT
StringFromTrigger(const PTASK_TRIGGER pTrigger, LPWSTR * ppwszTrigger, LPSHELLDETAILS lpDetails)
{
    if (IsBadWritePtr(ppwszTrigger, sizeof(WCHAR *)))
    {
        return E_INVALIDARG;
    }
    *ppwszTrigger = NULL;
    HRESULT hr;
    UINT uStrID = 0;
    DWORD dwDateFlags;

    TCHAR tszNumFmt[] = TEXT("%d");
    TCHAR tszNumber[SCH_SMBUF_LEN];
    TCHAR tszDOW[SCH_BIGBUF_LEN];
    TCHAR tszWhichWeek[SCH_MED0BUF_LEN];
    TCHAR tszMedBuf[SCH_MED0BUF_LEN];
    TCHAR tszBigBuf[SCH_XBIGBUF_LEN];
    TCHAR tszFormat[SCH_BUF_LEN];
    TCHAR tszTrigType[SCH_BIGBUF_LEN];
    LPTSTR rgptsz[5];

    //
    // If the trigger has not been set, return a phrase to that effect.
    //
    if (pTrigger->rgFlags & JOB_TRIGGER_I_FLAG_NOT_SET)
    {
        uStrID = IDS_TRIGGER_NOT_SET;
        goto DoString;
    }

    //
    // Compose the trigger-type string tszTrigType.
    //
    switch (pTrigger->TriggerType)
    {
    case TASK_TIME_TRIGGER_ONCE:
        //
        // Nothing to do here, handled below.
        //
        break;

    case TASK_EVENT_TRIGGER_ON_IDLE:
        //
        // Event triggers. Since event triggers don't have a set run time,
        // they load a string from the resource fork that describes the
        // event.
        //
        uStrID = IDS_IDLE_TRIGGER;
        break;

    case TASK_EVENT_TRIGGER_AT_SYSTEMSTART:
        //
        // Event trigger.
        //
        uStrID = IDS_STARTUP_TRIGGER;
        break;

    case TASK_EVENT_TRIGGER_AT_LOGON:
        //
        // Event trigger.
        //
        uStrID = IDS_LOGON_TRIGGER;
        break;

// Not yet implemented:
//    case TASK_EVENT_TRIGGER_ON_APM_RESUME:
//        //
//        // Event trigger.
//        //
//        uStrID = IDS_RESUME_TRIGGER;
//        break;

    case TASK_TIME_TRIGGER_DAILY:
        //
        // Run every n days.
        //
        if (pTrigger->Type.Daily.DaysInterval == 1)
        {
            //
            // Run every day.
            //
            if (!LoadString(g_hInstance, IDS_EVERY_DAY, tszTrigType,
                            SCH_BIGBUF_LEN))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                ERR_OUT("Create trigger string: LoadString", hr);
                return hr;
            }
        }
        else
        {
            //
            // Run every DaysInterval days: "every %d days"
            //
            if (!LoadString(g_hInstance, IDS_DAILY_FORMAT, tszFormat,
                            SCH_BUF_LEN))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                ERR_OUT("Create trigger string: LoadString", hr);
                return hr;
            }
            wsprintf(tszTrigType, tszFormat,
                     pTrigger->Type.Daily.DaysInterval);
        }
        break;

    case TASK_TIME_TRIGGER_WEEKLY:
        //
        // Run on mon, tues, etc every n weeks.
        //
        hr = GetDaysOfWeekString(pTrigger->Type.Weekly.rgfDaysOfTheWeek,
                                 tszDOW, SCH_BUF_LEN);
        if (FAILED(hr))
        {
            return hr;
        }

        if (pTrigger->Type.Weekly.WeeksInterval == 1)
        {
            //
            // Run every week: "every %s of every week"
            //
            if (!LoadString(g_hInstance, IDS_EVERY_WEEK_FORMAT, tszFormat,
                            SCH_BUF_LEN))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                ERR_OUT("Create trigger string: LoadString", hr);
                return hr;
            }
            wsprintf(tszTrigType, tszFormat, tszDOW);
        }
        else
        {
            //
            // Run every WeeksInterval weeks: "every %s of every %s weeks"
            //
            wsprintf(tszNumber, tszNumFmt,
                     pTrigger->Type.Weekly.WeeksInterval);

            rgptsz[0] = tszDOW;
            rgptsz[1] = tszNumber;

            if (!LoadString(g_hInstance, IDS_WEEKLY_FORMAT, tszFormat,
                            SCH_BUF_LEN))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                ERR_OUT("Create trigger string: LoadString", hr);
                return hr;
            }

            if (!FormatMessage(FORMAT_MESSAGE_FROM_STRING |
                               FORMAT_MESSAGE_ARGUMENT_ARRAY, tszFormat,
                               0, 0, tszTrigType, SCH_BIGBUF_LEN,
                               (va_list *)rgptsz))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                ERR_OUT("Create trigger string: FormatMessage", hr);
                return hr;
            }
        }
        break;

    case TASK_TIME_TRIGGER_MONTHLYDATE:
        //
        // On specific days of specific months.
        //
        //
        // Get the first run day and append etc if more than one.
        //
        WORD wFirstDay, cDays, i;
        cDays = 0;
        for (i = 0; i < JOB_DAYS_PER_MONTHMAX; i++)
        {
            if ((pTrigger->Type.MonthlyDate.rgfDays >> i) & 0x1)
            {
                cDays++;
                if (cDays == 1)
                {
                    wFirstDay = i + 1;
                }
            }
        }
        if (pTrigger->Type.MonthlyDate.rgfMonths == JOB_RGFMONTHS_MAX)
        {
            //
            // Every month: "on day %d(, etc.) of every month"
            //
            if (!LoadString(g_hInstance,
                            (cDays == 1) ? IDS_EVERY_MONTHLYDATE_FORMAT :
                                           IDS_EVERY_MONTHLYDATE_FORMAT_ETC,
                            tszFormat, SCH_BUF_LEN))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                ERR_OUT("Create trigger string: LoadString", hr);
                return hr;
            }
            wsprintf(tszTrigType, tszFormat, wFirstDay);
        }
        else
        {
            //
            // Specific months: "on day %s of %s"
            //
            wsprintf(tszNumber, tszNumFmt, wFirstDay);
            hr = GetMonthsString(pTrigger->Type.MonthlyDate.rgfMonths,
                                 tszBigBuf, SCH_XBIGBUF_LEN);
            if (FAILED(hr))
            {
                return hr;
            }

            rgptsz[0] = tszNumber;
            rgptsz[1] = tszBigBuf;

            if (!LoadString(g_hInstance,
                            (cDays == 1) ? IDS_MONTHLYDATE_FORMAT :
                                           IDS_MONTHLYDATE_FORMAT_ETC,
                            tszFormat, SCH_BUF_LEN))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                ERR_OUT("Create trigger string: LoadString", hr);
                return hr;
            }

            if (!FormatMessage(FORMAT_MESSAGE_FROM_STRING |
                               FORMAT_MESSAGE_ARGUMENT_ARRAY, tszFormat, 0, 0,
                               tszTrigType, SCH_BIGBUF_LEN, (va_list *)rgptsz))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                ERR_OUT("Create trigger string: FormatMessage", hr);
                return hr;
            }
        }
        break;

    case TASK_TIME_TRIGGER_MONTHLYDOW:
        //
        // On certain weeks of specific months.
        //

        if (!LoadString(g_hInstance,
                        IDS_FIRST + pTrigger->Type.MonthlyDOW.wWhichWeek - 1,
                        tszWhichWeek, SCH_MED0BUF_LEN))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            ERR_OUT("Create trigger string: LoadString", hr);
            return hr;
        }

        hr = GetDaysOfWeekString(pTrigger->Type.MonthlyDOW.rgfDaysOfTheWeek,
                                 tszDOW, SCH_BUF_LEN);
        if (FAILED(hr))
        {
            return hr;
        }

        if (pTrigger->Type.MonthlyDOW.rgfMonths == JOB_RGFMONTHS_MAX)
        {
            //
            // Runs every month: " on the %s %s of every month"
            //
            rgptsz[0] = tszWhichWeek;
            rgptsz[1] = tszDOW;

            if (!LoadString(g_hInstance, IDS_EVERY_MONTHLYDOW_FORMAT,
                            tszFormat, SCH_BUF_LEN))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                ERR_OUT("Create trigger string: LoadString", hr);
                return hr;
            }

            if (!FormatMessage(FORMAT_MESSAGE_FROM_STRING |
                               FORMAT_MESSAGE_ARGUMENT_ARRAY, tszFormat, 0, 0,
                               tszTrigType, SCH_BIGBUF_LEN, (va_list *)rgptsz))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                ERR_OUT("Create trigger string: FormatMessage", hr);
                return hr;
            }
        }
        else
        {
            //
            // Runs on specific months:
            // "on the %s %s of %s"
            //
            hr = GetMonthsString(pTrigger->Type.MonthlyDOW.rgfMonths,
                                 tszBigBuf, SCH_XBIGBUF_LEN);
            if (FAILED(hr))
            {
                return hr;
            }

            rgptsz[0] = tszWhichWeek;
            rgptsz[1] = tszDOW;
            rgptsz[2] = tszBigBuf;

            if (!LoadString(g_hInstance, IDS_MONTHLYDOW_FORMAT, tszFormat,
                            SCH_BUF_LEN))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                ERR_OUT("Create trigger string: LoadString", hr);
                return hr;
            }

            if (!FormatMessage(FORMAT_MESSAGE_FROM_STRING |
                               FORMAT_MESSAGE_ARGUMENT_ARRAY, tszFormat, 0, 0,
                               tszTrigType, SCH_BIGBUF_LEN, (va_list *)rgptsz))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                ERR_OUT("Create trigger string: FormatMessage", hr);
                return hr;
            }
        }
        break;

    default:
        schDebugOut((DEB_ERROR, "invalid TriggerType value: 0x%x\n",
                     pTrigger->TriggerType));
        return ERROR_INVALID_DATA;
    }

DoString:

    //
    // Event trigger or Daily part.
    //
    TCHAR tszTriggerString[SCH_XBIGBUF_LEN];
    TCHAR tszStartDate[SCH_DATEBUF_LEN];
    TCHAR tszEndDate[SCH_DATEBUF_LEN];
    TCHAR tszDaily[SCH_BUF_LEN];

    switch (uStrID)
    {
    case IDS_RESUME_TRIGGER:
    case IDS_STARTUP_TRIGGER:
    case IDS_LOGON_TRIGGER:
    case IDS_IDLE_TRIGGER:
    case IDS_TRIGGER_NOT_SET:
        //
        // Event-based or invalid trigger, load the description string.
        //
        if (!LoadString(g_hInstance, uStrID, tszTriggerString,
                        SCH_XBIGBUF_LEN))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            ERR_OUT("Create trigger string, LoadString", hr);
            return hr;
        }
        break;

    case 0:
        //
        // It is a time-based trigger.
        //
        TCHAR tszNum[SCH_SMBUF_LEN];

        //
        // Get the daily run time(s): tszDaily.
        //
        TCHAR tszFromTime[SCH_TIMEBUF_LEN];
        TCHAR tszToTime[SCH_TIMEBUF_LEN];
        SYSTEMTIME st = {0};
        st.wHour = pTrigger->wStartHour;
        st.wMinute = pTrigger->wStartMinute;

        if (!GetTimeFormat(sg_lcid, TIME_NOSECONDS, &st, NULL,
                           tszFromTime, SCH_TIMEBUF_LEN))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            ERR_OUT("Create trigger string: GetTimeFormat", hr);
            return hr;
        }

        if (pTrigger->MinutesInterval == 0)
        {
            //
            // Runs once a day at a specific time.
            //
            if (!LoadString(g_hInstance, IDS_ONCE_DAY_FORMAT, tszFormat,
                            SCH_BUF_LEN))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                ERR_OUT("Create trigger string: LoadString", hr);
                return hr;
            }
            wsprintf(tszDaily, tszFormat, tszFromTime);
        }
        else
        {
            //
            // On an interval daily from a starting time for a specified
            // number of minutes.
            //
            UINT uIntTimeStr, uDurTimeStr, uIntStr;
            if (pTrigger->MinutesInterval % JOB_MINS_PER_HOUR)
            {
                //
                // Runs on a minutes schedule.
                //
                wsprintf(tszNum, tszNumFmt, pTrigger->MinutesInterval);
                uIntTimeStr = IDS_MINUTES_PAREN;
            }
            else
            {
                //
                // Runs on an hourly schedule.
                //
                wsprintf(tszNum, tszNumFmt,
                         pTrigger->MinutesInterval / JOB_MINS_PER_HOUR);
                uIntTimeStr = IDS_HOURS_PAREN;
            }

            TCHAR tszDuration[SCH_SMBUF_LEN];
            TCHAR tszTimePart[SCH_MED0BUF_LEN];

            if (!LoadString(g_hInstance, uIntTimeStr, tszTimePart,
                            SCH_MED0BUF_LEN))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                ERR_OUT("Create trigger string: LoadString", hr);
                return hr;
            }

            if (pTrigger->rgFlags & JOB_TRIGGER_I_FLAG_DURATION_AS_TIME)
            {
                WORD wMinutes = pTrigger->wStartHour * JOB_MINS_PER_HOUR
                                + pTrigger->wStartMinute;
                wMinutes += (WORD)pTrigger->MinutesDuration;
                while (wMinutes > JOB_MINS_PER_DAY)
                {
                    wMinutes -= JOB_MINS_PER_DAY;
                }
                st.wHour = wMinutes / JOB_MINS_PER_HOUR;
                st.wMinute = wMinutes % JOB_MINS_PER_HOUR;
                if (!GetTimeFormat(sg_lcid, TIME_NOSECONDS, &st, NULL,
                                   tszToTime, SCH_TIMEBUF_LEN))
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    ERR_OUT("Create trigger string: GetTimeFormat", hr);
                    return hr;
                }
                uIntStr = IDS_MULTI_DAILY_FORMAT;

                rgptsz[0] = tszNum;
                rgptsz[1] = tszTimePart;
                rgptsz[2] = tszFromTime;
                rgptsz[3] = tszToTime;
            }
            else
            {
                if (pTrigger->MinutesDuration % JOB_MINS_PER_HOUR)
                {
                    //
                    // Express the duration in minutes.
                    //
                    wsprintf(tszDuration, tszNumFmt, pTrigger->MinutesDuration);
                    uDurTimeStr = IDS_MINUTES;
                }
                else
                {
                    //
                    // No remainder, so express the duration in hours.
                    //
                    wsprintf(tszDuration, tszNumFmt,
                             pTrigger->MinutesDuration / JOB_MINS_PER_HOUR);
                    uDurTimeStr = IDS_HOURS_PAREN;
                }

                if (!LoadString(g_hInstance, uDurTimeStr, tszToTime,
                                SCH_TIMEBUF_LEN))
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    ERR_OUT("Create trigger string: LoadString", hr);
                    return hr;
                }

                uIntStr = IDS_MULTI_DURATION_FORMAT;

                rgptsz[0] = tszNum;
                rgptsz[1] = tszTimePart;
                rgptsz[2] = tszFromTime;
                rgptsz[3] = tszDuration;
                rgptsz[4] = tszToTime;
            }

            if (!LoadString(g_hInstance, uIntStr, tszFormat, SCH_BUF_LEN))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                ERR_OUT("Create trigger string: LoadString", hr);
                return hr;
            }

            if (!FormatMessage(FORMAT_MESSAGE_FROM_STRING |
                               FORMAT_MESSAGE_ARGUMENT_ARRAY, tszFormat, 0, 0,
                               tszDaily, SCH_BUF_LEN, (va_list *)rgptsz))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                ERR_OUT("Create trigger string: FormatMessage", hr);
                return hr;
            }
        }

        //
        // Starting date: tszStartDate.
        //
        st.wYear = pTrigger->wBeginYear;
        st.wMonth = pTrigger->wBeginMonth;
        st.wDay = pTrigger->wBeginDay;
        dwDateFlags =  DATE_SHORTDATE;
#ifdef UNICODE
        if (lpDetails) {
            if (lpDetails->fmt & LVCFMT_RIGHT_TO_LEFT) {
                dwDateFlags |=  DATE_RTLREADING;
            } else if (lpDetails->fmt & LVCFMT_LEFT_TO_RIGHT) {
                dwDateFlags |=  DATE_LTRREADING;
            }
        }
#endif
        if (!GetDateFormat(sg_lcid, dwDateFlags, &st, NULL, tszStartDate,
                           SCH_DATEBUF_LEN))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            ERR_OUT("Create trigger string: GetDateFormat", hr);
            return hr;
        }

        //
        // Compose the complete trigger string from its parts.
        //
        if (pTrigger->TriggerType == TASK_TIME_TRIGGER_ONCE)
        {
            //
            // Trigger runs just on a single day: "%s on %s"
            //
            rgptsz[0] = tszDaily;
            rgptsz[1] = tszStartDate;

            if (!LoadString(g_hInstance, IDS_RUNS_ONCE_FORMAT, tszFormat,
                            SCH_BUF_LEN))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                ERR_OUT("Create trigger string: LoadString", hr);
                return hr;
            }

            if (!FormatMessage(FORMAT_MESSAGE_FROM_STRING |
                               FORMAT_MESSAGE_ARGUMENT_ARRAY, tszFormat, 0, 0,
                               tszTriggerString, SCH_XBIGBUF_LEN,
                               (va_list *)rgptsz))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                ERR_OUT("Create trigger string: FormatMessage", hr);
                return hr;
            }
        }
        else
        {
            if (pTrigger->rgFlags & TASK_TRIGGER_FLAG_HAS_END_DATE)
            {
                //
                // Job has an ending date.
                //
                st.wYear = pTrigger->wEndYear;
                st.wMonth = pTrigger->wEndMonth;
                st.wDay = pTrigger->wEndDay;
                dwDateFlags =  DATE_SHORTDATE;
#ifdef UNICODE
                if (lpDetails) {
                    if (lpDetails->fmt & LVCFMT_RIGHT_TO_LEFT) {
                        dwDateFlags |=  DATE_RTLREADING;
                    } else if (lpDetails->fmt & LVCFMT_LEFT_TO_RIGHT) {
                        dwDateFlags |=  DATE_LTRREADING;
                    }
                }
#endif
                if (!GetDateFormat(sg_lcid, dwDateFlags, &st, NULL,
                                   tszEndDate, SCH_DATEBUF_LEN))
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    ERR_OUT("Create trigger string, GetDateFormat", hr);
                    return hr;
                }
                //
                // Compose the trigger string with an end date.
                // "%s %s, starting %s & ending %s"
                //
                rgptsz[0] = tszDaily;
                rgptsz[1] = tszTrigType;
                rgptsz[2] = tszStartDate;
                rgptsz[3] = tszEndDate;

                if (!LoadString(g_hInstance, IDS_HAS_END_DATE_FORMAT,
                                tszFormat, SCH_BUF_LEN))
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    ERR_OUT("Create trigger string: LoadString", hr);
                    return hr;
                }

                if (!FormatMessage(FORMAT_MESSAGE_FROM_STRING |
                                   FORMAT_MESSAGE_ARGUMENT_ARRAY, tszFormat,
                                   0, 0, tszTriggerString, SCH_XBIGBUF_LEN,
                                   (va_list *)rgptsz))
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    ERR_OUT("Create trigger string: FormatMessage", hr);
                    return hr;
                }
            }
            else
            {
                //
                // Trigger does not have an ending date.
                // "%s %s, starting %s"
                //
                rgptsz[0] = tszDaily;
                rgptsz[1] = tszTrigType;
                rgptsz[2] = tszStartDate;

                if (!LoadString(g_hInstance, IDS_NO_END_DATE_FORMAT,
                                tszFormat, SCH_BUF_LEN))
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    ERR_OUT("Create trigger string: LoadString", hr);
                    return hr;
                }

                if (!FormatMessage(FORMAT_MESSAGE_FROM_STRING |
                                   FORMAT_MESSAGE_ARGUMENT_ARRAY, tszFormat,
                                   0, 0, tszTriggerString, SCH_XBIGBUF_LEN,
                                   (va_list *)rgptsz))
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    ERR_OUT("Create trigger string: FormatMessage", hr);
                    return hr;
                }
            }
        }
        break;
    }

    ULONG cb;
    //
    // Get the size to allocate for the returned string.
    //

#if defined(UNICODE)

    cb = wcslen(tszTriggerString) + 1;  // Include the null in the count.

#else

    cb = MultiByteToWideChar(CP_ACP, 0, tszTriggerString, -1, NULL, 0);

    if (!cb)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ERR_OUT("Create trigger string: MultiByteToWideChar", hr);
        return hr;
    }

#endif

    //
    // Allocate the returned string.
    //

    *ppwszTrigger = (LPWSTR)CoTaskMemAlloc(cb * sizeof(WCHAR));

    if (*ppwszTrigger == NULL)
    {
        return E_OUTOFMEMORY;
    }

#if defined(UNICODE)

    wcscpy(*ppwszTrigger, tszTriggerString);

#else   // convert ANSI string to UNICODE

    hr = AnsiToUnicode(*ppwszTrigger, tszTriggerString, cb);

    if (FAILED(hr))
    {
        CoTaskMemFree(*ppwszTrigger);
        *ppwszTrigger = NULL;
        ERR_OUT("Create trigger string: AnsiToUnicode", hr);
        return hr;
    }

#endif
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   GetDaysOfWeekString
//
//  Synopsis:   Builds a string containing the names of the days of the week
//              that correspond to bits set in the bitset array.
//
//  Arguments:  [rgfDaysOfTheWeek] - a bitset array.
//              [pwszBuf]          - return in this string buffer.
//              [cchBuf]           - size of string buffer.
//
//-----------------------------------------------------------------------------
HRESULT
GetDaysOfWeekString(WORD rgfDaysOfTheWeek, LPTSTR ptszBuf, UINT cchBuf)
{
    HRESULT hr;

    if (rgfDaysOfTheWeek == 0)
    {
        return E_INVALIDARG;
    }
    BOOL fMoreThanOne = FALSE;
    int cch;
    TCHAR tszSep[SCH_SMBUF_LEN];
    if (!LoadString(g_hInstance, IDS_LIST_SEP, tszSep, SCH_SMBUF_LEN))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ERR_OUT("GetDaysOfWeekString: LoadString", hr);
        return hr;
    }

    *ptszBuf = TEXT('\0');

    if (rgfDaysOfTheWeek & TASK_MONDAY)
    {
        if (!GetLocaleInfo(sg_lcid, LOCALE_SABBREVDAYNAME1, ptszBuf, cchBuf))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            ERR_OUT("GetLocaleInfo", hr);
            return hr;
        }
        fMoreThanOne = TRUE;
    }

    if (rgfDaysOfTheWeek & TASK_TUESDAY)
    {
        if (fMoreThanOne)
        {
            lstrcat(ptszBuf, tszSep);
        }
        cch = lstrlen(ptszBuf);
        if (!GetLocaleInfo(sg_lcid, LOCALE_SABBREVDAYNAME2, ptszBuf + cch,
                           cchBuf - cch))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            ERR_OUT("GetLocaleInfo", hr);
            return hr;
        }
        fMoreThanOne = TRUE;
    }
    if (rgfDaysOfTheWeek & TASK_WEDNESDAY)
    {
        if (fMoreThanOne)
        {
            lstrcat(ptszBuf, tszSep);
        }
        cch = lstrlen(ptszBuf);
        if (!GetLocaleInfo(sg_lcid, LOCALE_SABBREVDAYNAME3, ptszBuf + cch,
                           cchBuf - cch))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            ERR_OUT("GetLocaleInfo", hr);
            return hr;
        }
        fMoreThanOne = TRUE;
    }
    if (rgfDaysOfTheWeek & TASK_THURSDAY)
    {
        if (fMoreThanOne)
        {
            lstrcat(ptszBuf, tszSep);
        }
        cch = lstrlen(ptszBuf);
        if (!GetLocaleInfo(sg_lcid, LOCALE_SABBREVDAYNAME4, ptszBuf + cch,
                           cchBuf - cch))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            ERR_OUT("GetLocaleInfo", hr);
            return hr;
        }
        fMoreThanOne = TRUE;
    }
    if (rgfDaysOfTheWeek & TASK_FRIDAY)
    {
        if (fMoreThanOne)
        {
            lstrcat(ptszBuf, tszSep);
        }
        cch = lstrlen(ptszBuf);
        if (!GetLocaleInfo(sg_lcid, LOCALE_SABBREVDAYNAME5, ptszBuf + cch,
                           cchBuf - cch))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            ERR_OUT("GetLocaleInfo", hr);
            return hr;
        }
        fMoreThanOne = TRUE;
    }
    if (rgfDaysOfTheWeek & TASK_SATURDAY)
    {
        if (fMoreThanOne)
        {
            lstrcat(ptszBuf, tszSep);
        }
        cch = lstrlen(ptszBuf);
        if (!GetLocaleInfo(sg_lcid, LOCALE_SABBREVDAYNAME6, ptszBuf + cch,
                           cchBuf - cch))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            ERR_OUT("GetLocaleInfo", hr);
            return hr;
        }
        fMoreThanOne = TRUE;
    }
    if (rgfDaysOfTheWeek & TASK_SUNDAY)
    {
        if (fMoreThanOne)
        {
            lstrcat(ptszBuf, tszSep);
        }
        cch = lstrlen(ptszBuf);
        if (!GetLocaleInfo(sg_lcid, LOCALE_SABBREVDAYNAME7, ptszBuf + cch,
                           cchBuf - cch))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            ERR_OUT("GetLocaleInfo", hr);
            return hr;
        }
    }
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   GetMonthsString
//
//  Synopsis:   Builds a string containing the names of the months
//              that correspond to bits set in the bitset array.
//
//  Arguments:  [rgfMonths] - a bitset array.
//              [pwszBuf]   - return in this string buffer.
//              [cchBuf]    - size of string buffer.
//
//-----------------------------------------------------------------------------
HRESULT
GetMonthsString(WORD rgfMonths, LPTSTR ptszBuf, UINT cchBuf)
{
    if (rgfMonths == 0)
    {
        return E_INVALIDARG;
    }

    HRESULT hr;

    BOOL fMoreThanOne = FALSE;
    int cch;
    TCHAR tszSep[SCH_SMBUF_LEN];
    if (!LoadString(g_hInstance, IDS_LIST_SEP, tszSep, SCH_SMBUF_LEN))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ERR_OUT("GetMonthsString: LoadString", hr);
        return hr;
    }

    *ptszBuf = TEXT('\0');

    for (WORD i = 0; i < JOB_MONTHS_PER_YEAR; i++)
    {
        if ((rgfMonths >> i) & 0x1)
        {
            if (fMoreThanOne)
            {
                lstrcat(ptszBuf, tszSep);
            }
            cch = lstrlen(ptszBuf);
            if (!GetLocaleInfo(sg_lcid, LOCALE_SABBREVMONTHNAME1 + i,
                               ptszBuf + cch, cchBuf - cch))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                ERR_OUT("GetMonthsString: GetLocaleInfo", hr);
                return hr;
            }
            fMoreThanOne = TRUE;
        }
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   SchedMapRpcError
//
//  Purpose:    Remap RPC exception codes that are unsuitable for displaying
//              to the user to more comprehensible errors.
//
//  Arguments:  [dwError] - the error returned by RpcExceptionCode().
//
//  Returns:    An HRESULT.
//
//----------------------------------------------------------------------------
HRESULT
SchedMapRpcError(
    DWORD   dwError)
{
    HRESULT hr;

    if (dwError == EPT_S_NOT_REGISTERED)
    {
        hr = SCHED_E_SERVICE_NOT_RUNNING;
    }
    else
    {
        hr = HRESULT_FROM_WIN32(dwError);
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   ComposeErrorMsg
//
//  Purpose:    Take the two message IDs and the error code and create an
//              error reporting string that can be used by both service
//              logging and UI dialogs.
//
//  Arguments:  same as above.
//
//  Returns:    A string or NULL on failure.
//
//  Notes:      Release the string memory when done using LocalFree.
//
//----------------------------------------------------------------------------
LPTSTR
ComposeErrorMsg(
    UINT  uErrorClassMsgID,
    DWORD dwErrCode,
    UINT  uHelpHintMsgID,
    BOOL  fIndent)
{
    TCHAR szErrClassMsg[SCH_BIGBUF_LEN];

	    if (!LoadString(g_hInstance,
                     uErrorClassMsgID,
                     szErrClassMsg,
                     SCH_BIGBUF_LEN))
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        return NULL;
    }

    BOOL fDelete = FALSE;
    DWORD ccLength = 0;

    TCHAR szErrCode[SCH_MED0BUF_LEN], szGenericErr[SCH_BUF_LEN];
    TCHAR * psz;
	LPTSTR pszErrStr = NULL;
    DWORD dwWinErr = dwErrCode;

    if (dwErrCode != 0)
    {
        //
        // Format the error code as a hex string.
        //

        TCHAR szErrNumFormat[SCH_MED0BUF_LEN];

        if (!LoadString(g_hInstance,
                         IDS_ERROR_NUMBER_FORMAT,
                         szErrNumFormat,
                         SCH_MED0BUF_LEN))
        {
            CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
            return NULL;
        }

        wsprintf(szErrCode, szErrNumFormat, dwErrCode);

        //
        // If a Win32 error code, strip the HRESULT stuff.
        //

        if (HRESULT_FACILITY(dwErrCode) == FACILITY_WINDOWS ||
            HRESULT_FACILITY(dwErrCode) == FACILITY_WIN32)
        {
            dwWinErr = HRESULT_CODE(dwErrCode);
        }

        //
        // Try to obtain the error message from the system.
        //
        if (!(ccLength = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM |
                                           FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                        NULL,
                                        dwWinErr,
                                        LOCALE_SYSTEM_DEFAULT,
                                        (LPTSTR) &pszErrStr,
                                        1,
                                        NULL)))
        {
			DWORD di = GetLastError( );
            //
            // Well, that didn't work, so try to get it from the service.
            //
            if (!(ccLength = FormatMessage(FORMAT_MESSAGE_FROM_HMODULE |
                                               FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                            g_hInstance,
                                            dwErrCode,
                                            LOCALE_SYSTEM_DEFAULT,
                                            (LPTSTR) &pszErrStr,
                                            1,
                                            NULL)))
            {
                //
                // That didn't work either, so give a generic message.
                //
                if (!LoadString(g_hInstance,
                                 IDS_GENERIC_ERROR_MSG,
                                 szGenericErr,
                                 SCH_BUF_LEN))
                {
                    CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
                    return NULL;
                }
                pszErrStr = szGenericErr;
            }
        }

        if (ccLength != 0)
        {
            fDelete = TRUE;

            //
            // Overwrite \r\n with null characters.
            //
            psz = pszErrStr + ccLength - 2;

            *psz++ = '\0';
            *psz   = '\0';
        }
    }

    TCHAR * pwszLogStr = NULL;

    TCHAR * rgpszInserts[4];

    rgpszInserts[0] = szErrClassMsg;

    UINT uFormatID;

    TCHAR szHelpMsg[SCH_BIGBUF_LEN];

    if (uHelpHintMsgID == 0 && dwWinErr != 0)
    {
        //
        // Caller didn't specify a help hint.  Try to map the error to one.
        //

        switch (dwWinErr)
        {
        case ERROR_FILE_NOT_FOUND:
        case ERROR_PATH_NOT_FOUND:
        case ERROR_BAD_PATHNAME:
        case ERROR_DIRECTORY:
        case ERROR_ACCESS_DENIED:
        case ERROR_NO_NET_OR_BAD_PATH:
        case ERROR_INVALID_DRIVE:
        case ERROR_INVALID_COMPUTERNAME:
        case ERROR_INVALID_SHARENAME:
            uHelpHintMsgID = IDS_HELP_HINT_BROWSE;
            break;

        case ERROR_TOO_MANY_OPEN_FILES:
        case ERROR_NOT_ENOUGH_MEMORY:
        case ERROR_OUTOFMEMORY:
        case ERROR_TOO_MANY_NAMES:
        case ERROR_TOO_MANY_SESS:
        case ERROR_OUT_OF_STRUCTURES:
        case ERROR_NO_PROC_SLOTS:
        case ERROR_TOO_MANY_SEMAPHORES:
        case ERROR_NO_MORE_SEARCH_HANDLES:
        case ERROR_TOO_MANY_TCBS:
        case ERROR_MAX_THRDS_REACHED:
        case ERROR_DLL_INIT_FAILED:
        case ERROR_NO_SYSTEM_RESOURCES:
        case ERROR_NONPAGED_SYSTEM_RESOURCES:
        case ERROR_PAGED_SYSTEM_RESOURCES:
        case RPC_S_OUT_OF_RESOURCES:
            uHelpHintMsgID = IDS_HELP_HINT_CLOSE_APPS;
            break;

        case ERROR_NOT_SUPPORTED:
        case ERROR_REM_NOT_LIST:
        case ERROR_DUP_NAME:
        case ERROR_BAD_NETPATH:
        case ERROR_NETWORK_BUSY:
        case ERROR_DEV_NOT_EXIST:
        case ERROR_TOO_MANY_CMDS:
        case ERROR_ADAP_HDW_ERR:
        case ERROR_BAD_NET_RESP:
        case ERROR_UNEXP_NET_ERR:
        case ERROR_BAD_REM_ADAP:
        case ERROR_NETNAME_DELETED:
        case ERROR_NETWORK_ACCESS_DENIED:
        case ERROR_BAD_DEV_TYPE:
        case ERROR_BAD_NET_NAME:
        case ERROR_SHARING_PAUSED:
        case ERROR_REQ_NOT_ACCEP:
        case ERROR_REMOTE_SESSION_LIMIT_EXCEEDED:
        case ERROR_NO_NETWORK:
        case ERROR_NETWORK_UNREACHABLE:
        case ERROR_HOST_UNREACHABLE:
        case ERROR_PROTOCOL_UNREACHABLE:
        case ERROR_PORT_UNREACHABLE:
        case ERROR_CONNECTION_COUNT_LIMIT:
        case ERROR_NO_LOGON_SERVERS:
            uHelpHintMsgID = IDS_HELP_HINT_CALLPSS;
            break;

        case ERROR_BADDB:
        case ERROR_BADKEY:
        case ERROR_CANTOPEN:
        case ERROR_CANTREAD:
        case ERROR_CANTWRITE:
        case ERROR_REGISTRY_CORRUPT:
        case ERROR_REGISTRY_IO_FAILED:
        case ERROR_KEY_DELETED:
        case ERROR_DLL_NOT_FOUND:
            uHelpHintMsgID = IDS_HELP_HINT_REINSTALL;
            break;

        case EPT_S_NOT_REGISTERED:
            uHelpHintMsgID = IDS_HELP_HINT_STARTSVC;
            break;
        }
    }

    if (uHelpHintMsgID != 0)
    {
        //
        // A help hint string has been specified.
        //

        if (!LoadString(g_hInstance,
                         uHelpHintMsgID,
                         szHelpMsg,
                         SCH_BIGBUF_LEN))
        {
            CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
            goto CleanUp;
        }

        if (dwErrCode != 0)
        {
            //
            // An error code has also been given.
            //

            rgpszInserts[1] = szErrCode;
            rgpszInserts[2] = pszErrStr;
            rgpszInserts[3] = szHelpMsg;

            uFormatID = (fIndent ? IDS_ERROR_FORMAT_WCODE_WHELP_I :
                            IDS_ERROR_FORMAT_WCODE_WHELP);
        }
        else
        {
            //
            // Help string but no error code.
            //

            rgpszInserts[1] = szHelpMsg;

            uFormatID = (fIndent ? IDS_ERROR_FORMAT_WOCODE_WHELP_I :
                            IDS_ERROR_FORMAT_WOCODE_WHELP);
        }
    }
    else
    {
        //
        // No help hint.
        //

        if (dwErrCode != 0)
        {
            //
            // An error code has been given.
            //

            rgpszInserts[1] = szErrCode;
            rgpszInserts[2] = pszErrStr;

            uFormatID = (fIndent ? IDS_ERROR_FORMAT_WCODE_WOHELP_I :
                            IDS_ERROR_FORMAT_WCODE_WOHELP);
        }
        else
        {
            //
            // No help string or error code.
            //

            uFormatID = (fIndent ? IDS_ERROR_FORMAT_WOCODE_WOHELP_I :
                            IDS_ERROR_FORMAT_WOCODE_WOHELP);
        }
    }

    TCHAR szFormat[SCH_BIGBUF_LEN];

    if (!LoadString(g_hInstance,
                     uFormatID,
                     szFormat,
                     SCH_BIGBUF_LEN))
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        goto CleanUp;
    }

    if (!FormatMessage(FORMAT_MESSAGE_FROM_STRING         |
                            FORMAT_MESSAGE_ALLOCATE_BUFFER |
                            FORMAT_MESSAGE_ARGUMENT_ARRAY,
                        szFormat,
                        0,
                        0,
                        (LPTSTR) &pwszLogStr,
                        1,
                        (va_list *) rgpszInserts))
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        goto CleanUp;
    }
	            
CleanUp:
    if (fDelete)
    {
        LocalFree(pszErrStr);
    }
    return pwszLogStr;
}

//+----------------------------------------------------------------------------
//
//  Function:   CreateFolders
//
//  Synopsis:   Creates any missing  directories for any slash delimited folder
//              names in the path.
//
//  Arguments:  [ptszPathName] - the path name
//              [fHasFileName] - if true, the path name includes a file name.
//
//  Returns:    HRESULTS
//
//  Notes:      ptszPathName should never end in a slash.
//              Treats forward and back slashes identically.
//-----------------------------------------------------------------------------
HRESULT
CreateFolders(LPCTSTR ptszPathName, BOOL fHasFileName)
{
    //schDebugOut((DEB_ITRACE, "CreateFolders\n"));
    //
    // Copy the string so we can munge it
    //
    TCHAR * ptszPath = new TCHAR[lstrlen(ptszPathName) + 2];
    if (!ptszPath)
    {
        return E_OUTOFMEMORY;
    }
    lstrcpy(ptszPath, ptszPathName);

    if (!fHasFileName)
    {
        //
        // If no file name, append a slash so the following logic works
        // correctly.
        //
        lstrcat(ptszPath, TEXT("\\"));
    }

    //
    // Get a pointer to the last slash in the name.
    //

    TCHAR * ptszSlash = _tcsrchr(ptszPath, TEXT('\\'));

    if (ptszSlash == NULL)
    {
        //
        // no slashes found, so nothing to do
        //
        delete [] ptszPath;
        return S_OK;
    }

    if (fHasFileName)
    {
        //
        // Chop off the file name, leaving the slash as the last char.
        //
        ptszSlash[1] = TEXT('\0');
    }

    BOOL fFullPath = (lstrlen(ptszPath) > 2        &&
                      s_isDriveLetter(ptszPath[0]) &&
                      ptszPath[1] == TEXT(':'));

    //
    // Walk the string looking for slashes. Each found slash is temporarily
    // replaced with a null and that substring passed to CreateDir.
    //
    TCHAR * ptszTail = ptszPath;
    while (ptszSlash = _tcspbrk(ptszTail, TEXT("\\/")))
    {
        //
        // If the path name starts like C:\ then the first slash will be at
        // the third character
        //

        if (fFullPath && (ptszSlash - ptszTail == 2))
        {
            //
            // We are looking at the root of the drive, so don't try to create
            // a root directory.
            //
            ptszTail = ptszSlash + 1;
            continue;
        }
        *ptszSlash = TEXT('\0');
        if (!CreateDirectory(ptszPath, NULL))
        {
            DWORD dwErr = GetLastError();
            if (dwErr != ERROR_ALREADY_EXISTS)
            {
                delete [] ptszPath;
                return (HRESULT_FROM_WIN32(dwErr));
            }
        }
        *ptszSlash = TEXT('\\');
        ptszTail = ptszSlash + 1;
    }
    delete [] ptszPath;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetExitCodeString
//
//  Synopsis:   Retrieve the string associated with the exit code from a
//              message file. Algorithm:
//
//              Consult the Software\Microsoft\Job Scheduler subkey.
//
//              Attempt to retrieve the ExitCodeMessageFile string value from
//              a subkey matching the job executable prefix (i.e., minus the
//              extension).
//
//              The ExitCodeMessageFile specifies a binary from which the
//              message string associated with the exit code value is fetched.
//
//  Arguments:  [dwExitCode]        -- Job exit code.
//              [pwszExitCodeValue] -- Job exit code in string form.
//              [pszJobExecutable]  -- Binary name executed with the job.
//
//  Returns:    TCHAR * exit code string
//              NULL on error
//
//  Notes:      FormatMessage allocates the return string. Use LocalFree() to
//              deallocate.
//
//----------------------------------------------------------------------------
TCHAR *
GetExitCodeString(
    DWORD dwExitCode,
    TCHAR * ptszExitCodeValue,
    TCHAR * ptszJobExecutable)
{
    static TCHAR tszExitCodeMsgFile[] = TEXT("ExitCodeMessageFile");
    TCHAR        tszBuffer[MAX_PATH + 1];
    DWORD        cbBufferSize = sizeof(tszBuffer);
    TCHAR *      ptszExt;
    TCHAR *      ptszExitCode = NULL;
    DWORD        dwType;

    // Isolate job app name prefix.
    //
    if ((ptszExt = _tcsrchr(ptszJobExecutable, TEXT('.'))) != NULL)
    {
       *ptszExt = TEXT('\0');
    }

    HKEY hKey;
    HKEY hSubKey;

    // BUGBUG : Cache job scheduler key.

    if (!RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                       gszJobScheduler,
                       0,
                       KEY_READ,
                       &hKey))
    {
        // Open the JobScheduler\<app> subkey and fetch the exit code
        // message file name.
        //
        if (!RegOpenKeyEx(hKey, ptszJobExecutable, 0, KEY_READ, &hSubKey))
        {
            if (!RegQueryValueEx(hSubKey,
                                 tszExitCodeMsgFile,
                                 NULL,
                                 &dwType,
                                 (UCHAR *)tszBuffer,
                                 &cbBufferSize) && dwType == REG_SZ)
            {
                // Load the resource as a data file, so no code executes
                // in our process.
                //
                HINSTANCE hInst = LoadLibraryEx(tszBuffer,
                                                NULL,
                                                LOAD_LIBRARY_AS_DATAFILE);

                if (hInst != NULL)
                {
                    ULONG ccSize;

                    if (ccSize = FormatMessage(
                                            FORMAT_MESSAGE_FROM_HMODULE     |
                                              FORMAT_MESSAGE_IGNORE_INSERTS |
                                              FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                            hInst,
                                            dwExitCode,
                                            LOCALE_SYSTEM_DEFAULT,
                                            (TCHAR *)&ptszExitCode,
                                            1,
                                            NULL))
                    {
                        // Overwrite \r\n with null characters.
                        //
                        TCHAR * ptsz = ptszExitCode + lstrlen(ptszExitCode) - 2;

                        *ptsz++ = TEXT('\0');
                        *ptsz   = TEXT('\0');
                    }
                    else
                    {
                        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
                    }

                    FreeLibrary(hInst);
                }
            }
            RegCloseKey(hSubKey);
        }
        RegCloseKey(hKey);
    }

    if (ptszExt != NULL)                 // Restore '.'
    {
        *ptszExt = '.';
    }

    return(ptszExitCode);
}

//+---------------------------------------------------------------------------
//
//  Function:   GetSageExitCodeString
//
//  Synopsis:   Retrieve the string associated with the exit code the SAGE
//              way. Algorithm:
//
//              Consult the Software\Microsoft\System Agent\SAGE subkey.
//
//              Enumerate the subkeys to find a subkey with a "Program" string
//              value specifying an executable name matching that of the job.
//
//              If such a subkey was found, open the Result Codes subkey and
//              fetch the value name matching the exit code. The string value
//              is the exit code string.
//
//  Arguments:  [ptszExitCodeValue] -- Job exit code in string form.
//              [ptszJobExecutable] -- Binary name executed with the job.
//
//  Returns:    TCHAR * exit code string
//              NULL on error
//
//  Notes:      FormatMessage allocates the return string. Use LocalFree() to
//              deallocate.
//
//----------------------------------------------------------------------------
TCHAR *
GetSageExitCodeString(TCHAR * ptszExitCodeValue, TCHAR * ptszJobExecutable)
{
    static TCHAR tszSage[] = TEXT("SOFTWARE\\Microsoft\\Plus!\\System Agent\\SAGE");
    static TCHAR tszProgram[]     = TEXT("Program");
    static TCHAR tszResultCodes[] = TEXT("Result Codes");
    TCHAR        tszBuffer[MAX_PATH + 1];
    DWORD        cbBufferSize;
    TCHAR *      ptszExitCode     = NULL;
    HKEY         hKeySage        = NULL;
    HKEY         hSubKey         = NULL;
    HKEY         hKeyResultCodes = NULL;
    DWORD        dwType;

    // Open the Plus!\SAGE key, if it exists.
    //
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, tszSage, 0, KEY_READ, &hKeySage))
    {
        return(NULL);   // Didn't find it, or failed trying.
    }

    DWORD dwIndex;
    LONG  lRet;

    for (dwIndex = 0, lRet = 0; lRet != ERROR_NO_MORE_ITEMS && !lRet;
                            dwIndex++)
    {
        // Enum SAGE registry subkeys under software\msft\plus!\sage.
        //
        cbBufferSize = MAX_PATH + 1;    // RegEnumKeyEx character count

        lRet = RegEnumKeyEx(hKeySage,
                             dwIndex,
                             tszBuffer,
                             &cbBufferSize,
                             NULL,
                             NULL,
                             NULL,
                             NULL);     // BUGBUG : Last arg may fault.

        if (!lRet)
        {
            // Open the key & fetch the 'Program' key value.
            //
            if (RegOpenKeyEx(hKeySage, tszBuffer, 0, KEY_READ, &hSubKey))
            {
                break;                  // No sense continuing.
            }

            cbBufferSize = sizeof(tszBuffer);

            if (RegQueryValueEx(hSubKey,
                                tszProgram,
                                NULL,
                                &dwType,
                                (UCHAR *)tszBuffer,
                                &cbBufferSize) && dwType == REG_SZ)
            {
                break;                  // No sense continuing.
            }

            // Compare program name & job app name. If there's
            // a match, fetch the exit code string.
            //
            if (!lstrcmpi(tszBuffer, ptszJobExecutable))
            {
                // Open the 'Result Codes' sub key & fetch the exit code
                // string.
                //
                if (RegOpenKeyEx(hSubKey,
                                 tszResultCodes,
                                 0,
                                 KEY_READ,
                                 &hKeyResultCodes))
                {
                    break;              // No sense continuing.
                }

                // First obtain the string size, allocate a buffer,
                // then fetch it.
                //
                cbBufferSize = 0;       // To obtain string size.

                if (RegQueryValueEx(hKeyResultCodes,
                                    ptszExitCodeValue,
                                    NULL,
                                    &dwType,
                                    (UCHAR *)tszBuffer,
                                    &cbBufferSize) != ERROR_MORE_DATA)
                {
                    break;              // No sense continuing.
                }

                ptszExitCode = (TCHAR *)LocalAlloc(LMEM_FIXED, cbBufferSize);

                if (ptszExitCode == NULL)
                {
                    CHECK_HRESULT(E_OUTOFMEMORY);
                    break;              // No sense continuing.
                }

                cbBufferSize = sizeof(tszBuffer);

                if (!RegQueryValueEx(hKeyResultCodes,
                                     ptszExitCodeValue,
                                     NULL,
                                     &dwType,
                                     (UCHAR *)tszBuffer,
                                     &cbBufferSize) && dwType == REG_SZ)
                {
                    CopyMemory(ptszExitCode, tszBuffer, cbBufferSize);
                    break;
                }
                else
                {
                    LocalFree(ptszExitCode);
                    ptszExitCode = NULL;
                    break;
                }
            }
        }
    }

    // Cleanup.
    //
    if (hKeySage != NULL) RegCloseKey(hKeySage);
    if (hSubKey != NULL) RegCloseKey(hSubKey);
    if (hKeyResultCodes != NULL) RegCloseKey(hKeyResultCodes);

    return(ptszExitCode);
}

//+---------------------------------------------------------------------------
//
//  Function:   GetParentDirectory
//
//  Synopsis:   Return the parent directory of the path indicated.
//
//  Arguments:  [ptszPath]     -- Input path.
//              [tszDirectory] -- Caller-allocated returned directory.
//
//  Returns:    None.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
void
GetParentDirectory(LPCTSTR ptszPath, TCHAR tszDirectory[])
{
    lstrcpy(tszDirectory, ptszPath);

    LPTSTR ptsz = _tcsrchr(tszDirectory, _T('\\'));

    if (ptsz == NULL)
    {
        tszDirectory[0] = _T('\\');
    }
    else
    {
        *ptsz = _T('\0');
    }
}



//+---------------------------------------------------------------------------
//
//  Function:   GetAppNameFromPath
//
//  Synopsis:   Copy the filename portion (without double quotes) of full
//              or partial path in [tszAppPathName] into buffer pointed to
//              by [tszCopyTo].
//
//  Arguments:  [tszAppPathName] - full or partial path
//              [tszCopyTo]      - destination buffer
//              [cchMax]         - max size, in chars, of buffer
//
//  Modifies:   *[tszCopyTo]
//
//  History:    09-17-96   DavidMun   Created
//
//----------------------------------------------------------------------------

VOID
GetAppNameFromPath(
        LPCTSTR tszAppPathName,
        LPTSTR  tszCopyTo,
        ULONG   cchMax)
{
    LPCTSTR ptszStart;
    LPCTSTR ptszLastSlash;

    if (tszAppPathName[0] == TEXT('"'))
    {
        ptszStart = &tszAppPathName[1];
    }
    else
    {
        ptszStart = tszAppPathName;
    }

    ptszLastSlash = _tcsrchr(ptszStart, TEXT('\\'));

    if (ptszLastSlash)
    {
        lstrcpyn(tszCopyTo, ptszLastSlash + 1, cchMax);
    }
    else
    {
        lstrcpyn(tszCopyTo, ptszStart, cchMax);
    }

    LPTSTR ptszQuote = _tcschr(tszCopyTo, TEXT('"'));

    if (ptszQuote)
    {
        *ptszQuote = TEXT('\0');
    }
}



//+---------------------------------------------------------------------------
//
//  Function:   SetAppPath
//
//  Synopsis:   If the application in the full or partial path
//              [tszAppPathName] has an app path registry entry, save the
//              current value of the path variable in [pptszSavedPath] and
//              prepend the app path to the current path.
//
//  Arguments:  [tszAppPathName] - full or partial path to application
//              [pptszSavedPath] - filled with ptr to saved path string
//
//  Modifies:   *[pptszSavedPath], PATH environment variable
//
//  Returns:    nonzero - path environment var was set
//              zero    - path environment var not set
//
//  History:    09-17-96   DavidMun   Created
//
//----------------------------------------------------------------------------

BOOL SetAppPath(LPCTSTR tszAppPathName, LPTSTR *pptszSavedPath)
{
    BOOL    fChangedPath = FALSE;
    LPTSTR  tszAppName[MAX_PATH];
    TCHAR   tszAppPathVar[MAX_PATH_VALUE];

    do
    {
        //
        // Init out var
        //

        *pptszSavedPath = NULL;

        //
        // See if there's an app key with a PATH value.  If not we're done.
        //

        GetAppNameFromPath(tszAppPathName, (LPTSTR)tszAppName, MAX_PATH);

        GetAppPathInfo((LPCTSTR)tszAppName,
                       NULL,
                       0,
                       tszAppPathVar,
                       MAX_PATH_VALUE);

        if (!*tszAppPathVar)
        {
            break;
        }

        //
        // Save the original path, if it exists.
        //

        ULONG cchOriginalPath = GetEnvironmentVariable(PATH_ENV_VAR, NULL,0);

        if (0 != cchOriginalPath)
        {
            //
            // It exists, try to alloc mem to save it.  If we can't, we'll try
            // to run the app without setting its app path, but CreateProcess
            // will probably fail anyway due to lack of resources.
            //

            *pptszSavedPath = new TCHAR[cchOriginalPath];

            if (NULL == *pptszSavedPath)
            {
                ERR_OUT("SetAppPath: trying to save path", E_OUTOFMEMORY);
                break;
            }

            GetEnvironmentVariable(PATH_ENV_VAR,
                                   *pptszSavedPath,
                                   cchOriginalPath);
        }

        //
        // Now build the new path by prepending the app's path to the original
        // path.  Note cchNewPath includes 1 for terminating nul, and
        // cchOriginalPath does also, if it isn't 0.  This will give us 1
        // character extra if we are to be concatenating cchOriginalPath.
        // We'll use that extra character for the semicolon separating new and
        // original paths.
        //

        ULONG cchNewPath = lstrlen(tszAppPathVar) + 1;
        LPTSTR ptszNewPath = new TCHAR[cchNewPath + cchOriginalPath];

        if (NULL == ptszNewPath)
        {
            ERR_OUT("SetAppPath: trying to get AppPath", E_OUTOFMEMORY);
            break;
        }

        lstrcpy(ptszNewPath, tszAppPathVar);

        if (0 != cchOriginalPath)
        {
            ptszNewPath[cchNewPath - 1] = TEXT(';');
            lstrcpy(&ptszNewPath[cchNewPath], *pptszSavedPath);
        }

        //
        // Finally ready to set the path environment variable
        //

        fChangedPath = SetEnvironmentVariable(PATH_ENV_VAR, ptszNewPath);
        delete [] ptszNewPath;
    } while (0);

    return fChangedPath;
}


#if !defined(_CHICAGO_)

//+---------------------------------------------------------------------------
//
//  Function:   LoadAtJob
//
//  Synopsis:   Load the At job indicated.
//
//  Arguments:  [pJob]              - Job object to use.
//              [pwszAtJobFilename] - Relative path to the target At job.
//
//----------------------------------------------------------------------------
HRESULT
LoadAtJob(CJob * pJob, TCHAR * ptszAtJobFilename)
{
    static ULONG    ccJobFolderPathSize = 0;
    TCHAR           tszPath[MAX_PATH + 1];

    if (ccJobFolderPathSize == 0)
    {
        ccJobFolderPathSize = lstrlen(g_TasksFolderInfo.ptszPath);
    }

    //
    // Compute string size to prevent possible buffer overrun.
    //
    // NB : size + 2 for additional for '\' + NULL character.
    //

    ULONG ccAtJobPathSize = lstrlen(ptszAtJobFilename) +
                            ccJobFolderPathSize + 2;

    if (ccAtJobPathSize > MAX_PATH)
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(ERROR_INVALID_NAME));
        return HRESULT_FROM_WIN32(ERROR_INVALID_NAME);
    }

    lstrcpy(tszPath, g_TasksFolderInfo.ptszPath);
    lstrcat(tszPath, TEXT("\\"));
    lstrcat(tszPath, ptszAtJobFilename);

    return pJob->LoadP(tszPath, 0, FALSE, TRUE);
}




//+---------------------------------------------------------------------------
//
//  Function:   IsValidAtFilename
//
//  Synopsis:   Returns TRUE if [wszFilename] is of the form ATn.JOB, where
//              n is 1 or more digits, leading zeros not allowed, n >= 1.
//
//  History:    09-30-96   DavidMun   Created
//
//  Notes:      Assumes [wszFilename] has valid extension.
//
//----------------------------------------------------------------------------

BOOL IsValidAtFilename(LPCWSTR wszFilename)
{
    ULONG cchFilename;
    static ULONG s_cchExtension;

    cchFilename = lstrlen(wszFilename);

    if (!s_cchExtension)
    {
        s_cchExtension = ARRAY_LEN(TSZ_DOTJOB) - 1;
    }

    //
    // The filename must be of the form PREFIXdigitsEXTENSION, with at least
    // one digit.  This means that the min length is the length of PREFIX +
    // EXTENSION + 1.  We get the +1 from the ARRAY_LEN macro.
    //

    if (cchFilename < (ARRAY_LEN(TSZ_AT_JOB_PREFIX) + s_cchExtension))
    {
        return FALSE;
    }

    //
    // After the prefix there must be only digits up to the extension.
    // Leading zeros are not allowed.
    //

    ULONG i;
    BOOL fZerosAreLeading = TRUE;

    for (i = ARRAY_LEN(TSZ_AT_JOB_PREFIX) - 1; i < cchFilename; i++)
    {
        if (L'0' == wszFilename[i])
        {
            if (fZerosAreLeading)
            {
                return FALSE;
            }
        }
        else if (wszFilename[i] < L'0' || wszFilename[i] > L'9')
        {
            break;  // should've just hit .job
        }
        else
        {
            fZerosAreLeading = FALSE;
        }
    }

    //
    // We stopped at a non-digit.  We should now be at a bogus character or
    // the start of the extension.  Since the findfirst/next routines wouldn't
    // have returned a filename that didn't have the appropriate extension,
    // it's not necessary to do a string compare, we can just require that the
    // number of characters remaining is the same as the length of the
    // extension.
    //

    if (cchFilename - i != s_cchExtension)
    {
        return FALSE;
    }
    return TRUE;
}



#endif // !defined(_CHICAGO_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\common\enable.cxx ===
//+----------------------------------------------------------------------------
//
//  Scheduling Agent Service
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       enable.cxx
//
//  Contents:   Code to enable/disable the service.
//
//  Classes:    None.
//
//  Functions:  StringFromTrigger, CreateFolders, GetDaysOfWeekString,
//              GetExitCodeString, GetSageExitCodeString
//
//  History:    10-Jun-96   EricB   Created.
//
//-----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop

#include "..\inc\resource.h"
#include "..\inc\misc.hxx"
#include "..\inc\debug.hxx"
#include "..\..\inc\sadat.hxx"

HRESULT WillAnyJobsRun(void);

//+---------------------------------------------------------------------------
//
//  Function:   AutoStart
//
//  Synopsis:   Persists the autostart state in the registry.
//
//  Arguments:  [fAutoStart] - If true, service is set to autostart.
//
//  Returns:    HRESULTs
//
//  Notes:      FormatMessage allocates the return string. Use LocalFree() to
//              deallocate.
//
//              The "Run" key is written to on both platforms.
//              The "RunServices" key is written to on _CHICAGO_ only.
//              ChangeServiceConfig is called on NT only.
//
//----------------------------------------------------------------------------
HRESULT
AutoStart(BOOL fAutoStart)
{
    schDebugOut((DEB_ITRACE, "AutoStart(%s)\n", fAutoStart ? "TRUE" : "FALSE"));
    long lRet = 0;

    HKEY hRunKey;
    DWORD dwDisposition;    // ignored
    lRet = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                          REGSTR_PATH_RUN,
                          0,       // reserved
                          NULL,    // class
                          0,       // non volatile
                          KEY_SET_VALUE,
                          NULL,    // security attrs
                          &hRunKey,
                          &dwDisposition);
    if (lRet != ERROR_SUCCESS)
    {
        ERR_OUT("AutoStart: RegCreateKeyEx of Run key", lRet);
        return HRESULT_FROM_WIN32(lRet);
    }

#if defined(_CHICAGO_)

    HKEY hRunSvcKey;
    lRet = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                          REGSTR_PATH_RUNSERVICES,
                          0,       // reserved
                          NULL,    // class
                          0,       // non volatile
                          KEY_SET_VALUE,
                          NULL,    // security attrs
                          &hRunSvcKey,
                          &dwDisposition);
    if (lRet != ERROR_SUCCESS)
    {
        ERR_OUT("AutoStart: RegCreateKeyEx of RunServices key", lRet);
        RegCloseKey(hRunKey);
        return HRESULT_FROM_WIN32(lRet);
    }
#endif // _CHICAGO_

    if (fAutoStart)
    {
        //
        // Set the startup values.
        //
#if defined(_CHICAGO_)
        lRet = RegSetValueEx(hRunSvcKey,
                             SCH_RUN_VALUE,
                             0,
                             REG_SZ,
                             (CONST BYTE *) SCHED_SERVICE_APP_NAME,
                             sizeof(SCHED_SERVICE_APP_NAME));
        if (lRet != ERROR_SUCCESS)
        {
            ERR_OUT("AutoStart: RegSetValueEx of RunServices key value", lRet);
            goto Cleanup0;
        }
#endif // _CHICAGO_

        #define LogonValue  SCHED_SETUP_APP_NAME TEXT(" ") SCHED_FIRSTLOGON_SWITCH
        lRet = RegSetValueEx(hRunKey,
                             SCH_RUN_VALUE,
                             0,
                             REG_SZ,
                             (CONST BYTE *) LogonValue,
                             sizeof(LogonValue));
        if (lRet != ERROR_SUCCESS)
        {
            ERR_OUT("AutoStart: RegSetValueEx of Run key value", lRet);
            goto Cleanup0;
        }
    }
    else
    {
        //
        // Clear the startup values to disable autostart.
        //
#if defined(_CHICAGO_)
        lRet = RegDeleteValue(hRunSvcKey, SCH_RUN_VALUE);
        if (lRet != ERROR_SUCCESS && lRet != ERROR_FILE_NOT_FOUND)
        {
            ERR_OUT("AutoStart: RegDeleteValue of RunService key value", lRet);
            goto Cleanup0;
        }
#endif // _CHICAGO_

        lRet = RegDeleteValue(hRunKey, SCH_RUN_VALUE);
        if (lRet != ERROR_SUCCESS && lRet != ERROR_FILE_NOT_FOUND)
        {
            ERR_OUT("AutoStart: RegDeleteValue of Run key value", lRet);
            goto Cleanup0;
        }
    }

Cleanup0:
#if defined(_CHICAGO_)
    RegCloseKey(hRunSvcKey);
#endif // _CHICAGO_
    RegCloseKey(hRunKey);

    if (lRet != ERROR_SUCCESS)
    {
        return HRESULT_FROM_WIN32(lRet);
    }

#if !defined(_CHICAGO_)

    SC_HANDLE hSC, hSvc;

    hSC = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT | GENERIC_WRITE);

    if (hSC == NULL)
    {
        lRet = GetLastError();
        ERR_OUT("AutoStart: OpenSCManager", lRet);
        return HRESULT_FROM_WIN32(lRet);
    }

    hSvc = OpenService(hSC, g_tszSrvcName, SERVICE_CHANGE_CONFIG);

    if (hSvc == NULL)
    {
        lRet = GetLastError();
        ERR_OUT("AutoStart: OpenService", lRet);
        CloseServiceHandle(hSC);
        return HRESULT_FROM_WIN32(lRet);
    }

    if (ChangeServiceConfig(hSvc,
                            SERVICE_NO_CHANGE,
                            fAutoStart ? SERVICE_AUTO_START :
                                         SERVICE_DEMAND_START,
                            SERVICE_NO_CHANGE,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL) == FALSE)
    {
        lRet = GetLastError();
        ERR_OUT("AutoStart: ChangeServiceConfig", lRet);
    }

    CloseServiceHandle(hSvc);
    CloseServiceHandle(hSC);

#endif  // !defined(_CHICAGO_)

    return (lRet != 0) ? HRESULT_FROM_WIN32(lRet) : S_OK;
}


//+----------------------------------------------------------------------------
//
//  Member:     WillAnyJobsRun
//
//  Synopsis:   Examines the job objects in the scheduler folder to see if any
//              will run at some point in the future.
//
//  Returns:    S_OK if any jobs will run, S_FALSE if no jobs will run, or an
//              error code.
//
//  Notes:      This function is called only during setup; however, it is in
//              the task DLL, rather than the setup EXE, in order to avoid
//              exporting the CJob methods from the DLL.
//
//-----------------------------------------------------------------------------
HRESULT
WillAnyJobsRun(void)
{
    TRACE_FUNCTION(WillAnyJobsRun);
    HRESULT hr = S_OK;
    DWORD dwRet;
    HANDLE hFind;
    WIN32_FIND_DATA fd;

    //
    // Compose the job search string. It will be composed of the following:
    // g_TasksFolderInfo.ptszPath\*.TSZ_JOB
    //
    TCHAR tszPath[MAX_PATH + MAX_PATH];
    lstrcpy(tszPath, g_TasksFolderInfo.ptszPath);
    lstrcat(tszPath, TEXT("\\*.") TSZ_JOB);

    hFind = FindFirstFile(tszPath, &fd);
    if (hFind == INVALID_HANDLE_VALUE)
    {
        dwRet = GetLastError();
        if (dwRet == ERROR_FILE_NOT_FOUND)
        {
            //
            // No job files.
            //
            return S_FALSE;
        }
        else
        {
            ERR_OUT("WillAnyJobsRun FindFirstFile", dwRet);
            return HRESULT_FROM_WIN32(dwRet);
        }
    }

    SYSTEMTIME stNow;
    GetLocalTime(&stNow);

    CJob * pJob = CJob::Create();
    if (pJob == NULL)
    {
        ERR_OUT("WillAnyJobsRun CJob::Create", E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }

    do
    {
        schDebugOut((DEB_ITRACE, "Found job " FMT_TSTR "\n", fd.cFileName));
        //
        // TODO: differentiate between job and queue objects and handle
        // accordingly.
        //
        lstrcpy(tszPath, g_TasksFolderInfo.ptszPath);
        lstrcat(tszPath, TEXT("\\"));
        lstrcat(tszPath, fd.cFileName);
        hr = pJob->LoadP(tszPath, 0, TRUE, FALSE);
        if (FAILED(hr))
        {
            ERR_OUT("WillAnyJobsRun LoadP", hr);
            hr = S_OK;
            goto CheckNextJob;
        }

        //
        // Check if job can run.
        //
        DWORD dwFlags;
        pJob->GetAllFlags(&dwFlags);
        if (!(dwFlags & TASK_FLAG_DISABLED) &&
            (dwFlags & JOB_I_FLAG_HAS_APPNAME))
        {
            //
            // LoadTriggers will set or clear the JOB_I_FLAG_HAS_TRIGGERS flag
            // as appropriate.
            //
            hr = pJob->LoadTriggers();
            if (FAILED(hr))
            {
                ERR_OUT("WillAnyJobsRun, pJob->LoadTriggers", hr);
                hr = S_OK;
                goto CheckNextJob;
            }

            pJob->GetAllFlags(&dwFlags);
            if (dwFlags & JOB_I_FLAG_HAS_TRIGGERS)
            {
                WORD cRuns = 0;

                hr = pJob->GetRunTimesP(&stNow, NULL, &cRuns, 1, NULL, NULL);
                if (FAILED(hr))
                {
                    ERR_OUT("WillAnyJobsRun GetRunTimes", hr);
                    hr = S_OK;
                    goto CheckNextJob;
                }

                if (cRuns > 0 || hr == SCHED_S_EVENT_TRIGGER)
                {
                    //
                    // Finding one is sufficent, lets go home.
                    //
                    pJob->Release();
                    FindClose(hFind);
                    return S_OK;
                }
            }
        }

CheckNextJob:
        if (!FindNextFile(hFind, &fd))
        {
            dwRet = GetLastError();
            if (dwRet == ERROR_NO_MORE_FILES)
            {
                break;
            }
            else
            {
                ERR_OUT("CSchedWorker::WillAnyJobsRun, FindNextFile", dwRet);
                hr = HRESULT_FROM_WIN32(dwRet);
                goto Cleanup;
            }
        }
    }
    while (SUCCEEDED(hr));

Cleanup:
    pJob->Release();

    FindClose(hFind);

    return (FAILED(hr)) ? hr : S_FALSE;
}

//+----------------------------------------------------------------------------
//
//  Member:     ConditionallyEnableService
//
//  Synopsis:   If any of the job objects in the scheduler folder will run at
//              some point in the future, then the service is enabled.
//              Otherwise, it is disabled.
//
//  History:    1-15-1997   DavidMun   Call SADatCreate if service not
//                                      enabled.
//
//-----------------------------------------------------------------------------

STDAPI_(BOOL)
ConditionallyEnableService(void)
{
    BOOL    fEnable;
    DWORD   dwVersion;                          // For SADatGetData
    BYTE    bPlatform, brgSvcFlags;
    HRESULT hr;

#ifdef _CHICAGO_
    fEnable = (WillAnyJobsRun() == S_OK);
#else
    fEnable = TRUE;
#endif

    AutoStart(fEnable);

    hr = SADatGetData(g_TasksFolderInfo.ptszPath,
                      &dwVersion,
                      &bPlatform,
                      &brgSvcFlags);

    if (FAILED(hr))
    {
        brgSvcFlags = 0;
    }

    //
    // The SA.DAT file must be present for the UI to work properly.  It
    // is created on service start, but if the service isn't enabled,
    // the user may open the UI and see the wrong thing.  So create the
    // file here.
    //

    hr = SADatCreate(g_TasksFolderInfo.ptszPath,
                     (BOOL)brgSvcFlags & SA_DAT_SVCFLAG_SVC_RUNNING);

    if (FAILED(hr))
    {
        ERR_OUT("ConditionallyEnableService, SADatCreate", hr);
    }

    return(fEnable);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\common\runobj.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       runobj.cxx
//
//  Contents:   Run instance object class implementations.
//
//  Classes:    CRun and CRunList
//
//  History:    14-Mar-96   EricB   Created.
//              10-Nov-96   AnirudhS Fixed CRunList::AddSorted to discard the
//                  appropriate element if the list is at its maximum size.
//                  Fixed CRunList::MakeSysTimeArray to call CoTaskMemAlloc
//                  once instead of calling CoTaskMemRealloc in a loop.
//
//----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include <job_cls.hxx>
#include <misc.hxx>
#include <debug.hxx>
#include "..\svc_core\svc_core.hxx"

#if !defined(_CHICAGO_)
#include <userenv.h>  // UnloadUserProfile
#endif // !defined(_CHICAGO_)

PFNSetThreadExecutionState  pfnSetThreadExecutionState;
DWORD   g_WakeCountSlot = 0xFFFFFFFF;

//+----------------------------------------------------------------------------
//
//  Run instance object class
//
//-----------------------------------------------------------------------------

//+----------------------------------------------------------------------------
//
//  Method:     CRun::CRun
//
//  Synopsis:   ctor for time-sorted lists.
//
//-----------------------------------------------------------------------------
CRun::CRun(LPFILETIME pft, LPFILETIME pftDeadline, FILETIME ftKill,
           DWORD MaxRunTime, DWORD rgFlags, WORD wIdleWait,
           BOOL fKeepAfterRunning) :
    m_ft(*pft),
    m_ftDeadline(*pftDeadline),
    m_ftKill(ftKill),
    m_hJob(NULL),
    m_ptszJobName(NULL),
    m_dwProcessId(0),
#if !defined(_CHICAGO_)
    m_hUserToken(NULL),
	m_ptszDesktop(NULL),
	m_ptszStation(NULL),
    m_hProfile(NULL),
#endif // !defined(_CHICAGO_)
    m_rgFlags(rgFlags),
    m_dwMaxRunTime(MaxRunTime),
    m_wIdleWait(wIdleWait),
    m_fKeepInList(fKeepAfterRunning),
    m_fStarted(FALSE)
{
    schDebugOut((DEB_TRACE, "CRun::CRun(0x%x)\n", this));
}

//+----------------------------------------------------------------------------
//
//  Method:     CRun::CRun
//
//  Synopsis:   ctor for non-time-sorted lists.
//
//-----------------------------------------------------------------------------
CRun::CRun(DWORD MaxRunTime, DWORD rgFlags, FILETIME ftDeadline,
           BOOL fKeepAfterRunning) :
    m_ftDeadline(ftDeadline),
    m_ftKill(MAX_FILETIME),
    m_hJob(NULL),
    m_ptszJobName(NULL),

    m_dwProcessId(0),
#if !defined(_CHICAGO_)
	m_ptszDesktop(NULL),
	m_ptszStation(NULL),
    m_hUserToken(NULL),
    m_hProfile(NULL),
#endif // !defined(_CHICAGO_)
    m_rgFlags(rgFlags),
    m_dwMaxRunTime(MaxRunTime),
    m_wIdleWait(0),
    m_fKeepInList(fKeepAfterRunning),
    m_fStarted(FALSE)
{
    //schDebugOut((DEB_TRACE, "CRun::CRun(0x%x)\n", this));
    //
    // This ctor is used for non-sorted lists. Set the time elements to
    // non-zero values to distinguish these elements from the head.
    //
    // CODEWORK - Don't use 0,0 to mark the head.  Remove IsNull() method.
    // Instead use a NULL Next pointer to mark the last list element.
    //
    m_ft.dwLowDateTime = 1;
    m_ft.dwHighDateTime = 1;
}

//+----------------------------------------------------------------------------
//
//  Method:     CRun::CRun
//
//  Synopsis:   ctor for idle-time-sorted lists.
//
//-----------------------------------------------------------------------------
CRun::CRun(DWORD MaxRunTime, DWORD rgFlags, WORD wIdleWait,
           FILETIME ftDeadline, BOOL fKeepAfterRunning) :
    m_ftDeadline(ftDeadline),
    m_ftKill(MAX_FILETIME),
    m_hJob(NULL),
    m_ptszJobName(NULL),
    m_dwProcessId(0),
#if !defined(_CHICAGO_)
	m_ptszDesktop(NULL),
	m_ptszStation(NULL),
    m_hUserToken(NULL),
    m_hProfile(NULL),
#endif // !defined(_CHICAGO_)
    m_rgFlags(rgFlags),
    m_dwMaxRunTime(MaxRunTime),
    m_wIdleWait(wIdleWait),
    m_fKeepInList(fKeepAfterRunning),
    m_fStarted(FALSE)
{
    TRACE3(CRun,CRun);
    //
    // Set the time elements to non-zero values to distinguish
    // these elements from the head.
    // CODEWORK - as above, don't do this.
    //
    m_ft.dwLowDateTime = 1;
    m_ft.dwHighDateTime = 1;
}

//+----------------------------------------------------------------------------
//
//  Method:     CRun::CRun
//
//  Synopsis:   copy ctor.
//
//  Notes:      This ctor should not be used to copy running objects, i.e.
//              objects that have valid process, user token, or profile
//              handles.
//
//-----------------------------------------------------------------------------
CRun::CRun(CRun * pRun) :
    m_ft(pRun->m_ft),
    m_ftDeadline(pRun->m_ftDeadline),
    m_ftKill(pRun->m_ftKill),
    m_hJob(NULL),
    m_ptszJobName(NULL),
    m_dwProcessId(pRun->m_dwProcessId),
#if !defined(_CHICAGO_)
    m_ptszDesktop(NULL),
    m_ptszStation(NULL),
    m_hUserToken(NULL),
    m_hProfile(NULL),
#endif // !defined(_CHICAGO_)
    m_rgFlags(pRun->m_rgFlags),
    m_dwMaxRunTime(pRun->m_dwMaxRunTime),
    m_wIdleWait(pRun->m_wIdleWait),
    m_fKeepInList(pRun->m_fKeepInList),
    m_fStarted(pRun->m_fStarted)
{
    TRACE3(CRun,CRun(Copy));

    SetName(pRun->m_ptszJobName);
    schAssert(!pRun->m_hJob);

#if !defined(_CHICAGO_)
    schAssert(!pRun->m_hUserToken);
    schAssert(!pRun->m_hProfile);
#endif // !defined(_CHICAGO_)
}

//+---------------------------------------------------------------------------
//
//  Method:     CRun::CRun
//
//  Synopsis:   ctor
//
//----------------------------------------------------------------------------
CRun::CRun(void) :
    m_ftDeadline(MAX_FILETIME),
    m_ftKill(MAX_FILETIME),
    m_hJob(NULL),
    m_ptszJobName(NULL),
    m_dwProcessId(0),
#if !defined(_CHICAGO_)
	m_ptszDesktop(NULL),
	m_ptszStation(NULL),
    m_hUserToken(NULL),
    m_hProfile(NULL),
#endif // !defined(_CHICAGO_)
    m_rgFlags(0),
    m_dwMaxRunTime(RUN_TIME_NO_END),
    m_wIdleWait(0),
    m_fKeepInList(FALSE),
    m_fStarted(FALSE)
{
    //schDebugOut((DEB_TRACE, "CRun::CRun(0x%x)\n", this));
    //
    // The null arg ctor is used only by CRunList for its head element
    // member. The zero time value for this element marks it as the head
    // when traversing the doubly linked list.
    //
    m_ft.dwLowDateTime = 0;
    m_ft.dwHighDateTime = 0;
}

//+---------------------------------------------------------------------------
//
//  Method:     CRun::~CRun
//
//  Synopsis:   dtor
//
//----------------------------------------------------------------------------
CRun::~CRun()
{
    BOOL fOk;

    //schDebugOut((DEB_TRACE, "CRun::~CRun(0x%x)\n", this));
    if (m_hJob)
    {
        CloseHandle(m_hJob);
    }
    if (m_ptszJobName)
    {
        delete m_ptszJobName;
    }

#if !defined(_CHICAGO_)
    if (m_hProfile)
    {
        fOk = UnloadUserProfile(m_hUserToken, m_hProfile);

        if (!fOk)
        {
            ERR_OUT("~CRun: UnloadUserProfile",
                    HRESULT_FROM_WIN32(GetLastError()));
        }
    }
    if (m_hUserToken)
    {
        fOk = CloseHandle(m_hUserToken);
        if (!fOk)
        {
            ERR_OUT("~CRun: CloseHandle",
                    HRESULT_FROM_WIN32(GetLastError()));
        }
    }
	if ( m_ptszDesktop )
	{
		delete m_ptszDesktop;
	}

	if ( m_ptszStation )
	{
		delete m_ptszStation;
	}
#endif // !defined(_CHICAGO_)
}

//+---------------------------------------------------------------------------
//
//  Method:     CRun::SetName
//
//  Synopsis:   Set the job name property. This is the folder-relative name.
//
//----------------------------------------------------------------------------
HRESULT
CRun::SetName(LPCTSTR ptszName)
{
    if (m_ptszJobName)
    {
        delete m_ptszJobName;
        m_ptszJobName = NULL;
    }

    if (!ptszName)
    {
        return S_OK;
    }

    m_ptszJobName = new TCHAR[lstrlen(ptszName) + 1];

    if (m_ptszJobName == NULL)
    {
        return(E_OUTOFMEMORY);
    }

    lstrcpy(m_ptszJobName, ptszName);

    return(S_OK);
}


#if !defined(_CHICAGO_)
//+---------------------------------------------------------------------------
//
//  Method:     CRun::SetDesktop
//
//  Synopsis:   Set the Desktop name property. This is the windows station \ desktop.
//
//----------------------------------------------------------------------------
HRESULT
CRun::SetDesktop( LPCTSTR ptszDesktop )
{
    if (ptszDesktop)
    {
        delete m_ptszDesktop;
        m_ptszDesktop = NULL;
    }

    if (!ptszDesktop)
    {
        return S_OK;
    }

    m_ptszDesktop = new TCHAR[lstrlen(ptszDesktop) + 1];

    if (m_ptszDesktop == NULL)
    {
        return(E_OUTOFMEMORY);
    }

    lstrcpy(m_ptszDesktop, ptszDesktop);

    return(S_OK);
}
//+---------------------------------------------------------------------------
//
//  Method:     CRun::SetStation
//
//  Synopsis:   Set the Desktop name property. This is the windows station \ desktop.
//
//----------------------------------------------------------------------------
HRESULT
CRun::SetStation( LPCTSTR ptszStation )
{
    if (ptszStation)
    {
        delete m_ptszStation;
        m_ptszStation = NULL;
    }

    if (!ptszStation)
    {
        return S_OK;
    }

    m_ptszStation = new TCHAR[lstrlen(ptszStation) + 1];

    if (m_ptszStation == NULL)
    {
        return(E_OUTOFMEMORY);
    }

    lstrcpy(m_ptszStation, ptszStation);

    return(S_OK);
}
#endif // !defined(_CHICAGO_)
//+---------------------------------------------------------------------------
//
//  Method:     CRun::AdjustKillTimeByMaxRunTime
//
//  Synopsis:   If the job has a max run time, advance its kill time to "now"
//              plus the max run time.
//
//----------------------------------------------------------------------------
void
CRun::AdjustKillTimeByMaxRunTime(FILETIME ftNow)
{
    if (m_dwMaxRunTime != INFINITE)
    {
        AdvanceKillTime(FTfrom64(
                 FTto64(ftNow) +
                     (DWORDLONG) m_dwMaxRunTime *
                     FILETIMES_PER_MILLISECOND));
    }
}


//+----------------------------------------------------------------------------
//
//  Run object list class
//
//-----------------------------------------------------------------------------

//+----------------------------------------------------------------------------
//
//  Member:     CRunList::FreeList
//
//  Synopsis:   Frees the linked list elements, skipping the head.
//
//-----------------------------------------------------------------------------
void
CRunList::FreeList(void)
{
    //
    // Skip the head, it is a placeholder in the circular list with a time
    // value of zero. The zero time value is used as a marker so that we can
    // tell when we have traversed the entire list.
    //
    CRun * pCur = m_RunHead.Next();

    while (!pCur->IsNull())
    {
        CRun * pNext = pCur->Next();
        pCur->UnLink();
        delete pCur;
        pCur = pNext;
    }
}

//+----------------------------------------------------------------------------
//
//  Member:     CRunList::AddSorted
//
//  Synopsis:   Add to the list in time sorted order.
//
//  Arguments:  [ftRun] -
//              [ftDeadline] -
//              [ftKillTime] -
//              [ptszJobName] -
//              [dwJobFlags] -
//              [dwMaxRunTime] -
//              [wIdleWait] -
//              [pCount] - On entry and on exit, points to the number of
//                  elements in the list.
//              [cLimit] - Limit on the number of elements in the list.
//
//  Returns:    S_OK - new run added to the list.
//              S_FALSE - new run not added to the list because the list has
//                  already reached its size limit and the new job's run time
//                  is later than the last run time in the list.
//
//-----------------------------------------------------------------------------
HRESULT
CTimeRunList::AddSorted(FILETIME ftRun, FILETIME ftDeadline, FILETIME ftKillTime,
                        LPTSTR ptszJobName,
                    DWORD dwJobFlags, DWORD dwMaxRunTime, WORD wIdleWait,
                    WORD * pCount, WORD cLimit)
{
    schAssert(*pCount <= cLimit);

    //
    // The list is monotonically increasing in time. Traverse the list in
    // reverse order since the most common case will be to put the new
    // element at the end. That is, except in the case of overlapping
    // duration intervals, the run times for the same trigger will be
    // discovered in monotonically increasing order.
    //
    // For merging in the run times from separate triggers or jobs, the runs
    // will not be in any predictable order. In this case, it doesn't matter
    // from which end the search starts.
    //
    // CODEWORK  Use IsNull() instead of GetTime().  Make this loop a for loop.
    //
    FILETIME ftCur;
    CRun * pRun = m_RunHead.Prev();
    pRun->GetTime(&ftCur);
    //
    // Note that the head element is merely a marker (since this is a doubly
    // linked, circular list) and has its time value set to zero. Thus if we
    // reach a zero FILETIME, we have reached the head and thus know that
    // there is no list element with a later time, so insert at the tail.
    //
    while (ftCur.dwLowDateTime || ftCur.dwHighDateTime)
    {
        if (CompareFileTime(&ftCur, &ftRun) == 0)
        {
            //
            // Duplicate found, check for job name match. If here as a result
            // of a call to ITask::GetRunTimes, then both will be null. We
            // want duplicates eliminated in this case. Otherwise, compare
            // names.
            //
            if ((pRun->GetName() == NULL && ptszJobName == NULL) ||
                (pRun->GetName() != NULL && ptszJobName != NULL &&
                 lstrcmpi(pRun->GetName(), ptszJobName) == 0))
            {
                // keep the one already in the list but set the kill time
                // to the earlier of the two,
                // set the idle wait time to the lesser (less restrictive)
                // of the two
                // and set the start deadline to the later (less
                // restrictive) of the two.
                //

                pRun->ReduceWaitTo(wIdleWait);

                pRun->AdvanceKillTime(ftKillTime);

                pRun->RelaxDeadline(ftDeadline);

                // (There is no reason for the MaxRunTime to be different)
                schAssert(pRun->GetMaxRunTime() == dwMaxRunTime);
                return S_OK;
            }
        }

        if (CompareFileTime(&ftCur, &ftRun) < 0)
        {
            //
            // The new run is later than the current, so we are at the
            // insertion point.
            //
            break;
        }
        pRun = pRun->Prev();
        pRun->GetTime(&ftCur);
    }

    //
    // If the list is already at its maximum size, discard either the
    // last element or the one we were about to insert, whichever is
    // later.
    //
    if (*pCount >= cLimit)
    {
        CRun * pLast = m_RunHead.Prev();
        if (pLast == pRun)
        {
            //
            // We were about to insert after the last element.
            //
            return S_FALSE;
        }
        else
        {
            //
            // Discard the last element before inserting the new one.
            //
            pLast->UnLink();
            delete pLast;
            (*pCount)--;
        }
    }

    //
    // Create the new element and insert after the current one.
    //
    CRun * pNewRun = new CRun(&ftRun, &ftDeadline, ftKillTime, dwMaxRunTime,
                              dwJobFlags, wIdleWait, FALSE);
    if (!pNewRun)
    {
        ERR_OUT("RunList: Add", E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }
    HRESULT hr = pNewRun->SetName(ptszJobName);
    if (FAILED(hr))
    {
        ERR_OUT("CRunList::AddSorted SetName", hr);
        delete pNewRun;
        return hr;
    }

    pNewRun->SetNext(pRun->Next());
    pNewRun->Next()->SetPrev(pNewRun);
    pRun->SetNext(pNewRun);
    pNewRun->SetPrev(pRun);

    //
    // Increment the count.
    //
    (*pCount)++;

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CIdleRunList::AddSortedByIdleWait
//
//  Synopsis:   Add to the list in time sorted order.
//
//-----------------------------------------------------------------------------
void
CIdleRunList::AddSortedByIdleWait(CRun * pAdd)
{
    //
    // If the system needs to stay awake to run this task, increment the
    // thread's wake count.  (We know that this is always called by the
    // worker thread.)
    //
    if (pAdd->IsFlagSet(TASK_FLAG_SYSTEM_REQUIRED))
    {
        WrapSetThreadExecutionState(TRUE, "AddSortedByIdleWait");
    }

    if (m_RunHead.Next()->IsNull())
    {
        // List is empty, so add this as the first element.
        //
        pAdd->LinkAfter(&m_RunHead);
        return;
    }

    WORD wAddWait = pAdd->GetWait();
    schAssert(wAddWait > 0);    // We should never put a job in the idle wait
                                // list if its idle wait time is 0

    //
    // Walk the list, comparing idle wait times.
    //
    CRun * pCur = m_RunHead.Next();
    while (!pCur->IsNull())
    {
        if (wAddWait < pCur->GetWait())
        {
            pAdd->LinkBefore(pCur);
            return;
        }
        pCur = pCur->Next();
    }

    //
    // Add to the end of the list.
    //
    pAdd->LinkBefore(pCur);
}

//+----------------------------------------------------------------------------
//
//  Member:     CIdleRunList::GetFirstWait
//
//  Synopsis:   Finds the lowest idle wait time of the jobs in the list that
//              haven't already been started in this idle period.
//              Returns 0xffff if there is no such job.
//
//-----------------------------------------------------------------------------
WORD
CIdleRunList::GetFirstWait()
{
    for (CRun * pRun = m_RunHead.Next();
         !pRun->IsNull();
         pRun = pRun->Next())
    {
        if (!pRun->m_fStarted)
        {
            // (We should never have inserted a run with zero wait time)
            schAssert(pRun->GetWait() != 0);

            return (pRun->GetWait());
        }
    }

    return 0xffff;
}

//+----------------------------------------------------------------------------
//
//  Member:     CIdleRunList::MarkNoneStarted
//
//  Synopsis:   Marks all jobs in the idle list as not having been started in
//              the current idle period.
//
//-----------------------------------------------------------------------------
void
CIdleRunList::MarkNoneStarted()
{
    schDebugOut((DEB_IDLE, "Marking idle jobs as not started\n"));
    for (CRun * pRun = GetFirstJob();
         !pRun->IsNull();
         pRun = pRun->Next())
    {
        pRun->m_fStarted = FALSE;
    }
}

//+----------------------------------------------------------------------------
//
//  Member:     CRunList::AddCopy
//
//  Synopsis:   Add a copy of the object to the list.
//
//-----------------------------------------------------------------------------
HRESULT
CRunList::AddCopy(CRun * pOriginal)
{
    CRun * pCopy = new CRun(pOriginal);
    if (pCopy == NULL)
    {
        return E_OUTOFMEMORY;
    }

    pCopy->LinkAfter(&m_RunHead);
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CTimeRunList::Pop
//
//  Synopsis:   Removes the first (earliest) time element from the list and
//              returns it.
//
//-----------------------------------------------------------------------------
CRun *
CTimeRunList::Pop(void)
{
    CRun * pPop = m_RunHead.Next();

    if (pPop->IsNull())
    {
        // List is empty, so return a flag return code.
        //
        return NULL;
    }

    pPop->UnLink();

    return pPop;
}

//+----------------------------------------------------------------------------
//
//  Member:     CTimeRunList::PeekHeadTime
//
//  Synopsis:   Returns the filetime value for the element at the head of the
//              list.
//
//-----------------------------------------------------------------------------
HRESULT
CTimeRunList::PeekHeadTime(LPFILETIME pft)
{
    if (m_RunHead.Next()->IsNull())
    {
        // List is empty, so return a flag return code.
        //
        return S_FALSE;
    }

    m_RunHead.Next()->GetTime(pft);

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   CTimeRunList::MakeSysTimeArray
//
//  Synopsis:   returns the run list times as an array of SYSTEMTIME structs.
//
//  Arguments:  [prgst]  - a pointer to the returned array of filetime structs
//                         is stored here.  This function allocates the array
//                         using CoTaskMemAlloc.  It must be freed by the caller.
//              [pCount] - On entry, points to an upper limit on the number of
//                         array elements to return.  On exit, points to the
//                         actual number returned.
//
//  Returns:    E_OUTOFMEMORY, S_OK
//
//-----------------------------------------------------------------------------
HRESULT
CTimeRunList::MakeSysTimeArray(LPSYSTEMTIME * prgst, WORD * pCount)
{
    WORD cLimit = *pCount;
    *pCount = 0;
    *prgst = (LPSYSTEMTIME) CoTaskMemAlloc(cLimit * sizeof(SYSTEMTIME));
    if (*prgst == NULL)
    {
        return E_OUTOFMEMORY;
    }

    //
    // Skip the head, it is a placeholder in the circular list with a time
    // value of zero.
    //
    for (CRun * pCur = m_RunHead.Next();
         (*pCount < cLimit) && (!pCur->IsNull());
         (*pCount)++, pCur = pCur->Next())
    {
        pCur->GetSysTime( &(*prgst)[*pCount] );
    }

    return S_OK;
}


//+----------------------------------------------------------------------------
//
//  Member:     CIdleRunList::FreeList
//
//  Synopsis:   Same as CRunList::FreeList except it decrements the thread's
//              wake count for each system-required run in the list.  (We
//              know this method is only called by the worker thread.)
//
//-----------------------------------------------------------------------------
void
CIdleRunList::FreeList()
{
    CRun * pCur = m_RunHead.Next();

    while (!pCur->IsNull())
    {
        CRun * pNext = pCur->Next();
        pCur->UnLink();
        if (pCur->IsFlagSet(TASK_FLAG_SYSTEM_REQUIRED))
        {
            WrapSetThreadExecutionState(FALSE, "CIdleRunList::FreeList");
        }
        delete pCur;
        pCur = pNext;
    }
}

//+----------------------------------------------------------------------------
//
//  Member:     CIdleRunList::FreeExpiredOrRegenerated
//
//  Synopsis:   This method is called when rebuilding the idle wait list from
//              the data in the tasks folder.
//              Removes runs that have m_fKeepInList set.  (These correspond
//              to jobs with idle triggers.)  Also purges expired runs.
//              Runs that don't have m_fKeepInList set correspond to runs that
//              have been triggered due to some other event, and are waiting
//              for an idle period; these are not removed here.
//
//-----------------------------------------------------------------------------
void
CIdleRunList::FreeExpiredOrRegenerated()
{
    // BUGBUG ftNow should be a parameter
    FILETIME ftNow = GetLocalTimeAsFileTime();

    CRun * pNext;
    for (CRun *pRun = m_RunHead.Next();
         !pRun->IsNull();
         pRun = pNext)
    {
        pNext = pRun->Next();

        if (pRun->IsIdleTriggered() ||
            CompareFileTime(pRun->GetDeadline(), &ftNow) < 0)
        {
            pRun->UnLink();

            //
            // If the system needed to stay awake to run this task, decrement
            // the thread's wake count.  (We know that this is always called
            // by the worker thread.)
            //
            if (pRun->IsFlagSet(TASK_FLAG_SYSTEM_REQUIRED))
            {
                WrapSetThreadExecutionState(FALSE,
                        "CIdleRunList::FreeExpiredOrRegenerated");
            }

            delete pRun;
        }
    }
}


//+----------------------------------------------------------------------------
//
//  Function:   WrapSetThreadExecutionStateFn
//
//  Synopsis:   Wrapper for dynamically loaded function
//
//-----------------------------------------------------------------------------
void WINAPI
WrapSetThreadExecutionStateFn(
    BOOL   fSystemRequired
#if DBG
  , LPCSTR pszDbgMsg    // parameter for debug output message
#endif
    )
{
    DWORD dwCount = (DWORD) (ULONG_PTR)TlsGetValue(g_WakeCountSlot);

    if (fSystemRequired)
    {
        //
        // Increment this thread's keep-awake count.  If it was zero,
        // set the system-required state.
        //
        schDebugOut((DEB_USER5, "INCREMENTING keep-awake count to %ld: %s\n",
                     dwCount + 1, pszDbgMsg));
        schAssert(dwCount != (DWORD) -1);
        dwCount++;
        if (dwCount == 1)
        {
            if (pfnSetThreadExecutionState != NULL)
            {
                schDebugOut((DEB_USER5, "SETTING   sys-required state\n"));
                (pfnSetThreadExecutionState)(ES_CONTINUOUS | ES_SYSTEM_REQUIRED);
            }
        }
    }
    else
    {
        //
        // Decrement this thread's keep-awake count.  If it becomes zero,
        // reset the system-required state.
        //
        schDebugOut((DEB_USER5, "DECREMENTING keep-awake count to %ld: %s\n",
                     dwCount - 1, pszDbgMsg));
        schAssert(dwCount != 0);

        dwCount--;
        if (dwCount == 0)
        {
            if (pfnSetThreadExecutionState != NULL)
            {
                schDebugOut((DEB_USER5, "RESETTING sys-required state\n"));
                (pfnSetThreadExecutionState)(ES_CONTINUOUS);
            }
        }
    }


    if (!TlsSetValue(g_WakeCountSlot, UlongToPtr(dwCount)))
    {
        ERR_OUT("TlsSetValue", GetLastError());
    }
}


//+----------------------------------------------------------------------------
//
//  Function:   InitThreadWakeCount
//
//  Synopsis:   Initialize this thread's keep-awake count.
//
//-----------------------------------------------------------------------------
void
InitThreadWakeCount()
{
    schDebugOut((DEB_USER5, "INITIALIZING keep-awake count to 0\n"));
    if (!TlsSetValue(g_WakeCountSlot, 0))
    {
        ERR_OUT("TlsSetValue", GetLastError());
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\common\sadat.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       sadat.cxx
//
//  Contents:   Routines which manipulate the SA.DAT file in the Tasks
//              folder. This file is used by both the service and the UI
//              to determine service state, OS info, etc.
//
//  Classes:    None.
//
//  Functions:  SADatGetData
//              SADatPath
//              SADatCreate
//              SADatSetData
//              SADatSetSecurity
//
//  History:    08-Jul-96   MarkBl  Created
//              22-May-01   drbeck, jbenton  Added SADatSetSecurity
//
//----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "..\inc\debug.hxx"
#include "..\inc\sadat.hxx"

//Required for adding ACE to sa.dat file
#include <Accctrl.h>
#include <Aclapi.h>

DWORD 
SADatSetSecurity(
    HANDLE hFile);   // handle to file to add ACE

HRESULT
SADatGetData(
    HANDLE  hFile,
    DWORD   cbData,
    BYTE    rgbData[]);

void
SADatPath(
    LPCTSTR ptszFolderPath,
    LPTSTR  ptszSADatPath);

#ifdef _CHICAGO_
//
// These routines exist on Win98, NT4 and NT5 but not on Win95
//
typedef VOID (APIENTRY *PTIMERAPCROUTINE)(
    LPVOID lpArgToCompletionRoutine,
    DWORD dwTimerLowValue,
    DWORD dwTimerHighValue
    );

typedef HANDLE (WINAPI *PFNCreateWaitableTimerA)(
    LPSECURITY_ATTRIBUTES lpTimerAttributes,
    BOOL bManualReset,
    LPCSTR lpTimerName
    );

typedef BOOL (WINAPI *PFNSetWaitableTimer)(
    HANDLE hTimer,
    const LARGE_INTEGER *lpDueTime,
    LONG lPeriod,
    PTIMERAPCROUTINE pfnCompletionRoutine,
    LPVOID lpArgToCompletionRoutine,
    BOOL fResume
    );
#endif // _CHICAGO_

//+---------------------------------------------------------------------------
//
//  Function:   SADatGetData
//
//  Synopsis:   Retrieve and validate data from the file, SA.DAT, located
//              in the folder path specified.
//
//  Arguments:  [ptszFolderPath] -- SA.DAT path location.
//              [cbData]         -- Data buffer size.
//              [rgbData]        -- Data buffer.
//              [phFile]         -- Optional return handle.
//
//  Returns:    S_OK
//              E_UNEXPECTED if the amount read isn't what we expected or the
//                data is invalid.
//              Create/ReadFile HRESULT status code on failure.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
SADatGetData(
    LPCTSTR  ptszFolderPath,
    DWORD    cbData,
    BYTE     rgbData[],
    HANDLE * phFile)
{
    schAssert(cbData >= SA_DAT_VERSION_ONE_SIZE);

    //
    // Open SA.DAT in the folder path indicated. Fail if it doesn't exist.
    //

    TCHAR tszSADatPath[MAX_PATH + 1];
    SADatPath(ptszFolderPath, tszSADatPath);

    HANDLE hFile = CreateFile(tszSADatPath,
                              GENERIC_READ |
                                (phFile != NULL ? GENERIC_WRITE : 0),
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_HIDDEN,
                              NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
#if DBG == 1
        if (GetLastError() != ERROR_FILE_NOT_FOUND)
        {
            CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        }
#endif // DBG == 1
        return HRESULT_FROM_WIN32(GetLastError());
    }

    //
    // Read & validate file content.
    //

    HRESULT hr = SADatGetData(hFile, cbData,  rgbData);

    if (SUCCEEDED(hr))
    {
        //
        // No need to verify the size or the service flags. We've read at
        // least the amount expected, and for this version, only the LSB
        // of the service flags is used. Future versions may wish to do
        // further flag checks.
        //

        BYTE bPlatform;
        CopyMemory(&bPlatform, rgbData + SA_DAT_PLATFORM_OFFSET,
                        sizeof(bPlatform));

        if (bPlatform != VER_PLATFORM_WIN32_NT &&
            bPlatform != VER_PLATFORM_WIN32_WINDOWS)
        {
            hr = E_UNEXPECTED;
            CHECK_HRESULT(hr);
        }
        else
        {
            if (phFile != NULL)     // Optional return handle.
            {
                //
                // Reset the file pointer to the beginning for the returned
                // handle.
                //

                if (SetFilePointer(hFile,
                                    0,
                                    NULL,
                                    FILE_BEGIN) != -1)
                {
                    *phFile = hFile;
                    hFile   = NULL;
                }
                else
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    CHECK_HRESULT(hr);
                }
            }
        }
    }

    if (hFile != NULL) CloseHandle(hFile);

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   SADatGetData
//
//  Synopsis:   A more refined version of the overloaded function above.
//              Return individual fields instead of raw data.
//
//  Arguments:  [ptszFolderPath] -- SA.DAT path location.
//              [pdwVersion]     -- Returned version.
//              [pbPlatform]     -- Returned platform id.
//              [prgSvcFlags]    -- Returned service flags.
//
//  Returns:    SADatGetData return code.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
SADatGetData(
    LPCTSTR  ptszFolderPath,
    DWORD *  pdwVersion,
    BYTE *   pbPlatform,
    BYTE *   prgSvcFlags)
{
    BYTE    rgbData[SA_DAT_VERSION_ONE_SIZE];
    HRESULT hr;

    hr = SADatGetData(ptszFolderPath, SA_DAT_VERSION_ONE_SIZE, rgbData);

    if (SUCCEEDED(hr))
    {
        *pdwVersion = (DWORD)*rgbData;
        CopyMemory(pbPlatform, rgbData + SA_DAT_PLATFORM_OFFSET,
                        sizeof(*pbPlatform));
        CopyMemory(prgSvcFlags, rgbData + SA_DAT_SVCFLAGS_OFFSET,
                        sizeof(*prgSvcFlags));
    }

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   SADatCreate
//
//  Synopsis:   Create & initialize the binary file, SA.DAT, in the Tasks
//              folder. The platform id is set to indicate which OS we're
//              currently running under; the service flag is set to 1
//              to indicate the service is running.
//
//  Arguments:  [ptszFolderPath]  -- Path to the Tasks folder.
//              [fServiceRunning] -- Flag indicating running service.
//
//  Returns:    S_OK
//              E_UNEXPECTED if the amount written isn't what we expected.
//              Create/WriteFile HRESULT status code on failure.
//
//  Notes:      This is to be called by the service only with service start.
//
//----------------------------------------------------------------------------
HRESULT
SADatCreate(
    LPCTSTR  ptszFolderPath,
    BOOL     fServiceRunning)
{
    BYTE rgbData[SA_DAT_VERSION_ONE_SIZE];
    DWORD dwResult;

    //
    // Set size.
    //

    DWORD dwSize = SA_DAT_VERSION_ONE_SIZE;
    CopyMemory(rgbData, &dwSize, sizeof(dwSize));


    //
    // Set the platform id.
    //

    OSVERSIONINFO osverinfo;
    osverinfo.dwOSVersionInfoSize = sizeof(osverinfo);

    if (!GetVersionEx(&osverinfo))
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    BYTE bPlatform;
    if (osverinfo.dwPlatformId == VER_PLATFORM_WIN32_NT)    // NT
    {
        bPlatform = VER_PLATFORM_WIN32_NT;
    }
    else                                                    // Assume windows
    {
        bPlatform = VER_PLATFORM_WIN32_WINDOWS;
    }

    CopyMemory(rgbData + SA_DAT_PLATFORM_OFFSET, &bPlatform,
                    sizeof(bPlatform));

    //
    // Set the service flags to indicate the service is running.
    //

    BYTE rgfServiceFlags = (fServiceRunning ? SA_DAT_SVCFLAG_SVC_RUNNING : 0);

    //
    // Determine whether the machine supports wakeup timers.
    //
    if (ResumeTimersSupported())
    {
        rgfServiceFlags |= SA_DAT_SVCFLAG_RESUME_TIMERS;
    }

    rgbData[SA_DAT_SVCFLAGS_OFFSET] = rgfServiceFlags;

    //
    // Create the file. Overwrite, if it exists.
    //

    TCHAR tszSADatPath[MAX_PATH + 1];
    SADatPath(ptszFolderPath, tszSADatPath);

    //
    // First clear any extraneous attribute bits that were added by
    // somebody else that would cause the CreateFile to fail
    //

    if (!SetFileAttributes(tszSADatPath, FILE_ATTRIBUTE_HIDDEN))
    {

#if DBG == 1

        //
        // Not a problem if the file doesn't exist
        //

        if (GetLastError() != ERROR_FILE_NOT_FOUND)
        {
            CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        }

#endif  // DBG == 1

    }

    HANDLE hFile = CreateFile(tszSADatPath,
                              GENERIC_READ | GENERIC_WRITE | WRITE_DAC,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              NULL,
                              CREATE_ALWAYS,
                              FILE_ATTRIBUTE_HIDDEN,
                              NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        return HRESULT_FROM_WIN32(GetLastError());
    }

    // Add read ACE for authenticated users
    dwResult = SADatSetSecurity(hFile);

    if( ERROR_SUCCESS != dwResult )
    {
       CloseHandle(hFile);

       CHECK_HRESULT(HRESULT_FROM_WIN32(dwResult));
       return HRESULT_FROM_WIN32(dwResult);
    }

    //
    // Write out the contents.
    //

    HRESULT hr = SADatSetData(hFile, sizeof(rgbData), rgbData);

    CloseHandle(hFile);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   SADatGetData
//
//  Synopsis:   Nothing SA.DAT-specific here. Just a helper to read a blob
//              of bytes from the file indicated, and ensure we read the
//              amount expected.
//
//  Arguments:  [hFile]   -- Destination file.
//              [cbData]  -- Amount of data to read.
//              [rgbData] -- Read data.
//
//  Returns:    S_OK
//              E_UNEXPECTED if the amount read isn't what we expected.
//              ReadFile HRESULT status code on failure.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
SADatGetData(
    HANDLE  hFile,
    DWORD   cbData,
    BYTE    rgbData[])
{
    DWORD cbRead;
    if (!ReadFile(hFile,
                  rgbData,
                  cbData,
                  &cbRead,
                  NULL))
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        return HRESULT_FROM_WIN32(GetLastError());
    }

    if (cbRead != cbData)
    {
        CHECK_HRESULT(E_UNEXPECTED);
        return E_UNEXPECTED;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   SADatSetData
//
//  Synopsis:   Nothing SA.DAT-specific here. Just a helper to write a blob
//              of bytes to the file indicated, and ensure we wrote the
//              amount expected.
//
//  Arguments:  [hFile]   -- Destination file.
//              [cbData]  -- Amount of data to write.
//              [rgbData] -- Actual data.
//
//  Returns:    S_OK
//              E_UNEXPECTED if the amount written isn't what we expected.
//              WriteFile HRESULT status code on failure.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
SADatSetData(
    HANDLE     hFile,
    DWORD      cbData,
    const BYTE rgbData[])
{
    DWORD cbWritten;
    if (!WriteFile(hFile,
                   rgbData,
                   cbData,
                   &cbWritten,
                   NULL))
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        return HRESULT_FROM_WIN32(GetLastError());
    }

    if (cbWritten != cbData)
    {
        CHECK_HRESULT(E_UNEXPECTED);
        return E_UNEXPECTED;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   SADatPath
//
//  Synopsis:   Return a concatenation the folder path and "\SA.DAT".
//
//  Arguments:  [ptszFolderPath] -- Folder path.
//              [ptszSADatPath]  -- New path.
//
//  Returns:    None.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
void
SADatPath(
    LPCTSTR ptszFolderPath,
    LPTSTR  ptszSADatPath)
{
    TCHAR tszSADat[] = TEXT("\\SA.DAT");

#if (DBG == 1)

    //
    // Assert that the folder path:
    //  is not NULL
    //  is not an empty string
    //  does not end in a backslash
    //

    schAssert(ptszFolderPath != NULL);
    schAssert(*ptszFolderPath);
    LPCTSTR ptszLastSlash = _tcsrchr(ptszFolderPath, TEXT('\\'));
    schAssert(!ptszLastSlash || ptszLastSlash[1]);

#endif // (DBG == 1)

    lstrcpy(ptszSADatPath, ptszFolderPath);
    lstrcat(ptszSADatPath, tszSADat);
}

//+---------------------------------------------------------------------------
//
//  Function:   ResumeTimersSupported
//
//  Synopsis:   Jumps through hoops to determine whether the machine supports
//              resume timers (aka wakeup timers)
//
//  Arguments:  None.
//
//  Returns:    TRUE - Resume timers are supported
//              FALSE - Resume timers are not supported
//
//----------------------------------------------------------------------------
BOOL
ResumeTimersSupported()
{
    HANDLE  hTimer;

#ifdef _CHICAGO_

    PFNCreateWaitableTimerA pfnCreateWaitableTimerA;
    PFNSetWaitableTimer     pfnSetWaitableTimer;

    HMODULE hKernel32Dll = GetModuleHandle("KERNEL32.DLL");
    if (hKernel32Dll == NULL)
    {
        ERR_OUT("Load of kernel32.dll", GetLastError());
        return FALSE;
    }

    pfnCreateWaitableTimerA = (PFNCreateWaitableTimerA)
            GetProcAddress(hKernel32Dll, "CreateWaitableTimerA");
    pfnSetWaitableTimer     = (PFNSetWaitableTimer)
            GetProcAddress(hKernel32Dll, "SetWaitableTimer");
    if (pfnCreateWaitableTimerA == NULL ||
        pfnSetWaitableTimer == NULL)
    {
        ERR_OUT("GetProcAddress in kernel32.dll", GetLastError());
        return FALSE;
    }

    hTimer = pfnCreateWaitableTimerA(NULL, TRUE, NULL);

#else // !_CHICAGO_

    hTimer = CreateWaitableTimer(NULL, TRUE, NULL);

#endif // _CHICAGO_

    if (hTimer == NULL)
    {
        ERR_OUT("CreateWaitableTimer", GetLastError());
        return FALSE;
    }

    LARGE_INTEGER li = { 0xFFFFFFFF, 0xFFFFFFFF };
    BOOL    fResult = FALSE;

#ifdef _CHICAGO_
    if (pfnSetWaitableTimer(hTimer, &li, 0, NULL, 0, TRUE))
#else // !_CHICAGO_
    if (SetWaitableTimer(hTimer, &li, 0, NULL, 0, TRUE))
#endif // _CHICAGO_
    {
        //
        // By design, this call to SetWaitableTimer will succeed even on
        // machines that do NOT support resume timers.  GetLastError must
        // be used to determine if, indeed, the machine supports resume
        // timers.
        //
        if (GetLastError() == ERROR_NOT_SUPPORTED)
        {
            // This machine does not support resume timers
            DBG_OUT("Machine does not support resume timers");
        }
        else
        {
            DBG_OUT("Machine supports resume timers");
            fResult = TRUE;
        }
    }
    else
    {
        ERR_OUT("SetWaitableTimer", GetLastError());
    }

    CloseHandle(hTimer);

    return fResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   SADatSetSecurity
//
//  Synopsis:   Add an ACE to the file that allows authenticated users to
//              read the file. We cannot rely on inheriting the necessary 
//              permissions of the containing folder.
//
//  Arguments:  [hFile]   -- Destination file.
//
//  Returns:    ERROR_SUCCESS upon success
//              Non zero value upon failure
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
DWORD SADatSetSecurity (
    HANDLE hFile             // handle to file
) 
{
   DWORD                dwRes = ERROR_SUCCESS;
   PSID                 pSid     = NULL;
   PACL                 pOldDACL = NULL;
   PACL                 pNewDACL = NULL;
   PSECURITY_DESCRIPTOR pSD      = NULL;
   EXPLICIT_ACCESS      ExplicAcc;
   
   schAssert(hFile != NULL);
   
   // Create the SID for "NTAUTH\Athenticated Users"
   SID_IDENTIFIER_AUTHORITY NtAuth = SECURITY_NT_AUTHORITY;
   
   if (  !AllocateAndInitializeSid(
            &NtAuth,
            1,
            SECURITY_AUTHENTICATED_USER_RID, 
            0, 0, 0, 0, 0, 0, 0,
            &pSid
            )
      )
   {
      dwRes = GetLastError();
      goto Cleanup;
   }
   
   
   // Get a pointer to the existing DACL.
   dwRes = GetSecurityInfo(
      hFile, 
      SE_FILE_OBJECT, 
      DACL_SECURITY_INFORMATION,
      NULL, 
      NULL, 
      &pOldDACL, 
      NULL, 
      &pSD
      );
   
   if (ERROR_SUCCESS != dwRes)
   {
      goto Cleanup; 
   }  
   
   // Initialize an EXPLICIT_ACCESS structure for the new ACE. 
   
   ZeroMemory(&ExplicAcc, sizeof(EXPLICIT_ACCESS));
   
   ExplicAcc.grfAccessPermissions = GENERIC_READ;
   ExplicAcc.grfAccessMode        = GRANT_ACCESS;
   ExplicAcc.grfInheritance       = NO_INHERITANCE;
   ExplicAcc.Trustee.TrusteeForm  = TRUSTEE_IS_SID;
   ExplicAcc.Trustee.ptstrName    = (LPTSTR)pSid;
   
   // Create a new ACL that merges the new ACE
   // into the existing DACL.
   
   dwRes = SetEntriesInAcl(1, &ExplicAcc, pOldDACL, &pNewDACL);
   if (ERROR_SUCCESS != dwRes)
   {
      goto Cleanup; 
   }  
   
   // Attach the new ACL as the file's DACL.
   
   dwRes = SetSecurityInfo(
      hFile, 
      SE_FILE_OBJECT, 
      DACL_SECURITY_INFORMATION,
      NULL, 
      NULL, 
      pNewDACL, 
      NULL
      );
   
   if (ERROR_SUCCESS != dwRes)
   {
      goto Cleanup; 
   }  
   
   Cleanup:
   
   if(pSD != NULL) 
   {
      LocalFree((HLOCAL) pSD); 
   }
   
   if(pNewDACL != NULL) 
   {
      LocalFree((HLOCAL) pNewDACL); 
   }
   
   if( pSid != NULL )
   {
      FreeSid(pSid);
   }

   return dwRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\common\path.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
// 
//  File:       path.cxx
//
//  Contents:   Common routines for processing file and pathnames.
//
//  History:    11-22-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop

#include <regstr.h> // for app path reg key constant
#include "..\inc\common.hxx"
#include "..\inc\misc.hxx"
#include "..\inc\debug.hxx"



//
// Forward references
//

LPCTSTR 
FindFirstTrailingSpace(LPCTSTR ptsz);

BOOL 
FileExistsInPath(
        LPTSTR  ptszFilename,
        LPCTSTR ptszPath, 
        LPTSTR  ptszFoundFile, 
        ULONG   cchFoundBuf);


//+--------------------------------------------------------------------------
//
//  Function:   ProcessApplicationName
//
//  Synopsis:   Canonicalize and search for [ptszFilename].
//
//  Arguments:  [ptszFilename]  - must be at least MAX_PATH chars long
//              [tszWorkingDir] - "" or a directory not ending in slash
//
//  Returns:    TRUE - a filename was found
//              FALSE - no filename found
//
//  Modifies:   *[ptszFilename]
//
//  History:    11-21-1996   DavidMun   Created
//              06-03-1997   DavidMun   Expand environment vars
//
//  Notes:      This function should only be called to process filenames 
//              on the local machine.
//
//---------------------------------------------------------------------------

BOOL 
ProcessApplicationName(LPTSTR ptszFilename, LPCTSTR tszWorkingDir)
{
    BOOL  fFound = FALSE;
    TCHAR tszFilenameWithExe[MAX_PATH];
 
    //
    // Use tszFilenameWithExe as a temporary buffer for preparing the string 
    // in ptszFilename.  Get rid of lead/trail spaces and double quotes, then
    // expand environment strings. 
    // 

    lstrcpy(tszFilenameWithExe, ptszFilename);
    StripLeadTrailSpace(tszFilenameWithExe);
    DeleteQuotes(tszFilenameWithExe);
    ExpandEnvironmentStrings(tszFilenameWithExe, ptszFilename, MAX_PATH);
    tszFilenameWithExe[0] = TEXT('\0');

    ULONG cchFilename = lstrlen(ptszFilename);

    //
    // If the filename doesn't end with .exe, and the resulting string
    // wouldn't be greater than MAX_PATH, create a version of the filename
    // with .exe appended.
    //
    // Note this will prevent us from finding foo.exe.exe when we're given
    // foo.exe, but the performance gained by excluding this case outweighs
    // the value of completeness, since it's unlikely anyone would create
    // such a filename.
    //

    if (cchFilename < MAX_PATH - 4)
    {
        LPTSTR ptszLastDot = _tcsrchr(ptszFilename, TEXT('.'));

        if (!ptszLastDot || lstrcmpi(ptszLastDot, DOTEXE))
        {
            lstrcpy(tszFilenameWithExe, ptszFilename);
            lstrcpy(&tszFilenameWithExe[cchFilename], DOTEXE);
        }
    }
 
    do
    {
        //
        // If the user specified path information (if there is a colon or
        // backslash anywhere in the string), look for the file as
        // specified or with .exe appended, but look nowhere else.
        //

        if (_tcspbrk(ptszFilename, TEXT(":\\")))
        {
            if (*tszFilenameWithExe)
            {
                fFound = FileExists(tszFilenameWithExe);
 
                if (fFound)
                {
                    lstrcpy(ptszFilename, tszFilenameWithExe);
                }
            }
 
            if (!fFound)
            {
                fFound = FileExists(ptszFilename);
            }
            break;
        }

        //
        // First try the working directory
        //

        TCHAR tszFoundFile[MAX_PATH] = TEXT("");

        if (*tszWorkingDir)
        {
            if (*tszFilenameWithExe)
            {
                fFound = FileExistsInPath(tszFilenameWithExe, 
                                          tszWorkingDir, 
                                          tszFoundFile, 
                                          MAX_PATH);
            }
 
            if (!fFound)
            {
                fFound = FileExistsInPath(ptszFilename,
                                          tszWorkingDir, 
                                          tszFoundFile, 
                                          MAX_PATH);
            }
 
            if (fFound)
            {
                lstrcpy(ptszFilename, tszFoundFile);
                break;
            }
        }

        //
        // Next try using the app paths key
        //

        TCHAR tszAppPathVar[MAX_PATH_VALUE] = TEXT("");
        TCHAR tszAppPathDefault[MAX_PATH]   = TEXT("");

        if (*tszFilenameWithExe)
        {
            GetAppPathInfo(tszFilenameWithExe, 
                           tszAppPathDefault, 
                           MAX_PATH, 
                           tszAppPathVar,
                           MAX_PATH_VALUE);
        }

        if (!*tszAppPathDefault && !*tszAppPathVar)
        {
            GetAppPathInfo(ptszFilename, 
                           tszAppPathDefault, 
                           MAX_PATH, 
                           tszAppPathVar,
                           MAX_PATH_VALUE);
        }

        //
        // If there was a default value, try that
        // 

        if (*tszAppPathDefault)
        {
            fFound = FileExists(tszAppPathDefault);

            if (fFound)
            {
                lstrcpy(ptszFilename, tszAppPathDefault);
                break;
            }

            //
            // If there's room, concat .exe to the default and look for 
            // that
            //

            ULONG cchDefault = lstrlen(tszAppPathDefault);
            if (cchDefault < MAX_PATH - 4)
            {
                lstrcat(tszAppPathDefault, DOTEXE);

                fFound = FileExists(tszAppPathDefault);

                if (fFound)
                {
                    lstrcpy(ptszFilename, tszAppPathDefault);
                    break;
                }
            }
        }

        //
        // If the app path key specified a value for the PATH variable,
        // try looking in all the directories it specifies 
        //

        if (*tszAppPathVar)
        {
            if (*tszFilenameWithExe)
            {
                fFound = FileExistsInPath(tszFilenameWithExe, 
                                          tszAppPathVar, 
                                          tszFoundFile, 
                                          MAX_PATH);
            }

            if (!fFound)
            {
                fFound = FileExistsInPath(ptszFilename, 
                                          tszAppPathVar, 
                                          tszFoundFile, 
                                          MAX_PATH);
            }

            if (fFound)
            {
                lstrcpy(ptszFilename, tszFoundFile);
                break;
            }
        }

        //
        // Try looking along the system PATH variable
        //

        ULONG cchPath;
        TCHAR tszSystemPath[MAX_PATH_VALUE] = TEXT("");

        cchPath = GetEnvironmentVariable(TEXT("Path"), 
                                         tszSystemPath,
                                         MAX_PATH_VALUE);

        if (!cchPath || cchPath > MAX_PATH_VALUE)
        {
            break;
        }

        if (*tszFilenameWithExe)
        {
            fFound = FileExistsInPath(tszFilenameWithExe, 
                                      tszSystemPath, 
                                      tszFoundFile, 
                                      MAX_PATH);
        }

        if (!fFound)
        {
            fFound = FileExistsInPath(ptszFilename, 
                                      tszSystemPath, 
                                      tszFoundFile, 
                                      MAX_PATH);
        }

        if (fFound)
        {
            lstrcpy(ptszFilename, tszFoundFile);
        }
    } while (0);
 
    return fFound;
}



//+--------------------------------------------------------------------------
//
//  Function:   IsLocalFilename
//
//  Synopsis:   Return TRUE if [tszFilename] represents a file on the local
//              machine, FALSE otherwise.
//
//  History:    1-31-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
IsLocalFilename(LPCTSTR tszFilename)
{
    if (!tszFilename || !*tszFilename)
    {
        return FALSE;
    }

    if (tszFilename[0] == TEXT('\\') && tszFilename[1] == TEXT('\\'))
    {
        //
        // Find the length of the portion of the name belonging to the machine name
        //
        LPCTSTR ptszNextSlash = _tcschr(tszFilename + 2, TEXT('\\'));
        if (!ptszNextSlash)
        {
            return FALSE;
        }
        DWORD cchMachineName = (DWORD)(ptszNextSlash - tszFilename - 2);
    
        //
        // Get the local machine name (both NetBIOS and FQDN) to compare with that passed in.
        //
        TCHAR tszLocalName[SA_MAX_COMPUTERNAME_LENGTH + 1];
        DWORD cchLocalName = SA_MAX_COMPUTERNAME_LENGTH + 1;
        if (!GetComputerName(tszLocalName, &cchLocalName))
        {
            ERR_OUT("IsLocalFilename: GetComputerName", HRESULT_FROM_WIN32(GetLastError()));
            return FALSE;
        }

        TCHAR tszFQDN[SA_MAX_COMPUTERNAME_LENGTH + 1];
        DWORD cchFQDN = SA_MAX_COMPUTERNAME_LENGTH + 1;
        if (!GetComputerNameEx(ComputerNamePhysicalDnsFullyQualified, tszFQDN, &cchFQDN))
        {
            ERR_OUT("IsLocalFilename: GetComputerNameEx", HRESULT_FROM_WIN32(GetLastError()));
            return FALSE;
        }

        //
        // Return whether we have a match on the machine name portion.
        // I'm assuming that we won't have a case where the NetBIOS name
        // and the FQDN are the same length but different.
        //
        if (cchMachineName == cchLocalName)
        {
            return lstrcmpi(tszFilename + 2, tszLocalName) == 0;
        }
        else if (cchMachineName == cchFQDN)
        {
            return lstrcmpi(tszFilename + 2, tszFQDN) == 0;
        }
        else
        {
            // if the lengths didn't match, there's no need
            // to even bother with a string comparison
            return FALSE;
        }
    }

    if (s_isDriveLetter(tszFilename[0]) && tszFilename[1] == TEXT(':'))
    {
        TCHAR tszRoot[] = TEXT("x:\\");
        tszRoot[0] = tszFilename[0];
        UINT uiType = GetDriveType(tszRoot);
        if (uiType == DRIVE_REMOTE || uiType == 0 || uiType == 1)
        {
            return FALSE;
        }
    }
    return TRUE;
}




//+--------------------------------------------------------------------------
//
//  Function:   StripLeadTrailSpace
//
//  Synopsis:   Delete leading and trailing spaces from [ptsz].
//
//  History:    11-22-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
StripLeadTrailSpace(LPTSTR ptsz)
{
    ULONG cchLeadingSpace = _tcsspn(ptsz, TEXT(" \t"));
    ULONG cch = lstrlen(ptsz);

    //
    // If there are any leading spaces or tabs, move the string
    // (including its nul terminator) left to delete them.
    //

    if (cchLeadingSpace)
    {
        MoveMemory(ptsz, 
                   ptsz + cchLeadingSpace, 
                   (cch - cchLeadingSpace + 1) * sizeof(TCHAR));
        cch -= cchLeadingSpace;
    }

    //
    // Concatenate at the first trailing space
    //

    LPTSTR ptszTrailingSpace = (LPTSTR) FindFirstTrailingSpace(ptsz);

    if (ptszTrailingSpace)
    {
        *ptszTrailingSpace = TEXT('\0');
    }
}


//+--------------------------------------------------------------------------
//
//  Function:   FindFirstTrailingSpace
//
//  Synopsis:   Return a pointer to the first trailing space in [ptsz].
//
//  History:    11-22-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

LPCTSTR 
FindFirstTrailingSpace(LPCTSTR ptsz)
{
    LPCTSTR ptszFirstTrailingSpace = NULL;
    LPCTSTR ptszCur;

    for (ptszCur = ptsz; *ptszCur; ptszCur= NextChar(ptszCur))
    {
        if (*ptszCur == ' ' || *ptszCur == '\t')
        {
            if (!ptszFirstTrailingSpace)
            {
                ptszFirstTrailingSpace = ptszCur;
            }
        }
        else if (ptszFirstTrailingSpace)
        {
            ptszFirstTrailingSpace = NULL;
        }
    }
    return ptszFirstTrailingSpace;
}


//+--------------------------------------------------------------------------
//
//  Function:   DeleteQuotes
//
//  Synopsis:   Delete all instances of the double quote character from
//              [ptsz].
//
//  Arguments:  [ptsz] - nul terminated string
//
//  Modifies:   *[ptsz]
//
//  History:    11-21-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
DeleteQuotes(LPTSTR ptsz)
{
    TCHAR *ptszLead;
    TCHAR *ptszTrail;

    //
    // Move a lead and trail pointer through the buffer, copying from the lead 
    // to the trail whenever the character isn't one we're deleting (a double 
    // quote). 
    // 
    // Note: the "Lead" and "Trail" in ptszLead and ptszTrail do not refer
    // to DBCS lead/trail bytes, rather that the ptszLead pointer can move
    // ahead of ptszTrail when it is advanced past a double quote.
    // 

    for (ptszTrail = ptszLead = ptsz;
         *ptszLead;
         ptszLead = NextChar(ptszLead))
    {
        //
        // If the current char is a double quote, we want it deleted, so don't 
        // copy it and go on to the next char. 
        // 

        if (*ptszLead == TEXT('"'))
        {
            continue;
        }

        //
        // ptszLead is pointing to a 'normal' character, i.e.  not a double 
        // quote. 
        // 
        // It might be the first byte of a two-byte DBCS char if we are 
        // running on Win9x.  Be sure to copy both bytes of such a character 
        // (We're using the terms Lead and Trail in two different senses 
        // here.) 
        //

        if (IsLead(*ptszLead))
        {
            *ptszTrail++ = ptszLead[0];
            *ptszTrail++ = ptszLead[1];
        }
        else
        {
            *ptszTrail++ = ptszLead[0];
        }
    }
    *ptszTrail = TEXT('\0');
}


//+--------------------------------------------------------------------------
//
//  Function:   AddQuotes
//
//  Synopsis:   If there's room in the buffer, insert a quote as the first
//              character and concat a quote as the last character.
//
//  Arguments:  [ptsz]   - string to modify
//              [cchBuf] - size of string's buffer, in chars
//
//  History:    11-22-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
AddQuotes(LPTSTR ptsz, ULONG cchBuf)
{
    ULONG cch = lstrlen(ptsz);

    if (cch < cchBuf - 2)
    {
        MoveMemory(ptsz + 1, ptsz, cch * sizeof(TCHAR));
        *ptsz = ptsz[cch + 1] = TEXT('"');
        ptsz[cch + 2] = TEXT('\0');
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   FileExists
//
//  Synopsis:   Return TRUE if the specified file exists and is not a 
//              directory.
//
//  Arguments:  [ptszFileName] - filename to search for & modify
//
//  Modifies:   Filename portion of [ptszFileName].
//
//  Returns:    TRUE  - file found
//              FALSE - file not found or error
//
//  History:    11-21-96   DavidMun   Created
//
//----------------------------------------------------------------------------

BOOL
FileExists(LPTSTR ptszFileName)
{
    TCHAR tszFullPath[MAX_PATH];
    LPTSTR ptszFilePart;

    ULONG cchFullPath = GetFullPathName(ptszFileName,
                                        MAX_PATH,
                                        tszFullPath,
                                        &ptszFilePart);

    if (cchFullPath && cchFullPath <= MAX_PATH)
    {
        lstrcpy(ptszFileName, tszFullPath);
    }

    ULONG flAttributes; 
 
    flAttributes = GetFileAttributes(ptszFileName);

    // If we couldn't determine file's attributes, don't consider it found

    if (flAttributes == 0xFFFFFFFF)
    {
        return FALSE;
    }

    // if file is actually a directory, it's unsuitable as a task, so fail

    if (flAttributes & FILE_ATTRIBUTE_DIRECTORY)
    {
        return FALSE;
    }

    // Get the filename sans trailing spaces

    WIN32_FIND_DATA FindFileData;
    HANDLE hFile = FindFirstFile(ptszFileName, &FindFileData);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        return FALSE;
    }
    FindClose(hFile);

    LPTSTR ptszLastSlash = _tcsrchr((LPTSTR)ptszFileName, TEXT('\\'));
    if (ptszLastSlash)
    {
        lstrcpy(ptszLastSlash + 1, FindFileData.cFileName);
    }

    return TRUE;
}


//+--------------------------------------------------------------------------
//
//  Function:   FileExistsInPath
//
//  Synopsis:   Return TRUE if [ptszFilename] exists in path [ptszPath].
//
//  Arguments:  [ptszFilename]  - file to look for
//              [ptszPath]      - semicolon delimited list of dirs
//              [ptszFoundFile] - if found, [ptszDir]\[ptszFilename]
//              [cchFoundBuf]   - size in chars of [ptszFoundFile] buffer
//
//  Returns:    TRUE if file found in dir, FALSE otherwise
//
//  Modifies:   *[ptszFoundFile]
//
//  History:    11-22-1996   DavidMun   Created
//
//  Notes:      Note that by calling FileExists we ensure the found file
//              is a file, not a directory.
//
//---------------------------------------------------------------------------

BOOL
FileExistsInPath(
        LPTSTR  ptszFilename, 
        LPCTSTR ptszPath, 
        LPTSTR  ptszFoundFile, 
        ULONG   cchFoundBuf)
{
    ULONG  cchCopied;
    LPTSTR ptszFilePart;

    cchCopied = SearchPath(ptszPath,
                           ptszFilename,
                           NULL,
                           cchFoundBuf,
                           ptszFoundFile,
                           &ptszFilePart);

    if (cchCopied && cchCopied <= cchFoundBuf)
    {
        return FileExists(ptszFoundFile);
    }
    return FALSE;
}


#define MAX_KEY_LEN     (ARRAY_LEN(REGSTR_PATH_APPPATHS) + MAX_PATH)

//+--------------------------------------------------------------------------
//
//  Function:   GetAppPathInfo
//
//  Synopsis:   Fill [ptszAppPathDefault] with the default value and
//              [ptszAppPathVar] with the Path value in the
//              [ptszFilename] application's key under the APPPATHS regkey.
//
//  Arguments:  [ptszFilename]       - application name
//              [ptszAppPathDefault] - if not NULL, filled with default value
//              [cchDefaultBuf]      - size of [ptszAppPathDefault] buffer
//              [ptszAppPathVar]     - if not NULL, filled with Path value
//              [cchPathVarBuf]      - size of [cchPathVarBuf] buffer
//
//  Modifies:   *[ptszAppPathDefault], *[ptszAppPathVar]
//
//  History:    11-22-1996   DavidMun   Created
//
//  Notes:      Both values are optional on the registry key, so if a 
//              requested value isn't found, it is set to "".
//
//---------------------------------------------------------------------------

VOID
GetAppPathInfo(
        LPCTSTR ptszFilename, 
        LPTSTR  ptszAppPathDefault, 
        ULONG   cchDefaultBuf,
        LPTSTR  ptszAppPathVar, 
        ULONG   cchPathVarBuf)
{
    HKEY    hkey = NULL;
    TCHAR   tszAppPathKey[MAX_KEY_LEN];

    //
    // Initialize out vars
    //

    if (ptszAppPathDefault)
    {
        ptszAppPathDefault[0] = TEXT('\0');
    }

    if (ptszAppPathVar)
    {
        ptszAppPathVar[0] = TEXT('\0');
    }

    //
    // Build registry key name for this app
    //

    lstrcpy(tszAppPathKey, REGSTR_PATH_APPPATHS);
    lstrcat(tszAppPathKey, TEXT("\\"));
    lstrcat(tszAppPathKey, ptszFilename);

    do
    {
        LRESULT lr;
        lr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                          tszAppPathKey,
                          0,
                          KEY_QUERY_VALUE,
                          &hkey);

        if (lr != ERROR_SUCCESS)
        {
            break;
        }

        //
        // If the key could be opened, attempt to read requested values. 
        // Both are optional, so ignore errors.
        //

        DWORD cb;
        DWORD dwType;


        if (ptszAppPathDefault)
        {
            cb = cchDefaultBuf * sizeof(TCHAR);
            lr = RegQueryValueEx(hkey, 
                                 NULL, // value name
                                 NULL, // reserved
                                 &dwType,
                                 (LPBYTE) ptszAppPathDefault, 
                                 &cb);
 
            if (lr == ERROR_SUCCESS)
            {
                schAssert(dwType == REG_SZ);
            }
        }

        if (ptszAppPathVar)
        {
            cb = cchPathVarBuf * sizeof(TCHAR);
 
            lr = RegQueryValueEx(hkey, 
                                 TEXT("Path"),  // value name
                                 NULL,          // reserved
                                 &dwType,
                                 (LPBYTE) ptszAppPathVar, 
                                 &cb);
 
            if (lr == ERROR_SUCCESS)
            {
                schAssert(dwType == REG_SZ);
            }
        }
    } while (0);

    if (hkey)
    {
        RegCloseKey(hkey);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\common\dynload.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       dynload.cxx
//
//  Contents:   Wrappers for functions exported by DLLs that are loaded only
//              when needed.
//
//  Classes:
//
//  Functions:  FreeDynLoadLibs
//
//  History:    07-Oct-96   AnirudhS  Created.
//
//--------------------------------------------------------------------------


#include "..\pch\headers.hxx"
#pragma hdrstop
#include <debug.hxx>
#include "dynload.hxx"

//
// These typedefs must match the function prototypes in objbase.h
//
typedef LPVOID (STDAPICALLTYPE *PF_CoTaskMemAlloc)   (ULONG cb);
typedef LPVOID (STDAPICALLTYPE *PF_CoTaskMemRealloc) (LPVOID pv, ULONG cb);
typedef void   (STDAPICALLTYPE *PF_CoTaskMemFree)    (LPVOID pv);

//
// Local functions
//
void
LoadOleFunction(
    FARPROC *   pfCurrentValue,
    LPCSTR      pszFunctionName
    );

//
// Static data
//
HMODULE hOle32Dll;


//+----------------------------------------------------------------------------
//
//  Function:   GetProcAddressInModule
//
//  Synopsis:   Gets the address of the specified function exported by the
//              specified module.
//
//  Arguments:  [pszFunction] - Name of the function desired.
//              [ptszModule] - Name of the module.  This must already be loaded.
//
//-----------------------------------------------------------------------------
FARPROC
GetProcAddressInModule(
    LPCSTR      pszFunction,
    LPCTSTR     ptszModule
    )
{
    HMODULE     hMod = GetModuleHandle(ptszModule);
    schAssert(hMod != NULL);
    return (GetProcAddress(hMod, pszFunction));
}


//+----------------------------------------------------------------------------
//
//  Function:   LoadOleFunction
//
//  Synopsis:   Loads OLE32.DLL if it hasn't been loaded, and gets the address
//              of the specified function exported by it.
//
//  Arguments:  [pfCurrentValue] - Address where the function pointer will be
//                  returned.  If this is not NULL on entry it is assumed to
//                  already point to the function.
//              [pszFunctionName] - Name of the function desired.
//
//-----------------------------------------------------------------------------
void
LoadOleFunction(
    FARPROC *   pfCurrentValue,
    LPCSTR      pszFunctionName
    )
{
    if (*pfCurrentValue != NULL)
    {
        schAssert(hOle32Dll != NULL);
        return;
    }

    if (hOle32Dll != NULL
        || (hOle32Dll = LoadLibrary(TEXT("OLE32.DLL"))) != NULL)
    {
        *pfCurrentValue = GetProcAddress(hOle32Dll, pszFunctionName);
    }
}


//+----------------------------------------------------------------------------
//
//  Function:   FreeDynLoadLibs
//
//  Synopsis:   Unloads DLLs that have been dynamically loaded.
//
//  Arguments:  None.
//
//  Notes:      WARNING: This will make all the function pointers invalid.
//              Therefore, this function should only be called if this
//              module is being unloaded.
//
//-----------------------------------------------------------------------------
void
FreeDynLoadLibs(void)
{
    if (hOle32Dll != NULL)
    {
        FreeLibrary(hOle32Dll);
#if DBG == 1
        hOle32Dll = NULL;
#endif
    }
}


//+----------------------------------------------------------------------------
//
//  Function wrappers
//
//-----------------------------------------------------------------------------

LPVOID
WrapCoTaskMemAlloc(
    ULONG cb
    )
{
    static PF_CoTaskMemAlloc pf_CoTaskMemAlloc;

    LoadOleFunction((FARPROC *) &pf_CoTaskMemAlloc, "CoTaskMemAlloc");

    if (pf_CoTaskMemAlloc != NULL)
    {
        return pf_CoTaskMemAlloc(cb);
    }
    else
    {
        return NULL;
    }
}


LPVOID
WrapCoTaskMemRealloc(
    LPVOID pv,
    ULONG cb
    )
{
    static PF_CoTaskMemRealloc pf_CoTaskMemRealloc;

    LoadOleFunction((FARPROC *) &pf_CoTaskMemRealloc, "CoTaskMemRealloc");

    if (pf_CoTaskMemRealloc != NULL)
    {
        return pf_CoTaskMemRealloc(pv, cb);
    }
    else
    {
        return NULL;
    }
}


void
WrapCoTaskMemFree(
    LPVOID pv
    )
{
    static PF_CoTaskMemFree pf_CoTaskMemFree;

    LoadOleFunction((FARPROC *) &pf_CoTaskMemFree, "CoTaskMemFree");

    if (pf_CoTaskMemFree != NULL)
    {
        pf_CoTaskMemFree(pv);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\common\security.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       security.cxx
//
//  Contents:
//
//  Classes:    None.
//
//  Functions:  None.
//
//  History:    26-Jun-96   MarkBl  Created
//
//----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include <common.hxx>   // MAX_SID_SIZE
#include "..\inc\debug.hxx"
#include "..\inc\security.hxx"


//+---------------------------------------------------------------------------
//
//  Function:   CreateSecurityDescriptor
//
//  Synopsis:   Create a security descriptor with the ACE information
//              specified.
//
//  Arguments:  [AceCount] -- ACE count (no. of rgMyAce and rgAce elements).
//              [rgMyAce]  -- ACE specification array.
//              [rgAce]    -- Caller allocated array of ptrs to ACEs so
//                            this function doesn't have to allocate it.
//
//  Returns:    TRUE  -- Function succeeded,
//              FALSE -- Otherwise.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
PSECURITY_DESCRIPTOR
CreateSecurityDescriptor(
    DWORD               AceCount,
    MYACE               rgMyAce[],
    PACCESS_ALLOWED_ACE rgAce[],
    DWORD *             pStatus)
{
    PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;
    PACL  pAcl                               = NULL;
    DWORD LengthAces                         = 0;
    DWORD LengthAcl;
    DWORD i;
    DWORD Status;

    for (i = 0; i < AceCount; i++)
    {
        rgAce[i] = CreateAccessAllowedAce(rgMyAce[i].pSid,
                                          rgMyAce[i].AccessMask,
                                          0,
                                          rgMyAce[i].InheritFlags,
                                          &Status);

        if (rgAce[i] == NULL)
        {
            goto ErrorExit;
        }

        LengthAces += rgAce[i]->Header.AceSize;
    }

    //
    // Calculate ACL and SD sizes
    //

    LengthAcl  = sizeof(ACL) + LengthAces;

    //
    // Create the ACL.
    //

    pAcl = (PACL)LocalAlloc(LMEM_FIXED, LengthAcl);

    if (pAcl == NULL)
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        schDebugOut((DEB_ERROR,
            "CreateSecurityDescriptor, ACL allocation failed\n"));
        goto ErrorExit;
    }

    if (!InitializeAcl(pAcl, LengthAcl, ACL_REVISION))
    {
        Status = GetLastError();
        schDebugOut((DEB_ERROR,
            "CreateSecurityDescriptor, InitializeAcl failed, " \
            "status = 0x%lx\n",
            Status));
        goto ErrorExit;
    }

    for (i = 0; i < AceCount; i++)
    {
        if (!AddAce(pAcl,
                    ACL_REVISION,
                    0,
                    rgAce[i],
                    rgAce[i]->Header.AceSize))
        {
            Status = GetLastError();
            schDebugOut((DEB_ERROR,
                "CreateSecurityDescriptor, AddAce[%l] failed, " \
                "status = 0x%lx\n", i, Status));
            goto ErrorExit;
        }

        LocalFree(rgAce[i]);
        rgAce[i] = NULL;
    }

    //
    // Create the security descriptor.
    //

    pSecurityDescriptor = LocalAlloc(LMEM_FIXED,
                                     SECURITY_DESCRIPTOR_MIN_LENGTH);

    if (pSecurityDescriptor == NULL)
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        schDebugOut((DEB_ERROR,
            "CreateSecurityDescriptor, SECURITY_DESCRIPTOR allocation " \
            "failed\n"));
        goto ErrorExit;
    }

    if (!InitializeSecurityDescriptor(pSecurityDescriptor,
                                      SECURITY_DESCRIPTOR_REVISION))
    {
        Status = GetLastError();
        schDebugOut((DEB_ERROR,
            "CreateSecurityDescriptor, InitializeSecurityDescriptor " \
            "failed, status = 0x%lx\n",
            Status));
        goto ErrorExit;
    }

    if (!SetSecurityDescriptorDacl(pSecurityDescriptor,
                                   TRUE,
                                   pAcl,
                                   FALSE))
    {
        Status = GetLastError();
        schDebugOut((DEB_ERROR,
            "CreateSecurityDescriptor, SetSecurityDescriptorDacl " \
            "failed, status = 0x%lx\n",
            Status));
        goto ErrorExit;
    }

    if (pStatus != NULL) *pStatus = ERROR_SUCCESS;

    return(pSecurityDescriptor);

ErrorExit:
    for (i = 0; i < AceCount; i++)
    {
        if (rgAce[i] != NULL)
        {
            LocalFree(rgAce[i]);
            rgAce[i] = NULL;
        }
    }
    if (pAcl != NULL) LocalFree(pAcl);
    if (pSecurityDescriptor != NULL) LocalFree(pSecurityDescriptor);

    if (pStatus != NULL) *pStatus = Status;

    return(NULL);
}

//+---------------------------------------------------------------------------
//
//  Function:   DeleteSecurityDescriptor
//
//  Synopsis:   Deallocate the security descriptor allocated in
//              CreateSecurityDescriptor.
//
//  Arguments:  [pSecurityDescriptor] -- SD returned from
//                                       CreateSecurityDescriptor.
//
//  Returns:    None.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
void
DeleteSecurityDescriptor(PSECURITY_DESCRIPTOR pSecurityDescriptor)
{
    BOOL fPresent;
    BOOL fDefaulted;
    PACL pAcl;

    schAssert(pSecurityDescriptor != NULL);

    if (GetSecurityDescriptorDacl(pSecurityDescriptor,
                                  &fPresent,
                                  &pAcl,
                                  &fDefaulted))
    {
        if (fPresent && pAcl != NULL)
        {
            LocalFree(pAcl);
        }
    }
    else
    {
        schDebugOut((DEB_ERROR,
            "DeleteSecurityDescriptor, GetSecurityDescriptorDacl failed, " \
            "status = 0x%lx\n",
            GetLastError()));
    }

    LocalFree(pSecurityDescriptor);
}

//+---------------------------------------------------------------------------
//
//  Function:   CreateAccessAllowedAce
//
//  Synopsis:   Scavenged code from winlogon to create an access allowed ACE.
//              Modified a bit to use Win32 vs. Rtl.
//
//  Arguments:  [pSid]         -- Sid to which this ACE is applied.
//              [AccessMask]   -- ACE access mask value.
//              [AceFlags]     -- ACE flags value.
//              [InheritFlags] -- ACE inherit flags value.
//
//  Returns:    Created ACE if successful.
//              NULL on error.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
PACCESS_ALLOWED_ACE
CreateAccessAllowedAce(
    PSID        pSid,
    ACCESS_MASK AccessMask,
    UCHAR       AceFlags,
    UCHAR       InheritFlags,
    DWORD *     pStatus)
{
    ULONG   LengthSid = GetLengthSid(pSid);
    ULONG   LengthACE = sizeof(ACE_HEADER) + sizeof(ACCESS_MASK) + LengthSid;
    PACCESS_ALLOWED_ACE Ace;

    Ace = (PACCESS_ALLOWED_ACE)LocalAlloc(LMEM_FIXED, LengthACE);

    if (Ace == NULL)
    {
        if (pStatus != NULL) *pStatus = ERROR_NOT_ENOUGH_MEMORY;
        schDebugOut((DEB_ERROR,
            "CreateAccessAllowedAce, ACE allocation failed\n"));
        return(NULL);
    }

    Ace->Header.AceType  = ACCESS_ALLOWED_ACE_TYPE;
    Ace->Header.AceSize  = (UCHAR)LengthACE;
    Ace->Header.AceFlags = AceFlags | InheritFlags;
    Ace->Mask            = AccessMask;
    CopySid(LengthSid, (PSID)(&(Ace->SidStart)), pSid);

    if (pStatus != NULL) *pStatus = ERROR_SUCCESS;

    return(Ace);
}


//+---------------------------------------------------------------------------
//
//  Function:   IsThreadCallerAnAdmin
//
//  Synopsis:   Determine if the user represented by the specified token is a
//              member of the administrators group.
//
//  Arguments:  [hThreadToken] -- Token to check.  If NULL, the current
//                  thread's token is used if there is one, or else the
//                  current process' token.
//
//  Returns:    TRUE  -- Match
//              FALSE -- Thread caller not an admin or an error occurred.
//
//----------------------------------------------------------------------------
BOOL
IsThreadCallerAnAdmin(HANDLE hThreadToken)
{
    //
    // Create an admin SID to compare against.
    //
#if 1
    //
    // Efficient way - relies on the format of the SID structure (which is
    // published in winnt.h) - valid for at least NT 4 and NT 5
    //

    schAssert(sizeof SID == 12);

    const struct
    {
        SID     Sid;
        DWORD   SubAuthority1;
    } AdminSid =
        {
          { SID_REVISION,                   // Revision
            2,                              // SubAuthorityCount
            SECURITY_NT_AUTHORITY,          // IdentifierAuthority
            SECURITY_BUILTIN_DOMAIN_RID },  // SubAuthority[0]
            DOMAIN_ALIAS_RID_ADMINS         // SubAuthority[1]
        };
#else
/*
#error  SID structure has changed!
    //
    // Inefficient way, initialize at run time
    //
    BYTE    AdminSid[MAX_SID_SIZE];
    SID_IDENTIFIER_AUTHORITY IdentifierAuthority = SECURITY_NT_AUTHORITY;

    if (! InitializeSid(rgbAdminSid, &IdentifierAuthority, 2))
    {
        schAssert(0);
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        return FALSE;
    }

    *GetSidSubAuthority(rgbAdminSid, 0) = SECURITY_BUILTIN_DOMAIN_RID;
    *GetSidSubAuthority(rgbAdminSid, 1) = DOMAIN_ALIAS_RID_ADMINS;
*/
#endif

    //
    // See if the token is a member.
    //
    BOOL    fIsCallerAdmin;
    if (!CheckTokenMembership(hThreadToken,
                              (PSID) &AdminSid,
                              &fIsCallerAdmin))
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        return FALSE;
    }

    return fIsCallerAdmin;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\common\time.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       time.cxx
//
//  Contents:
//
//  Classes:    None.
//
//  Functions:  None.
//
//  History:    09-Sep-95   EricB   Created.
//              01-Dec-95   MarkBl  Split from util.cxx.
//
//----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop

#include <mstask.h>
#include "..\inc\common.hxx"
#include "..\inc\debug.hxx"
#include "..\inc\time.hxx"

//+-------------------------------------------------------------------------
//
//  Function:   IsLeapYear
//
//  Synopsis:   Determines if a given year is a leap year.
//
//  Arguments:  [wYear]  - the year
//
//  Returns:    boolean value: TRUE == leap year
//
//  History:    05-05-93 EricB
//
// BUGBUG: kevinro sez that there were no regular leap years prior to 1904!
//--------------------------------------------------------------------------
BOOL
IsLeapYear(WORD wYear)
{
    return wYear % 4 == 0 && wYear % 100 != 0 || wYear % 400 == 0;
}

//+----------------------------------------------------------------------------
//
//  Function:   IsValidDate
//
//  Synopsis:   Checks for valid values.
//
//-----------------------------------------------------------------------------
BOOL
IsValidDate(WORD wMonth, WORD wDay, WORD wYear)
{
    if (wMonth < JOB_MIN_MONTH || wMonth > JOB_MAX_MONTH ||
                wDay < JOB_MIN_DAY)
    {
        return FALSE;
    }
    if (wMonth == JOB_MONTH_FEBRUARY && IsLeapYear(wYear))
    {
        if (wDay > (g_rgMonthDays[JOB_MONTH_FEBRUARY] + 1))
        {
            return FALSE;
        }
    }
    else
    {
        if (wDay > g_rgMonthDays[wMonth])
        {
            return FALSE;
        }
    }
    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Function:   MonthDays
//
//  Synopsis:   Returns the number of days in the indicated month.
//
//  Arguments:  [wMonth] - Index of the month in question where January = 1
//                         through December equalling 12.
//              [yYear]  - If non-zero, then leap year adjustment for February
//                         will be applied.
//              [pwDays] - The place to return the number of days in the
//                         indicated month.
//
//  Returns:    S_OK or E_INVALIDARG
//
//  History:    10-29-93 EricB
//
//-----------------------------------------------------------------------------
HRESULT
MonthDays(WORD wMonth, WORD wYear, WORD *pwDays)
{
    if (wMonth < JOB_MIN_MONTH || wMonth > JOB_MAX_MONTH)
    {
        return E_INVALIDARG;
    }
    *pwDays = g_rgMonthDays[wMonth];
    //
    // If February, adjust for leap years
    //
    if (wMonth == 2 && wYear != 0)
    {
        if (IsLeapYear(wYear))
        {
            (*pwDays)++;
        }
    }
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   IncrementDay
//
//  Synopsis:   increases the SYSTEMTIME day value by one and corrects for
//              overflow
//
//  Arguments:  [pst] - the date to increment
//
//-----------------------------------------------------------------------------
void
IncrementDay(LPSYSTEMTIME pst)
{
    pst->wDay++;

    WORD wLastDay;
    HRESULT hr = MonthDays(pst->wMonth, pst->wYear, &wLastDay);
    if (FAILED(hr))
    {
        schAssert(!"Bad systemtime");
    }
    else
    {
        if (pst->wDay > wLastDay)
        {
            //
            // Wrap to the next month.
            //
            pst->wDay = 1;
            IncrementMonth(pst);
        }
    }
}

#ifdef YANK
//+----------------------------------------------------------------------------
//
//  Member:     CTimeList::MakeSysTimeArray
//
//  Synopsis:   returns the file time list as an array of SYSTEMTIME structs
//
//  Arguments:  [prgst]  - a pointer to an array of filetime structs
//              [pCount] - a place to leave the count of array elements. If
//                         this param is non-zero on entry, this places an
//                         upper limit on the number returned.
//
//-----------------------------------------------------------------------------
HRESULT
CTimeList::MakeSysTimeArray(LPSYSTEMTIME * prgst, WORD * pCount)
{
    WORD cLimit = USHRT_MAX;
    if (*pCount > 0)
    {
        cLimit = *pCount;
    }
    LPSYSTEMTIME rgst;
    *prgst = NULL;
    *pCount = 0;
    CTimeNode * pCur = m_ptnHead;

    while (pCur)
    {
        rgst = (LPSYSTEMTIME)CoTaskMemRealloc(*prgst,
                                        (*pCount + 1) * sizeof(SYSTEMTIME));
        if (rgst == NULL)
        {
            *pCount = 0;
            if (*prgst)
            {
                CoTaskMemFree(*prgst);
                *prgst = NULL;
            }
            return E_OUTOFMEMORY;
        }

        FileTimeToSystemTime(&pCur->m_ft, rgst + *pCount);

        *prgst = rgst;

        if (*pCount >= cLimit)
        {
            return S_OK;
        }

        (*pCount)++;

        pCur = pCur->Next();
    }
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//      Gregorian calendar functions
//
//-----------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//
//  Function:   MakeDate
//
//  Synopsis:   Turns the given Julian Day number into a Gregorian calendar
//              date.
//
//  Arguments:  [lDayNum] - the long Julian Day value.
//              [pwMonth] [pwDay] [pwYear] pointers to calendar part vars which
//              can be NULL if the part is not needed.
//
//  History:    05-05-93 EricB
//
//  Notes:      Adapted from the FORTRAN code that implements the algorithm
//              presented by Fliegl and Van Flanders in Communications of
//              the ACM, Vol. 11, No. 10, October, 1968, pg. 657.
//
//--------------------------------------------------------------------------
void
MakeDate(long lDayNum, WORD *pwMonth, WORD *pwDay, WORD *pwYear)
{
    long t1 = lDayNum + 68569L;
    long t2 = 4L * t1 / 146097L;
    t1 = t1 - (146097L * t2 + 3L) / 4L;
    long yr = 4000L * (t1 + 1) / 1461001L;
    t1 = t1 - 1461L * yr / 4L + 31;
    long mo = 80L * t1 / 2447L;
    if (pwDay != NULL)
    {
        *pwDay = (WORD)(t1 - 2447L * mo / 80L);
    }
    t1 = mo / 11L;
    if (pwMonth != NULL)
    {
        *pwMonth = (WORD)(mo + 2L - 12L * t1);
    }
    if (pwYear != NULL)
    {
        *pwYear = (WORD)(100L * (t2 - 49L) + yr + t1);
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   MakeJulianDayNumber
//
//  Synopsis:   Turns a m/d/y value (from the Gregorian calendar) into its
//              Julian Day number.
//
//  Arguments:  [wMonth]   - the month value
//              [wDay]     - the day value
//              [wYear]    - the year value
//              [plDayNum] - a pointer to a long to receive the result.
//
//  Returns:    S_OK or E_INVALIDARG
//
//  History:    05-04-93 EricB
//
//  Notes:      Same attribution as MakeDate above.
//
//--------------------------------------------------------------------------
HRESULT
MakeJulianDayNumber(WORD wMonth, WORD wDay, WORD wYear, long *plDayNum)
{
    BOOL fLeap = IsLeapYear(wYear);
    if ((wMonth < GREG_MINMONTH) ||
        (wMonth > GREG_MAXMONTH) ||
        (wDay < 1)               ||
        ((wDay > g_rgMonthDays[wMonth]) &&
         !((wMonth == 2) && (wDay == 29) && fLeap)))
    {
        schDebugOut((DEB_ERROR, "MakeJulDay: invalid date %u/%u/%u.\n",
                     wMonth, wDay, wYear));
        return E_INVALIDARG;
    }
    long lMonth = (long)wMonth,     // assign to longs instead of
         lDay   = (long)wDay,       // copious casting
         lYear  = (long)wYear;

    *plDayNum = lDay - 32075L +
                1461L * (lYear + 4800L + (lMonth - 14L) / 12L) / 4L +
                367L * (lMonth - 2L - (lMonth - 14L) / 12L * 12L) / 12L -
                3L * ((lYear + 4900L + (lMonth - 14L) / 12L) / 100L) / 4L;

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   DayOfWeek
//
//  Synopsis:   Given a Julian Day number, returns the day of the week.
//
//  Arguments:  [lDayNum] - the julian day number
//
//  Returns:    the day of the week with values Monday = 0 ... Sunday = 6
//
//  History:    05-05-93 EricB
//
//--------------------------------------------------------------------------
WORD
DayOfWeek(long lDayNum)
{
    return (WORD)(lDayNum % 7L);
}
#endif // YANK
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\folderui\avl.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:       avl.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    6/25/1995   RaviR   Created
//
//----------------------------------------------------------------------------


#include "headers.hxx"
#pragma hdrstop

//#include "memory.hxx"
#include "dbg.h"
#include "macros.h"
#include "avl.hxx"


//+---------------------------------------------------------------------------
//
//  Member:     CAVLTree::Insert
//
//  Synopsis:   Insert the given atom in the tree.
//
//  Arguments:  [pa] -- IN The atom to insert.
//
//  Returns:    HRESULT.
//
//  History:    8/29/1995   RaviR   Created
//
//----------------------------------------------------------------------------

HRESULT
CAVLTree::Insert(
    PAVLNODEATOM pa)
{
    _hrInsert = S_OK;

    _Insert(&_pFirstNode, pa);

    if (_pFirstNode != NULL)
    {
        _pFirstNode->SetParent(NULL);
    }

    return _hrInsert;
}

//+---------------------------------------------------------------------------
//
//  Member:     CAVLTree::_Insert
//
//  Synopsis:   A recursive function to insert the given atom.
//
//  Arguments:  [ppNode] -- The root of the current tree.
//              [pa] -- The atom to insert.
//
//  Returns:    TRUE if height changed, FALSE otherwise.
//
//  History:    8/29/1995   RaviR   Created
//
//----------------------------------------------------------------------------

BOOL
CAVLTree::_Insert(
    CTreeNode ** ppNode,
    PAVLNODEATOM pa)
{
    CTreeNode  *t = *ppNode;
    CTreeNode  *t1 = NULL;
    CTreeNode  *t2 = NULL;

    if (t == NULL)
    {
        CTreeNode * ptn = new CTreeNode(pa);

        if (ptn == NULL)
        {
            _hrInsert = E_OUTOFMEMORY;
            CHECK_HRESULT(_hrInsert);
            return FALSE;
        }

        *ppNode = ptn;

        return TRUE;
    }

    BOOL fHeightChanged = FALSE;

    int iComp = pa->Compare(t->Atom());

    if (iComp < 0)
    {
        fHeightChanged = _Insert(&(t->_l), pa);

        t->_l->SetParent(t);

        if (fHeightChanged == TRUE)
        {
            switch (t->Balance())
            {
            case 1:
                t->SetBalance(0);
                fHeightChanged = FALSE;
                break;

            case 0:
                t->SetBalance(-1);
                // fHeightChanged = TRUE; // already TRUE
                break;

            case -1:
                // Reblance

                t1 = t->Left();

                if (t1->Balance() == -1)
                {
                    t->SetLeft(t1->Right());

                    t->SetBalance(0);

                    t1->SetRight(t);

                    t1->SetBalance(0);

                    t = t1;

                    fHeightChanged = FALSE;
                }
                else
                {
                    Win4Assert(t1->Balance() == 1);

                    t2 = t1->Right();

                    t->SetLeft(t2->Right());

                    t1->SetRight(t2->Left());

                    t2->SetLeft(t1);

                    t2->SetRight(t);

                    if (t2->Balance() == -1)
                    {
                        t->SetBalance(1);

                        t1->SetBalance(0);
                    }
                    else if (t2->Balance() == 1)
                    {
                        t->SetBalance(0);

                        t1->SetBalance(-1);
                    }
                    else
                    {
                        Win4Assert(t2->Balance() == 0);

                        Win4Assert(t->Left() == NULL);
                        Win4Assert(t->Right() == NULL);

                        Win4Assert(t1->Right() == NULL);
                        Win4Assert(t1->Left() == NULL);

                        t->SetBalance(0);

                        t1->SetBalance(0);
                    }

                    t = t2;

                    t->SetBalance(0);

                    fHeightChanged = FALSE;
                }
                break;

            default:
                Win4Assert(0 && "Unknown balance!");
                break;
            }
        }
    }
    else if (iComp > 0)
    {
        fHeightChanged = _Insert(&(t->_r), pa);

        t->_r->SetParent(t);

        if (fHeightChanged == TRUE)
        {
            switch (t->Balance())
            {
            case -1:
                t->SetBalance(0);
                fHeightChanged = FALSE;
                break;

            case 0:
                t->SetBalance(1);
                // fHeightChanged = TRUE; // already TRUE
                break;

            case 1:
                // Rebalance

                t1 = t->Right();

                if (t1->Balance() == 1)
                {
                    t->SetRight(t1->Left());

                    t->SetBalance(0);

                    t1->SetLeft(t);

                    t1->SetBalance(0);

                    t = t1;

                    fHeightChanged = FALSE;
                }
                else
                {
                    Win4Assert(t1->Balance() == -1);

                    t2 = t1->Left();

                    t->SetRight(t2->Left());

                    t1->SetLeft(t2->Right());

                    t2->SetLeft(t);

                    t2->SetRight(t1);

                    if (t2->Balance() == -1)
                    {
                        t->SetBalance(0);

                        t1->SetBalance(1);
                    }
                    else if (t2->Balance() == 1)
                    {
                        t->SetBalance(-1);

                        t1->SetBalance(0);
                    }
                    else
                    {
                        Win4Assert(t2->Balance() == 0);

                        Win4Assert(t->Left() == NULL);
                        Win4Assert(t->Right() == NULL);

                        Win4Assert(t1->Right() == NULL);
                        Win4Assert(t1->Left() == NULL);

                        t->SetBalance(0);

                        t1->SetBalance(0);
                    }

                    t2->SetBalance(0);

                    t = t2;

                    fHeightChanged = FALSE;
                }
                break;

            default:
                Win4Assert(0 && "Unknown balance!");
                break;
            }
        }
    }
    else
    {
        _hrInsert = S_FALSE;
    }

    *ppNode = t;

    return fHeightChanged;
}



void
CAVLTree::Delete(
    PAVLNODEATOM pa)
{
    _Delete(&_pFirstNode, pa);

    if (_pFirstNode != NULL)
    {
        _pFirstNode->SetParent(NULL);
    }
}

BOOL
CAVLTree::_Delete(
    CTreeNode ** ppNode,
    PAVLNODEATOM pa)
{
    CTreeNode  *t = *ppNode;

    if (t == NULL)
    {
        return FALSE;
    }

    CTreeNode  *lt = t->Left();
    CTreeNode  *rt = t->Right();
    CTreeNode  *ct;
    CTreeNode  *tToDel;

    PAVLNODEATOM paTemp = NULL;

    BOOL fHeightChanged = FALSE; // value to return
    BOOL fTemp;

    int iComp = pa->Compare(t->Atom());

    if (iComp == 0)
    {
        if (lt == NULL)
        {
            tToDel = t;

            t = rt;

            tToDel->SetLeft(NULL);
            tToDel->SetRight(NULL);
            delete tToDel;

            fHeightChanged = TRUE;
        }
        else if (rt == NULL)
        {
            tToDel = t;

            t = lt;

            tToDel->SetLeft(NULL);
            tToDel->SetRight(NULL);
            delete tToDel;

            fHeightChanged = TRUE;
        }
        else
        {
            switch (t->Balance())
            {
            case -1:
                paTemp = lt->GetMax();

                fTemp = _Delete(&t->_l, paTemp);

                if (t->_l)
                {
                    t->_l->SetParent(t);
                }

                if (fTemp == TRUE)
                {
                    t->SetBalance(0);
                    fHeightChanged = TRUE;
                }
                break;

            case 0:
                paTemp = lt->GetMax();

                fTemp = _Delete(&t->_l, paTemp);

                if (t->_l)
                {
                    t->_l->SetParent(t);
                }

                if (fTemp == TRUE)
                {
                    t->SetBalance(1);
                }
                break;

            case 1:
                paTemp = rt->GetMin();

                fTemp = _Delete(&t->_r, paTemp);

                if (t->_r)
                {
                    t->_r->SetParent(t);
                }

                if (fTemp == TRUE)
                {
                    t->SetBalance(0);
                    fHeightChanged = TRUE;
                }
                break;
            }

            t->SetAtom(paTemp);
        }
    }
    else if (iComp > 0)
    {
        fTemp = _Delete(&t->_r, pa);

        if (t->_r)
        {
            t->_r->SetParent(t);
        }

        if (fTemp == TRUE)
        {
            switch (t->Balance())
            {
            case 1:
                t->SetBalance(0);
                fHeightChanged = TRUE;
                break;

            case 0:
                t->SetBalance(-1);
                break;

            case -1:
                switch (lt->Balance())
                {
                case -1:
                    t->SetLeft(lt->Right());
                    t->SetParent(lt);
                    lt->SetRight(t);

                    t->SetBalance(0);
                    lt->SetBalance(0);

                    t = lt;

                    fHeightChanged = TRUE;

                    break;

                case 0:
                    t->SetLeft(lt->Right());
                    t->SetParent(lt);
                    lt->SetRight(t);

                    t->SetBalance(-1);
                    lt->SetBalance(1);

                    t = lt;

                    break;

                case 1:
                    ct = lt->Right();

                    Win4Assert(ct != NULL); // becos (lt->Balance() == 1)

                    t->SetLeft(ct->Right());
                    t->SetParent(ct);

                    lt->SetRight(ct->Left());
                    lt->SetParent(ct);

                    ct->SetLeft(lt);
                    ct->SetRight(t);

                    switch (ct->Balance())
                    {
                    case -1:
                        lt->SetBalance(0);
                        t->SetBalance(1);
                        break;

                    case 0:
                        lt->SetBalance(0);
                        t->SetBalance(0);
                        break;

                    case 1:
                        lt->SetBalance(-1);
                        t->SetBalance(0);
                        break;
                    }

                    ct->SetBalance(0);

                    t = ct;

                    fHeightChanged = TRUE;

                    break;
                }

                break;
            }
        }
    }
    else // if (iComp < 0)
    {
        fTemp = _Delete(&t->_l, pa);

        if (t->_l)
        {
            t->_l->SetParent(t);
        }

        if (fTemp == TRUE)
        {
            switch (t->Balance())
            {
            case -1:
                t->SetBalance(0);
                fHeightChanged = TRUE;
                break;

            case 0:
                t->SetBalance(1);
                break;

            case 1:
                switch (rt->Balance())
                {
                case 1:
                    t->SetRight(rt->Left());
                    t->SetParent(rt);
                    rt->SetLeft(t);

                    t->SetBalance(0);
                    rt->SetBalance(0);

                    t = rt;

                    fHeightChanged = TRUE;

                    break;

                case 0:
                    t->SetRight(rt->Left());
                    t->SetParent(rt);
                    rt->SetLeft(t);

                    t->SetBalance(1);
                    rt->SetBalance(-1);

                    t = rt;

                    break;

                case -1:
                    ct = rt->Left();

                    Win4Assert(ct != NULL); // becos (rt->Balance() == -1)

                    t->SetRight(ct->Left());
                    t->SetParent(ct);
                    rt->SetLeft(ct->Right());
                    rt->SetParent(ct);

                    ct->SetLeft(t);
                    ct->SetRight(rt);

                    switch (ct->Balance())
                    {
                    case -1:
                        t->SetBalance(0);
                        rt->SetBalance(1);
                        break;

                    case 0:
                        t->SetBalance(0);
                        rt->SetBalance(0);
                        break;

                    case 1:
                        t->SetBalance(-1);
                        rt->SetBalance(0);
                        break;
                    }

                    ct->SetBalance(0);

                    t = ct;

                    fHeightChanged = TRUE;

                    break;
                }
                break;
            }
        }
    }

    *ppNode = t;

    return fHeightChanged;
}

//+---------------------------------------------------------------------------
//
//  Member:     CAVLTree::GetAtom
//
//  Arguments:  [pa] -- Atom
//
//  Returns:    The TreeNode containig the atom.
//
//  History:    8/29/1995   RaviR   Created
//
//----------------------------------------------------------------------------

PAVLNODEATOM
CAVLTree::GetAtom(
    PAVLNODEATOM pa)
{
    CTreeNode *t = _pFirstNode;

    while (t != NULL)
    {
        int iComp = pa->Compare(t->Atom());

        if (iComp == 0)
        {
            return t->Atom();
        }
        else if (iComp < 0)
        {
            t = t->Left();
            continue;
        }
        else
        {
            t = t->Right();
            continue;
        }
    }

    return NULL;
}




//+---------------------------------------------------------------------------
//
//  Member:     CAVLTree::GetFirst
//
//  Synopsis:   Returns the first atom in the tree.
//
//  History:    8/29/1995   RaviR   Created
//
//----------------------------------------------------------------------------

PAVLNODEATOM
CAVLTree::GetFirst(void)
{
    if (_pFirstNode == NULL)
    {
        return NULL;
    }

    _pFirstNode->ResetTraversedFlag();

    CTreeNode *t = _pFirstNode;

    while (t->Left() != NULL)
    {
        t = t->Left();
    }

    _pCurrentNode = t;

    t->SetTraversed();

    return t->Atom();
}

//+---------------------------------------------------------------------------
//
//  Member:     CAVLTree::GetNext
//
//  Synopsis:   Traverses the tree inorder.
//
//  History:    8/29/1995   RaviR   Created
//
//----------------------------------------------------------------------------

PAVLNODEATOM
CAVLTree::GetNext(void)
{
    CTreeNode *t = _pCurrentNode;

    do
    {
        if (t->Right() != NULL)
        {
            t = t->Right();

            while (t->Left() != NULL)
            {
                t = t->Left();
            }
        }
        else
        {
            t = t->Parent();

            while (t != NULL && t->IsTraversed())
            {
                t = t->Parent();
            }
        }

    } while (0);

    _pCurrentNode = t;

    if (t != NULL)
    {
        t->SetTraversed();

        return t->Atom();
    }

    return NULL;
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

#if (DBG == 1)

void
CTreeNode::Dump(void)
{
    if (_l)
    {
        _l->Dump();
    }

    //printf("<val, bal> = <");

    _pa->Dump();

    //printf(", %d>\n", (UINT)_b);

    if (_r)
    {
        _r->Dump();
    }
}

void
CAVLTree::Dump(void)
{
    DEBUG_OUT((DEB_USER1, "Start Dump:\n"));

    if (_pFirstNode != NULL)
    {
        _pFirstNode->Dump();
    }

    DEBUG_OUT((DEB_USER1, "End Dump.\n"));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\folderui\guids.cxx ===
#include "..\pch\headers.hxx"
#pragma hdrstop

#include <initguid.h>

#include "guids.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\folderui\dbg.h ===
#ifndef __DBG_HXX__
#define __DBG_HXX__


#define DEBUG_OUT(x)
#define DECLARE_HEAPCHECKING
#define DEBUGCHECK
#define TRACE(ClassName,MethodName)
#define TRACE_FUNCTION(FunctionName)
#define CHECK_HRESULT(hr)
#define CHECK_LASTERROR(lr)
#define VERIFY(x)   x
#define DEBUG_OUT_LASTERROR
#define DEBUG_ASSERT(e)
#define PosDisplay(sz)
#define DbxDisplay(sz)
#define DbxResult(e)

#if DBG==1

#define DEB_TRACE1  DEB_USER1

// debug style : 1 - use dbg out,  2 - use message boxes

#define DBG_STYLE 1

#if defined(_CHICAGO_) && defined(DBX)
  #undef  DBG_STYLE
  #define DBG_STYLE 1
#endif

////////////////////////////////////////////////////////////////////////////
//
//  Style 1: Debug out to stdout
//

#if DBG_STYLE==1

    DECLARE_DEBUG(Job)

    #undef  DEBUG_OUT
    #define DEBUG_OUT(x) JobInlineDebugOut x

    extern DWORD dwHeapChecking;
    #undef  DECLARE_HEAPCHECKING
    #define DECLARE_HEAPCHECKING    DWORD dwHeapChecking = 0

    #undef  DEBUGCHECK
    #define DEBUGCHECK \
        if ( (dwHeapChecking & 0x1) == 0x1 ) \
            HeapValidate(GetProcessHeap(),0,NULL)

    #undef  TRACE
    #define TRACE(ClassName,MethodName) \
        DEBUGCHECK; \
        DEBUG_OUT((DEB_TRACE, #ClassName"::"#MethodName"(%x)\n", this));

    #undef  TRACE_FUNCTION
    #define TRACE_FUNCTION(FunctionName) \
        DEBUGCHECK; \
        DEBUG_OUT((DEB_TRACE, #FunctionName"\n"));

    #undef  CHECK_HRESULT
    #define CHECK_HRESULT(hr) \
        if ( FAILED(hr) ) \
        { \
            DEBUG_OUT((DEB_ERROR, \
                "**** ERROR RETURN <%s @line %d> -> %08lx\n", \
                __FILE__, \
                __LINE__, \
                hr)); \
        }

    #undef  CHECK_LASTERROR
    #define CHECK_LASTERROR(lr) \
        if ( lr != ERROR_SUCCESS ) \
        { \
            DEBUG_OUT((DEB_ERROR, \
                "**** ERROR RETURN <%s @line %d> -> %dL\n", \
                __FILE__, \
                __LINE__, \
                lr)); \
        }

    #undef  VERIFY
    #define VERIFY(x)   Win4Assert(x)

    #undef  DEBUG_OUT_LASTERROR
    #define DEBUG_OUT_LASTERROR \
        DEBUG_OUT((DEB_ERROR, \
            "**** ERROR RETURN <%s @line %d> -> %dL\n", \
            __FILE__, \
            __LINE__, \
            GetLastError()));

    #undef  DEBUG_ASSERT
    #define DEBUG_ASSERT(e) \
        if ((e) == FALSE) \
        { \
            DEBUG_OUT((DEB_ERROR, \
                "**** ASSERTION <%s> FAILED <%s @line %d>\n", \
                #e, \
                __FILE__, \
                __LINE__)); \
        }

#endif  // DBG_STYLE==1

////////////////////////////////////////////////////////////////////////////
//
//  Style 2: Debug out to message box
//

#if DBG_STYLE==2

extern TCHAR emsg[300];

    #define PRINT_LR(lr) \
        wsprintf(emsg, "<%s @ %d> %dL\n", __FILE__, __LINE__, (lr))

    #define PRINT_HR(hr) \
        wsprintf(emsg, "<%s @ %d> 0x%x\n", __FILE__, __LINE__, (hr))

    #define DISP_ERRMSG MessageBox(NULL, emsg, TEXT("**** ERROR ****"), MB_OK)

    #define DISP_MSG    MessageBox(NULL, emsg, TEXT("**** TRACE ****"), MB_OK)

    #undef  CHECK_LASTERROR
    #define CHECK_LASTERROR(lr) \
        if (lr != ERROR_SUCCESS) { PRINT_LR(lr); DISP_ERRMSG; }

    #undef  DEBUG_OUT_LASTERROR
    #define DEBUG_OUT_LASTERROR { PRINT_LR(GetLastError()); DISP_ERRMSG; }

    #undef  CHECK_HRESULT
    #define CHECK_HRESULT(hr) \
        if ( FAILED(hr) ) { PRINT_HR(hr); DISP_ERRMSG; }

    #undef  PosDisplay
    #define PosDisplay(e) \
        wsprintf(emsg, "<%s @ %d>\n\n\t %s", __FILE__, __LINE__, #e); DISP_MSG

#endif  // DBG_STYLE==2


////////////////////////////////////////////////////////////////////////////
//
//  Simple DBX messages
//

#ifdef DBX

  #undef  DbxDisplay
  #define DbxDisplay(sz) MessageBoxA(NULL, sz, "DBX", MB_OK);

  #undef  DbxResult
  #define DbxResult(e)                                      \
        {                                                   \
            char Buff[100];                                 \
            if (FAILED(hr))                                 \
            {                                               \
                sprintf(Buff, "%s failed (%x)", #e, hr);    \
            }                                               \
            else                                            \
            {                                               \
                sprintf(Buff, "%s succeeded", #e);          \
            }                                               \
            MessageBoxA(NULL, Buff, "DBX", MB_OK);          \
        }
#endif // DBX


#endif // DBG==1

#endif // __DBG_HXX__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\folderui\jfnotify.cxx ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:   Routines to watch the Jobs directory and handle change
//          notifications.
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    2/15/1996   RaviR   Created
//
//____________________________________________________________________________

#include "..\pch\headers.hxx"
#pragma hdrstop

#include "dbg.h"
#include "macros.h"
#include "jobfldr.hxx"

//#undef DEB_TRACE
//#define DEB_TRACE DEB_USER1


class CNotifyWatch;


class CNotifyWatch
{
public:
    CNotifyWatch(CJobFolder * pjf)
        : m_hWatch(INVALID_HANDLE_VALUE), m_pJobFolder(pjf) {}

    ~CNotifyWatch()
    {
        if (m_hWatch != INVALID_HANDLE_VALUE)
        {
            FindCloseChangeNotification(m_hWatch);
            m_hWatch = INVALID_HANDLE_VALUE;
        }
    }

    HANDLE       m_hWatch;  // Returned from FindFirstChangeNotify.
    CJobFolder * m_pJobFolder;

private:
    CNotifyWatch(void);
};



//------------------------------------------------------------------------
// FUNCTION:   NotifyWatchProc
//
//------------------------------------------------------------------------
//____________________________________________________________________________
//
//  Function:   NotifyWatchProc
//
//  Synopsis:   Watch the jobs directory and notify CJobFolder when something
//              has changed.
//
//  Arguments:  [pNotify] -- IN
//
//  Returns:    DWORD
//
//  History:    2/20/1996   RaviR   Created
//
//____________________________________________________________________________

DWORD
NotifyWatchProc(
    CNotifyWatch * pNotify)
{
    TRACE_FUNCTION(NotifyWatchProc);

    DWORD dwRet;
    BOOL  bFileChange = FALSE;
    UINT  cChanges = 0;

    if (pNotify == NULL)
    {
        return((DWORD) -1);
    }

    Sleep(7000);

    while (1)
    {
        //
        //  Wait for the Jobs folder to change.
        //

        dwRet = WaitForSingleObject(pNotify->m_hWatch, 3000);

        switch( dwRet )
        {
        case WAIT_OBJECT_0:
            //
            //  We could handle the change at this point, but we might
            //  as well wait for a time out and do it all at once.
            //  Doing nothing just causes us to wait
            //  another 1.5 secs; i.e. reset the timeout.
            //

            bFileChange = TRUE;

            ++cChanges;

            if (FindNextChangeNotification(pNotify->m_hWatch) == FALSE)
            {
                CHECK_LASTERROR(GetLastError());
            }

            break;

        case WAIT_TIMEOUT:
            if (bFileChange == TRUE)
            {
                DEBUG_OUT((DEB_USER1, "Count of changes = %d\n", cChanges));

                pNotify->m_pJobFolder->CheckForChanges();

                bFileChange = FALSE;

                cChanges = 0;
            }

            break;

        default:
            break;
        }

    }

    return 0;
}


//____________________________________________________________________________
//
//  Member:     CJobFolder::CheckForChanges
//
//  Synopsis:   S
//
//  Returns:    void
//
//  History:    2/20/1996   RaviR   Created
//
//____________________________________________________________________________

void
CJobFolder::CheckForChanges(void)
{
    DEBUG_OUT((DEB_USER1, "CJobFolder::CheckForChanges <<--\n"));

    LRESULT lr = ERROR_SUCCESS;
    static TCHAR s_szSearchPath[MAX_PATH] = TEXT("");

    if (s_szSearchPath[0] == TEXT('\0'))
    {
        lstrcpy(s_szSearchPath, m_pszFolderPath);
        lstrcat(s_szSearchPath, TEXT("\\*") TSZ_DOTJOB);
    }

    WIN32_FIND_DATA fd;
    HANDLE          hFind = FindFirstFile(s_szSearchPath, &fd);

    if (hFind == INVALID_HANDLE_VALUE)
    {
        if (GetLastError() != ERROR_FILE_NOT_FOUND)
        {
            CHECK_LASTERROR(GetLastError());
        }
        else if (GetLastError() != ERROR_NO_MORE_FILES)
        {
            if (m_pShellView != NULL)
            {
                m_pShellView->Refresh();
            }
        }
    }
    else
    {
        UINT    cJobs = 0;
        BOOL    fRefresh = FALSE;

        while (1)
        {
            ++cJobs;

            if (CompareFileTime(&fd.ftLastWriteTime, &m_ftLastChecked) > 0)
            {
                if (CompareFileTime(&fd.ftCreationTime, &m_ftLastChecked) > 0)
                {
                    // this is a new job
                    DEBUG_OUT((DEB_USER1, "-----------------------------\n"));
                    DEBUG_OUT((DEB_USER1, "New File <%ws>\n", fd.cFileName));
                    DEBUG_OUT((DEB_USER1, "-----------------------------\n"));
                }
                //
                // Job file changed since last check.
                //

                else if (_UpdateJob(fd.cFileName) == FALSE)
                {
                    fRefresh = TRUE;
                    break;
                }
            }

            //
            //  Get the next file.
            //

            if (FindNextFile(hFind, &fd) == FALSE)
            {
                if (GetLastError() != ERROR_NO_MORE_FILES)
                {
                    CHECK_LASTERROR(GetLastError());
                }

                break;
            }
        }

        FindClose(hFind);

        //
        //  Refresh if either (fRefresh == TRUE) or
        //              the count of objects has changed.
        //

        if (fRefresh == FALSE)
        {
            ULONG ulObjCount = ShellFolderView_GetObjectCount(m_hwndOwner);

            if (ulObjCount != cJobs)
            {
                fRefresh = TRUE;
            }
        }

        if (fRefresh == TRUE)
        {
            if (m_pShellView != NULL)
            {
                //m_pShellView->Refresh();
            }
        }

        //
        // Save the current time now that the UI is up to date.
        //

        SYSTEMTIME st;
        GetSystemTime(&st);
        SystemTimeToFileTime(&st, &m_ftLastChecked);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\folderui\dataobj.cxx ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       dataobj.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    1/17/1996   RaviR   Created
//
//____________________________________________________________________________


#include "..\pch\headers.hxx"
#pragma hdrstop

#include "dbg.h"
#include "macros.h"
#include "jobidl.hxx"


extern "C" UINT g_cfJobIDList;
extern "C" UINT g_cfShellIDList;
extern "C" UINT g_cfPreferredDropEffect;

//____________________________________________________________________________
//
//  Class:      CObjFormats
//
//  Purpose:    Impements IEnumFORMATETC for job objects.
//____________________________________________________________________________


class CObjFormats : public IEnumFORMATETC
{
    friend HRESULT JFGetObjFormats(UINT cfmt, FORMATETC *afmt, LPVOID *ppvObj);

public:
    ~CObjFormats() { if (m_aFmt) delete [] m_aFmt; }

    //  IUnknown methods
    DECLARE_STANDARD_IUNKNOWN;

    //  IEnumFORMATETC methods
    STDMETHODIMP Next(ULONG celt, FORMATETC *rgelt, ULONG *pceltFethed);
    STDMETHODIMP Skip(ULONG celt);
    STDMETHODIMP Reset();
    STDMETHODIMP Clone(IEnumFORMATETC ** ppenum);

private:
    CObjFormats(UINT cfmt, FORMATETC * afmt)
            : m_iFmt(0), m_cFmt(cfmt), m_aFmt(afmt), m_ulRefs(1) {}

    UINT            m_iFmt;
    UINT            m_cFmt;
    FORMATETC     * m_aFmt;
};


//____________________________________________________________________________
//
//  Members:     IUnknown methods
//____________________________________________________________________________

IMPLEMENT_STANDARD_IUNKNOWN(CObjFormats);

STDMETHODIMP
CObjFormats::QueryInterface(
   REFIID riid,
   LPVOID FAR* ppvObj)
{
    if (IsEqualIID(IID_IUnknown, riid) ||
        IsEqualIID(IID_IEnumFORMATETC, riid))
    {
        *ppvObj = (IUnknown*)(IEnumFORMATETC*) this;
        this->AddRef();
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}


//____________________________________________________________________________
//
//  Members:     IEnumFORMATETC methods
//____________________________________________________________________________


STDMETHODIMP
CObjFormats::Next(
    ULONG celt,
    FORMATETC *rgelt,
    ULONG *pceltFethed)
{
    UINT    cfetch = 0;
    HRESULT hr = S_FALSE;

    if (m_iFmt < m_cFmt)
    {
        cfetch = m_cFmt - m_iFmt;

        if (cfetch >= celt)
        {
            cfetch = celt;
            hr = S_OK;
        }

        CopyMemory(rgelt, &m_aFmt[m_iFmt], cfetch * sizeof(FORMATETC));
        m_iFmt += cfetch;
    }

    if (pceltFethed)
    {
        *pceltFethed = cfetch;
    }

    return hr;
}


STDMETHODIMP
CObjFormats::Skip(
    ULONG celt)
{
    m_iFmt += celt;

    if (m_iFmt > m_cFmt)
    {
        m_iFmt = m_cFmt;
        return S_FALSE;
    }

    return S_OK;
}

STDMETHODIMP
CObjFormats::Reset()
{
    m_iFmt = 0;
    return S_OK;
}

STDMETHODIMP
CObjFormats::Clone(
    IEnumFORMATETC ** ppenum)
{
    return E_NOTIMPL;
}

//____________________________________________________________________________
//
//  Function:     Function to obtain the IEnumFORMATETC interface for jobs.
//____________________________________________________________________________

HRESULT
JFGetObjFormats(
    UINT        cfmt,
    FORMATETC * afmt,
    LPVOID    * ppvObj)
{
    TRACE_FUNCTION(JFGetObjFormats);

    FORMATETC * pFmt = new FORMATETC[cfmt];

    if (pFmt == NULL)
    {
        CHECK_HRESULT(E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }

    CopyMemory(pFmt, afmt, cfmt * sizeof(FORMATETC));

    CObjFormats * pObjFormats = new CObjFormats(cfmt, pFmt);

    if (pObjFormats == NULL)
    {
        delete [] pFmt;
        CHECK_HRESULT(E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pObjFormats->QueryInterface(IID_IEnumFORMATETC, ppvObj);
    pObjFormats->Release();

    DEBUG_OUT((DEB_TRACE, "RETURNING CObjFormats<%x, %d>\n",
                                        pObjFormats, pObjFormats->m_ulRefs));
    return hr;
}



//____________________________________________________________________________
//____________________________________________________________________________
//________________                     _______________________________________
//________________  class CJobObject  _______________________________________
//________________                     _______________________________________
//____________________________________________________________________________
//____________________________________________________________________________


class CJobObject : public IDataObject
{
public:

    CJobObject(
        LPCTSTR         pszFolderPath,
        LPITEMIDLIST    pidlFolder,
        UINT            cidl,
        LPITEMIDLIST   *apidl,
        BOOL            fCut);

    ~CJobObject()
    {
        ILA_Free(m_cidl, m_apidl);
        ILFree(m_pidlFolder);
        DEBUG_ASSERT(m_ulRefs == 0);
    }


    //  Iunknown methods
    DECLARE_STANDARD_IUNKNOWN;

    // IDataObject
    STDMETHODIMP GetData(FORMATETC *pformatetcIn, STGMEDIUM *pmedium);
    STDMETHODIMP GetDataHere(FORMATETC *pformatetc, STGMEDIUM *pmedium);
    STDMETHODIMP QueryGetData(FORMATETC *pformatetc);
    STDMETHODIMP GetCanonicalFormatEtc(FORMATETC *pformatectIn,
                                       FORMATETC *pformatetcOut);
    STDMETHODIMP SetData(FORMATETC *pformatetc, STGMEDIUM *pmedium,
                         BOOL fRelease);
    STDMETHODIMP EnumFormatEtc(DWORD dwDirection,
                               IEnumFORMATETC **ppenumFormatEtc);
    STDMETHODIMP DAdvise(FORMATETC *pformatetc, DWORD advf,
                         IAdviseSink *pAdvSink, DWORD *pdwConnection);
    STDMETHODIMP DUnadvise(DWORD dwConnection);
    STDMETHODIMP EnumDAdvise(IEnumSTATDATA **ppenumAdvise);

private:
    LPCTSTR         m_pszFolderPath;
    LPITEMIDLIST    m_pidlFolder;
    UINT            m_cidl;
    LPITEMIDLIST  * m_apidl;

    BOOL            m_fCut;     // this is for a cut operation
};

inline
CJobObject::CJobObject(
    LPCTSTR         pszFolderPath,
    LPITEMIDLIST    pidlFolder,
    UINT            cidl,
    LPITEMIDLIST   *apidl,
    BOOL            fCut):
        m_cidl(cidl),
        m_pszFolderPath(pszFolderPath),
        m_pidlFolder(pidlFolder),
        m_apidl(apidl),
        m_ulRefs(1),
        m_fCut(fCut)
{
}

//____________________________________________________________________________
//
//  Members:     IUnknown methods
//____________________________________________________________________________

IMPLEMENT_STANDARD_IUNKNOWN(CJobObject);

STDMETHODIMP
CJobObject::QueryInterface(
   REFIID riid,
   LPVOID FAR* ppvObj)
{
    if (IsEqualIID(IID_IUnknown, riid) ||
        IsEqualIID(IID_IDataObject, riid))
    {
        *ppvObj = (IUnknown*)((IDataObject*)this);
        this->AddRef();
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

//____________________________________________________________________________
//
//  Function:   DbgPrintFmt
//
//  Synopsis:   Function to print out the format name.
//____________________________________________________________________________

#if DBG==1
void
DbgPrintFmt(
    UINT  format)
{
#undef  DEB_USEREX
#define DEB_USEREX DEB_USER15

    TCHAR szFmtName[550];
    int cchFmtName = 550;

    if (format == g_cfJobIDList)
    {
        DEBUG_OUT((DEB_USEREX, "\t\t<Format=Job IDList Array>\n"));
        return;
    }
    else if (format == g_cfPreferredDropEffect)
    {
        DEBUG_OUT((DEB_USEREX, "\t\t<Format=Preferred DropEffect>\n"));
        return;
    }

    int iRet = GetClipboardFormatName(format, szFmtName, cchFmtName);

    if (iRet == 0)
        if (GetLastError() == 0)
            DEBUG_OUT((DEB_USEREX, "\t\t<Predefined format=%d>\n", format));
        else
            DEBUG_OUT((DEB_USEREX, "\t\t<Unknown Format=%d>\n", format));
    else
        DEBUG_OUT((DEB_USEREX, "\t\t<Format=%ws>\n", szFmtName));
}
#define DBG_PRINT_FMT(fmt) DbgPrintFmt(fmt)
#else
#define DBG_PRINT_FMT(fmt)
#endif

//____________________________________________________________________________
//
//  Member:     CJobObject::IDataObject::GetData
//
//  History:    1/31/1996   RaviR   Created
//____________________________________________________________________________

STDMETHODIMP
CJobObject::GetData(
    FORMATETC *pfmt,
    STGMEDIUM *pmedium)
{
    TRACE(CJobObject, GetData);
    DBG_PRINT_FMT(pfmt->cfFormat);

    Win4Assert(g_cfJobIDList != 0);

    if (pfmt->tymed & TYMED_HGLOBAL)
    {
        if (pfmt->cfFormat == CF_HDROP)
        {
            pmedium->hGlobal = HDROPFromJobIDList(m_pszFolderPath,
                                            m_cidl, (PJOBID *)m_apidl);
        }
        else if (pfmt->cfFormat == g_cfShellIDList)
        {
            pmedium->hGlobal = CreateIDListArray(m_pidlFolder,
                                                 m_cidl,
                                                 (PJOBID *)m_apidl);
        }
        else if (pfmt->cfFormat == g_cfJobIDList)
        {
            // Note Ole32's GetHGlobalFromILockBytes uses this

            pmedium->hGlobal = HJOBIDA_Create(m_cidl, (PJOBID *)m_apidl);
        }
        else if (pfmt->cfFormat == g_cfPreferredDropEffect)
        {
            DWORD *pdw = (DWORD *)GlobalAlloc(GPTR, sizeof(DWORD));

            if (pdw)
            {
                *pdw = m_fCut ? DROPEFFECT_MOVE : DROPEFFECT_COPY;
                pmedium->hGlobal = (HGLOBAL)pdw;
            }
        }
        else
        {
            pmedium->tymed = TYMED_NULL;
            pmedium->hGlobal = NULL;
            pmedium->pUnkForRelease = NULL;

            return DATA_E_FORMATETC;
        }

        if (pmedium->hGlobal != NULL)
        {
            pmedium->tymed          = TYMED_HGLOBAL;
            pmedium->pUnkForRelease = NULL;

            return S_OK;
        }
        else
        {
            return E_OUTOFMEMORY;
        }
    }

    return DV_E_TYMED;
}


//____________________________________________________________________________
//
//  Member:     CJobObject::IDataObject::GetDataHere
//____________________________________________________________________________

STDMETHODIMP
CJobObject::GetDataHere(
    FORMATETC *pfmt,
    STGMEDIUM *pmedium)
{
    TRACE(CJobObject, GetDataHere);
    DBG_PRINT_FMT(pfmt->cfFormat);

    return E_NOTIMPL;
}


//____________________________________________________________________________
//
//  Member:     CJobObject::IDataObject::QueryGetData
//
//  History:    1/31/1996   RaviR   Created
//____________________________________________________________________________

STDMETHODIMP
CJobObject::QueryGetData(
    FORMATETC *pfmt)
{
    TRACE(CJobObject, QueryGetData);
    DBG_PRINT_FMT(pfmt->cfFormat);

    //
    //  Check the aspects we support.
    //

    if (!(DVASPECT_CONTENT & pfmt->dwAspect))
    {
        return DATA_E_FORMATETC;
    }

    Win4Assert(g_cfJobIDList != 0);

    if (pfmt->cfFormat == CF_HDROP ||
        pfmt->cfFormat == g_cfJobIDList ||
        pfmt->cfFormat == g_cfShellIDList ||
        pfmt->cfFormat == g_cfPreferredDropEffect)
    {
        return S_OK;
    }

    return S_FALSE;
}


//____________________________________________________________________________
//
//  Member:     CJobObject::IDataObject::GetCanonicalFormatEtc
//____________________________________________________________________________

STDMETHODIMP
CJobObject::GetCanonicalFormatEtc(
    FORMATETC *pfmtIn,
    FORMATETC *pfmtOut)
{
    TRACE(CJobObject, GetCanonicalFormatEtc);

    *pfmtOut = *pfmtIn;

    pfmtOut->ptd = NULL;

    return DATA_S_SAMEFORMATETC;
}


//____________________________________________________________________________
//
//  Member:     CJobObject::IDataObject::SetData
//____________________________________________________________________________

STDMETHODIMP
CJobObject::SetData(
    FORMATETC *pfmt,
    STGMEDIUM *pmedium,
    BOOL fRelease)
{
    TRACE(CJobObject, SetData);
    DBG_PRINT_FMT(pfmt->cfFormat);

    return E_NOTIMPL;
}


//____________________________________________________________________________
//
//  Member:     CJobObject::IDataObject::EnumFormatEtc
//
//  History:    1/31/1996   RaviR   Created
//____________________________________________________________________________

STDMETHODIMP
CJobObject::EnumFormatEtc(
    DWORD dwDirection,
    IEnumFORMATETC **ppenumFormatEtc)
{
    TRACE(CJobObject, EnumFormatEtc);

    if (dwDirection == DATADIR_SET)
    {
        return E_FAIL;
    }

    FORMATETC fmte[] = {
        {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
        {(CLIPFORMAT)g_cfJobIDList, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
        {(CLIPFORMAT)g_cfShellIDList, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
        {(CLIPFORMAT)g_cfPreferredDropEffect, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
    };

    HRESULT hr = JFGetObjFormats(ARRAYLEN(fmte), fmte, (void**)ppenumFormatEtc);

    return hr;
}


//____________________________________________________________________________
//
//  Member:     CJobObject::IDataObject::DAdvise
//____________________________________________________________________________

STDMETHODIMP
CJobObject::DAdvise(
    FORMATETC *pformatetc,
    DWORD advf,
    IAdviseSink *pAdvSink,
    DWORD *pdwConnection)
{
    TRACE(CJobObject, DAdvise);

    return E_NOTIMPL;
}


//____________________________________________________________________________
//
//  Member:     CJobObject::IDataObject::DUnadvise
//____________________________________________________________________________

STDMETHODIMP
CJobObject::DUnadvise(
    DWORD dwConnection)
{
    TRACE(CJobObject, DUnadvise);

    return E_NOTIMPL;
}

//____________________________________________________________________________
//
//  Member:     CJobObject::IDataObject::EnumDAdvise
//____________________________________________________________________________

STDMETHODIMP
CJobObject::EnumDAdvise(
    IEnumSTATDATA **ppenumAdvise)
{
    TRACE(CJobObject, EnumDAdvise);

    return E_NOTIMPL;
}



//+--------------------------------------------------------------------------
//
//  Function:   JFGetDataObject
//
//  Synopsis:   Function to create a data object for jobs in the job folder.
//
//  Arguments:  [pszFolderPath] - full path to tasks folder
//              [pidlFolder]    - pidl to that folder, supplied by shell's
//                                 call to IPersistFolder::Initialize.
//              [cidl]          - number elements in array
//              [apidl]         - array of idls, each naming a .job object
//              [fCut]          - TRUE if this is created for cut operation
//              [ppvObj]        - filled with pointer to new data object
//
//  Returns:    HRESULT
//
//  Modifies:   *[ppvObj]
//
//  History:    01/31/1996   RaviR      Created
//              05-30-1997   DavidMun   Pass copy of [pidlFolder]
//
//---------------------------------------------------------------------------

HRESULT
JFGetDataObject(
    LPCTSTR         pszFolderPath,
    LPCITEMIDLIST   pidlFolder,
    UINT            cidl,
    LPCITEMIDLIST * apidl,
    BOOL            fCut,
    LPVOID        * ppvObj)
{
    TRACE_FUNCTION(JFGetDataObject);

    LPITEMIDLIST  * apidlTemp = ILA_Clone(cidl, apidl);

    if (NULL == apidlTemp)
    {
        CHECK_HRESULT(E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }

    LPITEMIDLIST pidlFolderCopy = ILClone(pidlFolder);

    if (!pidlFolderCopy)
    {
        ILA_Free(cidl, apidlTemp);
        CHECK_HRESULT(E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }

    CJobObject * pJobObjects = new CJobObject(pszFolderPath,
                                              pidlFolderCopy,
                                              cidl,
                                              apidlTemp,
                                              fCut);
    if (pJobObjects == NULL)
    {
        ILA_Free(cidl, apidlTemp);

        CHECK_HRESULT(E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pJobObjects->QueryInterface(IID_IDataObject, ppvObj);

    pJobObjects->Release();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\folderui\guids.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       guids.h
//
//  Contents:   All GUIDs
//
//  History:    Jan-05-96    RaviR     Created
//
//----------------------------------------------------------------------------

// {d6277990-4c6a-11cf-8d87-00aa0060f5bf}
DEFINE_GUID(CLSID_CJobFolder, 0xd6277990, 0x4c6a, 0x11cf, 0x8d, 0x87, 0x00,0xaa,0x00,0x60,0xf5,0xbf);

// {797F1E90-9EDD-11cf-8D8E-00AA0060F5BF}
DEFINE_GUID(CLSID_CSchedObjExt, 0x797f1e90, 0x9edd, 0x11cf, 0x8d, 0x8e, 0x0, 0xaa, 0x0, 0x60, 0xf5, 0xbf);

// {DD2110F0-9EEF-11cf-8D8E-00AA0060F5BF}
DEFINE_GUID(CLSID_CTaskIconExt, 0xdd2110f0, 0x9eef, 0x11cf, 0x8d, 0x8e, 0x0, 0xaa, 0x0, 0x60, 0xf5, 0xbf);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\folderui\dllutil.cxx ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:       dllutil.cxx
//
//  Contents:   DLL related stuff
//
//  Classes:
//
//  Functions:
//
//  History:    1/4/1996   RaviR   Created
//
//____________________________________________________________________________

#include "..\pch\headers.hxx"
#pragma hdrstop

#include <locale.h>

#include "dbg.h"
#include "macros.h"
#include "common.hxx"

//
//  Debug stuff
//

DECLARE_INFOLEVEL(Job);
DECLARE_HEAPCHECKING;

#if defined(DBX) && defined(_CHICAGO_)
TCHAR emsg[300];
#endif


//
//  Clipboard formats
//

#define CFSTR_JOBIDLIST             TEXT("Job IDList Array")
#define CFSTR_PREFERREDDROPEFFECT   TEXT("Preferred DropEffect")

extern "C" UINT g_cfJobIDList = 0;
extern "C" UINT g_cfShellIDList = 0;
extern "C" UINT g_cfPreferredDropEffect = 0;

#if (DBG == 1)
extern BOOL fInfoLevelInit;
#endif // (DBG == 1)

BOOL
JFOnProcessAttach(void)
{
    //
    //  Init debugging stuff.
    //

    #if DBG == 1
    {
        InitializeDebugging();

        JobInfoLevel = DEB_ERROR | DEB_WARN;

        #ifdef DBX
            JobInfoLevel |= DEB_USER1;
        #endif // DBX

        fInfoLevelInit = FALSE;
        CheckInit(JobInfoLevelString, &JobInfoLevel);
        //SetSmAssertLevel(ASSRT_BREAK | ASSRT_MESSAGE);
        SetSmAssertLevel(ASSRT_POPUP | ASSRT_MESSAGE);
    }
    #endif // DBG == 1

    TRACE_FUNCTION(JFOnProcessAttach);

    //
    // Get the clipboard formats used by the data object.
    //

    g_cfJobIDList = RegisterClipboardFormat(CFSTR_JOBIDLIST);

    g_cfShellIDList = RegisterClipboardFormat(CFSTR_SHELLIDLIST);

    g_cfPreferredDropEffect = RegisterClipboardFormat(
                                    CFSTR_PREFERREDDROPEFFECT);

    if (g_cfJobIDList == 0 ||
        g_cfPreferredDropEffect == 0)
    {
        DEBUG_OUT_LASTERROR;
        return FALSE;
    }

    //
    // Get common controls
    //

    InitCommonControls();

    INITCOMMONCONTROLSEX icce;

    icce.dwSize = sizeof(icce);
    icce.dwICC = ICC_DATE_CLASSES;
    InitCommonControlsEx(&icce);

#if !defined(_CHICAGO_)

    //
    // Set the C runtime library locale, for string operations (not needed on
    // Chicago 'cause it isn't UNICODE nor does the statically linked subset
    // of the CRTs that we use include it).
    //

    setlocale(LC_CTYPE, "");

#endif

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\folderui\enum.cxx ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       enum.cxx
//
//  Contents:   Implementation of IEnumIDList
//
//  Classes:
//
//  Functions:
//
//  History:    1/5/1996   RaviR   Created
//
//____________________________________________________________________________


#include "..\pch\headers.hxx"
#pragma hdrstop

#include "dbg.h"
#include "macros.h"
#include "..\inc\common.hxx"
#include "..\inc\policy.hxx"

#include "dll.hxx"
#include "jobidl.hxx"
#include "util.hxx"
#include "bitflag.hxx"

//#undef DEB_TRACE
//#define DEB_TRACE DEB_USER1

//
// Private flags
//

#define JE_LOCAL                0x0001
#define JE_ENUMERATED_TEMPLATE  0x0002

//____________________________________________________________________________
//
//  Class:      CJobsEnum
//
//  Purpose:    Enumerates jobs in a folder.
//
//  History:    1/25/1996   RaviR   Created
//____________________________________________________________________________

class CJobsEnum : public IEnumIDList,
                  public CBitFlag
{
public:
    CJobsEnum(ULONG uFlags, LPCTSTR pszFolderPath, IEnumWorkItems *pEnumJobs);
    ~CJobsEnum(void);

    // IUnknown methods
    DECLARE_STANDARD_IUNKNOWN;

    // IEnumIDList methods
    STDMETHOD(Next)(ULONG celt, LPITEMIDLIST* rgelt, ULONG* pceltFetched);
    STDMETHOD(Skip)(ULONG celt);
    STDMETHOD(Reset)(void);
    STDMETHOD(Clone)(IEnumIDList** ppenum);

private:
    ULONG            m_uShellFlags;   // SHCONTF flags passed in by shell 
    IEnumWorkItems * m_pEnumJobs;
    LPCTSTR          m_pszFolderPath;
    CDllRef          m_DllRef;
};



//____________________________________________________________________________
//
//  Member:     CJobsEnum::CJobsEnum, Constructor
//
//  History:    1/5/1996   RaviR   Created
//
//____________________________________________________________________________

inline
CJobsEnum::CJobsEnum(
    ULONG            uFlags,
    LPCTSTR          pszFolderPath,
    IEnumWorkItems * pEnumJobs)
        :
        m_ulRefs(1),
        m_uShellFlags(uFlags),
        m_pEnumJobs(pEnumJobs),
        m_pszFolderPath(pszFolderPath)
{
    TRACE(CJobsEnum, CJobsEnum);

    DEBUG_OUT((DEB_USER1, "FolderPath = %ws\n", pszFolderPath));

    if (IsLocalFilename(pszFolderPath))
    {
        _SetFlag(JE_LOCAL);
    }
    Win4Assert(m_pEnumJobs != NULL);

    m_pEnumJobs->AddRef();

    //
    // Policy - do not allow the template item if we are not
    // allowing job creation
    //  -- Later, we prevent this flag from being cleared
    //

    if (RegReadPolicyKey(TS_KEYPOLICY_DENY_CREATE_TASK))
    {
        DEBUG_OUT((DEB_ITRACE, "Policy CREATE_TASK active - no template wizard\n"));
		
        //
        // This next flag means that we have ALREADY shown the template.
        // Setting it will force us never to enumerate it
        //

        _SetFlag(JE_ENUMERATED_TEMPLATE);
    }
	
}


//____________________________________________________________________________
//
//  Member:     CJobsEnum::~CJobsEnum, Destructor
//____________________________________________________________________________

inline
CJobsEnum::~CJobsEnum()
{
    TRACE(CJobsEnum, ~CJobsEnum);

    if (m_pEnumJobs != NULL)
    {
        m_pEnumJobs->Release();
    }

    // Note: No need to free m_pszFolderPath.
}

//____________________________________________________________________________
//
//  Member:     IUnknown methods
//____________________________________________________________________________

IMPLEMENT_STANDARD_IUNKNOWN(CJobsEnum);


STDMETHODIMP
CJobsEnum::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    if (IsEqualIID(IID_IUnknown, riid) ||
        IsEqualIID(IID_IEnumIDList, riid))
    {
        *ppvObj = (IUnknown*)(IEnumIDList*) this;
        this->AddRef();
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}


//____________________________________________________________________________
//
//  Member:     CJobsEnum::IEnumIDList::Next
//
//  Arguments:  [celt] -- IN
//              [ppidlOut] -- IN
//              [pceltFetched] -- IN
//
//  Returns:    HRESULT.
//
//  History:    1/5/1996   RaviR   Created
//              2-12-1997   DavidMun   Handle NULL pceltFetched
//
//____________________________________________________________________________

STDMETHODIMP
CJobsEnum::Next(
    ULONG celt,
    LPITEMIDLIST* ppidlOut,
    ULONG* pceltFetched)
{
    TRACE(CJobsEnum, Next);

    HRESULT hr = S_OK;
    CJobID   jid;

    if (!(m_uShellFlags & SHCONTF_NONFOLDERS))
    {
        return S_FALSE;
    }

    if (m_pEnumJobs == NULL)
    {
        return E_FAIL;
    }

    if (pceltFetched == NULL && celt != 1)
    {
        return E_INVALIDARG;
    }

    if (pceltFetched)
    {
        *pceltFetched = 0;
    }

    ULONG    curr = 0;
    LPWSTR * ppwszJob = NULL;
    ULONG    ulTemp;

    if (_IsFlagSet(JE_LOCAL) && 
        !_IsFlagSet(JE_ENUMERATED_TEMPLATE) &&
        celt)
    {
        jid.InitToTemplate();
        ppidlOut[curr] = ILClone((LPCITEMIDLIST)(&jid));

        if (!ppidlOut[curr])
        {
            return E_OUTOFMEMORY;
        }
        DEBUG_OUT((DEB_ITRACE, "Created template\n"));
        curr++;
        _SetFlag(JE_ENUMERATED_TEMPLATE);
    }

    while (curr < celt)
    {
        hr = m_pEnumJobs->Next(1, &ppwszJob, &ulTemp);

        CHECK_HRESULT(hr);

        if (FAILED(hr))
        {
            break;
        }
        else if (ulTemp == 0)
        {
            hr = S_FALSE;
            break;
        }

        LPTSTR pszJob = (LPTSTR)*ppwszJob;

#if !defined(UNICODE)
        char szBuff[MAX_PATH];
        UnicodeToAnsi(szBuff, *ppwszJob, MAX_PATH);
        pszJob = szBuff;
#endif

        hr = jid.Load(m_pszFolderPath, pszJob);

        CoTaskMemFree(*ppwszJob);
        CoTaskMemFree(ppwszJob);

        if (S_OK == hr)
        {
            ppidlOut[curr] = ILClone((LPCITEMIDLIST)(&jid));

            if (NULL != ppidlOut[curr])
            {
                ++curr;
                hr = S_OK;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

        if (hr == E_OUTOFMEMORY)
        {
            break;
        }
    }

    if (curr > 0 && curr < celt)
    {
        hr = S_FALSE;
    }

    if (pceltFetched)
    {
        *pceltFetched = curr;
    }
    return hr;
}


//____________________________________________________________________________
//
//  Member:     CJobsEnum::Skip
//
//  Arguments:  [celt] -- IN
//
//  Returns:    HRESULT.
//
//  History:    1/5/1996   RaviR   Created
//
//____________________________________________________________________________

STDMETHODIMP
CJobsEnum::Skip(
    ULONG celt)
{
    TRACE(CJobsEnum, Skip);

    if (!celt)
    {
        return E_INVALIDARG;
    }

    if (_IsFlagSet(JE_LOCAL) && !_IsFlagSet(JE_ENUMERATED_TEMPLATE))
    {
        celt--;
        _SetFlag(JE_ENUMERATED_TEMPLATE);

        if (!celt)
        {
            return S_OK;
        }
    }
    return m_pEnumJobs->Skip(celt);
}

//____________________________________________________________________________
//
//  Member:     CJobsEnum::Reset
//
//  Returns:    HRESULT.
//
//  History:    1/5/1996   RaviR   Created
//
//____________________________________________________________________________

STDMETHODIMP
CJobsEnum::Reset(void)
{
    TRACE(CJobsEnum, Reset);
	
    //
    // Policy - don't clear flag if we are not allowing job creation
    //

    if (! RegReadPolicyKey(TS_KEYPOLICY_DENY_CREATE_TASK))
    {
        DEBUG_OUT((DEB_ITRACE, "Policy CREATE_TASK active - prevent template wiz\n"));
	
        //
        // Not clearing this flag maintains that we will have enumerated
        // the template on the next go around
        //

        _ClearFlag(JE_ENUMERATED_TEMPLATE);
    }
    return m_pEnumJobs->Reset();
}

//____________________________________________________________________________
//
//  Member:     CJobsEnum::Clone
//
//  Arguments:  [ppenum] -- IN
//
//  Returns:    HRESULT.
//
//  History:    1/5/1996   RaviR   Created
//
//____________________________________________________________________________

STDMETHODIMP
CJobsEnum::Clone(
    IEnumIDList** ppenum)
{
    TRACE(CJobsEnum, Clone);

    return E_FAIL;  // not supported
}


//____________________________________________________________________________
//
//  Function:   JFGetEnumIDList
//
//  Synopsis:   Function to create the object to enumearte the JobIDList
//
//  Arguments:  [uFlags] -- IN
//              [pszFolderPath] -- IN
//              [pEnumJobs] -- IN
//              [riid] -- IN
//              [ppvObj] -- OUT
//
//  Returns:    HRESULT
//
//  History:    1/24/1996   RaviR   Created
//
//____________________________________________________________________________

HRESULT
JFGetEnumIDList(
    ULONG            uFlags,
    LPCTSTR          pszFolderPath,
    IEnumWorkItems * pEnumJobs,
    LPVOID    *      ppvObj)
{
    CJobsEnum * pEnum = new CJobsEnum(uFlags, pszFolderPath, pEnumJobs);

    if (NULL == pEnum)
    {
        CHECK_HRESULT(E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }

    pEnumJobs->Reset();

    HRESULT hr = pEnum->QueryInterface(IID_IEnumIDList, ppvObj);

    pEnum->Release();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\folderui\hsort.cxx ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       HSort.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    5/3/1996   RaviR   Created
//
//____________________________________________________________________________

#include "..\pch\headers.hxx"
#pragma hdrstop

#include "macros.h"
#include "jobidl.hxx"

void PercolateUp(PJOBID *ppjid, UINT iMaxLevel);
void PercolateDown(PJOBID *ppjid, UINT iMaxLevel);

//
// HeapSort:  HeapSort (also called TreeSort) works by calling
// PercolateUp and PercolateDown. PercolateUp organizes the elements
// into a "heap" or "tree," which has the properties shown below:
//
//                            element[1]
//                          /            \
//               element[2]                element[3]
//              /          \              /          \
//        element[4]     element[5]   element[6]    element[7]
//        /        \     /        \   /        \    /        \
//       ...      ...   ...      ... ...      ...  ...      ...
//
//
//  Each "parent node" is greater than each of its "child nodes"; for
//  example, element[1] is greater than element[2] or element[3];
//  element[2] is greater than element[4] or element[5], and so forth.
//  Therefore, once the first loop in HeapSort is finished, the
//  largest element is in element[1].
//
//  The second loop rebuilds the heap (with PercolateDown), but starts
//  at the top and works down, moving the largest elements to the bottom.
//  This has the effect of moving the smallest elements to the top and
//  sorting the heap.
//

void hsort(PJOBID *ppjid, UINT cObjs)
{
    //
    // First build a "heap" with the largest element at the top
    //

    for (UINT i = 1; i < cObjs; i++)
    {
        PercolateUp(ppjid, i);
    }

    //
    //  The next loop rebuilds the heap (with PercolateDown), but starts
    //  at the top and works down, moving the largest elements to the bottom.
    //  This has the effect of moving the smallest elements to the top and
    //  sorting the heap.
    //

    PJOBID pjid;

    for (i = cObjs - 1; i > 0; i--)
    {
        // Swap ppjid[0] & ppjid[i]
        pjid = ppjid[0];
        ppjid[0] = ppjid[i];
        ppjid[i] = pjid;

        PercolateDown(ppjid, i - 1);
    }
}

inline int CompareJobIDs(PJOBID pjid1, PJOBID pjid2)
{
    return lstrcmpi(pjid1->GetName(), pjid2->GetName());
}


// PercolateUp: Converts elements into a "heap" with the largest
// element at the top (see the diagram above).

void PercolateUp(PJOBID *ppjid, UINT iMaxLevel)
{
    UINT    i = iMaxLevel;
    UINT    iParent;
    PJOBID  pjid;

    // Move the value in ppjid[iMaxLevel] up the heap until it has
    // reached its proper node (that is, until it is greater than either
    // of its child nodes, or until it has reached 1, the top of the heap).

    while (i)
    {
        iParent = i / 2;    // Get the subscript for the parent node

        if (CompareJobIDs(ppjid[i], ppjid[iParent]) > 0)
        {
            // The value at the current node is bigger than the value at
            // its parent node, so swap these two array elements.

            // Swap ppjid[iParent], ppjid[i]
            pjid = ppjid[iParent];
            ppjid[iParent] = ppjid[i];
            ppjid[i] = pjid;


            i = iParent;
        }
        else
        {
            // Otherwise, the element has reached its proper place in the
            // heap, so exit this procedure.

            break;
        }
    }
}


// PercolateDown: Converts elements to a "heap" with the largest elements
// at the bottom. When this is done to a reversed heap (largest elements
// at top), it has the effect of sorting the elements.
//
void PercolateDown(PJOBID *ppjid, UINT iMaxLevel)
{
    UINT    iChild;
    UINT    i = 0;
    PJOBID  pjid;

    // Move the value in ppjid[0] down the heap until it has reached
    // its proper node (that is, until it is less than its parent node
    // or until it has reached iMaxLevel, the bottom of the current heap).

    while (1)
    {
        // Get the subscript for the child node.
        iChild = 2 * i;

        // Reached the bottom of the heap, so exit this procedure.
        if (iChild > iMaxLevel)
        {
            break;
        }

        // If there are two child nodes, find out which one is bigger.
        if (iChild + 1 <= iMaxLevel)
        {
            if (CompareJobIDs(ppjid[iChild + 1], ppjid[iChild]) > 0)
            {
                iChild++;
            }
        }

        if (CompareJobIDs(ppjid[i], ppjid[iChild]) < 0)
        {
            // Move the value down since it is still not bigger than
            // either one of its children.

            // Swaps ppjid[i], ppjid[iChild]
            pjid = ppjid[iChild];
            ppjid[iChild] = ppjid[i];
            ppjid[i] = pjid;


            i = iChild;
        }
        else
        {
            // Otherwise, ppjid has been restored to a heap from 1 to
            // iMaxLevel, so exit.

            break;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\folderui\jobicons.cxx ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       icon.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    4/5/1996   RaviR   Created
//
//____________________________________________________________________________

#include "..\pch\headers.hxx"
#pragma hdrstop

#include "dbg.h"
#include "macros.h"
#include "..\inc\resource.h"
#include "resource.h"
#include "jobicons.hxx"

extern HINSTANCE g_hInstance;

CJobIcon::CJobIcon(void)
{
    m_himlSmall = NULL; // init so that if creation of m_himlLarge fails,
                        // the destrucor will not fault.

    //
    //  Large
    //

    int cx = GetSystemMetrics(SM_CXICON);
    int cy = GetSystemMetrics(SM_CYICON);

    m_himlLarge = ImageList_Create(cx, cy, TRUE, 1, 1);

    if (m_himlLarge == NULL)
    {
        DEBUG_OUT((DEB_ERROR, "ImageList_Create(large) returned NULL.\n"));
        return;
    }

    HBITMAP hBmp = LoadBitmap(g_hInstance, MAKEINTRESOURCE(BMP_JOBSTATEL));

    if (hBmp == NULL)
    {
        DEBUG_OUT((DEB_ERROR, "LoadBitmap(state-large) returned NULL.\n"));
        return;
    }

    int i = ImageList_AddMasked(m_himlLarge, hBmp, RGB(0, 255, 0));

    if (i != 0)
    {
        DEBUG_OUT((DEB_ERROR, "ImageList_AddMasked returned <%d> expected 0.\n", i));
    }

    DeleteObject(hBmp);

    //
    //  Small
    //

    cx = GetSystemMetrics(SM_CXSMICON);
    cy = GetSystemMetrics(SM_CYSMICON);

    m_himlSmall = ImageList_Create(cx, cy, TRUE, 1, 1);

    if (m_himlSmall == NULL)
    {
        DEBUG_OUT((DEB_ERROR, "ImageList_Create(small) returned NULL.\n"));
        return;
    }

    hBmp = LoadBitmap(g_hInstance, MAKEINTRESOURCE(BMP_JOBSTATES));

    if (hBmp == NULL)
    {
        DEBUG_OUT((DEB_ERROR, "LoadBitmap(state-small) returned NULL.\n"));
        return;
    }

    i = ImageList_AddMasked(m_himlSmall, hBmp, RGB(0, 255, 0));

    if (i != 0)
    {
        DEBUG_OUT((DEB_ERROR, "ImageList_AddMasked returned <%d> expected 0.\n", i));
    }

    DeleteObject(hBmp);
}


HICON
GetDefaultAppIcon(
    BOOL fLarge)
{
    TRACE_FUNCTION(GetDefaultAppIcon);

    HICON hicon = 0;

    int cx = GetSystemMetrics(fLarge ? SM_CXICON : SM_CXSMICON);
    int cy = GetSystemMetrics(fLarge ? SM_CYICON : SM_CYSMICON);

    hicon = (HICON)LoadImage(g_hInstance, (LPCTSTR)IDI_GENERIC, IMAGE_ICON,
                                            cx, cy, LR_DEFAULTCOLOR);
    return hicon;
}

void
CJobIcon::GetIcons(
    LPCTSTR pszApp,
    BOOL    fEnabled,
    HICON * phiconLarge,
    HICON * phiconSmall)
{
    TRACE(CJobIcon, GetIcons);

    UINT count;

    if (pszApp != NULL && *pszApp != TEXT('\0'))
    {
        count = ExtractIconEx(pszApp, 0, phiconLarge, phiconSmall, 1);
    }

    _OverlayIcons(phiconLarge, phiconSmall, fEnabled);
}



//+--------------------------------------------------------------------------
//
//  Member:     CJobIcon::GetTemplateIcons
//
//  Synopsis:   Fill out pointers with large and small template icons
//
//  Arguments:  [phiconLarge] - NULL or ptr to icon handle to fill
//              [phiconSmall] - ditto
//
//  History:    5-15-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CJobIcon::GetTemplateIcons(
    HICON * phiconLarge,
    HICON * phiconSmall)
{
    TRACE(CJobIcon, GetTemplateIcons);

    if (phiconLarge)
    {
        int cx = GetSystemMetrics(SM_CXICON);
        int cy = GetSystemMetrics(SM_CYICON);
    
        *phiconLarge = (HICON) LoadImage(g_hInstance, 
                                         MAKEINTRESOURCE(IDI_TEMPLATE), 
                                         IMAGE_ICON,
                                         cx, 
                                         cy, 
                                         LR_DEFAULTCOLOR);
    
        if (!*phiconLarge)
        {
            DEBUG_OUT_LASTERROR;
        }
    }

    if (phiconSmall)
    {
        int cx = GetSystemMetrics(SM_CXSMICON);
        int cy = GetSystemMetrics(SM_CYSMICON);
    
        *phiconSmall = (HICON) LoadImage(g_hInstance, 
                                         MAKEINTRESOURCE(IDI_TEMPLATE), 
                                         IMAGE_ICON,
                                         cx, 
                                         cy, 
                                         LR_DEFAULTCOLOR);
        if (!*phiconSmall)
        {
            DEBUG_OUT_LASTERROR;
        }
    }
}


void
CJobIcon::_OverlayIcons(
    HICON * phiconLarge,
    HICON * phiconSmall,
    BOOL    fEnabled)
{
    HICON hiconTemp;

    if (phiconLarge != NULL)
    {
        if (*phiconLarge == NULL)
        {
            *phiconLarge = GetDefaultAppIcon(TRUE);
        }

        hiconTemp = OverlayStateIcon(*phiconLarge, fEnabled);

        DestroyIcon(*phiconLarge);
        *phiconLarge = hiconTemp;
    }

    if (phiconSmall != NULL)
    {
        if (*phiconSmall == NULL)
        {
            *phiconSmall = GetDefaultAppIcon(FALSE);
        }

        hiconTemp = OverlayStateIcon(*phiconSmall, fEnabled, FALSE);

        DestroyIcon(*phiconSmall);
        *phiconSmall = hiconTemp;
    }
}

HICON
CJobIcon::OverlayStateIcon(
    HICON   hicon,
    BOOL    fEnabled,
    BOOL    fLarge)
{
    TRACE(CJobIcon, OverlayStateIcon);

    HICON hiconOut;

    // dont destroy rhiml !!
    HIMAGELIST &rhiml = (fLarge == TRUE) ? m_himlLarge : m_himlSmall;

    int i = ImageList_AddIcon(rhiml, hicon);

    HIMAGELIST himlNew = ImageList_Merge(rhiml, i, rhiml,
                                        (fEnabled ? 0 : 1), 0, 0);

    ImageList_Remove(rhiml, i);

    hiconOut = ImageList_GetIcon(himlNew, 0, 0);

    if (himlNew != NULL)
    {
        ImageList_Destroy(himlNew);
    }

    return hiconOut;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\folderui\jobfldr.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       jobfldr.cxx
//
//  Contents:   Implementation of COM object CJobFolder
//
//  Classes:    CJobFolder
//
//  History:    1/4/1996   RaviR   Created
//              1-23-1997   DavidMun   Add m_hwndNotify
//
//----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop

#include "dbg.h"
#include "macros.h"
#include "..\inc\resource.h"
#include "resource.h"

#include "sch_cls.hxx"  // sched\inc
#include "job_cls.hxx"  // sched\inc
#include "misc.hxx"     // sched\inc
#include "policy.hxx"   // sched\inc

#include "jobidl.hxx"
#include "jobfldr.hxx"
#include "common.hxx"
#include "guids.h"
#include "util.hxx"
#include "avl.hxx"

//#undef DEB_TRACE
//#define DEB_TRACE DEB_USER1

#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

BOOL
UserCanChangeService(
    LPCTSTR ptszServer);

HRESULT
PromptForServiceStart(
    HWND hwnd);

BOOL
IsMsNetwork( LPTSTR ptszMachine );


//____________________________________________________________________________
//
//  Member:     CJobFolder::~CJobFolder, Destructor
//____________________________________________________________________________

CJobFolder::~CJobFolder()
{
    TRACE(CJobFolder, ~CJobFolder);

    if (m_uRegister)
    {
        DEBUG_OUT((DEB_ERROR,
                   "CJobFolder::~CJobFolder: m_uRegister = %uL but should be 0\n",
                   m_uRegister));
        SHChangeNotifyDeregister(m_uRegister);
        m_uRegister = 0;
        CDll::LockServer(FALSE);
    }

    if (m_hwndNotify)
    {
        DEBUG_OUT((DEB_ERROR,
                   "CJobFolder::~CJobFolder: m_hwndNotify = 0x%x but should be NULL\n",
                   m_hwndNotify));

        BOOL fOk = DestroyWindow(m_hwndNotify);

        if (!fOk)
        {
            DEBUG_OUT_LASTERROR;
        }
    }

    delete m_pszMachine;

    if (m_pUpdateDirData)
    {
        GlobalFree(m_pUpdateDirData);
    }

    if (m_pidlFldr)
    {
        ILFree(m_pidlFldr);
    }

    //  No need to Release m_pShellView since we never addrefed it.
    //  See CreateViewObject in sfolder.cxx for more info.

    if (m_pScheduler != NULL)
    {
        DEBUG_OUT((DEB_USER1, "m_pScheduler->Release\n"));
        m_pScheduler->Release();
    }

    OleUninitialize();
}




HRESULT
CJobFolder::_AddObject(
    PJOBID pjid,
    LPITEMIDLIST *ppidl)
{
    HRESULT hr = S_OK;
    INT_PTR iRet = -1;

    LPITEMIDLIST pidl = ILClone((LPCITEMIDLIST)pjid);

    if (pidl == NULL)
    {
        hr = E_OUTOFMEMORY;
        CHECK_HRESULT(hr);
        return hr;
    }

#if (DBG == 1)
    ((PJOBID) pidl)->Validate();
#endif // (DBG == 1)

    iRet = ShellFolderView_AddObject(m_hwndOwner, pidl);

    if (iRet < 0)
    {
        ILFree(pidl);
        pidl = NULL;

        hr = E_FAIL;
        CHECK_HRESULT(hr);
    }

    if (ppidl)
    {
        *ppidl = pidl;
    }

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CJobFolder::_UpdateObject
//
//  Synopsis:   Notify the shell defview that the object with pidl [pjidOld]
//              has been updated and now should look like pidl [pjidNew].
//
//  Arguments:  [pjidOld] - pidl of object as it appears in defview
//              [pjidNew] - pidl of object as it should now appear
//              [ppidl]   - filled with pidl of updated object
//
//  Returns:    HRESULT
//
//  Modifies:   *[ppidl]
//
//  History:    7-07-1999   davidmun   Commented
//
//  Notes:      Do not free returned pidl in *[ppidl].
//
//---------------------------------------------------------------------------

HRESULT
CJobFolder::_UpdateObject(
    PJOBID pjidOld,
    PJOBID pjidNew,
    LPITEMIDLIST *ppidl)
{
    TRACE(CJobFolder, _UpdateObject);

    HRESULT hr = S_OK;
    INT_PTR iRet = -1;

#if (DBG == 1)
    DEBUG_OUT((DEB_TRACE,
               "CJobFolder::_UpdateObject Validating pjidNew %x\n",
               pjidNew));
    pjidNew->Validate();
#endif // (DBG == 1)

    LPITEMIDLIST pidlCopyOfNew = ILClone((LPCITEMIDLIST)pjidNew);

    if (pidlCopyOfNew == NULL)
    {
        hr = E_OUTOFMEMORY;
        CHECK_HRESULT(hr);
        return hr;
    }

#if (DBG == 1)
    DEBUG_OUT((DEB_TRACE,
               "CJobFolder::_UpdateObject Validating pidlCopyOfNew %x\n",
               pidlCopyOfNew));
    ((PJOBID) pidlCopyOfNew)->Validate();

    DEBUG_OUT((DEB_TRACE,
               "CJobFolder::_UpdateObject Validating pjidOld %x\n",
               pjidOld));
    pjidOld->Validate();
#endif // (DBG == 1)

    LPITEMIDLIST apidl[2] = {(LPITEMIDLIST)pjidOld, pidlCopyOfNew};

    iRet = ShellFolderView_UpdateObject(m_hwndOwner, apidl);

    if (iRet < 0)
    {
        //
        // The object to update couldn't be found, so the shell won't
        // take ownership of the new object, and we have to free it now.
        //

        ILFree(pidlCopyOfNew);
        pidlCopyOfNew = NULL;
    }

    if (ppidl)
    {
        *ppidl = (LPITEMIDLIST)ShellFolderView_GetObject(m_hwndOwner, iRet);
#if (DBG == 1)
        if (*ppidl)
        {
            DEBUG_OUT((DEB_TRACE,
                       "CJobFolder::_UpdateObject Validating *ppidl %x\n",
                       *ppidl));
            ((PJOBID) *ppidl)->Validate();
        }
        else
        {
            DEBUG_OUT((DEB_TRACE, "CJobFolder::_UpdateObject *ppidl is NULL\n"));
        }
#endif // (DBG == 1)
    }

    DEBUG_OUT((DEB_TRACE, "<CJobFolder::_UpdateObject\n"));
    return hr;
}



//____________________________________________________________________________
//
//  Function:   JFGetJobFolder
//
//  Synopsis:   Create an instance of CJobFolder and return the requested
//              interface.
//
//  Arguments:  [riid] -- IN interface needed.
//              [ppvObj] -- OUT place to store the interface.
//
//  Returns:    HRESULT
//
//  History:    1/24/1996   RaviR   Created
//____________________________________________________________________________

HRESULT
JFGetJobFolder(
    REFIID riid,
    LPVOID* ppvObj)
{
    CJobFolder * pJobFolder = NULL;

    HRESULT hr = CJobFolder::Create(&pJobFolder);

    if (SUCCEEDED(hr))
    {
        hr = pJobFolder->QueryInterface(riid, ppvObj);

        pJobFolder->Release();
    }

    return hr;
}

//____________________________________________________________________________
//
//  Member:     CJobFolder::Create
//
//  History:    1/31/1996   RaviR   Created
//____________________________________________________________________________

HRESULT
CJobFolder::Create(
    CJobFolder ** ppJobFolder)
{
    TRACE_FUNCTION(CJobFolder::Create);

    HRESULT hr = OleInitialize(NULL);

    CHECK_HRESULT(hr);

    if (SUCCEEDED(hr))
    {
        CJobFolder *pJobFolder;

        pJobFolder = new CJobFolder();

        if (pJobFolder != NULL)
        {
            *ppJobFolder = pJobFolder;
            hr = S_OK;
        }
        else
        {
            hr = E_OUTOFMEMORY;
            CHECK_HRESULT(hr);

            OleUninitialize();
        }
    }

    return hr;
}

//____________________________________________________________________________
//
//  Member:     CJobFolder::IUnknown methods
//
//  History:    1/31/1996   RaviR   Created
//____________________________________________________________________________


IMPLEMENT_STANDARD_IUNKNOWN(CJobFolder);


STDMETHODIMP
CJobFolder::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    LPUNKNOWN punk = NULL;

    if (IsEqualIID(IID_IUnknown, riid) ||
        IsEqualIID(IID_IShellFolder, riid))
    {
        punk = (IUnknown*) (IShellFolder*) this;
    }
    else if (IsEqualIID(IID_IPersistFolder, riid))
    {
        punk = (IUnknown*) (IPersistFolder*) this;
    }
#if (_WIN32_IE >= 0x0400)
    else if (IsEqualIID(IID_IPersistFolder2, riid))
    {
        punk = (IUnknown*) (IPersistFolder2*) this;
    }
#endif (_WIN32_IE >= 0x0400)
    else if (IsEqualIID(IID_IDropTarget, riid))
    {
        punk = (IUnknown*) (IDropTarget*) this;
    }
    else if (IsEqualIID(IID_IRemoteComputer, riid))
    {
        punk = (IUnknown*) (IRemoteComputer*) this;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    *ppvObj = punk;
    punk->AddRef();

    return S_OK;
}




//____________________________________________________________________________
//
//  Member:     CJobFolder::IRemoteComputer::Initialize
//
//  Synopsis:   This method is called when the explorer is initializing or
//              enumerating the name space extension. If failure is returned
//              during enumeration, the extension won't appear for this
//              computer. Otherwise, the extension will appear, and should
//              target the given machine.
//
//  Arguments:  [pwszMachine]  -- IN Specifies the name of the machine to target.
//              [bEnumerating] -- IN
//
//  Returns:    HRESULT.
//
//  History:    2/21/1996   RaviR   Created
//
//____________________________________________________________________________

STDMETHODIMP
CJobFolder::Initialize(
    LPCWSTR  pwszMachine,
    BOOL    bEnumerating)
{
    DEBUG_OUT((DEB_USER12,
               "CJobFolder::IRemoteComputer::Initialize<%ws>\n",
               pwszMachine));

    HRESULT hr = S_OK;
    LPTSTR ptszMachine = NULL;

    do
    {
        if (!pwszMachine)
        {
            hr = E_INVALIDARG;
            CHECK_HRESULT(hr);
            break;
        }

        //
        // Make a copy of the machine name.
        //

#ifdef UNICODE
        ptszMachine = NewDupString(pwszMachine);

        if (!ptszMachine)
        {
            hr = E_OUTOFMEMORY;
            CHECK_HRESULT(hr);
            break;
        }
#else
        ULONG cbMachine = 1 + 2 * wcslen(pwszMachine);

        ptszMachine = new CHAR[cbMachine];

        if (!ptszMachine)
        {
            hr = E_OUTOFMEMORY;
            CHECK_HRESULT(hr);
            break;
        }

        hr = UnicodeToAnsi(ptszMachine, pwszMachine, cbMachine);

        if (FAILED(hr))
        {
            CHECK_HRESULT(hr);
            break;
        }
#endif // UNICODE
		//
		// The first thing about showing a remote folder is it must be
		// a MS network or else the RegConnectregistry time out will 
		// take at least 20 seconds and there won't even be a MSTask
		// on the machine.

		if( !IsMsNetwork( ptszMachine ) )
		{
			return E_FAIL;
		}


        //
        // We only want to show the remote jobs folder if the user has
        // administrative access to that machine, and the task scheduler
        // is installed there.
        //
        // Test both at once by trying to get a full access handle to
        // the remote machine's task scheduler reg key.
        //

        if (bEnumerating)
        {
            //
            // Check if the schedule service is registered on pwszMachine.
            //

            long    lr = ERROR_SUCCESS;
            HKEY    hRemoteKey = NULL;
            HKEY    hSchedKey = NULL;

            lr = RegConnectRegistry(ptszMachine,
                                    HKEY_LOCAL_MACHINE,
                                    &hRemoteKey);
            CHECK_LASTERROR(lr);

            if (lr == ERROR_SUCCESS)
            {
                lr = RegOpenKeyEx(hRemoteKey,
                                  SCH_AGENT_KEY,
                                  0,
                                  KEY_ALL_ACCESS,
                                  &hSchedKey);
                CHECK_LASTERROR(lr);
            }

            if (hRemoteKey != NULL)
            {
                RegCloseKey(hRemoteKey);
            }

            if (hSchedKey != NULL)
            {
                RegCloseKey(hSchedKey);
            }

            if (lr != ERROR_SUCCESS)
            {
                hr = HRESULT_FROM_WIN32(lr);
                break;
            }
        }

        //
        // Success; remember the machine name.
        //

        m_pszMachine = ptszMachine;
    } while (0);

    if (FAILED(hr))
    {
        delete [] ptszMachine;
    }

    return hr;
}

//____________________________________________________________________________
//
//
//	Support function:	MsNetwork
//
//	Synopsis:			Resolves whether or not we're attempting to connect to
//						a MS network
//
//	History:			11/12/00	DGrube	Created
//
//
//____________________________________________________________________________

BOOL IsMsNetwork( LPTSTR ptszMachine )
{
    DWORD          dwError;
    NETRESOURCE    nr;
    NETRESOURCE    nrOut;
    LPTSTR         pszSystem = NULL;          // pointer to variable-length strings
    NETRESOURCE*   lpBuffer = &nrOut;        // buffer
    DWORD          cbResult  = sizeof(nrOut); // buffer size
	BOOL		   bReturn = TRUE;

    //
    // Fill a block of memory with zeroes; then 
    //  initialize the NETRESOURCE structure. 
    //
    ZeroMemory(&nr, sizeof(nr));

    nr.dwScope       = RESOURCE_GLOBALNET;
    nr.dwType        = RESOURCETYPE_ANY;
    nr.lpRemoteName  = ptszMachine;

    //
    // First call the WNetGetResourceInformation function with 
    //  memory allocated to hold only a NETRESOURCE structure. This 
    //  method can succeed if all the NETRESOURCE pointers are NULL.
    //
    dwError = WNetGetResourceInformation(&nr, lpBuffer, &cbResult, &pszSystem);

    //
    // If the call fails because the buffer is too small, 
    //   call the LocalAlloc function to allocate a larger buffer.
    //
    if (dwError == ERROR_MORE_DATA)
    {
        lpBuffer = (NETRESOURCE*) LocalAlloc(LMEM_FIXED, cbResult);

        if (lpBuffer == NULL)
        {
			CHECK_LASTERROR(GetLastError());
			return FALSE;
        }
    }


    //
    // Call WNetGetResourceInformation again
    //  with the larger buffer.
    //

    dwError = WNetGetResourceInformation(&nr, lpBuffer, &cbResult, &pszSystem);

    if (dwError == NO_ERROR)
    {
        // If the call succeeds, process the contents of the 
        //  returned NETRESOURCE structure and the variable-length
        //  strings in lpBuffer. Then free the memory.
        //
        if ( NULL != lpBuffer->lpProvider )
        {
			NETINFOSTRUCT NetInfo;

			NetInfo.cbStructure = sizeof( NetInfo );
			DWORD dwReturn = WNetGetNetworkInformation( lpBuffer->lpProvider, &NetInfo );

			//
			// Need to shift 16 bits for masks below because their a DWORD starting at the
			// 16th bit and wNetType is a word starting at 0
			//
			if ( !( ( NetInfo.wNetType == ( WNNC_NET_MSNET >> 16)) || 
				( NetInfo.wNetType == ( WNNC_NET_LANMAN >>16) ) ) )
			{
				bReturn = FALSE;
			}
	    }
		else
		{
			CHECK_LASTERROR(GetLastError());
			bReturn = FALSE;
		}
    }
	else
	{
		CHECK_LASTERROR(GetLastError());
		bReturn = FALSE;
	}

	if( NULL != lpBuffer )
	{
		LocalFree( lpBuffer );
	}

    return bReturn;
}


//____________________________________________________________________________
//
//  Member:     CJobFolder::IPersistFolder::Initialize
//
//  Synopsis:   same as IPersistFolder::Initialize
//
//  History:    1/31/1996   RaviR   Created
//____________________________________________________________________________

STDMETHODIMP
CJobFolder::Initialize(
    LPCITEMIDLIST pidl)
{
    TRACE(CJobFolder, IPersistFolder::Initialize);

    m_pidlFldr = ILClone(pidl);

    if (NULL == m_pidlFldr)
    {
        CHECK_HRESULT(E_OUTOFMEMORY);

        return E_OUTOFMEMORY;
    }

    // NOTE: if this is being invoked remotely, we assume that IRemoteComputer
    // is invoked *before* IPersistFolder.

    return S_OK;
}


//____________________________________________________________________________
//
//  Member:     CJobFolder::GetClassID
//
//  Synopsis:   same as IPersistFolder::GetClassID
//
//  History:    1/31/1996   RaviR   Created
//____________________________________________________________________________

STDMETHODIMP
CJobFolder::GetClassID(
    LPCLSID lpClassID)
{
    TRACE(CJobFolder, GetClassID);

    *lpClassID = CLSID_CJobFolder;

    return S_OK;
}



#if (_WIN32_IE >= 0x0400)

//+--------------------------------------------------------------------------
//
//  Member:     CJobFolder::IPersistFolder2::GetCurFolder
//
//  Synopsis:   Return a copy of the item id list for the current folder.
//
//  Arguments:  [ppidl] - filled with copy of pidl, or NULL on error.
//
//  Returns:    S_OK or E_OUTOFMEMORY
//
//  Modifies:   *[ppidl]
//
//  History:    12-04-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CJobFolder::GetCurFolder(
    LPITEMIDLIST *ppidl)
{
    TRACE(CJobFolder, GetCurFolder);

    *ppidl = ILClone(m_pidlFldr);

    if (NULL == *ppidl)
    {
        CHECK_HRESULT(E_OUTOFMEMORY);

        return E_OUTOFMEMORY;
    }

    // NOTE: if this is being invoked remotely, we assume that IRemoteComputer
    // is invoked *before* IPersistFolder2.

    return S_OK;
}

#endif // (_WIN32_IE >= 0x0400)



//____________________________________________________________________________
//____________________________________________________________________________
//________________                         ___________________________________
//________________  Interface IDropTarget  ___________________________________
//________________                         ___________________________________
//____________________________________________________________________________
//____________________________________________________________________________

//____________________________________________________________________________
//
//  Member:     CJobFolder::DragEnter
//
//  Synopsis:   same as IDropTarget::DragEnter
//
//  History:    1/31/1996   RaviR   Created
//____________________________________________________________________________

HRESULT
CJobFolder::DragEnter(
    LPDATAOBJECT pdtobj,
    DWORD grfKeyState,
    POINTL pt,
    DWORD *pdwEffect)
{
    DEBUG_OUT((DEB_TRACE, "CJobFolder::DragEnter<%x, dwEffect=%x>\n",
                                                        this, *pdwEffect));
    m_grfKeyStateLast = grfKeyState;

    *pdwEffect = DROPEFFECT_NONE;

    //
    // Policy - if key TS_KEYPOLICY_DENY_DRAGDROP or DENY_CREATE_TASK
    // then we won't allow this
    //

    if (RegReadPolicyKey(TS_KEYPOLICY_DENY_DRAGDROP) ||
        RegReadPolicyKey(TS_KEYPOLICY_DENY_CREATE_TASK))
    {
        DEBUG_OUT((DEB_ITRACE, "Policy CREATE_TASK or DRAGDROP active - no copy operations\n"));

        return S_OK;
    }

    if (pdtobj != NULL)
    {
        LPENUMFORMATETC penum;
        HRESULT         hr;

        pdtobj->AddRef();

        hr = pdtobj->EnumFormatEtc(DATADIR_GET, &penum);

        if (SUCCEEDED(hr))
        {
            FORMATETC fmte;
            ULONG     celt;

            while (penum->Next(1, &fmte, &celt) == S_OK)
            {
                if (fmte.cfFormat == CF_HDROP && (fmte.tymed & TYMED_HGLOBAL))
                {
                    // The default action is to MOVE the object. If the user
                    // has the CONTROL key pressed, then the operation
                    // becomes a copy

                    *pdwEffect = DROPEFFECT_MOVE;

                    if (grfKeyState & MK_CONTROL)
                    {
                        *pdwEffect = DROPEFFECT_COPY;
                    }

                    break;
                }
            }

            penum->Release();
        }

        pdtobj->Release();
    }

    return S_OK;
}


//____________________________________________________________________________
//
//  Member:     CJobFolder::DragOver
//
//  Synopsis:   same as IDropTarget::DragOver
//
//  History:    1/31/1996   RaviR   Created
//____________________________________________________________________________

HRESULT
CJobFolder::DragOver(
    DWORD grfKeyState,
    POINTL pt,
    DWORD *pdwEffect)
{
    DEBUG_OUT((DEB_TRACE, "CJobFolder::DragOver<%x, dwEffect=%d>\n",
                                                        this, *pdwEffect));


    *pdwEffect = DROPEFFECT_NONE;

    //
    // Policy - if we cannot create a task, or have no drag-drop, deny
    // the request
    //

    if (RegReadPolicyKey(TS_KEYPOLICY_DENY_DRAGDROP) ||
        RegReadPolicyKey(TS_KEYPOLICY_DENY_CREATE_TASK))
    {
        DEBUG_OUT((DEB_ITRACE, "Policy CREATE_TASK or DRAGDROP active - no copy operations\n"));

        return S_OK;
    }

    *pdwEffect = DROPEFFECT_MOVE;

    if (grfKeyState & MK_CONTROL)
    {
        *pdwEffect = DROPEFFECT_COPY;
    }

    return S_OK;
}

//____________________________________________________________________________
//
//  Member:     CJobFolder::DragLeave
//
//  Synopsis:   same as IDropTarget::DragLeave
//
//  History:    1/31/1996   RaviR   Created
//____________________________________________________________________________

HRESULT
CJobFolder::DragLeave(void)
{
    TRACE(CJobFolder, DragLeave);

    return S_OK;    // Don't need to do anything here...
}



//____________________________________________________________________________
//
//  Member:     CJobFolder::CopyToFolder
//
//  Synopsis:   Performs copy of a job obect passed in to this folder
//
//  Notes:      If policy prevents a copy into this folder, this will
//              return E_FAIL.  Callers should check this if necessary.
//
//  History:    1/31/1996   RaviR     Created
//              4/23/1998   CameronE  Modified for policy
//____________________________________________________________________________

HRESULT
CJobFolder::CopyToFolder(
    LPDATAOBJECT    pdtobj,
    BOOL            fMove,
    BOOL            fDragDrop,  // TRUE if called as a result of a dd op.
    POINTL        * pPtl)        // Valid for a dd op.
{
    DEBUG_OUT((DEB_USER12, "CJobFolder::CopyToFolder <<----\n"));

    //
    // Policy - no copying into the folder if DENY_CREATE_TASK is on
    //        - no copying via dragdrop, either, if DENY_DRAGDROP is on
    //

    if (RegReadPolicyKey(TS_KEYPOLICY_DENY_CREATE_TASK) ||
        (fDragDrop && RegReadPolicyKey(TS_KEYPOLICY_DENY_DRAGDROP)))
    {
        DEBUG_OUT((DEB_ITRACE, "Policy CREATE_TASK or DRAGDROP active - no copy operations\n"));
        return E_FAIL;
    }

    BOOL fIsDropOnSrc = ShellFolderView_IsDropOnSource(m_hwndOwner,
                                                       (IDropTarget*)this);

    STGMEDIUM medium;
    FORMATETC fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

    HRESULT hr = pdtobj->GetData(&fmte, &medium);

    if (FAILED(hr))
    {
        return hr;
    }

    HDROP   hdrop = (HDROP)medium.hGlobal;
    UINT    cFiles = DragQueryFile(hdrop, (UINT)-1, NULL, 0);
    BYTE  * rglen = NULL;
    LPTSTR  pFrom = NULL;
    UINT    i;
    BOOL    fCreatedJob = FALSE;

    do
    {
        TCHAR   szFileFrom[MAX_PATH+1];
        UINT    cchFileFrom = ARRAYSIZE(szFileFrom);
        BOOL    fHasASchedObj = fIsDropOnSrc;

        if (fHasASchedObj == FALSE)
        {
            for (i = 0; i < cFiles; i++)
            {
                DragQueryFile(hdrop, i, szFileFrom, cchFileFrom);

                if (IsAScheduleObject(szFileFrom) == TRUE)
                {
                    fHasASchedObj = TRUE;
                    break;
                }
            }
        }

        if ((fDragDrop == TRUE) &&
            (m_grfKeyStateLast & MK_RBUTTON) &&
            (fHasASchedObj == TRUE))
        {
            if (_PopupRBMoveCtx(pPtl->x, pPtl->y, &fMove) == FALSE)
            {
                hr = S_FALSE;
                break;
            }
        }

        if ((fIsDropOnSrc == TRUE) && (fMove == TRUE))
        {
            // We don't handle positioning in the jobs folder.
            hr = S_FALSE;
            break;
        }

        //
        //  Prepare to copy jobs.
        //

        if (fHasASchedObj == TRUE)
        {
            rglen = new BYTE[cFiles];

            if (rglen == NULL)
            {
                hr = E_OUTOFMEMORY;
                CHECK_HRESULT(hr);
                break;
            }

            ZeroMemory(rglen, cFiles * sizeof(BYTE));
        }

        UINT cchReqd = 1; // for an extra null char

        for (i = 0; i < cFiles; i++)
        {
            DragQueryFile(hdrop, i, szFileFrom, cchFileFrom);

            if ((fIsDropOnSrc == FALSE) &&
                (IsAScheduleObject(szFileFrom) == FALSE))
            {
                hr = CreateAJobForApp(szFileFrom);
                CHECK_HRESULT(hr);

                if (SUCCEEDED(hr))
                {
                    fCreatedJob = TRUE;
                }

                // continue even if an error occurs
                continue;
            }

            if (fHasASchedObj == TRUE)
            {
                rglen[i] = lstrlen(szFileFrom) + 1;
                cchReqd += rglen[i];
            }
        }

        hr = S_OK; // reset CreateAJobForApp might have failed

        if (fHasASchedObj == FALSE)
        {
            break;
        }

        pFrom = new TCHAR[cchReqd];

        if (pFrom == NULL)
        {
            hr = E_OUTOFMEMORY;
            CHECK_HRESULT(hr);
            break;
        }

        LPTSTR pszTemp = pFrom;

        for (i = 0; i < cFiles; i++)
        {
            if (rglen[i])
            {
                DragQueryFile(hdrop, i, szFileFrom, cchFileFrom);

                CopyMemory(pszTemp, szFileFrom, rglen[i] * sizeof(TCHAR));

                pszTemp += rglen[i];
            }
        }

        // add extra null char
        *pszTemp = TEXT('\0');

        SHFILEOPSTRUCT fo = {m_hwndOwner, (fMove ? FO_MOVE : FO_COPY),
                pFrom, m_pszFolderPath,
                FOF_ALLOWUNDO | (fIsDropOnSrc ? FOF_RENAMEONCOLLISION : 0),
                FALSE, NULL, NULL};

        if (SHFileOperation(&fo) || fo.fAnyOperationsAborted)
        {
            hr = E_FAIL;
            CHECK_HRESULT(hr);
            BREAK_ON_FAIL(hr);
        }

        fCreatedJob = TRUE;

        //
        //  If the drop was on the job folder shortcut, there is nothing
        //  else to do here.
        //

        if (m_hwndOwner == NULL || m_pShellView == NULL)
        {
            break;
        }

        //
        // If fIsDropOnSource then this was a copy operation from the source
        // (if it was a move operation we would've already returned), the
        // SHFileOperation has done the rename work for us and will
        // create the files.
        //
        // That will produce a SHCNE_CREATE message for each dropped renamed &
        // copied file.  CJobFolder::HandleFsNotify will then do an _AddObject
        // to put them in the UI.
        //
        // So in this case we need to leave before adding a bogus copy
        // ourselves.
        //

        if (fIsDropOnSrc == TRUE)
        {
            break;
        }

        //
        //  Add these items to the foldr & select them.
        //

        LPITEMIDLIST pidl;
        CJobID jid;

        // First deselect any selected items

        LPITEMIDLIST * ppidl;

        hr = (HRESULT)ShellFolderView_GetSelectedObjects(m_hwndOwner, &ppidl);

        if (SUCCEEDED(hr))
        {
            i = ShortFromResult(hr);

            while (i--)
            {
                m_pShellView->SelectItem(ppidl[i], SVSI_DESELECT);
            }

            LocalFree(ppidl);
        }


        for (i = 0; i < cFiles; i++)
        {
            if (rglen[i])
            {
                DragQueryFile(hdrop, i, szFileFrom, cchFileFrom);

                LPTSTR pszName = PathFindFileName(szFileFrom);

                //
                // If a move or copy operation includes objects which collide
                // with objects already in the folder, we need to avoid
                // creating a bogus duplicate in the UI for those objects.
                //

                if (_ObjectAlreadyPresent(pszName))
                {
                    continue;
                }

                hr = jid.Load(m_pszFolderPath, pszName);

                BREAK_ON_FAIL(hr);

                hr = _AddObject(&jid, &pidl);

                BREAK_ON_FAIL(hr);

                m_pShellView->SelectItem(pidl, SVSI_SELECT);
            }
        }

        BREAK_ON_FAIL(hr);

    } while (0);

    if (FAILED(hr))
    {
        MessageBeep(MB_ICONHAND);
    }
    else if (fCreatedJob)
    {
        //
        // If the drag/drop operation resulted in a new task being added
        // to the tasks folder, prompt the user to start the service
        // if it isn't already running.
        //

        if (UserCanChangeService(m_pszMachine))
        {
            PromptForServiceStart(m_hwndOwner);
        }
    }

    // clean up
    delete pFrom;
    delete rglen;
    ReleaseStgMedium(&medium);

    return S_OK;    // Don't need to do anything here...
}

//____________________________________________________________________________
//
//  Member:     CJobFolder::Drop
//
//  Synopsis:   same as IDropTarget::Drop
//
//  History:    1/31/1996   RaviR   Created
//____________________________________________________________________________

HRESULT
CJobFolder::Drop(
    LPDATAOBJECT pdtobj,
    DWORD grfKeyState,
    POINTL ptl,
    DWORD *pdwEffect)
{
    DEBUG_OUT((DEB_USER1, "CJobFolder::Drop <<----\n"));

    *pdwEffect = DROPEFFECT_NONE;

    //
    // Policy - we should never get here, since we disabled
    // it in DragEnter and DragOver, but just in case
    //

    if (RegReadPolicyKey(TS_KEYPOLICY_DENY_CREATE_TASK) ||
        RegReadPolicyKey(TS_KEYPOLICY_DENY_DRAGDROP))
    {
        return S_OK;
    }

    BOOL fMove = !(grfKeyState & MK_CONTROL);

    DEBUG_OUT((DEB_USER12, "CJobFolder::Drop <%s>\n", fMove ? "Move" : "Copy"));

    return CopyToFolder(pdtobj, fMove, TRUE, &ptl);
}



BOOL
CJobFolder::_PopupRBMoveCtx(
    LONG    x,
    LONG    y,
    BOOL  * pfMove)
{
    DEBUG_OUT((DEB_USER1, "CJobFolder::_PopupRBMoveCtx\n"));

    const TCHAR c_szStatic[] = TEXT("Static");
    int iRet = FALSE;

    HWND hwndDummy = CreateWindow(c_szStatic, NULL, 0, x, y, 1, 1,
                                m_hwndOwner, // HWND_DESKTOP,
                                NULL, g_hInstance, NULL);
    if (hwndDummy)
    {
        HWND hwndPrev = GetForegroundWindow();  // to restore
        UINT uFlags = TPM_RETURNCMD | TPM_RIGHTBUTTON | TPM_LEFTALIGN;

        HMENU   popup;
        HMENU   subpopup;

        popup = LoadMenu(g_hInstance, MAKEINTRESOURCE(POPUP_RBUTTON_MOVE));
        subpopup = GetSubMenu(popup, 0);

        SetForegroundWindow(hwndDummy);
        SetFocus(hwndDummy);
        iRet = TrackPopupMenu(subpopup, uFlags, x, y, 0, hwndDummy, NULL);

        DestroyMenu(popup);

        if (iRet)
        {
            // non-cancel item is selected. Make the hwndOwner foreground.
            SetForegroundWindow(m_hwndOwner);
            SetFocus(m_hwndOwner);
        }
        else
        {
            //
            // The user canceled the menu. Restore the previous foreground
            // window (before destroying hwndDummy).
            //

            if (hwndPrev)
            {
                SetForegroundWindow(hwndPrev);
            }
        }

        DestroyWindow(hwndDummy);
    }

    switch (iRet)
    {
    case DDIDM_MOVE:
        *pfMove = TRUE;
        return TRUE;

    case DDIDM_COPY:
        *pfMove = FALSE;
        return TRUE;

    case 0:
    default:
        return FALSE;
    }
}


//____________________________________________________________________________
//
//  Member:     CJobFolder::CreateAJobForApp
//
//  Synopsis:   Creates a job for the given app.
//              If (pszApp != 0) job name <- app name with ext changed to job
//              Else job name <- "New Job.job", with rename.
//
//  Arguments:  [pszApp] -- IN
//
//  Returns:    HRESULT
//              --- E_FAIL if policy is on preventing creation.  Callers
//                  should check this if are contingent on a job being made.
//
//  History:    4/4/1996   RaviR   Created
//
//____________________________________________________________________________

HRESULT
CJobFolder::CreateAJobForApp(
    LPCTSTR pszApp)
{
    HRESULT     hr = S_OK;

    //
    // Policy - if we have the regkey DENY_CREATE_TASK active
    // we cannot permit new jobs to be created via the ui
    //

    if (RegReadPolicyKey(TS_KEYPOLICY_DENY_CREATE_TASK))
    {
        DEBUG_OUT((DEB_ITRACE, "Policy CREATE_TASK active - no drag-drop or copy/cut/paste\n"));
        return E_FAIL;
    }

    CJob * pCJob = CJob::Create();

    if (pCJob == NULL)
    {
        hr = E_OUTOFMEMORY;
        CHECK_HRESULT(hr);
        return hr;
    }

#ifndef UNICODE
    WCHAR wcBuf[MAX_PATH];
#endif

    do
    {
        DWORD dwAddFlags = TASK_FLAG_DONT_START_IF_ON_BATTERIES |
                           TASK_FLAG_KILL_IF_GOING_ON_BATTERIES;

        hr = pCJob->SetFlags(dwAddFlags);

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

        //
        // Create and set a default trigger for ever day at 9:00 AM, with
        // no repetition.
        //

        TASK_TRIGGER jt;
        SYSTEMTIME   stNow;

        GetSystemTime(&stNow);

        ZeroMemory(&jt, sizeof(jt));

        jt.cbTriggerSize = sizeof(jt);
        jt.wBeginYear = stNow.wYear;
        jt.wBeginMonth = stNow.wMonth;
        jt.wBeginDay = stNow.wDay;
        jt.TriggerType = TASK_TIME_TRIGGER_DAILY;
        jt.Type.Daily.DaysInterval = 1;
        jt.wStartHour = 9;
        jt.wStartMinute = 0;
        jt.rgFlags = 0;

        ITaskTrigger  * pTrigger = NULL;
        WORD            iTrigger = (WORD)-1;

        hr = pCJob->CreateTrigger(&iTrigger, &pTrigger);

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

        hr = pTrigger->SetTrigger((const PTASK_TRIGGER)&jt);

        pTrigger->Release();

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);


        TCHAR szJob[MAX_PATH+12];

        lstrcpy(szJob, m_pszFolderPath);
        lstrcat(szJob, TEXT("\\"));

        if (pszApp != NULL)
        {
            // set the app name

#ifdef UNICODE
            hr = pCJob->SetApplicationName(pszApp);
#else
            hr = AnsiToUnicode(wcBuf, pszApp, MAX_PATH);
            CHECK_HRESULT(hr);
            BREAK_ON_FAIL(hr);

            hr = pCJob->SetApplicationName(wcBuf);
#endif

            CHECK_HRESULT(hr);
            BREAK_ON_FAIL(hr);

            // the job name ...

            lstrcat(szJob, PathFindFileName(pszApp));

            LPTSTR pszExt = PathFindExtension(szJob);
            lstrcpy(pszExt, TSZ_DOTJOB);
        }
        else
        {
            UINT len = lstrlen(szJob);

            static int s_nLengthOK = -1;

            if (s_nLengthOK == -1)
            {
                UINT uiTemp = (UINT)LoadString(g_hInstance, IDS_NEW_JOB,
                                         &szJob[len], (MAX_PATH + 12 - len));

                uiTemp += len;

                if (uiTemp <= MAX_PATH)
                {
                    s_nLengthOK = 1;
                }
                else
                {
                    s_nLengthOK = 0;
                }
            }

            if (s_nLengthOK == 0)
            {
                hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
                CHECK_HRESULT(hr);
                break;
            }

            LoadString(g_hInstance, IDS_NEW_JOB,
                                        &szJob[len], (MAX_PATH - len));

            EnsureUniquenessOfFileName(szJob);

            if (lstrlen(szJob) > MAX_PATH)
            {
                hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
                CHECK_HRESULT(hr);
                break;
            }
        }

#ifdef UNICODE
        hr = pCJob->Save(szJob, FALSE);
#else
        hr = AnsiToUnicode(wcBuf, szJob, MAX_PATH);
        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

        hr = pCJob->Save(wcBuf, FALSE);
#endif

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

        //
        //  If the drop was on the job folder shortcut, there is nothing
        //  else to do here.
        //

        if (m_hwndOwner == NULL || m_pShellView == NULL)
        {
            break;
        }

        //
        // Add the job to the job folder
        //

        CJobID jid;

        LPTSTR pszJobName = &szJob[lstrlen(m_pszFolderPath)+1];

        //*(pszJobName - 1) = TEXT('\0');

        hr = jid.Load(m_pszFolderPath, pszJobName);
        BREAK_ON_FAIL(hr);

        hr = _AddObject(&jid);
        BREAK_ON_FAIL(hr);

        //
        //  If this is a new task prompt the user for rename
        //

        if (pszApp == NULL)
        {
            //
            // Prompt the user to rename the new job.
            //

            if (m_pShellView != NULL)
            {
                hr = m_pShellView->SelectItem(((LPCITEMIDLIST)&jid), SVSI_EDIT);

                CHECK_HRESULT(hr);
            }
        }

        //BREAK_ON_FAIL(hr);

    } while (0);

    if (pCJob != NULL)
    {
        pCJob->Release();
    }

    return hr;
}


int
CJobFolder::_GetJobIDForTask(
    PJOBID *ppjid,
    int     count,
    LPTSTR  pszTask)
{
    LPTSTR pszExt = PathFindExtension(pszTask);
    TCHAR tcSave;

    if (pszExt)
    {
        tcSave = *pszExt;
        *pszExt = TEXT('\0');
    }

    //
    // If the folder is empty, count is 0, so initialize iCmp to -1
    // to force the return statement to indicate there was no match.
    //

    int iCmp = -1;

    for (int i=0; i < count; i++)
    {
#if (DBG == 1)
        ppjid[i]->Validate();
#endif // (DBG == 1)

        //
        // Don't compare template (virtual) objects against real files.
        //

        if (ppjid[i]->IsTemplate())
        {
            continue;
        }

        iCmp = lstrcmpi(ppjid[i]->GetName(), pszTask);

        if (iCmp >= 0)
        {
            break;
        }
    }

    if (pszExt)
    {
        *pszExt = tcSave;
    }

    return (iCmp == 0) ? i : -1;
}


void hsort(PJOBID *ppjid, UINT cObjs);

void I_Sort(PJOBID * ppjid, UINT cObjs)
{
    UINT i;

#if (DBG == 1)
    for (i=0; i < cObjs; i++)
    {
        ppjid[i]->Validate();
    }
#endif // (DBG == 1)

    if (cObjs < 10)
    {
        UINT k = 0;
        PJOBID pjid;

        for (i=1; i < cObjs; i++)
        {
            for (k=i;
             k && (lstrcmpi(ppjid[k]->GetName(), ppjid[k-1]->GetName()) < 0);
                 --k)
            {
                pjid = ppjid[k];
                ppjid[k] = ppjid[k-1];
                ppjid[k-1] = pjid;
            }
        }
    }
    else
    {
        // Heap sort
        hsort(ppjid, cObjs);
    }

#if (DBG == 1)
    for (i=0; i < cObjs; i++)
    {
        ppjid[i]->Validate();
    }
#endif // (DBG == 1)
}


//____________________________________________________________________________
//
//  Member:     CJobFolder::OnUpdateDir
//
//  Synopsis:   S
//
//  Returns:    void
//
//  History:    2/20/1996   RaviR   Created
//
//____________________________________________________________________________

void
CJobFolder::OnUpdateDir(void)
{
    DEBUG_OUT((DEB_USER1, "CJobFolder::OnUpdateDir <<--\n"));

    HRESULT hr = S_OK;

    //
    // First collect all the itemids from the LPSHELLVIEW
    //

    int cObjs = (int) ShellFolderView_GetObjectCount(m_hwndOwner);

    if (m_cObjsAlloced < cObjs)
    {
        // 40 so that it is DWORD aligned

        m_cObjsAlloced = ((cObjs / 40) + 1) * 40;

        //
        // Allocate an extra byte per jobid to use with pbPresent flag
        // array.  (See below.)
        //

        DWORD dwBytes = m_cObjsAlloced * (sizeof(PJOBID) + 1);

        if (m_pUpdateDirData == NULL)
        {
            m_pUpdateDirData = (BYTE *)GlobalAlloc(GPTR, dwBytes);
        }
        else
        {

            BYTE * pbTemp = (BYTE *)GlobalReAlloc(m_pUpdateDirData,
                                                     dwBytes, GHND);

            if (pbTemp)
            {
                m_pUpdateDirData = pbTemp;
            }
            else
            {
                GlobalFree(m_pUpdateDirData);
                m_pUpdateDirData = NULL;
            }
        }

        if (m_pUpdateDirData == NULL)
        {
            hr = E_OUTOFMEMORY;
            CHECK_HRESULT(hr);

            m_cObjsAlloced = 0;

            return;
        }
    }

    PJOBID *ppjid = (PJOBID *)m_pUpdateDirData;
    PBYTE   pbPresent = m_pUpdateDirData + m_cObjsAlloced * sizeof(PJOBID);

    ZeroMemory(pbPresent, m_cObjsAlloced * sizeof(BYTE));

    for (int i=0; i < cObjs; i++)
    {
        ppjid[i] = (PJOBID)ShellFolderView_GetObject(m_hwndOwner, i);
#if (DBG == 1)
        ppjid[i]->Validate();
#endif
    }

    I_Sort(ppjid, cObjs);

    //
    //
    //

    TCHAR szSearchPath[MAX_PATH] = TEXT("");
    lstrcpy(szSearchPath, m_pszFolderPath);
    lstrcat(szSearchPath, TEXT("\\*") TSZ_DOTJOB);

    WIN32_FIND_DATA fd;
    HANDLE hFind = FindFirstFile(szSearchPath, &fd);

    int index;

    if (hFind != INVALID_HANDLE_VALUE)
    {
        CJobID jid;

        while (1)
        {
            index = _GetJobIDForTask(ppjid, cObjs, fd.cFileName);

            if (index < 0)
            {
                // Add item

                hr = jid.Load(m_pszFolderPath, fd.cFileName);

                if (hr == S_OK)
                {
                    hr = _AddObject(&jid);
                }
            }
            else
            {
                if (CompareFileTime(&fd.ftCreationTime,
                                    &ppjid[index]->_ftCreation) ||
                    CompareFileTime(&fd.ftLastWriteTime,
                                    &ppjid[index]->_ftLastWrite))
                {
                    // update job
                    DEBUG_OUT((DEB_USER12, "OnUpdateDir::UPDATE_ITEM<%ws>\n",
                                                        fd.cFileName));

                    hr = jid.Load(m_pszFolderPath, fd.cFileName);

                    if (hr == S_OK)
                    {
                        LPITEMIDLIST pidl;

                        hr = _UpdateObject(&jid, &jid, &pidl);

                        if (SUCCEEDED(hr))
                        {
                            ppjid[index] = (PJOBID)pidl;
                        }

                        // mark as present
                        pbPresent[index] = 1;
                    }
                }
                else
                {
                    // mark as present
                    pbPresent[index] = 1;
                }
            }

            //
            // Let us continue even on failure unless it is a memory error
            //

            if (hr == E_OUTOFMEMORY)
            {
                break;
            }

            //
            //  Get the next file.
            //

            if (FindNextFile(hFind, &fd) == FALSE)
            {
                if (GetLastError() != ERROR_NO_MORE_FILES)
                {
                    CHECK_LASTERROR(GetLastError());
                }

                break;
            }
        }

        FindClose(hFind);

        //
        // Let us continue even on failure unless it is a memory error
        //

        if (hr != E_OUTOFMEMORY)
        {
            //
            // Now delete any old items that are no longer valid, making
            // sure to ignore the template object.
            //

            for (i=0; i < cObjs; i++)
            {
                if (!pbPresent[i] && !ppjid[i]->IsTemplate())
                {
                    // Delete object
                    _RemoveObject(ppjid[i]);
                }
            }
        }
    }
    else
    {
        if (GetLastError() != ERROR_FILE_NOT_FOUND)
        {
            CHECK_LASTERROR(GetLastError());
        }
        else if (GetLastError() != ERROR_NO_MORE_FILES)
        {
            // delete everything but template objects

            for (i=0; i < cObjs; i++)
            {
                if (!ppjid[i]->IsTemplate())
                {
                    _RemoveObject(ppjid[i]);
                }
            }
        }
    }

    if (hr == E_OUTOFMEMORY)
    {
        // Display error message
    }

    DEBUG_OUT((DEB_USER1, "CJobFolder::OnUpdateDir -->>\n"));

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\folderui\jobidl.cxx ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       jobidl.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  Notes:      For the first release of the scheduling agent, all security
//              operations are disabled under Win95, even Win95 to NT.
//
//  History:    1/24/1996   RaviR   Created
//
//____________________________________________________________________________

#include "..\pch\headers.hxx"
#pragma hdrstop

#include "dbg.h"
#include "macros.h"
#include "..\inc\resource.h"
#include "resource.h"
#include "..\wizard\resource.h"
#include "..\inc\common.hxx"

#include "jobidl.hxx"
#include "sch_cls.hxx"  // sched\inc
#include "job_cls.hxx"  // sched\inc
#include "misc.hxx"     // sched\inc
#include "util.hxx"
#include "..\schedui\schedui.hxx"

#if !defined(_CHICAGO_)
void
SecurityErrorDialog(
    HWND    hWndOwner,
    HRESULT hr);
#endif // !defined(_CHICAGO_)


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
////////
////////    CJobID class implementation
////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

//+--------------------------------------------------------------------------
//
//  Member:     CJobID::InitToTemplate
//
//  Synopsis:   Inititialize this to represent a template object in the
//              folder.
//
//  History:    05-15-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CJobID::InitToTemplate()
{
    _id = ID_TEMPLATE;

    //
    // Name offset is at 1 so the first char can serve to make empty app
    // name, creator, and path strings.
    //

    _oCreator = 0;
    _oPath = 0;
    _oName = 1;

    LoadString(g_hInstance,
               IDS_TEMPLATE_NAME,
               &_cBuf[_oName],
               IDJOB_BUFFER_SIZE - 3);
    _cb = offsetof(CJobID, _cBuf) +
              (_oName + lstrlen(&_cBuf[_oName]) + 1) * sizeof(TCHAR);
             // ^^^ pidl size has to include offset into _cBuf

    _NullTerminate();
}


//____________________________________________________________________________
//
//  Member:     CJobID::Load
//
//  Arguments:  [pszFolderPath] -- IN
//              [pszJob] -- IN
//
//  Returns:    HRESULT.
//____________________________________________________________________________

HRESULT
CJobID::Load(
    LPCTSTR     pszFolderPath,
    LPTSTR      pszJob) // job path relative to Jobs folder with .job extension
{
    DEBUG_OUT((DEB_USER12,
              "[CJobID::Load] <%ws, %ws>\n",
              pszFolderPath ? (LPWSTR)pszFolderPath : L"NULL FolderPath",
              pszJob));

#if DBG==1
TCHAR * pExt = PathFindExtension(pszJob);
Win4Assert(lstrcmpi(pExt, TSZ_DOTJOB) == 0);
#endif

    HRESULT     hr = S_OK;
    CJob       *pJob = NULL;

    ZeroMemory(this, sizeof(CJobID));

    do
    {
        //
        //  Set creation & last write times
        //

        TCHAR   tcFile[MAX_PATH+1];
        LPTSTR  pFile = tcFile;

        if (pszFolderPath != NULL)
        {
            lstrcpy(tcFile, pszFolderPath);
            lstrcat(tcFile, TEXT("\\"));
            lstrcat(tcFile, pszJob);
        }
        else
        {
            pFile = pszJob;
        }

        //
        // Skip hidden jobs.
        //

        if (GetFileAttributes(pFile) & FILE_ATTRIBUTE_HIDDEN)
        {
            return S_FALSE;
        }

        HANDLE hFile = CreateFile(pFile, GENERIC_READ, FILE_SHARE_READ,
                        NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);

        if (hFile == INVALID_HANDLE_VALUE)
        {
            DEBUG_OUT_LASTERROR;
            hr = HRESULT_FROM_WIN32(GetLastError());
            break;
        }

        if (GetFileTime(hFile, &_ftCreation, NULL, &_ftLastWrite) == FALSE)
        {
            CloseHandle(hFile);

            DEBUG_OUT_LASTERROR;
            hr = HRESULT_FROM_WIN32(GetLastError());
            break;
        }

        CloseHandle(hFile);

        //
        // Create & load the job
        //

        hr = ::JFCreateAndLoadCJob(pszFolderPath, pszJob, &pJob);

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

        _id = ID_JOB;

        ////////////////////////////////////////////////////////////
        //
        //  Extract the properties
        //

        //
        // Get last exit code
        //
        // The return value from this call is the task's last start error.
        //

        HRESULT hrLastStart = pJob->GetExitCode(&_dwExitCode);

        //
        //  Get a code to tell what to display in the "Status" column.
        //  For the purposes of this column the job can be:
        //      a. missed
        //      b. failed to start
        //      c. running
        //      d. other
        //

        ULONG ulAllFlags;

        pJob->GetAllFlags(&ulAllFlags);

        if (ulAllFlags & JOB_I_FLAG_MISSED)
        {
            _status = ejsMissed;
        }
        else if (FAILED(hrLastStart))
        {
           switch(hrLastStart)
           {
           case HRESULT_FROM_WIN32(ERROR_LOGON_FAILURE):
              _status = ejsBadAcct;
              break;

           case HRESULT_FROM_WIN32(ERROR_ACCOUNT_RESTRICTION):
              _status = ejsResAcct;
              break;

           default:
              _status = ejsWouldNotStart;
           }

        }
        else
        {
            HRESULT hrStatus = 0;

            hr = pJob->GetStatus(&hrStatus);

            CHECK_HRESULT(hr);
            BREAK_ON_FAIL(hr);

            switch (hrStatus)
            {
            case SCHED_S_TASK_RUNNING:
                _status = ejsRunning;
                break;

            case SCHED_S_TASK_NOT_SCHEDULED:
                _status = ejsNotScheduled;
                break;
            }
        }

        //
        // Get last run time
        //

        hr = pJob->GetMostRecentRunTime(&_stLastRunTime);

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

        // ensure wDayOfWeek is 0, else memcmp fails.
        _stLastRunTime.wDayOfWeek = 0;

        //
        // Get next run time
        //

        hr = pJob->GetNextRunTime(&_stNextRunTime);

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

        // ensure wDayOfWeek is 0, else memcmp fails.
        _stNextRunTime.wDayOfWeek = 0;

        //
        //  Get the job flags
        //

        hr = pJob->GetFlags(&_ulJobFlags);

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

        //
        // Get the first job trigger if any
        //

        hr = pJob->GetTriggerCount(&_cTriggers);

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

        if (_cTriggers > 0)
        {
            ITaskTrigger * pIJobTrigger = NULL;

            hr = pJob->GetTrigger(0, &pIJobTrigger);

            CHECK_HRESULT(hr);
            BREAK_ON_FAIL(hr);

            _sJobTrigger.cbTriggerSize = sizeof(TASK_TRIGGER);

            hr = pIJobTrigger->GetTrigger(&_sJobTrigger);

            pIJobTrigger->Release();

            CHECK_HRESULT(hr);
            BREAK_ON_FAIL(hr);
        }
        else
        {
            _sJobTrigger.cbTriggerSize = 0;
        }


        ///////////////////////////////////////////////////////////////////
        //
        //  Fill up the buffer cBuf
        //

        USHORT cchCurr = 0;

        //
        //  Get the command
        //

        LPWSTR  pwszCommand = NULL;

        hr = pJob->GetApplicationName(&pwszCommand);

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

#ifndef UNICODE
        hr = UnicodeToAnsi(_cBuf, pwszCommand, MAX_PATH);
        CoTaskMemFree(pwszCommand);
        BREAK_ON_FAIL(hr);
#else
        lstrcpy(_cBuf, pwszCommand);
        CoTaskMemFree(pwszCommand);
#endif

        DEBUG_OUT((DEB_USER12, "Command = %ws\n", _cBuf));

        // update size
        cchCurr += lstrlen(_cBuf) + 1;


        //
        //  Get the account name
        //

        _oCreator = cchCurr;

        LPWSTR pwszCreator = NULL;

        hr = pJob->GetCreator(&pwszCreator);

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

#if defined(UNICODE)
        lstrcpy(&_cBuf[_oCreator], pwszCreator);
        CoTaskMemFree(pwszCreator);
#else
        hr = UnicodeToAnsi(&_cBuf[_oCreator], pwszCreator, MAX_PATH);
        CoTaskMemFree(pwszCreator);
        BREAK_ON_FAIL(hr);
#endif


        //  update size
        cchCurr += lstrlen(&_cBuf[_oCreator]) + 1;

        //
        //  Copy the job path
        //

        _oPath = cchCurr;

        if (pszFolderPath == NULL)
        {
            pszJob = PathFindFileName(pszJob);
        }

        lstrcpy(&_cBuf[_oPath], pszJob);

        TCHAR * ptcPath = &_cBuf[_oPath];
        TCHAR * ptcName = PathFindFileName(ptcPath);
        TCHAR * ptcExtn = PathFindExtension(ptcName);

        if (ptcExtn)
        {
            *ptcExtn = TEXT('\0');
        }

        _oName = _oPath + (USHORT)(ptcName - ptcPath) * sizeof(TCHAR);

        // update buff size
        cchCurr += lstrlen(ptcPath) + 1;

        //
        //  Finaly set the size
        //

        _cb = offsetof(CJobID, _cBuf) + cchCurr * sizeof(TCHAR);

        //
        //  Ensure that the DWORD at the end is zero, used by ILClone, etc.
        //

        _NullTerminate();

    } while (0);

    if (pJob != NULL)
    {
        pJob->Release();
    }

    return hr;
}

//____________________________________________________________________________
//
//  Member:     CJobID::Rename
//
//  Synopsis:   Loads this object with data from jidIn, except for
//              the name which is set to lpszName.
//
//  Arguments:  [jidIn] -- IN
//              [lpszName] -- IN
//
//  Returns:    HRESULT.
//
//  History:    1/25/1996   RaviR   Created
//
//____________________________________________________________________________

HRESULT
CJobID::Rename(
    CJobID &  jidIn,
    LPCOLESTR lpszNameIn)
{
    ZeroMemory(this, sizeof(CJobID));
    CopyMemory(this, &jidIn, jidIn.GetSize());

    LPTSTR lpszName = (LPTSTR)lpszNameIn;

#if !defined(UNICODE)
    CHAR cBufTemp[MAX_PATH];

    HRESULT hr = UnicodeToAnsi(cBufTemp, lpszNameIn, MAX_PATH);
    if (FAILED(hr))
    {
        return hr;
    }
    lpszName = cBufTemp;
#endif

    lstrcpy(&_cBuf[_oName], lpszName);

    _cb = offsetof(CJobID, _cBuf) +
             (_oName + lstrlen(lpszName) + 1) * sizeof(TCHAR);

    _NullTerminate();
    return S_OK;
}

//____________________________________________________________________________
//
//  Member:     CJobID::Clone
//
//  Returns:    CJobID *
//____________________________________________________________________________

CJobID *
CJobID::Clone(void)
{
    CJobID * pjid = (CJobID *) SHAlloc(_cb + sizeof(_cb));

    if (pjid)
    {
        CopyMemory(pjid, this, _cb);
        pjid->_NullTerminate();
    }

    return pjid;
}




#if (DBG == 1)

//+--------------------------------------------------------------------------
//
//  Member:     CJobID::Validate
//
//  Synopsis:   Assert if this job idlist object is invalid
//
//  History:    12-04-1997   DavidMun   Created
//
//  Notes:      For debugging only.
//
//---------------------------------------------------------------------------

VOID
CJobID::Validate()
{
    //
    // Expect _cb to have been set to nonzero value
    //

    Win4Assert(_cb);
    Win4Assert(_cb < sizeof(CJobID));

    //
    // Expect all jobids to have a name.  Offset should be nonzero because
    // name is not the first string.
    //

    Win4Assert(_oName < IDJOB_BUFFER_SIZE);

    //
    // Expect that name is null terminated before the end of the buffer.
    //

    Win4Assert(_oName + lstrlen(GetName()) < IDJOB_BUFFER_SIZE);

    //
    // Expect the jobid itself to be null terminated
    //

    UNALIGNED USHORT *pusNextCB = (UNALIGNED USHORT *)(((BYTE *)this) + _cb);
    Win4Assert(_cb + sizeof(USHORT) <= sizeof(CJobID));
    Win4Assert(!*pusNextCB);
}

#endif // (DBG == 1)



BOOL
GetLocaleDateTimeString(
    SYSTEMTIME*     pst,
    DWORD           dwDateFlags,
    DWORD           dwTimeFlags,
    TCHAR           szBuff[],
    int             cchBuffLen,
    LPSHELLDETAILS  lpDetails);
//____________________________________________________________________________
//
//  Member:     CJobID::GetNextRunTimeString
//
//  Synopsis:   S
//
//  Arguments:  [tcBuff] -- IN
//              [cchBuff] -- IN
//              [fForComparison] -- IN
//
//  Returns:    HRESULT.
//
//  History:    4/25/1996   RaviR   Created
//
//____________________________________________________________________________

LPTSTR
CJobID::GetNextRunTimeString(
    TCHAR           tcBuff[],
    UINT            cchBuff,
    BOOL            fForComparison,
    LPSHELLDETAILS  lpDetails)
{
    if (this->IsJobNotScheduled() == TRUE)
    {
        LoadString(g_hInstance, IDS_NEVER, tcBuff, cchBuff);
    }
    else if (this->IsJobFlagOn(TASK_FLAG_DISABLED) == TRUE)
    {
        LoadString(g_hInstance, IDS_DISABLED, tcBuff, cchBuff);
    }
    else if (this->IsTriggerFlagOn(TASK_TRIGGER_FLAG_DISABLED))
    {
        LoadString(g_hInstance, IDS_TRIGGER_DISABLED, tcBuff, cchBuff);
    }
    else if (this->GetTriggerType() == TASK_EVENT_TRIGGER_AT_SYSTEMSTART)
    {
        LoadString(g_hInstance, IDS_ON_STARTUP, tcBuff, cchBuff);
    }
    else if (this->GetTriggerType() == TASK_EVENT_TRIGGER_AT_LOGON)
    {
        LoadString(g_hInstance, IDS_ON_LOGON, tcBuff, cchBuff);
    }
    else if (this->GetTriggerType() == TASK_EVENT_TRIGGER_ON_IDLE)
    {
        LoadString(g_hInstance, IDS_WHEN_IDLE, tcBuff, cchBuff);
    }
    else
    {
        SYSTEMTIME &st = this->GetNextRunTime();

        if (st.wYear == 0 || st.wMonth == 0 || st.wDay == 0)
        {
            LoadString(g_hInstance, IDS_NEVER, tcBuff, cchBuff);
        }
        else
        {
            if (fForComparison == TRUE)
            {
                return NULL;
            }

            GetLocaleDateTimeString(&st, DATE_SHORTDATE, 0, tcBuff, cchBuff, lpDetails);
        }
    }

    return tcBuff;
}

//____________________________________________________________________________
//
//  Function:   HDROPFromJobIDList
//
//  Synopsis:   Create an HDROP for the files in the apjid array.
//              Used for CF_HDROP format.
//
//  Arguments:  [cidl] -- IN
//              [apjidl] -- IN
//
//  Returns:    HDROP
//
//  History:    1/31/1996   RaviR   Created
//
//____________________________________________________________________________

HDROP
HDROPFromJobIDList(
    LPCTSTR     pszFolderPath,
    UINT        cidl,
    PJOBID    * apjidl)
{
    HDROP            hMem = 0;
    LPDROPFILESTRUCT lpDrop;
    DWORD            dwSize = 0;

    if (cidl == 0)
    {
        return NULL;
    }

    TCHAR tcFolder[MAX_PATH];
    lstrcpy(tcFolder, pszFolderPath);
    lstrcat(tcFolder, TEXT("\\"));

    USHORT cbFolderPathLen = (USHORT)(lstrlen(tcFolder) * sizeof(TCHAR));

    //
    //  Walk the list and find out how much space we need.
    //

    dwSize = sizeof(DROPFILESTRUCT) + sizeof(TCHAR);  // size + terminal nul


    USHORT * pusPathLen = new USHORT[cidl * 2];

    if (pusPathLen == NULL)
    {
        CHECK_HRESULT(E_OUTOFMEMORY);
        return NULL;
    }

    USHORT * pusExtLen = &pusPathLen[cidl];

    for (UINT i=0; i < cidl; i++)
    {
        pusPathLen[i] = (USHORT)(lstrlen(apjidl[i]->GetPath()) * sizeof(TCHAR));

        pusExtLen[i]  = (USHORT)((lstrlen(apjidl[i]->GetExtension()) + 1) * sizeof(TCHAR));

        dwSize += cbFolderPathLen + pusPathLen[i] + pusExtLen[i];
    }

    //
    //  If it's bigger than the struct can hold, then bail.
    //  TODO: Return an error?
    //

    if (dwSize > 0x0000ffff)
    {
        delete [] pusPathLen;
        return NULL;
    }

    //
    //  Allocate the buffer and fill it in.
    //

    hMem = (HDROP)GlobalAlloc(GHND, dwSize);

    if (hMem == NULL)
    {
        delete [] pusPathLen;
        CHECK_HRESULT(E_OUTOFMEMORY);
        return NULL;
    }

    lpDrop = (LPDROPFILESTRUCT) GlobalLock(hMem);

    lpDrop->pFiles = (DWORD)(sizeof(DROPFILESTRUCT));
    lpDrop->pt.x   = 0;
    lpDrop->pt.y   = 0;
    lpDrop->fNC    = FALSE;
#ifdef UNICODE
    lpDrop->fWide  = TRUE;
#else
    lpDrop->fWide  = FALSE;
#endif

    //
    //  Fill in the path names.
    //

    LPBYTE pbTemp = (LPBYTE) ((LPBYTE) lpDrop + lpDrop->pFiles);

    for (i=0; i < cidl; i++)
    {
        CopyMemory(pbTemp, tcFolder, cbFolderPathLen);
        pbTemp += cbFolderPathLen;

        CopyMemory(pbTemp, apjidl[i]->GetPath(), pusPathLen[i]);
        pbTemp += pusPathLen[i];

        CopyMemory(pbTemp, apjidl[i]->GetExtension(), pusExtLen[i]);
        pbTemp += pusExtLen[i];
    }

    *((LPTSTR)pbTemp) = TEXT('\0');  // Extra Nul terminate

    //
    //  Unlock the buffer and return it.
    //

    GlobalUnlock(hMem);

    delete [] pusPathLen;

    return hMem;
}




//+--------------------------------------------------------------------------
//
//  Function:   CreateIDListArray
//
//  Synopsis:   Create shell idlist array in the format required by the
//              CFSTR_SHELLIDLIST clipboard format.
//
//  Arguments:  [pidlFolder] - pidl of tasks folder
//              [cidl]       - number of elements in [apjidl]
//              [apjidl]     - array of pointers to idls, each idl
//                             specifies a .job object.
//
//  Returns:    Handle to created array, or NULL on error.
//
//  History:    05-30-1997   DavidMun   Created
//
//  Notes:      For this format, the first element in the array is an
//              absolute idl to a container (the tasks folder), and the
//              remainder (each a single .job object) are relative to the
//              first.
//
//---------------------------------------------------------------------------

HGLOBAL
CreateIDListArray(
    LPCITEMIDLIST   pidlFolder,
    UINT            cidl,
    PJOBID         *apjidl)
{
    TRACE_FUNCTION(CreateIDListArray);

    Win4Assert(cidl);
    if (cidl == 0)
    {
        return NULL;
    }

    HJOBIDA hJobIDA = NULL;
    DWORD   offset = sizeof(CJobIDA) + sizeof(UINT) * cidl;
    DWORD   dwSize = offset;

    for (UINT i=0; i < cidl ; i++)
    {
        dwSize += apjidl[i]->GetSize() + 2; // +2 for null list terminator
    }

    dwSize += ILGetSize(pidlFolder);

    hJobIDA = GlobalAlloc(GPTR, dwSize);  // This MUST be GlobalAlloc!!!

    if (hJobIDA == NULL)
    {
        CHECK_HRESULT(E_OUTOFMEMORY);
        return NULL;
    }

    PJOBIDA pJobIDA = (PJOBIDA)hJobIDA;       // no need to lock

    pJobIDA->cidl = cidl;           // count doesn't include idl at offset 0,
    pJobIDA->aoffset[0] = offset;   // which is container

    CopyMemory(((LPBYTE)pJobIDA)+offset, pidlFolder, ILGetSize(pidlFolder));
    offset += ILGetSize(pidlFolder);

    for (i=0; i < cidl ; i++)
    {
        UINT cbSize = apjidl[i]->GetSize();

        pJobIDA->aoffset[i+1] = offset;

        CopyMemory(((LPBYTE)pJobIDA)+offset, apjidl[i], cbSize);

        offset += cbSize + 2; // +2 to leave null after copied in idl
    }

    Win4Assert(offset == dwSize);
    return hJobIDA;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
////////
////////    CJobIDA related functions.
////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

//____________________________________________________________________________
//
//  Function:   HJOBIDA_Create
//
//  Synopsis:   Create an HJOBIDA for the files in the apjid array.
//              Used for CF_JOBIDLIST data format.
//
//  Arguments:  [cidl] -- IN
//              [apjidl] -- IN
//
//  Returns:    HJOBIDA
//
//  History:    1/31/1996   RaviR   Created
//
//____________________________________________________________________________

HJOBIDA
HJOBIDA_Create(
    UINT        cidl,
    PJOBID    * apjidl)
{
    if (cidl == 0)
    {
        return NULL;
    }

    HJOBIDA hJobIDA = NULL;
    DWORD   offset = sizeof(CJobIDA) + sizeof(UINT) * (cidl - 1);
    DWORD   dwSize = offset;

    for (UINT i=0; i < cidl ; i++)
    {
        dwSize += apjidl[i]->GetSize() + 2;  // +2 for null list terminator
    }

    hJobIDA = GlobalAlloc(GPTR, dwSize);  // This MUST be GlobalAlloc with
                                          // GPTR!

    if (hJobIDA == NULL)
    {
        CHECK_HRESULT(E_OUTOFMEMORY);
        return NULL;
    }

    PJOBIDA pJobIDA = (PJOBIDA)hJobIDA;       // no need to lock

    pJobIDA->cidl = cidl;

    //
    // Note that apjidl[i] reports its true size, which doesn't include the
    // extra 0 ulong following it.  That null terminator is required, and
    // isn't copied into pJobIDA by the CopyMemory, which is using
    // apjidl[i]'s reported size.
    //
    // Since the GPTR ensures zero-initialized memory, and the extra 2
    // bytes per jobid has been accounted for in computing dwSize, we can
    // get the terminator just by increasing offset by the terminator size
    // on each iteration.
    //

    for (i=0; i < cidl ; i++)
    {
        UINT cbSize = apjidl[i]->GetSize();

        pJobIDA->aoffset[i] = offset;

        CopyMemory(((LPBYTE)pJobIDA)+offset, apjidl[i], cbSize);

        offset += cbSize + 2;
    }

    Win4Assert(offset == dwSize);

    return hJobIDA;
}

void
HJOBIDA_Free(
    HJOBIDA hJobIDA)
{
    GlobalFree(hJobIDA);           // This MUST be GlobalFree
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
////////
////////    Functions to clone and free a LPCITEMIDLIST array.
////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

//____________________________________________________________________________
//
//  Function:   ILA_Clone
//
//  Synopsis:   S
//
//  Arguments:  [cidl] -- IN
//              [apidl] -- IN
//
//  Returns:    LPITEMIDLIST
//
//  History:    1/9/1996   RaviR   Created
//
//____________________________________________________________________________

LPITEMIDLIST*
ILA_Clone(
    UINT            cidl,
    LPCITEMIDLIST * apidl)
{
    TRACE_FUNCTION(ILA_Clone);

    LPITEMIDLIST* aNewPidl = new LPITEMIDLIST[cidl];

    if (NULL == aNewPidl)
    {
        return NULL;
    }

    for (UINT i = 0; i < cidl; i++)
    {
        aNewPidl[i] = ILClone(apidl[i]);

        if (NULL == aNewPidl[i])
        {
            // delete what we've allocated so far
            for (UINT j = 0; j < i; j++)
            {
                ILFree(aNewPidl[i]);
            }

            delete[] aNewPidl;

            return NULL;
        }
    }

    return aNewPidl;
}



//____________________________________________________________________________
//
//  Function:   ILA_Free
//
//  Synopsis:   S
//
//  Arguments:  [cidl] -- IN
//              [apidl] -- IN
//
//  Returns:    VOID
//
//  History:    1/9/1996   RaviR   Created
//
//____________________________________________________________________________

VOID
ILA_Free(
    UINT            cidl,
    LPITEMIDLIST  * apidl)
{
    TRACE_FUNCTION(ILA_Free);

    for (UINT i = 0; i < cidl; i++)
    {
        ILFree(apidl[i]);
    }

    delete [] apidl;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
////////
////////    Functions to access the CJob & CSchedule
////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

//____________________________________________________________________________
//
//  Function:   JFGetJobScheduler
//
//  Synopsis:   S
//
//  Arguments:  [ppJobScheduler] -- IN
//              [ppwszFolderPath] -- IN
//
//  Returns:    HRESULT
//
//  History:    1/25/1996   RaviR   Created
//
//____________________________________________________________________________

HRESULT
JFGetJobScheduler(
    LPTSTR             pszMachine,
    ITaskScheduler **  ppJobScheduler,
    LPCTSTR           *ppszFolderPath)
{
    HRESULT     hr = S_OK;
    CSchedule * pCSchedule = NULL;

    do
    {
        pCSchedule = new CSchedule;

        if (pCSchedule == NULL)
        {
            hr = E_OUTOFMEMORY;
            CHECK_HRESULT(hr);
            break;
        }

        hr = pCSchedule->Init();

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

        if (pszMachine != NULL)
        {
#ifdef UNICODE
            hr = pCSchedule->SetTargetComputer(pszMachine);
#else
            WCHAR wBuff[MAX_PATH];
            hr = AnsiToUnicode(wBuff, pszMachine, MAX_PATH);
            CHECK_HRESULT(hr);
            BREAK_ON_FAIL(hr);

            hr = pCSchedule->SetTargetComputer(wBuff);
#endif

            CHECK_HRESULT(hr);
            BREAK_ON_FAIL(hr);
        }

        *ppszFolderPath = pCSchedule->GetFolderPath();

        *ppJobScheduler = (ITaskScheduler *)pCSchedule;

    } while (0);

    if (FAILED(hr) && pCSchedule != NULL)
    {
        pCSchedule->Release();
    }

    return hr;
}



//____________________________________________________________________________
//
//  Member:     CreateAndLoadCJob
//
//  Arguments:  [pszJob] -- IN
//              [ppJob] -- OUT
//
//  Returns:    HRESULT.
//____________________________________________________________________________

HRESULT
JFCreateAndLoadCJob(
    LPCTSTR     pszFolderPath,
    LPTSTR      pszJob,  // job path relative to the folder
    CJob     ** ppJob)
{
    TRACE_FUNCTION(CreateAndLoadCJob);

    *ppJob = NULL; // init for failure

    CJob  *pJob = CJob::Create();

    if (pJob == NULL)
    {
        CHECK_HRESULT(E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }

    TCHAR   buff[MAX_PATH];
    LPTSTR  pszJobPathTemp = pszJob;

    if (pszFolderPath != NULL)
    {
        lstrcpy(buff, pszFolderPath);
        lstrcat(buff, TEXT("\\"));
        lstrcat(buff, pszJob);

        pszJobPathTemp = buff;
    }

    HRESULT hr = S_OK;

#if defined(UNICODE)
    LPWSTR pwszJobPath = pszJobPathTemp;
#else
    WCHAR wcBuff[MAX_PATH];
    hr = AnsiToUnicode(wcBuff, pszJobPathTemp, MAX_PATH);

    if (FAILED(hr))
    {
        pJob->Release();
        CHECK_HRESULT(hr);
        return hr;
    }
    LPWSTR pwszJobPath = wcBuff;
#endif

    DEBUG_OUT((DEB_USER1, "Load Job <%ws>\n", pwszJobPath));

    hr = pJob->Load(pwszJobPath, STGM_READWRITE | STGM_SHARE_EXCLUSIVE);

    if (FAILED(hr))
    {
        pJob->Release();
        CHECK_HRESULT(hr);
        return hr;
    }

    //
    // Success, return the object
    //

    *ppJob = pJob;
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   JFCreateAndLoadTask
//
//  Synopsis:   Create an in-memory task object and initialize it from
//              [pszJob], returning the ITask interface on the object.
//
//  Arguments:  [pszFolderPath] - path to tasks folder
//              [pszJob]        - filename of job
//              [ppITask]       - filled with ITask interface ptr
//
//  Returns:    HRESULT
//
//  Modifies:   *[ppITask]
//
//  History:    10-07-1997   DavidMun   Created
//
//  Notes:      Caller must Release returned interface.
//
//---------------------------------------------------------------------------

HRESULT
JFCreateAndLoadTask(
    LPCTSTR     pszFolderPath,
    LPTSTR      pszJob,  // job path relative to the folder
    ITask    ** ppITask)
{
    TRACE_FUNCTION(CreateAndLoadTask);
    HRESULT hr;
    CJob *pJob;

    hr = JFCreateAndLoadCJob(pszFolderPath, pszJob, &pJob);

    if (SUCCEEDED(hr))
    {
        hr = pJob->QueryInterface(IID_ITask, (void **)ppITask);
        pJob->Release();
    }

    return hr;
}

//____________________________________________________________________________
//
//  Function:   JFSaveJob
//
//  Synopsis:   Save task settings to storage via the task's IPersistFile
//              interface. Also, if applicable, prompt the user for security
//              account information.
//
//  Arguments:  [hwndOwner]                          -- Owner window.
//              [pIJob]                              -- Target task object.
//              [fSecuritySupported]                 -- Flag indicating if
//                                                      security-specific code
//                                                      should be invoked.
//              [fTaskAccountChange]                 -- TRUE, the task account
//                                                      information has
//                                                      changed.
//              [fTaskApplicationChange]             -- TRUE, the task
//                                                      application has
//                                                      changed.
//              [fSuppressAccountInformationRequest] -- TRUE, do not prompt
//                                                      the user for account
//                                                      information.
//
//  Returns:    HRESULT
//
//  History:    4/25/1996   RaviR   Created
//
//____________________________________________________________________________

HRESULT
JFSaveJob(
    HWND    hwndOwner,
    ITask * pITask,
    BOOL    fSecuritySupported,
    BOOL    fTaskAccountChange,
    BOOL    fTaskApplicationChange,
    BOOL    fSuppressAccountInformationRequest)
{
#if defined(_CHICAGO_)
    Win4Assert(!fSecuritySupported);
#endif // defined(_CHICAGO_)

#if !defined(_CHICAGO_)
    AccountInfo    AcctInfo;
#endif // !defined(_CHICAGO_)
    HRESULT        hr;
    IPersistFile * pipfTask;
    WCHAR *        pwszAccountName = NULL;
#if !defined(_CHICAGO_)
    BOOL           fChangesSaved   = FALSE;
#endif // !defined(_CHICAGO_)

    hr = pITask->QueryInterface(IID_IPersistFile, (void **)&pipfTask);

    if (FAILED(hr))
    {
        return hr;
    }

#if !defined(_CHICAGO_)
    if (fSecuritySupported)
    {
        InitializeAccountInfo(&AcctInfo);

        //
        // Application change but no corresponding account information change.
        // Launch the set account information dialog in this case.
        //

        if (fTaskApplicationChange && !fTaskAccountChange)
        {
            //
            // Attempt to retreive account information for the set account
            // information dialog. Ignore failures, we would just like to
            // have something to fill in the account name control.
            //

            if (SUCCEEDED(pITask->GetAccountInformation(&pwszAccountName)))
            {
                AcctInfo.pwszAccountName = pwszAccountName;
            }

            goto SetAccountInformationDlg;
        }
    }
#endif // !defined(_CHICAGO_)

    //
    // Go ahead and save the changes.
    //

    hr = pipfTask->Save(NULL, FALSE);
#if !defined(_CHICAGO_)
    fChangesSaved = TRUE;
#endif // !defined(_CHICAGO_)

#if !defined(_CHICAGO_)
    if (fSecuritySupported)
    {
        if (FAILED(hr))
        {
            if (pipfTask->IsDirty() == S_FALSE)
            {
                //
                // If Save failed, yet the job is no longer dirty, the
                // error is due to a failure setting security information.
                //
                // Let the user know there was a problem. Remap the return
                // code so we don't get further error dialogs.
                //

                CHECK_HRESULT(hr);
                SecurityErrorDialog(hwndOwner, hr);
                hr = S_OK;
            }
#if DBG == 1
            else
            {
                //
                // Standard persist code failure. Calling page code will
                // put up an error dialog.
                //

                CHECK_HRESULT(hr);
            }
#endif // DBG == 1

            goto CleanExit;
        }

        if (!fTaskAccountChange)
        {
            //
            // No account information changes. Verify that this job does
            // indeed have account information associated with it.
            //

            hr = pITask->GetAccountInformation(&pwszAccountName);

            if (hr == SCHED_E_ACCOUNT_INFORMATION_NOT_SET)
            {
                //
                // No account information. Launch the set account information
                // dialog.
                //

                hr = S_OK;
                goto SetAccountInformationDlg;
            }
            else if (SUCCEEDED(hr))
            {
                //
                // Done.
                //

                goto CleanExit;
            }
            else
            {
                //
                // In error cases, silently fail. There's nothing we can do
                // about it other than confuse the user. Remapping the return
                // code so the calling page code doesn't put up an error
                // dialog.
                //

                CHECK_HRESULT(hr);
                hr = S_OK;
                goto CleanExit;
            }
        }
        else if (fTaskApplicationChange && fTaskAccountChange)
        {
            //
            // Fetch cached account information from the job object for
            // the pending set account information dialog. Silently fail
            // in an error case.
            //

            hr = pITask->GetAccountInformation(&pwszAccountName);

            Win4Assert(hr != SCHED_E_ACCOUNT_INFORMATION_NOT_SET);

            if (FAILED(hr) || hr == S_FALSE)
            {
                //
                // The information is cached. This would fail for no
                // reason other than insufficient memory.
                //
                // Though, did we goof?
                //

                CHECK_HRESULT(hr);
                hr = S_OK;
                goto CleanExit;
            }

            AcctInfo.pwszAccountName = pwszAccountName;
        }
        else
        {
            //
            // Done.
            //

            goto CleanExit;
        }
    }
    else
    {
        CHECK_HRESULT(hr);
        goto CleanExit;
    }

SetAccountInformationDlg:

    //
    // Should've arrived here only for security reasons.
    //

    Win4Assert(fSecuritySupported);

    //
    // Can only arrive at this point if the user must specify security
    // account information.
    //
    // Launch the set account information dialog.
    //

    if (!fSuppressAccountInformationRequest)
    {
        LaunchSetAccountInformationDlg(hwndOwner, &AcctInfo);

        //
        // Check if the data is dirty. On dialog entry, the password is set
        // to the global empty string. If the password ptr still equals this,
        // then the user didn't change the password (e.g. the user canceled
        // the dialog).
        //

        if (AcctInfo.pwszAccountName != NULL &&
            AcctInfo.pwszPassword != tszEmpty)
        {
            //
            // Reset the account information and persist the changes.
            //

            hr = pITask->SetAccountInformation(AcctInfo.pwszAccountName,
                                               AcctInfo.pwszPassword);

            fChangesSaved = FALSE;

            if (FAILED(hr))
            {
                goto CleanExit;
            }
        }
    }

    if (!fChangesSaved)
    {
        CWaitCursor WaitCursor;
        hr = pipfTask->Save(NULL, FALSE);

        if (FAILED(hr) && pipfTask->IsDirty() == S_FALSE)
        {
            //
            // Similar check as above. General save succeeded but the attempt
            // to set security information failed. Let the user know there
            // was a problem and remap the return code so we don't get
            // further dialogs.
            //

            SecurityErrorDialog(hwndOwner, hr);
            hr = S_OK;
        }
#if DBG == 1
        else
        {
            CHECK_HRESULT(hr);
        }
#endif // DBG == 1
    }
#endif // !defined(_CHICAGO_)

#if !defined(_CHICAGO_)
CleanExit:
#endif // !defined(_CHICAGO_)
    pipfTask->Release();
#if !defined(_CHICAGO_)
    if (fSecuritySupported)
    {
        ResetAccountInfo(&AcctInfo);
    }
#endif // !defined(_CHICAGO_)

    return hr;
}

#if !defined(_CHICAGO_)
//____________________________________________________________________________
//
//  Function:   SecurityErrorDialog
//
//  Synopsis:   Map the error to a hopefully friendly & informative dialog.
//
//  Arguments:  [hWndOwner] -- Parent window handle.
//              [hr]        -- Security error to map.
//
//  Returns:    None.
//
//  Notes:      None.
//
//____________________________________________________________________________
void
SecurityErrorDialog(
    HWND    hWndOwner,
    HRESULT hr)
{
    int  idsErrorMessage;
    UINT idsHelpHint;

    idsErrorMessage = IERR_SECURITY_WRITE_ERROR;

    if (hr == SCHED_E_ACCOUNT_NAME_NOT_FOUND)
    {
        idsHelpHint = IDS_HELP_HINT_INVALID_ACCT;
    }
    else if (hr == SCHED_E_ACCOUNT_DBASE_CORRUPT)
    {
        idsHelpHint = IDS_HELP_HINT_DBASE_CORRUPT;
    }
    else if (hr == HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED))
    {
        idsHelpHint = IDS_HELP_HINT_ACCESS_DENIED;
    }
    else if (hr == SCHED_E_SERVICE_NOT_RUNNING ||
             HRESULT_FACILITY(hr) == FACILITY_RPC)
    {
        idsHelpHint = IDS_HELP_HINT_SEC_GENERAL;
    }
    else
    {
        //
        // No help hint for unexpected errors.
        //

        idsHelpHint = 0;
    }

    //
    // Put up the error dialog.
    //

    SchedUIErrorDialog(hWndOwner, idsErrorMessage, hr, idsHelpHint);
}
#endif // !defined(_CHICAGO_)


//____________________________________________________________________________
//
//  Function:   JFGetAppNameForTask
//
//  Synopsis:   S
//
//  Arguments:  [path] -- IN
//              [pszAppName] -- IN
//              [cchAppName] -- IN
//
//  Returns:    HRESULT
//
//  History:    4/25/1996   RaviR   Created
//
//____________________________________________________________________________

HRESULT
JFGetAppNameForTask(
    LPCTSTR     pszTask,        // Full path
    LPTSTR      pszAppName,
    UINT        cchAppName)
{
    TRACE_FUNCTION(JFGetAppNameForTask);

    HRESULT hr = S_OK;

    CJob  *pJob = CJob::Create();

    if (pJob == NULL)
    {
        CHECK_HRESULT(E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }

    hr = pJob->LoadP(pszTask, 0, FALSE, FALSE);

    CHECK_HRESULT(hr);

    if (SUCCEEDED(hr))
    {
        LPWSTR pwszCommand = NULL;

        hr = pJob->GetApplicationName(&pwszCommand);

        CHECK_HRESULT(hr);

        if (SUCCEEDED(hr))
        {
#ifdef UNICODE
            lstrcpy(pszAppName, pwszCommand);
            DEBUG_OUT((DEB_USER1, "JFGetAppNameForTask -> %ws\n", pszAppName));
#else
            hr = UnicodeToAnsi(pszAppName, pwszCommand, cchAppName);
#endif

            CoTaskMemFree(pwszCommand);
        }
    }

    pJob->Release();

    return hr;
}





BOOL
IsAScheduleObject(
    TCHAR szFile[])
{
	if( NULL == szFile )
	{
		return FALSE;
	}

    LPTSTR  pszName = PathFindFileName(szFile);
    LPTSTR  pszExt = PathFindExtension(pszName);

    if (lstrcmpi(pszExt, TSZ_DOTJOB) != 0)
        // && (lstrcmpi(pszExt, g_szDotQue) != 0)
    {
        return FALSE;
    }

    return TRUE;
}



//____________________________________________________________________________
//
//  Function:   JFCopyJob
//
//  Synopsis:   S
//
//  Arguments:  [hwndOwner] -- IN
//              [szFileFrom] -- IN
//              [pszFolderPath] -- IN
//              [fMove] -- IN
//
//  Returns:    HRESULT
//
//  History:    2/2/1996   RaviR   Created
//
//____________________________________________________________________________

HRESULT
JFCopyJob(
    HWND        hwndOwner,
    TCHAR       szFileFrom[],
    LPCTSTR     pszFolderPath,
    BOOL        fMove)
{
    HRESULT hr = S_OK;
    ITask * pJob = NULL;

    LPTSTR  pszName = PathFindFileName(szFileFrom);

    hr = JFCreateAndLoadTask(NULL, szFileFrom, &pJob);

    if (FAILED(hr))
    {
        if (hr == HRESULT_FROM_WIN32(ERROR_INVALID_DATA))
        {
            SchedUIErrorDialog(hwndOwner, IERR_INVALID_DATA, pszName);
        }

        return hr;
    }
    else
    {
        pJob->Release();
    }

    TCHAR   szFileTo[MAX_PATH+1];
    lstrcpy(szFileTo, pszFolderPath);

    SHFILEOPSTRUCT fo = {hwndOwner, (fMove ? FO_MOVE : FO_COPY), szFileFrom,
                         szFileTo, FOF_ALLOWUNDO, FALSE, NULL, NULL};

    // Make sure we have double trailing NULL!
    *(szFileFrom + lstrlen(szFileFrom) + 1) = TEXT('\0');

    if ((SHFileOperation(&fo) !=0) || fo.fAnyOperationsAborted == TRUE)
    {
        hr = E_FAIL;
        CHECK_HRESULT(hr);
        return hr;
    }

    //SHChangeNotify(SHCNE_RENAMEITEM, SHCNF_PATH, szFileFrom, szFileTo);

    return hr;
}


//____________________________________________________________________________
//
//  Function:   GetTriggerStringFromTrigger
//
//  Synopsis:   S
//
//  Arguments:  [pJobTrigger] -- IN
//              [psTrigger] -- IN
//              [cchTrigger] -- IN
//
//  Returns:    HRESULT
//____________________________________________________________________________

HRESULT
GetTriggerStringFromTrigger(
    TASK_TRIGGER  * pJobTrigger,
    LPTSTR          psTrigger,
    UINT            cchTrigger,
    LPSHELLDETAILS  lpDetails)
{
    HRESULT     hr = S_OK;
    LPWSTR      pwsz = NULL;

    if (pJobTrigger->cbTriggerSize > 0)
    {
        hr = ::StringFromTrigger(pJobTrigger, &pwsz, lpDetails);

        CHECK_HRESULT(hr);

        if (SUCCEEDED(hr))
        {
#if defined(UNICODE)
            lstrcpy(psTrigger, pwsz);
#else
            hr = UnicodeToAnsi(psTrigger, pwsz, cchTrigger);
#endif

            CoTaskMemFree(pwsz);
        }
    }
    else
    {
        LoadString(g_hInstance, IDS_JOB_NOT_SCHEDULED, psTrigger, cchTrigger);
    }

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
////////
////////    Misc functions.
////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

LPITEMIDLIST *
SHIDLFromJobIDL(
    UINT        cidl,
    PJOBID    * apjidl)
{
    LPITEMIDLIST * apidlOut = (LPITEMIDLIST *)SHAlloc(
                                            sizeof(LPITEMIDLIST) * cidl);

    if (apidlOut)
    {
        for (UINT i=0; i < cidl; i++)
        {
            apidlOut[i] = ILCreateFromPath(apjidl[i]->GetPath());

            if (apidlOut[i] == NULL)
            {
                break;
            }
        }

        if (i < cidl) // => memory error
        {
            while (i--)
            {
                ILFree(apidlOut[i]);
            }

            SHFree(apidlOut);

            apidlOut = NULL;
        }
    }

#if DBG==1
    if (apidlOut == NULL)
    {
        CHECK_HRESULT(E_OUTOFMEMORY);
    }
#endif

    return apidlOut;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\folderui\ole.cxx ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       ole.cxx
//
//  Contents:   IUnknown & IClassFactory for all OLE objects
//
//  History:    1/4/1996   RaviR   Created
//
//____________________________________________________________________________

#include "..\pch\headers.hxx"
#pragma hdrstop

#include "dbg.h"
#include "macros.h"
#include "guids.h"
#include "dll.hxx"
#include <mstask.h>     // Necessary for util.hxx/schedui.hxx inclusion.
#include "util.hxx"
#include "..\schedui\schedui.hxx"


//____________________________________________________________________________
//
//  Class:      CJobFolderCF
//
//  Purpose:    Class factory to create CJobFolder.
//
//  History:    1/24/1996   RaviR   Created
//____________________________________________________________________________


class CJobFolderCF : public IClassFactory
{
public:
    // IUnknown methods
    DECLARE_IUNKNOWN_METHODS;

    // IClassFactory methods
    STDMETHOD(CreateInstance)(IUnknown* pUnkOuter, REFIID riid, LPVOID* ppvObj);
    STDMETHOD(LockServer)(BOOL fLock);
};

STDMETHODIMP
CJobFolderCF::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    if (IsEqualIID(IID_IUnknown, riid) ||
        IsEqualIID(IID_IClassFactory, riid))
    {
        *ppvObj = (IUnknown*)(IClassFactory*) this;
        this->AddRef();
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG)
CJobFolderCF::AddRef()
{
    return CDll::AddRef();
}

STDMETHODIMP_(ULONG)
CJobFolderCF::Release()
{
    return CDll::Release();
}

STDMETHODIMP
CJobFolderCF::CreateInstance(IUnknown* pUnkOuter, REFIID riid, LPVOID* ppvObj)
{
    if (pUnkOuter != NULL)
    {
        return E_NOTIMPL;  // don't support aggregation
    }

    return JFGetJobFolder(riid, ppvObj);
}

STDMETHODIMP
CJobFolderCF::LockServer(BOOL fLock)
{
    CDll::LockServer(fLock);

    return S_OK;
}



//____________________________________________________________________________
//
//  Class:      CSchedObjExtCF
//
//  Purpose:    Class factory to create CSchedObjExt.
//
//  History:    4/25/1996   RaviR   Created
//____________________________________________________________________________


class CSchedObjExtCF : public IClassFactory
{
public:
    // IUnknown methods
    DECLARE_IUNKNOWN_METHODS;

    // IClassFactory methods
    STDMETHOD(CreateInstance)(IUnknown* pUnkOuter, REFIID riid, LPVOID* ppvObj);
    STDMETHOD(LockServer)(BOOL fLock);
};

STDMETHODIMP
CSchedObjExtCF::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    if (IsEqualIID(IID_IUnknown, riid) ||
        IsEqualIID(IID_IClassFactory, riid))
    {
        *ppvObj = (IUnknown*)(IClassFactory*) this;
        this->AddRef();
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG)
CSchedObjExtCF::AddRef()
{
    return CDll::AddRef();
}

STDMETHODIMP_(ULONG)
CSchedObjExtCF::Release()
{
    return CDll::Release();
}

STDMETHODIMP
CSchedObjExtCF::CreateInstance(IUnknown* pUnkOuter, REFIID riid, LPVOID* ppvObj)
{
    if (pUnkOuter != NULL)
    {
        return E_NOTIMPL;  // don't support aggregation
    }

    return JFGetSchedObjExt(riid, ppvObj);
}

STDMETHODIMP
CSchedObjExtCF::LockServer(BOOL fLock)
{
    CDll::LockServer(fLock);

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////


JF_IMPLEMENT_CLASSFACTORY(CTaskIconExt);

STDMETHODIMP
CTaskIconExtCF::CreateInstance(IUnknown* pUnkOuter, REFIID riid, LPVOID* ppvObj)
{
    if (pUnkOuter != NULL)
    {
        return E_NOTIMPL;  // don't support aggregation
    }

    return JFGetTaskIconExt(riid, ppvObj);
}



//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

CJobFolderCF   * pcfJobFolder   = NULL;
CSchedObjExtCF * pcfSchedObjExt = NULL;
CTaskIconExtCF * pcfTaskIconExt = NULL;

HRESULT
JFGetClassObject(
    REFCLSID cid,
    REFIID   riid,
    LPVOID * ppvObj)
{
    CDllRef DllRef;   // don't nuke me now!

    if (IsEqualCLSID(cid, CLSID_CJobFolder))
    {
        if (pcfJobFolder != NULL)
        {
            return pcfJobFolder->QueryInterface(riid, ppvObj);
        }
        else
        {
            return E_FAIL;
        }
    }
    else if (IsEqualCLSID(cid, CLSID_CSchedObjExt))
    {
        if (pcfSchedObjExt != NULL)
        {
            return pcfSchedObjExt->QueryInterface(riid, ppvObj);
        }
        else
        {
            return E_FAIL;
        }
    }
    else if (IsEqualCLSID(cid, CLSID_CTaskIconExt))
    {
        if (pcfTaskIconExt != NULL)
        {
            return pcfTaskIconExt->QueryInterface(riid, ppvObj);
        }
        else
        {
            return E_FAIL;
        }
    }

    return E_NOINTERFACE;
}

HRESULT
AllocFolderCFs(void)
{
    pcfJobFolder = new CJobFolderCF;
    if (pcfJobFolder == NULL)
    {
        return E_OUTOFMEMORY;
    }
    pcfSchedObjExt = new CSchedObjExtCF;
    if (pcfSchedObjExt == NULL)
    {
        delete pcfJobFolder;
        pcfJobFolder = NULL;
        return E_OUTOFMEMORY;
    }
    pcfTaskIconExt = new CTaskIconExtCF;
    if (pcfTaskIconExt == NULL)
    {
        delete pcfJobFolder;
        pcfJobFolder = NULL;
        delete pcfSchedObjExt;
        pcfSchedObjExt = NULL;
        return E_OUTOFMEMORY;
    }
    return S_OK;
}

void
FreeFolderCFs(void)
{
    if (pcfJobFolder != NULL)
    {
        delete pcfJobFolder;
        pcfJobFolder = NULL;
    }
    if (pcfSchedObjExt != NULL)
    {
        delete pcfSchedObjExt;
        pcfSchedObjExt = NULL;
    }
    if (pcfTaskIconExt != NULL)
    {
        delete pcfTaskIconExt;
        pcfTaskIconExt = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\folderui\menu.cxx ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       menu.hxx
//
//  Contents:   Declaration of CJobsCM, implementing IContextMenu
//
//  Classes:
//
//  Functions:
//
//  History:    1/4/1996   RaviR   Created
//
//____________________________________________________________________________


#include "..\pch\headers.hxx"
#pragma hdrstop

#include "dbg.h"
#include "macros.h"
#include <misc.hxx>     // ARRAY_LEN
#include "policy.hxx"

#include "resource.h"
#include "jobidl.hxx"
#include "util.hxx"
#include "dll.hxx"
#include "..\schedui\schedui.hxx"
#include "..\schedui\dlg.hxx"
#include "..\wizard\wizpage.hxx"
#include "..\wizard\taskwiz.hxx"

//
// extern
//

extern HINSTANCE g_hInstance;


HRESULT
JFGetDataObject(
    LPCTSTR         pszFolderPath,
    LPCITEMIDLIST   pidlFolder,
    UINT            cidl,
    LPCITEMIDLIST * apidl,
    BOOL            fCut,
    LPVOID        * ppvObj);


HRESULT
JFOpenPropSheet(
    LPDATAOBJECT pdtobj,
    LPTSTR       pszCaption);


HRESULT
GetSchSvcState(
    DWORD &dwCurrState);


HRESULT
StartScheduler(void);


HRESULT
PauseScheduler(
    BOOL fPause);

BOOL
UserCanChangeService(
    LPCTSTR ptszServer);

HRESULT
PromptForServiceStart(
    HWND hwnd);


//____________________________________________________________________________
//
//  Class:      CJobsCM
//
//  Purpose:    Provide IContextMenu interface to Job Folder objects.
//
//  History:    1/24/1996   RaviR   Created
//____________________________________________________________________________

class CJobsCM : public IContextMenu
{
public:
    CJobsCM(
        HWND hwnd,
        ITaskScheduler *pScheduler,
        LPCTSTR ptszMachine);

    HRESULT
    InitInstance(
        LPCTSTR pszFolderPath,
        LPCITEMIDLIST pidlFolder,
        UINT cidl,
        LPCITEMIDLIST* apidl);

    ~CJobsCM();

    // IUnknown methods
    DECLARE_STANDARD_IUNKNOWN;

    // IContextMenu methods
    STDMETHOD(QueryContextMenu)(HMENU hmenu, UINT indexMenu, UINT idCmdFirst,
                            UINT idCmdLast, UINT uFlags);
    STDMETHOD(InvokeCommand)(LPCMINVOKECOMMANDINFO lpici);
    STDMETHOD(GetCommandString)(UINT_PTR idCmd, UINT uType, UINT *pwReserved,
                            LPSTR pszName, UINT cchMax);
private:
    HRESULT _RunJob(CJobID & jid);
    HRESULT _AbortJob(CJobID & jid);
    HRESULT _DeleteJobs(void);
    HRESULT _DisplayJobProperties(HWND hwnd, CJobID & jid);

    LPCTSTR            m_pszFolderPath;
    LPITEMIDLIST       m_pidlFolder;
    UINT               m_cidl;
    LPITEMIDLIST  *    m_apidl;
    HWND               m_hwnd;
    ITaskScheduler *   m_pScheduler;
    LPCTSTR            m_ptszMachine;
};



inline
CJobsCM::CJobsCM(
    HWND hwnd,
    ITaskScheduler *pScheduler,
    LPCTSTR ptszMachine):
        m_ulRefs(1),
        m_hwnd(hwnd),
        m_cidl(0),
        m_apidl(NULL),
        m_pScheduler(pScheduler),
        m_ptszMachine(ptszMachine),
        m_pidlFolder(NULL),
        m_pszFolderPath(NULL)
{
    TRACE(CJobsCM, CJobsCM);
}




//____________________________________________________________________________
//
//  Member:     CJobsCM::~CJobsCM, Destructor
//
//  History:    1/8/1996   RaviR   Created
//____________________________________________________________________________

CJobsCM::~CJobsCM()
{
    TRACE(CJobsCM, ~CJobsCM);

    ILA_Free(m_cidl, m_apidl);
    ILFree(m_pidlFolder);

    m_cidl = 0;
    m_apidl = NULL;

    // Don't do a release on pScheduler, since this object never
    // increased its ref count.
}


//____________________________________________________________________________
//
//  Member:     IUnknown methods
//____________________________________________________________________________

IMPLEMENT_STANDARD_IUNKNOWN(CJobsCM);


STDMETHODIMP
CJobsCM::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    if (IsEqualIID(IID_IUnknown, riid) ||
        IsEqualIID(IID_IContextMenu, riid))
    {
        *ppvObj = (IUnknown*)(IContextMenu*) this;
        this->AddRef();
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}




//____________________________________________________________________________
//
//  Member:     CJobsCM::InitInstance
//
//  Synopsis:   S
//
//  Arguments:  [cidl] -- IN
//              [apidl] -- IN
//
//  Returns:    HRESULT.
//
//  History:    1/8/1996   RaviR   Created
//
//____________________________________________________________________________

HRESULT
CJobsCM::InitInstance(
    LPCTSTR pszFolderPath,
    LPCITEMIDLIST pidlFolder,
    UINT cidl,
    LPCITEMIDLIST* apidl)
{
    TRACE(CJobsCM, InitInstance);

    HRESULT     hr = S_OK;

    m_pszFolderPath = pszFolderPath;
    m_cidl = cidl;
    m_apidl = ILA_Clone(cidl, apidl);

    if (!m_apidl)
    {
        hr = E_OUTOFMEMORY;
        CHECK_HRESULT(hr);
        return hr;
    }

    m_pidlFolder = ILClone(pidlFolder);

    if (!m_pidlFolder)
    {
        ILA_Free(m_cidl, m_apidl);
        m_cidl = 0;
        m_apidl = NULL;
        hr = E_OUTOFMEMORY;
        CHECK_HRESULT(hr);
        return hr;
    }
    return S_OK;
}



//____________________________________________________________________________
//
//  Member:     CJobsCM::QueryContextMenu
//
//  Synopsis:   Same as IContextMenu::QueryContextMenu
//
//  Arguments:  [hmenu] -- IN
//              [indexMenu] -- IN
//              [idCmdFirst] -- IN
//              [idCmdLast] -- IN
//              [uFlags] -- IN
//
//  Returns:    STDMETHODIMP
//
//  History:    1/8/1996   RaviR   Created
//
//____________________________________________________________________________

STDMETHODIMP
CJobsCM::QueryContextMenu(
    HMENU hmenu,
    UINT indexMenu,
    UINT idCmdFirst,
    UINT idCmdLast,
    UINT uFlags)
{
    TRACE(CJobsCM, QueryContextMenu);
    DEBUG_OUT((DEB_TRACE, "QueryContextMenu<uFlags=%d>\n", uFlags));

    QCMINFO qcm = {hmenu, indexMenu, idCmdFirst, idCmdLast};
    BOOL fRunning = FALSE; // selected objects include running object
    BOOL fTemplate = FALSE; // selected objects include template object
    UINT i;

    for (i=0; i < m_cidl; i++)
    {
        PJOBID pjid = (PJOBID)m_apidl[i];

        if (pjid->IsTemplate())
        {
            fTemplate = TRUE;
        }

        if (pjid->IsRunning())
        {
            fRunning = TRUE;
        }
    }

    if (fTemplate)
    {
        UtMergeMenu(g_hInstance,
                    POPUP_JOB_TEMPLATE,
                    0,
                    (LPQCMINFO)&qcm);
        SetMenuDefaultItem(hmenu, idCmdFirst + CMIDM_OPEN, FALSE);
    }
    else
    {
        UtMergeMenu(g_hInstance,
                    (uFlags & CMF_DVFILE) ? POPUP_JOB_VERBS_ONLY : POPUP_JOB,
                    0,
                    (LPQCMINFO)&qcm);

        UINT uEnable = (m_cidl > 1) ? (MF_GRAYED | MF_BYCOMMAND)
                                    : (MF_ENABLED | MF_BYCOMMAND);

        EnableMenuItem(hmenu, idCmdFirst + CMIDM_PROPERTIES, uEnable);


        uEnable = (fRunning == TRUE) ? (MF_ENABLED | MF_BYCOMMAND)
                                     : (MF_GRAYED | MF_BYCOMMAND);

        EnableMenuItem(hmenu, idCmdFirst + CMIDM_ABORT, uEnable);

        //
        // We are trying to prevent the "RUN" command
        // from being available if the job is already running
        //  -- okay b/c we only permit one running instance at a time
        //
        // Note, that as in the above (abort enable) we have about
        // a second's worth of delay between when we fire off the
        // run command and when the service actually updates the
        // state of the job object itself, permitting us to make the
        // right choice.  We've always had this with "End Task" and
        // it has so far been okay.
        //

        uEnable = (fRunning == FALSE) ? (MF_ENABLED | MF_BYCOMMAND)
                                      : (MF_GRAYED | MF_BYCOMMAND);

        EnableMenuItem(hmenu, idCmdFirst + CMIDM_RUN, uEnable);

        //
        // Policy - user can control the ui
        //

        if (RegReadPolicyKey(TS_KEYPOLICY_DENY_DELETE))
        {
            // Do not permit the removal of tasks

            EnableMenuItem(hmenu, idCmdFirst + CMIDM_DELETE,
                                    (MF_GRAYED | MF_BYCOMMAND));
            EnableMenuItem(hmenu, idCmdFirst + CMIDM_CUT,
                                    (MF_GRAYED | MF_BYCOMMAND));
            EnableMenuItem(hmenu, idCmdFirst + CMIDM_RENAME,
                                    (MF_GRAYED | MF_BYCOMMAND));
        }
            if (RegReadPolicyKey(TS_KEYPOLICY_DENY_CREATE_TASK))
        {
            // Do not allow tasks to be created (new name)

            EnableMenuItem(hmenu, idCmdFirst + CMIDM_RENAME,
                                    (MF_GRAYED | MF_BYCOMMAND));
        }
        if (RegReadPolicyKey(TS_KEYPOLICY_DENY_DRAGDROP))
        {
            // Prevent any drag-drop type operations/clipboard stuff

            EnableMenuItem(hmenu, idCmdFirst + CMIDM_CUT,
                                    (MF_GRAYED | MF_BYCOMMAND));
            EnableMenuItem(hmenu, idCmdFirst + CMIDM_COPY,
                                    (MF_GRAYED | MF_BYCOMMAND));
            EnableMenuItem(hmenu, idCmdFirst + CMIDM_RENAME,
                                    (MF_GRAYED | MF_BYCOMMAND));
        }
        if (RegReadPolicyKey(TS_KEYPOLICY_DENY_PROPERTIES))
        {
            // Do not allow access to property pages

            EnableMenuItem(hmenu, idCmdFirst + CMIDM_PROPERTIES,
                                    (MF_GRAYED | MF_BYCOMMAND));
        }
        if (RegReadPolicyKey(TS_KEYPOLICY_DENY_EXECUTION))
        {
            // Do not allow users to run or stop a job

            EnableMenuItem(hmenu, idCmdFirst + CMIDM_RUN,
                                    (MF_GRAYED | MF_BYCOMMAND));
            EnableMenuItem(hmenu, idCmdFirst + CMIDM_ABORT,
                                    (MF_GRAYED | MF_BYCOMMAND));
        }

        SetMenuDefaultItem(hmenu, idCmdFirst + CMIDM_PROPERTIES, FALSE);
    }


    return ResultFromShort(qcm.idCmdFirst - idCmdFirst);
}

//____________________________________________________________________________
//
//  Member:     CJobsCM::InvokeCommand
//
//  Synopsis:   Same as IContextMenu::InvokeCommand
//
//  Arguments:  [lpici] -- IN
//
//  Returns:    STDMETHODIMP
//
//  History:    1/8/1996   RaviR   Created
//
//____________________________________________________________________________

STDMETHODIMP
CJobsCM::InvokeCommand(
    LPCMINVOKECOMMANDINFO lpici)
{
    TRACE(CJobsCM, InvokeCommand);

    HRESULT hr = S_OK;
    UINT i;
    UINT idCmd;

    if (HIWORD(lpici->lpVerb))
    {
        // Deal with string commands
        PSTR pszCmd = (PSTR)lpici->lpVerb;

        if (0 == lstrcmpA(pszCmd, "delete"))
        {
            idCmd = CMIDM_DELETE;
        }
        else if (0 == lstrcmpA(pszCmd, "properties"))
        {
            idCmd = CMIDM_PROPERTIES;
        }
        else if (0 == lstrcmpA(pszCmd, "cut"))
        {
            idCmd = CMIDM_CUT;
        }
        else if (0 == lstrcmpA(pszCmd, "copy"))
        {
            idCmd = CMIDM_COPY;
        }
        else if (0 == lstrcmpA(pszCmd, "rename"))
        {
            idCmd = CMIDM_RENAME;
        }
        else
        {
            DEBUG_OUT((DEB_ERROR, "Unprocessed InvokeCommand<%s>\n", pszCmd));
            return E_INVALIDARG;
        }
    }
    else
    {
        idCmd = LOWORD(lpici->lpVerb);
    }

    switch(idCmd)
    {
    case CMIDM_DELETE:
    {
        hr = _DeleteJobs();
        break;
    }

    case CMIDM_PROPERTIES:
        Win4Assert(m_cidl == 1);
        hr = _DisplayJobProperties(m_hwnd, *((PJOBID)m_apidl[0]));
        break;

    case CMIDM_CUT:
    case CMIDM_COPY:
    {
        LPDATAOBJECT pdobj = NULL;

        hr = JFGetDataObject(m_pszFolderPath,
                             m_pidlFolder,
                             m_cidl,
                             (LPCITEMIDLIST *)m_apidl,
                             (idCmd == CMIDM_CUT),
                             (void **)&pdobj);
        if (SUCCEEDED(hr))
        {
            hr = OleSetClipboard(pdobj);

            CHECK_HRESULT(hr);
        }

        pdobj->Release();

        if (idCmd == CMIDM_CUT)
        {
            ShellFolderView_SetClipboard(m_hwnd, DFM_CMD_MOVE);
        }

        break;
    }
    case CMIDM_RUN:
    {
        if (UserCanChangeService(m_ptszMachine))
        {
            hr = PromptForServiceStart(m_hwnd);
        }

        if (hr != S_OK)
        {
            break;
        }

        for (i=0; i < m_cidl; i++)
        {
            hr = _RunJob(*((PJOBID)m_apidl[i]));
        }

        break;
    }
    case CMIDM_ABORT:
    {
        for (i=0; i < m_cidl; i++)
        {
            PJOBID pjid = (PJOBID)m_apidl[i];

            if (pjid->IsRunning() == TRUE)
            {
                hr = _AbortJob(*((PJOBID)m_apidl[i]));
            }
        }

        break;
    }
    case CMIDM_OPEN:
        (void) CTaskWizard::Launch(m_pszFolderPath, m_pidlFolder);
        break;

    default:
        return E_FAIL;
    }

    return hr;
}


//____________________________________________________________________________
//
//  Member:     CJobsCM::GetCommandString
//
//  Synopsis:   Same as IContextMenu::GetCommandString
//
//  Arguments:  [idCmd] -- IN
//              [uType] -- IN
//              [pwReserved] -- IN
//              [pszName] -- IN
//              [cchMax] -- IN
//
//  Returns:    STDMETHODIMP
//
//  History:    1/8/1996   RaviR   Created
//
//____________________________________________________________________________

STDMETHODIMP
CJobsCM::GetCommandString(
    UINT_PTR    idCmd,
    UINT        uType,
    UINT      * pwReserved,
    LPSTR       pszName,
    UINT        cchMax)
{
    TRACE(CJobsCM, GetCommandString);

#if DBG==1
    char * aType[] = {"GCS_VERBA", "GCS_HELPTEXTA", "GCS_VALIDATEA", "Unused",
                    "GCS_VERBW", "GCS_HELPTEXTW", "GCS_VALIDATEW", "UNICODE"};

    DEBUG_OUT((DEB_TRACE, "GetCommandString<id,type,name> = <%d, %d, %s>\n",
               idCmd, uType, aType[uType]));
#endif // DBG==1


    *((LPTSTR)pszName) = TEXT('\0');

    if (uType == GCS_HELPTEXT)
    {
        LoadString(g_hInstance, (UINT)idCmd + IDS_MH_FSIDM_FIRST, (LPTSTR)pszName,
                                                                      cchMax);
        return S_OK;
    }
    if (uType == GCS_VERB && idCmd == CMIDM_RENAME)
    {
        // "rename" is language independent
        lstrcpy((LPTSTR)pszName, TEXT("rename"));

        return S_OK;
    }

    return E_FAIL;
}


//____________________________________________________________________________
//
//  Member:     CJobsCM::_RunJob
//
//  Arguments:  [hwnd] -- IN
//              [jid] -- IN
//
//  Returns:    HRESULT.
//
//  History:    1/12/1996   RaviR   Created
//
//____________________________________________________________________________

HRESULT
CJobsCM::_RunJob(
    CJobID & jid)
{
    TRACE(CJobsCM, _RunJob);

    ITask  * pJob = NULL;

    TCHAR tcJob[MAX_PATH];

    lstrcpy(tcJob, jid.GetPath());
    lstrcat(tcJob, TSZ_DOTJOB);

    HRESULT hr = ::JFCreateAndLoadTask(m_pszFolderPath, tcJob, &pJob);

    if (SUCCEEDED(hr))
    {
        hr = pJob->Run();

        CHECK_HRESULT(hr);

        pJob->Release();
    }

    return hr;
}

//____________________________________________________________________________
//
//  Member:     CJobsCM::_AbortJob
//
//  Arguments:  [hwnd] -- IN
//              [jid] -- IN
//
//  Returns:    HRESULT.
//
//  History:    1/12/1996   RaviR   Created
//
//____________________________________________________________________________

HRESULT
CJobsCM::_AbortJob(
    CJobID & jid)
{
    TRACE(CJobsCM, _AbortJob);

    ITask  * pJob = NULL;

    TCHAR tcJob[MAX_PATH];

    lstrcpy(tcJob, jid.GetPath());
    lstrcat(tcJob, TSZ_DOTJOB);

    HRESULT hr = ::JFCreateAndLoadTask(m_pszFolderPath, tcJob, &pJob);

    if (SUCCEEDED(hr))
    {
        hr = pJob->Terminate();

        CHECK_HRESULT(hr);

        pJob->Release();
    }

    return hr;
}


//____________________________________________________________________________
//
//  Member:     CJobsCM::_DeleteJobs
//
//  Arguments:  [hwnd] -- IN
//              [pwszJob] -- IN
//
//  Returns:    HRESULT.
//
//  History:    1/11/1996   RaviR   Created
//
//____________________________________________________________________________

HRESULT
CJobsCM::_DeleteJobs(void)
{
    TRACE(CJobsCM, _DeleteJobs);

    PJOBID pjid = NULL;
    UINT   cchReqd = 0;


    //
    // Policy - if DELETE flag set, cannot remove jobs
    //

    if (RegReadPolicyKey(TS_KEYPOLICY_DENY_DELETE))
    {
        return E_FAIL;
    }

    //
    // First compute buffer size for pFrom.
    //

    // Each file full path is composed as:
    //       FolderPath + \ + job path rel to fldr + extn + null
    //
    // Only <job path rel to fldr> differs for each. (Assuming extension
    //       length is always 4 <.job, .que>)

    for (UINT i=0; i < m_cidl; i++)
    {
        pjid = (PJOBID)m_apidl[i];

        cchReqd += lstrlen(pjid->GetPath());
    }

    cchReqd += (lstrlen(m_pszFolderPath) + 1 + ARRAY_LEN(TSZ_DOTJOB)) *
                                                                    m_cidl;
    // one for the extra null at the end
    ++cchReqd;

    LPTSTR pFrom = new TCHAR[cchReqd];

    if (pFrom == NULL)
    {
        CHECK_HRESULT(E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }

    UINT ufldrPathLen = lstrlen(m_pszFolderPath);
    LPTSTR pCur = pFrom;

    for (i=0; i < m_cidl; i++)
    {
        pjid = (PJOBID)m_apidl[i];

        lstrcpy(pCur, m_pszFolderPath);
        pCur += ufldrPathLen;

        *pCur++ = TEXT('\\');

        lstrcpy(pCur, pjid->GetPath());
        lstrcat(pCur, pjid->GetExtension());

        pCur += lstrlen(pCur) + 1;
    }

    // Make sure we have double trailing NULL!
    *pCur = TEXT('\0');

    SHFILEOPSTRUCT fo;

    fo.hwnd = m_hwnd;
    fo.wFunc = FO_DELETE;
    fo.pFrom = pFrom;
    fo.pTo = NULL;
    fo.fFlags = FOF_ALLOWUNDO;
    fo.fAnyOperationsAborted = FALSE;
    fo.hNameMappings = NULL;
    fo.lpszProgressTitle = NULL;

    HRESULT hr = S_OK;

    if ((SHFileOperation(&fo) !=0) || fo.fAnyOperationsAborted == TRUE)
    {
        hr = E_FAIL;
        CHECK_HRESULT(hr);
    }

    delete pFrom;

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
//
//  Display properties
//


// from ..\ps\jobpages.cxx
HRESULT
DisplayJobProperties(
    LPDATAOBJECT    pdtobj);


DWORD
__stdcall
JFPropertiesThread(
    LPVOID pvData)
{
    LPDATAOBJECT pdtobj = (LPDATAOBJECT)pvData;

    HRESULT hrOle = OleInitialize(NULL);

    __try
    {
        if (SUCCEEDED(hrOle))
        {
            ::DisplayJobProperties(pdtobj);
        }
    }
    __finally
    {
        pdtobj->Release();

        if (SUCCEEDED(hrOle))
        {
            OleUninitialize();
        }

        ExitThread(0);
    }

    return 0;
}


//____________________________________________________________________________
//
//  Member:     CJobsCM::_DisplayJobProperties
//
//  Arguments:  [hwnd] -- IN
//              [pwszJob] -- IN
//
//  Returns:    HRESULT.
//
//  History:    1/11/1996   RaviR   Created
//
//____________________________________________________________________________

HRESULT
CJobsCM::_DisplayJobProperties(
    HWND    hwnd,
    CJobID & jid)
{
    TRACE(CJobsCM, _DisplayJobProperties);

    Win4Assert(m_cidl == 1);

    HRESULT         hr = S_OK;
    LPDATAOBJECT    pdtobj = NULL;

    do
    {
        hr = JFGetDataObject(m_pszFolderPath,
                             m_pidlFolder,
                             m_cidl,
                             (LPCITEMIDLIST *)m_apidl,
                             FALSE,
                             (LPVOID *)&pdtobj);

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

        HANDLE  hThread;
        DWORD   idThread;

        hThread = CreateThread(NULL, 0, JFPropertiesThread,
                                                pdtobj, 0, &idThread);

        if (hThread)
        {
            CloseHandle(hThread);
        }
        else
        {
            pdtobj->Release();
        }

    } while (0);

    return hr;
}


//____________________________________________________________________________
//
//  Function:   JFGetItemContextMenu
//
//  Synopsis:   S
//
//  Arguments:  [hwnd] -- IN
//              [pScheduler] -- IN
//              [cidl] -- IN
//              [apidl] -- IN
//              [ppvOut] -- OUT
//
//  Returns:    HRESULT
//
//  History:    1/25/1996   RaviR   Created
//____________________________________________________________________________

HRESULT
JFGetItemContextMenu(
    HWND hwnd,
    ITaskScheduler * pScheduler,
    LPCTSTR ptszMachine,
    LPCTSTR pszFolderPath,
    LPCITEMIDLIST pidlFolder,
    UINT cidl,
    LPCITEMIDLIST* apidl,
    LPVOID * ppvOut)
{
    CJobsCM* pObj = new CJobsCM(hwnd, pScheduler, ptszMachine);

    if (NULL == pObj)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pObj->InitInstance(pszFolderPath, pidlFolder, cidl, apidl);

    if (SUCCEEDED(hr))
    {
        hr = pObj->QueryInterface(IID_IContextMenu, ppvOut);
    }

    pObj->Release();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\folderui\macros.h ===
#define ARRAYLEN(a) (sizeof(a) / sizeof((a)[0]))

#define BREAK_ON_FAIL(hr) if (FAILED(hr)) { break; } else 1;

#define BREAK_ON_ERROR(lr) if ((lr) != ERROR_SUCCESS) { break; } else 1;

#ifndef offsetof
#define offsetof(type,field) ((size_t)&(((type*)0)->field))
#endif



//---------------------------------------------------------------
//  IUnknown
//---------------------------------------------------------------

//
//  This declares the set of IUnknown methods and is for general-purpose
//  use inside classes that inherit from IUnknown
//

#define DECLARE_IUNKNOWN_METHODS                                    \
    STDMETHOD(QueryInterface) (REFIID riid, LPVOID FAR* ppvObj);    \
    STDMETHOD_(ULONG,AddRef) (void);                                \
    STDMETHOD_(ULONG,Release) (void)

//
// This is for use in declaring non-aggregatable objects.  It declares the
// IUnknown methods and reference counter, m_ulRefs.
// m_ulRefs should be initialized to 1 in the constructor of the object
//

#define DECLARE_STANDARD_IUNKNOWN           \
    DECLARE_IUNKNOWN_METHODS;               \
    ULONG m_ulRefs

//
// NOTE:    this does NOT implement QueryInterface, which must be
//          implemented by each object
//

#define IMPLEMENT_STANDARD_IUNKNOWN(cls)                        \
    STDMETHODIMP_(ULONG) cls##::AddRef()                        \
        { return InterlockedIncrement((LONG*)&m_ulRefs); }      \
    STDMETHODIMP_(ULONG) cls##::Release()                       \
        { ULONG ulRet = InterlockedDecrement((LONG*)&m_ulRefs); \
          if (0 == ulRet) { delete this; }                      \
          return ulRet; }



//-----------------------------------------------------------------------------
//  IClassFactory
//-----------------------------------------------------------------------------

#define JF_IMPLEMENT_CLASSFACTORY(cls)                          \
    class cls##CF : public IClassFactory                        \
    {                                                           \
    public:                                                     \
        STDMETHOD(QueryInterface)(REFIID riid, LPVOID *ppvObj); \
        STDMETHOD_(ULONG,AddRef)(void);                         \
        STDMETHOD_(ULONG,Release)(void);                        \
                                                                \
        STDMETHOD(CreateInstance)(IUnknown* pUnkOuter,          \
                            REFIID riid, LPVOID* ppvObj);       \
        STDMETHOD(LockServer)(BOOL fLock);                      \
    };                                                          \
                                                                \
    STDMETHODIMP                                                \
    cls##CF::QueryInterface(REFIID riid, LPVOID* ppvObj)        \
    {                                                           \
        if (IsEqualIID(IID_IUnknown, riid) ||                   \
            IsEqualIID(IID_IClassFactory, riid))                \
        {                                                       \
            *ppvObj = (IUnknown*)(IClassFactory*) this;         \
            this->AddRef();                                     \
            return S_OK;                                        \
        }                                                       \
                                                                \
        *ppvObj = NULL;                                         \
        return E_NOINTERFACE;                                   \
    }                                                           \
                                                                \
    STDMETHODIMP_(ULONG)                                        \
    cls##CF::AddRef()                                           \
    {                                                           \
        return CDll::AddRef();                                  \
    }                                                           \
                                                                \
    STDMETHODIMP_(ULONG)                                        \
    cls##CF::Release()                                          \
    {                                                           \
        return CDll::Release();                                 \
    }                                                           \
                                                                \
    STDMETHODIMP                                                \
    cls##CF::LockServer(BOOL fLock)                             \
    {                                                           \
        CDll::LockServer(fLock);                                \
                                                                \
        return S_OK;                                            \
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\folderui\policy.cxx ===
//+---------------------------------------------------------------------------
//
//  Scheduling Agent Service
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       policy.cxx
//
//  Contents:   Functions for implementing policy checking
//
//  Classes:    None.
//
//  Functions:  RegReadPolicyKey
//
//  History:    04/23/98   CameronE   created
//
//----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "..\inc\policy.hxx"
#include "..\inc\debug.hxx"

//+---------------------------------------------------------------------------
//
//  Function:   RegReadPolicyKey
//
//  Synopsis:   Determine whether a specified policy value is in the registry
//              and is on (exists, value > 0x0).  Policy on means deny
//              the user permission to do a particular action in the UI only.
//
//  Arguments:  [lpszValue]     -- value name, appended to the base key
//
//  Returns:    BOOL - true for value > 0 (policy active)
//
//  Notes:      None.
//
//  History:    4/14/98  CameronE - created
//
//----------------------------------------------------------------------------
BOOL
RegReadPolicyKey(
                 LPCTSTR lpszValue)
{
    // TRACE_FUNCTION(RegReadPolicyKey) is too verbose
    schDebugOut((DEB_USER6, "RegReadPolicyKey\n"));
    // CODEWORK:  This function is called way too often.  See if we can cache
    // the results, or at least keep the key handle open.

    HKEY keyPolicy;
    BOOL fPolicy = FALSE;
    DWORD dwType;
    DWORD dwData;
    DWORD dwDataSize = sizeof(DWORD);

    //
    // It is possible to have a policy key under HKLM and/or HKCU
    // We assume that HKCU can shutoff what HKLM enables, but not vice
    // versa.
    //

    LONG lerr = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                              TS_KEYPOLICY_BASE,
                              0,
                              KEY_READ,
                              &keyPolicy);
	
    if (lerr == ERROR_SUCCESS)
    {
        lerr = RegQueryValueEx( keyPolicy,
                                lpszValue,
                                NULL,
                                &dwType,
                                (BYTE *) &dwData,
                                &dwDataSize);
		
        if (lerr == ERROR_SUCCESS)
        {
            if (dwType == REG_DWORD)
            {
                fPolicy = (dwData > 0);
            }
            else
            {
                schDebugOut((DEB_ITRACE, "HKLM Policy value not a DWORD!\n"));
            }
        }

        RegCloseKey(keyPolicy);
    }
	
    //
    // If HKLM policy value has shut off part of the UI on this machine,
    // return it now, so that HKCU cannot override a stricter machine policy.
    //

    if (fPolicy)
    {
        return fPolicy;
    }

	
    //
    // Otherwise, see if maybe it's just this user that can't do this task
    //
	
    lerr = RegOpenKeyEx( HKEY_CURRENT_USER,
                         TS_KEYPOLICY_BASE,
                         0,
                         KEY_READ,
                         &keyPolicy);

    dwDataSize = sizeof(DWORD);
	
    if (lerr == ERROR_SUCCESS)
    {
        lerr = RegQueryValueEx( keyPolicy,
                                lpszValue,
                                NULL,
                                &dwType,
                                (BYTE *) &dwData,
                                &dwDataSize);
		
        if (lerr == ERROR_SUCCESS)
        {
            if (dwType == REG_DWORD)
            {
                fPolicy = (dwData > 0);
            }
            else
            {
                schDebugOut((DEB_ITRACE, "HKCU Policy value not a DWORD!\n"));
            }
        }

        RegCloseKey(keyPolicy);
    }
	
    return fPolicy;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\folderui\menubg.cxx ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       menubg.cxx
//
//  Contents:   IContextMenu implementaion.
//
//  Classes:    CJobsCMBG, implementing IContextMenu for the background
//
//  Functions:
//
//  History:    1/5/1996   RaviR   Created
//
//____________________________________________________________________________

#include "..\pch\headers.hxx"
#pragma hdrstop

#include "dbg.h"
#include "macros.h"

#include "..\inc\resource.h"
#include "resource.h"
#include "jobidl.hxx"
#include "sch_cls.hxx"  // sched\inc
#include "job_cls.hxx"  // sched\inc
#include "misc.hxx"     // sched\inc
#include "policy.hxx"   // sched\inc

#include "jobfldr.hxx"
#include "util.hxx"

//
// extern
//

extern HINSTANCE g_hInstance;

HRESULT
PromptForServiceStart(
    HWND hwnd);

BOOL
UserCanChangeService(
    LPCTSTR ptszServer);

//
//  Forward declaration of local functions
//

HRESULT
JFCreateNewQueue(
    HWND    hwnd);


extern "C" UINT g_cfPreferredDropEffect;


//____________________________________________________________________________
//
//  Class:      CJobsCMBG
//
//  Purpose:    Provide IContextMenu interface to Job Folder (background).
//
//  History:    1/24/1996   RaviR   Created
//____________________________________________________________________________

class CJobsCMBG : public IContextMenu
{
public:
    CJobsCMBG(HWND hwnd, CJobFolder * pCJobFolder)
        : m_ulRefs(1), m_hwnd(hwnd), m_pCJobFolder(pCJobFolder) {}

    ~CJobsCMBG() {}

    // IUnknown methods
    DECLARE_STANDARD_IUNKNOWN;

    // IContextMenu methods
    STDMETHOD(QueryContextMenu)(HMENU hmenu, UINT indexMenu, UINT idCmdFirst,
                            UINT idCmdLast, UINT uFlags);
    STDMETHOD(InvokeCommand)(LPCMINVOKECOMMANDINFO lpici);
    STDMETHOD(GetCommandString)(UINT_PTR idCmd, UINT uType, UINT * pwReserved,
                            LPSTR pszName, UINT cchMax);

private:
    HWND            m_hwnd;
    CJobFolder    * m_pCJobFolder;
};



//____________________________________________________________________________
//
//  Member:     IUnknown methods
//____________________________________________________________________________

IMPLEMENT_STANDARD_IUNKNOWN(CJobsCMBG);


STDMETHODIMP
CJobsCMBG::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    if (IsEqualIID(IID_IUnknown, riid) ||
        IsEqualIID(IID_IContextMenu, riid))
    {
        *ppvObj = (IUnknown*)(IContextMenu*) this;
        this->AddRef();
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}


//____________________________________________________________________________
//
//  Member:     CJobsCMBG::QueryContextMenu
//
//  Arguments:  [hmenu] -- IN
//              [indexMenu] -- IN
//              [idCmdFirst] -- IN
//              [idCmdLast] -- IN
//              [uFlags] -- IN
//
//  Returns:    STDMETHODIMP
//
//  History:    1/8/1996   RaviR   Created
//
//____________________________________________________________________________

STDMETHODIMP
CJobsCMBG::QueryContextMenu(
    HMENU hmenu,
    UINT indexMenu,
    UINT idCmdFirst,
    UINT idCmdLast,
    UINT uFlags)
{
    TRACE(CJobsCMBG, QueryContextMenu);

    QCMINFO qcm = { hmenu, indexMenu, idCmdFirst, idCmdLast };

    UtMergeMenu(g_hInstance, POPUP_JOBSBG_MERGE,
                             POPUP_JOBSBG_POPUPMERGE, (LPQCMINFO)&qcm);

    return ResultFromShort(qcm.idCmdFirst - idCmdFirst);
}


HRESULT
DataObj_GetDWORD(
    IDataObject   * pdtobj,
    UINT            cf,
    DWORD         * pdwOut)
{
    STGMEDIUM medium;
    FORMATETC fmte = {(CLIPFORMAT)cf, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    HRESULT hr;

    medium.pUnkForRelease = NULL;
    medium.hGlobal = NULL;

    hr = pdtobj->GetData(&fmte, &medium);

    if (SUCCEEDED(hr))
    {
        DWORD *pdw = (DWORD *)GlobalLock(medium.hGlobal);

        if (pdw)
        {
            *pdwOut = *pdw;
            GlobalUnlock(medium.hGlobal);
        }
        else
        {
            hr = E_UNEXPECTED;
        }

        ReleaseStgMedium(&medium);
    }

    return hr;
}



//____________________________________________________________________________
//
//  Member:     CJobsCMBG::InvokeCommand
//
//  Arguments:  [lpici] -- IN
//
//  Returns:    STDMETHODIMP
//
//  History:    1/8/1996   RaviR   Created
//
//____________________________________________________________________________

STDMETHODIMP
CJobsCMBG::InvokeCommand(
    LPCMINVOKECOMMANDINFO lpici)
{
    TRACE(CJobsCMBG, InvokeCommand);

#define SORT_BY(X)  \
    case FSIDM_SORTBY##X: ShellFolderView_ReArrange(m_hwnd, COLUMN_##X); break

    UINT    idCmd;
    HRESULT hr = S_OK;

    if (HIWORD(lpici->lpVerb))
    {
        // Deal with string commands
        PSTR pszCmd = (PSTR)lpici->lpVerb;

        if (0 == lstrcmpA(pszCmd, "paste"))
        {
            idCmd = CMIDM_PASTE;
        }
        else
        {
            DEBUG_OUT((DEB_ERROR, "Unprocessed InvokeCommandBG<%s>\n", pszCmd));
            return E_INVALIDARG;
        }
    }
    else
    {
        idCmd = LOWORD(lpici->lpVerb);
    }


    switch (idCmd)
    {
    SORT_BY(NAME);
    SORT_BY(NEXTRUNTIME);
    SORT_BY(LASTRUNTIME);
    SORT_BY(SCHEDULE);
#if !defined(_CHICAGO_)
    SORT_BY(LASTEXITCODE);
    SORT_BY(CREATOR);
#endif // !defined(_CHICAGO_)

    case FSIDM_NEWJOB:
        if (UserCanChangeService(m_pCJobFolder->GetMachine()))
        {
            PromptForServiceStart(m_hwnd);
        }
        hr = m_pCJobFolder->CreateAJobForApp(NULL);
        break;

    case CMIDM_PASTE:
    {
            //
            // Policy - if cannot create a job, then
            // paste is not allowed
            //

            if (! RegReadPolicyKey(TS_KEYPOLICY_DENY_CREATE_TASK))
            {
                LPDATAOBJECT pdtobj = NULL;
                hr = OleGetClipboard(&pdtobj);

                CHECK_HRESULT(hr);
                BREAK_ON_FAIL(hr);

                // GetPreferred drop effect

                DWORD dw;
                hr = DataObj_GetDWORD(pdtobj, g_cfPreferredDropEffect, &dw);

                CHECK_HRESULT(hr);

                if (FAILED(hr))
	        {
                    dw = DROPEFFECT_COPY;
	        }

	            hr = m_pCJobFolder->CopyToFolder(pdtobj,
	                                (dw & DROPEFFECT_MOVE) ? TRUE : FALSE,
                                        FALSE, NULL);
                    pdtobj->Release();
            }
		
        break;
    }
    default:
        return E_INVALIDARG;
    }

    return hr;
}


//____________________________________________________________________________
//
//  Member:     CJobsCMBG::GetCommandString
//
//  Arguments:  [idCmd] -- IN
//              [uType] -- IN
//              [pwReserved] -- IN
//              [pszName] -- IN
//              [cchMax] -- IN
//
//  Returns:    STDMETHODIMP
//
//  History:    1/8/1996   RaviR   Created
//
//____________________________________________________________________________

STDMETHODIMP
CJobsCMBG::GetCommandString(
    UINT_PTR    idCmd,
    UINT        uType,
    UINT      * pwReserved,
    LPSTR       pszName,
    UINT        cchMax)
{
    TRACE(CJobsCMBG, GetCommandString);

#if DBG==1
    char * aType[] = {"GCS_VERBA", "GCS_HELPTEXTA", "GCS_VALIDATEA", "Unused",
                    "GCS_VERBW", "GCS_HELPTEXTW", "GCS_VALIDATEW", "UNICODE"};

    DEBUG_OUT((DEB_USER5, "GetCommandString <id,type> = <%d, %d, %s>\n",
               idCmd, uType, aType[uType]));
#endif // DBG==1

    *((LPTSTR)pszName) = TEXT('\0');

    if (uType == GCS_HELPTEXT)
    {
        LoadString(g_hInstance, (UINT)idCmd + IDS_MH_FSIDM_FIRST,
                                        (LPTSTR)pszName, cchMax);
        return S_OK;
    }

    return E_FAIL;
}



//____________________________________________________________________________
//
//  Function:   JFCreateNewQueue
//
//  Synopsis:   S
//
//  Arguments:  [hwnd] -- IN
//
//  Returns:    HRESULT
//
//  History:    3/26/1996   RaviR   Created
//
//____________________________________________________________________________

HRESULT
JFCreateNewQueue(
    HWND    hwnd)
{
    MessageBoxA(hwnd, "Creating a New Queue is NOTIMPL", "Job Folder", MB_OK);
    return S_FALSE;
}



//____________________________________________________________________________
//
//  Function:   JFGetFolderContextMenu
//
//  Synopsis:   S
//
//  Arguments:  [hwnd] -- IN
//              [riid] -- IN
//              [ppvObj] -- OUT
//
//  Returns:    HRESULT
//
//  History:    1/24/1996   RaviR   Created
//
//____________________________________________________________________________

HRESULT
JFGetFolderContextMenu(
    HWND            hwnd,
    CJobFolder    * pCJobFolder,
    LPVOID        * ppvObj)
{
    CJobsCMBG* pObj = new CJobsCMBG(hwnd, pCJobFolder);

    if (NULL == pObj)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pObj->QueryInterface(IID_IContextMenu, ppvObj);

    pObj->Release();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\folderui\prshtx.cxx ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       psx.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    2/13/1996   RaviR   Created
//
//____________________________________________________________________________

#include "..\pch\headers.hxx"
#pragma hdrstop

#include "dbg.h"
#include "macros.h"

#include "resource.h"
//#include "jobidl.hxx"
#include "util.hxx"

//
// extern
//

extern HINSTANCE g_hInstance;
#define HINST_THISDLL g_hInstance

//
//  Local constants
//

TCHAR const FAR c_szNULL[] = TEXT("");
TCHAR const FAR c_szStubWindowClass[] = TEXT("JobPropWnd");

const size_t MAX_FILE_PROP_PAGES = 32;

class CHkey
{
public:
    CHkey(void) : _h(NULL) {}
    CHkey(HKEY h) : _h(h) {}
    virtual ~CHkey() { if (_h != NULL) RegCloseKey(_h); }

    operator HKEY() { return _h; }
    HKEY * operator &() { return &_h; }

    HKEY Attach(HKEY h) { HKEY hTemp = _h; _h = h; return hTemp; }
    HKEY Detach(void) { HKEY hTemp = _h; _h = NULL; return hTemp; }

    void Close(void) { if (_h) RegCloseKey(_h); _h = NULL; }

protected:
    HKEY _h;
};



/////////////////////////////////////////////////////////////////////////////
//
//  Display properties
//


class CJFPropertyThreadData
{
public:

    static CJFPropertyThreadData * Create(LPDATAOBJECT pdtobj,
                                          LPTSTR       pszCaption);

    ~CJFPropertyThreadData()
    {
        if (_pdtobj != NULL)
        {
            _pdtobj->Release();
        }

        delete _pszCaption;
    }

    LPDATAOBJECT GetDataObject() { return _pdtobj; }
    LPTSTR GetCaption() { return _pszCaption; }

private:

    CJFPropertyThreadData() : _pdtobj(NULL), _pszCaption(NULL) {}

    LPDATAOBJECT    _pdtobj;
    LPTSTR          _pszCaption;
};


CJFPropertyThreadData *
CJFPropertyThreadData::Create(
    LPDATAOBJECT pdtobj,
    LPTSTR       pszCaption)
{
    CJFPropertyThreadData * pData = new CJFPropertyThreadData;

    if (pData == NULL)
    {
        return NULL;
    }

    pData->_pszCaption = NewDupString(pszCaption);

    if (pData->_pszCaption == NULL)
    {
        delete pData;
        return NULL;
    }

    pData->_pdtobj = pdtobj;
    pData->_pdtobj->AddRef();

    return pData;
}



DWORD
__stdcall
JFPropertiesThread(
    LPVOID pvData)
{
    CJFPropertyThreadData *pData = (CJFPropertyThreadData *)pvData;

    HRESULT hrOle = OleInitialize(NULL);

    __try
    {
        if (SUCCEEDED(hrOle))
        {
            JFOpenPropSheet(pData->GetDataObject(), pData->GetCaption());
        }
    }
    __finally
    {
        delete pData;

        if (SUCCEEDED(hrOle))
        {
            OleUninitialize();
        }

        ExitThread(0);
    }

    return 0;
}



//____________________________________________________________________________
//
//  Member:     CJobsCM::_DisplayJobProperties
//
//  Arguments:  [hwnd] -- IN
//              [pwszJob] -- IN
//
//  Returns:    HRESULT.
//
//  History:    1/11/1996   RaviR   Created
//
//____________________________________________________________________________

HRESULT
CJobsCM::_DisplayJobProperties(
    HWND    hwnd,
    CJobID & jid)
{
    TRACE_FUNCTION(DisplayJobProperties);

    Win4Assert(m_cidl == 1);

    HRESULT         hr = S_OK;
    LPDATAOBJECT    pdtobj = NULL;

    do
    {
        hr = JFGetDataObject(hwnd, m_pszFolderPath, m_cidl,
                         (LPCITEMIDLIST *)m_apidl, (LPVOID *)&pdtobj);

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

        CJFPropertyThreadData * pData = NULL;

        TCHAR tcName[MAX_PATH];

        lstrcpy(tcName, ((PJOBID)m_apidl[0])->GetName());

        LPTSTR pszExt = PathFindExtension(tcName);

        if (pszExt)
        {
            *pszExt = TEXT('\0');
        }

        pData = CJFPropertyThreadData::Create(pdtobj, tcName);

        if (pData == NULL)
        {
            hr = E_OUTOFMEMORY;
            CHECK_HRESULT(hr);
            break;
        }

        HANDLE  hThread;
        DWORD   idThread;

        hThread = CreateThread(NULL, 0, JFPropertiesThread,
                                                pData, 0, &idThread);
        if (hThread)
        {
            CloseHandle(hThread);
        }
        else
        {
            delete pData;
        }

    } while (0);

    if (pdtobj != NULL)
    {
        pdtobj->Release();
    }

    return hr;
}



//-----------------------------------------------------------------------------
//
// PSXA
//
// An array of IShellPropSheetExt interface pointers
//
//-----------------------------------------------------------------------------

struct PSXA
{
    static PSXA * Alloc(UINT count);
    static void Delete(PSXA * pPsxa);

    UINT count;
    IShellPropSheetExt *intfc[1];
};

PSXA * PSXA::Alloc(UINT count)
{
    UINT cb = sizeof(UINT) + sizeof(IShellPropSheetExt *) * count;

    PSXA * pPsxa = (PSXA *)new BYTE[cb];

    if (pPsxa != NULL)
    {
        ZeroMemory(pPsxa, cb);
    }

    return pPsxa;
}

void PSXA::Delete(PSXA * pPsxa)
{
    while (pPsxa->count--)
    {
        if (pPsxa->intfc[pPsxa->count] != NULL)
        {
            pPsxa->intfc[pPsxa->count]->Release();
        }
    }

    delete [] ((LPBYTE)pPsxa);
}

HRESULT
GetHkeyForJobObject(
    HKEY * phkey)
{
    //
    //  Get ProgID for .job files. Get an HKEY for this ProgID.
    //

    LRESULT lr = ERROR_SUCCESS;

    do
    {
        HKEY hkey = NULL;

        lr = RegOpenKeyEx(HKEY_CLASSES_ROOT, TSZ_DOTJOB, 0,
                                                KEY_QUERY_VALUE, &hkey);
        if (lr != ERROR_SUCCESS)
        {
            CHECK_LASTERROR(lr);
            break;
        }

        DWORD dwType = 0;
        TCHAR buff[200];
        ULONG cb = sizeof(buff);

        lr = RegQueryValueEx(hkey, NULL, NULL, &dwType, (LPBYTE)buff, &cb);

        RegCloseKey(hkey);

        if (lr != ERROR_SUCCESS)
        {
            CHECK_LASTERROR(lr);
            break;
        }

        hkey = NULL; // reset

        lr = RegOpenKeyEx(HKEY_CLASSES_ROOT, buff, 0, KEY_READ, &hkey);

        if (lr != ERROR_SUCCESS)
        {
            CHECK_LASTERROR(lr);
            break;
        }

        *phkey = hkey;

    } while (0);

    return HRESULT_FROM_WIN32(lr);
}

LPTSTR
I_GetWord(
    LPTSTR psz)
{
    static TCHAR * s_psz = NULL;

    if (psz != NULL)
    {
        s_psz = psz;
    }

    psz = s_psz;

    // skip the space or comma characters
    while (*psz == TEXT(' ') || *psz == TEXT(',')) { ++psz; }

    s_psz = psz;

    while (*s_psz != TEXT('\0'))
    {
        if (*s_psz == TEXT(' ') || *s_psz == TEXT(','))
        {
            *s_psz = TEXT('\0');
            ++s_psz;
            break;
        }

        ++s_psz;
    }

    return psz;
}


inline
HRESULT
I_CLSIDFromString(
    LPTSTR  pszClsid,
    LPCLSID pclsid)
{
#ifdef UNICODE
    return CLSIDFromString(pszClsid, pclsid);
#else
    WCHAR wBuff[64];
    HRESULT hr = AnsiToUnicode(wBuff, pszClsid, 64);

    if (FAILED(hr))
    {
        return hr;
    }
    return CLSIDFromString(wBuff, pclsid);
#endif
}


inline
BOOL
I_IsPresent(
    CLSID   aclsid[],
    UINT    count)
{
    for (UINT i=0; i < count; i++)
    {
        if (IsEqualCLSID(aclsid[i], aclsid[count]))
        {
            return TRUE;
        }
    }

    return FALSE;
}


HRESULT
GetPropSheetExtArray(
    HKEY    hkeyIn,
    PSXA ** ppPsxa)
{
    *ppPsxa = NULL; // init

    //
    //  From HKEY determine the clsids. Bind to each clsid
    //  and get the IShellPropSheetExt interface ptrs.
    //

    HRESULT hr = S_OK;
    LRESULT lr = ERROR_SUCCESS;
    CHkey   hkey;
    UINT    count = 0;
    CLSID   aclsid[20];
    TCHAR   szClsid[64];
    ULONG   SIZEOF_SZCLSID = sizeof(szClsid);

    do
    {
        TCHAR buff[MAX_PATH * 2];
        ULONG SIZEOF_BUFF = sizeof(buff);
        ULONG cb = SIZEOF_BUFF;

        lr = RegOpenKeyEx(hkeyIn, STRREG_SHEX_PROPSHEET, 0, KEY_READ, &hkey);

        BREAK_ON_ERROR(lr);

        lr = RegQueryValueEx(hkey, NULL, NULL, NULL, (LPBYTE)buff, &cb);

        CHECK_LASTERROR(lr);

        if (lr == ERROR_SUCCESS & cb > 0)
        {
            LPTSTR psz = I_GetWord(buff);
            CHkey  hkeyTemp = NULL;

            while (*psz != TEXT('\0'))
            {
                hkeyTemp.Close();

                lr = RegOpenKeyEx(hkey, psz, 0, KEY_READ, &hkeyTemp);

                BREAK_ON_ERROR(lr);

                cb = SIZEOF_SZCLSID;

                lr = RegQueryValueEx(hkeyTemp, NULL, NULL, NULL,
                                            (LPBYTE)szClsid, &cb);
                BREAK_ON_ERROR(lr);

                hr = I_CLSIDFromString(szClsid, &aclsid[count]);

                BREAK_ON_FAIL(hr);

                ++count;

                psz = I_GetWord(NULL);
            }
        }


        for (int i=0; ; i++)
        {
            cb = SIZEOF_SZCLSID;

            lr = RegEnumKeyEx(hkey, i, szClsid, &cb,
                                        NULL, NULL, NULL, NULL);
            BREAK_ON_ERROR(lr);

            // Is it a classid?
            hr = I_CLSIDFromString(szClsid, &aclsid[count]);

            if (FAILED(hr)) // no - see if the value is a classid
            {
                CHkey hkey3;

                lr = RegOpenKeyEx(hkey, szClsid, 0, KEY_READ, &hkey3);

                if (lr == ERROR_SUCCESS)
                {
                    cb = SIZEOF_SZCLSID;

                    lr = RegQueryValueEx(hkey3, NULL, NULL, NULL,
                                            (LPBYTE)szClsid, &cb);
                    if (lr == ERROR_SUCCESS)
                    {
                        hr = I_CLSIDFromString(szClsid, &aclsid[count]);
                    }
                }
            }

            if (SUCCEEDED(hr))
            {
                // is it already present ?
                if (I_IsPresent(aclsid, count) == FALSE)
                {
                    ++count;
                }
            }
        }

    } while (0);

    if (count <= 0)
    {
        DEBUG_OUT((DEB_USER1, "No pages to display.\n"));
        return E_FAIL;
    }

    do
    {
        //
        //  Now create the IShellPropSheetExt interface ptrs.
        //

        PSXA * pPsxa = PSXA::Alloc(count);

        if (pPsxa == NULL)
        {
            hr = E_OUTOFMEMORY;
            CHECK_HRESULT(hr);
            break;
        }

        for (UINT k=0; k < count; k++)
        {
            hr = CoCreateInstance(aclsid[k], NULL, CLSCTX_ALL,
                   IID_IShellPropSheetExt, (void **)&pPsxa->intfc[pPsxa->count]);

            CHECK_HRESULT(hr);

            if (SUCCEEDED(hr))
            {
                ++pPsxa->count;
            }
        }

        if (pPsxa->count > 0)
        {
            *ppPsxa = pPsxa;
            hr = S_OK;
        }
        else
        {
            hr = E_FAIL;
        }

    } while (0);

    return hr;
}


//
//  This function is a callback function from property sheet page extensions.
//
BOOL CALLBACK I_AddPropSheetPage(HPROPSHEETPAGE hpage, LPARAM lParam)
{
    PROPSHEETHEADER * ppsh = (PROPSHEETHEADER *)lParam;

    if (ppsh->nPages < MAX_FILE_PROP_PAGES)
    {
        ppsh->phpage[ppsh->nPages++] = hpage;

        return TRUE;
    }

    return FALSE;
}


LRESULT CALLBACK WndProc(HWND hWnd, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
        switch(iMessage)
        {
        case WM_CREATE:
                break;

        case WM_DESTROY:
                break;

        case WM_NOTIFY:
            break;

//      case STUBM_SETDATA:
//          SetWindowLongPtr(hWnd, 0, wParam);
//          break;
//
//      case  STUBM_GETDATA:
//          return GetWindowLongPtr(hWnd, 0);

        default:
                return DefWindowProc(hWnd, iMessage, wParam, lParam) ;
                break;
        }

        return 0L;
}


HWND I_CreateStubWindow(void)
{
    WNDCLASS wndclass;

    if (!GetClassInfo(HINST_THISDLL, c_szStubWindowClass, &wndclass))
    {
        wndclass.style         = 0;
        wndclass.lpfnWndProc   = WndProc;
        wndclass.cbClsExtra    = 0;
        wndclass.cbWndExtra    = 0;
        wndclass.hInstance     = HINST_THISDLL;
        wndclass.hIcon         = NULL;
        wndclass.hCursor       = LoadCursor(NULL, IDC_ARROW);
        wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
        wndclass.lpszMenuName  = NULL;
        wndclass.lpszClassName = c_szStubWindowClass;

        if (!RegisterClass(&wndclass))
            return NULL;
    }

    return CreateWindowEx(WS_EX_TOOLWINDOW, c_szStubWindowClass, c_szNULL,
                      WS_OVERLAPPED, CW_USEDEFAULT, CW_USEDEFAULT, 0, 0,
                      NULL, NULL, HINST_THISDLL, NULL);
}



HRESULT
JFOpenPropSheet(
    LPDATAOBJECT pdtobj,
    LPTSTR       pszCaption)
{
    HRESULT hr = S_OK;
    CHkey   hkey;
    PSXA  * pPsxa = NULL;
    PROPSHEETHEADER psh;
    HPROPSHEETPAGE  ahpage[MAX_FILE_PROP_PAGES];

    do
    {
        //
        //  Get HKEY for the .job class object
        //

        hr = GetHkeyForJobObject(&hkey);

        BREAK_ON_FAIL(hr);

        //
        //  Get the IShellPropSheetExt interface ptrs for classes wishing to
        //  add pages.
        //

        hr = GetPropSheetExtArray(hkey, &pPsxa);

        BREAK_ON_FAIL(hr);

        //  For each IShellPropSheetExt interface ptr initialize(IShellExtInit)
        //  and call the AddPages.

        psh.dwSize     = sizeof(psh);
        psh.dwFlags    = PSH_PROPTITLE;
        psh.hwndParent = I_CreateStubWindow();
        psh.hInstance  = g_hInstance;
        psh.hIcon      = NULL;
        psh.pszCaption = pszCaption;
        //psh.pszCaption = MAKEINTRESOURCE(IDS_JOB_PSH_CAPTION);
        psh.nPages     = 0; // incremented in callback
        psh.nStartPage = 0;
        psh.phpage     = ahpage;

        IShellExtInit * pShExtInit = NULL;

        for (UINT n=0; n < pPsxa->count; n++)
        {
            hr = pPsxa->intfc[n]->QueryInterface(IID_IShellExtInit,
                                                    (void **)&pShExtInit);
            CHECK_HRESULT(hr);

            if (SUCCEEDED(hr))
            {
                hr = pShExtInit->Initialize(NULL, pdtobj, hkey);

                CHECK_HRESULT(hr);

                pShExtInit->Release();

                if (SUCCEEDED(hr))
                {
                    hr = pPsxa->intfc[n]->AddPages(I_AddPropSheetPage,
                                                        (LPARAM)&psh);
                    CHECK_HRESULT(hr);
                }
            }
        }

        PSXA::Delete(pPsxa);

        //  create a modeless property sheet.

        // Open the property sheet, only if we have some pages.
        if (psh.nPages > 0)
        {
            _try
            {
                hr = E_FAIL;

                if (PropertySheet(&psh) >= 0) // IDOK or IDCANCEL (< 0 is error)
                {
                    hr = S_OK;
                }

DEBUG_OUT((DEB_USER1, "PropertySheet returned.\n"));
            }
            _except(EXCEPTION_EXECUTE_HANDLER)
            {
                hr = E_FAIL;
                CHECK_HRESULT(hr);
            }
        }

    } while (0);

    if (psh.hwndParent)
    {
        DestroyWindow(psh.hwndParent);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\folderui\resource.h ===
//
//  Bitmaps & icons
//

#define BMP_JOBSTATES                   271
#define BMP_JOBSTATEL                   272

#define IDI_GENERIC                     273
#define IDI_TEMPLATE                    274

//
//  Menus
//

#define POPUP_JOB                       300
#define POPUP_JOB_VERBS_ONLY            301
#define POPUP_JOBSBG_MERGE              302
#define POPUP_JOBSBG_POPUPMERGE         303
#define POPUP_JOBS_MAIN_POPUPMERGE      304
#define POPUP_ADVANCED                  305
#define POPUP_RBUTTON_MOVE              306
#define POPUP_JOB_TEMPLATE              307

//
//  Strings in string table
//

#define IDS_NAME                        100
#define IDS_NEXTRUNTIME                 101
#define IDS_LASTRUNTIME                 102
#define IDS_LASTEXITCODE                103
#define IDS_SCHEDULE                    104
#define IDS_STATUS                      105
#define IDS_CREATOR                     106
#define IDS_MI_STOP                     107
#define IDS_MI_START                    108
#define IDS_MI_PAUSE                    109
#define IDS_MI_CONTINUE                 110

#define IDS_JOB_PSH_CAPTION             151
#define IDS_NOPAGE                      152
#define IDS_JOBFOLDER                   153
#define IDS_RUNNING                     154
#define IDS_JOB_NOT_SCHEDULED           155
#define IDS_NEVER                       156
#define IDS_DISABLED                    157
#define IDS_ON_STARTUP                  158
#define IDS_ON_LOGON                    159
#define IDS_TRIGGER_DISABLED            160
#define IDS_COPY_OF                     161
#define IDS_START_SERVICE               162
#define IDS_CONTINUE_SERVICE            163
#define IDS_START_PENDING               164
#define IDS_MULTIPLE_TRIGGERS           165
#define IDS_MISSED                      166
#define IDS_START_FAILED                167
#define IDS_BAD_ACCT                    168
#define IDS_REST_ACCT                   169

//
//  Others
//

#define CMIDM_FIRST                     0x0000
#define CMIDM_RUN                       (CMIDM_FIRST + 0x0001)
#define CMIDM_ABORT                     (CMIDM_FIRST + 0x0002)
#define CMIDM_CUT                       (CMIDM_FIRST + 0x0003)
#define CMIDM_COPY                      (CMIDM_FIRST + 0x0004)
#define CMIDM_PASTE                     (CMIDM_FIRST + 0x0005)
#define CMIDM_DELETE                    (CMIDM_FIRST + 0x0006)
#define CMIDM_RENAME                    (CMIDM_FIRST + 0x0007)
#define CMIDM_PROPERTIES                (CMIDM_FIRST + 0x0008)
#define CMIDM_OPEN                      (CMIDM_FIRST + 0x0009)

#define FSIDM_SORT_FIRST                0x0030
#define FSIDM_SORTBYNAME                (FSIDM_SORT_FIRST + 0x0000)
#define FSIDM_SORTBYSCHEDULE            (FSIDM_SORT_FIRST + 0x0001)
#define FSIDM_SORTBYNEXTRUNTIME         (FSIDM_SORT_FIRST + 0x0002)
#define FSIDM_SORTBYLASTRUNTIME         (FSIDM_SORT_FIRST + 0x0003)
#define FSIDM_SORTBYLASTEXITCODE        (FSIDM_SORT_FIRST + 0x0004)
#define FSIDM_SORTBYSTATUS              (FSIDM_SORT_FIRST + 0x0005)
#define FSIDM_SORTBYCREATOR             (FSIDM_SORT_FIRST + 0x0006)

#define FSIDM_MENU_NEW                  0x0060
#define FSIDM_NEWJOB                    (FSIDM_MENU_NEW + 0x0001)
#define FSIDM_NEWQUEUE                  (FSIDM_MENU_NEW + 0x0002)

#define FSIDM_MENU_ADVANCED             0x0090
#define FSIDM_STOP_SCHED                (FSIDM_MENU_ADVANCED + 0x0001)
#define FSIDM_PAUSE_SCHED               (FSIDM_MENU_ADVANCED + 0x0002)
#define FSIDM_VIEW_LOG                  (FSIDM_MENU_ADVANCED + 0x0003)
#define FSIDM_DBG_BUILD_NUM             (FSIDM_MENU_ADVANCED + 0x0004)
#define FSIDM_AT_ACCOUNT                (FSIDM_MENU_ADVANCED + 0x0005)
#define FSIDM_NOTIFY_MISSED             (FSIDM_MENU_ADVANCED + 0x0006)

#define DIDM_RBUTTON_MOVE_START         0x00c0
#define DDIDM_MOVE                      (DIDM_RBUTTON_MOVE_START + 0x0001)
#define DDIDM_COPY                      (DIDM_RBUTTON_MOVE_START + 0x0002)
#define DDIDM_CREATEAJOB                (DIDM_RBUTTON_MOVE_START + 0x0003)


#define IDS_MH_FSIDM_FIRST              2000
#define IDS_MH_FSIDM_LAST               2999

#define IDS_MH_SORTBYNAME               (IDS_MH_FSIDM_FIRST + FSIDM_SORTBYNAME)
#define IDS_MH_SORTBYNEXTRUNTIME        (IDS_MH_FSIDM_FIRST + FSIDM_SORTBYNEXTRUNTIME)
#define IDS_MH_SORTBYLASTRUNTIME        (IDS_MH_FSIDM_FIRST + FSIDM_SORTBYLASTRUNTIME)
#define IDS_MH_SORTBYLASTEXITCODE       (IDS_MH_FSIDM_FIRST + FSIDM_SORTBYLASTEXITCODE)
#define IDS_MH_SORTBYSCHEDULE           (IDS_MH_FSIDM_FIRST + FSIDM_SORTBYSCHEDULE)
#define IDS_MH_SORTBYCREATOR            (IDS_MH_FSIDM_FIRST + FSIDM_SORTBYCREATOR)
#define IDS_MH_MENU_NEW                 (IDS_MH_FSIDM_FIRST + FSIDM_MENU_NEW)
#define IDS_MH_NEWJOB                   (IDS_MH_FSIDM_FIRST + FSIDM_NEWJOB)
#define IDS_MH_NEWQUEUE                 (IDS_MH_FSIDM_FIRST + FSIDM_NEWQUEUE)
#define IDS_MH_MENU_ADVANCED            (IDS_MH_FSIDM_FIRST + FSIDM_MENU_ADVANCED)
#define IDS_MH_STOP_SCHED               (IDS_MH_FSIDM_FIRST + FSIDM_STOP_SCHED)
#define IDS_MH_PAUSE_SCHED              (IDS_MH_FSIDM_FIRST + FSIDM_PAUSE_SCHED)
#define IDS_MH_NOTIFY_OF_MISSED         (IDS_MH_FSIDM_FIRST + FSIDM_NOTIFY_MISSED)
#define IDS_MH_VIEW_LOG                 (IDS_MH_FSIDM_FIRST + FSIDM_VIEW_LOG)
#define IDS_MH_AT_ACCOUNT               (IDS_MH_FSIDM_FIRST + FSIDM_AT_ACCOUNT)
#define IDS_MH_ABOUT                    (IDS_MH_FSIDM_FIRST + FSIDM_DBG_BUILD_NUM)
#define MH_TEXT_TOGGLE                  20
#define IDS_MH_START_SCHED              (IDS_MH_FSIDM_FIRST + FSIDM_STOP_SCHED + MH_TEXT_TOGGLE)
#define IDS_MH_CONTINUE_SCHED           (IDS_MH_FSIDM_FIRST + FSIDM_PAUSE_SCHED + MH_TEXT_TOGGLE)

#define IDS_MH_RUN                      (IDS_MH_FSIDM_FIRST + CMIDM_RUN)
#define IDS_MH_ABORT                    (IDS_MH_FSIDM_FIRST + CMIDM_ABORT)
#define IDS_MH_CUT                      (IDS_MH_FSIDM_FIRST + CMIDM_CUT)
#define IDS_MH_COPY                     (IDS_MH_FSIDM_FIRST + CMIDM_COPY)
#define IDS_MH_PASTE                    (IDS_MH_FSIDM_FIRST + CMIDM_PASTE)
#define IDS_MH_DELETE                   (IDS_MH_FSIDM_FIRST + CMIDM_DELETE)
#define IDS_MH_RENAME                   (IDS_MH_FSIDM_FIRST + CMIDM_RENAME)
#define IDS_MH_PROPERTIES               (IDS_MH_FSIDM_FIRST + CMIDM_PROPERTIES)
#define IDS_MH_OPEN                     (IDS_MH_FSIDM_FIRST + CMIDM_OPEN)

#ifndef SFVIDM_MENU_ARRANGE
#define SFVIDM_MENU_ARRANGE             0x7001
#endif // SFVIDM_MENU_ARRANGE


#define IERR_START                      3800
#define IERR_CANT_FIND_VIEWER           (IERR_START + 0x0001)
#define IERR_GETSVCSTATE                (IERR_START + 0x0002)
#define IERR_STOPSVC                    (IERR_START + 0x0003)
#define IERR_PAUSESVC                   (IERR_START + 0x0004)
#define IERR_CONTINUESVC                (IERR_START + 0x0005)
#define IERR_SCHEDSVC                   (IERR_START + 0x0006)
#define IERR_EXT_NOT_VALID              (IERR_START + 0X0007)
#define IERR_INVALID_DATA               (IERR_START + 0X0008)
#define IERR_STARTSVC                   (IERR_START + 0X0009)
#define IERR_GETATACCOUNT               (IERR_START + 0X000A)


#define IDS_BUILD_NUM                   4000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\folderui\schstate.cxx ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       SchState.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    3/27/1996   RaviR   Created
//
//____________________________________________________________________________


#include "..\pch\headers.hxx"
#pragma hdrstop

#include "dbg.h"
#include "macros.h"

#include "..\inc\common.hxx"
#include "..\inc\resource.h"
#include "..\inc\misc.hxx"
#include "resource.h"
#include "..\schedui\schedui.hxx"


#define MAX_MSGLEN 300
#define MAX_SCHED_START_WAIT    60  // seconds


#ifdef _CHICAGO_

#define TIMEOUT_INTERVAL        10000
#define TIMEOUT_INCREMENT       10000
#define TIMEOUT_INTERVAL_MAX    (5 * 60 * 1000) // 5 minutes

//____________________________________________________________________________
//
//  Function:   I_SendMsgTimeout
//
//  Synopsis:   Uses SendMessageTimeout to send the message with SMTO_BLOCK
//              option. If SendMessageTimeout fails due to timeout error,
//              we prompt the user for retry.
//
//  Arguments:  [hwnd] -- IN
//              [uMsg] -- IN
//              [pdwRes] -- IN
//
//  Returns:    BOOL
//
//  History:    3/29/1996   RaviR   Created
//
//____________________________________________________________________________

BOOL
I_SendMsgTimeout(
    HWND    hwnd,
    UINT    uMsg,
    DWORD * pdwRes)
{
    UINT    uTimeOut = TIMEOUT_INTERVAL;
    int     idsErr = 0;
    TCHAR   szErrMsg[MAX_MSGLEN] = TEXT("");
    TCHAR   szErrCaption[MAX_MSGLEN] = TEXT("");

    switch (uMsg)
    {
    case SCHED_WIN9X_GETSVCSTATE:   idsErr = IERR_GETSVCSTATE;     break;
    case SCHED_WIN9X_STOPSVC:       idsErr = IERR_STOPSVC;         break;
    case SCHED_WIN9X_PAUSESVC:      idsErr = IERR_PAUSESVC;        break;
    case SCHED_WIN9X_CONTINUESVC:   idsErr = IERR_CONTINUESVC;     break;
    }

    while (1)
    {
        if (SendMessageTimeout(hwnd, uMsg, 0L, 0L, SMTO_BLOCK,
                                             uTimeOut, pdwRes)
            == TRUE)
        {
            return TRUE;
        }

        if (szErrMsg[0] == TEXT('\0'))
        {
            UINT iCur = 0;

            if (idsErr != 0)
            {
                LoadString(g_hInstance, idsErr, szErrMsg, MAX_MSGLEN);

                iCur = lstrlen(szErrMsg);
                szErrMsg[iCur++] = TEXT(' ');
            }

            LoadString(g_hInstance, IERR_SCHEDSVC, &szErrMsg[iCur],
                                                MAX_MSGLEN - iCur);

            LoadString(g_hInstance, IDS_SCHEDULER_NAME, szErrCaption,
                                                MAX_MSGLEN);
        }

        int iReply = MessageBox(hwnd, szErrMsg, szErrCaption, MB_YESNO);

        if (iReply == IDNO)
        {
            return FALSE;
        }

        if (uTimeOut < TIMEOUT_INTERVAL_MAX)
        {
            uTimeOut += TIMEOUT_INCREMENT;
        }
    }

    return FALSE;
}
#endif // _CHICAGO_



//____________________________________________________________________________
//
//  Function:   GetSchSvcState
//
//  Synopsis:   returns the schedul service status
//
//  Arguments:  [dwState] -- IN
//
//  Returns:    HRESULT
//
//  History:    3/29/1996   RaviR   Created
//
//____________________________________________________________________________

HRESULT
GetSchSvcState(
    DWORD &dwState)
{
#ifdef _CHICAGO_

    HWND hwnd = FindWindow(SCHED_CLASS, SCHED_TITLE);

    if (hwnd == NULL)
    {
        dwState = SERVICE_STOPPED;
    }
    else
    {
        if (I_SendMsgTimeout(hwnd, SCHED_WIN9X_GETSVCSTATE, &dwState) == FALSE)
        {
            return E_FAIL;
        }
    }

    return S_OK;

#else // _NT1X_

    SC_HANDLE   hSchSvc = NULL;
    HRESULT     hr = S_OK;

    do
    {
        hSchSvc = OpenScheduleService(SERVICE_QUERY_STATUS);
        if (hSchSvc == NULL)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DEBUG_OUT_LASTERROR;
            break;
        }

        SERVICE_STATUS SvcStatus;

        if (QueryServiceStatus(hSchSvc, &SvcStatus) == FALSE)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DEBUG_OUT_LASTERROR;
            break;
        }

        dwState = SvcStatus.dwCurrentState;

    } while (0);

    if (hSchSvc != NULL)
    {
        CloseServiceHandle(hSchSvc);
    }

    return hr;

#endif // _NT1X_
}

//____________________________________________________________________________
//
//  Function:   StartScheduler
//
//  Synopsis:   Start the schedule service
//
//  Returns:    HRESULT
//
//  History:    3/29/1996   RaviR   Created
//
//____________________________________________________________________________

HRESULT
StartScheduler(void)
{
#ifdef _CHICAGO_

    //
    // Persist the change.
    //
    AutoStart(TRUE);

    //
    // See if it is running.
    //
    HWND hwnd = FindWindow(SCHED_CLASS, SCHED_TITLE);

    if (hwnd != NULL)
    {
        // It is already running.
        return S_OK;
    }

    //
    //  Create a process to open the log.
    //

    STARTUPINFO         sui;
    PROCESS_INFORMATION pi;

    ZeroMemory(&sui, sizeof(sui));
    sui.cb = sizeof (STARTUPINFO);

    TCHAR szApp[MAX_PATH];
    LPTSTR pszFilePart;

    DWORD dwRet = SearchPath(NULL, SCHED_SERVICE_APP_NAME, NULL, MAX_PATH,
                                                        szApp, &pszFilePart);

    if (dwRet == 0)
    {
        DEBUG_OUT_LASTERROR;
        return HRESULT_FROM_WIN32(GetLastError());
    }

    BOOL fRet = CreateProcess(
                    szApp,              // lpszImageName
                    NULL,               // lpszCommandLine
                    NULL,               // lpsaProcess - security attributes
                    NULL,               // lpsaThread  - security attributes
                    FALSE,              // fInheritHandles
                    CREATE_NEW_CONSOLE  // fdwCreate - creation flags
                        | CREATE_NEW_PROCESS_GROUP,
                    NULL,               // lpvEnvironment
                    NULL,               // lpszCurDir
                    &sui,               // lpsiStartInfo
                    &pi );              // lppiProcInfo

    if (fRet == 0)
    {
        DEBUG_OUT_LASTERROR;
        return HRESULT_FROM_WIN32(GetLastError());
    }

    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);

    return S_OK;

#else // _NT1X_

    SC_HANDLE   hSchSvc = NULL;
    HRESULT     hr = S_OK;

    do
    {
        hSchSvc = OpenScheduleService(
                              SERVICE_CHANGE_CONFIG | SERVICE_START |
                              SERVICE_QUERY_STATUS);
        if (hSchSvc == NULL)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DEBUG_OUT_LASTERROR;
            break;
        }

        SERVICE_STATUS SvcStatus;

        if (QueryServiceStatus(hSchSvc, &SvcStatus) == FALSE)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DEBUG_OUT_LASTERROR;
            break;
        }

        if (SvcStatus.dwCurrentState == SERVICE_RUNNING)
        {
            // The service is already running.
            break;
        }

        if (StartService(hSchSvc, 0, NULL) == FALSE)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DEBUG_OUT_LASTERROR;
            break;
        }

        //
        // Persist the change.  Since the service started successfully,
        // don't complain if this fails.
        //
        HRESULT hrAuto = AutoStart(TRUE);
        CHECK_HRESULT(hrAuto);

    } while (0);

    if (hSchSvc != NULL)
    {
        CloseServiceHandle(hSchSvc);
    }

    return hr;

#endif // _NT1X_
}

//____________________________________________________________________________
//
//  Function:   StopScheduler
//
//  Synopsis:   Stops the schedule service
//
//  Returns:    HRESULT
//
//  History:    3/29/1996   RaviR   Created
//
//____________________________________________________________________________

HRESULT
StopScheduler(void)
{
#ifdef _CHICAGO_

    //
    // Persist the change.
    //
    AutoStart(FALSE);

    //
    // See if it is running or not.
    //
    HWND hwnd = FindWindow(SCHED_CLASS, SCHED_TITLE);

    if (hwnd == NULL)
    {
        // already stopped
        return S_OK;
    }
    else if (I_SendMsgTimeout(hwnd, SCHED_WIN9X_STOPSVC, NULL) == TRUE)
    {
        return S_OK;
    }

    return E_FAIL;

#else // _NT1X_

    SC_HANDLE   hSchSvc = NULL;
    HRESULT     hr = S_OK;

    do
    {
        hSchSvc = OpenScheduleService(
                              SERVICE_CHANGE_CONFIG | SERVICE_STOP |
                              SERVICE_QUERY_STATUS);
        if (hSchSvc == NULL)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DEBUG_OUT_LASTERROR;
            break;
        }

        SERVICE_STATUS SvcStatus;

        if (QueryServiceStatus(hSchSvc, &SvcStatus) == FALSE)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DEBUG_OUT_LASTERROR;
            break;
        }

        if (SvcStatus.dwCurrentState == SERVICE_STOPPED)
        {
            // The service is already stopped.
            break;
        }

        if (ControlService(hSchSvc, SERVICE_CONTROL_STOP, &SvcStatus) == FALSE)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DEBUG_OUT_LASTERROR;
            break;
        }

        //
        // Persist the change.  Since the service was stopped successfully,
        // don't complain if this fails.
        //
        HRESULT hrAuto = AutoStart(FALSE);
        CHECK_HRESULT(hrAuto);

    } while (0);

    if (hSchSvc != NULL)
    {
        CloseServiceHandle(hSchSvc);
    }

    return hr;

#endif // _NT1X_
}

//____________________________________________________________________________
//
//  Function:   PauseScheduler
//
//  Synopsis:   If fPause==TRUE requests the schedule service to pauses,
//              else to continue.
//
//  Arguments:  [fPause] -- IN
//
//  Returns:    HRESULT
//
//  History:    3/29/1996   RaviR   Created
//
//____________________________________________________________________________

HRESULT
PauseScheduler(
    BOOL fPause)
{
#ifdef _CHICAGO_

    HWND hwnd = FindWindow(SCHED_CLASS, SCHED_TITLE);
    UINT uMsg = fPause ? SCHED_WIN9X_PAUSESVC : SCHED_WIN9X_CONTINUESVC;

    if ((hwnd != NULL) && (I_SendMsgTimeout(hwnd, uMsg, NULL) == TRUE))
    {
        return S_OK;
    }

    return E_FAIL;

#else // _NT1X_

    SC_HANDLE   hSchSvc = NULL;
    HRESULT     hr = S_OK;

    do
    {
        hSchSvc = OpenScheduleService(
                            SERVICE_PAUSE_CONTINUE | SERVICE_QUERY_STATUS);

        if (hSchSvc == NULL)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DEBUG_OUT_LASTERROR;
            break;
        }

        SERVICE_STATUS SvcStatus;

        if (QueryServiceStatus(hSchSvc, &SvcStatus) == FALSE)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DEBUG_OUT_LASTERROR;
            break;
        }

        if (fPause == TRUE)
        {
            if ((SvcStatus.dwCurrentState == SERVICE_PAUSED) ||
                (SvcStatus.dwCurrentState == SERVICE_PAUSE_PENDING))
            {
                // Nothing to do here.
                break;
            }
            else if ((SvcStatus.dwCurrentState == SERVICE_STOPPED) ||
                     (SvcStatus.dwCurrentState == SERVICE_STOP_PENDING))
            {
                Win4Assert(0 && "Unexpected");
                hr = E_UNEXPECTED;
                CHECK_HRESULT(hr);
                break;
            }
            else
            {
                if (ControlService(hSchSvc, SERVICE_CONTROL_PAUSE, &SvcStatus)
                    == FALSE)
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    DEBUG_OUT_LASTERROR;
                    break;
                }
            }
        }
        else // continue
        {
            if ((SvcStatus.dwCurrentState == SERVICE_RUNNING) ||
                (SvcStatus.dwCurrentState == SERVICE_CONTINUE_PENDING))
            {
                // Nothing to do here.
                break;
            }
            else if ((SvcStatus.dwCurrentState == SERVICE_STOPPED) ||
                     (SvcStatus.dwCurrentState == SERVICE_STOP_PENDING))
            {
                Win4Assert(0 && "Unexpected");
                hr = E_UNEXPECTED;
                CHECK_HRESULT(hr);
                break;
            }
            else
            {
                if (ControlService(hSchSvc, SERVICE_CONTROL_CONTINUE,
                                                            &SvcStatus)
                    == FALSE)
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    DEBUG_OUT_LASTERROR;
                    break;
                }
            }
        }

    } while (0);

    if (hSchSvc != NULL)
    {
        CloseServiceHandle(hSchSvc);
    }

    return hr;

#endif // _NT1X_
}



//+--------------------------------------------------------------------------
//
//  Function:   UserCanChangeService
//
//  Synopsis:   Returns TRUE if the UI should allow the user to invoke
//              service start, stop, pause/continue, or at account options.
//
//  Returns:    TRUE if focus is local machine and OS is win95 or it is NT
//              and the user is an admin.
//
//  History:    4-16-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
UserCanChangeService(
    LPCTSTR pszServerFocus)
{
    if (pszServerFocus)
    {
        return FALSE;
    }

#if defined(_CHICAGO_)
    return TRUE;
#else
    //
    // Determine if user is an admin.  If not, some items under the
    // advanced menu will be disabled.
    // BUGBUG  A more accurate way to do this would be to attempt to open
    // the relevant registry keys and service handle.
    //
    return IsThreadCallerAnAdmin(NULL);
#endif // !defined(_CHICAGO_)
}


//+--------------------------------------------------------------------------
//
//  Function:   PromptForServiceStart
//
//  Synopsis:   If the service is not started or is paused, prompt the user
//              to allow us to start/continue it.
//
//  Returns:    S_OK    - service was already running, or was successfully
//                          started or continued.
//              S_FALSE - user elected not to start/continue service
//              E_*     - error starting/continuing service
//
//  History:    4-16-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
PromptForServiceStart(
    HWND hwnd)
{
    HRESULT hr = S_OK;

    do
    {
        //
        // Get the current service state
        //

        DWORD dwState = SERVICE_STOPPED;

        hr = GetSchSvcState(dwState);

        if (FAILED(hr))
        {
            dwState = SERVICE_STOPPED;
            hr = S_OK; // reset
        }

        //
        // Determine the required action
        //

        UINT uMsg = 0;

        if (dwState == SERVICE_STOPPED ||
            dwState == SERVICE_STOP_PENDING)
        {
            uMsg = IDS_START_SERVICE;
        }
        else if (dwState == SERVICE_PAUSED ||
                 dwState == SERVICE_PAUSE_PENDING)
        {
            uMsg = IDS_CONTINUE_SERVICE;
        }
        else if (dwState == SERVICE_START_PENDING)
        {
            uMsg = IDS_START_PENDING;
        }

        //
        // If the service is running, there's nothing to do.
        //

        if (!uMsg)
        {
            hr = S_OK;
            break;
        }

        if (uMsg == IDS_START_PENDING)
        {
            SchedUIMessageDialog(hwnd,
                                 uMsg,
                                 MB_SETFOREGROUND      |
                                    MB_TASKMODAL       |
                                    MB_ICONINFORMATION |
                                    MB_OK,
                                 NULL);
        }
        else
        {
            if (SchedUIMessageDialog(hwnd, uMsg,
                        MB_SETFOREGROUND |
                        MB_TASKMODAL |
                        MB_ICONQUESTION |
                        MB_YESNO,
                        NULL)
                == IDNO)
            {
                hr = S_FALSE;
                break;
            }
        }

        CWaitCursor waitCursor;

        if (uMsg == IDS_START_SERVICE)
        {
            hr = StartScheduler();

            if (FAILED(hr))
            {
                SchedUIErrorDialog(hwnd, IERR_STARTSVC, (LPTSTR)NULL);
                break;
            }

            // Give the schedule service time to start up.
            Sleep(2000);
        }
        else if (uMsg == IDS_CONTINUE_SERVICE)
        {
            PauseScheduler(FALSE);
        }

        for (int count=0; count < 60; count++)
        {
            GetSchSvcState(dwState);

            if (dwState == SERVICE_RUNNING)
            {
                break;
            }

            Sleep(1000); // Sleep for 1 seconds.
        }

        if (dwState != SERVICE_RUNNING)
        {
            //
            // unable to start/continue the service.
            //

            SchedUIErrorDialog(hwnd,
                (uMsg == IDS_START_SERVICE) ? IERR_STARTSVC
                                                : IERR_CONTINUESVC,
                (LPTSTR)NULL);
            hr = E_FAIL;
            break;
        }
    } while (0);

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Function:   QuietStartContinueService
//
//  Synopsis:   Start or continue the service without requiring user
//              interaction.
//
//  Returns:    S_OK   - service running
//              E_FAIL - timeout or failure
//
//  History:    5-19-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
QuietStartContinueService()
{
    HRESULT hr = S_OK;
    DWORD dwState = SERVICE_STOPPED;

    do
    {
        hr = GetSchSvcState(dwState);

        if (FAILED(hr))
        {
            dwState = SERVICE_STOPPED;
            hr = S_OK; // reset
        }

        //
        // If the service is running, there's nothing to do.
        //

        if (dwState == SERVICE_RUNNING)
        {
            break;
        }

        //
        // If it's stopped, request a start.  If it's paused, request
        // continue.
        //

        CWaitCursor waitCursor;

        switch (dwState)
        {
        case SERVICE_STOPPED:
        case SERVICE_STOP_PENDING:
            hr = StartScheduler();
            break;

        case SERVICE_PAUSED:
        case SERVICE_PAUSE_PENDING:
            hr = PauseScheduler(FALSE);
            break;
        }

        if (FAILED(hr))
        {
            CHECK_HRESULT(hr);
            break;
        }

        //
        // Wait for its state to change to running
        //

        for (int count=0; count < MAX_SCHED_START_WAIT; count++)
        {
            GetSchSvcState(dwState);

            if (dwState == SERVICE_RUNNING)
            {
                break;
            }

            Sleep(1000); // Sleep for 1 seconds.
        }

        if (dwState != SERVICE_RUNNING)
        {
            //
            // unable to start/continue the service.
            //

            hr = E_FAIL;
            CHECK_HRESULT(hr);
        }
    } while (0);

    return hr;
}




//____________________________________________________________________________
//
//  Function:   OpenScheduleService
//
//  Synopsis:   Opens a handle to the "Schedule" service
//
//  Arguments:  [dwDesiredAccess] -- desired access
//
//  Returns:    Handle; if NULL, use GetLastError()
//
//  History:    15-Nov-1996 AnirudhS  Created
//
//____________________________________________________________________________

#ifndef _CHICAGO_
SC_HANDLE
OpenScheduleService(DWORD dwDesiredAccess)
{
    SC_HANDLE hSC = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);

    if (hSC == NULL)
    {
        DEBUG_OUT_LASTERROR;
        return NULL;
    }

    SC_HANDLE hSchSvc = OpenService(hSC, SCHED_SERVICE_NAME, dwDesiredAccess);

    CloseServiceHandle(hSC);

    if (hSchSvc == NULL)
    {
        DEBUG_OUT_LASTERROR;
    }

    return hSchSvc;
}
#endif // !_CHICAGO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\folderui\sources.inc ===
#+----------------------------------------------------------------------------
#
#  Microsoft Windows
#  Copyright (C) Microsoft Corporation, 1995 - 1996.
#
#  Synopsis:    Source list file for the scheduler dll.
#
#  History:     Jan-05-96     RaviR   Created.
#
#-----------------------------------------------------------------------------

TARGETNAME=     jobfldr
TARGETTYPE=     LIBRARY
TARGETPATH=     obj

!IF "$(DBX)" == "yes"
C_DEFINES=$(C_DEFINES) -DDBX
!endif


SOURCES=        \
                ..\dataobj.cxx \
                ..\dllutil.cxx \
                ..\enum.cxx \
                ..\guids.cxx \
                ..\hsort.cxx \
                ..\jobfldr.cxx \
                ..\jobicons.cxx \
                ..\jobidl.cxx \
                ..\menu.cxx \
                ..\menubg.cxx \
                ..\ole.cxx \
                ..\policy.cxx \
                ..\schstate.cxx \
                ..\sdetails.cxx \
                ..\sfolder.cxx \
                ..\wraps.cxx \
                ..\xicon.cxx \
                ..\util.cxx \
                ..\viewlog.cxx


INCLUDES=       ..; \
                $(INCLUDES)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\folderui\sfolder.cxx ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       sfolder.cxx
//
//  Contents:   Implementation of IShellFolder for Job Folders
//
//  Classes:    CJobFolder::IShellFolder members
//
//  Functions:
//
//  History:    1/4/1996    RaviR      Created
//              1-23-1997   DavidMun   Destroy notify window upon receiving
//                                      DVM_WINDOWDESTROY
//
//____________________________________________________________________________

#include "..\pch\headers.hxx"
#pragma hdrstop

#include "dbg.h"
#include "macros.h"
#include "resource.h"
#include "..\schedui\rc.h"
#include "jobidl.hxx"
#include "jobfldr.hxx"
#include "policy.hxx"
#include "..\schedui\timeutil.hxx"
#include "..\schedui\schedui.hxx"
#include "util.hxx"
#include "..\inc\defines.hxx"
#include "..\inc\misc.hxx"
#include "..\inc\common.hxx"
#include "atacct.h"

#define JF_FSNOTIFY     (WM_USER + 0xA1)
#define STUBM_SETDATA   (WM_USER + 0xb1)
#define STUBM_GETDATA   (WM_USER + 0xb2)


#define VIEW_ICON_MENU_ID           28713
#define VIEW_SMALLICON_MENU_ID      28714
#define VIEW_LIST_MENU_ID           28715
#define VIEW_DETAILS_MENU_ID        28716

//
// extern
//

extern HINSTANCE g_hInstance;
extern "C" UINT      g_cfJobIDList;

HRESULT
JFGetShellDetails(
    HWND    hwnd,
    LPVOID* ppvObj);

HRESULT
JFGetFolderContextMenu(
    HWND            hwnd,
    CJobFolder    * pCJobFolder,
    LPVOID        * ppvObj);

HRESULT
JFGetDataObject(
    LPCTSTR         pszFolderPath,
    LPCITEMIDLIST   pidlFolder,
    UINT            cidl,
    LPCITEMIDLIST * apidl,
    BOOL            fCut,
    LPVOID        * ppvObj);

HRESULT
JFGetItemContextMenu(
    HWND hwnd,
    ITaskScheduler * pScheduler,
    LPCTSTR ptszMachine,
    LPCTSTR pszFolderPath,
    LPCITEMIDLIST pidlFolder,
    UINT cidl,
    LPCITEMIDLIST* apidl,
    LPVOID * ppvOut);

HRESULT
JFGetExtractIcon(
    LPVOID        * ppvObj,
    LPCTSTR         pszFolderPath,
    LPCITEMIDLIST   pidl);

#ifdef UNICODE
HRESULT
JFGetExtractIconA(
    LPVOID        * ppvObj,
    LPCTSTR         pszFolderPath,
    LPCITEMIDLIST   pidl);
#endif // UNICODE


HRESULT
JFGetEnumIDList(
    ULONG            uFlags,
    LPCTSTR          pszFolderPath,
    IEnumWorkItems * pEnumJobs,
    LPVOID    *      ppvObj);


HRESULT
JFCreateNewQueue(
    HWND    hwnd);


void
OnViewLog(
    LPTSTR  lpMachineName,
    HWND    hwndOwner);


HRESULT
GetSchSvcState(
    DWORD &dwCurrState);


HRESULT
StopScheduler(void);


HRESULT
StartScheduler(void);

BOOL
UserCanChangeService(
    LPCTSTR ptszServer);

HRESULT
PromptForServiceStart(
    HWND hwnd);

HRESULT
PauseScheduler(
    BOOL fPause);

#if !defined(_CHICAGO_)

VOID
SecurityErrorDialog(
    HWND    hWndOwner,
    HRESULT hr);

VOID
GetDefaultDomainAndUserName(
    LPTSTR ptszDomainAndUserName,
    ULONG  cchBuf);

#endif // !defined(_CHICAGO_)

//
// local funcs
//

HWND
I_CreateNotifyWnd(void);

int
LocaleStrCmp(LPCTSTR ptsz1, LPCTSTR ptsz2);


//____________________________________________________________________________
//
//  Member:     CJobFolder::ParseDisplayName
//____________________________________________________________________________

STDMETHODIMP
CJobFolder::ParseDisplayName(
    HWND            hwndOwner,
    LPBC            pbcReserved,
    LPOLESTR        lpszDisplayName,
    ULONG         * pchEaten,
    LPITEMIDLIST  * ppidl,
    ULONG         * pdwAttributes)
{
    TRACE(CJobFolder, ParseDisplayName);

    return E_NOTIMPL;
}


//____________________________________________________________________________
//
//  Member:     CJobFolder::EnumObjects
//
//  Arguments:  [hwndOwner] -- IN
//              [grfFlags] -- IN
//              [ppenumIDList] -- OUT
//
//  Returns:    HRESULT.
//
//  History:    1/5/1996   RaviR   Created
//
//____________________________________________________________________________

STDMETHODIMP
CJobFolder::EnumObjects(
    HWND hwndOwner,
    DWORD grfFlags,
    LPENUMIDLIST* ppenumUnknown)
{
    DEBUG_OUT((DEB_USER12, "CJobFolder::EnumObjects<%x>\n", this));

    *ppenumUnknown = NULL;

    //
    //  We dont support folders.
    //

    if (!(grfFlags & SHCONTF_NONFOLDERS))
    {
        return E_FAIL;
    }

    //
    //  Get the IDList enumerator
    //

    HRESULT hr = S_OK;

    if (m_pScheduler == NULL)
    {
        hr = _InitRest();

        CHECK_HRESULT(hr);
    }

    IEnumWorkItems * pEnumJobs = NULL;

    if (SUCCEEDED(hr))
    {
        hr = m_pScheduler->Enum(&pEnumJobs);

        CHECK_HRESULT(hr);

        if (SUCCEEDED(hr))
        {
            hr = JFGetEnumIDList(grfFlags, m_pszFolderPath,
                                 pEnumJobs, (LPVOID*)ppenumUnknown);
            CHECK_HRESULT(hr);

            pEnumJobs->Release();
        }
    }

    return hr;
}


//____________________________________________________________________________
//
//  Member:     CJobFolder::BindToObject
//____________________________________________________________________________

STDMETHODIMP
CJobFolder::BindToObject(
    LPCITEMIDLIST pidl,
    LPBC pbcReserved,
    REFIID riid,
    LPVOID* ppvOut)
{
    TRACE(CJobFolder, BindToObject);

    // Job folder doesn't contain sub-folders
    return E_NOTIMPL;
}


//____________________________________________________________________________
//
//  Member:     CJobFolder::BindToStorage
//
//  Note:       not used in Win95
//____________________________________________________________________________


STDMETHODIMP
CJobFolder::BindToStorage(
    LPCITEMIDLIST pidl,
    LPBC pbcReserved,
    REFIID riid,
    LPVOID* ppvObj)
{
    TRACE(CJobFolder, BindToStorage);

    *ppvObj = NULL;
    return E_NOTIMPL;
}




//____________________________________________________________________________
//
//  Member:     CJobFolder::CompareIDs
//
//  Arguments:  [lParam] -- IN
//              [pidl1] -- IN
//              [pidl2] -- IN
//
//  Returns:    HRESULT.
//
//  History:    1/5/1996   RaviR   Created
//
//____________________________________________________________________________

STDMETHODIMP
CJobFolder::CompareIDs(
    LPARAM lCol,
    LPCITEMIDLIST pidl1,
    LPCITEMIDLIST pidl2)
{
    DEBUG_OUT((DEB_USER12, "CJobFolder::CompareIDs<%d>\n", lCol));

    HRESULT hr = S_OK;
    int     iCmp;

    if (JF_IsValidID(pidl1) == FALSE || JF_IsValidID(pidl2) == FALSE)
    {
        return E_INVALIDARG;
    }

    PJOBID pjid1 = (PJOBID)pidl1;
    PJOBID pjid2 = (PJOBID)pidl2;

    //
    // Ensure that the template object is always first
    //

    if (pjid1->IsTemplate() && pjid2->IsTemplate())
    {
        return S_OK; // equal
    }

    if (pjid1->IsTemplate())
    {
        return ResultFromShort(-1);
    }

    if (pjid2->IsTemplate())
    {
        return ResultFromShort(1);
    }

    switch (lCol)
    {
    case COLUMN_LASTRUNTIME:
        iCmp = CompareSystemTime(pjid1->GetLastRunTime(),
                                 pjid2->GetLastRunTime());
        break;

    case COLUMN_NEXTRUNTIME:
    {
        TCHAR  buff1[MAX_PATH];
        TCHAR  buff2[MAX_PATH];
        LPTSTR psz1, psz2;

        psz1 = pjid1->GetNextRunTimeString(buff1, MAX_PATH, TRUE);
        psz2 = pjid2->GetNextRunTimeString(buff2, MAX_PATH, TRUE);

        if (psz1 != NULL)
        {
            if (psz2 != NULL)
            {
                iCmp = LocaleStrCmp(psz1, psz2);
            }
            else
            {
                iCmp = 1;
            }
        }
        else
        {
            if (psz2 != NULL)
            {
                iCmp = -1;
            }
            else
            {
                iCmp = CompareSystemTime(pjid1->GetNextRunTime(),
                                         pjid2->GetNextRunTime());
            }
        }
        break;
    }

    case COLUMN_SCHEDULE:
    {
        TCHAR tszTrig1[SCH_XBIGBUF_LEN];
        TCHAR tszTrig2[SCH_XBIGBUF_LEN];

        if (pjid1->IsJobFlagOn(TASK_FLAG_DISABLED) == TRUE)
        {
            LoadString(g_hInstance, IDS_DISABLED, tszTrig1, SCH_XBIGBUF_LEN);
        }
        else
        {
            hr = GetTriggerStringFromTrigger(&pjid1->GetTrigger(),
                                                tszTrig1, SCH_XBIGBUF_LEN, NULL);
            BREAK_ON_FAIL(hr);
        }

        if (pjid2->IsJobFlagOn(TASK_FLAG_DISABLED) == TRUE)
        {
            LoadString(g_hInstance, IDS_DISABLED, tszTrig2, SCH_XBIGBUF_LEN);
        }
        else
        {
            hr = GetTriggerStringFromTrigger(&pjid2->GetTrigger(),
                                                tszTrig2, SCH_XBIGBUF_LEN, NULL);
            BREAK_ON_FAIL(hr);
        }

        iCmp = LocaleStrCmp(tszTrig1, tszTrig2);

        break;
    }

    case COLUMN_STATUS:
    {
        iCmp = pjid1->_status - pjid2->_status;
        break;
    }

    case COLUMN_NAME:
        // Fall through

    default:
        DEBUG_OUT((DEB_USER12, "CompareIDs<%ws, %ws>\n", pjid1->GetName(),
                                                         pjid2->GetName()));

        iCmp = LocaleStrCmp(pjid1->GetName(), pjid2->GetName());

        break;

#if !defined(_CHICAGO_)
    case COLUMN_LASTEXITCODE:
        iCmp = pjid1->GetExitCode() - pjid2->GetExitCode();
        break;

    case COLUMN_CREATOR:
        iCmp = LocaleStrCmp(pjid1->GetCreator(), pjid2->GetCreator());
        break;
#endif // !defined(_CHICAGO_)

    }

    if (SUCCEEDED(hr))
    {
        hr = ResultFromShort(iCmp);
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   LocaleStrCmp
//
//  Synopsis:   Do a case insensitive string compare that is safe for any
//              locale.
//
//  Arguments:  [ptsz1] - strings to compare
//              [ptsz2]
//
//  Returns:    -1, 0, or 1 just like lstrcmpi
//
//  History:    10-28-96   DavidMun   Created
//
//  Notes:      This is slower than lstrcmpi, but will work when sorting
//              strings even in Japanese.
//
//----------------------------------------------------------------------------

int
LocaleStrCmp(LPCTSTR ptsz1, LPCTSTR ptsz2)
{
    int iRet;

    iRet = CompareString(LOCALE_USER_DEFAULT,
                         NORM_IGNORECASE        |
                           NORM_IGNOREKANATYPE  |
                           NORM_IGNOREWIDTH,
                         ptsz1,
                         -1,
                         ptsz2,
                         -1);

    if (iRet)
    {
        iRet -= 2;  // convert to lstrcmpi-style return -1, 0, or 1
    }
    else
    {
        DEBUG_OUT_LASTERROR;
    }
    return iRet;
}


//____________________________________________________________________________
//
//  Member:     CJobFolder::CreateViewObject
//
//  Arguments:  [hwndOwner] -- IN
//              [riid] -- IN
//              [ppvOut] -- IN
//
//  Returns:    HRESULT.
//
//  History:    1/5/1996   RaviR   Created
//
//____________________________________________________________________________


STDMETHODIMP
CJobFolder::CreateViewObject(
    HWND hwndOwner,
    REFIID riid,
    LPVOID* ppvOut)
{
    TRACE(CJobFolder, CreateViewObject);

    HRESULT hr = S_OK;

    m_hwndOwner = hwndOwner;

    *ppvOut = NULL;

    if (m_pszFolderPath == NULL)
    {
        hr = _InitRest();

        CHECK_HRESULT(hr);

        if (FAILED(hr))
        {
            return hr;
        }
    }

    if (IsEqualIID(riid, IID_IShellView))
    {
        CSFV csfv =
        {
            sizeof(CSFV),           // cbSize
            (IShellFolder*)this,    // pshf
            NULL,                   // psvOuter
            m_pidlFldr,             // pidl to monitor
            0,                      // events
            s_JobsFVCallBack,       // pfnCallback
            FVM_DETAILS
        };

        IShellView * pShellView;

        if (SUCCEEDED(hr))
        {
            hr = SHCreateShellFolderViewEx(&csfv, &pShellView);

            CHECK_HRESULT(hr);
        }

        if (SUCCEEDED(hr))
        {
            m_pShellView = pShellView;
            // WARNING: Do not AddRef m_pShellView this will cause
            // a cyclic addref. Use DVM_RELEASE in callback to know
            // whem m_pShellView is destroyed.
        }

        *ppvOut = (LPVOID)m_pShellView;
    }
    else if (IsEqualIID(riid, IID_IShellDetails))
    {
        hr = JFGetShellDetails(hwndOwner, ppvOut);
    }
    else if (IsEqualIID(riid, IID_IContextMenu))
    {
        hr = JFGetFolderContextMenu(hwndOwner, this, ppvOut);
    }
    else if (IsEqualIID(riid, IID_IDropTarget))
    {
        hr = this->QueryInterface(IID_IDropTarget, ppvOut);
    }
    else
    {
        hr = E_NOINTERFACE;
        CHECK_HRESULT(hr);
    }

    return hr;
}


//____________________________________________________________________________
//
//  Member:     CJobFolder::GetAttributesOf
//
//  Arguments:  [cidl] -- IN
//              [apidl] -- IN
//              [rgfInOut] -- IN
//
//  Returns:    HRESULT.
//
//  History:    1/5/1996   RaviR   Created
//              5-09-1997   DavidMun   handle template object
//
//____________________________________________________________________________

STDMETHODIMP
CJobFolder::GetAttributesOf(
    UINT cidl,
    LPCITEMIDLIST* apidl,
    ULONG* rgfInOut)
{
    // TRACE(CJobFolder, GetAttributesOf);

    //
    // Three cases:
    //
    // a. list contains only non-template object(s)
    // b. list contains only a template object
    // c. list contains template object plus non-template object(s)
    //
    // For cases b and c, no operations are allowed, since the
    // template object is not a real object.
    //

    ULONG rgfMask;

    if (ContainsTemplateObject(cidl, apidl))
    {
        rgfMask = 0;
    }
    else
    {
        //
        // Policy - creation, deletion are regulated
        //

        rgfMask = 0;

        //
        // If no DRAG and DROP restriction, then it ok to copy.
        // read it once, for efficiency's sake.
        //

        BOOL fDragDropRestricted = RegReadPolicyKey(TS_KEYPOLICY_DENY_DRAGDROP);
        BOOL fDeleteRestricted = RegReadPolicyKey(TS_KEYPOLICY_DENY_DELETE);

        if (! fDragDropRestricted)
        {
            rgfMask |= SFGAO_CANCOPY;
        }

        if ((! fDeleteRestricted) && (! fDragDropRestricted))
        {
            // If allowed deletion, then move or delete is okay
            rgfMask |= SFGAO_CANMOVE;

            if (! RegReadPolicyKey(TS_KEYPOLICY_DENY_CREATE_TASK))
            {
                //
                // If allowed creation, as well, then rename is okay
                // Note we consider a RENAME both a create and a delete
                //

                rgfMask |= SFGAO_CANRENAME;
            }
        }

        if (! fDeleteRestricted)
        {
            rgfMask |= SFGAO_CANDELETE;
        }

        if ((cidl == 1) && (! RegReadPolicyKey(TS_KEYPOLICY_DENY_PROPERTIES)))
        {
            // no multi-select property sheets
            rgfMask |= SFGAO_HASPROPSHEET;
        }
    }

    *rgfInOut &= rgfMask;

    return S_OK;
}


//____________________________________________________________________________
//
//  Member:     CJobFolder::GetUIObjectOf
//
//  Arguments:  [hwndOwner] -- IN
//              [cidl] -- IN
//              [apidl] -- IN
//              [riid] -- IN
//              [prgfInOut] -- IN
//              [ppvOut] -- IN
//
//  Returns:    STDMETHODIMP
//
//  History:    1/5/1996   RaviR   Created
//
//____________________________________________________________________________

STDMETHODIMP
CJobFolder::GetUIObjectOf(
    HWND hwndOwner,
    UINT cidl,
    LPCITEMIDLIST* apidl,
    REFIID riid,
    UINT* prgfInOut,
    LPVOID* ppvOut)
{
    TRACE(CJobFolder, GetUIObjectOf);

    if( NULL == apidl )
    {
        return E_INVALIDARG;
    }

    PJOBID pjid = (PJOBID)apidl[0];

    if (cidl < 1)
    {
        return E_INVALIDARG;
    }

    if (JF_IsValidID(apidl[0]) == FALSE)
    {
        return E_INVALIDARG;
    }

    HRESULT hr = E_NOINTERFACE;

    *ppvOut = NULL;

    if (cidl == 1 && IsEqualIID(riid, IID_IExtractIcon))
    {
        hr = JFGetExtractIcon(ppvOut, m_pszFolderPath, apidl[0]);
    }
#ifdef UNICODE
    else if (cidl == 1 && IsEqualIID(riid, IID_IExtractIconA))
    {
        hr = JFGetExtractIconA(ppvOut, m_pszFolderPath, apidl[0]);
    }
#endif // UNICODE
    else if (IsEqualIID(riid, IID_IContextMenu))
    {
        if (m_pszFolderPath == NULL)
        {
            hr = _InitRest();
            CHECK_HRESULT(hr);

            if (FAILED(hr))
            {
                return hr;
            }
        }

        hr = JFGetItemContextMenu(hwndOwner,
                                  m_pScheduler,
                                  m_pszMachine,
                                  m_pszFolderPath,
                                  m_pidlFldr,
                                  cidl,
                                  apidl,
                                  ppvOut);
    }
    else if (cidl > 0 && IsEqualIID(riid, IID_IDataObject))
    {
        DEBUG_OUT((DEB_USER1, "[GetUIObjectOf] IDataObject \n"));

        BOOL fCut = (GetKeyState(VK_CONTROL) >= 0);

        //
        // Policy - if DRAGDROP or DELETE and we are here,
        // we must be doing a cut or copy op and cannot allow it
        //

        if (RegReadPolicyKey(TS_KEYPOLICY_DENY_DRAGDROP) ||
            (fCut && RegReadPolicyKey(TS_KEYPOLICY_DENY_DELETE)))
        {
            return E_NOINTERFACE;
        }

        DEBUG_OUT((DEB_USER12, "fCut<%d>\n", fCut));

        hr = JFGetDataObject(m_pszFolderPath,
                             m_pidlFldr,
                             cidl,
                             apidl,
                             fCut,
                             ppvOut);
    }

    return hr;
}

//____________________________________________________________________________
//
//  Member:     CJobFolder::GetDisplayNameOf
//
//  Arguments:  [pidl] -- IN
//              [uFlags] -- IN
//              [lpName] -- IN
//
//  Returns:    HRESULT.
//
//  History:    1/5/1996   RaviR   Created
//
//____________________________________________________________________________

STDMETHODIMP
CJobFolder::GetDisplayNameOf(
    LPCITEMIDLIST pidl,
    DWORD uFlags,
    LPSTRRET lpName)
{
    TRACE(CJobFolder, GetDisplayNameOf);
    DEBUG_OUT((DEB_USER12, "CJobFolder::GetDisplayNameOf<uFlags = %d>\n", uFlags));

    if (JF_IsValidID(pidl) == FALSE)
    {
        return E_INVALIDARG;
    }

    PJOBID pjid = (PJOBID)pidl;

    LPTSTR ptszToReturn;
    TCHAR  tszFullPath[MAX_PATH + 1];

    //
    // If the display name is to be used for parsing, return the full path to
    // the file.  This is used by rshx32.dll when we request that it add the
    // security page for a file.
    //

    if (uFlags & SHGDN_FORPARSING)
    {
        //
        // If we don't have the folder path, complete the initialization to
        // get it.
        //

        if (m_pszFolderPath == NULL)
        {
            HRESULT hr = _InitRest();
            CHECK_HRESULT(hr);

            if (FAILED(hr))
            {
                return hr;
            }
        }

        wsprintf(tszFullPath,
                 TEXT("%s\\%s.") TSZ_JOB,
                 m_pszFolderPath,
                 pjid->GetName());

        ptszToReturn = tszFullPath;
        DEBUG_OUT((DEB_TRACE,
                   "CJobFolder::GetDisplayNameOf: Returning path '%S'\n",
                   ptszToReturn));
    }
    else
    {
        ptszToReturn = pjid->GetName();
    }

    UINT uiByteLen = (lstrlen(ptszToReturn) + 1) * sizeof(TCHAR);

#ifdef UNICODE

    lpName->uType = STRRET_WSTR;

    lpName->pOleStr = (LPWSTR) SHAlloc(uiByteLen);

    if (NULL == lpName->pOleStr)
    {
        return E_OUTOFMEMORY;
    }

    CopyMemory(lpName->pOleStr, ptszToReturn, uiByteLen);

#else // ANSI

    lpName->uType = STRRET_CSTR;

    lstrcpy(lpName->cStr, ptszToReturn);

#endif

    return NOERROR;
}


//____________________________________________________________________________
//
//  Member:     CJobFolder::SetNameOf
//
//  Arguments:  [hwndOwner] -- IN
//              [pidl] -- IN
//              [lpszName] -- IN
//              [uFlags] -- IN
//              [ppidlOut] -- IN
//
//  Returns:    STDMETHODIMP
//
//  History:    1/5/1996   RaviR   Created
//
//____________________________________________________________________________

STDMETHODIMP
CJobFolder::SetNameOf(
    HWND hwndOwner,
    LPCITEMIDLIST pidl,
    LPCOLESTR lpszName,
    DWORD uFlags,
    LPITEMIDLIST* ppidlOut)
{
    TRACE(CJobFolder, SetNameOf);

    HRESULT     hr = S_OK;

    if (JF_IsValidID(pidl) == FALSE)
    {
        return E_INVALIDARG;
    }

    PJOBID pjidOld = (PJOBID)pidl;

    DEBUG_ASSERT(!pjidOld->IsTemplate());

    if (ppidlOut != NULL)
    {
        *ppidlOut = NULL;
    }

    CJobID jidNew;

    jidNew.Rename(*pjidOld, lpszName);

    //
    // Change the file name
    //

    TCHAR szOldFile[MAX_PATH + 2];
    TCHAR szNewFile[MAX_PATH + 2];
    BOOL  fRet;

    lstrcpy(szOldFile, m_pszFolderPath);
    lstrcat(szOldFile, TEXT("\\"));
    lstrcat(szOldFile, pjidOld->GetPath());
    lstrcat(szOldFile, TSZ_DOTJOB);

    lstrcpy(szNewFile, m_pszFolderPath);
    lstrcat(szNewFile, TEXT("\\"));
    lstrcat(szNewFile, jidNew.GetName());
    lstrcat(szNewFile, TSZ_DOTJOB);

    DEBUG_OUT((DEB_USER1, "Rename %ws to %ws\n", szOldFile, szNewFile));

    SHFILEOPSTRUCT fo;

    fo.hwnd = m_hwndOwner;
    fo.wFunc = FO_RENAME;
    fo.pFrom = szOldFile;
    fo.pTo = szNewFile;
    fo.fFlags = FOF_ALLOWUNDO;
    fo.fAnyOperationsAborted = FALSE;
    fo.hNameMappings = NULL;
    fo.lpszProgressTitle = NULL;

    // Make sure we have double trailing NULL!
    *(szOldFile + lstrlen(szOldFile) + 1) = TEXT('\0');
    *(szNewFile + lstrlen(szNewFile) + 1) = TEXT('\0');

    if ((SHFileOperation(&fo) !=0) || fo.fAnyOperationsAborted == TRUE)
    {
        hr = E_FAIL;
        CHECK_HRESULT(hr);
        return hr;
    }

    return hr;
}


#if DBG==1
void JFDbgOutCallbackMsg(UINT uMsg);
#endif // DBG==1

//____________________________________________________________________________
//
//  Member:     CJobFolder::s_JobsFVCallBack, static
//
//  Arguments:  [psvOuter] -- IN
//              [psf] -- IN
//              [hwndOwner] -- IN
//              [uMsg] -- IN
//              [wParam] -- IN
//              [lParam] -- IN
//
//  Returns:    HRESULT
//
//  History:    1/5/1996   RaviR   Created
//
//____________________________________________________________________________

HRESULT CALLBACK
CJobFolder::s_JobsFVCallBack(
    LPSHELLVIEW psvOuter,
    LPSHELLFOLDER psf,
    HWND hwndOwner,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    CJobFolder *pCJobFolder = (CJobFolder *)psf;

    return pCJobFolder->_JobsFVCallBack(psvOuter, psf, hwndOwner,
                                        uMsg, wParam, lParam);
}


#if !defined(_CHICAGO_)

//+---------------------------------------------------------------------------
//
//  Function:   EnableAtAccountControls
//
//  Synopsis:   Enable or disable the account and password controls in the
//              at account dialog.
//
//  Arguments:  [hDlg]    - handle to dialog
//              [fEnable] - TRUE = enable, FALSE = disable
//
//  History:    09-19-96   DavidMun   Created
//
//----------------------------------------------------------------------------

VOID
EnableAtAccountControls(HWND hDlg, BOOL fEnable)
{
    EnableWindow(GetDlgItem(hDlg, IDD_AT_CUSTOM_ACCT_NAME), fEnable);
    EnableWindow(GetDlgItem(hDlg, IDD_AT_PASSWORD), fEnable);
    EnableWindow(GetDlgItem(hDlg, IDD_AT_CONFIRM_PASSWORD), fEnable);
}




//+---------------------------------------------------------------------------
//
//  Function:   InitAtAccountDlg
//
//  Synopsis:   Initialize the controls in the at account dialog
//
//  Arguments:  [hDlg] - handle to dialog
//
//  History:    09-19-96   DavidMun   Created
//
//----------------------------------------------------------------------------

VOID
InitAtAccountDlg(HWND hDlg)
{
    HRESULT hr;
    WCHAR wszAccount[MAX_USERNAME + 1];
    DWORD cchAccount = MAX_USERNAME + 1;

    //
    // Limit the length of account and password edit controls, and init the
    // password controls to stars just like the task account dialog does.
    //

    SendDlgItemMessage(hDlg,
                       IDD_AT_CUSTOM_ACCT_NAME,
                       EM_LIMITTEXT,
                       MAX_USERNAME,
                       0);

    SendDlgItemMessage(hDlg,
                       IDD_AT_PASSWORD,
                       EM_LIMITTEXT,
                       MAX_PASSWORD,
                       0);

    SendDlgItemMessage(hDlg,
                       IDD_AT_CONFIRM_PASSWORD,
                       EM_LIMITTEXT,
                       MAX_PASSWORD,
                       0);

    //
    // Ask the service for the current at account information.  Menu item for
    // this dialog should be disabled if service isn't running, so this should
    // succeed.  If this fails, we can't expect the Set api to work, so
    // complain and bail.
    //

    hr = GetNetScheduleAccountInformation(NULL, cchAccount, wszAccount);

    if (SUCCEEDED(hr))
    {
        if (hr == S_FALSE)
        {
            // running as local system
            CheckDlgButton(hDlg, IDD_AT_USE_SYSTEM, BST_CHECKED);
            EnableAtAccountControls(hDlg, FALSE);
        }
        else
        {
            CheckDlgButton(hDlg, IDD_AT_USE_CUSTOM, BST_CHECKED);
            SetDlgItemText(hDlg, IDD_AT_CUSTOM_ACCT_NAME, wszAccount);
            EnableAtAccountControls(hDlg, TRUE);
        }
    }
    else
    {
        SchedUIMessageDialog(hDlg,
                             IERR_GETATACCOUNT,
                             MB_OK | MB_ICONEXCLAMATION | MB_TASKMODAL,
                             NULL);
        EndDialog(hDlg, 0);
    }
}




//+---------------------------------------------------------------------------
//
//  Function:   HandleAtAccountChange
//
//  Synopsis:   Make the At account reflect the current settings in the
//              dialog, and end the dialog if successful.
//
//  Arguments:  [hDlg] - handle to dialog
//
//  History:    09-19-96   DavidMun   Created
//
//----------------------------------------------------------------------------

VOID
HandleAtAccountChange(HWND hDlg)
{
    HRESULT hr = S_OK;
    WCHAR  wszAccountName[MAX_USERNAME + 1]       = TEXT("");
    WCHAR  wszPassword[MAX_PASSWORD + 1]          = TEXT("");
    WCHAR  wszConfirmedPassword[MAX_PASSWORD + 1] = TEXT("");

    do
    {
        //
        // See if user just wants at jobs to run as localsystem
        //

        if (IsDlgButtonChecked(hDlg, IDD_AT_USE_SYSTEM) == BST_CHECKED)
        {
            hr = SetNetScheduleAccountInformation(NULL, NULL, wszPassword);

            if (FAILED(hr))
            {
                SecurityErrorDialog(hDlg, hr);
            }
            else
            {
                EndDialog(hDlg, 0);
            }
            break;
        }

        //
        // No, we have to validate account and password controls.  Get the
        // account name and fail if it's empty.
        //

        GetDlgItemText(hDlg,
                       IDD_AT_CUSTOM_ACCT_NAME,
                       wszAccountName,
                       MAX_USERNAME + 1);

        if (wszAccountName[0] == L'\0')
        {
            SchedUIErrorDialog(hDlg, IERR_ACCOUNTNAME, (LPTSTR)NULL);
            break;
        }

        //
        // Get the passwords and fail if they haven't been changed, or if
        // they don't match eachother.
        //

        GetDlgItemText(hDlg,
                       IDD_AT_PASSWORD,
                       wszPassword,
                       MAX_PASSWORD + 1);

        GetDlgItemText(hDlg,
                       IDD_AT_CONFIRM_PASSWORD,
                       wszConfirmedPassword,
                       MAX_PASSWORD + 1);

        if (lstrcmp(wszPassword, wszConfirmedPassword) != 0)
        {
            SchedUIErrorDialog(hDlg, IERR_PASSWORD, (LPTSTR)NULL);
            break;
        }

        //
        // Account name and passwords valid (as far as we can tell). Make
        // the change to the account.
        //

        hr = SetNetScheduleAccountInformation(NULL, // local machine
                                              wszAccountName,
                                              wszPassword);

        if (FAILED(hr))
        {
            SecurityErrorDialog(hDlg, hr);
        }
        else
        {
            EndDialog(hDlg, 0);
        }
    } while (0);
}



//+---------------------------------------------------------------------------
//
//  Function:   SetAtAccountDlgProc
//
//  Synopsis:   Allow the user to specify which account to run AT jobs under
//
//  Arguments:  standard dialog proc
//
//  Returns:    standard dialog proc
//
//  History:    09-19-96   DavidMun   Created
//
//----------------------------------------------------------------------------

INT_PTR APIENTRY
SetAtAccountDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    BOOL  fHandled = TRUE;

    //
    // Note: the DWLP_USER long is used as a dirty flag.  If the user hits OK
    // without having modified the edit controls or hit the radio buttons,
    // then we'll just treat it as a Cancel if the dirty flag is FALSE.
    //

    switch (uMsg)
    {
    case WM_INITDIALOG:
        InitAtAccountDlg(hDlg);
        SetWindowLongPtr(hDlg, DWLP_USER, FALSE);
        break;  // return TRUE so windows will set focus

    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case IDD_AT_USE_SYSTEM:
            EnableAtAccountControls(hDlg, FALSE);
            SetWindowLongPtr(hDlg, DWLP_USER, TRUE);
            break;

        case IDD_AT_USE_CUSTOM:
        {
            WCHAR wszUserName[MAX_USERNAME + 1];
            DWORD cchUserName = MAX_USERNAME + 1;

            SetWindowLongPtr(hDlg, DWLP_USER, TRUE);

            //
            // If there's nothing in the user account field, make it default
            // to the logged-on user.
            //

            if (!GetDlgItemText(hDlg,
                                IDD_AT_CUSTOM_ACCT_NAME,
                                wszUserName,
                                cchUserName))
            {
                GetDefaultDomainAndUserName(wszUserName, cchUserName);
                SetDlgItemText(hDlg, IDD_AT_CUSTOM_ACCT_NAME, wszUserName);
            }

            EnableAtAccountControls(hDlg, TRUE);
            break;
        }

        case IDD_AT_CUSTOM_ACCT_NAME:
        case IDD_AT_PASSWORD:
        case IDD_AT_CONFIRM_PASSWORD:
            if (EN_CHANGE == HIWORD(wParam))
            {
                SetWindowLongPtr(hDlg, DWLP_USER, TRUE);
            }
            else
            {
                fHandled = FALSE;
            }
            break;

        case IDOK:
            if (GetWindowLongPtr(hDlg, DWLP_USER))
            {
                //
                // Do NOT clear the dirty flag here--if HandleAtAccountChange
                // is successful, the dialog will end, but if not we need to
                // retain the dirty state.
                //

                CWaitCursor WaitCursor;
                HandleAtAccountChange(hDlg);
                break;
            }
            // else FALL THROUGH

        case IDCANCEL:
            EndDialog(hDlg, wParam);
            break;

        default:
            fHandled = FALSE;
            break;
        }
        break;

    default:
        fHandled = FALSE;
        break;
    }
    return fHandled;
}

#endif // !defined(_CHICAGO_)


//____________________________________________________________________________
//
//  Member:     CJobFolder::_JobsFVCallBack
//
//  Arguments:  [psvOuter] -- IN
//              [psf] -- IN
//              [hwndOwner] -- IN
//              [uMsg] -- IN
//              [wParam] -- IN
//              [lParam] -- IN
//
//  Returns:    HRESULT
//
//  History:    1/5/1996   RaviR   Created
//
//____________________________________________________________________________

HRESULT CALLBACK
CJobFolder::_JobsFVCallBack(
    LPSHELLVIEW psvOuter,
    LPSHELLFOLDER psf,
    HWND hwndOwner,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    DEBUG_OUT((DEB_USER12, "_JobsFVCallBack<uMsg=%d>\n", uMsg));

    HRESULT     hr = S_OK;
    LRESULT     lr = ERROR_SUCCESS;

    switch(uMsg)
    {
    case DVM_GETCCHMAX:
    {
        UINT * pcchMax = (UINT *)lParam;

        // <folder path> + '\' + cchMax + '.job' + null  <= MAX_PATH

        *pcchMax = MAX_PATH - (lstrlen(m_pszFolderPath) + 6);

        break;
    }
    case DVM_DEFITEMCOUNT:
        //
        // If DefView times out enumerating items, let it know we probably only
        // have about 20 items
        //

        *(int *)lParam = 20;
        break;

    case DVM_MERGEMENU:
    {
        m_qcm = *((LPQCMINFO)lParam);

        UtMergeMenu(g_hInstance, POPUP_ADVANCED, POPUP_JOBS_MAIN_POPUPMERGE,
                                                        (LPQCMINFO)lParam);
        break;
    }
    case DVM_INITMENUPOPUP:
    {
        UINT idCmdFirst = LOWORD(wParam);
        UINT nIndex = HIWORD(wParam);
        HMENU hmenu = (HMENU)lParam;
        UINT idCmd = GetMenuItemID(hmenu, 0) - idCmdFirst;

        if (idCmd == FSIDM_STOP_SCHED)
        {
            if (!UserCanChangeService(m_pszMachine))
            {
                //
                // The job folder is on a remote machine, or we're on NT
                // and the user is not an administrator.  Disable stop,
                // pause, and at account options and get out.
                //

                EnableMenuItem(hmenu, FSIDM_STOP_SCHED+idCmdFirst,
                                            MF_DISABLED | MF_GRAYED);

                EnableMenuItem(hmenu, FSIDM_PAUSE_SCHED+idCmdFirst,
                                            MF_DISABLED | MF_GRAYED);

                EnableMenuItem(hmenu, FSIDM_NOTIFY_MISSED+idCmdFirst,
                                            MF_DISABLED | MF_GRAYED);
#if !defined(_CHICAGO_)
                EnableMenuItem(hmenu, FSIDM_AT_ACCOUNT+idCmdFirst,
                                            MF_DISABLED | MF_GRAYED);
#endif // !defined(_CHICAGO_)
                break;
            }

            DWORD dwState;

            hr = GetSchSvcState(dwState);

            DEBUG_OUT((DEB_USER1, "Service state = %d\n", dwState));

            if (FAILED(hr))
            {
                dwState = SERVICE_STOPPED;
            }

            UINT uiStartID = IDS_MI_STOP;
            UINT uiPauseID = IDS_MI_PAUSE;
            UINT uiPauseEnable = MFS_ENABLED;
#define CCH_MENU_TEXT 80
            TCHAR tszStart[CCH_MENU_TEXT];
            TCHAR tszPause[CCH_MENU_TEXT];

            if (dwState == SERVICE_STOPPED ||
                dwState == SERVICE_STOP_PENDING)
            {
                uiStartID = IDS_MI_START;
                uiPauseEnable = MFS_DISABLED;
            }
            else if (dwState == SERVICE_PAUSED ||
                     dwState == SERVICE_PAUSE_PENDING)
            {
                uiPauseID = IDS_MI_CONTINUE;
            }

            if (dwState == SERVICE_START_PENDING)
            {
                uiPauseEnable = MFS_DISABLED;
            }

            MENUITEMINFO mii = {0};
            mii.cbSize = sizeof(MENUITEMINFO);

            mii.fMask = MIIM_TYPE;

            LoadString(g_hInstance, uiStartID, tszStart, CCH_MENU_TEXT);
            mii.dwTypeData = tszStart;

            SetMenuItemInfo(hmenu, FSIDM_STOP_SCHED+idCmdFirst, FALSE,
                            &mii);

            mii.fMask = MIIM_TYPE | MIIM_STATE;

            LoadString(g_hInstance, uiPauseID, tszPause, CCH_MENU_TEXT);
            mii.dwTypeData = tszPause;
            mii.fState = uiPauseEnable;

            SetMenuItemInfo(hmenu, FSIDM_PAUSE_SCHED+idCmdFirst, FALSE,
                            &mii);

            CheckMenuItem(hmenu,
                          FSIDM_NOTIFY_MISSED+idCmdFirst,
                          g_fNotifyMiss ? MF_CHECKED : MF_UNCHECKED);

#if !defined(_CHICAGO_)
            EnableMenuItem(hmenu,
                           FSIDM_AT_ACCOUNT+idCmdFirst,
                           MFS_ENABLED == uiPauseEnable ?
                            MF_ENABLED : MF_DISABLED | MF_GRAYED);
#endif // !defined(_CHICAGO_)
        }

        break;
    }
    case DVM_INVOKECOMMAND:
    {
        HMENU &hmenu = m_qcm.hmenu;
        UINT  id = (UINT)wParam + m_qcm.idCmdFirst;
        DWORD dwState;

        hr = GetSchSvcState(dwState);

        if (FAILED(hr))
        {
            dwState = SERVICE_STOPPED;
        }

        switch (wParam)
        {
        case FSIDM_SORTBYNAME:
            ShellFolderView_ReArrange(hwndOwner, COLUMN_NAME);
            break;

        case FSIDM_SORTBYSCHEDULE:
            ShellFolderView_ReArrange(hwndOwner, COLUMN_SCHEDULE);
            break;

        case FSIDM_SORTBYNEXTRUNTIME:
            ShellFolderView_ReArrange(hwndOwner, COLUMN_NEXTRUNTIME);
            break;

        case FSIDM_SORTBYLASTRUNTIME:
            ShellFolderView_ReArrange(hwndOwner, COLUMN_LASTRUNTIME);
            break;

        case FSIDM_SORTBYSTATUS:
            ShellFolderView_ReArrange(hwndOwner, COLUMN_STATUS);
            break;

#if !defined(_CHICAGO_)
        case FSIDM_SORTBYLASTEXITCODE:
            ShellFolderView_ReArrange(hwndOwner, COLUMN_LASTEXITCODE);
            break;

        case FSIDM_SORTBYCREATOR:
            ShellFolderView_ReArrange(hwndOwner, COLUMN_CREATOR);
            break;
#endif // !defined(_CHICAGO_)

        case FSIDM_NEWJOB:
            if (UserCanChangeService(m_pszMachine))
            {
                PromptForServiceStart(hwndOwner);
            }
            hr = CreateAJobForApp(NULL);
            break;

        case FSIDM_STOP_SCHED:
            if (dwState == SERVICE_STOPPED ||
                dwState == SERVICE_STOP_PENDING)
            {
                hr = StartScheduler();

                if (FAILED(hr))
                {
                    SchedUIErrorDialog(hwndOwner, IERR_STARTSVC, (LPTSTR) NULL);
                }
            }
            else
            {
                hr = StopScheduler();

                if (FAILED(hr))
                {
                    SchedUIErrorDialog(hwndOwner, IERR_STOPSVC, (LPTSTR) NULL);
                }
            }

            break;

        case FSIDM_PAUSE_SCHED:
            hr = PauseScheduler(dwState != SERVICE_PAUSED &&
                                dwState != SERVICE_PAUSE_PENDING);
            break;

#if !defined(_CHICAGO_)
        case FSIDM_AT_ACCOUNT:
            DialogBox(g_hInstance,
                      MAKEINTRESOURCE(IDD_AT_ACCOUNT_DLG),
                      hwndOwner,
                      SetAtAccountDlgProc);
            break;
#endif // !defined(_CHICAGO_)

        case FSIDM_NOTIFY_MISSED:
        {
            LONG lErr;
            HKEY hSchedKey = NULL;

            lErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                              SCH_AGENT_KEY,
                              0,
                              KEY_SET_VALUE,
                              &hSchedKey);

            if (lErr != ERROR_SUCCESS)
            {
                DEBUG_OUT((DEB_ERROR, "RegOpenKeyEx of Scheduler key %uL\n", lErr));
                break;
            }

            // Toggle the global var state

            g_fNotifyMiss = !g_fNotifyMiss;

            // Persist the change in the registry

            ULONG cbData = sizeof(g_fNotifyMiss);

            lErr = RegSetValueEx(hSchedKey,
                                 SCH_NOTIFYMISS_VALUE,
                                 0,
                                 REG_DWORD,
                                 (LPBYTE) &g_fNotifyMiss,
                                 cbData);
            RegCloseKey(hSchedKey);

            // If the change couldn't be persisted, undo it.

            if (lErr != ERROR_SUCCESS)
            {
                DEBUG_OUT((DEB_ERROR, "RegSetValueEx of notify miss %uL\n", lErr));
                g_fNotifyMiss = !g_fNotifyMiss;
            }
            break;
        }

        case FSIDM_VIEW_LOG:
            OnViewLog(m_pszMachine, hwndOwner);
            break;

        default:
            DEBUG_OUT((DEB_ERROR, "Unknown DVM_INVOKECOMMAND<%u>\n",wParam));
            hr = E_FAIL;
        }

        break;
    }
    case DVM_GETTOOLTIPTEXT:
    case DVM_GETHELPTEXT:
    {
        UINT idCmd = (UINT)LOWORD(wParam);
        UINT cchMax = (UINT)HIWORD(wParam);
        UINT uiToggle = 0;

        LPSTR pszText = (LPSTR)lParam;

        if (idCmd == FSIDM_STOP_SCHED || idCmd == FSIDM_PAUSE_SCHED)
        {
            DWORD dwState;

            hr = GetSchSvcState(dwState);

            if (FAILED(hr))
            {
                dwState = SERVICE_STOPPED;
            }

            if ((dwState == SERVICE_STOPPED ||
                 dwState == SERVICE_STOP_PENDING) &&
                idCmd == FSIDM_STOP_SCHED)
            {
                uiToggle = MH_TEXT_TOGGLE;
            }
            else
            {
                if ((dwState == SERVICE_PAUSED ||
                     dwState == SERVICE_PAUSE_PENDING) &&
                    idCmd == FSIDM_PAUSE_SCHED)
                {
                    uiToggle = MH_TEXT_TOGGLE;
                }
            }
        }

        LoadString(g_hInstance, idCmd + IDS_MH_FSIDM_FIRST + uiToggle,
                                            (LPTSTR)pszText, cchMax);

        break;
    }

    case DVM_DIDDRAGDROP:
    {
        DEBUG_OUT((DEB_USER12, "DVM_DIDDRAGDROP\n"));

//      DWORD dwEffect = wParam;
//      IDataObject * pdtobj = (IDataObject *)lParam;
//
//      if (!(dwEffect & DROPEFFECT_MOVE))
//      {
//          DEBUG_OUT((DEB_USER1, "DVM_DIDDRAGDROP<Copy>\n"));
//      }
//      else
//      {
//          DEBUG_OUT((DEB_USER1, "DVM_DIDDRAGDROP<Move>\n"));
//      }

        break;
    }
    case DVM_GETWORKINGDIR:
    {
        UINT    uMax = (UINT)wParam;
        LPTSTR  pszDir = (LPTSTR)lParam;

        lstrcpy(pszDir, m_pszFolderPath);
        break;
    }

    //
    // DVM_INSERTITEM and DVM_DELETEITEM are not processed because the
    // directory change notifications already provide this information.
    //

//  case DVM_INSERTITEM:
//  {
//      PJOBID pjid = (PJOBID)wParam;
//      if (JF_IsValidID((LPCITEMIDLIST)pjid) == TRUE)
//      {
//          DEBUG_OUT((DEB_USER1, "DVM_INSERTITEM <%ws>\n", pjid->GetName()));
//      }
//      break;
//  }
//  case DVM_DELETEITEM:
//  {
//      PDVSELCHANGEINFO psci = (PDVSELCHANGEINFO)lParam;
//
//      PJOBID pjid = (PJOBID)psci->lParamItem;
//
//      if (pjid == NULL)
//      {
//          DEBUG_OUT((DEB_USER1, "DVM_DELETEITEM delete all items.\n"));
//      }
//      else if (JF_IsValidID((LPCITEMIDLIST)pjid) == TRUE)
//      {
//          DEBUG_OUT((DEB_USER1, "DVM_DELETEITEM <%ws>\n", pjid->GetName()));
//      }
//      break;
//  }
    case DVM_RELEASE:
    {
        DEBUG_OUT((DEB_USER1, "\tDVM_RELEASE\n"));
        m_pShellView = NULL;
        break;
    }
    case DVM_WINDOWCREATED:
    {
        //
        // If we're opening on the local machine, make sure the sa.dat
        // file is up to date.
        //

        if (!m_pszMachine)
        {
            CheckSaDat(m_pszFolderPath);
        }

        // Save current listview mode

        m_ulListViewModeOnEntry = _GetChildListViewMode(hwndOwner);

        // Register change notifications for the pidl of the Tasks dir

        DEBUG_ASSERT(!m_hwndNotify);
        m_hwndNotify = I_CreateNotifyWnd();

        if (m_hwndNotify == NULL)
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        SendMessage(m_hwndNotify, STUBM_SETDATA, (WPARAM)this, 0);

        if (m_pszFolderPath == NULL)
        {
            hr = _InitRest();

            CHECK_HRESULT(hr);
            BREAK_ON_FAIL(hr);
        }

        LPITEMIDLIST pidl;
        hr = SHILCreateFromPath(m_pszFolderPath, &pidl, NULL);

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

        SHChangeNotifyEntry fsne;
        fsne.pidl       = pidl;
        fsne.fRecursive = FALSE;

        int fSources = SHCNRF_ShellLevel | SHCNRF_InterruptLevel;
                                         //| SHCNRF_NewDelivery;

        LONG fEvents = SHCNE_DISKEVENTS | SHCNE_RENAMEITEM | SHCNE_CREATE |
                       SHCNE_UPDATEITEM | SHCNE_ATTRIBUTES | SHCNE_DELETE;

        CDll::LockServer(TRUE);
        m_uRegister = SHChangeNotifyRegister(m_hwndNotify, fSources, fEvents,
                                                    JF_FSNOTIFY, 1, &fsne);

        if (!m_uRegister)
        {
            CDll::LockServer(FALSE);
            DEBUG_OUT_LASTERROR;
        }

        break;
    }
    case DVM_WINDOWDESTROY:
    {
        //
        // Restore the listview mode that we found on entry, unless the
        // user has changed away from report mode.
        //

        if (m_ulListViewModeOnEntry != INVALID_LISTVIEW_STYLE &&
            _GetChildListViewMode(hwndOwner) == LVS_REPORT)
        {
           _SetViewMode(hwndOwner, m_ulListViewModeOnEntry);
        }

        if (m_uRegister)
        {
            SHChangeNotifyDeregister(m_uRegister);
            CDll::LockServer(FALSE);
            m_uRegister = 0;
        }

        if (m_hwndNotify)
        {
            BOOL fOk = DestroyWindow(m_hwndNotify);

            m_hwndNotify = NULL;

            if (!fOk)
            {
                DEBUG_OUT_LASTERROR;
            }
        }
        break;
    }
    case SFVM_GETHELPTOPIC:
    {
        SFVM_HELPTOPIC_DATA * phtd = (SFVM_HELPTOPIC_DATA*)lParam;
        StrCpyW(phtd->wszHelpFile, L"mstask.chm");
        break;
    }

    default:
        hr = E_FAIL;

        #if DBG==1
            JFDbgOutCallbackMsg(uMsg);
        #endif // DBG==1
    }

    return hr;
}



//+--------------------------------------------------------------------------
//
//  Member:     CJobFolder::_SetViewMode
//
//  Synopsis:   Select the listview mode specified by [ulListViewStyle].
//
//  Arguments:  [hwndOwner]       - explorer window handle
//              [ulListViewStyle] - LVS_* in LVS_TYPEMASK.
//
//  History:    07-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CJobFolder::_SetViewMode(
    HWND hwndOwner,
    ULONG ulListViewStyle)
{
    switch (ulListViewStyle)
    {
    case LVS_ICON:
        PostMessage(hwndOwner, WM_COMMAND, VIEW_ICON_MENU_ID, 0);
        break;

    case LVS_REPORT:
        PostMessage(hwndOwner, WM_COMMAND, VIEW_DETAILS_MENU_ID, 0);
        break;

    case LVS_SMALLICON:
        PostMessage(hwndOwner, WM_COMMAND, VIEW_SMALLICON_MENU_ID, 0);
        break;

    case LVS_LIST:
        PostMessage(hwndOwner, WM_COMMAND, VIEW_LIST_MENU_ID, 0);
        break;

    default:
        DEBUG_OUT((DEB_ERROR,
                   "CJobFolder::_SetViewMode: invalid view mode 0x%x\n",
                   ulListViewStyle));
        break;
    }
}




//+--------------------------------------------------------------------------
//
//  Function:   EnumChildWindowCallback
//
//  Synopsis:   Fill hwnd pointed to by [lParam] with [hwnd] if [hwnd] has
//              class WC_LISTVIEW.
//
//
//  Arguments:  [hwnd]   - window to check
//              [lParam] - pointer to HWND
//
//  Returns:    TRUE  - continue enumeration
//              FALSE - [hwnd] is listview, *(HWND*)[lParam] = [hwnd], stop
//                       enumerating
//
//  Modifies:   *(HWND*)[lParam]
//
//  History:    07-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL CALLBACK
EnumChildWindowCallback(
    HWND hwnd,
    LPARAM lParam)
{
    TCHAR tszClassName[80];

    GetClassName(hwnd, tszClassName, ARRAYLEN(tszClassName));

    if (!lstrcmpi(tszClassName, WC_LISTVIEW))
    {
        *(HWND *)lParam = hwnd;
        return FALSE;
    }
    return TRUE;
}




//+--------------------------------------------------------------------------
//
//  Member:     CJobFolder::_GetChildListViewMode
//
//  Synopsis:   Return the LVS_* value representing the mode of the first
//              child listview control found for [hwndOwner].
//
//  Arguments:  [hwndOwner] -
//
//  Returns:    LVS_ICON, LVS_SMALLICON, LVS_REPORT, LVS_LIST, or
//              INVALID_LISTVIEW_STYLE.
//
//  History:    07-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

ULONG
CJobFolder::_GetChildListViewMode(
    HWND hwndOwner)
{
    HWND hwnd = NULL;

    EnumChildWindows(hwndOwner,
                     EnumChildWindowCallback,
                     (LPARAM)&hwnd);

    if (!hwnd)
    {
        DEBUG_OUT((DEB_ERROR,
                   "_GetChildListViewMode: can't find child listview\n"));
        return INVALID_LISTVIEW_STYLE;
    }

    LONG lStyle = GetWindowLong(hwnd, GWL_STYLE);

    return lStyle & LVS_TYPEMASK;
}




BOOL
CJobFolder::_ObjectAlreadyPresent(
    LPTSTR pszObj)
{
    BOOL fPresent = FALSE;

    PJOBID  pjid;
    LPTSTR  pszName = PathFindFileName(pszObj);
    LPTSTR  pszExt = PathFindExtension(pszName);
    TCHAR   tcSave;

    if (pszExt)
    {
        tcSave = *pszExt;
        *pszExt = TEXT('\0');
    }

    int cObjs = (int) ShellFolderView_GetObjectCount(m_hwndOwner);

    for (int i=0; i < cObjs; i++)
    {
        pjid = (PJOBID)ShellFolderView_GetObject(m_hwndOwner, i);

        if (lstrcmpi(pjid->GetName(), pszName) == 0)
        {
            fPresent = TRUE;
            break;
        }
    }

    if (pszExt)
    {
        *pszExt = tcSave;
    }

    return fPresent;
}

LRESULT
CJobFolder::HandleFsNotify(
    LONG lNotification,
    LPCITEMIDLIST* ppidl)
{
    HRESULT hr = S_OK;
    CJobID jid;
    LRESULT lr;
    TCHAR from[MAX_PATH];
    TCHAR to[MAX_PATH];

    SHGetPathFromIDList(ppidl[0], from);
    DEBUG_OUT((DEB_USER1, "First pidl<%ws>\n", from));

    switch (lNotification)
    {
    case SHCNE_RENAMEITEM:
    {
        DEBUG_OUT((DEB_USER1, "SHCNE_RENAMEITEM\n"));

        LPTSTR psFrom = PathFindFileName(from) - 1;
        *psFrom = TEXT('\0');

        SHGetPathFromIDList(ppidl[1], to);
        DEBUG_OUT((DEB_USER1, "Second pidl<%ws>\n", to));
        LPTSTR psTo = PathFindFileName(to) - 1;
        *psTo = TEXT('\0');

        BOOL fFromJF = (lstrcmpi(m_pszFolderPath, from) == 0);
        BOOL fToJF = (lstrcmpi(m_pszFolderPath, to) == 0);

        *psFrom = TEXT('\\');
        *psTo = TEXT('\\');

        if (fFromJF == FALSE)
        {
            if (fToJF == FALSE)
            {
                break; // Nothing to do with job folder
            }

            //
            // ADD object
            //

            // First check if this object doesn't already exist in the UI

            if (_ObjectAlreadyPresent(to) == FALSE)
            {
                hr = jid.Load(NULL, to);

                CHECK_HRESULT(hr);
                BREAK_ON_FAIL(hr);

                _AddObject(&jid);
            }
        }
        else
        {
            if (fToJF == TRUE)
            {
                // Rename

                hr = jid.Load(NULL, to);

                CHECK_HRESULT(hr);
                BREAK_ON_FAIL(hr);

                CJobID jidOld;

                jidOld.LoadDummy(PathFindFileName(from));

                hr = _UpdateObject(&jidOld, &jid);
            }
            else
            {
                // Delete

                // Need to create a dummy jobid

                jid.LoadDummy(PathFindFileName(from));

                _RemoveObject(&jid);
            }
        }

        break;
    }
    case SHCNE_CREATE:
    {
        DEBUG_OUT((DEB_USER1, "SHCNE_CREATE\n"));

        if (_ObjectAlreadyPresent(from) == FALSE)
        {
            //
            // Not present, so add it.
            //

            hr = jid.Load(NULL, from);

            if (hr == S_FALSE)
            {
                //
                // Task is hidden. Don't display it.
                //
                break;
            }

            CHECK_HRESULT(hr);
            BREAK_ON_FAIL(hr);

            hr = _AddObject(&jid);
        }

        break;
    }
    case SHCNE_DELETE:
        DEBUG_OUT((DEB_USER1, "SHCNE_DELETE\n"));

        jid.LoadDummy(from);

        _RemoveObject(&jid);

        break;

    case SHCNE_UPDATEDIR:
        DEBUG_OUT((DEB_USER1, "SHCNE_UPDATEDIR\n"));

        this->OnUpdateDir();

        break;

    case SHCNE_UPDATEITEM:
        DEBUG_OUT((DEB_USER1, "SHCNE_UPDATEITEM\n"));

        hr = jid.Load(NULL, from);

        if (hr == S_FALSE)
        {
            //
            // Task is hidden. Don't display it. Always remove from the ID list
            // to take care of the case where this notification was due to the
            // task being hidden.
            //
            _RemoveObject(&jid);
            break;
        }

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

        hr = _UpdateObject(&jid, &jid);

        break;

    default:
     DEBUG_OUT((DEB_USER1, "JF_FSNOTIFY unprocessed <0x%x>\n", lNotification));
#ifdef _CHICAGO_
        wsprintfA(to, "JF_FSNOTIFY unprocessed <0x%x>\n", lNotification);
        DbxDisplay(to);
#endif
    }

    return 0L;
}



LRESULT
CALLBACK
NotifyWndProc(
    HWND    hWnd,
    UINT    iMessage,
    WPARAM  wParam,
    LPARAM  lParam)
{
    DEBUG_OUT((DEB_USER12, "NWP<0x%x>\n", iMessage));

    switch (iMessage)
    {
    case STUBM_SETDATA:
        SetWindowLongPtr(hWnd, 0, wParam);
        return TRUE;

    case STUBM_GETDATA:
        return GetWindowLongPtr(hWnd, 0);

    case JF_FSNOTIFY:
    {
        CJobFolder * pjf = (CJobFolder*)GetWindowLongPtr(hWnd, 0);

        if (pjf == NULL)
        {
            DEBUG_OUT((DEB_ERROR, "NotifyWndProc: NULL CJobFolder pointer\n"));
            return FALSE;
        }

        pjf->HandleFsNotify((LONG)lParam, (LPCITEMIDLIST*)wParam);

        return TRUE;
    }
    default:
        return DefWindowProc(hWnd, iMessage, wParam, lParam);
    }
}

TCHAR const c_szNotifyWindowClass[] = TEXT("JF Notify Window Class");
TCHAR const c_szNULL[] = TEXT("");

HWND
I_CreateNotifyWnd(void)
{
    WNDCLASS wndclass;

    if (!GetClassInfo(g_hInstance, c_szNotifyWindowClass, &wndclass))
    {
        wndclass.style         = 0;
        wndclass.lpfnWndProc   = NotifyWndProc;
        wndclass.cbClsExtra    = 0;
        wndclass.cbWndExtra    = sizeof(PVOID) * 2;
        wndclass.hInstance     = g_hInstance;
        wndclass.hIcon         = NULL;
        wndclass.hCursor       = LoadCursor(NULL, IDC_ARROW);
        wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
        wndclass.lpszMenuName  = NULL;
        wndclass.lpszClassName = c_szNotifyWindowClass;

        if (!RegisterClass(&wndclass))
            return NULL;
    }

    return CreateWindowEx(WS_EX_TOOLWINDOW, c_szNotifyWindowClass, c_szNULL,
                      WS_OVERLAPPED, CW_USEDEFAULT, CW_USEDEFAULT, 0, 0,
                      NULL, NULL, g_hInstance, NULL);
}





#if DBG==1
void
JFDbgOutCallbackMsg(
    UINT    uMsg)
{
#define PROCESS_MSG(M) \
    case M: DEBUG_OUT((DEB_USER12, "UNPROCESSED msg<%s, %d>\n", #M, M)); break;

#define DONT_PROCESS_MSG(M) \
    case M: break;

    switch (uMsg)
    {
    DONT_PROCESS_MSG(DVM_GETHELPTEXT)
    DONT_PROCESS_MSG(DVM_GETTOOLTIPTEXT)
    DONT_PROCESS_MSG(DVM_GETBUTTONINFO)
    DONT_PROCESS_MSG(DVM_GETBUTTONS)
    DONT_PROCESS_MSG(DVM_INITMENUPOPUP)

    DONT_PROCESS_MSG(DVM_SELCHANGE)
    PROCESS_MSG(DVM_DRAWITEM)

    DONT_PROCESS_MSG(DVM_MEASUREITEM)
    DONT_PROCESS_MSG(DVM_EXITMENULOOP)

    PROCESS_MSG(DVM_RELEASE)

    DONT_PROCESS_MSG(DVM_GETCCHMAX)

    PROCESS_MSG(DVM_FSNOTIFY)

    DONT_PROCESS_MSG(DVM_WINDOWCREATED)
    DONT_PROCESS_MSG(DVM_WINDOWDESTROY)

    PROCESS_MSG(DVM_REFRESH)

    DONT_PROCESS_MSG(DVM_SETFOCUS)
    DONT_PROCESS_MSG(DVM_KILLFOCUS)

    PROCESS_MSG(DVM_QUERYCOPYHOOK)
    PROCESS_MSG(DVM_NOTIFYCOPYHOOK)

    DONT_PROCESS_MSG(DVM_GETDETAILSOF)
    DONT_PROCESS_MSG(DVM_COLUMNCLICK)

    PROCESS_MSG(DVM_QUERYFSNOTIFY)
    PROCESS_MSG(DVM_DEFITEMCOUNT)
    PROCESS_MSG(DVM_DEFVIEWMODE)
    PROCESS_MSG(DVM_UNMERGEMENU)
    PROCESS_MSG(DVM_INSERTITEM)
    PROCESS_MSG(DVM_DELETEITEM)

    DONT_PROCESS_MSG(DVM_UPDATESTATUSBAR)
    DONT_PROCESS_MSG(DVM_BACKGROUNDENUM)

    PROCESS_MSG(DVM_GETWORKINGDIR)

    DONT_PROCESS_MSG(DVM_GETCOLSAVESTREAM)
    DONT_PROCESS_MSG(DVM_SELECTALL)

    PROCESS_MSG(DVM_DIDDRAGDROP)
    PROCESS_MSG(DVM_FOLDERISPARENT)

    default:
        DEBUG_OUT((DEB_USER12, "UNKNOWN message <%d> !!!!\n", uMsg));
    }
}
#endif // DBG==1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\folderui\util.cxx ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       util.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    1/8/1996   RaviR   Created (Copied from BruceFo's lmshare)
//
//____________________________________________________________________________

#include "..\pch\headers.hxx"
#pragma hdrstop

#include "dbg.h"
#include <mstask.h>     // Necessary for util.hxx
#include "jobidl.hxx"
#include "util.hxx"
#include "resource.h"
#include "commdlg.h"
#include "..\inc\sadat.hxx"

extern HINSTANCE g_hInstance;

HRESULT
GetSchSvcState(
    DWORD &dwCurrState);

//___________________________________________________________________________
//___________________________________________________________________________
//___________________________________________________________________________
//___________________________________________________________________________
//
//  Menu merging routines
//___________________________________________________________________________
//___________________________________________________________________________
//___________________________________________________________________________
//___________________________________________________________________________


HMENU
LoadPopupMenu(
    HINSTANCE hinst,
    UINT id)
{
    HMENU hmParent = LoadMenu(hinst, MAKEINTRESOURCE(id));

    if (NULL == hmParent)
    {
        return NULL;
    }

    HMENU hmPopup = GetSubMenu(hmParent, 0);
    RemoveMenu(hmParent, 0, MF_BYPOSITION);
    DestroyMenu(hmParent);

    return hmPopup;
}


HMENU
UtGetMenuFromID(
    HMENU hmMain,
    UINT uID
    )
{
    MENUITEMINFO mii;

    mii.cbSize = sizeof(mii);
    mii.fMask  = MIIM_SUBMENU;
    mii.cch    = 0;     // just in case

    if (!GetMenuItemInfo(hmMain, uID, FALSE, &mii))
    {
        return NULL;
    }

    return mii.hSubMenu;
}


int
UtMergePopupMenus(
    HMENU hmMain,
    HMENU hmMerge,
    int   idCmdFirst,
    int   idCmdLast)
{
    int i;
    int idTemp;
    int idMax = idCmdFirst;

    for (i = GetMenuItemCount(hmMerge) - 1; i >= 0; --i)
    {
        MENUITEMINFO mii;

        mii.cbSize = sizeof(mii);
        mii.fMask  = MIIM_ID | MIIM_SUBMENU;
        mii.cch    = 0;     // just in case

        if (!GetMenuItemInfo(hmMerge, i, TRUE, &mii))
        {
            continue;
        }

        idTemp = Shell_MergeMenus(
                    UtGetMenuFromID(hmMain, mii.wID),
                    mii.hSubMenu,
                    0,
                    idCmdFirst,
                    idCmdLast,
                    MM_ADDSEPARATOR | MM_SUBMENUSHAVEIDS);

        if (idMax < idTemp)
        {
            idMax = idTemp;
        }
    }

    return idMax;
}


void
UtMergeMenu(
    HINSTANCE hinst,
    UINT idMainMerge,
    UINT idPopupMerge,
    LPQCMINFO pqcm)
{
    HMENU hmMerge;
    UINT  idMax = pqcm->idCmdFirst;
    UINT  idTemp;

    if (idMainMerge
        && (hmMerge = LoadPopupMenu(hinst, idMainMerge)) != NULL)
    {
        idMax = Shell_MergeMenus(
                        pqcm->hmenu,
                        hmMerge,
                        pqcm->indexMenu,
                        pqcm->idCmdFirst,
                        pqcm->idCmdLast,
                        MM_SUBMENUSHAVEIDS);

        DestroyMenu(hmMerge);
    }

    if (idPopupMerge
        && (hmMerge = LoadMenu(hinst, MAKEINTRESOURCE(idPopupMerge))) != NULL)
    {
        idTemp = UtMergePopupMenus(
                        pqcm->hmenu,
                        hmMerge,
                        pqcm->idCmdFirst,
                        pqcm->idCmdLast);

        if (idMax < idTemp)
        {
            idMax = idTemp;
        }

        DestroyMenu(hmMerge);
    }

    pqcm->idCmdFirst = idMax;
}




//+--------------------------------------------------------------------------
//
//  Function:   ContainsTemplateObject
//
//  Synopsis:   Return TRUE if [apidl] contains a CJobID object which is
//              marked as a template object.
//
//  Arguments:  [cidl]  - number of item id lists in [apidl]
//              [apidl] - array of item id lists, each of which can contain
//                          only one itemid.
//
//  History:    5-09-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
ContainsTemplateObject(
    UINT cidl,
    LPCITEMIDLIST *apidl)
{
    UINT i;

    for (i = 0; i < cidl; i++)
    {
        if (JF_IsValidID(apidl[i]))
        {
            if (((PJOBID) apidl[i])->IsTemplate())
            {
                return TRUE;
            }
        }
        else
        {
            DEBUG_OUT((DEB_WARN, "ContainsTemplateObject: item %u not jobid\n", i));
        }
    }
    return FALSE;
}


//____________________________________________________________________________
//
//  Function:   EnsureUniquenessOfFileName
//
//  Synopsis:   Internal function. pszFile's buffer size assumed to be
//              greater than MAX_PATH.
//
//  Arguments:  [pszFile] -- IN
//
//  Returns:    void
//
//  History:    2/8/1996   RaviR   Created
//
//____________________________________________________________________________

void
EnsureUniquenessOfFileName(
    LPTSTR  pszFile)
{
	Win4Assert( NULL != pszFile );

    int     iPostFix = 2;

    LPTSTR  pszName = PathFindFileName(pszFile);
    LPTSTR  pszExt = PathFindExtension(pszName);

    TCHAR szBufExt[10];
    lstrcpy(szBufExt, pszExt);

    int lenUpToExt = (int)(pszExt - pszFile); // lstrlen(pszFile) - lstrlen(pszExt)

    Win4Assert(lenUpToExt >= 0);

    //
    //  Ensure uniqueness of the file
    //

    while (1)
    {
        HANDLE hFile = CreateFile(pszFile, GENERIC_READ,
                                FILE_SHARE_READ, NULL, OPEN_EXISTING,
                                FILE_FLAG_SEQUENTIAL_SCAN, NULL);

        if (hFile == INVALID_HANDLE_VALUE)
        {
            // No file with this name exists. So this name is unique.
            break;
        }
        else
        {
            CloseHandle(hFile);

            // post fix a number to make the file name unique
            TCHAR szBufPostFix[10];
            wsprintf(szBufPostFix, TEXT(" %d"), iPostFix++);

            lstrcpy(&pszFile[lenUpToExt], szBufPostFix);

            lstrcat(&pszFile[lenUpToExt], szBufExt);
        }
    }
}




//+--------------------------------------------------------------------------
//
//  Function:   CheckSaDat
//
//  Synopsis:   Update or create the sa.dat file if it is missing or its
//              waitable timer support flag disagrees with what the system
//              reports.
//
//  Arguments:  [tszFolderPath] - path to tasks folder
//
//  History:    11-12-1997   DavidMun   Created
//
//  Notes:      Call only with [tszFolderPath] a path on the local machine.
//
//---------------------------------------------------------------------------

VOID
CheckSaDat(
    LPCTSTR tszFolderPath)
{
    HRESULT hr;
    DWORD dwVersion;
    BYTE  bSvcFlags;
    BYTE  bPlatformId;

    hr = SADatGetData(tszFolderPath,
                      &dwVersion,
                      &bPlatformId,
                      &bSvcFlags);

    BOOL fNeedUpdate = FALSE;

    if (SUCCEEDED(hr))
    {
        BOOL fSaDatTimersFlag = bSvcFlags & SA_DAT_SVCFLAG_RESUME_TIMERS;
        BOOL fTimers = ResumeTimersSupported();

        if (fSaDatTimersFlag && !fTimers || !fSaDatTimersFlag && fTimers)
        {
            fNeedUpdate = TRUE;
        }
    }
    else
    {
        fNeedUpdate = TRUE;
    }

    if (fNeedUpdate)
    {
        DWORD dwState;

        hr = GetSchSvcState(dwState);

        if (SUCCEEDED(hr))
        {

            BOOL fRunning = (dwState != SERVICE_STOPPED &&
                             dwState != SERVICE_STOP_PENDING);

            SADatCreate(tszFolderPath, fRunning);
        }
    }
}




#if DBG==1

LPTSTR DbgGetTimeStr(FILETIME &ft)
{
    SYSTEMTIME st;
    FileTimeToSystemTime(&ft, &st);
    return DbgGetTimeStr(st);
}

LPTSTR DbgGetTimeStr(SYSTEMTIME &st)
{
    static TCHAR s_szTimeStamp[20];  // space for time & date in format below

    wsprintf(s_szTimeStamp,
        TEXT("%02d:%02d:%02d %d/%02d/%d"),
        st.wHour,
        st.wMinute,
        st.wSecond,
        st.wMonth,
        st.wDay,
        st.wYear);

    return s_szTimeStamp;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\folderui\sdetails.cxx ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       sdetails.cxx
//
//  Contents:   implementation of IShellDetails
//
//  Classes:    CJobsSD
//
//  Functions:
//
//  History:    1/4/1996   RaviR   Created
//
//____________________________________________________________________________


#include "..\pch\headers.hxx"
#pragma hdrstop

#include "dbg.h"
#include "macros.h"
#include "resource.h"

#include "dll.hxx"
#include "jobidl.hxx"
#include "util.hxx"
#include "common.hxx"

//
// extern
//

extern HINSTANCE g_hInstance;



//////////////////////////////////////////////////////////////////////////////
//  Forward declaration of local functions
//

BOOL
GetLocaleDateTimeString(
    SYSTEMTIME*     pst,
    DWORD           dwDateFlags,
    DWORD           dwTimeFlags,
    TCHAR           szBuff[],
    int             cchBuffLen,
    LPSHELLDETAILS  lpDetails);


//////////////////////////////////////////////////////////////////////////////
//
//  Define the columns (used by CJobsSD::GetDetailsOf)
//

struct COL_INFO
{
    UINT idString;
    int  fmt;
    UINT cxChar;
};

const COL_INFO c_ColumnHeaders[] =
{                                      
    {IDS_NAME,         LVCFMT_LEFT,  30},
    {IDS_SCHEDULE,     LVCFMT_LEFT,  20},
    {IDS_NEXTRUNTIME,  LVCFMT_LEFT,  15},
    {IDS_LASTRUNTIME,  LVCFMT_LEFT,  15},
    {IDS_STATUS,       LVCFMT_LEFT,  25},
#if !defined(_CHICAGO_)
    {IDS_LASTEXITCODE, LVCFMT_RIGHT, 15},
    {IDS_CREATOR,      LVCFMT_LEFT,  15}
#endif // !defined(_CHICAGO_)
};


//____________________________________________________________________________
//
//  Class:      CJobsSD
//
//  Purpose:    Provide IShellDetails interface to Job Folder objects.
//
//  History:    1/24/1996   RaviR   Created
//____________________________________________________________________________

class CJobsSD : public IShellDetails
{
public:
    CJobsSD(HWND hwnd) : m_ulRefs(1), m_hwnd(hwnd) {}
    ~CJobsSD() {}

    // IUnknown methods
    DECLARE_STANDARD_IUNKNOWN;

    // IShellDetails methods
    STDMETHOD(GetDetailsOf)(LPCITEMIDLIST pidl, UINT iColumn,
                            LPSHELLDETAILS pDetails);
    STDMETHOD(ColumnClick)(UINT iColumn);

private:
    HWND    m_hwnd;
    CDllRef m_DllRef;
};


//____________________________________________________________________________
//
//  Member:     CJobsSD::IUnknown methods
//____________________________________________________________________________

IMPLEMENT_STANDARD_IUNKNOWN(CJobsSD)

STDMETHODIMP
CJobsSD::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    if (IsEqualIID(IID_IUnknown, riid) ||
        IsEqualIID(IID_IShellDetails, riid))
    {
        *ppvObj = (IUnknown*)(IShellDetails*) this;
        this->AddRef();
        return S_OK;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
}


inline
HRESULT
CopyToSTRRET(STRRET &str, LPTSTR pszIn)
{
    UINT uiByteLen = (lstrlen(pszIn) + 1) * sizeof(TCHAR);

#ifdef UNICODE

    str.uType = STRRET_WSTR;

    str.pOleStr = (LPWSTR) SHAlloc(uiByteLen);

    if (str.pOleStr == NULL)
    {
        CHECK_HRESULT(E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }

    CopyMemory(str.pOleStr, pszIn, uiByteLen);

#else // ANSI

    str.uType = STRRET_CSTR;

    CopyMemory(str.cStr, pszIn, uiByteLen);

#endif // ANSI

    return S_OK;
}


//____________________________________________________________________________
//
//  Member:     CJobsSD::GetDetailsOf
//
//  Arguments:  [pidl] -- IN
//              [iColumn] -- IN
//              [lpDetails] -- IN
//
//  Returns:    HRESULT.
//
//  History:    1/8/1996   RaviR   Created
//
//____________________________________________________________________________

STDMETHODIMP
CJobsSD::GetDetailsOf(
    LPCITEMIDLIST pidl,
    UINT iColumn,
    LPSHELLDETAILS lpDetails)
{
    // TRACE(CJobsSD, GetDetailsOf);

    HRESULT hr = S_OK;
    TCHAR   tcBuff[SCH_XBIGBUF_LEN] = TEXT("");

    if (iColumn >= COLUMN_COUNT)
    {
        return E_FAIL;
    }

    if (NULL == pidl)
    {
        // 
        // Caller wants strings for the column headers
        //

        LoadString(g_hInstance,
                   c_ColumnHeaders[iColumn].idString,
                   tcBuff,
                   SCH_XBIGBUF_LEN);

        lpDetails->fmt    = c_ColumnHeaders[iColumn].fmt;
        lpDetails->cxChar = c_ColumnHeaders[iColumn].cxChar;
    }
    else
    {
        CJobID & jid = *(PJOBID)pidl;

        //
        // Fill tcBuff with the string describing column iColumn of
        // object jid.  If jid represents a template object, only the
        // name column is not blank.
        //

        if (!jid.IsTemplate() || iColumn == COLUMN_NAME)
        {
            switch (iColumn)
            {
            case COLUMN_NAME:
            {
                lstrcpy(tcBuff, jid.GetName());
    
                break;
            }
            case COLUMN_SCHEDULE:
            {
                if (jid.IsJobFlagOn(TASK_FLAG_DISABLED) == TRUE)
                {
                    LoadString(g_hInstance,
                               IDS_DISABLED,
                               tcBuff,
                               SCH_XBIGBUF_LEN);
                }
                else if (jid.GetTriggerCount() > 1)
                {
                    LoadString(g_hInstance,
                               IDS_MULTIPLE_TRIGGERS, 
                               tcBuff, 
                               SCH_XBIGBUF_LEN);
                }
                else
                {
                    hr = GetTriggerStringFromTrigger(&jid.GetTrigger(),
                                                     tcBuff,
                                                     SCH_XBIGBUF_LEN,
                                                     lpDetails);
                }
    
                break;
            }
            case COLUMN_LASTRUNTIME:
            {
                SYSTEMTIME &st = jid.GetLastRunTime();
    
                if (st.wYear == 0 || st.wMonth == 0 || st.wDay == 0)
                {
                    LoadString(g_hInstance,
                               IDS_NEVER,
                               tcBuff,
                               SCH_XBIGBUF_LEN);
                }
                else
                {
                    GetLocaleDateTimeString(&st,
                                            DATE_SHORTDATE,
                                            0,
                                            tcBuff,
                                            SCH_XBIGBUF_LEN, lpDetails);
                }
    
                break;
            }

            case COLUMN_NEXTRUNTIME:
                jid.GetNextRunTimeString(tcBuff, SCH_XBIGBUF_LEN, FALSE, lpDetails);
                break;
    
            case COLUMN_STATUS:
            {
                ULONG ids = 0;

                if (jid.IsRunning())
                {
                    ids = IDS_RUNNING;
                }
                else if (jid.WasRunMissed())
                {
                    ids = IDS_MISSED;
                }
                else if (jid.DidJobStartFail())
                {
                    ids = IDS_START_FAILED;
                }
                else if(jid.DidJobBadAcct())
                {
                    ids = IDS_BAD_ACCT;
                }
                else if(jid.DidJobRestAcct())
                {
                    ids = IDS_REST_ACCT;
                }

                if (ids)
                {
                    LoadString(g_hInstance, ids, tcBuff, SCH_XBIGBUF_LEN);
                }
                break;
            }

#if !defined(_CHICAGO_)
            case COLUMN_LASTEXITCODE:
                wsprintf(tcBuff, TEXT("0x%x"), jid.GetExitCode());
                break;
    
            case COLUMN_CREATOR:
                lstrcpy(tcBuff, jid.GetCreator());
                break;
#endif // !defined(_CHICAGO_)
            }
        }
    }

    hr = CopyToSTRRET(lpDetails->str, tcBuff);

    return hr;
}


//____________________________________________________________________________
//
//  Member:     CJobsSD::ColumnClick
//
//  Arguments:  [iColumn] -- IN
//
//  Returns:    STDMETHODIMP
//
//  History:    1/8/1996   RaviR   Created
//
//____________________________________________________________________________

STDMETHODIMP
CJobsSD::ColumnClick(
    UINT iColumn)
{
    TRACE(CJobsSD, ColumnClick);

    ShellFolderView_ReArrange(m_hwnd, iColumn);

    return S_OK;
}

//
//Define the UNICODE RLM control character.
//
#ifdef UNICODE 
#define RLM TEXT("\x200f")
#else
#define RLM TEXT("\xfe")
#endif
//+-------------------------------------------------------------------------
//
//  Function:   GetLocaleDateTimeString, public
//
//  Synopsis:   Use the proper locale-formatted time and date
//
//  History:    07/09/95   RaviR Created.
//
//--------------------------------------------------------------------------

BOOL
GetLocaleDateTimeString(
    SYSTEMTIME*     pst,
    DWORD           dwDateFlags,
    DWORD           dwTimeFlags,
    TCHAR           szBuff[],
    int             cchBuffLen,
    LPSHELLDETAILS  lpDetails)
{
    if (pst->wYear == 0 || pst->wMonth == 0 || pst->wDay == 0)
    {
        szBuff = TEXT('\0');
        return TRUE;
    }

    LCID  lcid = GetUserDefaultLCID();
    TCHAR Time[150] = TEXT("");
    TCHAR Date[150] = TEXT("");

    if (0 == GetTimeFormat(lcid, dwTimeFlags, pst, NULL, Time, 150))
    {
        DEBUG_OUT_LASTERROR;
        return FALSE;
    }

#ifdef UNICODE
    if (lpDetails) {
        if (lpDetails->fmt & LVCFMT_RIGHT_TO_LEFT) {
            dwDateFlags |=  DATE_RTLREADING;
        } else if (lpDetails->fmt & LVCFMT_LEFT_TO_RIGHT) {
            dwDateFlags |=  DATE_LTRREADING;
        }
    }
#endif

    if (0 == GetDateFormat(lcid, dwDateFlags, pst, NULL, Date, 150))
    {
        DEBUG_OUT_LASTERROR;
        return FALSE;
    }

    //
    //Force the time to appears as if it is preceded by BiDi character.
    //
#ifdef UNICODE
    if (dwDateFlags & DATE_RTLREADING) {
        lstrcpy(szBuff, RLM);
        lstrcat(szBuff, Time);
    } else 
#endif
        lstrcpy(szBuff, Time);

    lstrcat(szBuff, TEXT("  "));
    lstrcat(szBuff, Date);

    return TRUE;
}



//____________________________________________________________________________
//
//  Function:   CJobsShellDetails_Create
//
//  Synopsis:   S
//
//  Arguments:  [hwnd] -- IN
//              [riid] -- IN
//              [ppvObj] -- IN
//
//  Returns:    HRESULT
//
//  History:    1/24/1996   RaviR   Created
//____________________________________________________________________________

HRESULT
JFGetShellDetails(
    HWND    hwnd,
    LPVOID* ppvObj)
{
    CJobsSD* pObj = new CJobsSD(hwnd);

    if (NULL == pObj)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pObj->QueryInterface(IID_IShellDetails, ppvObj);

    pObj->Release();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\folderui\wraps.cxx ===
#include "..\pch\headers.hxx"
#pragma hdrstop

//
// We need this wrapper for ILCreateFromPath since it was a TCHAR exported by ordinal
// on NT4 and now has A/W versions on NT5. Since we want to be able to run on both of
// these platforms we wrap the API here.
//
// This api just loads shell32, and calls ordinal 157 which is the old TCHAR export
//
typedef LPITEMIDLIST (__stdcall *PFNILCREATEFROMPATH)(LPCTSTR pszPath);

STDAPI_(LPITEMIDLIST) Wrap_ILCreateFromPath(LPCTSTR pszPath)
{
    static PFNILCREATEFROMPATH pfn = (PFNILCREATEFROMPATH)-1;

    if (pfn == (PFNILCREATEFROMPATH)-1)
    {
        HINSTANCE hinst = GetModuleHandle(TEXT("shell32.dll"));

        if (hinst)
        {
            pfn = (PFNILCREATEFROMPATH) GetProcAddress(hinst, (LPCSTR)157);
        }
        else
        {
            pfn = NULL;
        }
    }

    if (pfn)
    {
        return pfn(pszPath);
    }
    
    // If we failed for some reason, just return NULL
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\idletask\client\idletskc.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    idletskc.h

Abstract:

    This module contains private declarations to support idle tasks.
    Note that client does not stand for the users of the idle task
    API, but the code in the users process that implements these APIs.
    
Author:

    Dave Fields (davidfie) 26-July-1998
    Cenk Ergan (cenke) 14-June-2000

Revision History:

--*/

#ifndef _IDLETSKC_H_
#define _IDLETSKC_H_

//
// Include common definitions.
//

#include "idlrpc.h"
#include "idlecomn.h"

//
// Client function declarations.
//

DWORD
ItCliInitialize(
    VOID
    );

VOID
ItCliUninitialize(
    VOID
    );

DWORD
ItCliRegisterIdleTask (
    IN IT_IDLE_TASK_ID IdleTaskId,
    OUT HANDLE *ItHandle,
    OUT HANDLE *StartEvent,
    OUT HANDLE *StopEvent
    );

VOID
ItCliUnregisterIdleTask (
    IN HANDLE ItHandle,
    IN HANDLE StartEvent,
    IN HANDLE StopEvent   
    );

#endif // _IDLETSKC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\idletask\client\idlrpc_client.c ===
#include <idlrpc_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\idl\atsvcinc.h ===
/*++

Copyright (c) 1991 - 2002 Microsoft Corporation

Module Name:

    AtSvcInc.h

Abstract:

    This file allows us to include standard system header files in the AtSvc.idl file.
    The main AtSvc.idl file imports a file called AtSvcInc.idl.  This allows the .idl
    file to use the types defined in these header files.  It also causes the following
    line to be added in the MIDL generated header file:

    #include "AtSvcInc.h"

    Thus these types are available to the RPC stub routines as well.

--*/

#include <windef.h>
#include <lmcons.h>
#include <lmat.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\folderui\xicon.cxx ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       xicon.cxx
//
//  Contents:   implementation of CJobsEI & CJobsEIA classes.
//
//  Classes:
//
//  Functions:
//
//  History:    1/4/1996   RaviR   Created
//
//____________________________________________________________________________

#include "..\pch\headers.hxx"
#pragma hdrstop

#include "dbg.h"
#include "macros.h"
#include "..\inc\resource.h"

#include "dll.hxx"
#include "jobidl.hxx"
#include "util.hxx"
#include "jobicons.hxx"

//
// extern
//

extern HINSTANCE g_hInstance;

//#undef DEB_TRACE
//#define DEB_TRACE DEB_USER1


const TCHAR c_szTask[] = TEXT("task!");
extern const TCHAR TEMPLATE_STR[] = TEXT("wizard:");

//____________________________________________________________________________
//
//  Class:      CJobsEI
//
//  Purpose:    Provide IExtractIcon interface to Job Folder objects.
//
//  History:    1/24/1996   RaviR   Created
//____________________________________________________________________________

class CJobsEI : public IExtractIcon
{
public:
    CJobsEI(LPCTSTR pszFolderPath, LPITEMIDLIST pidl)
        : m_pszFolderPath(pszFolderPath), m_pidl(pidl),
          m_JobIcon(), m_ulRefs(1) {}

    ~CJobsEI() { ILFree(m_pidl); }

    // IUnknown methods
    DECLARE_STANDARD_IUNKNOWN;

    // IExtractIcon methods
    STDMETHOD(GetIconLocation)(UINT uFlags, LPTSTR szIconFile, UINT cchMax,
                                int *piIndex, UINT *pwFlags);
    STDMETHOD(Extract)(LPCTSTR pszFile, UINT nIconIndex, HICON *phiconLarge,
                                HICON *phiconSmall, UINT nIconSize);
private:
    CDllRef         m_DllRef;
    LPCTSTR         m_pszFolderPath;
    LPITEMIDLIST    m_pidl;
    CJobIcon        m_JobIcon;
};

//____________________________________________________________________________
//
//  Member:     IUnknown methods
//____________________________________________________________________________

IMPLEMENT_STANDARD_IUNKNOWN(CJobsEI);

STDMETHODIMP
CJobsEI::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    if (IsEqualIID(IID_IUnknown, riid) ||
        IsEqualIID(IID_IExtractIcon, riid))
    {
        *ppvObj = (IUnknown*)(IExtractIcon*) this;
        this->AddRef();
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}


//____________________________________________________________________________
//
//  Member:     CJobsEI::IExtractIcon::GetIconLocation
//
//  Arguments:  [uFlags] -- IN
//              [szIconFile] -- IN
//              [cchMax] -- IN
//              [piIndex] -- IN
//              [pwFlags] -- IN
//
//  Returns:    HTRESULT
//
//  History:    1/5/1996   RaviR   Created
//
//____________________________________________________________________________

STDMETHODIMP
CJobsEI::GetIconLocation(
    UINT    uFlags,
    LPTSTR  szIconFile,
    UINT    cchMax,
    int   * piIndex,
    UINT  * pwFlags)
{
    TRACE(CJobsEI, GetIconLocation);

    szIconFile[0] = '\0'; // init

    if (uFlags & GIL_OPENICON)
    {
        return S_FALSE;
    }

    *pwFlags = GIL_NOTFILENAME | GIL_PERINSTANCE;

    PJOBID pjid = (PJOBID)m_pidl;

    if (cchMax <= (UINT)(lstrlen(c_szTask) + lstrlen(pjid->GetAppName())))
    {
        DEBUG_OUT((DEB_ERROR, 
                   "CJobsEI::GetIconLocation: insufficient buffer\n"));
        return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }

    lstrcpy(szIconFile, c_szTask);

    if (pjid->IsTemplate())
    {
        lstrcat(szIconFile, TEMPLATE_STR);
        *piIndex = 0;
    }
    else 
    {
        lstrcat(szIconFile, pjid->GetAppName());
        *piIndex = ! pjid->IsJobFlagOn(TASK_FLAG_DISABLED);
    }

    return S_OK;
}



//____________________________________________________________________________
//
//  Member:     CJobsEI::Extract
//
//  Arguments:  [pszFile] -- IN
//              [nIconIndex] -- IN
//              [phiconLarge] -- IN
//              [phiconSmall] -- IN
//              [nIconSize] -- IN
//
//  Returns:    STDMETHODIMP
//
//  History:    1/5/1996   RaviR   Created
//____________________________________________________________________________

STDMETHODIMP
CJobsEI::Extract(
    LPCTSTR pszFile,
    UINT    nIconIndex,
    HICON * phiconLarge,
    HICON * phiconSmall,
    UINT    nIconSize)
{
    TRACE(CJobsEI, Extract);

    if (((PJOBID)m_pidl)->IsTemplate())
    {
        m_JobIcon.GetTemplateIcons(phiconLarge, phiconSmall);
    }
    else
    {
        m_JobIcon.GetIcons(((PJOBID)m_pidl)->GetAppName(), 
                           nIconIndex,
                           phiconLarge, 
                           phiconSmall);
    }

    return S_OK;
}


//____________________________________________________________________________
//
//  Function:   JFGetExtractIcon
//
//  Synopsis:   Function to create IExtractIcon
//
//  Arguments:  [ppvObj] -- OUT
//
//  Returns:    HRESULT
//
//  History:    1/31/1996   RaviR   Created
//
//____________________________________________________________________________

HRESULT
JFGetExtractIcon(
    LPVOID        * ppvObj,
    LPCTSTR         pszFolderPath,
    LPCITEMIDLIST   pidl)
{
    Win4Assert(pidl != NULL);

    LPITEMIDLIST pidlClone = ILClone(pidl);

    if (pidlClone == NULL)
    {
        CHECK_HRESULT(E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }

    CJobsEI* pObj = new CJobsEI(pszFolderPath, pidlClone);

    if (NULL == pObj)
    {
        ILFree(pidlClone);
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pObj->QueryInterface(IID_IExtractIcon, ppvObj);

    pObj->Release();

    return hr;
}




////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
//////////////////// CJobsEIA //////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////




#ifdef UNICODE


//____________________________________________________________________________
//
//  Class:      CJobsEIA
//
//  Purpose:    Provide IExtractIconA interface to Job Folder objects.
//
//  History:    1/24/1996   RaviR   Created
//____________________________________________________________________________

class CJobsEIA : public IExtractIconA
{
public:
    CJobsEIA(LPCTSTR pszFolderPath, LPITEMIDLIST pidl)
        : m_pszFolderPath(pszFolderPath), m_pidl(pidl),
          m_JobIcon(), m_ulRefs(1) {}

    ~CJobsEIA() { ILFree(m_pidl); }

    // IUnknown methods
    DECLARE_STANDARD_IUNKNOWN;

    // IExtractIcon methods
    STDMETHOD(GetIconLocation)(UINT uFlags, LPSTR szIconFile, UINT cchMax,
                                int *piIndex, UINT *pwFlags);
    STDMETHOD(Extract)(LPCSTR pszFile, UINT nIconIndex, HICON *phiconLarge,
                                HICON *phiconSmall, UINT nIconSize);
private:
    CDllRef         m_DllRef;
    LPCTSTR         m_pszFolderPath;
    LPITEMIDLIST    m_pidl;
    CJobIcon        m_JobIcon;
};


//____________________________________________________________________________
//
//  Member:     IUnknown methods
//____________________________________________________________________________

IMPLEMENT_STANDARD_IUNKNOWN(CJobsEIA);

STDMETHODIMP
CJobsEIA::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    if (IsEqualIID(IID_IUnknown, riid) ||
        IsEqualIID(IID_IExtractIconA, riid))
    {
        *ppvObj = (IUnknown*)(IExtractIconA*) this;
        this->AddRef();
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}


//____________________________________________________________________________
//
//  Member:     CJobsEIA::GetIconLocation
//
//  Arguments:  [uFlags] -- IN
//              [szIconFile] -- IN
//              [cchMax] -- IN
//              [piIndex] -- IN
//              [pwFlags] -- IN
//
//  Returns:    HTRESULT
//
//  History:    1/5/1996   RaviR   Created
//
//____________________________________________________________________________

STDMETHODIMP
CJobsEIA::GetIconLocation(
    UINT    uFlags,
    LPSTR   szIconFile,
    UINT    cchMax,
    int   * piIndex,
    UINT  * pwFlags)
{
    TRACE(CJobsEIA, GetIconLocation);
    HRESULT hr = S_OK;

    szIconFile[0] = '\0'; // init

    if (uFlags & GIL_OPENICON)
    {
        return S_FALSE;
    }

    *pwFlags = GIL_NOTFILENAME | GIL_PERINSTANCE;

    WCHAR wcBuff[MAX_PATH];

    PJOBID pjid = (PJOBID)m_pidl;

    lstrcpy(wcBuff, c_szTask);

    if (pjid->IsTemplate())
    {
        lstrcat(wcBuff, TEMPLATE_STR);
        *piIndex = 0;
    }
    else 
    {
        lstrcat(wcBuff, pjid->GetAppName());
        *piIndex = ! pjid->IsJobFlagOn(TASK_FLAG_DISABLED);
    }

    hr = UnicodeToAnsi(szIconFile, wcBuff, cchMax);


    return hr;
}

//____________________________________________________________________________
//
//  Member:     CJobsEIA::Extract
//
//  Arguments:  [pszFile] -- IN
//              [nIconIndex] -- IN
//              [phiconLarge] -- IN
//              [phiconSmall] -- IN
//              [nIconSize] -- IN
//
//  Returns:    HTRESULT
//
//  History:    1/5/1996   RaviR   Created
//
//____________________________________________________________________________

STDMETHODIMP
CJobsEIA::Extract(
    LPCSTR pszFile,
    UINT   nIconIndex,
    HICON* phiconLarge,
    HICON* phiconSmall,
    UINT   nIconSize)
{
    TRACE(CJobsEIA, Extract);


    if (((PJOBID)m_pidl)->IsTemplate())
    {
        m_JobIcon.GetTemplateIcons(phiconLarge, phiconSmall);
    }
    else
    {
        m_JobIcon.GetIcons(((PJOBID)m_pidl)->GetAppName(), 
                           nIconIndex,
                           phiconLarge, 
                           phiconSmall);
    }
    return S_OK;
}


//____________________________________________________________________________
//
//  Function:   JFGetExtractIconA
//
//  Synopsis:   Function to create IExtractIconA
//
//  Arguments:  [ppvObj] -- OUT
//
//  Returns:    HRESULT
//
//  History:    1/31/1996   RaviR   Created
//
//____________________________________________________________________________

HRESULT
JFGetExtractIconA(
    LPVOID        * ppvObj,
    LPCTSTR         pszFolderPath,
    LPCITEMIDLIST   pidl)
{
    Win4Assert(pidl != NULL);

    LPITEMIDLIST pidlClone = ILClone(pidl);

    if (pidlClone == NULL)
    {
        CHECK_HRESULT(E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }

    CJobsEIA* pObj = new CJobsEIA(pszFolderPath, pidlClone);

    if (NULL == pObj)
    {
        ILFree(pidlClone);
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pObj->QueryInterface(IID_IExtractIcon, ppvObj);

    pObj->Release();

    return hr;
}


#endif // UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\folderui\viewlog.cxx ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       viewlog.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    3/25/1996   RaviR   Created
//
//____________________________________________________________________________

#include "..\pch\headers.hxx"
#pragma hdrstop

#include "dbg.h"
#include "macros.h"

#include "..\inc\common.hxx"
#include "..\inc\resource.h"
#include "..\inc\misc.hxx"
#include "resource.h"

extern HINSTANCE g_hInstance;


LRESULT
OnViewLog_RegGetValue(
    HKEY    hKeyMachine,
    LPCTSTR pszValueName,
    LPTSTR  pszValueStr);


#define SUBKEY_LOGPATH      TEXT("LogPath")


#ifdef UNICODE
#define FMT_TSTR    "%S"
#else
#define FMT_TSTR    "%s"
#endif


//____________________________________________________________________________
//
//  Function:   OnViewLog
//
//  Synopsis:   Open the job sheduler log.
//
//  Arguments:  [hwndOwner] -- IN
//
//  Returns:    void
//
//  History:    3/25/1996   RaviR   Created
//
//____________________________________________________________________________

void
OnViewLog(
    LPTSTR  lpMachineName,
    HWND    hwndOwner)
{
    TCHAR   tszLogPath[MAX_PATH + 1];
    ULONG   ulTemp;
    HKEY    hKeyMachine = HKEY_LOCAL_MACHINE;
    LRESULT lr = 0;

    if (lpMachineName != NULL)
    {
        lr = RegConnectRegistry(lpMachineName, HKEY_LOCAL_MACHINE,
                                                        &hKeyMachine);
        if (lr != ERROR_SUCCESS)
        {
            CHECK_LASTERROR(lr);
            return;
        }
    }

    //
    //  Get the log file name.
    //

    lr = OnViewLog_RegGetValue(hKeyMachine, SUBKEY_LOGPATH, tszLogPath);

    RegCloseKey(hKeyMachine);

    if (lr == ERROR_SUCCESS)
    {
        if (lpMachineName != NULL)
        {
            // If path is drive based convert it to share based.
            if (s_isDriveLetter(tszLogPath[0]) && tszLogPath[1] == TEXT(':'))
            {
                TCHAR tszBuf[MAX_PATH + 1];

                lstrcpy(tszBuf, tszLogPath);
                tszBuf[1] = TEXT('$');

                if (lpMachineName[0] == TEXT('\\'))
                {
                    Win4Assert(lpMachineName[1] == TEXT('\\'));
                    tszLogPath[0] = TEXT('\0');
                }
                else
                {
                    lstrcpy(tszLogPath, TEXT("\\\\"));
                }

                lstrcat(tszLogPath, lpMachineName);
                lstrcat(tszLogPath, TEXT("\\"));
                lstrcat(tszLogPath, tszBuf);

                DEBUG_OUT((DEB_USER1, "Viewing log -> " FMT_TSTR "\n", tszLogPath));
            }
        }
    }
    else
    {
        if (lpMachineName == NULL)
        {
            CHECK_LASTERROR(lr);
            return;
        }

        ulTemp = ExpandEnvironmentStrings(TSZ_LOG_NAME_DEFAULT,
                                            tszLogPath, MAX_PATH);

        if (ulTemp == 0)
        {
            DEBUG_OUT_LASTERROR;
            return;
        }

        if (ulTemp > MAX_PATH)
        {
            CHECK_LASTERROR(ERROR_INSUFFICIENT_BUFFER);
            return;
        }
    }

    //
    //  Create a process to open the log.
    //

    HINSTANCE hinst = ShellExecute(0, TEXT("open"), tszLogPath, 0, 0, SW_SHOW);

    if ((INT_PTR)hinst <= 32)
    {
        DEBUG_OUT((DEB_ERROR, " returned %dL\n", hinst));
    }
}


//____________________________________________________________________________
//
//  Function:   OnViewLog_RegGetValue
//
//  Synopsis:   S
//
//  Arguments:  [pszValueName] -- IN
//              [pszValueStr] -- IN
//
//  Returns:    LRESULT
//
//  History:    3/25/1996   RaviR   Created
//
//____________________________________________________________________________

LRESULT
OnViewLog_RegGetValue(
    HKEY    hKeyMachine,
    LPCTSTR pszValueName,
    LPTSTR  pszValueStr)
{
    HKEY    hKey = NULL;
    LRESULT lr = ERROR_SUCCESS;

    //
    // Read the log path and maximum size from the registry.
    //

    lr = RegOpenKeyEx(hKeyMachine, SCH_AGENT_KEY, 0, KEY_READ, &hKey);

    if (lr == ERROR_SUCCESS)
    {
        TCHAR szBuff[MAX_PATH];
        DWORD dwTemp = MAX_PATH * sizeof(TCHAR);
        DWORD dwType;

        lr = RegQueryValueEx(hKey, pszValueName, 0, &dwType,
                            (UCHAR *)szBuff, &dwTemp);

        if (lr == ERROR_SUCCESS)
        {
            switch (dwType)
            {
            case REG_SZ:
                CopyMemory(pszValueStr, szBuff, dwTemp);
                break;

            case REG_EXPAND_SZ:
                dwTemp = ExpandEnvironmentStrings(szBuff, pszValueStr,
                                                              MAX_PATH);
                if (dwTemp > MAX_PATH)
                {
                    lr = ERROR_INSUFFICIENT_BUFFER;
                }
                break;
            }
        }

        RegCloseKey(hKey);
    }

    return lr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\idletask\inc\idlesrv.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    idlesrv.h

Abstract:

    This module contains declarations for the idle detection server
    host.
    
Author:

    Dave Fields (davidfie) 26-July-1998
    Cenk Ergan (cenke) 14-June-2000

Revision History:

--*/

#ifndef _IDLESRV_H_
#define _IDLESRV_H_

#ifdef __cplusplus
extern "C" {
#endif

//
// Functions to initialize / uninitialize the server.
//

DWORD
ItSrvInitialize (
    VOID
    );

VOID
ItSrvUninitialize (
    VOID
    );

#ifdef __cplusplus
}
#endif

#endif // _IDLESRV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\idletask\client\idletskc.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    idletskc.c

Abstract:

    This module implements the idle task client APIs.

Author:

    Dave Fields (davidfie) 26-July-1998
    Cenk Ergan (cenke) 14-June-2000

Revision History:

--*/

//
// Define this to note that we are being built as a part of advapi32 and the
// routines we'll call from advapi32 should not be marked as "dll imports".
//

#define _ADVAPI32_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "idletskc.h"

//
// Implementation of client side exposed functions.
//

DWORD
RegisterIdleTask (
    IN IT_IDLE_TASK_ID IdleTaskId,
    OUT HANDLE *ItHandle,
    OUT HANDLE *StartEvent,
    OUT HANDLE *StopEvent
    )

/*++

Routine Description:

    This function is a stub to ItCliRegisterIdleTask. Please see that
    function for comments.

Arguments:

    See ItCliRegisterIdleTask.

Return Value:

    See ItCliRegisterIdleTask.

--*/

{
    return ItCliRegisterIdleTask(IdleTaskId,
                                 ItHandle,
                                 StartEvent,
                                 StopEvent);
}

DWORD
ItCliRegisterIdleTask (
    IN IT_IDLE_TASK_ID IdleTaskId,
    OUT HANDLE *ItHandle,
    OUT HANDLE *StartEvent,
    OUT HANDLE *StopEvent
    )

/*++

Routine Description:

    Registers an idle task in the current process with the server and
    returns handles to two events that will be used by the server to
    signal the idle task to start/stop running.

    When the task gets to run and is completed, or not needed anymore,
    UnregisterIdleTask should be called with the same Id and returned
    event handles.

    The caller should not set and reset the events. It should just
    wait on them.
    
    An idle task should not run indefinitely as this may prevent the
    system from signaling other idle tasks. There is no guarantee that
    the StartEvent will be signaled, as the system could be always
    active/in use. If your task really has to run at least once every
    so often you can also queue a timer-queue timer.

Arguments:

    IdleTaskId - Which idle task this is. There can be only a single
      task registered from a process with this id.

    ItHandle - Handle to registered idle task is returned here.

    StartEvent - Handle to a manual reset event that is set when the
      task should start running is returned here.

    StopEvent - Handle to a manual reset event that is set when the
      task should stop running is returned here.

Return Value:

    Win32 error code.

--*/

{
    DWORD ErrorCode;
    BOOLEAN CreatedStartEvent;
    BOOLEAN CreatedStopEvent;
    IT_IDLE_TASK_PROPERTIES IdleTask;
    DWORD ProcessId;

    //
    // Initialize locals.
    //
    
    CreatedStartEvent = FALSE;
    CreatedStopEvent = FALSE;
    ProcessId = GetCurrentProcessId();

    DBGPR((ITID,ITTRC,"IDLE: CliRegisterIdleTask(%d,%d)\n",IdleTaskId,ProcessId));

    //
    // Setup IdleTask fields.
    //

    IdleTask.Size = sizeof(IdleTask);
    IdleTask.IdleTaskId = IdleTaskId;
    IdleTask.ProcessId = ProcessId;

    //
    // Create events for start/stop. Start event is initially
    // nonsignalled.
    //

    (*StartEvent) = CreateEvent(NULL, TRUE, FALSE, NULL);
    
    if (!(*StartEvent)) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    IdleTask.StartEventHandle = (ULONG_PTR) (*StartEvent);
    
    CreatedStartEvent = TRUE;

    //
    // Stop event is initially signaled.
    //

    (*StopEvent) = CreateEvent(NULL, TRUE, TRUE, NULL);
    
    if (!(*StopEvent)) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    IdleTask.StopEventHandle = (ULONG_PTR) (*StopEvent);

    CreatedStopEvent = TRUE;
    
    //
    // Call the server.
    //

    RpcTryExcept {

        ErrorCode = ItSrvRegisterIdleTask(NULL, (IT_HANDLE *) ItHandle, &IdleTask);
    } 
    RpcExcept(IT_RPC_EXCEPTION_HANDLER()) {

        ErrorCode = RpcExceptionCode();
    }
    RpcEndExcept
    
 cleanup:

    if (ErrorCode != ERROR_SUCCESS) {

        if (CreatedStartEvent) {
            CloseHandle(*StartEvent);
        }

        if (CreatedStopEvent) {
            CloseHandle(*StopEvent);
        }
    }

    DBGPR((ITID,ITTRC,"IDLE: CliRegisterIdleTask(%d,%d,%p)=%x\n",IdleTaskId,ProcessId,*ItHandle,ErrorCode));

    return ErrorCode;
}

DWORD
UnregisterIdleTask (
    IN HANDLE ItHandle,
    IN HANDLE StartEvent,
    IN HANDLE StopEvent
    )

/*++

Routine Description:

    This function is a stub to ItCliUnregisterIdleTask. Please see
    that function for comments.

Arguments:

    See ItCliUnregisterIdleTask.

Return Value:

    Win32 error code.

--*/

{
    ItCliUnregisterIdleTask(ItHandle,
                            StartEvent,
                            StopEvent);

    return ERROR_SUCCESS;
}

VOID
ItCliUnregisterIdleTask (
    IN HANDLE ItHandle,
    IN HANDLE StartEvent,
    IN HANDLE StopEvent   
    )

/*++

Routine Description:

    Unregisters an idle task in the current process with the server
    and cleans up any allocated resources. This function should be
    called when the idle task is completed, or not needed anymore
    (e.g. the process is exiting).

Arguments:

    ItHandle - Registration RPC context handle.

    StartEvent - Handle returned from RegisterIdleTask.

    StopEvent - Handle returned from RegisterIdleTask.

Return Value:

    Win32 error code.

--*/

{
    DWORD ErrorCode;

    //
    // Initialize locals.
    //

    DBGPR((ITID,ITTRC,"IDLE: CliUnregisterIdleTask(%p)\n", ItHandle));

    //
    // Call server to unregister the idle task. 
    //

    RpcTryExcept {

        ItSrvUnregisterIdleTask(NULL, (IT_HANDLE *)&ItHandle);
        ErrorCode = ERROR_SUCCESS;

    } 
    RpcExcept(IT_RPC_EXCEPTION_HANDLER()) {

        ErrorCode = RpcExceptionCode();
    }
    RpcEndExcept

    //
    // Close handles to the start/stop events.
    //
                                        
    CloseHandle(StartEvent);
    CloseHandle(StopEvent);

    DBGPR((ITID,ITTRC,"IDLE: CliUnregisterIdleTask(%p)=0\n",ItHandle));

    return;
}

DWORD
ProcessIdleTasks (
    VOID
    )

/*++

Routine Description:

    This routine forces all queued tasks (if there are any) to be processed 
    right away.
    
Arguments:

    None.

Return Value:

    Win32 error code.

--*/

{
    DWORD ErrorCode;

    DBGPR((ITID,ITTRC,"IDLE: ProcessIdleTasks()\n"));

    //
    // Call the server. 
    //

    RpcTryExcept {

        ErrorCode = ItSrvProcessIdleTasks(NULL);

    } 
    RpcExcept(IT_RPC_EXCEPTION_HANDLER()) {

        ErrorCode = RpcExceptionCode();
    }
    RpcEndExcept

    DBGPR((ITID,ITTRC,"IDLE: ProcessIdleTasks()=%x\n",ErrorCode));

    return ErrorCode;
}

//
// These are the custom binding functions that are called by RPC stubs
// when we call interface functions:
//

handle_t
__RPC_USER
ITRPC_HANDLE_bind(
    ITRPC_HANDLE Reserved
    )

/*++

Routine Description:

    Typical RPC custom binding routine. It is called to get a binding
    for the RPC interface functions that require explicit_binding.

Arguments:

    Reserved - Ignored.

Return Value:

    RPC binding handle or NULL if there was an error.

--*/

{
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    RPC_BINDING_HANDLE BindingHandle;
    RPC_SECURITY_QOS SecurityQOS;
    PSID LocalSystemSid;
    WCHAR *StringBinding;
    SID_NAME_USE AccountType;
    WCHAR AccountName[128];
    DWORD AccountNameSize = sizeof(AccountName);
    WCHAR DomainName[128];
    DWORD DomainNameSize = sizeof(DomainName);
    DWORD ErrorCode;
    
    //
    // Initialize locals.
    //
    
    LocalSystemSid = NULL;
    BindingHandle = NULL;
    StringBinding = NULL;

    ErrorCode = RpcStringBindingCompose(NULL,
                                        IT_RPC_PROTSEQ,
                                        NULL,
                                        NULL,
                                        NULL,
                                        &StringBinding);
    
    if (ErrorCode != RPC_S_OK) {
        goto cleanup;
    }

    ErrorCode = RpcBindingFromStringBinding(StringBinding,
                                            &BindingHandle);


    if (ErrorCode != RPC_S_OK) {
        IT_ASSERT(BindingHandle == NULL);
        goto cleanup;
    }

    //
    // Set security information.
    //

    SecurityQOS.Version = RPC_C_SECURITY_QOS_VERSION;
    SecurityQOS.Capabilities = RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH;
    SecurityQOS.IdentityTracking = RPC_C_QOS_IDENTITY_DYNAMIC;
    SecurityQOS.ImpersonationType = RPC_C_IMP_LEVEL_IMPERSONATE;

    //
    // Get the security principal name for LocalSystem: we'll only allow an
    // RPC server running as LocalSystem to impersonate us.
    //

    if (!AllocateAndInitializeSid(&NtAuthority,
                                  1,
                                  SECURITY_LOCAL_SYSTEM_RID,
                                  0, 0, 0, 0, 0, 0, 0,
                                  &LocalSystemSid)) {

        ErrorCode = GetLastError();
        goto cleanup;
    }

    if (LookupAccountSid(NULL,
                         LocalSystemSid,
                         AccountName,
                         &AccountNameSize,
                         DomainName,
                         &DomainNameSize,
                         &AccountType) == 0) {

        ErrorCode = GetLastError();
        goto cleanup;
    }

    //
    // Set mutual authentication requirements on the binding handle.
    //

    ErrorCode = RpcBindingSetAuthInfoEx(BindingHandle, 
                                        AccountName, 
                                        RPC_C_AUTHN_LEVEL_PKT_PRIVACY, 
                                        RPC_C_AUTHN_WINNT, 
                                        NULL, 
                                        0, 
                                        &SecurityQOS);

    if (ErrorCode!= RPC_S_OK) {
        goto cleanup;
    }
    
    ErrorCode = ERROR_SUCCESS;

 cleanup:

    if (StringBinding) {
        RpcStringFree(&StringBinding);
    }

    if (LocalSystemSid) {
        FreeSid(LocalSystemSid);
    }

    return BindingHandle;
}

VOID
__RPC_USER
ITRPC_HANDLE_unbind(
    ITRPC_HANDLE Reserved,
    RPC_BINDING_HANDLE BindingHandle
    )

/*++

Routine Description:

    Typical RPC custom unbinding routine. It is called to close a
    binding established for an RPC interface function that required
    explicit_binding.

Arguments:

    Reserved - Ignored.

    BindingHandle - Primitive binding handle.

Return Value:

    None.

--*/

{
    RPC_STATUS Status;
    
    Status = RpcBindingFree(&BindingHandle);

    IT_ASSERT(Status == RPC_S_OK);
    IT_ASSERT(BindingHandle == NULL);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\idletask\inc\idlecomn.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    idlecomn.h

Abstract:

    This module contains common private declarations to support idle tasks.
    Note that client does not stand for the users of the idle task
    API, but the code in the users process that implements these APIs.
    
Author:

    Dave Fields (davidfie) 26-July-1998
    Cenk Ergan (cenke) 14-June-2000

Revision History:

--*/

#ifndef _IDLETASK_H_
#define _IDLETASK_H_

//
// This exception handler is prefered because it does not mask
// exceptions that can be raised from the heap etc. during an RPC
// call.
//

#define IT_RPC_EXCEPTION_HANDLER()                                      \
    (((RpcExceptionCode() != STATUS_ACCESS_VIOLATION)                && \
      (RpcExceptionCode() != STATUS_POSSIBLE_DEADLOCK)               && \
      (RpcExceptionCode() != STATUS_INSTRUCTION_MISALIGNMENT)        && \
      (RpcExceptionCode() != STATUS_DATATYPE_MISALIGNMENT)           && \
      (RpcExceptionCode() != STATUS_PRIVILEGED_INSTRUCTION)          && \
      (RpcExceptionCode() != STATUS_ILLEGAL_INSTRUCTION)             && \
      (RpcExceptionCode() != STATUS_BREAKPOINT)                         \
     ) ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)

//
// Debug definitions:
//

#if DBG
#ifndef IT_DBG
#define IT_DBG
#endif // !IT_DBG
#endif // DBG

#ifdef IT_DBG

//
// Define the component ID we use.
//

#define ITID       DPFLTR_IDLETASK_ID

//
// Define DbgPrintEx levels.
//

#define ITERR      DPFLTR_ERROR_LEVEL
#define ITWARN     DPFLTR_WARNING_LEVEL
#define ITTRC      DPFLTR_TRACE_LEVEL
#define ITINFO     DPFLTR_INFO_LEVEL

#define ITCLID     4
#define ITSRVD     5
#define ITSRVDD    6
#define ITTSTD     7
#define ITSNAP     8

//
//  This may help you determine what to set the DbgPrintEx mask.
//
//  3 3 2 2  2 2 2 2  2 2 2 2  1 1 1 1   1 1 1 1  1 1 0 0  0 0 0 0  0 0 0 0
//  1 0 9 8  7 6 5 4  3 2 1 0  9 8 7 6   5 4 3 2  1 0 9 8  7 6 5 4  3 2 1 0
//  _ _ _ _  _ _ _ _  _ _ _ _  _ _ _ _   _ _ _ _  _ _ _ _  _ _ _ _  _ _ _ _
//

//
// We have to declare RtlAssert here because it is not declared in
// public header files if DBG is not defined.
//

NTSYSAPI
VOID
NTAPI
RtlAssert(
    PVOID FailedAssertion,
    PVOID FileName,
    ULONG LineNumber,
    PCHAR Message
    );

#define IT_ASSERT(x) if (!(x)) RtlAssert(#x, __FILE__, __LINE__, NULL )
#define DBGPR(x) DbgPrintEx x

#else // IT_DBG

#define IT_ASSERT(x)
#define DBGPR(x)

#endif // IT_DBG

#endif // _IDLETASK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\idletask\server\idlrpc_server.c ===
#include <idlrpc_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\idletask\server\idletsks.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    idletsks.h

Abstract:

    This module contains private declarations for the idle task & detection
    server.
    
Author:

    Dave Fields (davidfie) 26-July-1998
    Cenk Ergan (cenke) 14-June-2000

Revision History:

--*/

#ifndef _IDLETSKS_H_
#define _IDLETSKS_H_

//
// Include public and common definitions.
//

#include <wmium.h>
#include <ntdddisk.h>
#include "idlrpc.h"
#include "idlecomn.h"

//
// Define the default period in ms for checking if the system is idle.
//

#define IT_DEFAULT_IDLE_DETECTION_PERIOD    (12 * 60 * 1000) // 12 minutes.

//
// If the system has been idle over the idle detection period, we
// verify that it is really idle by checking frequently over a shorter
// period for a number of times. This helps us know when there were
// 100 disk I/O's in the last second of idle detection period, but
// over 15 minutes it does not look a lot.
//

#define IT_DEFAULT_IDLE_VERIFICATION_PERIOD (30 * 1000)      // 30 seconds.
#define IT_DEFAULT_NUM_IDLE_VERIFICATIONS   5                // 5 times.

//
// We will be polling for user input when running idle tasks every
// this many ms. We want to catch user input and notify the idle task
// to stop running as soon as possible. Even though the system is
// idle, we don't want to create too much overhead which may mislead
// ourself.
//

#define IT_DEFAULT_IDLE_USER_INPUT_CHECK_PERIOD     250      // 4 times a sec. 

//
// We check to see if the idle task we asked to run is really running
// (i.e. it is using the disk and CPU) every this many ms. This is our
// mechanism for cleaning up after unregistered/orphaned tasks. This
// should be greater than IT_USER_INPUT_POLL_PERIOD_WHEN_IDLE.
//

#define IT_DEFAULT_IDLE_TASK_RUNNING_CHECK_PERIOD   (5 * 60 * 1000) // 5 min.

//
// If the CPU is not idle more than this percent over a time interval,
// the system is not considered idle.
//

#define IT_DEFAULT_MIN_CPU_IDLE_PERCENTAGE          90

//
// If a disk is not idle more than this percent over a time interval,
// the system is not considered idle.
//

#define IT_DEFAULT_MIN_DISK_IDLE_PERCENTAGE         90

//
// We will not try to run our tasks if there is only this many seconds
// left before the system will enter hibernate or standby automatically.
// Note that the time remaining is updated every so many seconds (e.g. 
// 15) so this number should not be very small.
//

#define IT_DEFAULT_MAX_TIME_REMAINING_TO_SLEEP      60

//
// This is the maximum number of registered idle tasks. This is a
// sanity check. It also protects against evil callers.
//

#define IT_DEFAULT_MAX_REGISTERED_TASKS             512

//
// We set timer period for idle detection callback to this while the
// callback is running to prevent new callbacks from firing. We end up
// having to do this because you cannot requeue/change a timer for
// which you don't specify a period. If a callback fires while another
// one is already running, it simply returns without doing anything.
//

#define IT_VERYLONG_TIMER_PERIOD                    0x7FFFFFFF

//
// This is the number of recent server statuses that we keep track
// of. Do not make this number smaller without revisiting the logic &
// code that uses the LastStatus history.
//

#define ITSRV_GLOBAL_STATUS_HISTORY_SIZE            8

//
// Hints for the number of outstanding RPC call-ins we will have.
//

#define ITSRV_RPC_MIN_CALLS                         1
#define ITSRV_RPC_MAX_CALLS                         1

//
// Define useful macros.
//

#define IT_ALLOC(NumBytes)          (HeapAlloc(GetProcessHeap(),0,(NumBytes)))
#define IT_REALLOC(Buffer,NumBytes) (HeapReAlloc(GetProcessHeap(),0,(Buffer),(NumBytes)))
#define IT_FREE(Buffer)             (HeapFree(GetProcessHeap(),0,(Buffer)))

//
// These macros are used to acquire/release a mutex.
//

#define IT_ACQUIRE_LOCK(Lock)                                                         \
    WaitForSingleObject((Lock), INFINITE);                                            \

#define IT_RELEASE_LOCK(Lock)                                                         \
    ReleaseMutex((Lock));                                                             \

//
// This macro is used in the idle detection callback (while holding
// the global lock of the input global context) to determine if the
// idle detection callback should just exit/go away.
//

#define ITSP_SHOULD_STOP_IDLE_DETECTION(GlobalContext)                       \
    ((GlobalContext->Status == ItSrvStatusStoppingIdleDetection) ||          \
     (GlobalContext->Status == ItSrvStatusUninitializing))                   \

//
// Status of a server global context. It also acts as a magic to
// identify/verify the global context, as it starts from Df00. There
// is not a full-blown state machine, although the state is used as a
// critical hint for making decisions when registering an idle
// task. This is more for informative and verification purposes. If
// you add a new status without updating everything that needs to be
// updated, you may hit several asserts, especially in the idle
// detection callback. Frankly, don't add a new state without a very
// good reason.
//

typedef enum _ITSRV_GLOBAL_CONTEXT_STATUS {
    ItSrvStatusMinStatus                = 'Df00',
    ItSrvStatusInitializing,
    ItSrvStatusWaitingForIdleTasks,
    ItSrvStatusDetectingIdle,
    ItSrvStatusRunningIdleTasks,
    ItSrvStatusStoppingIdleDetection,
    ItSrvStatusUninitializing,
    ItSrvStatusUninitialized,
    ItSrvStatusMaxStatus
} ITSRV_GLOBAL_CONTEXT_STATUS, *PITSRV_GLOBAL_CONTEXT_STATUS;

//
// These are the various types of idle detection overrides. Multiple
// overrides can be specified by OR'ing them (i.e. these are bits!)
//
// If you are adding an override here, check whether you need to specify
// it when force-processing all idle tasks.
//

typedef enum _ITSRV_IDLE_DETECTION_OVERRIDE {
    
    ItSrvOverrideIdleDetection                      = 0x00000001,
    ItSrvOverrideIdleVerification                   = 0x00000002,
    ItSrvOverrideUserInputCheckToStopTask           = 0x00000004,
    ItSrvOverrideTaskRunningCheck                   = 0x00000008,
    ItSrvOverridePostTaskIdleCheck                  = 0x00000010,
    ItSrvOverrideLongRequeueTime                    = 0x00000020,
    ItSrvOverrideBatteryCheckToStopTask             = 0x00000040,
    ItSrvOverrideAutoPowerCheckToStopTask           = 0x00000080,

} ITSRV_IDLE_DETECTION_OVERRIDE, *PITSRV_IDLE_DETECTION_OVERRIDE;

//
// These are the various reasons why ItSpIsSystemIdle function may be
// called.
//

typedef enum _ITSRV_IDLE_CHECK_REASON {

    ItSrvInitialIdleCheck,
    ItSrvIdleVerificationCheck,
    ItSrvIdleTaskRunningCheck,
    ItSrvMaxIdleCheckReason

}ITSRV_IDLE_CHECK_REASON, *PITSRV_IDLE_CHECK_REASON;

//
// This structure is used to keep context for a registered task for
// the server.
//

typedef struct _ITSRV_IDLE_TASK_CONTEXT {

    //
    // Link in the list of idle tasks.
    //

    LIST_ENTRY IdleTaskLink;

    //
    // Status of the idle task.
    //

    IT_IDLE_TASK_STATUS Status;

    //
    // Idle task properties the client specified.
    //

    IT_IDLE_TASK_PROPERTIES Properties;

    //
    // Event to be notified when the task should start running
    // (e.g. the system is idle).
    //

    HANDLE StartEvent;

    //
    // Event to be notified when the task should stop running.
    //
   
    HANDLE StopEvent;

} ITSRV_IDLE_TASK_CONTEXT, *PITSRV_IDLE_TASK_CONTEXT;

//
// This structure contains disk performance information we are
// interested in.
//

typedef struct _ITSRV_DISK_PERFORMANCE_DATA {
    
    //
    // How long the disk was idle in ms.
    //

    ULONG DiskIdleTime;

} ITSRV_DISK_PERFORMANCE_DATA, *PITSRV_DISK_PERFORMANCE_DATA;

//
// Define structure to contain system resource information & state at
// a specific time.
//

typedef struct _ITSRV_SYSTEM_SNAPSHOT {

    //
    // When this snapshot was taken, in ms elapsed since system was
    // started (i.e. GetTickCount)
    //

    DWORD SnapshotTime;

    //
    // Whether we were able to get the specified data in this snapshot.
    //

    ULONG GotLastInputInfo:1;
    ULONG GotSystemPerformanceInfo:1;
    ULONG GotDiskPerformanceInfo:1;
    ULONG GotSystemPowerStatus:1;
    ULONG GotSystemPowerInfo:1;
    ULONG GotSystemExecutionState:1;
    ULONG GotDisplayPowerStatus:1;

    //
    // This is when the last user input happened before the snapshot
    // was taken.
    //

    LASTINPUTINFO LastInputInfo;

    //
    // System performance information when the snapshot was taken.
    //

    SYSTEM_PERFORMANCE_INFORMATION SystemPerformanceInfo;

    //
    // Disk performance data on registered harddisks when the snapshot
    // was taken.
    //

    ULONG NumPhysicalDisks;
    ITSRV_DISK_PERFORMANCE_DATA *DiskPerfData;
    
    //
    // System power status (e.g. are we running on battery etc.)
    //
    
    SYSTEM_POWER_STATUS SystemPowerStatus;

    //
    // System power information (e.g. how long till system turns itself
    // off & goes to sleep.)
    //
    
    SYSTEM_POWER_INFORMATION PowerInfo;

    //
    // System execution state (e.g. is somebody running a presentation?)
    //

    EXECUTION_STATE ExecutionState;

    //
    // Whether the screen saver is running.
    //

    BOOL ScreenSaverIsRunning;

} ITSRV_SYSTEM_SNAPSHOT, *PITSRV_SYSTEM_SNAPSHOT;

//
// Type for the routine that is called to notify that forced processing of 
// idle tasks have been requested.
//

typedef VOID (*PIT_PROCESS_IDLE_TASKS_NOTIFY_ROUTINE)(VOID);

//
// Define structure to contain server global context for idle
// detection and keeping track of registered idle tasks.
//

typedef struct _ITSRV_GLOBAL_CONTEXT {

    //
    // Status of the server and its history, LastStatus[0] being the
    // most recent. The status version is incremented each time the
    // status is updated.
    //
    
    ITSRV_GLOBAL_CONTEXT_STATUS Status;
    ITSRV_GLOBAL_CONTEXT_STATUS LastStatus[ITSRV_GLOBAL_STATUS_HISTORY_SIZE];
    LONG StatusVersion;

    //
    // Nearly all operations involve the idle tasks list and instead
    // of having a lock for the list and seperate synchronization
    // mechanisms for other operations on the structure, we have a
    // single global lock to make life simpler.
    //

    HANDLE GlobalLock;

    //
    // This is the list and number of idle tasks that have been
    // scheduled.
    //

    LIST_ENTRY IdleTasksList;
    ULONG NumIdleTasks;

    //
    // Handle to the timer queue timer that is used to periodically
    // check for system idleness.
    //

    HANDLE IdleDetectionTimerHandle;

    //
    // This manual reset event gets signaled when idle detection
    // should stop (e.g. because there are no more idle tasks, the
    // server is shutting down etc.) It signals a running idle
    // detection callback to quickly exit.
    //

    HANDLE StopIdleDetection;

    //
    // This manual reset event gets signaled when idle detection has
    // fully stopped (i.e. no callback is running, the timer is not in
    // the queue etc.
    //

    HANDLE IdleDetectionStopped;

    //
    // This manual reset event is signaled when an idle task that was
    // running is unregistered/removed. This would happen usually
    // after an idle task that was told to run completes and has no
    // more to do. It unregisters itself, and this event is set to
    // notify the idle detection callback to move on to other idle
    // tasks.
    //

    HANDLE RemovedRunningIdleTask;

    //
    // This manual-reset event is reset while ItSrvServiceHandler is
    // running. It is signaled when the function is done. It is used
    // to synchronize shutdown with ItSrvServiceHandler call ins.
    //

    HANDLE ServiceHandlerNotRunning;

    //
    // If it is set, this routine is called to notify that 
    // forced processing of idle tasks have been requested.
    //

    PIT_PROCESS_IDLE_TASKS_NOTIFY_ROUTINE ProcessIdleTasksNotifyRoutine;

    //
    // These are the parameters that control idle detection.
    //

    IT_IDLE_DETECTION_PARAMETERS Parameters;

    //
    // This is the WMI handle used in disk performance queries.
    //

    WMIHANDLE DiskPerfWmiHandle;

    //
    // Number of processors on the system. Used to calculate CPU
    // utilization.
    //

    UCHAR NumProcessors; 

    //
    // This buffer is used to make Wmi queries. It is maintained here
    // so we don't have to allocate a new one each time.
    //

    PVOID WmiQueryBuffer;
    ULONG WmiQueryBufferSize;

    //
    // The last system resource / activity snapshot we took.
    //

    ITSRV_SYSTEM_SNAPSHOT LastSystemSnapshot;

    //
    // Is an idle detection callback already running? This is used to
    // protect us from idle detection callbacks being fired while
    // there is already one active.
    //

    BOOLEAN IsIdleDetectionCallbackRunning;

    //
    // Various phases of idle detection can be overriden by setting
    // this.
    //

    ITSRV_IDLE_DETECTION_OVERRIDE IdleDetectionOverride;

    //
    // RPC binding vector used to register ourselves in the local
    // endpoint-map database.
    //

    RPC_BINDING_VECTOR *RpcBindingVector;

    //
    // Whether we actually registered our endpoint and interface.
    //

    BOOLEAN RegisteredRPCEndpoint;
    BOOLEAN RegisteredRPCInterface;

} ITSRV_GLOBAL_CONTEXT, *PITSRV_GLOBAL_CONTEXT;


//
// Reference count structure.
//

typedef struct _ITSRV_REFCOUNT {

    //
    // This is set when somebody wants to gain exclusive access to the
    // protected structure.
    //

    LONG Exclusive;
    
    //
    // When initialized or reset, this reference count starts from
    // 1. When exclusive access is granted it stays at 0: even if it
    // may get bumped by an AddRef by mistake, it will return to 0.
    //

    LONG RefCount;

    //
    // The thread that got exclusive access.
    //

    HANDLE ExclusiveOwner;
    
} ITSRV_REFCOUNT, *PITSRV_REFCOUNT;

//
// Server function declarations. They should be only used by the
// server host and the client functions.
//

DWORD
ItSrvInitialize (
    VOID
    );

VOID
ItSrvUninitialize (
    VOID
    );

BOOLEAN
ItSrvServiceHandler(
    IN DWORD ControlCode,
    IN DWORD EventType,
    IN LPVOID EventData,
    IN LPVOID Context,
    OUT PDWORD ErrorCode
    );

DWORD
ItSrvRegisterIdleTask (
    ITRPC_HANDLE Reserved,
    IT_HANDLE *ItHandle,
    PIT_IDLE_TASK_PROPERTIES IdleTaskProperties
    );

VOID
ItSrvUnregisterIdleTask (
    ITRPC_HANDLE Reserved,
    IT_HANDLE *ItHandle
    );

DWORD
ItSrvSetDetectionParameters (
    ITRPC_HANDLE Reserved,
    PIT_IDLE_DETECTION_PARAMETERS Parameters
    );

DWORD
ItSrvProcessIdleTasks (
    ITRPC_HANDLE Reserved
    );

VOID 
__RPC_USER 
IT_HANDLE_rundown (
    IT_HANDLE ItHandle
    ); 

//
// Local support function prototypes for the server.
//

RPC_STATUS 
__stdcall 
ItSpRpcSecurityCallback (
    IN PVOID Interface,
    IN PVOID Context
    );
   
VOID
ItSpUnregisterIdleTask (
    ITRPC_HANDLE Reserved,
    IT_HANDLE *ItHandle,
    BOOLEAN CalledInternally
    );

VOID
ItSpUpdateStatus (
    PITSRV_GLOBAL_CONTEXT GlobalContext,
    ITSRV_GLOBAL_CONTEXT_STATUS NewStatus
    );

VOID
ItSpCleanupGlobalContext (
    PITSRV_GLOBAL_CONTEXT GlobalContext
    );

VOID
ItSpCleanupIdleTask (
    PITSRV_IDLE_TASK_CONTEXT IdleTask
    );

ULONG
ItpVerifyIdleTaskProperties (
    PIT_IDLE_TASK_PROPERTIES IdleTaskProperties
    );

DWORD
ItSpStartIdleDetection (
    PITSRV_GLOBAL_CONTEXT GlobalContext
    );

VOID
ItSpStopIdleDetection (
    PITSRV_GLOBAL_CONTEXT GlobalContext
    );

VOID 
CALLBACK
ItSpIdleDetectionCallbackRoutine (
    PVOID Parameter,
    BOOLEAN TimerOrWaitFired
    );

PITSRV_IDLE_TASK_CONTEXT
ItSpFindRunningIdleTask (
    PITSRV_GLOBAL_CONTEXT GlobalContext
    );

PITSRV_IDLE_TASK_CONTEXT
ItSpFindIdleTask (
    PITSRV_GLOBAL_CONTEXT GlobalContext,
    IT_HANDLE ItHandle
    );

VOID
ItSpInitializeSystemSnapshot (
    PITSRV_SYSTEM_SNAPSHOT SystemSnapshot
    );

VOID
ItSpCleanupSystemSnapshot (
    PITSRV_SYSTEM_SNAPSHOT SystemSnapshot
    );

DWORD
ItSpCopySystemSnapshot (
    PITSRV_SYSTEM_SNAPSHOT DestSnapshot,
    PITSRV_SYSTEM_SNAPSHOT SourceSnapshot
    );

DWORD
ItSpGetSystemSnapshot (
    PITSRV_GLOBAL_CONTEXT GlobalContext,
    PITSRV_SYSTEM_SNAPSHOT SystemSnapshot
    );

BOOLEAN
ItSpIsSystemIdle (
    PITSRV_GLOBAL_CONTEXT GlobalContext,
    PITSRV_SYSTEM_SNAPSHOT CurrentSnapshot,
    PITSRV_SYSTEM_SNAPSHOT LastSnapshot,
    ITSRV_IDLE_CHECK_REASON IdleCheckReason
    );

DWORD
ItSpGetLastInputInfo (
    PLASTINPUTINFO LastInputInfo
    );

DWORD
ItSpGetWmiDiskPerformanceData(
    IN WMIHANDLE DiskPerfWmiHandle,
    OUT PITSRV_DISK_PERFORMANCE_DATA *DiskPerfData,
    OUT ULONG *NumPhysicalDisks,
    OPTIONAL IN OUT PVOID *InputQueryBuffer,
    OPTIONAL IN OUT ULONG *InputQueryBufferSize
    );

BOOLEAN
ItSpIsPhysicalDrive (
    PDISK_PERFORMANCE DiskPerformanceData
    );

DWORD
ItSpGetDisplayPowerStatus(
    PBOOL ScreenSaverIsRunning
    );

//
// Reference count functions.
//

VOID
ItSpInitializeRefCount(
    PITSRV_REFCOUNT RefCount
    );

DWORD
FASTCALL
ItSpAddRef(
    PITSRV_REFCOUNT RefCount
    );

VOID
FASTCALL
ItSpDecRef(
    PITSRV_REFCOUNT RefCount
    );

DWORD
ItSpAcquireExclusiveRef(
    PITSRV_REFCOUNT RefCount
    );

#endif // _IDLETSKS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\idletask\server\idletsks.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    idletsks.c

Abstract:

    This module implements the idle detection / task server.

Author:

    Dave Fields (davidfie) 26-July-1998
    Cenk Ergan (cenke) 14-June-2000

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include "idletsks.h"

//
// Define WMI Guids, e.g. DiskPerfGuid.
//

#ifndef INITGUID
#define INITGUID 1
#endif

#include <wmiguid.h>

//
// Global variables.
//

//
// This is the idle detection global context. It is declared as a
// single element array so that ItSrvGlobalContext can be used as a
// pointer (allowing us to switch to allocating it from heap etc. in
// the future).
//

ITSRV_GLOBAL_CONTEXT ItSrvGlobalContext[1] = {0};

//
// Reference count protecting the global context.
//

ITSRV_REFCOUNT ItSrvRefCount = {0};

//
// Implementation of server side exposed functions.
//

DWORD
ItSrvInitialize (
    VOID
    )

/*++

Routine Description:

    Initializes the global idle detection context. This function
    should be called after at least one ncalrpc binding has been
    registered.

Arguments:

    None.

Return Value:

    Win32 error code.

--*/

{
    DWORD ErrorCode;
    PITSRV_GLOBAL_CONTEXT GlobalContext;
    PIT_IDLE_DETECTION_PARAMETERS Parameters;
    ULONG StatusIdx;
    BOOLEAN StartedServer;
    BOOLEAN AcquiredLock;

    //
    // Initialize locals.
    //
    
    GlobalContext = ItSrvGlobalContext;
    StartedServer = FALSE;
    AcquiredLock = FALSE;

    DBGPR((ITID,ITTRC,"IDLE: SrvInitialize(%p)\n",GlobalContext));

    //
    // Initialize reference count for the global context structure.
    //

    ItSpInitializeRefCount(&ItSrvRefCount);

    //
    // Initialize the server context structure. Before we do anything
    // that can fail we initialize fields to reasonable values so we
    // know what to cleanup. The following fields really have to be
    // initialized to zero:
    //
    //   StatusVersion
    //   GlobalLock
    //   IdleDetectionTimerHandle
    //   StopIdleDetection
    //   IdleDetectionStopped
    //   RemovedRunningIdleTask
    //   DiskPerfWmiHandle
    //   WmiQueryBuffer
    //   WmiQueryBufferSize
    //   NumProcessors
    //   IsIdleDetectionCallbackRunning
    //   Parameters
    //   ServiceHandlerNotRunning
    //   ProcessIdleTasksNotifyRoutine
    //   RpcBindingVector
    //   RegisteredRPCInterface
    //   RegisteredRPCEndpoint
    //
    
    RtlZeroMemory(GlobalContext, sizeof(ITSRV_GLOBAL_CONTEXT));

    //
    // Initialize the idle tasks list.
    //

    InitializeListHead(&GlobalContext->IdleTasksList);

    //
    // Initialize the status now (so cleanup does not complain). From
    // this point on, UpdateStatus should be called to set the status.
    //

    GlobalContext->Status = ItSrvStatusInitializing;
    for (StatusIdx = 0; StatusIdx < ITSRV_GLOBAL_STATUS_HISTORY_SIZE; StatusIdx++) {
        GlobalContext->LastStatus[StatusIdx] = ItSrvStatusInitializing;
    }   

    //
    // Initialize the system snapshot buffer.
    //

    ItSpInitializeSystemSnapshot(&GlobalContext->LastSystemSnapshot);

    //
    // Initialize the server global context lock. We need at least a
    // lock to protect the idle task list. Since nearly all operations
    // will involve the list, to make the code simple, we just have a
    // single lock for the list and for other operations on the global
    // context (e.g. uninitialization etc).
    //

    GlobalContext->GlobalLock = CreateMutex(NULL, FALSE, NULL);

    if (GlobalContext->GlobalLock == NULL) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    //
    // Initialize the event that will be set when we should not be
    // doing idle detection anymore (e.g. due to server shutdown, or
    // no more idle tasks remaining). It is set by default, since
    // there are no idle tasks to start with. It signals a running
    // idle detection callback to quickly exit.
    //

    GlobalContext->StopIdleDetection = CreateEvent(NULL,
                                                   TRUE,
                                                   TRUE,
                                                   NULL);
    
    if (GlobalContext->StopIdleDetection == NULL) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    //
    // Initialize the event that gets set when idle detection is fully
    // stopped and it is OK to start a new callback. It is set by
    // default.
    //

    GlobalContext->IdleDetectionStopped = CreateEvent(NULL,
                                                      TRUE,
                                                      TRUE,
                                                      NULL);
    
    if (GlobalContext->IdleDetectionStopped == NULL) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    //
    // Initialize the event that gets set when a currently running
    // idle task is removed/unregistered to signal the idle detection
    // callback to move on to other idle tasks.
    //

    GlobalContext->RemovedRunningIdleTask = CreateEvent(NULL,
                                                        TRUE,
                                                        FALSE,
                                                        NULL);
    
    if (GlobalContext->RemovedRunningIdleTask == NULL) {
        ErrorCode = GetLastError();
        goto cleanup;
    }


    //
    // This manual reset event is reset when ItSrvServiceHandler is
    // running and is signaled when this function is done.
    //

    GlobalContext->ServiceHandlerNotRunning = CreateEvent(NULL,
                                                          TRUE,
                                                          TRUE,
                                                          NULL);
    
    if (GlobalContext->ServiceHandlerNotRunning == NULL) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    //
    // Set the default parameters.
    //

    Parameters = &GlobalContext->Parameters;

    Parameters->IdleDetectionPeriod = IT_DEFAULT_IDLE_DETECTION_PERIOD;
    Parameters->IdleVerificationPeriod = IT_DEFAULT_IDLE_VERIFICATION_PERIOD;
    Parameters->NumVerifications = IT_DEFAULT_NUM_IDLE_VERIFICATIONS;
    Parameters->IdleInputCheckPeriod = IT_DEFAULT_IDLE_USER_INPUT_CHECK_PERIOD;
    Parameters->IdleTaskRunningCheckPeriod = IT_DEFAULT_IDLE_TASK_RUNNING_CHECK_PERIOD;
    Parameters->MinCpuIdlePercentage = IT_DEFAULT_MIN_CPU_IDLE_PERCENTAGE;
    Parameters->MinDiskIdlePercentage = IT_DEFAULT_MIN_DISK_IDLE_PERCENTAGE;
    Parameters->MaxNumRegisteredTasks = IT_DEFAULT_MAX_REGISTERED_TASKS;
    
    //
    // Acquire the lock to avoid any race conditions after we mark the
    // server started.
    //

    IT_ACQUIRE_LOCK(GlobalContext->GlobalLock);
    AcquiredLock = TRUE;   

    //
    // We are done until an idle task that we can run gets
    // registered. We will start idle detection (e.g. get initial
    // snapshot, queue a timer etc) then.
    //

    ItSpUpdateStatus(GlobalContext, ItSrvStatusWaitingForIdleTasks);

    //
    // After this point, if we fail, we cannot just cleanup: we have
    // to stop the server.
    //

    StartedServer = TRUE;

    //
    // We have to start up the RPC server only after we have
    // initialized everything else, so when RPC calls come the server
    // is ready. 
    //

    //
    // We don't want to register any well known end points because
    // each LPC endpoint will cause another thread to be spawned to
    // listen on it. We try to bind through only the existing
    // bindings.
    //

    ErrorCode = RpcServerInqBindings(&GlobalContext->RpcBindingVector);
    
    if (ErrorCode != RPC_S_OK) {

        //
        // At least one binding should have been registered before we
        // got called. It would be cool if we could check to see if
        // there is an ncalrpc binding registered.
        //

        IT_ASSERT(ErrorCode != RPC_S_NO_BINDINGS);

        goto cleanup;
    }

    ErrorCode = RpcEpRegister(idletask_ServerIfHandle,
                              GlobalContext->RpcBindingVector,
                              NULL,
                              NULL);
    
    if (ErrorCode != RPC_S_OK) {
        goto cleanup;
    }

    GlobalContext->RegisteredRPCEndpoint = TRUE;

    //
    // Register an auto-listen interface so we are not dependant on
    // others calling RpcMgmtStart/Stop listening.
    //

    ErrorCode = RpcServerRegisterIfEx(idletask_ServerIfHandle,
                                      NULL,
                                      NULL,
                                      RPC_IF_AUTOLISTEN | RPC_IF_ALLOW_SECURE_ONLY,
                                      RPC_C_LISTEN_MAX_CALLS_DEFAULT,
                                      ItSpRpcSecurityCallback);
    
    if (ErrorCode != RPC_S_OK) {
        goto cleanup;
    }

    //
    // Register default security principal name for this process, e.g.
    // NT Authority\LocalSystem.
    //

    ErrorCode = RpcServerRegisterAuthInfo(NULL, RPC_C_AUTHN_WINNT, NULL, NULL);

    if (ErrorCode != RPC_S_OK) {
        goto cleanup;
    }

    GlobalContext->RegisteredRPCInterface = TRUE;

    //
    // We are done.
    //

    ErrorCode = ERROR_SUCCESS;

 cleanup:

    if (AcquiredLock) {
        IT_RELEASE_LOCK(GlobalContext->GlobalLock);
    }

    if (ErrorCode != ERROR_SUCCESS) {
        if (StartedServer) {
            ItSrvUninitialize();
        } else {
            ItSpCleanupGlobalContext(GlobalContext);
        }
    }

    DBGPR((ITID,ITTRC,"IDLE: SrvInitialize(%p)=%x\n",GlobalContext,ErrorCode));

    return ErrorCode;
}

VOID
ItSrvUninitialize (
    VOID
    )

/*++

Routine Description:

    Winds down and uninitializes the server global context.

    Do not call this from the idle detection timer callback function
    thread, because there will be a deadlock when we try to delete the
    timer.

    This function should not be called before ItSrvInitialize
    completes. It should be called only once per ItSrvInitialize.

Arguments:

    None.

Return Value:

    None.

--*/

{   
    PITSRV_GLOBAL_CONTEXT GlobalContext;
    BOOLEAN AcquiredLock;
    DWORD ErrorCode;

    //
    // Initialize locals.
    //

    GlobalContext = ItSrvGlobalContext;
    AcquiredLock = FALSE;

    DBGPR((ITID,ITTRC,"IDLE: SrvUninitialize(%p)\n",GlobalContext));

    //
    // Acquire the global lock and update status.
    //

    IT_ACQUIRE_LOCK(GlobalContext->GlobalLock);
    AcquiredLock = TRUE;

    //
    // Make sure we get uninitialized only once.
    //

    IT_ASSERT(GlobalContext->Status != ItSrvStatusUninitializing);
    IT_ASSERT(GlobalContext->Status != ItSrvStatusUninitialized);
    
    ItSpUpdateStatus(GlobalContext, ItSrvStatusUninitializing);

    //
    // If idle detection is alive, we need to stop it before we tell
    // RPCs to go away. We need to do this even if there are
    // registered idle tasks. Since we have set the state to
    // ItSrvStatusUninitializing, new "register idle task"s
    // won't get stuck.
    //
    
    if (GlobalContext->IdleDetectionTimerHandle) {
        ItSpStopIdleDetection(GlobalContext);
    }
    
    //
    // Release the lock so rpc call-ins can grab the lock to
    // uninitialize/exit as necessary.
    //

    IT_RELEASE_LOCK(GlobalContext->GlobalLock);
    AcquiredLock = FALSE;

    //
    // Make sure incoming client register/unregister calls are stopped.
    //
    
    if (GlobalContext->RegisteredRPCInterface) {

        //
        // If we registered an interface, we should have registered
        // our endpoint in the local database too.
        //

        IT_ASSERT(GlobalContext->RegisteredRPCEndpoint);

        //
        // Calling UnregisterIfEx makes sure all the context handles
        // are run down so we don't get rundown calls after we have
        // uninitialized.
        //

        RpcServerUnregisterIfEx(idletask_ServerIfHandle, NULL, TRUE);
    }

    if (GlobalContext->RegisteredRPCEndpoint) {

        //
        // We could have registered an endpoint only if we
        // successfully queried bindings.
        //

        IT_ASSERT(GlobalContext->RpcBindingVector);

        RpcEpUnregister(idletask_ServerIfHandle, 
                        GlobalContext->RpcBindingVector, 
                        NULL);
    }

    //
    // Wait until idle detection is fully stopped (e.g. the callback
    // exits, the timer is dequeued etc.)
    //

    WaitForSingleObject(GlobalContext->IdleDetectionStopped, INFINITE);

    //
    // Wait for active service handler call in to exit (if there is
    // one).
    //

    WaitForSingleObject(GlobalContext->ServiceHandlerNotRunning, INFINITE);

    //
    // Acquire the reference count for the global context
    // exclusively. This shuts off ItSrvServiceHandler callbacks and
    // such. We should not have to poll for long in this call since
    // everybody should have already exit or should be winding down.
    //

    ErrorCode = ItSpAcquireExclusiveRef(&ItSrvRefCount);
    IT_ASSERT(ErrorCode == ERROR_SUCCESS);

    //
    // At this point no workers should be active and no new requests
    // should be coming. Now we will be breaking down the global state
    // structure (e.g. freeing memory, closing events etc.)  they
    // would be using.
    //

    ItSpCleanupGlobalContext(GlobalContext);

    DBGPR((ITID,ITTRC,"IDLE: SrvUninitialize(%p)=0\n",GlobalContext));

    return;
}

BOOLEAN
ItSrvServiceHandler(
    IN DWORD ControlCode,
    IN DWORD EventType,
    IN LPVOID EventData,
    IN LPVOID Context,
    OUT PDWORD ErrorCode
    )

/*++

Routine Description:

    This function is called with service/window messages to give idle
    detection a chance to filter/handle them. This is not a full blown
    service handler function as idle detection is piggy backed on
    another (e.g. scheduler) service that is responsible for
    starting/stopping idle detection. This function returns TRUE only
    if it wants ErrorCode to be returned from the caller to the
    system. If everything is successful and it does not need the
    caller to do anything special it returns FALSE.

    Only one ItSrvServiceHandler call should be outstanding.

Arguments:

    ControlCode - Service control code.

    EventType - Type of event that occured.

    EventData - Additional information based on ControlCode and EventType.
    
    Context - Ignored.
    
    ErrorCode - If the function return TRUE, this ErrorCode should be
      propagated to the system.

Return Value:

    TRUE - ErrorCode should be propagated to the system.
    
    FALSE - No need to do anything.

--*/

{
    PITSRV_GLOBAL_CONTEXT GlobalContext;
    BOOLEAN PropagateErrorCode;
    BOOLEAN AcquiredLock;
    BOOLEAN ClearedNotRunningEvent;
    
    //
    // Initialize locals.
    //

    GlobalContext = ItSrvGlobalContext;
    PropagateErrorCode = FALSE;
    AcquiredLock = FALSE;
    ClearedNotRunningEvent = FALSE;

    //
    // We cannot do anything if idle detection is not initialized.
    //

    if (GlobalContext->Status == 0 ||
        GlobalContext->Status == ItSrvStatusInitializing) {

        PropagateErrorCode = FALSE;
        goto cleanup;
    }

    //
    // Get a reference on the global context so it does not go away
    // beneath our feet.
    //

    *ErrorCode = ItSpAddRef(&ItSrvRefCount);
    
    if (*ErrorCode != ERROR_SUCCESS) {
        PropagateErrorCode = FALSE;
        goto cleanup;
    }
    
    //
    // Clear the event that says we are not running.
    //

    ResetEvent(GlobalContext->ServiceHandlerNotRunning);
    ClearedNotRunningEvent = TRUE;
    
    //
    // If server started uninitializing after we reset the event, we
    // should not do anything. By setting/checking for things in the
    // opposite order the server checks/sets them we minimize how long
    // it may have to poll when getting the exclusive reference.
    //

    if (GlobalContext->Status == ItSrvStatusUninitializing ||
        GlobalContext->Status == ItSrvStatusUninitialized) {

        PropagateErrorCode = FALSE;
        goto cleanup;
    }

    //
    // See if we have to do something based on input ControlCode and
    // EventType. The ControlCode is ignored by default if
    // PropagateErrorCode is not set otherwise.
    //

    //
    // Currently we don't handle any control codes. This is where we
    // would put the SERVICE_CONTROL_POWEREVENT/PBT_APMQUERYSUSPEND
    // handlers as well as service pause/resume requests and such.
    //

    PropagateErrorCode = FALSE;
    
 cleanup:

    if (AcquiredLock) {
        IT_RELEASE_LOCK(GlobalContext->GlobalLock);
    }

    if (ClearedNotRunningEvent) {
        SetEvent(GlobalContext->ServiceHandlerNotRunning);
    }
    
    return PropagateErrorCode;
}

DWORD
ItSrvRegisterIdleTask (
    ITRPC_HANDLE Reserved,
    IT_HANDLE *ItHandle,
    PIT_IDLE_TASK_PROPERTIES IdleTaskProperties
    )

/*++

Routine Description:

    Adds a new idle task to be run when the system is idle.

Arguments:

    Reserved - Ignored.

    ItHandle - Context handle returned to the client.

    IdleTaskProperties - Pointer to properties for the idle task.

Return Value:

    Status.

--*/

{
    PITSRV_IDLE_TASK_CONTEXT IdleTask;
    PITSRV_GLOBAL_CONTEXT GlobalContext;
    HANDLE ClientProcess;
    ULONG FailedCheckId;
    DWORD ErrorCode;
    DWORD WaitResult;
    LONG StatusVersion;
    ULONG NumLoops;
    BOOL Result;
    BOOLEAN AcquiredLock;
    BOOLEAN ImpersonatingClient;
    BOOLEAN OpenedThreadToken;

    //
    // Initialize locals.
    //

    IdleTask = NULL;
    AcquiredLock = FALSE;
    ImpersonatingClient = FALSE;
    ClientProcess = NULL;
    GlobalContext = ItSrvGlobalContext;

    //
    // Initialize parameters.
    //

    *ItHandle = NULL;

    DBGPR((ITID,ITTRC,"IDLE: SrvRegisterTask(%p)\n",IdleTaskProperties));

    //
    // Allocate a new idle task context.
    //
    
    IdleTask = IT_ALLOC(sizeof(ITSRV_IDLE_TASK_CONTEXT));

    if (!IdleTask) {
        ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    //
    // Initialize the fields to safe values so we know what to
    // cleanup.
    //

    IdleTask->Status = ItIdleTaskInitializing;
    IdleTask->StartEvent = NULL;
    IdleTask->StopEvent = NULL;   

    //
    // Copy and verify input buffer.
    //

    IdleTask->Properties = *IdleTaskProperties;

    FailedCheckId = ItpVerifyIdleTaskProperties(&IdleTask->Properties);
    
    if (FailedCheckId != 0) {
        ErrorCode = ERROR_BAD_FORMAT;
        goto cleanup;
    }

    //
    // Impersonate the client to open the start/stop events. They
    // should have been created by the client.
    //

    ErrorCode = RpcImpersonateClient(NULL);

    if (ErrorCode != RPC_S_OK) {
        goto cleanup;
    }

    ImpersonatingClient = TRUE;

    //
    // Open the client process. Since we impersonated the client, it
    // is safe to use the client id it specifies.
    //

    ClientProcess = OpenProcess(PROCESS_ALL_ACCESS,
                                FALSE,
                                IdleTaskProperties->ProcessId);
    
    if (!ClientProcess) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    //
    // Get handle to the start event.
    //

    Result = DuplicateHandle(ClientProcess,
                             (HANDLE) IdleTaskProperties->StartEventHandle,
                             GetCurrentProcess(),
                             &IdleTask->StartEvent,
                             EVENT_ALL_ACCESS,
                             FALSE,
                             0);

    if (!Result) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    //
    // Get handle to the stop event.
    //

    Result = DuplicateHandle(ClientProcess,
                             (HANDLE) IdleTaskProperties->StopEventHandle,
                             GetCurrentProcess(),
                             &IdleTask->StopEvent,
                             EVENT_ALL_ACCESS,
                             FALSE,
                             0);

    if (!Result) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    //
    // No need to impersonate any longer.
    //

    RpcRevertToSelf();
    ImpersonatingClient = FALSE;

    //
    // Make sure the handle is for an event and it is in the right
    // state.
    //

    if (!ResetEvent(IdleTask->StartEvent)) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    if (!SetEvent(IdleTask->StopEvent)) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    //
    // Acquire the server lock to check the status and insert new task
    // into the list.
    //
    
    NumLoops = 0;

    IT_ACQUIRE_LOCK(GlobalContext->GlobalLock);
    AcquiredLock = TRUE;
    
    do {
        
        //
        // We should be holding the GlobalLock when we come here the
        // first time or after looping. Inside the loop we may let go
        // of the lock, but we have to reacquire it before we loop.
        //

        IT_ASSERT(AcquiredLock);

        //
        // If there are already too many idle tasks registered, bail
        // out.
        //

        if (GlobalContext->NumIdleTasks >= 
            GlobalContext->Parameters.MaxNumRegisteredTasks) {
            ErrorCode = ERROR_TOO_MANY_OPEN_FILES;
            goto cleanup;
        }

        switch (GlobalContext->Status) {

        case ItSrvStatusInitializing:
            
            //
            // We should not have gotten called if the server is still
            // initializing!
            //
        
            IT_ASSERT(FALSE);
            ErrorCode = ERROR_NOT_READY;
            goto cleanup;

        case ItSrvStatusUninitializing:
            
            //
            // If the server is uninitializing, we should not add a
            // new idle task.
            //

            ErrorCode = ERROR_NOT_READY;
            goto cleanup;

            break;

        case ItSrvStatusUninitialized:  

            //
            // The server should not have uninitialized while we could be
            // running.
            //
        
            IT_ASSERT(FALSE);
            ErrorCode = ERROR_NOT_READY;
            goto cleanup;

        case ItSrvStatusStoppingIdleDetection:

            //
            // The idle task list should be empty if we are stopping
            // idle detection. There should not be a
            // IdleDetectionTimerHandle either.
            //

            IT_ASSERT(IsListEmpty(&GlobalContext->IdleTasksList));
            IT_ASSERT(GlobalContext->IdleDetectionTimerHandle == NULL);

            //
            // We must wait until idle detection is fully stopped. We
            // need to release our lock to do so. But note the status
            // version first.
            //

            StatusVersion = GlobalContext->StatusVersion;

            IT_RELEASE_LOCK(GlobalContext->GlobalLock);
            AcquiredLock = FALSE;
            
            WaitResult = WaitForSingleObject(GlobalContext->IdleDetectionStopped, 
                                             INFINITE);
        
            if (WaitResult != WAIT_OBJECT_0) {
                DBGPR((ITID,ITERR,"IDLE: SrvRegisterTask-FailedWaitStop\n"));
                ErrorCode = ERROR_INVALID_FUNCTION;
                goto cleanup;
            }

            //
            // Reacquire the lock.
            //

            IT_ACQUIRE_LOCK(GlobalContext->GlobalLock);
            AcquiredLock = TRUE;

            //
            // If nobody woke before us and updated the status, update
            // it now.
            //

            if (StatusVersion == GlobalContext->StatusVersion) {
                IT_ASSERT(GlobalContext->Status == ItSrvStatusStoppingIdleDetection);
                ItSpUpdateStatus(GlobalContext, ItSrvStatusWaitingForIdleTasks);
            }

            //
            // Loop to do what is necessary next.
            //

            break;

        case ItSrvStatusWaitingForIdleTasks:

            //
            // The idle task list should be empty if we are waiting
            // for idle tasks.
            //
            
            IT_ASSERT(IsListEmpty(&GlobalContext->IdleTasksList));
            
            //
            // If we are waiting for idle tasks, start idle detection
            // so we can add our task.
            //
            
            ErrorCode = ItSpStartIdleDetection(GlobalContext);
            
            if (ErrorCode != ERROR_SUCCESS) {
                goto cleanup;
            }
            
            //
            // Update the status.
            //
            
            ItSpUpdateStatus(GlobalContext, ItSrvStatusDetectingIdle);
            
            //
            // Loop and insert our idle task into the list. Note that
            // we are not releasing the lock, so we will not be in a
            // state where the status is ItSrvStatusDetectingIdle but
            // there are no idle tasks in the list.
            //
            
            break;
            
        case ItSrvStatusDetectingIdle:
        case ItSrvStatusRunningIdleTasks:
            
            //
            // If we are detecting idle, we just need to insert our
            // task into the list and break out.
            //
    
            //
            // This operation currently does not fail. If in the
            // future it may, make sure to handle the case we started
            // idle detection for this task. It is not an acceptable
            // state to have idle detection but no tasks in the list.
            //

            //
            // Insert the task into the list. We do not check for
            // duplicates and such as RPC helps us maintain context
            // per registration.
            //

            GlobalContext->NumIdleTasks++;

            InsertTailList(&GlobalContext->IdleTasksList, 
                           &IdleTask->IdleTaskLink);
            
            IdleTask->Status = ItIdleTaskQueued;

            break;


        default:

            //
            // We should be handling all valid cases above.
            //

            IT_ASSERT(FALSE);
            ErrorCode = ERROR_INVALID_FUNCTION;
            goto cleanup;
        }

        //
        // We should be still holding the global lock.
        //

        IT_ASSERT(AcquiredLock);

        //
        // Break out if we could queue our task.
        //

        if (IdleTask->Status == ItIdleTaskQueued) {
            break;
        }

        //
        // We should not loop too many times.
        //

        NumLoops++;

        if (NumLoops > 128) {
            DBGPR((ITID,ITERR,"IDLE: SrvRegisterTask-LoopTooMuch\n"));
            ErrorCode = ERROR_INVALID_FUNCTION;
            goto cleanup;
        }

    } while (TRUE);

    //
    // We should be still holding the lock.
    //

    IT_ASSERT(AcquiredLock);

    //
    // If we came here, we successfully inserted the task into the
    // list.
    //

    IT_ASSERT(!IsListEmpty(&GlobalContext->IdleTasksList));
    IT_ASSERT(IdleTask->Status == ItIdleTaskQueued);

    //
    // Release the lock.
    //

    IT_RELEASE_LOCK(GlobalContext->GlobalLock);
    AcquiredLock = FALSE;

    //
    // We are done.
    //

    ErrorCode = ERROR_SUCCESS;

 cleanup:

    if (ClientProcess) {
        CloseHandle(ClientProcess);
    }

    if (ImpersonatingClient) {
        RpcRevertToSelf();
    }
    
    if (ErrorCode != ERROR_SUCCESS) {

        if (IdleTask) {
            ItSpCleanupIdleTask(IdleTask);
            IT_FREE(IdleTask);
        }

    } else {
        
        *ItHandle = (IT_HANDLE)IdleTask;
    }

    if (AcquiredLock) {
        IT_RELEASE_LOCK(GlobalContext->GlobalLock);
    }

    DBGPR((ITID,ITTRC,"IDLE: SrvRegisterTask(%p)=%x\n",IdleTaskProperties,ErrorCode));

    return ErrorCode;
}
   
VOID
ItSrvUnregisterIdleTask (
    ITRPC_HANDLE Reserved,
    IT_HANDLE *ItHandle
    )

/*++

Routine Description:

    This function is a stub for ItSpUnregisterIdleTask that does the
    real work. Please see that function for comments.

Arguments:

    See ItSpUnregisterIdleTask.

Return Value:

    See ItSpUnregisterIdleTask.

--*/

{
    ItSpUnregisterIdleTask(Reserved, ItHandle, FALSE);
}

DWORD
ItSrvSetDetectionParameters (
    ITRPC_HANDLE Reserved,
    PIT_IDLE_DETECTION_PARAMETERS Parameters
    )

/*++

Routine Description:

    This debug routine is used by test programs to set the idle detection
    parameters. It will return ERROR_INVALID_FUNCTION on retail build.

Arguments:

    Reserved - Ignored.

    Parameters - New idle detection parameters.

Return Value:

    Win32 error code.

--*/

{

    DWORD ErrorCode;
    PITSRV_GLOBAL_CONTEXT GlobalContext;

    //
    // Initialize locals.
    //

    GlobalContext = ItSrvGlobalContext;

    DBGPR((ITID,ITTRC,"IDLE: SrvSetParameters(%p)\n",Parameters));

#ifndef IT_DBG

    //
    // This is a debug only API.
    //

    ErrorCode = ERROR_INVALID_FUNCTION;

#else // !IT_DBG

    //
    // Acquire the lock and copy the new parameters.
    //

    IT_ACQUIRE_LOCK(GlobalContext->GlobalLock);
    
    GlobalContext->Parameters = *Parameters;

    IT_RELEASE_LOCK(GlobalContext->GlobalLock);    

    ErrorCode = ERROR_SUCCESS;

#endif // !IT_DBG

    DBGPR((ITID,ITTRC,"IDLE: SrvSetParameters(%p)=%d\n",Parameters,ErrorCode));

    return ErrorCode;
}

DWORD
ItSrvProcessIdleTasks (
    ITRPC_HANDLE Reserved
    )

/*++

Routine Description:

    This routine forces all queued tasks (if there are any) to be processed 
    right away.

Arguments:

    Reserved - Ignored.

Return Value:

    Win32 error code.

--*/

{
    PITSRV_GLOBAL_CONTEXT GlobalContext;
    ITSRV_IDLE_DETECTION_OVERRIDE Overrides;
    DWORD ErrorCode;
    DWORD WaitResult;
    BOOLEAN AcquiredLock;
    
    //
    // Initialize locals.
    //

    AcquiredLock = FALSE;
    GlobalContext = ItSrvGlobalContext;

    DBGPR((ITID,ITTRC,"IDLE: SrvProcessAll()\n"));

    //
    // If a notification routine was specified, call it.
    //

    if (GlobalContext->ProcessIdleTasksNotifyRoutine) {
        GlobalContext->ProcessIdleTasksNotifyRoutine();
    }

    //
    // Acquire the server lock.
    //

    IT_ACQUIRE_LOCK(GlobalContext->GlobalLock);
    AcquiredLock = TRUE;

    //
    // The server should not have shutdown while we could be called.
    //
    
    IT_ASSERT(GlobalContext->Status != ItSrvStatusUninitialized);

    //
    // If the server is shutting down, we should not do anything.
    //

    if (GlobalContext->Status == ItSrvStatusUninitializing) {
        ErrorCode = ERROR_NOT_READY;
        goto cleanup;
    }

    //
    // If there are no tasks queued, we are done.
    //

    if (IsListEmpty(&GlobalContext->IdleTasksList)) {
        ErrorCode = ERROR_SUCCESS;
        goto cleanup;
    }

    //
    // There should be a timer queued if the list is not empty.
    //

    IT_ASSERT(GlobalContext->IdleDetectionTimerHandle);

    //
    // Set idle detection overrides:
    //

    Overrides = 0;
    Overrides |= ItSrvOverrideIdleDetection;
    Overrides |= ItSrvOverrideIdleVerification;
    Overrides |= ItSrvOverrideUserInputCheckToStopTask;
    Overrides |= ItSrvOverridePostTaskIdleCheck;
    Overrides |= ItSrvOverrideLongRequeueTime;
    Overrides |= ItSrvOverrideBatteryCheckToStopTask;

    GlobalContext->IdleDetectionOverride = Overrides;

    //
    // If an idle detection callback is not running, try to start the next one 
    // sooner (e.g. after 50ms).
    //

    if (!GlobalContext->IsIdleDetectionCallbackRunning) {

        if (!ChangeTimerQueueTimer(NULL,
                                   GlobalContext->IdleDetectionTimerHandle,
                                   50,
                                   IT_VERYLONG_TIMER_PERIOD)) {


            ErrorCode = GetLastError();
            goto cleanup;
        }
    }

    //
    // Release the lock.
    //

    IT_RELEASE_LOCK(GlobalContext->GlobalLock);
    AcquiredLock = FALSE;

    //
    // Wait for all tasks to be processed: i.e. when StopIdleDetection event is set.
    //

    WaitResult = WaitForSingleObject(GlobalContext->StopIdleDetection, INFINITE);

    if (WaitResult != WAIT_OBJECT_0) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    ErrorCode = ERROR_SUCCESS;

cleanup:

    GlobalContext->IdleDetectionOverride = 0;

    if (AcquiredLock) {
        IT_RELEASE_LOCK(GlobalContext->GlobalLock);
    }

    DBGPR((ITID,ITTRC,"IDLE: SrvProcessAll()=%x\n",ErrorCode));

    return ErrorCode;
 
}


VOID 
__RPC_USER 
IT_HANDLE_rundown (
    IT_HANDLE ItHandle
    )

/*++

Routine Description:

    This routine gets called by RPC when a client dies without
    unregistering.

Arguments:

    ItHandle - Context handle for the client.

Return Value:

    None.

--*/

{
    DWORD ErrorCode;

    //
    // Unregister the registered task.
    //

    ItSpUnregisterIdleTask(NULL, &ItHandle, TRUE);

    DBGPR((ITID,ITTRC,"IDLE: SrvHandleRundown(%p)\n",ItHandle));   

    return;
}

//
// Implementation of server side support functions.
//

RPC_STATUS 
__stdcall 
ItSpRpcSecurityCallback (
    IN PVOID Interface,
    IN PVOID Context
    )

/*++

Routine Description:


Arguments:


Return Value:

    Win32 error code.

--*/

{
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID AdministratorsSid;
    HANDLE ThreadToken;
    WCHAR *BindingString;
    WCHAR *ProtocolSequence;
    DWORD ErrorCode;
    BOOL ClientIsAdmin;
    BOOLEAN ImpersonatingClient;
    BOOLEAN OpenedThreadToken;

    //
    // Initialize locals.
    //

    BindingString = NULL;
    ProtocolSequence = NULL;
    ImpersonatingClient = FALSE;
    OpenedThreadToken = FALSE;
    AdministratorsSid = NULL;
    
    //
    // Make sure that the caller is calling over LRPC. We do this by 
    // determining the protocol sequence used from the string binding.
    //

    ErrorCode = RpcBindingToStringBinding(Context, &BindingString);

    if (ErrorCode != RPC_S_OK) {
        ErrorCode = RPC_S_ACCESS_DENIED;
        goto cleanup;
    }

    ErrorCode = RpcStringBindingParse(BindingString,
                                      NULL,
                                      &ProtocolSequence,
                                      NULL,
                                      NULL,
                                      NULL);

    if (ErrorCode != RPC_S_OK) {
        ErrorCode = RPC_S_ACCESS_DENIED;
        goto cleanup;
    }

    if (_wcsicmp(ProtocolSequence, L"ncalrpc") != 0) {
        ErrorCode = RPC_S_ACCESS_DENIED;
        goto cleanup;
    }

    //
    // Make sure the caller has admin priviliges:
    //

    //
    // Build the Administrators group SID so we can check if the
    // caller is has administrator priviliges.
    //

    if (!AllocateAndInitializeSid(&NtAuthority,
                                  2,
                                  SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS,
                                  0, 0, 0, 0, 0, 0,
                                  &AdministratorsSid)) {

        ErrorCode = GetLastError();
        goto cleanup;
    }

    //
    // Impersonate the client to check for membership/privilige.
    //

    ErrorCode = RpcImpersonateClient(NULL);

    if (ErrorCode != RPC_S_OK) {
        goto cleanup;
    }

    ImpersonatingClient = TRUE;

    //
    // Get the thread token and check to see if the client has admin
    // priviliges.
    //

    if (!OpenThreadToken(GetCurrentThread(),
                         TOKEN_READ,
                         FALSE,
                         &ThreadToken)) {

        ErrorCode = GetLastError();
        goto cleanup;
    }

    OpenedThreadToken = TRUE;

    if (!CheckTokenMembership(ThreadToken,
                              AdministratorsSid,
                              &ClientIsAdmin)) {
        
        ErrorCode = GetLastError();
        goto cleanup;
    }
    
    if (!ClientIsAdmin) {
        ErrorCode = ERROR_ACCESS_DENIED;
        goto cleanup;
    } 

    //
    // Everything looks good: allow this call to proceed.
    //

    ErrorCode = RPC_S_OK;

  cleanup:

    if (BindingString) {
        RpcStringFree(&BindingString);
    }

    if (ProtocolSequence) {
        RpcStringFree(&ProtocolSequence);
    }

    if (OpenedThreadToken) {
        CloseHandle(ThreadToken);
    }

    if (AdministratorsSid) {
        FreeSid (AdministratorsSid);
    }

    if (ImpersonatingClient) {
        RpcRevertToSelf();
    }

    return ErrorCode;
};
 
VOID
ItSpUnregisterIdleTask (
    ITRPC_HANDLE Reserved,
    IT_HANDLE *ItHandle,
    BOOLEAN CalledInternally
    )

/*++

Routine Description:

    Removes the specified idle task from the idle tasks list.

    As well as from a client RPC, this function can also be called
    from the idle detection callback to unregister an unresponsive
    idle task etc.

Arguments:

    Reserved - Ignored.

    ItHandle - Registration RPC Context handle. NULL on return.

    CalledInternally - Whether this function was called internally and
      not from an RPC client.

Return Value:

    None.

--*/

{
    PITSRV_IDLE_TASK_CONTEXT IdleTask;
    PITSRV_GLOBAL_CONTEXT GlobalContext;
    HANDLE ClientProcess;
    DWORD ErrorCode;   
    BOOLEAN AcquiredLock;
    BOOLEAN ImpersonatingClient;

    //
    // Initialize locals.
    //

    GlobalContext = ItSrvGlobalContext;
    AcquiredLock = FALSE;
    ImpersonatingClient = FALSE;
    ClientProcess = NULL;

    DBGPR((ITID,ITTRC,"IDLE: SrvUnregisterTask(%p)\n",(ItHandle)?*ItHandle:0));

    //
    // Grab the lock to walk through the list.
    //

    IT_ACQUIRE_LOCK(GlobalContext->GlobalLock);
    AcquiredLock = TRUE;

    //
    // The server should not have shutdown while we could be called.
    //
    
    IT_ASSERT(GlobalContext->Status != ItSrvStatusUninitialized);

    //
    // If the server is shutting down, we should not do anything.
    //

    if (GlobalContext->Status == ItSrvStatusUninitializing) {
        ErrorCode = ERROR_NOT_READY;
        goto cleanup;
    }
    
    //
    // Find the task.
    //

    IdleTask = ItSpFindIdleTask(GlobalContext, *ItHandle);
            
    if (!IdleTask) {
        ErrorCode = ERROR_NOT_FOUND;
        goto cleanup;
    }

    if (!CalledInternally) {

        //
        // To check security, impersonate the client and try to open the
        // client process for this idle task.
        //

        ErrorCode = RpcImpersonateClient(NULL);

        if (ErrorCode != RPC_S_OK) {
            goto cleanup;
        }

        ImpersonatingClient = TRUE;

        ClientProcess = OpenProcess(PROCESS_ALL_ACCESS,
                                    FALSE,
                                    IdleTask->Properties.ProcessId);
    
        if (!ClientProcess) {
            ErrorCode = GetLastError();
            goto cleanup;
        }
    
        //
        // If we could open the client process for this task, it is safe
        // to go on with unregistration. Now revert back to ourselves.
        //

        CloseHandle(ClientProcess);
        ClientProcess = NULL;
    
        RpcRevertToSelf();
        ImpersonatingClient = FALSE;
    }

    //
    // Remove it from the list, cleanup its fields and free
    // the memory allocated for it.
    //

    GlobalContext->NumIdleTasks--;
    RemoveEntryList(&IdleTask->IdleTaskLink);

    //
    // As a safety feature, to prevent from holding back
    // someone from running, set the run event and clear the
    // stop event from the task to be removed.
    //
    
    SetEvent(IdleTask->StartEvent);
    ResetEvent(IdleTask->StopEvent);

    //
    // If this is a running task, set the event that signals
    // we are removing the running idle task. This way some
    // other idle task may be started if the system is still
    // idle.
    //
    
    if (IdleTask->Status == ItIdleTaskRunning) {
        SetEvent(GlobalContext->RemovedRunningIdleTask);
    }

    ItSpCleanupIdleTask(IdleTask);
    
    IT_FREE(IdleTask);
    
    //
    // Check if the list is empty.
    //

    if (IsListEmpty(&GlobalContext->IdleTasksList)) {

        //
        // If we removed the task and the list became empty, we have
        // to update the status.
        //

        //
        // The current status should not be "waiting for idle
        // tasks" or "stopping idle detection", since the list was
        // NOT empty.
        //
        
        IT_ASSERT(GlobalContext->Status != ItSrvStatusWaitingForIdleTasks);
        IT_ASSERT(GlobalContext->Status != ItSrvStatusStoppingIdleDetection);
        
        //
        // Update the status.
        //

        ItSpUpdateStatus(GlobalContext, ItSrvStatusStoppingIdleDetection);
        
        //
        // Stop idle detection (e.g. close the timer handle, set event
        // etc.)
        //

        ItSpStopIdleDetection(GlobalContext);

    } else {

        //
        // The status should not be waiting for idle tasks or stopping
        // idle detection if the list is not empty.
        //

        IT_ASSERT(GlobalContext->Status != ItSrvStatusWaitingForIdleTasks &&
                  GlobalContext->Status != ItSrvStatusStoppingIdleDetection);
        
    }

    ErrorCode = ERROR_SUCCESS;

 cleanup:

    if (ClientProcess) {
        CloseHandle(ClientProcess);
    }

    if (ImpersonatingClient) {
        RpcRevertToSelf();
    }

    if (AcquiredLock) {
        IT_RELEASE_LOCK(GlobalContext->GlobalLock);
    }

    //
    // NULL the context handle, so RPC stubs know to end the
    // connection.
    //

    *ItHandle = NULL;

    DBGPR((ITID,ITTRC,"IDLE: SrvUnregisterTask(%p)=%x\n",(ItHandle)?*ItHandle:0,ErrorCode));

    return;
}

VOID
ItSpUpdateStatus (
    PITSRV_GLOBAL_CONTEXT GlobalContext,
    ITSRV_GLOBAL_CONTEXT_STATUS NewStatus
    )

/*++

Routine Description:

    This routine updates the current status and status history on the
    global context. Global contexts GlobalLock should be held while
    calling this function.

Arguments:

    GlobalContext - Pointer to server context structure.

    NewStatus - New status.

Return Value:

    None.

--*/

{
    LONG StatusIdx;

    DBGPR((ITID,ITTRC,"IDLE: SrvUpdateStatus(%p,%x)\n",GlobalContext,NewStatus));

    //
    // Verify new status.
    //

    IT_ASSERT(NewStatus > ItSrvStatusMinStatus);
    IT_ASSERT(NewStatus < ItSrvStatusMaxStatus);   

    //
    // Update history.
    //

    IT_ASSERT(ITSRV_GLOBAL_STATUS_HISTORY_SIZE >= 1);
    
    for (StatusIdx = ITSRV_GLOBAL_STATUS_HISTORY_SIZE - 1; 
         StatusIdx > 0;
         StatusIdx--) {

        IT_ASSERT(GlobalContext->LastStatus[StatusIdx - 1] > ItSrvStatusMinStatus);
        IT_ASSERT(GlobalContext->LastStatus[StatusIdx - 1] < ItSrvStatusMaxStatus);
        
        GlobalContext->LastStatus[StatusIdx] =  GlobalContext->LastStatus[StatusIdx - 1];
    }
   
    //
    // Verify current status and save it.
    //

    IT_ASSERT(GlobalContext->Status > ItSrvStatusMinStatus);
    IT_ASSERT(GlobalContext->Status < ItSrvStatusMaxStatus);
   
    GlobalContext->LastStatus[0] = GlobalContext->Status;

    //
    // Update current status.
    //

    GlobalContext->Status = NewStatus;

    //
    // Update status version.
    //
    
    GlobalContext->StatusVersion++;

    DBGPR((ITID,ITTRC,"IDLE: SrvUpdateStatus(%p,%x)=%d\n",
           GlobalContext, NewStatus,GlobalContext->StatusVersion));

    return;
}

VOID
ItSpCleanupGlobalContext (
    PITSRV_GLOBAL_CONTEXT GlobalContext
    )

/*++

Routine Description:

    This function cleans up the various fields of the ITSRV_GLOBAL_CONTEXT
    structure passed in. It does not free the structure itself.

    You should not be holding the global lock when calling this
    function, as it will be freed too. No workers etc. should be
    active. The idle detection timer should have already been
    removed. The structure should not be used after cleanup until it
    is initialized again.

    The current status of the global context should either be
    initializing or uninitializing. It will be set to uninitialized.

Arguments:

    GlobalContext - Pointer to server context structure.

Return Value:

    None.

--*/

{
    PITSRV_IDLE_TASK_CONTEXT IdleTask;
    PLIST_ENTRY ListHead;
    HANDLE EventHandle;

    DBGPR((ITID,ITSRVD,"IDLE: SrvCleanupContext(%p)\n",GlobalContext));

    //
    // Make sure there is no active idle detection timer.
    //

    if (GlobalContext->IdleDetectionTimerHandle) {
        IT_ASSERT(FALSE);
        return;
    }

    //
    // Verify the status of the global context.
    //

    if (GlobalContext->Status != ItSrvStatusInitializing &&
        GlobalContext->Status != ItSrvStatusUninitializing) {
        IT_ASSERT(FALSE);
        return;
    }

    //
    // Close the handle to global lock.
    //

    if (GlobalContext->GlobalLock) {
        CloseHandle(GlobalContext->GlobalLock);
    }

    //
    // Close the handle to the various events.
    //

    if (GlobalContext->StopIdleDetection) {
        CloseHandle(GlobalContext->StopIdleDetection);
    }

    if (GlobalContext->IdleDetectionStopped) {
        CloseHandle(GlobalContext->IdleDetectionStopped);
    }

    if (GlobalContext->RemovedRunningIdleTask) {
        CloseHandle(GlobalContext->RemovedRunningIdleTask);
    }

    if (GlobalContext->ServiceHandlerNotRunning) {
        CloseHandle(GlobalContext->ServiceHandlerNotRunning);
    }

    //
    // Close WMI DiskPerf handle.
    //
    
    if (GlobalContext->DiskPerfWmiHandle) {
        WmiCloseBlock(GlobalContext->DiskPerfWmiHandle);
    }
    
    //
    // Free WMI query buffer.
    //

    if (GlobalContext->WmiQueryBuffer) {
        IT_FREE(GlobalContext->WmiQueryBuffer);
    }

    //
    // Cleanup the snapshot buffer.
    //

    ItSpCleanupSystemSnapshot(&GlobalContext->LastSystemSnapshot);

    //
    // Walk through the list of registered idle tasks.
    //
    
    while (!IsListEmpty(&GlobalContext->IdleTasksList)) {

        GlobalContext->NumIdleTasks--;
        ListHead = RemoveHeadList(&GlobalContext->IdleTasksList);
        
        IdleTask = CONTAINING_RECORD(ListHead,
                                     ITSRV_IDLE_TASK_CONTEXT,
                                     IdleTaskLink);

        //
        // Cleanup and free the idle task structure.
        //
        
        ItSpCleanupIdleTask(IdleTask);

        IT_FREE(IdleTask);
    }

    //
    // Free the RPC binding vector.
    //

    if (GlobalContext->RpcBindingVector) {
        RpcBindingVectorFree(&GlobalContext->RpcBindingVector);
    }

    //
    // Update status.
    //

    ItSpUpdateStatus(GlobalContext, ItSrvStatusUninitialized);

    DBGPR((ITID,ITSRVD,"IDLE: SrvCleanupContext(%p)=0\n",GlobalContext));

    return;
}

VOID
ItSpCleanupIdleTask (
    PITSRV_IDLE_TASK_CONTEXT IdleTask
    )

/*++

Routine Description:

    This function cleans up the various fields of the ITSRV_IDLE_TASK_CONTEXT 
    structure. It does not free the structure itself.

Arguments:

    IdleTask - Pointer to idle task server context.

Return Value:

    None.

--*/

{

    DBGPR((ITID,ITSRVD,"IDLE: SrvCleanupTask(%p)\n",IdleTask));

    //
    // Close handles to start/stop events.
    //

    if (IdleTask->StartEvent) {
        CloseHandle(IdleTask->StartEvent);
    }

    if (IdleTask->StopEvent) {
        CloseHandle(IdleTask->StopEvent);
    }
}

ULONG
ItpVerifyIdleTaskProperties (
    PIT_IDLE_TASK_PROPERTIES IdleTaskProperties
    )

/*++

Routine Description:

    Verifies the specified structure.

Arguments:

    IdleTaskProperties - Pointer to properties for the idle task.

Return Value:

    0 - Verification passed.

    FailedCheckId - Id of the check that failed.

--*/

{
    ULONG FailedCheckId;

    //
    // Initialize locals.
    //

    FailedCheckId = 1;

    //
    // Verify the structure size/version.
    //

    if (IdleTaskProperties->Size != sizeof(*IdleTaskProperties)) {
        FailedCheckId = 10;
        goto cleanup;
    }

    //
    // Verify that the idle task ID is valid.
    //
    
    if (IdleTaskProperties->IdleTaskId >= ItMaxIdleTaskId) {
        FailedCheckId = 20;
        goto cleanup;
    }

    //
    // We passed all the checks.
    //

    FailedCheckId = 0;

 cleanup:

    DBGPR((ITID,ITSRVD,"IDLE: SrvVerifyTaskProp(%p)=%d\n",
           IdleTaskProperties, FailedCheckId));
    
    return FailedCheckId;
}

DWORD
ItSpStartIdleDetection (
    PITSRV_GLOBAL_CONTEXT GlobalContext
    )

/*++

Routine Description:

    This function is called to start idle detection. 

    GlobalContext's GlobalLock should be held while calling this
    function.

    The current state should be ItSrvStatusWaitingForIdleTasks when
    calling this function. The caller should ensure that stopping
    previous idle detection has been completed. 

    The caller should update the state to "detecting idle" etc, if
    this function returns success.

Arguments:

    GlobalContext - Pointer to server context structure.

Return Value:

    Win32 error code.

--*/

{
    DWORD ErrorCode;
    NTSTATUS Status;
    SYSTEM_BASIC_INFORMATION BasicInfo;
    DWORD TimerPeriod;

    DBGPR((ITID,ITTRC,"IDLE: SrvStartIdleDetection(%p)\n",GlobalContext));

    //
    // Make sure the current status is ItSrvStatusWaitingForIdleTasks.
    //

    IT_ASSERT(GlobalContext->Status == ItSrvStatusWaitingForIdleTasks);

    //
    // If we do not already have a diskperf wmi handle, try to get
    // one.
    //

    if (!GlobalContext->DiskPerfWmiHandle) {

        //
        // Get WMI context so we can query disk performance.
        //
        
        ErrorCode = WmiOpenBlock((GUID *)&DiskPerfGuid,
                                 GENERIC_READ,
                                 &GlobalContext->DiskPerfWmiHandle);
        
        if (ErrorCode != ERROR_SUCCESS) {
            
            //
            // Disk counters may not be initiated. We'll have to do
            // without them.
            //
            
            GlobalContext->DiskPerfWmiHandle = NULL;
        }
    }
        
    //
    // Determine the number of processors on the system.
    //
    
    if (!GlobalContext->NumProcessors) {
    
        Status = NtQuerySystemInformation(SystemBasicInformation,
                                          &BasicInfo,
                                          sizeof(BasicInfo),
                                          NULL);

        if (!NT_SUCCESS(Status)) {
            ErrorCode = RtlNtStatusToDosError(Status);
            goto cleanup;
        }
        
        GlobalContext->NumProcessors = BasicInfo.NumberOfProcessors;
    }

    //
    // Get initial snapshot only when this is the very first time we
    // are starting idle detection. Otherwise we'll keep the last
    // snapshot we got.
    //

    IT_ASSERT(ITSRV_GLOBAL_STATUS_HISTORY_SIZE >= 1);

    if (GlobalContext->LastStatus[0] == ItSrvStatusInitializing) {

        ErrorCode = ItSpGetSystemSnapshot(GlobalContext,
                                          &GlobalContext->LastSystemSnapshot);
        
        if (ErrorCode != ERROR_SUCCESS) {
            goto cleanup;
        }
    }

    //
    // Make sure the StopIdleDetection event is cleared.
    //
    
    ResetEvent(GlobalContext->StopIdleDetection);

    //
    // There should not be a timer-queue timer. We'll create one.
    //

    IT_ASSERT(!GlobalContext->IdleDetectionTimerHandle);
    
    //
    // Set the default timer period.
    //

    TimerPeriod = GlobalContext->Parameters.IdleDetectionPeriod;

    //
    // Adjust timer period to something small if we were idling when
    // idle detection was stopped. 
    //
    
    IT_ASSERT(ITSRV_GLOBAL_STATUS_HISTORY_SIZE >= 2);

    if (GlobalContext->LastStatus[0] == ItSrvStatusStoppingIdleDetection &&
        GlobalContext->LastStatus[1] == ItSrvStatusRunningIdleTasks) {
        
        //
        // Set small wake up time in ms. We'll still check if we were idle
        // since the last snapshot and verify it over small periods.
        //

        if (TimerPeriod > (60 * 1000)) {
            TimerPeriod = 60 * 1000; // 1 minute.
        }
    }

    DBGPR((ITID,ITTRC,"IDLE: SrvStartIdleDetection(%p)-TimerPeriod=%d\n",GlobalContext,TimerPeriod));

    if (!CreateTimerQueueTimer(&GlobalContext->IdleDetectionTimerHandle,
                               NULL,
                               ItSpIdleDetectionCallbackRoutine,
                               GlobalContext,
                               TimerPeriod,
                               IT_VERYLONG_TIMER_PERIOD,
                               WT_EXECUTELONGFUNCTION)) {
        
        GlobalContext->IdleDetectionTimerHandle = NULL;
        ErrorCode = GetLastError();
        goto cleanup;
    }

    //
    // We are done.
    //
    
    ErrorCode = ERROR_SUCCESS;

 cleanup:

    DBGPR((ITID,ITTRC,"IDLE: SrvStartIdleDetection(%p)=%x\n",GlobalContext,ErrorCode));

    return ErrorCode;
}

VOID
ItSpStopIdleDetection (
    PITSRV_GLOBAL_CONTEXT GlobalContext
    )

/*++

Routine Description:

    This function is called to stop idle detection. Even though it
    returns immediately, idle detection may not have stopped
    completely (i.e. the callback may be running). The
    IdleDetectionStopped event on the GlobalContext will be set when
    the idle detection will be fully stopped.

    GlobalContext's GlobalLock should be held while calling this
    function.

    The status before calling this function should be set to
    ItSrvStatusStoppingIdleDetection or ItSrvStatusUninitializing.

Arguments:

    GlobalContext - Pointer to server context structure.

Return Value:

    None.

--*/

{
    DBGPR((ITID,ITTRC,"IDLE: SrvStopIdleDetection(%p)\n",GlobalContext));

    //
    // Make sure the status is set right.
    //

    IT_ASSERT(GlobalContext->Status == ItSrvStatusStoppingIdleDetection ||
              GlobalContext->Status == ItSrvStatusUninitializing);

    //
    // Clear the event that will be set when idle detection has been
    // fully stoped.
    //

    ResetEvent(GlobalContext->IdleDetectionStopped);

    //
    // Signal the event that signals the idle detection callback to go
    // away asap.
    //

    if (GlobalContext->StopIdleDetection) {
        SetEvent(GlobalContext->StopIdleDetection);
    }

    //
    // Close the handle to the timer-queue timer.
    //

    IT_ASSERT(GlobalContext->IdleDetectionTimerHandle);

    DeleteTimerQueueTimer(NULL, 
                          GlobalContext->IdleDetectionTimerHandle,
                          GlobalContext->IdleDetectionStopped);
        
    GlobalContext->IdleDetectionTimerHandle = NULL;

    DBGPR((ITID,ITTRC,"IDLE: SrvStopIdleDetection(%p)=0\n",GlobalContext));

    return;
}

PITSRV_IDLE_TASK_CONTEXT
ItSpFindRunningIdleTask (
    PITSRV_GLOBAL_CONTEXT GlobalContext
    )

/*++

Routine Description:

    If there is an idle task marked "running" this routine finds and
    returns it. GlobalContext's GlobalLock should be held while
    calling this function.

Arguments:

    GlobalContext - Pointer to server context structure.

Return Value:

    Pointer to running idle task or NULL if no idle tasks are marked
    running.

--*/

{
    PITSRV_IDLE_TASK_CONTEXT IdleTask;
    PITSRV_IDLE_TASK_CONTEXT RunningIdleTask;
    PLIST_ENTRY HeadEntry;
    PLIST_ENTRY NextEntry;

    //
    // Initialize locals.
    //
    
    RunningIdleTask = NULL;

    HeadEntry = &GlobalContext->IdleTasksList;
    NextEntry = HeadEntry->Flink;
    
    while (NextEntry != HeadEntry) {
        
        IdleTask = CONTAINING_RECORD(NextEntry,
                                      ITSRV_IDLE_TASK_CONTEXT,
                                      IdleTaskLink);
        
        NextEntry = NextEntry->Flink;

        if (IdleTask->Status == ItIdleTaskRunning) {

            //
            // There should be a single running task.
            //

            IT_ASSERT(RunningIdleTask == NULL);

            //
            // We found it. Loop through the remaining entries to make
            // sure there is really only one if not debugging.
            //

            RunningIdleTask = IdleTask;

#ifndef IT_DBG
            
            break;

#endif // !IT_DBG

        }
    }

    //
    // Fall through with RunningIdleTask found when walking the list
    // or NULL as initialized at the top.
    //

    DBGPR((ITID,ITSRVD,"IDLE: SrvFindRunningTask(%p)=%p\n",GlobalContext,RunningIdleTask));

    return RunningIdleTask;
}

PITSRV_IDLE_TASK_CONTEXT
ItSpFindIdleTask (
    PITSRV_GLOBAL_CONTEXT GlobalContext,
    IT_HANDLE ItHandle
    )

/*++

Routine Description:

    If there is an idle task registered with ItHandle, this routine
    finds and returns it. GlobalContext's GlobalLock should be held
    while calling this function.

Arguments:

    GlobalContext - Pointer to server context structure.

    ItHandle - Registration handle.

Return Value:

    Pointer to found idle task or NULL if no matching idle tasks were
    found.

--*/

{
    PITSRV_IDLE_TASK_CONTEXT IdleTask;
    PITSRV_IDLE_TASK_CONTEXT FoundIdleTask;
    PLIST_ENTRY HeadEntry;
    PLIST_ENTRY NextEntry;

    //
    // Initialize locals.
    //
    
    FoundIdleTask = NULL;

    HeadEntry = &GlobalContext->IdleTasksList;
    NextEntry = HeadEntry->Flink;
    
    while (NextEntry != HeadEntry) {
        
        IdleTask = CONTAINING_RECORD(NextEntry,
                                      ITSRV_IDLE_TASK_CONTEXT,
                                      IdleTaskLink);
        
        NextEntry = NextEntry->Flink;

        if ((IT_HANDLE) IdleTask == ItHandle) {
            FoundIdleTask = IdleTask;
            break;
        }
    }

    //
    // Fall through with FoundIdleTask found when walking the list or
    // NULL as initialized at the top.
    //

    DBGPR((ITID,ITSRVD,"IDLE: SrvFindTask(%p,%p)=%p\n",GlobalContext,ItHandle,FoundIdleTask));

    return FoundIdleTask;
}

VOID 
CALLBACK
ItSpIdleDetectionCallbackRoutine (
    PVOID Parameter,
    BOOLEAN TimerOrWaitFired
    )

/*++

Routine Description:

    While there are idle tasks to run, this function is called every
    IdleDetectionPeriod to determine if the system is idle. It uses
    the last system snapshot saved in the global context. If it
    determines that the system was idle in the time it was called, it
    samples system activity for smaller intervals, to make sure system
    activity that started as the (possible very long) idle detection
    period expired, is not ignored.

    As long as we are not told to go away (checked by the macro
    ITSP_SHOULD_STOP_IDLE_DETECTION) this function always tries to
    queue a timer to get called back in IdleDetectionPeriod. This
    macro should be called each time the lock is acquired in this
    function. Also, we should not sleep blindly when we need to let
    time pass, but wait on an event that will get signaled when we are
    asked to stop.

Arguments:

    Parameter - Pointer to an idle detection context.
    
    TimerOrWaitFired - Reason why we were called. This should be TRUE
      (i.e. our timer expired)

Return Value:

    None.

--*/

{
    DWORD ErrorCode;
    PITSRV_GLOBAL_CONTEXT GlobalContext;
    ITSRV_SYSTEM_SNAPSHOT CurrentSystemSnapshot;
    SYSTEM_POWER_STATUS SystemPowerStatus;
    LASTINPUTINFO LastUserInput;
    LASTINPUTINFO CurrentLastUserInput;
    BOOLEAN SystemIsIdle;
    BOOLEAN AcquiredLock;
    BOOLEAN MarkedIdleTaskRunning;
    BOOLEAN OrderedToStop;
    ULONG VerificationIdx;
    DWORD WaitResult;
    PITSRV_IDLE_TASK_CONTEXT IdleTask;
    ULONG NumTasksRun;
    ULONG DuePeriod;
    BOOLEAN NotIdleBecauseOfUserInput;
    BOOLEAN MisfiredCallback;
    IT_HANDLE ItHandle;
    NTSTATUS Status;
    SYSTEM_POWER_INFORMATION PowerInfo;
    
    //
    // Initialize locals.
    //
    
    GlobalContext = Parameter;
    AcquiredLock = FALSE;
    MarkedIdleTaskRunning = FALSE;
    ItSpInitializeSystemSnapshot(&CurrentSystemSnapshot);
    LastUserInput.cbSize = sizeof(LASTINPUTINFO);
    CurrentLastUserInput.cbSize = sizeof(LASTINPUTINFO);
    NumTasksRun = 0;
    SystemIsIdle = FALSE;
    MisfiredCallback = FALSE;
    NotIdleBecauseOfUserInput = FALSE;

    DBGPR((ITID,ITTRC,"IDLE: SrvIdleDetectionCallback(%p)\n",GlobalContext));

    //
    // We should not be called without an idle detection context.
    //

    IT_ASSERT(GlobalContext);

    //
    // We should be called only because IdleDetectionPeriod passed and
    // our timer expired.
    //

    IT_ASSERT(TimerOrWaitFired);

    //
    // Get the server lock.
    //

    IT_ACQUIRE_LOCK(GlobalContext->GlobalLock);
    AcquiredLock = TRUE;

    //
    // If there is an idle detection callback already running simply
    // exit without doing anything.
    //

    if (GlobalContext->IsIdleDetectionCallbackRunning) {
        DBGPR((ITID,ITTRC,"IDLE: SrvIdleDetectionCallback-Misfired!\n"));
        MisfiredCallback = TRUE;
        ErrorCode = ERROR_ALREADY_EXISTS;
        goto cleanup;
    }

    GlobalContext->IsIdleDetectionCallbackRunning = TRUE;

    //
    // Make sure the current state is feasible if we are running.
    //

    IT_ASSERT(GlobalContext->Status == ItSrvStatusDetectingIdle ||
              GlobalContext->Status == ItSrvStatusUninitializing ||
              GlobalContext->Status == ItSrvStatusStoppingIdleDetection); 

    //
    // If we are told to go away, do so.
    //

    if (ITSP_SHOULD_STOP_IDLE_DETECTION(GlobalContext)) {
        ErrorCode = ERROR_SUCCESS;
        goto cleanup;
    }
    
    //
    // Get initial last input time that will be used later if we
    // decide to run idle tasks.
    //
        
    ErrorCode = ItSpGetLastInputInfo(&LastUserInput);

    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // Perform idle detection over the period we've been sleeping (if
    // it is not overriden.)
    //
    
    if (!(GlobalContext->IdleDetectionOverride & ItSrvOverrideIdleDetection)) {

        //
        // Get current system snapshot.
        //

        ErrorCode = ItSpGetSystemSnapshot(GlobalContext, 
                                          &CurrentSystemSnapshot);
    
        if (ErrorCode != ERROR_SUCCESS) {
            goto cleanup;
        }

        //
        // See if system looks idle since the last snapshot.
        //

        SystemIsIdle = ItSpIsSystemIdle(GlobalContext,
                                        &CurrentSystemSnapshot,
                                        &GlobalContext->LastSystemSnapshot,
                                        ItSrvInitialIdleCheck);

        //
        // If the last input times don't match and that's why we are not
        // idle, make a note.
        //

        if ((CurrentSystemSnapshot.GotLastInputInfo &&
             GlobalContext->LastSystemSnapshot.GotLastInputInfo) &&
            (CurrentSystemSnapshot.LastInputInfo.dwTime !=
             GlobalContext->LastSystemSnapshot.LastInputInfo.dwTime)) {

            NotIdleBecauseOfUserInput = TRUE;
            ASSERT(!SystemIsIdle);
        }

        //
        // Save snapshot.
        //

        ErrorCode = ItSpCopySystemSnapshot(&GlobalContext->LastSystemSnapshot,
                                           &CurrentSystemSnapshot);
    
        if (ErrorCode != ERROR_SUCCESS) {
            goto cleanup;
        }

        //
        // If the system does not look idle over the detection period
        // we'll poll again later.
        //

        if (!SystemIsIdle) {
            ErrorCode = ERROR_SUCCESS;
            goto cleanup;
        }
    }

    //
    // If we were not asked to override idle verification, verify that
    // the system is idle for a while.
    //

    if (!(GlobalContext->IdleDetectionOverride & ItSrvOverrideIdleVerification)) {

        //
        // Loop for a while getting system snapshots over shorter
        // durations. This helps us catch recent significant system
        // activity that seemed insignificant when viewed over the whole
        // IdleDetectionPeriod.
        //

        DBGPR((ITID,ITTRC,"IDLE: SrvIdleDetectionCallback-Verifying\n"));

        for (VerificationIdx = 0; 
             VerificationIdx < GlobalContext->Parameters.NumVerifications;
             VerificationIdx ++) {

            //
            // Release the lock.
            //
        
            IT_ASSERT(AcquiredLock);
            IT_RELEASE_LOCK(GlobalContext->GlobalLock);
            AcquiredLock = FALSE;
        
            //
            // Sleep for the verification period.
            //

            WaitResult = WaitForSingleObject(GlobalContext->StopIdleDetection,
                                             GlobalContext->Parameters.IdleVerificationPeriod);

            if (WaitResult != WAIT_TIMEOUT) {
            
                if (WaitResult == WAIT_OBJECT_0) {
                    ErrorCode = ERROR_SUCCESS;
                } else {
                    ErrorCode = GetLastError();
                }

                goto cleanup;
            }

            //
            // Acquire the lock.
            //
        
            IT_ACQUIRE_LOCK(GlobalContext->GlobalLock);
            AcquiredLock = TRUE;

            //
            // Are we told to go away (this may happen from the time the
            // wait returns till we acquire the lock.)
            //

            if (ITSP_SHOULD_STOP_IDLE_DETECTION(GlobalContext)) {
                ErrorCode = ERROR_SUCCESS;
                goto cleanup;
            }
            
            //
            // Get the new snapshot.
            //

            ErrorCode = ItSpGetSystemSnapshot(GlobalContext, 
                                              &CurrentSystemSnapshot);
        
            if (ErrorCode != ERROR_SUCCESS) {
                goto cleanup;
            }

            //
            // See if system looks idle since the last snapshot.
            //
        
            SystemIsIdle = ItSpIsSystemIdle(GlobalContext,
                                            &CurrentSystemSnapshot,
                                            &GlobalContext->LastSystemSnapshot,
                                            ItSrvIdleVerificationCheck);
        
            //
            // Save snapshot.
            //
        
            ErrorCode = ItSpCopySystemSnapshot(&GlobalContext->LastSystemSnapshot,
                                               &CurrentSystemSnapshot);
        
            if (ErrorCode != ERROR_SUCCESS) {
                goto cleanup;
            }
        
            //
            // If the system was not idle over the detection period we'll
            // try again later.
            //
        
            if (!SystemIsIdle) {
                ErrorCode = ERROR_SUCCESS;
                goto cleanup;
            }
        }
    }

    //
    // The system has become idle. Update the status.
    //

    DBGPR((ITID,ITTRC,"IDLE: SrvIdleDetectionCallback-RunningIdleTasks\n"));
        
    IT_ASSERT(GlobalContext->Status == ItSrvStatusDetectingIdle);
    ItSpUpdateStatus(GlobalContext, ItSrvStatusRunningIdleTasks);   

    //
    // While we are not told to go away...
    //

    while (!ITSP_SHOULD_STOP_IDLE_DETECTION(GlobalContext)) {

        //
        // We should be holding the lock when we are making the above
        // check and whenever we come here.
        //
        
        IT_ASSERT(AcquiredLock);
        
        //
        // The list should not be empty.
        //
        
        IT_ASSERT(!IsListEmpty(&GlobalContext->IdleTasksList));
        
        if (IsListEmpty(&GlobalContext->IdleTasksList)) {
            ErrorCode = ERROR_INVALID_FUNCTION;
            goto cleanup;
        }

        //
        // Mark the first idle task in the list running and signal its
        // event.
        //

        IdleTask = CONTAINING_RECORD(GlobalContext->IdleTasksList.Flink,
                                     ITSRV_IDLE_TASK_CONTEXT,
                                     IdleTaskLink);
    
        //
        // It should not be uninitialized or already running!
        //
        
        IT_ASSERT(IdleTask->Status == ItIdleTaskQueued);
        IdleTask->Status = ItIdleTaskRunning;
        MarkedIdleTaskRunning = TRUE;

        DBGPR((ITID,ITTRC,"IDLE: SrvIdleDetectionCallback-Running %d\n",IdleTask->Properties.IdleTaskId));

        NumTasksRun++;
        
        //
        // Signal its events.
        //

        ResetEvent(IdleTask->StopEvent);
        SetEvent(IdleTask->StartEvent);

        //
        // Reset the event that will get set when the idle task we
        // mark running gets unregistered.
        //

        ResetEvent(GlobalContext->RemovedRunningIdleTask);

        //
        // Release the lock.
        //

        IT_RELEASE_LOCK(GlobalContext->GlobalLock);
        AcquiredLock = FALSE;

        //
        // Poll frequently for user input while system background
        // activity should be taking place. We cannot poll for
        // anything else because the running idle task is supposed to
        // be using CPU, issuing I/Os etc. As soon as user input comes
        // we want to signal background threads to stop their
        // activity. We will do this until the running idle task is
        // completed and unregistered.
        //

        do {

            //
            // We should not be holding the lock while polling.
            //
            
            IT_ASSERT(!AcquiredLock);

            //
            // Note that since we set MarkedIdleTaskRunning, going to
            // "cleanup" will end up marking this idle task not
            // running and setting the stop event.
            //

            if (!(GlobalContext->IdleDetectionOverride & ItSrvOverrideUserInputCheckToStopTask)) {

                //
                // Get last user input.
                //
                
                ErrorCode = ItSpGetLastInputInfo(&CurrentLastUserInput);

                if (ErrorCode != ERROR_SUCCESS) {
                    goto cleanup;
                }

                if (LastUserInput.dwTime != CurrentLastUserInput.dwTime) {

                    //
                    // There is new input.
                    //

                    DBGPR((ITID,ITTRC,"IDLE: SrvIdleDetectionCallback-NewUserInput\n"));
                    
                    SystemIsIdle = FALSE;
                    ErrorCode = ERROR_SUCCESS;
                    goto cleanup;
                }

                //
                // We don't need to update last input since it should
                // be same as current.
                //
            }

            //
            // Wait for a while to poll for user input again. We
            // should not be holding the lock while waiting.
            //

            IT_ASSERT(!AcquiredLock);

            WaitResult = WaitForSingleObject(GlobalContext->RemovedRunningIdleTask,
                                         GlobalContext->Parameters.IdleInputCheckPeriod);
            
            if (WaitResult == WAIT_OBJECT_0) {
                
                //
                // Break out of this loop to pick up a new idle
                // task to run.
                //
                
                MarkedIdleTaskRunning = FALSE;

                DBGPR((ITID,ITTRC,"IDLE: SrvIdleDetectionCallback-TaskRemoved\n"));
                
                break;
            }
            
            if (WaitResult != WAIT_TIMEOUT) {
                
                //
                // Something went wrong...
                //
                
                ErrorCode = ERROR_INVALID_FUNCTION;
                goto cleanup;
            }

            //
            // Check to see if the system has started running from battery.
            //

            if (!(GlobalContext->IdleDetectionOverride & ItSrvOverrideBatteryCheckToStopTask)) {
                if (GetSystemPowerStatus(&SystemPowerStatus)) {
                    if (SystemPowerStatus.ACLineStatus == 0) {

                        DBGPR((ITID,ITTRC,"IDLE: SrvIdleDetectionCallback-SystemOnBattery\n"));
                        
                        SystemIsIdle = FALSE;
                        ErrorCode = ERROR_SUCCESS;
                        goto cleanup;
                    }
                }
            }

            //
            // If the kernel is about to enter standby or hibernate because
            // it has also detected the system idle, stop this task.
            //

            if (!(GlobalContext->IdleDetectionOverride & ItSrvOverrideAutoPowerCheckToStopTask)) {

                Status = NtPowerInformation(SystemPowerInformation,
                                            NULL,
                                            0,
                                            &PowerInfo,
                                            sizeof(PowerInfo));
            
                if (NT_SUCCESS(Status)) {
                    if (PowerInfo.TimeRemaining < IT_DEFAULT_MAX_TIME_REMAINING_TO_SLEEP) {
                        SystemIsIdle = FALSE;
                        ErrorCode = ERROR_SUCCESS;
                        goto cleanup;
                    }
                }
            }

            //
            // The idle task is still running. Loop to check for user
            // input.
            //

        } while (TRUE);

        if (!AcquiredLock) {
            IT_ACQUIRE_LOCK(GlobalContext->GlobalLock);
            AcquiredLock = TRUE;
        }

        if (!(GlobalContext->IdleDetectionOverride & ItSrvOverridePostTaskIdleCheck)) {
        
            //
            // Get the latest snapshot of the system. This snapshot will
            // be used to determine if the system is still idle before
            // picking up a new task.
            //
            
            ErrorCode = ItSpGetSystemSnapshot(GlobalContext, 
                                              &GlobalContext->LastSystemSnapshot);
            
            if (ErrorCode != ERROR_SUCCESS) {
                goto cleanup;
            }

            //
            // Release the lock.
            //

            IT_RELEASE_LOCK(GlobalContext->GlobalLock);
            AcquiredLock = FALSE;

            //
            // Wait for the verification period.
            //

            WaitResult = WaitForSingleObject(GlobalContext->StopIdleDetection,
                                             GlobalContext->Parameters.IdleVerificationPeriod);

            if (WaitResult != WAIT_TIMEOUT) {
                
                if (WaitResult == WAIT_OBJECT_0) {
                    ErrorCode = ERROR_SUCCESS;
                } else {
                    ErrorCode = GetLastError();
                }
                
                goto cleanup;
            }

            //
            // Acquire the lock and get new snapshot.
            //

            IT_ASSERT(!AcquiredLock);
            IT_ACQUIRE_LOCK(GlobalContext->GlobalLock);
            AcquiredLock = TRUE;

            ErrorCode = ItSpGetSystemSnapshot(GlobalContext, 
                                              &CurrentSystemSnapshot);
            
            if (ErrorCode != ERROR_SUCCESS) {
                goto cleanup;
            }

            //
            // See if system looks idle since the last snapshot.
            //
            
            SystemIsIdle = ItSpIsSystemIdle(GlobalContext,
                                            &CurrentSystemSnapshot,
                                            &GlobalContext->LastSystemSnapshot,
                                            ItSrvIdleVerificationCheck);
            
            //
            // Save snapshot.
            //
            
            ErrorCode = ItSpCopySystemSnapshot(&GlobalContext->LastSystemSnapshot,
                                               &CurrentSystemSnapshot);
            
            if (ErrorCode != ERROR_SUCCESS) {
                goto cleanup;
            }

            //
            // If the system is no longer idle, we should not start a new task.
            //
            
            if (!SystemIsIdle) {
                ErrorCode = ERROR_SUCCESS;
                goto cleanup;
            }
        }

        //
        // Loop to try to run more idle tasks. The lock should be acquired.
        //

        IT_ASSERT(AcquiredLock);
    }
    
    //
    // We should come here only if we were asked to stop, i.e. the
    // check in while() causes us to break from looping.
    //
    
    IT_ASSERT(AcquiredLock);
    IT_ASSERT(ITSP_SHOULD_STOP_IDLE_DETECTION(GlobalContext));

 cleanup:

    //
    // Simply cleanup and exit if this is a misfired callback.
    //

    if (!MisfiredCallback) {
    
        //
        // We'll have to check status to see if we have to requeue
        // ourselves. Make sure we have the lock.
        //

        if (AcquiredLock == FALSE) {
            IT_ACQUIRE_LOCK(GlobalContext->GlobalLock);
            AcquiredLock = TRUE;
        }

        //
        // If we marked an idle task running, make sure we reset its state
        // back to queued.
        //

        if (MarkedIdleTaskRunning) {

            //
            // We may have gone to cleanup after the idle task we were
            // running was removed, but before we realized it. See if
            // the running idle task was removed. We are not waiting,
            // we are just checking if the event has been signaled.
            //

            WaitResult = WaitForSingleObject(GlobalContext->RemovedRunningIdleTask,
                                             0);
            
            if (WaitResult != WAIT_OBJECT_0) {

                //
                // The running idle was not removed. Reset its state.
                //

                IdleTask = ItSpFindRunningIdleTask(GlobalContext);
                
                //
                // To be safe, we try to cleanup even if the above
                // check fails with another result. We don't want the
                // assert to fire then, but only if the event is
                // really not set.
                //

                if (WaitResult == WAIT_TIMEOUT) {
                    IT_ASSERT(IdleTask);
                }
                
                if (IdleTask) {
                    ResetEvent(IdleTask->StartEvent);
                    SetEvent(IdleTask->StopEvent);
                    IdleTask->Status = ItIdleTaskQueued;

                    //
                    // Put this task to the end of the list. If a single task
                    // is taking too long to run, this gives more chance to other
                    // tasks.
                    //

                    RemoveEntryList(&IdleTask->IdleTaskLink);
                    InsertTailList(&GlobalContext->IdleTasksList, &IdleTask->IdleTaskLink);                    
                }
            }
        }

        //
        // If we set the status to running idle tasks, revert it to
        // detecting idle.
        //

        if (GlobalContext->Status == ItSrvStatusRunningIdleTasks) {
            ItSpUpdateStatus(GlobalContext, ItSrvStatusDetectingIdle);
        }

        //
        // Queue ourselves to fire up after another idle detection
        // period. We'll try every once a while until we get it or we
        // are ordered to stop.
        //
    
        while (!ITSP_SHOULD_STOP_IDLE_DETECTION(GlobalContext)) {
    
            IT_ASSERT(GlobalContext->IdleDetectionTimerHandle);

            DuePeriod = GlobalContext->Parameters.IdleDetectionPeriod;

            //
            // Try to detect idle quicker for the case when the last user 
            // input was just seconds after the last snapshot. In that case
            // instead of waiting for another full "DetectionPeriod", we'll 
            // wait up to "DetectionPeriod" after the last user input. Note
            // that we'll attempt this optimization only if the reason we
            // say the system is not idle is recent user input. E.g. We don't 
            // want to poll more often if we are on battery and that's why
            // we say that the system is not idle.
            //

            if (NotIdleBecauseOfUserInput && 
                (ERROR_SUCCESS == ItSpGetLastInputInfo(&LastUserInput))) {

                ULONG DuePeriod2;
                ULONG TimeSinceLastInput;

                //
                // Calculate how long it's been since last user input.
                //

                TimeSinceLastInput = GetTickCount() - LastUserInput.dwTime;

                //
                // Subtract this time from the idle detection period to account
                // for time that has already past since last input.
                //

                DuePeriod2 = 0;
                
                if (TimeSinceLastInput < GlobalContext->Parameters.IdleDetectionPeriod) {           
                    DuePeriod2 = GlobalContext->Parameters.IdleDetectionPeriod - TimeSinceLastInput;
                }

                //
                // The last user input we check gets updated only every so
                // often (e.g. every minute). Add a fudge factor for this and to 
                // protect us from scheduling the next idle check too soon.
                //

#ifdef IT_DBG
                if (ItSrvGlobalContext->Parameters.IdleDetectionPeriod >= 60*1000) {
#endif // IT_DBG

                    DuePeriod2 += 65 * 1000;

#ifdef IT_DBG
                }
#endif // IT_DBG

                if (DuePeriod > DuePeriod2) {
                    DuePeriod = DuePeriod2;
                }
            }

            //
            // If we are forcing all tasks to be processed, requeue ourself to
            // run again in a short time.
            //

            if (GlobalContext->IdleDetectionOverride & ItSrvOverrideLongRequeueTime) {
                DuePeriod = 50;
            }

            if (ChangeTimerQueueTimer(NULL,
                                      GlobalContext->IdleDetectionTimerHandle,
                                      DuePeriod,
                                      IT_VERYLONG_TIMER_PERIOD)) {

                DBGPR((ITID,ITTRC,"IDLE: SrvIdleDetectionCallback-Requeued: DuePeriod=%d\n", DuePeriod));

                break;
            }

            //
            // Release the lock.
            //
            
            IT_ASSERT(AcquiredLock);
            IT_RELEASE_LOCK(GlobalContext->GlobalLock);
            AcquiredLock = FALSE;

            //
            // Sleep for sometime and try again.
            //
            
            WaitResult = WaitForSingleObject(GlobalContext->StopIdleDetection, 
                                             GlobalContext->Parameters.IdleDetectionPeriod); 

            //
            // Get the lock again.
            //

            IT_ACQUIRE_LOCK(GlobalContext->GlobalLock);
            AcquiredLock = TRUE;       
            
            //
            // Now check the result of the wait.
            //
            
            if (WaitResult != WAIT_OBJECT_0 && 
                WaitResult != WAIT_TIMEOUT) {

                //
                // This is an error too! The world is going down on us,
                // let us get carried away... This will make it easier for
                // the server to shutdown (i.e. no callback running).
                //
                
                break;
            }
        }
    
        IT_ASSERT(AcquiredLock);

        //
        // Check if we were ordered to stop.
        //

        OrderedToStop = ITSP_SHOULD_STOP_IDLE_DETECTION(GlobalContext);
        
        //
        // Mark us not running anymore.
        //

        GlobalContext->IsIdleDetectionCallbackRunning = FALSE;
    }

    //
    // Release the lock if we are holding it.
    //

    if (AcquiredLock) {
        IT_RELEASE_LOCK(GlobalContext->GlobalLock);
    }

    //
    // Cleanup intermediate snapshot structure if necessary.
    //
    
    ItSpCleanupSystemSnapshot(&CurrentSystemSnapshot);

    DBGPR((ITID,ITSRVD,"IDLE: SrvIdleDetectionCallback(%p)=%d,%d,%d,%d\n",
           GlobalContext,ErrorCode,OrderedToStop,SystemIsIdle,NumTasksRun));

    return;
}

VOID
ItSpInitializeSystemSnapshot (
    PITSRV_SYSTEM_SNAPSHOT SystemSnapshot
    )

/*++

Routine Description:

    This routine initializes a system snapshot structure.

Arguments:

    SystemSnapshot - Pointer to structure.

Return Value:

    None.

--*/

{
    //
    // Initialize the disk performance data array.
    //

    SystemSnapshot->NumPhysicalDisks = 0;
    SystemSnapshot->DiskPerfData = NULL;

    //
    // We don't have any valid data.
    //

    SystemSnapshot->GotLastInputInfo = 0;
    SystemSnapshot->GotSystemPerformanceInfo = 0;
    SystemSnapshot->GotDiskPerformanceInfo = 0;
    SystemSnapshot->GotSystemPowerStatus = 0;
    SystemSnapshot->GotSystemExecutionState = 0;
    SystemSnapshot->GotDisplayPowerStatus = 0;

    SystemSnapshot->SnapshotTime = -1;
}

VOID
ItSpCleanupSystemSnapshot (
    PITSRV_SYSTEM_SNAPSHOT SystemSnapshot
    )

/*++

Routine Description:

    This routine cleans up fields of a system snapshot structure. It
    does not free the structure itself. The structure should have been
    initialized with a call to ItSpCleanupSystemSnapshot.

Arguments:

    SystemSnapshot - Pointer to structure.

Return Value:

    None.

--*/

{
    //
    // If a disk performance data array is allocated free it.
    //
    
    if (SystemSnapshot->DiskPerfData) {
        IT_ASSERT(SystemSnapshot->NumPhysicalDisks);
        IT_FREE(SystemSnapshot->DiskPerfData);
    }
}

DWORD
ItSpCopySystemSnapshot (
    PITSRV_SYSTEM_SNAPSHOT DestSnapshot,
    PITSRV_SYSTEM_SNAPSHOT SourceSnapshot
    )

/*++

Routine Description:

    This routine attempts to copy SourceSnapshot to DestSnapshot. If
    the copy fails, DestSnapshot remains intact.

Arguments:

    DestSnapshot - Pointer to snapshot to be updated.
    
    SourceSnapshot - Pointer to snapshot to copy.

Return Value:

    Win32 error code.

--*/

{
    DWORD ErrorCode;
    ULONG OrgNumDisks;
    PITSRV_DISK_PERFORMANCE_DATA OrgDiskPerfData;
    PITSRV_DISK_PERFORMANCE_DATA NewDiskPerfData;
    ULONG AllocationSize;
    ULONG CopySize;

    //
    // Initialize locals.
    //

    NewDiskPerfData = NULL;

    //
    // Do we have to copy disk performance data?
    //

    if (SourceSnapshot->GotDiskPerformanceInfo) {
        
        //
        // Allocate a new array if the disk performance data won't fit.
        //

        if (SourceSnapshot->NumPhysicalDisks > DestSnapshot->NumPhysicalDisks) {
            
            AllocationSize = SourceSnapshot->NumPhysicalDisks * 
                sizeof(ITSRV_DISK_PERFORMANCE_DATA);

            NewDiskPerfData = IT_ALLOC(AllocationSize);
            
            if (!NewDiskPerfData) {
                ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
                goto cleanup;
            }
        }    
    }
    
    //
    // Beyond this point we should not fail because we modify
    // DestSnapshot.
    //

    //
    // Save original disk performance data array.
    //

    OrgDiskPerfData = DestSnapshot->DiskPerfData;
    OrgNumDisks = DestSnapshot->NumPhysicalDisks;

    //
    // Copy the whole structure over and put back original disk
    // performance data array.
    //

    RtlCopyMemory(DestSnapshot,
                  SourceSnapshot,
                  sizeof(ITSRV_SYSTEM_SNAPSHOT));

    DestSnapshot->DiskPerfData = OrgDiskPerfData;
    DestSnapshot->NumPhysicalDisks = OrgNumDisks;

    //
    // Determine if/how we will copy over disk performance data.
    //
    
    if (SourceSnapshot->GotDiskPerformanceInfo) {

        if (SourceSnapshot->NumPhysicalDisks > DestSnapshot->NumPhysicalDisks) {
            
            //
            // Free old array and use the new one we allocated above.
            //
            
            if (DestSnapshot->DiskPerfData) {
                IT_FREE(DestSnapshot->DiskPerfData);
            }

            DestSnapshot->DiskPerfData = NewDiskPerfData;

        } 
        
        if (SourceSnapshot->NumPhysicalDisks == 0) {
            
            //
            // This does not make sense... (They got disk data and
            // there are 0 physical disks in the system?) Yet we go
            // with it and to be consistent, free our data array.
            //
            
            if (DestSnapshot->DiskPerfData) {
                IT_FREE(DestSnapshot->DiskPerfData);
            }
            
            DestSnapshot->DiskPerfData = NULL;
        }

        //
        // Copy over their disk data and update NumPhysicalDisks.
        //

        CopySize = SourceSnapshot->NumPhysicalDisks * 
            sizeof(ITSRV_DISK_PERFORMANCE_DATA);

        RtlCopyMemory(DestSnapshot->DiskPerfData,
                      SourceSnapshot->DiskPerfData,
                      CopySize);
        
        DestSnapshot->NumPhysicalDisks = SourceSnapshot->NumPhysicalDisks;
    }

    //
    // Done.
    //
    
    ErrorCode = ERROR_SUCCESS;
    
 cleanup:

    if (ErrorCode != ERROR_SUCCESS) {
        if (NewDiskPerfData) {
            IT_FREE(NewDiskPerfData);
        }
    }

    DBGPR((ITID,ITSRVDD,"IDLE: SrvCopySnapshot()=%d\n",ErrorCode));

    return ErrorCode;
}

DWORD
ItSpGetSystemSnapshot (
    PITSRV_GLOBAL_CONTEXT GlobalContext,
    PITSRV_SYSTEM_SNAPSHOT SystemSnapshot
    )

/*++

Routine Description:

    This routine fills input system snapshot with data queried from
    various sources. The snapshot structure should have been
    initialized by ItSpInitializeSystemSnapshot. The output
    SystemSnapshot can be passed back in.

Arguments:

    GlobalContext - Pointer to idle detection context.

    SystemSnapshot - Pointer to structure to fill.

Return Value:

    Win32 error code.

--*/

{
    DWORD ErrorCode;
    NTSTATUS Status;

    //
    // Query disk performance counters.
    //

    if (GlobalContext->DiskPerfWmiHandle) {

        ErrorCode = ItSpGetWmiDiskPerformanceData(GlobalContext->DiskPerfWmiHandle,
                                                  &SystemSnapshot->DiskPerfData,
                                                  &SystemSnapshot->NumPhysicalDisks,
                                                  &GlobalContext->WmiQueryBuffer,
                                                  &GlobalContext->WmiQueryBufferSize);
        
        if (ErrorCode == ERROR_SUCCESS) {

            SystemSnapshot->GotDiskPerformanceInfo = TRUE;

        } else {
            
            SystemSnapshot->GotDiskPerformanceInfo = FALSE;
        }

    } else {
        
        SystemSnapshot->GotDiskPerformanceInfo = FALSE;
    }

    //
    // Get system performance information.
    //

    Status = NtQuerySystemInformation(SystemPerformanceInformation,
                                      &SystemSnapshot->SystemPerformanceInfo,
                                      sizeof(SYSTEM_PERFORMANCE_INFORMATION),
                                      NULL);

    if (NT_SUCCESS(Status)) {
        
        SystemSnapshot->GotSystemPerformanceInfo = TRUE;

    } else {

        SystemSnapshot->GotSystemPerformanceInfo = FALSE;
    }

    //
    // Get last input time.
    //

    SystemSnapshot->LastInputInfo.cbSize = sizeof(LASTINPUTINFO);

    ErrorCode = ItSpGetLastInputInfo(&SystemSnapshot->LastInputInfo);

    if (ErrorCode == ERROR_SUCCESS) {

        SystemSnapshot->GotLastInputInfo = TRUE;

    } else {
        
        SystemSnapshot->GotLastInputInfo = FALSE;
    }

    //
    // Get system power status to determine if we are running on
    // battery etc.
    //

    if (GetSystemPowerStatus(&SystemSnapshot->SystemPowerStatus)) {
        
        SystemSnapshot->GotSystemPowerStatus = TRUE;
        
    } else {

        SystemSnapshot->GotSystemPowerStatus = FALSE;
    }   

    //
    // Get system power information to see if the system is close to
    // entering standby or hibernate automatically.
    //   

    Status = NtPowerInformation(SystemPowerInformation,
                                NULL,
                                0,
                                &SystemSnapshot->PowerInfo,
                                sizeof(SYSTEM_POWER_INFORMATION));

    if (NT_SUCCESS(Status)) {

        SystemSnapshot->GotSystemPowerInfo = TRUE;

    } else {

        SystemSnapshot->GotSystemPowerInfo = FALSE;
    }

    //
    // Get system execution state to determine if somebody's running a
    // presentation, burning a cd etc.
    //

    Status = NtPowerInformation(SystemExecutionState,
                                NULL,                
                                0,                   
                                &SystemSnapshot->ExecutionState,              
                                sizeof(EXECUTION_STATE));  
    
    if (NT_SUCCESS(Status)) {
        
        SystemSnapshot->GotSystemExecutionState = TRUE;

    } else {

        SystemSnapshot->GotSystemExecutionState = FALSE; 
    }

    //
    // Get display power status.
    //

    ErrorCode = ItSpGetDisplayPowerStatus(&SystemSnapshot->ScreenSaverIsRunning);
    
    if (ErrorCode == ERROR_SUCCESS) {

        SystemSnapshot->GotDisplayPowerStatus = TRUE;

    } else {

        SystemSnapshot->GotDisplayPowerStatus = FALSE;

    }

    //
    // Fill in the time when this snapshot was taken as the last thing
    // to be conservative. This function may have taken long, and the
    // values we snapshoted may have changed by now.
    //
    
    SystemSnapshot->SnapshotTime = GetTickCount();

    DBGPR((ITID,ITSRVDD,"IDLE: SrvGetSnapshot()=%d,%d,%d\n",
           (ULONG) SystemSnapshot->GotLastInputInfo,
           (ULONG) SystemSnapshot->GotSystemPerformanceInfo,
           (ULONG) SystemSnapshot->GotDiskPerformanceInfo));

    return ERROR_SUCCESS;
}

BOOLEAN
ItSpIsSystemIdle (
    PITSRV_GLOBAL_CONTEXT GlobalContext,
    PITSRV_SYSTEM_SNAPSHOT CurrentSnapshot,
    PITSRV_SYSTEM_SNAPSHOT LastSnapshot,
    ITSRV_IDLE_CHECK_REASON IdleCheckReason
    )

/*++

Routine Description:

    This routine compares two snapshots to determine if the system has
    been idle between them.

    This function acts very conservatively in saying that the system
    is idle.

Arguments:

    GlobalContext - Pointer to server context structure.

    CurrentSnapshot - Pointer to system snapshot.
    
    LastSnapshot - Pointer to system snapshot taken before
      CurrentSnapshot.
      
    IdleCheckReason - Where this function is being called from. We may
      do things differently when we get called to do the initial check
      to see if the system idle, or to verify it is really idle, or to
      make sure the idle task we started is still running and is not
      stuck.

Return Value:

    TRUE - System was idle between the two snapshots.
    
    FALSE - The system was not idle between two snapshots.

--*/

{
    DWORD SnapshotTimeDifference;
    BOOLEAN SystemIsIdle;
    LARGE_INTEGER IdleProcessRunTime;
    ULONG CpuIdlePercentage;
    ULONG DiskIdx;
    ULONG DiskIdleTimeDifference;
    ULONG DiskIdlePercentage;
    PIT_IDLE_DETECTION_PARAMETERS Parameters;

    //
    // Initialize locals.
    //
    
    Parameters = &GlobalContext->Parameters;
    SystemIsIdle = FALSE;
    SnapshotTimeDifference = CurrentSnapshot->SnapshotTime - 
                             LastSnapshot->SnapshotTime;
    
    //
    // Verify parameters.
    //
    
    IT_ASSERT(IdleCheckReason < ItSrvMaxIdleCheckReason);

    //
    // If system tick count wrapped or they are passing in bogus
    // times, or the snapshots seem to be taken nearly at the same
    // time, say the system is not idle to avoid any weird issues.
    //
    
    if (CurrentSnapshot->SnapshotTime <= LastSnapshot->SnapshotTime) {
        goto cleanup;
    }

    IT_ASSERT(SnapshotTimeDifference);

    //
    // If either snapshot does not have last user input (mouse or
    // keyboard) info, we cannot reliably say the system was idle.
    //

    if (!CurrentSnapshot->GotLastInputInfo ||
        !LastSnapshot->GotLastInputInfo) {
        goto cleanup;
    }

    //
    // If there has been user input between the two snapshots, the
    // system was not idle. We don't care when the user input
    // happened (e.g. right after the last snapshot).
    //

    DBGPR((ITID,ITSNAP,"IDLE: UserInput: Last %u Current %u\n", 
           LastSnapshot->LastInputInfo.dwTime,
           CurrentSnapshot->LastInputInfo.dwTime));

    if (LastSnapshot->LastInputInfo.dwTime != 
        CurrentSnapshot->LastInputInfo.dwTime) {
        goto cleanup;
    }

    //
    // If we are running on battery, don't run idle tasks.
    //
    
    if (CurrentSnapshot->GotSystemPowerStatus) {
        if (CurrentSnapshot->SystemPowerStatus.ACLineStatus == 0) {
            DBGPR((ITID,ITSNAP,"IDLE: Snapshot: Running on battery\n"));
            goto cleanup;
        }
    }

    //
    // If system will automatically enter standby or hibernate soon
    // it is too late for us to run our tasks.
    //

    if (CurrentSnapshot->GotSystemPowerInfo) {
        if (CurrentSnapshot->PowerInfo.TimeRemaining < IT_DEFAULT_MAX_TIME_REMAINING_TO_SLEEP) {
            DBGPR((ITID,ITSNAP,"IDLE: Snapshot: System will standby / hibernate soon\n"));
            goto cleanup;
        }
    }

    //
    // If the screen saver is running, assume the system is
    // idle. Otherwise, if a heavy-weight OpenGL screen saver is
    // running our CPU checks may bail us out of realizing that the
    // system is idle. We skip this check when trying to determine an
    // idle task is stuck or if it is really running. Note that the
    // screen saver activity may make us think the idle task is still
    // running, even if it is stuck.
    //

    if (IdleCheckReason != ItSrvIdleTaskRunningCheck) {
        if (CurrentSnapshot->GotDisplayPowerStatus) {
            if (CurrentSnapshot->ScreenSaverIsRunning) {
                
                DBGPR((ITID,ITSNAP,"IDLE: Snapshot: ScreenSaverRunning\n"));
                SystemIsIdle = TRUE;
                goto cleanup;
            }
        }
    }

    //
    // If system may look idle but somebody's running a powerpoint
    // presentation, watching hardware-decoded DVD etc don't run idle
    // tasks. Note that we do not check for ES_SYSTEM_REQUIRED, since
    // it is set by fax servers, answering machines and such as well.
    // ES_DISPLAY_REQUIRED is the one supposed to be used by
    // multimedia/presentation applications.
    //

    if (CurrentSnapshot->GotSystemExecutionState) {
        if ((CurrentSnapshot->ExecutionState & ES_DISPLAY_REQUIRED)) {

            DBGPR((ITID,ITSNAP,"IDLE: Snapshot: Execution state:%x\n",CurrentSnapshot->ExecutionState));
            goto cleanup;
        }
    }

    //
    // We definitely want CPU & general system performance data as
    // well.
    //

    if (!CurrentSnapshot->GotSystemPerformanceInfo ||
        !LastSnapshot->GotSystemPerformanceInfo) {
        goto cleanup;
    }

    //
    // Calculate how many ms the idle process ran. The IdleProcessTime
    // on system performance information structures is in 100ns. To
    // convert it to ms we divide by (10 * 1000).
    //
    
    IdleProcessRunTime.QuadPart = 
        (CurrentSnapshot->SystemPerformanceInfo.IdleProcessTime.QuadPart - 
         LastSnapshot->SystemPerformanceInfo.IdleProcessTime.QuadPart);

    IdleProcessRunTime.QuadPart = IdleProcessRunTime.QuadPart / 10000;
    
    //
    // Adjust it for the number of CPUs in the system. 
    //
    
    IT_ASSERT(GlobalContext->NumProcessors);

    if (GlobalContext->NumProcessors) {
        IdleProcessRunTime.QuadPart = IdleProcessRunTime.QuadPart / GlobalContext->NumProcessors;
    }
    
    //
    // Calculate idle cpu percentage this translates to.
    //

    CpuIdlePercentage = (ULONG) (IdleProcessRunTime.QuadPart * 100 / SnapshotTimeDifference);

    DBGPR((ITID,ITSNAP,"IDLE: Snapshot: CPU %d\n", CpuIdlePercentage));

    if (CpuIdlePercentage < Parameters->MinCpuIdlePercentage) {
        goto cleanup;
    }

    //
    // We may not have disk performance data because WMI thingies were
    // not initiated etc.
    //

    if (CurrentSnapshot->GotDiskPerformanceInfo &&
        LastSnapshot->GotDiskPerformanceInfo) {

        //
        // If a new disk was added / removed since last snapshot, say
        // the system is not idle.
        //

        if (CurrentSnapshot->NumPhysicalDisks != 
            LastSnapshot->NumPhysicalDisks) {
            goto cleanup;
        }

        //
        // We assume that the disk data is in the same order in both
        // snapshots. If the ordering of disks changed etc, it will
        // most likely cause us to say the system is not idle. It may
        // cause us to ignore some real activity with very low
        // possibility. That is why we verify several times when we
        // see system idle.
        //
        
        for (DiskIdx = 0; 
             DiskIdx < CurrentSnapshot->NumPhysicalDisks;
             DiskIdx++) {
            
            DiskIdleTimeDifference = 
                CurrentSnapshot->DiskPerfData[DiskIdx].DiskIdleTime -
                LastSnapshot->DiskPerfData[DiskIdx].DiskIdleTime;
            
            DiskIdlePercentage = (DiskIdleTimeDifference  * 100) /
                                 SnapshotTimeDifference;
            
            DBGPR((ITID,ITSNAP,"IDLE: Snapshot: Disk %d:%d\n",
                   DiskIdx, DiskIdlePercentage));
            
            if (DiskIdlePercentage < Parameters->MinDiskIdlePercentage) {
                goto cleanup;
            }
        }
    }

    //
    // We passed all the checks.
    //

    SystemIsIdle = TRUE;

 cleanup:

    DBGPR((ITID,ITSRVDD,"IDLE: SrvIsSystemIdle()=%d\n",(ULONG)SystemIsIdle));
    
    return SystemIsIdle;
}

DWORD
ItSpGetLastInputInfo (
    PLASTINPUTINFO LastInputInfo
    )

/*++

Routine Description:

    This function retrieves the time of the last user input event.

Arguments:

    LastInputInfo - Pointer to structure to update.

Return Value:

    Win32 error code.
    
--*/

{
    DWORD ErrorCode;

    //
    // Verify parameter.
    //

    if (LastInputInfo->cbSize != sizeof(LASTINPUTINFO)) {
        ErrorCode = ERROR_BAD_FORMAT;
        goto cleanup;
    }

    //
    // We get the last input info from the shared system page that is
    // updated by all terminal server sessions.
    //

    LastInputInfo->dwTime = USER_SHARED_DATA->LastSystemRITEventTickCount;

#ifdef IT_DBG
    
    //
    // On the checked build, if we are stressing, we will set the detection
    // period below the period with which the system last input time is
    // updated. If it is so, use the Win32 GetLastInputInfo call. This call
    // will get the user input info only for the current session, but when
    // stressing this is OK.
    //

    if (ItSrvGlobalContext->Parameters.IdleDetectionPeriod < 60*1000) {

        if (!GetLastInputInfo(LastInputInfo)) {
            ErrorCode = GetLastError();
            goto cleanup;
        }
    }

#endif // IT_DBG

    ErrorCode = ERROR_SUCCESS;

cleanup:

    return ErrorCode;
}

BOOLEAN
ItSpIsPhysicalDrive (
    PDISK_PERFORMANCE DiskPerformanceData
    ) 

/*++

Routine Description:

    This function attempts to determine if the specified disk is a
    logical or physical disk.

Arguments:

    DiskPerformanceData - Pointer to disk performance data for the disk.

Return Value:

    TRUE - The disk is a physical disk.
    
    FALSE - The disk is not a physical disk.

--*/

{
    ULONG ComparisonLength;

    //
    // Initialize locals.
    //

    ComparisonLength = 
        sizeof(DiskPerformanceData->StorageManagerName) / sizeof(WCHAR);

    //
    // We have to determine if this is a physical disk or not from the
    // storage manager's name.
    //

    if (!wcsncmp(DiskPerformanceData->StorageManagerName, 
                 L"Partmgr ", 
                 ComparisonLength)) {

        return TRUE;
    }

    if (!wcsncmp(DiskPerformanceData->StorageManagerName, 
                 L"PhysDisk", 
                 ComparisonLength)) {

        return TRUE;
    }
    
    return FALSE;
}

DWORD
ItSpGetWmiDiskPerformanceData(
    IN WMIHANDLE DiskPerfWmiHandle,
    IN OUT PITSRV_DISK_PERFORMANCE_DATA *DiskPerfData,
    IN OUT ULONG *NumPhysicalDisks,
    OPTIONAL IN OUT PVOID *InputQueryBuffer,
    OPTIONAL IN OUT ULONG *InputQueryBufferSize
    )

/*++

Routine Description:

    This function queries disk performance counters and updates input
    parameters.

Arguments:

    DiskPerfWmiHandle - WMI handle to DiskPerf.   

    DiskPerfData - This array is updated with data from all registered
      physical disks' WMI performance data blocks. If it is not big
      enough, it is freed and reallocated using IT_FREE/IT_ALLOC.
      
    NumPhysicalDisks - This is the size of DiskPerfData array on
      input. If the number of registered physical disks change, it is
      updated on return.

    InputQueryBuffer, InputQueryBufferSize - If specified, they describe a
      query buffer to be used and updated when querying WMI. The
      buffer must be allocated with IT_ALLOC. The returned buffer may
      be relocated/resized and should be freed with IT_FREE. The
      buffer's contents on input and output are trash.

Return Value:

    Win32 error code.

--*/

{
    DWORD ErrorCode;
    PVOID QueryBuffer;
    ULONG QueryBufferSize;
    ULONG RequiredSize;
    ULONG NumTries;
    PWNODE_ALL_DATA DiskWmiDataCursor;
    PDISK_PERFORMANCE DiskPerformanceData;
    LARGE_INTEGER PerformanceCounterFrequency;
    BOOLEAN UsingInputBuffer;
    ULONG NumDiskData;
    PITSRV_DISK_PERFORMANCE_DATA NewDataBuffer;

    //
    // Initialize locals.
    //

    QueryBuffer = NULL;
    QueryBufferSize = 0;
    UsingInputBuffer = FALSE;
    NewDataBuffer = NULL;

    //
    // Determine if we will be using the query buffer input by the
    // user. In case we are using them it is crucial that QueryBuffer
    // and QueryBufferSize are not set to bogus values during the
    // function.
    //

    if (InputQueryBuffer && InputQueryBufferSize) {
        UsingInputBuffer = TRUE;
        QueryBuffer = *InputQueryBuffer;
        QueryBufferSize = *InputQueryBufferSize;
    }
    
    //
    // Query disk performance data.
    //
    
    NumTries = 0;

    do {
        
        RequiredSize = QueryBufferSize;

        __try {

            ErrorCode = WmiQueryAllData(DiskPerfWmiHandle,
                                     &RequiredSize,
                                     QueryBuffer);

        } __except (EXCEPTION_EXECUTE_HANDLER) {

            //
            // There is something wrong if we got an exception.
            //

            ErrorCode = GetExceptionCode();
            
            if (ErrorCode == ERROR_SUCCESS) {
                ErrorCode = ERROR_INVALID_FUNCTION;
            }
            
            goto cleanup;
        }
            
        if (ErrorCode == ERROR_SUCCESS) {
            
            //
            // We got the data.
            //
            
            break;
        }

        //
        // Check to see if we failed for a real reason other than that
        // our input buffer was too small.
        //

        if (ErrorCode != ERROR_INSUFFICIENT_BUFFER) {
            goto cleanup;
        }
        
        //
        // Reallocate the buffer to the required size.
        //

        if (QueryBufferSize) {
            IT_FREE(QueryBuffer);
            QueryBufferSize = 0;
        }

        QueryBuffer = IT_ALLOC(RequiredSize);

        if (!QueryBuffer) {
            ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }

        QueryBufferSize = RequiredSize;
        
        //
        // Don't loop forever...
        //
        
        NumTries++;

        if (NumTries >= 1000) {
            ErrorCode = ERROR_INVALID_FUNCTION;
            goto cleanup;
        }

    } while (TRUE);

    //
    // We have gotten WMI disk performance data. Verify it makes sense.
    //

    DiskWmiDataCursor = QueryBuffer;

    if (DiskWmiDataCursor->WnodeHeader.BufferSize < sizeof(WNODE_ALL_DATA)) {
        IT_ASSERT(FALSE);
        ErrorCode = ERROR_BAD_FORMAT;
        goto cleanup;
    }
    
    if (DiskWmiDataCursor->InstanceCount == 0) {
        
        //
        // There are no disks?
        //

        ErrorCode = ERROR_BAD_FORMAT;
        goto cleanup;
    }

    //
    // Determine the number of disks we have data for.
    //

    NumDiskData = 0;

    do {
        
        DiskPerformanceData = (PDISK_PERFORMANCE) 
            ((PUCHAR) DiskWmiDataCursor + DiskWmiDataCursor->DataBlockOffset);
        
        //
        // Count only physical disk data. Otherwise we will double
        // count disk I/Os for logical disks on the physical disk.
        //

        if (ItSpIsPhysicalDrive(DiskPerformanceData)) {
            NumDiskData++;
        }
        
        if (DiskWmiDataCursor->WnodeHeader.Linkage == 0) {
            break;
        }

        DiskWmiDataCursor = (PWNODE_ALL_DATA) 
            ((LPBYTE)DiskWmiDataCursor + DiskWmiDataCursor->WnodeHeader.Linkage);

    } while (TRUE);

    //
    // Do we have enough space in the input buffer?
    //

    if (NumDiskData > *NumPhysicalDisks) {
        
        NewDataBuffer = IT_ALLOC(NumDiskData *
                                 sizeof(ITSRV_DISK_PERFORMANCE_DATA));

        if (!NewDataBuffer) {
            ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }

        //
        // Update old buffer & its max size.
        //
        
        if (*DiskPerfData) {
            IT_FREE(*DiskPerfData);
        }

        *DiskPerfData = NewDataBuffer;
        *NumPhysicalDisks = NumDiskData;
    }

    //
    // Reset cursor and walk through the WMI data copying into the
    // target buffer.
    //

    DiskWmiDataCursor = QueryBuffer;
    *NumPhysicalDisks = 0;

    do {
        
        DiskPerformanceData = (PDISK_PERFORMANCE) 
            ((PUCHAR) DiskWmiDataCursor + DiskWmiDataCursor->DataBlockOffset);
        
        //
        // Count only physical disk data. Otherwise we will double
        // count disk I/Os for logical disks on the physical disk.
        //

        if (ItSpIsPhysicalDrive(DiskPerformanceData)) {
            
            if (*NumPhysicalDisks >= NumDiskData) {
                
                //
                // We calculated this above. Did the data change
                // beneath our feet?
                //

                IT_ASSERT(FALSE);
                ErrorCode = ERROR_INVALID_FUNCTION;
                goto cleanup;
            }
            
            //
            // Convert idle time in 100ns to ms.
            //

            (*DiskPerfData)[*NumPhysicalDisks].DiskIdleTime = 
                (ULONG) (DiskPerformanceData->IdleTime.QuadPart / 10000);
            
            (*NumPhysicalDisks)++;
        }
        
        if (DiskWmiDataCursor->WnodeHeader.Linkage == 0) {
            break;
        }

        DiskWmiDataCursor = (PWNODE_ALL_DATA) 
            ((LPBYTE)DiskWmiDataCursor + DiskWmiDataCursor->WnodeHeader.Linkage);

    } while (TRUE);

    IT_ASSERT(*NumPhysicalDisks == NumDiskData);

    ErrorCode = ERROR_SUCCESS;
    
 cleanup:

    if (UsingInputBuffer) {

        //
        // Update the callers query buffer info.
        //

        *InputQueryBuffer = QueryBuffer;
        *InputQueryBufferSize = QueryBufferSize;

    } else {

        //
        // Free temporary buffer.
        //

        if (QueryBuffer) {
            IT_FREE(QueryBuffer);
        }
    }

    if (ErrorCode != ERROR_SUCCESS) {
        if (NewDataBuffer) {
            IT_FREE(NewDataBuffer);
        }
    }

    DBGPR((ITID,ITSRVDD,"IDLE: SrvGetDiskData()=%d\n",ErrorCode));

    return ErrorCode;
}

DWORD
ItSpGetDisplayPowerStatus(
    PBOOL ScreenSaverIsRunning
    )

/*++

Routine Description:

    This routine determines power status of the default display.

Arguments:

    ScreenSaverIsRunning - Whether a screen saver is running is
      returned here.

Return Value:

    Win32 error code.

--*/  

{
    DWORD ErrorCode;
    
    //
    // Determine whether the screen saver is running.
    //

    if (!SystemParametersInfo(SPI_GETSCREENSAVERRUNNING,
                              0,
                              ScreenSaverIsRunning,
                              0)) {

        ErrorCode = GetLastError();
        goto cleanup;
    }

    ErrorCode = ERROR_SUCCESS;
    
 cleanup:

    return ErrorCode;
}

//
// Reference count implementation:
//

VOID
ItSpInitializeRefCount(
    PITSRV_REFCOUNT RefCount
    )

/*++

Routine Description:

    This routine initializes a reference count structure.

Arguments:

    RefCount - Pointer to reference count structure.
    
Return Value:

    None.

--*/   

{
    //
    // Start reference count from 1. When somebody wants to gain
    // exclusive access they decrement it one extra so it may become
    // 0.
    //
    
    RefCount->RefCount = 1;

    //
    // Nobody has exclusive access to start with. 
    //

    RefCount->Exclusive = 0;
    RefCount->ExclusiveOwner = 0;
}

DWORD
FASTCALL
ItSpAddRef(
    PITSRV_REFCOUNT RefCount
    )

/*++

Routine Description:

    This routine tries to bump the reference count if it has not been
    acquired exclusive.

Arguments:

    RefCount - Pointer to reference count structure.
    
Return Value:

    Status.

--*/   

{
    //
    // Do a fast check if the lock was acquire exclusive. If so just
    // return.
    //
    
    if (RefCount->Exclusive) {
        return ERROR_ACCESS_DENIED;
    }

    //
    // Bump the reference count.
    //

    InterlockedIncrement(&RefCount->RefCount);
    
    //
    // If it was acquired exclusive, pull back.
    //

    if (RefCount->Exclusive) {
        
        InterlockedDecrement(&RefCount->RefCount);

        //
        // Reference count should never go negative.
        //
        
        IT_ASSERT(RefCount->RefCount >= 0);
                
        return ERROR_ACCESS_DENIED;

    } else {

        //
        // We got our reference.
        //

        return ERROR_SUCCESS;
    }  
}

VOID
FASTCALL
ItSpDecRef(
    PITSRV_REFCOUNT RefCount
    )

/*++

Routine Description:

    This routine decrements the reference count. 

Arguments:

    RefCount - Pointer to reference count structure.
    
Return Value:

    None.

--*/   

{
    //
    // Decrement the reference count.
    //

    InterlockedDecrement(&RefCount->RefCount);   

    //
    // Reference count should never go negative.
    //

    IT_ASSERT(RefCount->RefCount >= 0);
}

DWORD
ItSpAcquireExclusiveRef(
    PITSRV_REFCOUNT RefCount
    )

/*++

Routine Description:

    This routine attempts to get exclusive reference. If there is
    already an exclusive reference, it fails. Othwerwise it waits for
    all normal references to go away.

Arguments:

    RefCount - Pointer to reference count structure.
    
Return Value:

    Status.

--*/   

{
    LONG OldValue;

    //
    // Try to get exclusive access by setting Exclusive from 0 to 1.
    //

    OldValue = InterlockedCompareExchange(&RefCount->Exclusive, 1, 0);

    if (OldValue != 0) {

        //
        // Somebody already had the lock.
        //
        
        return ERROR_ACCESS_DENIED;
    }

    //
    // Decrement the reference count once so it may become 0.
    //

    InterlockedDecrement(&RefCount->RefCount);

    //
    // No new references will be given away. We poll until existing
    // references are released.
    //

    do {

        if (RefCount->RefCount == 0) {

            break;

        } else {

            //
            // Sleep for a while.
            //

            Sleep(50);
        }

    } while(TRUE);

    //
    // We have exclusive access now. Note that we are the exclusive
    // owner.
    //
    
    RefCount->ExclusiveOwner = GetCurrentThread();

    return ERROR_SUCCESS;
}

BOOL
ItSpSetProcessIdleTasksNotifyRoutine (
    PIT_PROCESS_IDLE_TASKS_NOTIFY_ROUTINE NotifyRoutine
    )

/*++

Routine Description:

    This routine is called by an internal component (prefetcher) to set a 
    notification routine that will get called if processing of all idle
    tasks are requested. The routine should be set once, and it cannot be
    removed.

Arguments:

    NotifyRoutine - Routine to be called. This routine will be called 
      and has to return before we start launching queued idle tasks. 
    
Return Value:

    Success.

--*/   

{
    BOOL Success;

    if (!ItSrvGlobalContext->ProcessIdleTasksNotifyRoutine) {
        ItSrvGlobalContext->ProcessIdleTasksNotifyRoutine = NotifyRoutine;
    }
    
    return (ItSrvGlobalContext->ProcessIdleTasksNotifyRoutine == NotifyRoutine);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\idletask\test\conidle\conidle.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    conidle.c

Abstract:

    This module builds a console test program to stress idle
    detection, and registration/unregistration mechanisms.

    The quality of the code for the test programs is as such.

Author:

    Cenk Ergan (cenke)

Environment:

    User Mode

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wmium.h>
#include <ntdddisk.h>
#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include "idlrpc.h"
#include "idlecomn.h"

//
// Note that the following code is test quality code.
//

DWORD
RegisterIdleTask (
    IN IT_IDLE_TASK_ID IdleTaskId,
    OUT HANDLE *ItHandle,
    OUT HANDLE *StartEvent,
    OUT HANDLE *StopEvent
    );

DWORD
UnregisterIdleTask (
    IN HANDLE ItHandle,
    IN HANDLE StartEvent,
    IN HANDLE StopEvent
    );

DWORD
ProcessIdleTasks (
    VOID
    );

#define NUM_TEST_TASKS 3

typedef enum _WORKTYPE {
    CpuWork,
    DiskWork,
    MaxWorkType
} WORKTYPE, *PWORKTYPE;

typedef struct _TESTTASK {
    HANDLE ThreadHandle;
    ULONG No;
    IT_IDLE_TASK_ID Id;
    IT_HANDLE ItHandle;
    HANDLE StartEvent;
    HANDLE StopEvent;
} TESTTASK, *PTESTTASK;

typedef struct _TESTWORK {
    ULONG No;
    WORKTYPE Type;
    DWORD WorkLength;
    HANDLE StopEvent;
} TESTWORK, *PTESTWORK;

TESTTASK g_Tasks[NUM_TEST_TASKS];

BOOLEAN g_ProcessingIdleTasks = FALSE;
HANDLE g_ProcessedIdleTasksEvent = NULL;

#define MAX_WAIT_FOR_START      20000
#define MAX_WORK_LENGTH          5000
#define MAX_READ_SIZE     (64 * 1024)

DWORD
WINAPI
DoWorkThreadProc(
    LPVOID lpParameter
    )
{
    PTESTWORK Work;
    DWORD EndTime;
    DWORD WaitResult;
    DWORD ErrorCode;
    DWORD RunTillTime;
    HANDLE DiskHandle;
    PVOID ReadBuffer;
    BOOL ReadResult;
    ULONG NumBytesRead;
    LARGE_INTEGER VolumeSize;
    LARGE_INTEGER SeekPosition;
    ULONG ReadIdx;
    DISK_GEOMETRY DiskGeometry;
    ULONG BytesReturned;
    static LONG DiskNumber;

    //
    // Initialize locals.
    //
    
    Work = lpParameter;
    EndTime = GetTickCount() + Work->WorkLength;
    DiskHandle = NULL;
    ReadBuffer = NULL;

    //
    // Do initialization for performing specified work.
    //
    
    switch (Work->Type) {
    case DiskWork:

        //
        // Open disk. Maybe we could open different physical drives
        // each time.
        //

        DiskHandle = CreateFile(L"\\\\.\\PHYSICALDRIVE0",
                                GENERIC_READ,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                NULL,
                                OPEN_EXISTING,
                                FILE_FLAG_NO_BUFFERING,
                                0);
    
        if (!DiskHandle) {
            ErrorCode = GetLastError();
            printf("W%d: Failed open PHYSICALDRIVE0.\n", Work->No);
            goto cleanup;
        }
    
        //
        // Get volume size.
        //
    
        if (!DeviceIoControl(DiskHandle,
                             IOCTL_DISK_GET_DRIVE_GEOMETRY,
                             NULL,
                             0,
                             &DiskGeometry,
                             sizeof(DiskGeometry),
                             &BytesReturned,
                             NULL)) {

            ErrorCode = GetLastError();
            printf("W%d: Failed GET_DRIVE_GEOMETRY.\n", Work->No);
            goto cleanup;
        }

        VolumeSize.QuadPart = DiskGeometry.Cylinders.QuadPart *
            DiskGeometry.TracksPerCylinder *
            DiskGeometry.SectorsPerTrack *
            DiskGeometry.BytesPerSector;

        //
        // Allocate buffer.
        //

        ReadBuffer = VirtualAlloc(NULL,
                                  MAX_READ_SIZE,
                                  MEM_COMMIT,
                                  PAGE_READWRITE);
    
        if (!ReadBuffer) {
            ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
            printf("W%d: Failed VirtualAlloc.\n", Work->No);
            goto cleanup;
        }

        break;

    default:
        
        //
        // Nothing to prepare.
        //
        
        break;
    }
    
    while (GetTickCount() < EndTime) {
        
        //
        // Check if we are asked to stop.
        //

        WaitResult = WaitForSingleObject(Work->StopEvent, 0);
        if (WaitResult == WAIT_OBJECT_0) {
            ErrorCode = ERROR_SUCCESS;
            goto cleanup;
        }

        //
        // Do a unit of work that should not take more than several
        // tens of milliseconds.
        //
        
        switch (Work->Type) {

        case CpuWork:
            
            RunTillTime = GetTickCount() + 10;
            
            while (GetTickCount() < RunTillTime) ;
            
            break;

        case DiskWork:

            //
            // Seek to random position.
            //

            SeekPosition.QuadPart = rand() * 4 * 1024;
            SeekPosition.QuadPart %= VolumeSize.QuadPart;

            if (!SetFilePointerEx(DiskHandle,
                                  SeekPosition,
                                  NULL,
                                  FILE_BEGIN)) {

                printf("W%d: Failed SetFilePointerEx.\n", Work->No);
                ErrorCode = GetLastError();
                goto cleanup;
            }

            //
            // Issue read.
            //

            ReadResult = ReadFile(DiskHandle,
                                  ReadBuffer,
                                  MAX_READ_SIZE,
                                  &NumBytesRead,
                                  NULL);

            if (!ReadResult) {
                printf("W%d: Failed ReadFile.\n", Work->No);
                ErrorCode = GetLastError();
                goto cleanup;
            }

            break;

        default:
            
            printf("W%d: Not valid work type %d!\n", Work->No, Work->Type);
            ErrorCode = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }
    
    ErrorCode = ERROR_SUCCESS;

 cleanup:
    
    if (DiskHandle) {
        CloseHandle(DiskHandle);
    }
    
    if (ReadBuffer) {
        VirtualFree(ReadBuffer, 0, MEM_RELEASE);
    }

    printf("W%d: Exiting with error code: %d\n", Work->No, ErrorCode);

    return ErrorCode;
}

DWORD 
WINAPI 
TaskThreadProc(
    LPVOID lpParameter
    )
{
    PTESTTASK Task = lpParameter;
    TESTWORK Work;
    DWORD ErrorCode;
    WORKTYPE Type;
    DWORD WaitResult;
    DWORD WaitForStart;
    HANDLE WorkerThreadHandle;
    DWORD WorkLength;
    HANDLE Events[2];
    DWORD ElapsedTime;
    DWORD StartTime;
    ULONG TryIdx;
    BOOLEAN RegisteredIdleTask;

    //
    // Initialize locals.
    //

    RegisteredIdleTask = FALSE;
    WorkerThreadHandle = NULL;
    RtlZeroMemory(&Work, sizeof(Work));

    //
    // Initialize work structure.
    //

    Work.StopEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (!Work.StopEvent) {
        goto cleanup;
    }
    
    Work.No = Task->No;

    //
    // Loop registering, running, unregistering idle tasks.
    //

    while (TRUE) {

        //
        // If we are force-processing all tasks, usually wait for all tasks
        // to complete before queueing a new task.
        //

        if (g_ProcessingIdleTasks) {

            if ((rand() % 3) != 0) {

                printf("%d: Waiting for g_ProcessedIdleTasksEvent\n", Task->No);

                WaitResult = WaitForSingleObject(g_ProcessedIdleTasksEvent, INFINITE);

                if (WaitResult != WAIT_OBJECT_0) {
                    ErrorCode = GetLastError();
                    printf("%d: Failed wait for g_ProcessedIdleTasksEvent=%x\n", Task->No, ErrorCode);
                    goto cleanup;
                }
            }
        }
        
        //
        // Register the idle task.
        //

        ErrorCode = RegisterIdleTask(Task->Id,
                                     &Task->ItHandle,
                                     &Task->StartEvent,
                                     &Task->StopEvent);

        if (ErrorCode != ERROR_SUCCESS) {
            printf("%d: Could not register: %d\n", Task->No, ErrorCode);
            goto cleanup;
        }

        RegisteredIdleTask = TRUE;
        
        //
        // Determine task parameters. 
        //
        
        Type = rand() % MaxWorkType;
        WaitForStart = rand() % MAX_WAIT_FOR_START;
        WorkLength = rand() % MAX_WORK_LENGTH;

        //
        // Update work item.
        //

        Work.Type = Type;
        Work.WorkLength = WorkLength;
        
        printf("%d: NewTask Type=%d,WStart=%d,Length=%d,Handle=%p\n", 
               Task->No, Type, WaitForStart, WorkLength, Task->ItHandle);

        do {

            //
            // Wait to be signaled.
            //

            printf("%d: Waiting for start\n", Task->No);
        
            WaitResult = WaitForSingleObject(Task->StartEvent, WaitForStart);

            if (WaitResult == WAIT_TIMEOUT) {
                printf("%d: Timed out wait for start. Re-registering\n", Task->No);
                break;
            }
        
            //
            // Spawn the work.
            //

            ResetEvent(Work.StopEvent);

            StartTime = GetTickCount();
        
            WorkerThreadHandle = CreateThread(NULL,
                                              0,
                                              DoWorkThreadProc,
                                              &Work,
                                              0,
                                              NULL);
        
            if (!WorkerThreadHandle) {
                ErrorCode = GetLastError();
                printf("%d: Failed spawn work: %d\n", Task->No, ErrorCode);
                goto cleanup;
            }
        
            //
            // Wait for stop event to be signaled or the work to be
            // completed.
            //

            Events[0] = WorkerThreadHandle;
            Events[1] = Task->StopEvent;

            printf("%d: Waiting for stop or workdone\n", Task->No);
        
            WaitResult = WaitForMultipleObjects(2,
                                                Events,
                                                FALSE,
                                                INFINITE);       
        
            if (WaitResult == WAIT_OBJECT_0) {

                //
                // Break out if the work was done.
                //

                printf("%d: Work done.\n", Task->No);
                
                CloseHandle(WorkerThreadHandle);
                WorkerThreadHandle = NULL;

                break;

            } else if (WaitResult == WAIT_OBJECT_0 + 1) {

                //
                // We were told to stop. Signal the worker thread and
                // wait.
                //

                printf("%d: Stopped, Waiting for thread to exit\n", Task->No);
                
                SetEvent(Work.StopEvent);
                WaitForSingleObject(WorkerThreadHandle, INFINITE);
                CloseHandle(WorkerThreadHandle);
                WorkerThreadHandle = NULL;
                
                //
                // This is not really the time we worked (e.g. we may be
                // switched out etc.) We want to keep rolling and this is
                // what we can get easily.
                //
                
                ElapsedTime = GetTickCount() - StartTime;
            
                if (ElapsedTime > Work.WorkLength) {
                    
                    //
                    // We've gone too long with this work. Unregistester
                    // this task and pick another one.
                    //
                    
                    break;
                }
                
                Work.WorkLength -= ElapsedTime;

                //
                // Loop on until we pass enough time with this work.
                //

            } else {

                //
                // There was an error.
                //
                
                ErrorCode = GetLastError();
                printf("%d: WaitForMultipleObjects failed: %d\n", Task->No, ErrorCode);
                goto cleanup;
            }

        } while (TRUE);

        ASSERT(RegisteredIdleTask);

        UnregisterIdleTask(Task->ItHandle,
                           Task->StartEvent,
                           Task->StopEvent);
        
        RegisteredIdleTask = FALSE;
    }

 cleanup:

    if (RegisteredIdleTask) {
        UnregisterIdleTask(Task->ItHandle,
                           Task->StartEvent,
                           Task->StopEvent);
    }

    if (WorkerThreadHandle) {
        SetEvent(Work.StopEvent);
        WaitForSingleObject(WorkerThreadHandle, INFINITE);
        CloseHandle(WorkerThreadHandle);
    }

    if (Work.StopEvent) {
        CloseHandle(Work.StopEvent);
    }

    return ErrorCode;
}

int 
__cdecl 
main(int argc, char* argv[])
{
    DWORD ErrorCode;
    ULONG TaskIdx;
    IT_IDLE_DETECTION_PARAMETERS Parameters;
    PTESTTASK Task;
    INPUT MouseInput;
    ULONG SleepTime;

    //
    // Initialize locals.
    //

    RtlZeroMemory(&MouseInput, sizeof(MouseInput));
    MouseInput.type = INPUT_MOUSE;
    MouseInput.mi.dwFlags = MOUSEEVENTF_MOVE;

    //
    // Initialize globals.
    //

    g_ProcessingIdleTasks = FALSE;
    g_ProcessedIdleTasksEvent = NULL;

    //
    // Initialize random.
    //
    
    srand((unsigned)time(NULL));

    //
    // Create an manual reset event that will be signaled when we finish 
    // processing all tasks after telling the server to process all tasks.
    //

    g_ProcessedIdleTasksEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    if (!g_ProcessedIdleTasksEvent) {
        ErrorCode = GetLastError();
        printf("Failed to create g_ProcessedIdleTasksEvent=%x\n",ErrorCode);
        goto cleanup;
    }

    //
    // Set idle detection parameters for stress.
    //

    Parameters.IdleDetectionPeriod =          1000;
    Parameters.IdleVerificationPeriod =        500;
    Parameters.NumVerifications =                2;
    Parameters.IdleInputCheckPeriod =          100;
    Parameters.IdleTaskRunningCheckPeriod =   1000;
    Parameters.MinCpuIdlePercentage =           50;
    Parameters.MinDiskIdlePercentage =          50;
    Parameters.MaxNumRegisteredTasks =         500;

    RpcTryExcept {

        ErrorCode = ItSrvSetDetectionParameters(NULL, &Parameters);
    }
    RpcExcept(IT_RPC_EXCEPTION_HANDLER()) {

        ErrorCode = RpcExceptionCode();
    }
    RpcEndExcept
    
    if (ErrorCode != ERROR_SUCCESS) {
        printf("Failed set idle detection params for stress.\n");
        goto cleanup;
    }

    //
    // Register and start tasks.
    //

    for (TaskIdx = 0; TaskIdx < NUM_TEST_TASKS; TaskIdx++) {

        Task = &g_Tasks[TaskIdx];

        Task->No = TaskIdx;
        Task->Id = ItOptimalDiskLayoutTaskId;
        
        Task->ThreadHandle = CreateThread(NULL,
                                          0,
                                          TaskThreadProc,
                                          &g_Tasks[TaskIdx],
                                          0,
                                          0);
        
        if (!Task->ThreadHandle) {
            ErrorCode = GetLastError();
            printf("Could not spawn task %d: %x\n", TaskIdx, ErrorCode);    
            goto cleanup;
        }

    }   

    //
    // Loop forever sending input messages once in a while to stop
    // idle tasks.
    //

    while (1) {
        
        SleepTime = MAX_WAIT_FOR_START * (rand() % 64) / 64;

        Sleep(SleepTime);

        //
        // Every so often, ask all idle tasks to be processed.
        //
    
        if ((rand() % 2) == 0) {

            if ((rand() % 2) == 0) {
                printf("MainThread: Sending user input before processing all tasks\n");
                SendInput(1, &MouseInput, sizeof(MouseInput));
            }

            printf("MainThread: ProcessIdleTasks()\n");

            ResetEvent(g_ProcessedIdleTasksEvent);
            g_ProcessingIdleTasks = TRUE;
            
            ErrorCode = ProcessIdleTasks();

            printf("MainThread: ProcessIdleTasks()=%x\n",ErrorCode);

            g_ProcessingIdleTasks = FALSE;
            SetEvent(g_ProcessedIdleTasksEvent);

            if (ErrorCode != ERROR_SUCCESS) {
                goto cleanup;
            }
        }

        if ((rand() % 2) == 0) {
            printf("MainThread: Sending user input\n");
            SendInput(1, &MouseInput, sizeof(MouseInput));
        }
    }
    
 cleanup:

    if (g_ProcessedIdleTasksEvent) {
        CloseHandle(g_ProcessedIdleTasksEvent);
    }

    return ErrorCode;
}

/*********************************************************************/
/*                MIDL allocate and free                             */
/*********************************************************************/

void __RPC_FAR * __RPC_USER midl_user_allocate(size_t len)
{
    return(HeapAlloc(GetProcessHeap(),0,(len)));
}

void __RPC_USER midl_user_free(void __RPC_FAR * ptr)
{
    HeapFree(GetProcessHeap(),0,(ptr));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\inc\dllwrap.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       dllwrap.h
//
//  Contents:   Wrappers for functions exported by DLLs that are loaded only
//              when needed.
//
//  Classes:
//
//  Functions:
//
//  History:    07-Oct-96   AnirudhS  Created.
//
//____________________________________________________________________________


#ifndef _DLLWRAP_H_
#define _DLLWRAP_H_

//
// Make this DLL use the wrappers
//
#define CoTaskMemAlloc   WrapCoTaskMemAlloc
#define CoTaskMemRealloc WrapCoTaskMemRealloc
#define CoTaskMemFree    WrapCoTaskMemFree


LPVOID
WrapCoTaskMemAlloc(
    ULONG cb
    );

LPVOID
WrapCoTaskMemRealloc(
    LPVOID pv,
    ULONG cb
    );

void
WrapCoTaskMemFree(
    LPVOID pv
    );


FARPROC
GetProcAddressInModule(
    LPCSTR      pszFunction,
    LPCTSTR     ptszModule
    );


//
// This was a TCHAR export on NT4/Win95, but is now xxxA/xxxW on NT5
// so we wrap it.
//
#ifdef ILCreateFromPath
STDAPI_(LPITEMIDLIST) Wrap_ILCreateFromPath(LPCTSTR pszPath);
#endif

#endif  // _DLLWRAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\idletask\test\itsrv\itsrv.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    itsrv.c

Abstract:

    This module builds a console test program that registers RPC
    interfaces for idle detection and runs as the idle detection server.

    The quality of the code for the test programs is as such.

Author:

    Cenk Ergan (cenke)

Environment:

    User Mode

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include "idlrpc.h"
#include "idlesrv.h"

//
// Note that the following code is test quality code.
//

HANDLE ItTstStopEvent = NULL;

BOOL
ItTstConsoleHandler(DWORD dwControl)
{
    if (ItTstStopEvent) {
        SetEvent(ItTstStopEvent);
    }

    return TRUE;
}

VOID
LogTaskStatus(
    LPCTSTR ptszTaskName,
    LPTSTR  ptszTaskTarget,
    UINT    uMsgID,
    DWORD   dwExitCode
    )
{
    return;
}

int 
__cdecl 
main(int argc, char* argv[])
{
    DWORD ErrorCode;
    DWORD WaitResult;
    BOOLEAN StartedIdleDetectionServer;

    //
    // Initialize locals.
    //
    
    StartedIdleDetectionServer = FALSE;

    //
    // Create the event to be signaled when we should stop.
    //

    ItTstStopEvent = CreateEvent (NULL,
                                  TRUE,
                                  FALSE,
                                  NULL);

    if (ItTstStopEvent == NULL) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    //
    // Specify Control-C handler.
    //

    SetConsoleCtrlHandler(ItTstConsoleHandler, TRUE);

    //
    // Specify which protocol sequences to use. (just LPC)
    //

    ErrorCode = RpcServerUseProtseq(IT_RPC_PROTSEQ,
                                    256,
                                    NULL);

    if (ErrorCode != RPC_S_OK) {
        goto cleanup;
    }

    //
    // Start the idle detection server.
    //

    ErrorCode = ItSrvInitialize();

    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    StartedIdleDetectionServer = TRUE;

    printf("Started idle detection server...\n");

    //
    // Wait for the exit event to be signaled.
    //
    
    WaitResult = WaitForSingleObject(ItTstStopEvent, INFINITE);
    
    if (WaitResult != WAIT_OBJECT_0) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    //
    // We are done.
    //

    ErrorCode = ERROR_SUCCESS;
    
 cleanup:

    if (StartedIdleDetectionServer) {
        ItSrvUninitialize();
    }
    
    if (ItTstStopEvent) {
        CloseHandle(ItTstStopEvent);
    }

    printf("Exiting idle detection server with error code: %d\n", ErrorCode);

    return ErrorCode;
}

/*********************************************************************/
/*                MIDL allocate and free                             */
/*********************************************************************/

void __RPC_FAR * __RPC_USER midl_user_allocate(size_t len)
{
    return(HeapAlloc(GetProcessHeap(),0,(len)));
}

void __RPC_USER midl_user_free(void __RPC_FAR * ptr)
{
    HeapFree(GetProcessHeap(),0,(ptr));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\inc\pbt.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1996
*
*  TITLE:       PBT.H
*
*  VERSION:     1.0
*
*  DATE:        15 Jan 1994
*
*  Definitions for the Virtual Power Management Device.
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  15 Jan 1994 TCS Original implementation.
*
*******************************************************************************/

#ifndef _INC_PBT
#define _INC_PBT

#ifndef WM_POWERBROADCAST
#define WM_POWERBROADCAST               0x218
#endif

#define PBT_APMQUERYSUSPEND             0x0000
#define PBT_APMQUERYSTANDBY             0x0001

#define PBT_APMQUERYSUSPENDFAILED       0x0002
#define PBT_APMQUERYSTANDBYFAILED       0x0003

#define PBT_APMSUSPEND                  0x0004
#define PBT_APMSTANDBY                  0x0005

#define PBT_APMRESUMECRITICAL           0x0006
#define PBT_APMRESUMESUSPEND            0x0007
#define PBT_APMRESUMESTANDBY            0x0008

#define PBTF_APMRESUMEFROMFAILURE       0x00000001

#define PBT_APMBATTERYLOW               0x0009
#define PBT_APMPOWERSTATUSCHANGE        0x000A

#define PBT_APMOEMEVENT                 0x000B

#endif // _INC_PBT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\inc\job-ids.h ===
//+----------------------------------------------------------------------------
//
//  Job Scheduler
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       job-ids.hxx
//
//  Contents:   Property/Dispatch and other Job Scheduler IDs
//
//  History:    23-May-95 EricB created
//
//-----------------------------------------------------------------------------

// oleext.h used to define PROPID_FIRST_NAME_DEFAULT to be 4095; it doesn't
// anymore...
//#include <oleext.h>
#ifndef PROPID_FIRST_NAME_DEFAULT
#define PROPID_FIRST_NAME_DEFAULT   ( 4095 )
#endif

//
// Job object propterty set IDs/Dispatch IDs
//
#define PROPID_JOB_ID                PROPID_FIRST_NAME_DEFAULT
#define PROPID_JOB_Command          (PROPID_FIRST_NAME_DEFAULT + 1)
#define PROPID_JOB_WorkingDir       (PROPID_FIRST_NAME_DEFAULT + 2)
#define PROPID_JOB_EnvironStrs      (PROPID_FIRST_NAME_DEFAULT + 3)
#define PROPID_JOB_OleObjPath       (PROPID_FIRST_NAME_DEFAULT + 4)
#define PROPID_JOB_MethodName       (PROPID_FIRST_NAME_DEFAULT + 5)
#define PROPID_JOB_AccountSID       (PROPID_FIRST_NAME_DEFAULT + 6)
#define PROPID_JOB_Comment          (PROPID_FIRST_NAME_DEFAULT + 7)
#define PROPID_JOB_Priority         (PROPID_FIRST_NAME_DEFAULT + 8)
#define PROPID_JOB_LogCfgChanges    (PROPID_FIRST_NAME_DEFAULT + 9)
#define PROPID_JOB_LogRuns          (PROPID_FIRST_NAME_DEFAULT + 10)
#define PROPID_JOB_Interactive      (PROPID_FIRST_NAME_DEFAULT + 11)
#define PROPID_JOB_NotOnBattery     (PROPID_FIRST_NAME_DEFAULT + 12)
#define PROPID_JOB_NetSchedule      (PROPID_FIRST_NAME_DEFAULT + 13)
#define PROPID_JOB_InQueue          (PROPID_FIRST_NAME_DEFAULT + 14)
#define PROPID_JOB_Suspend          (PROPID_FIRST_NAME_DEFAULT + 15)
#define PROPID_JOB_DeleteWhenDone   (PROPID_FIRST_NAME_DEFAULT + 16)
#define PROPID_JOB_LastRunTime      (PROPID_FIRST_NAME_DEFAULT + 17)
#define PROPID_JOB_NextRunTime      (PROPID_FIRST_NAME_DEFAULT + 18)
#define PROPID_JOB_ExitCode         (PROPID_FIRST_NAME_DEFAULT + 19)
#define PROPID_JOB_Status           (PROPID_FIRST_NAME_DEFAULT + 20)

//
// Job object property set boundary values
//
#define PROPID_JOB_First             PROPID_JOB_ID
#define PROPID_JOB_Last              PROPID_JOB_Status
#define NUM_JOB_PROPS               (PROPID_JOB_Last - PROPID_JOB_First + 1)
#define JOB_PROP_IDX(x)             (x - PROPID_FIRST_NAME_DEFAULT)

//
// Version property set IDs
//
#define PROPID_VERSION_Major		(PROPID_FIRST_NAME_DEFAULT + 100)
#define PROPID_VERSION_Minor		(PROPID_FIRST_NAME_DEFAULT + 101)

//
// Version property set boundary values
//
#define NUM_VERSION_PROPS			2
#define VERSION_PROP_MAJOR			0
#define VERSION_PROP_MINOR			1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\job\guids.cxx ===
//+----------------------------------------------------------------------------
//
//  Job Object Handler
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       guids.cxx
//
//  Contents:   guid allocations - guids are defined in mstask.h
//
//  History:    24-May-95 EricB created
//
//-----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop

//#include <windows.h>

// initguid.h requires this.
//
#include <objbase.h>

// this redefines the DEFINE_GUID() macro to do allocation.
//
#include <initguid.h>

//
// mstask.h contains the GUID
// definitions in DEFINE_GUID macros. initguid.h causes the DEFINE_GUID
// definitions to actually allocate data.
//
#include <mstask.h>
#include <job_cls.hxx>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\idletask\test\winidle\winidle.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    winidle.c

Abstract:

    This module builds a gui test program for the idle detection which
    pops up a window and uses CPU to simulate a running idle task when
    the system becomes idle.

    The test programs are built from the same sources as the original. This
    allows the test program to override parts of the original program to run
    it in a managed environment, and be able to test individual functions. 

    The quality of the code for the test programs is as such.

Author:

    Cenk Ergan (cenke)

Environment:

    User Mode

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wmium.h>
#include <ntdddisk.h>
#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include "idlrpc.h"
#include "idlecomn.h"

//
// This is mostly based on DavidFie's original IdleInfo application.
//

//
// Note that this code is written for a test app, and is of that
// quality.
//

DWORD
RegisterIdleTask (
    IN IT_IDLE_TASK_ID IdleTaskId,
    OUT HANDLE *ItHandle,
    OUT HANDLE *StartEvent,
    OUT HANDLE *StopEvent
    );

DWORD
UnregisterIdleTask (
    IN HANDLE ItHandle,
    IN HANDLE StartEvent,
    IN HANDLE StopEvent
    );

WCHAR *WinIdleUsage = 
L"Usage: winidle [options]                                                  \n"
L"Options:                                                                  \n"
L"    -wintimeout=x Sets how long notification window takes to go away.     \n"
L"    -logtrace     Will write a trace-log to c:\\idledbg.txt.              \n"
L"    -stressparams Sets idle detection defaults for the above to small     \n"
L"                  values so you can make sure it is working. These can    \n"
L"                  still be overriden by setting the above parameters.     \n"
L"StressParams OVERRIDES: To be used only if -stressparams is specified     \n"
L"    -period=x     Sets idle detection period to x ms.                     \n"
L"    -vperiod=x    Sets idle detection verification period to x ms.        \n"
L"    -vnum=x       Idle is verified over x verification periods.           \n"
L"    -taskcheck=x  Sets idle-task-running check to x ms.                   \n"
L"    -mincpu=x     Sets min cpu percentage at which system can be idle.    \n"
L"    -mindisk=x    Sets min disk percentage at which system can be idle.   \n"
;

#define DBGPRNT(x)       FileDbgPrintEx x

FILE *WinIdleDbgFile = NULL;
BOOLEAN WinIdleLogToFile = FALSE;

ULONG
_cdecl
FileDbgPrintEx(
    IN PCH Format,
    ...
    )
{
    va_list args;

    if (!WinIdleLogToFile) {
        return 0;
    }

    if (!WinIdleDbgFile) {
        char CurTime[20];
        char CurDate[20];

        WinIdleDbgFile = fopen("c:\\idledbg.txt", "a+");
        
        if (!WinIdleDbgFile) {
            return 0;
        }
        
        if (setvbuf(WinIdleDbgFile, NULL, _IONBF, 0)) {
            return 0;
        }
        
        _strtime(CurTime);
        _strdate(CurDate);
        
        fprintf(WinIdleDbgFile, ">>>>>> STARTING NEW LOG AT %s %s <<<<<<\n", 
                CurTime, CurDate);
    }

    va_start(args, Format);
    
    vfprintf(WinIdleDbgFile, Format, args);
    
    va_end(args);

    return 0;
}

#define II_POPUP_WIDTH                   300
#define II_POPUP_HEIGHT                  60
#define II_APPNAME                       L"IdleInfo"
#define II_MAINWINDOW_CLASSNAME          L"IdleInfoMainClass"

HINSTANCE IiInstance = NULL;
HWND IiMainWindow = NULL;

WCHAR *IiMessageStrings[] = {
    L"Running idle task.",
    L"No longer idle!",
};

#define II_MSG_RUNNING 0
#define II_MSG_NOTIDLE 1

ULONG IiCurrentMessageIdx = 0;

LRESULT
CALLBACK
IiMainWndProc(
    HWND hWnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    HDC hDc;
    PAINTSTRUCT Paint;
    RECT Rect;
    static HWND Button;
    static LONG CharHeight;

    switch (uMsg) {
        
    case WM_CLOSE:
        PostQuitMessage (0);
        return 0;

    case WM_PAINT:
        hDc = BeginPaint(hWnd, &Paint);
        GetClientRect(hWnd, &Rect);

        Rect.top += CharHeight / 2;
        DrawText(hDc,
                 IiMessageStrings[IiCurrentMessageIdx],
                 -1,
                 &Rect,
                 DT_SINGLELINE | DT_CENTER | DT_VCENTER);

        EndPaint(hWnd, &Paint);
        return 0;

    case WM_TIMER:
        ShowWindow(IiMainWindow, SW_HIDE);
        return 0;

    default:
        break;
    }

    return DefWindowProc(hWnd, uMsg, wParam, lParam);
}

HWND
IiInit(
    HINSTANCE Instance
    )
{
    DWORD ErrorCode;
    WNDCLASSEX WindowClass;
    LONG WindowHeight;

    WindowClass.cbSize = sizeof(WNDCLASSEX);
    WindowClass.style = CS_BYTEALIGNCLIENT | CS_BYTEALIGNWINDOW;
    WindowClass.lpfnWndProc = IiMainWndProc;
    WindowClass.cbClsExtra = 0;
    WindowClass.cbWndExtra = 0;
    WindowClass.hInstance = Instance;
    WindowClass.hIcon = LoadIcon(NULL, IDI_INFORMATION);
    WindowClass.hCursor = LoadCursor(NULL, IDC_ARROW);
    WindowClass.hbrBackground =  (HBRUSH)(COLOR_WINDOW + 1);
    WindowClass.lpszMenuName = NULL;
    WindowClass.lpszClassName = II_MAINWINDOW_CLASSNAME;
    WindowClass.hIconSm = LoadIcon(NULL, IDI_INFORMATION);

    if (!RegisterClassEx(&WindowClass)) {
        return NULL;
    }

    WindowHeight = II_POPUP_HEIGHT +
        GetSystemMetrics(SM_CYCAPTION) +
        GetSystemMetrics(SM_CYFIXEDFRAME) +
        GetSystemMetrics(SM_CYEDGE);

    return CreateWindowEx(
        WS_EX_TOPMOST | WS_EX_OVERLAPPEDWINDOW,
        II_MAINWINDOW_CLASSNAME,
        II_APPNAME,
        WS_SYSMENU,
        (GetSystemMetrics(SM_CXSCREEN) - II_POPUP_WIDTH) / 2,
        (GetSystemMetrics(SM_CYSCREEN) - WindowHeight) / 2,
        II_POPUP_WIDTH,
        WindowHeight,
        NULL,
        NULL,
        Instance,
        NULL);
}

DWORD
RunIdleTask(
    HANDLE StopEvent,
    BOOLEAN *ShouldExitApp
    )
{
    DWORD EndTime;
    DWORD ErrorCode;
    DWORD WaitResult;
    MSG Msg;
    
    //
    // Initialize locals.
    //

    *ShouldExitApp = FALSE;

    DBGPRNT(("WIN: RunIdleTask()\n"));

    while (TRUE) {
        
        WaitResult = MsgWaitForMultipleObjects (1,
                                                &StopEvent,
                                                FALSE,
                                                0,
                                                QS_ALLEVENTS|QS_ALLINPUT);
        
        switch (WaitResult) {
            
        case WAIT_OBJECT_0:
            
            DBGPRNT(("WIN: RunIdleTask-StopEvent\n"));
            
            ErrorCode = ERROR_SUCCESS;
            goto cleanup;

            break;

        case WAIT_OBJECT_0 + 1:

            DBGPRNT(("WIN: RunIdleTask-WindowMessage\n"));

            if (PeekMessage (&Msg, NULL, 0, 0, PM_REMOVE)) {

                if (Msg.message == WM_QUIT) {
                    *ShouldExitApp = TRUE;
                    ErrorCode = ERROR_SUCCESS;
                    goto cleanup;
                }
                
                TranslateMessage (&Msg);
                DispatchMessage (&Msg);
            }
            
            break;

        case WAIT_TIMEOUT:
            
            EndTime = GetTickCount() + 50;
            while (GetTickCount() < EndTime);
            break;

        default:
            
            ErrorCode = GetLastError();
            goto cleanup;
        }
    }

    ErrorCode = ERROR_SUCCESS;
    
 cleanup:

    DBGPRNT(("WIN: RunIdleTask()=%x\n",ErrorCode));

    return ErrorCode;
}

INT WINAPI WinMain(
   HINSTANCE Instance,
   HINSTANCE PreviousInstance,
   LPSTR CommandLine,
   INT ShowCommand)
{
    DWORD ErrorCode;
    DWORD WaitResult;
    HANDLE StartEvent;
    HANDLE StopEvent;
    MSG Msg;
    IT_IDLE_DETECTION_PARAMETERS Parameters;
    BOOLEAN ShouldExitApp;
    PCHAR Argument;
    DWORD IdleWindowTimeout;
    BOOLEAN RegisteredIdleTask;
    DWORD NotIdleTimerId;
    IT_HANDLE ItHandle;

    //
    // Initialize locals.
    //

    RegisteredIdleTask = FALSE;
    IdleWindowTimeout = 3000;     // 3 seconds.
    NotIdleTimerId = 1;

    //
    // Check for a running instance. If this is the first instance,
    // continue initialization.
    //

    if (PreviousInstance) {
        ErrorCode = ERROR_ALREADY_EXISTS;
        goto cleanup;
    }

    //
    // Turn on file logging if asked for.
    //

    if (Argument = strstr(CommandLine, "-logtrace")) {
        WinIdleLogToFile = TRUE;
    }

    IiInstance = Instance;
    IiMainWindow = IiInit(IiInstance);

    if (!IiMainWindow) {
        ErrorCode = ERROR_INVALID_FUNCTION;
        goto cleanup;
    }

    //
    // Check if we need to display help.
    //    

    if (Argument = strstr(CommandLine, "?")) {
        MessageBox(IiMainWindow, 
                   WinIdleUsage, 
                   L"WinIdle - Idle Detection Test Program",
                   MB_OK);
        ErrorCode = ERROR_SUCCESS;
        goto cleanup;
    }

    //
    // Idle notification window timeout.
    //

    if (Argument = strstr(CommandLine, "-wintimeout=")) {
        sscanf(Argument, "-wintimeout=%u", &IdleWindowTimeout);
    }

    //
    // Set defaults to stress values if asked for.
    //

    Parameters.MaxNumRegisteredTasks = 256;
    
    if (Argument = strstr(CommandLine, "-stressparams")) {

        Parameters.IdleDetectionPeriod =          1000;
        Parameters.IdleVerificationPeriod =        500;
        Parameters.NumVerifications =                2;
        Parameters.IdleInputCheckPeriod =          200;
        Parameters.IdleTaskRunningCheckPeriod =   1000;
        Parameters.MinCpuIdlePercentage =           90;
        Parameters.MinDiskIdlePercentage =          85;

        //
        // Update parameters from command line options.
        //

        if (Argument = strstr(CommandLine, "-period=")) {
            sscanf(Argument, "-period=%u", &Parameters.IdleDetectionPeriod);
        }
        if (Argument = strstr(CommandLine, "-vperiod=")) {
            sscanf(Argument, "-vperiod=%u", &Parameters.IdleVerificationPeriod);
        }
        if (Argument = strstr(CommandLine, "-vnum=")) {
            sscanf(Argument, "-vnum=%u", &Parameters.NumVerifications);
        }
        if (Argument = strstr(CommandLine, "-taskcheck=")) {
            sscanf(Argument, "-taskcheck=%u", &Parameters.IdleTaskRunningCheckPeriod);
        }
        if (Argument = strstr(CommandLine, "-mincpu=")) {
            sscanf(Argument, "-mincpu=%u", &Parameters.MinCpuIdlePercentage);
        }
        if (Argument = strstr(CommandLine, "-mindisk=")) {
            sscanf(Argument, "-mindisk=%u", &Parameters.MinDiskIdlePercentage);
        }
    
        //
        // Set the parameters on the server.
        //

        RpcTryExcept {

            ErrorCode = ItSrvSetDetectionParameters(NULL, &Parameters);
        }
        RpcExcept(IT_RPC_EXCEPTION_HANDLER()) {

            ErrorCode = RpcExceptionCode();
        }
        RpcEndExcept

            DBGPRNT(("WIN: WinMain-SetParameters()=%d\n",ErrorCode));
    
        if (ErrorCode != RPC_S_OK) {
            goto cleanup;
        }
    }

    //
    // Register idle task.
    //

    ErrorCode = RegisterIdleTask(ItOptimalDiskLayoutTaskId,
                                 &ItHandle,
                                 &StartEvent,
                                 &StopEvent);   

    DBGPRNT(("WIN: WinMain-RegisterTask()=%d\n",ErrorCode));

    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    RegisteredIdleTask = TRUE;

    while (TRUE) {
        
        WaitResult = MsgWaitForMultipleObjects (1,
                                                &StartEvent,
                                                FALSE,
                                                INFINITE,
                                                QS_ALLEVENTS|QS_ALLINPUT);
        
        switch (WaitResult) {
            
        case WAIT_OBJECT_0:
            
            DBGPRNT(("WIN: WinMain-StartEvent\n"));
            
            KillTimer(IiMainWindow, NotIdleTimerId);
            IiCurrentMessageIdx = II_MSG_RUNNING;
            InvalidateRect(IiMainWindow, NULL, TRUE);
            ShowWindow(IiMainWindow, SW_SHOW);

            ErrorCode = RunIdleTask(StopEvent, &ShouldExitApp);

            if (ErrorCode != ERROR_SUCCESS) {
                goto cleanup;
            }

            if (ShouldExitApp) {
                goto cleanup;
            }

            IiCurrentMessageIdx = II_MSG_NOTIDLE;
            InvalidateRect(IiMainWindow, NULL, TRUE);
            SetTimer(IiMainWindow, NotIdleTimerId, IdleWindowTimeout, NULL);

            break;

        case WAIT_OBJECT_0 + 1:

            DBGPRNT(("WIN: WinMain-WindowMessage\n"));

            if (PeekMessage (&Msg, NULL, 0, 0, PM_REMOVE)) {

                if (Msg.message == WM_QUIT) {
                    ErrorCode = ERROR_SUCCESS;
                    goto cleanup;
                }
                
                TranslateMessage (&Msg);
                DispatchMessage (&Msg);
            }
            
            break;

        default:
            
            ErrorCode = GetLastError();
            goto cleanup;
        }
    }

    ErrorCode = ERROR_SUCCESS;

 cleanup:

    if (RegisteredIdleTask) {
        UnregisterIdleTask(ItHandle,
                           StartEvent,
                           StopEvent);
    }

    DBGPRNT(("WIN: WinMain()=%d\n",ErrorCode));
    
    return ErrorCode;
}

/*********************************************************************/
/*                MIDL allocate and free                             */
/*********************************************************************/

void __RPC_FAR * __RPC_USER midl_user_allocate(size_t len)
{
    return(HeapAlloc(GetProcessHeap(),0,(len)));
}

void __RPC_USER midl_user_free(void __RPC_FAR * ptr)
{
    HeapFree(GetProcessHeap(),0,(ptr));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\inc\tasks.h ===
//+----------------------------------------------------------------------------
//
//  Scheduling Agent Service
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       tasks.hxx
//
//  Contents:   definitions for Sage compatability.
//
//  History:    25-Jun-96 EricB created
//
//-----------------------------------------------------------------------------

#define MAXPATH 267
#define MAXSETTINGS 256
#define MAXCOMMANDLINE (MAXPATH+MAXSETTINGS)
#define MAXCOMMENT 256
#define CB_RESERVED 32

//
// The following are reserved for 16 bit apps to send messages to control sage.
//
#define SAGE_RESTART            WM_USER + 4
//#define SAGE_NOIDLE           WM_USER + 5 defined in svc_core.hxx
#define SAGE_ENABLE             WM_USER + 6
#define SAGE_DISABLE            WM_USER + 7
#define SAGE_GETSTATUS          WM_USER + 8
#define SAGE_ADDTASK            WM_USER + 9
#define SAGE_REMOVETASK         WM_USER + 10
#define SAGE_GETTASK            WM_USER + 11

typedef struct TaskInfo
{
    unsigned long  StructureSize;
    unsigned long   Task_Identifier;
    unsigned long   Sub_Task_Identifier;
    unsigned long   Status;
    unsigned long   Result;
    unsigned long   Time_Granularity;
    unsigned long   StopAfterTime;
    unsigned long   TimeTillAlarm;
    unsigned long   User_Idle;
    unsigned long   Powered;
    unsigned long   CreatorId;

    SYSTEMTIME      BeginTime;             //indefinite period start time
    SYSTEMTIME      EndTime;               //indefinite peroid end time
    SYSTEMTIME      LastRunStart;          //actual start time
    SYSTEMTIME      LastRunEndScheduled;   //planned termination time
    SYSTEMTIME      LastTerminationTime;   //actual termination time
    SYSTEMTIME      DontRunUntil;          //specific date to not start before
    SYSTEMTIME      LastAlarmTime;
    SYSTEMTIME      RESERVED1;
    SYSTEMTIME      RESERVED2;

    STARTUPINFO     StartupInfo;

    DWORD           dwProcessId;
    DWORD           dwThreadId;

    DWORD           LockingProcess;
    unsigned long   LockTime;
    DWORD           fdwCreate;
    DWORD           taskflags;

    char            SystemTask;
    char            TerminateAtRangeEnd;

    char            StartupTask;
    char            AlarmEnabled;
    char            RunNow;
    char            TerminateNoIdle;
    char            Disabled;
    char            TerminateNow;
    char            RestartNoIdle;

    char            CommandLine[MAXCOMMANDLINE];
    char            Comment[MAXCOMMENT];
    char            WorkingDirectory[MAXPATH];
    DWORD           hProcess;  //declare as dword so 16 bit apps get right size
    DWORD           hThread;
    DWORD           hTerminateThread;
    char            ExcludeDaysVector;
    char            Reserved[CB_RESERVED-12];
} TaskInfo;

typedef struct SystemInfo
{
    SYSTEMTIME      CurrentTime;
    unsigned long   MouseTime;
    BOOL            Asleep;
    unsigned long   TickCount;
    HANDLE          AgentSemaphore;
    HANDLE          SleepSemaphore;
}SystemInfo;

#define SAGE_SUSPEND            WM_USER + 1
#define SAGE_TERMINATE          WM_USER + 2
#define SAGE_RESUME             WM_USER + 3

#if 0

typedef struct ADD_TASK
{
	unsigned long	result_code;
	TaskInfo	    new_task;
	char			reserved[256];
} ADD_TASK;

typedef struct REMOVE_TASK
{
	unsigned long	result_code;
	unsigned long	task_id;
	unsigned long 	subtask_id;
	char			reserved[256];
} REMOVE_TASK;

typedef struct TASK_ENUMERATION_HEADER
{
	unsigned long 	result_code;
	unsigned long 	packet_size;
	unsigned long 	total_tasks;
	unsigned long 	count_tasks;

} TASK_ENUMERATION_HEADER;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\job\jobex.cxx ===
//+----------------------------------------------------------------------------
//
//  Job Scheduler Job Object Handler
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       jobex.cxx
//
//  Contents:   ITask interface methods
//
//  Classes:    CJob
//
//  Interfaces: ITask
//
//  History:    16-Oct-95 EricB     created
//              11-Nov-96 AnirudhS  Fixed both GetRunTimes methods to return
//                  the right success codes.
//              20-Nov-01 ShBrown   Switched to use standard NT build versioning
//
//-----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "job.hxx"
#include "defines.hxx"
#include <ntverp.h>

//
// Increment the following if the job object file format is changed in an incompatible fashion.
//
#define JOB_OBJ_FORMAT_VERSION      1


//+----------------------------------------------------------------------------
//
//  Member:     CJob::CJob
//
//  Synopsis:   constructor
//
//-----------------------------------------------------------------------------
CJob::CJob(void) :
    m_wVersion(MAKEWORD(VER_PRODUCTMINORVERSION, VER_PRODUCTMAJORVERSION)),
    m_wFileObjVer(JOB_OBJ_FORMAT_VERSION),
    m_wTriggerOffset(0),
    m_wErrorRetryCount(0),
    m_wErrorRetryInterval(0),
    m_cRunningInstances(0),
    m_wIdleWait(SCH_DEFAULT_IDLE_TIME),
    m_wIdleDeadline(SCH_DEFAULT_IDLE_DEADLINE),
    m_dwPriority(NORMAL_PRIORITY_CLASS),
    m_dwMaxRunTime(MAX_RUN_TIME_DEFAULT),
    m_ExitCode(0),
    m_hrStatus(SCHED_S_TASK_NOT_SCHEDULED),
    m_rgFlags(JOB_I_FLAG_NO_RUN_PROP_CHANGE),        // The task is not yet dirty
    m_rgTaskFlags(0),
    m_pwszApplicationName(NULL),
    m_pwszParameters(NULL),
    m_pwszWorkingDirectory(NULL),
    m_pwszCreator(NULL),
    m_pwszComment(NULL),
    m_cbTaskData(0),
    m_pbTaskData(NULL),
    m_cReserved(0),
    m_pbReserved(NULL),
    m_hrStartError(SCHED_S_TASK_HAS_NOT_RUN),
    m_pIJobTypeInfo(NULL),
    m_cReferences(1),
#if !defined(_CHICAGO_)
    m_pAccountInfo(NULL),
    m_pbSignature(NULL),
#endif // !defined(_CHICAGO_)
    m_ptszFileName(NULL),
    m_fFileCreated(FALSE)
{
    //TRACE(CJob, CJob);

    UUID uuidNull = {0};
    m_uuidJob = uuidNull;

    SYSTEMTIME stNull = {0};
    m_stMostRecentRunTime = stNull;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::~CJob
//
//  Synopsis:   destructor
//
//-----------------------------------------------------------------------------
CJob::~CJob(void)
{
    //TRACE(CJob, ~CJob);
    FreeProperties();
    if (m_pIJobTypeInfo != NULL)
    {
        m_pIJobTypeInfo->Release();
    }
    delete m_ptszFileName;

#if !defined(_CHICAGO_)

    if (m_pAccountInfo != NULL)
    {
        ZERO_PASSWORD(m_pAccountInfo->pwszPassword);    // NULL is handled.
        delete m_pAccountInfo->pwszAccount;
        delete m_pAccountInfo->pwszPassword;
        delete m_pAccountInfo;
    }

#endif // !defined(_CHICAGO_)
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::GetRunTimes
//
//  Synopsis:   Return a list of run times for this job that fall between the
//              bracketing times inclusively.
//
//  Arguments:  [pstBegin]     - the start of the bracketing period
//              [pstEnd]       - the end of the bracketing period, may be NULL
//              [pCount]       - On entry, points to the number of run times
//                               to retrieve.  This must be a number between 1
//                               and TASK_MAX_RUN_TIMES.  On exit, points to
//                               the number of run times actually retrieved.
//              [rgstJobTimes] - the returned array of SYSTEMTIME structures
//
//  Returns:    S_OK: the requested number of run times are returned.
//              S_FALSE: fewer than the requested number of run times are
//                  returned. (More precisely: the task has valid time-based
//                  triggers, but the number of run times during the specified
//                  time bracket is less than the number of run times requested.
//                  (This includes the case of no event triggers and zero run
//                  times during that time bracket.))
//              SCHED_S_EVENT_TRIGGER: no time-based triggers will cause the
//                  task to run during the specified time bracket, but event
//                  triggers may (note that event triggers have no set run
//                  times).  (In this case *pCount is set to 0)
//              SCHED_S_TASK_NO_VALID_TRIGGERS: the task is enabled but has no
//                  valid triggers.
//              SCHED_S_TASK_DISABLED: the task is disabled.
//              E_INVALIDARG: the arguments are not valid.
//              E_OUTOFMEMORY: not enough memory is available.
//
//  Notes:      The job time list is callee allocated and caller freed. The
//              caller must use CoTaskMemFree to free this list.
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::GetRunTimes(const LPSYSTEMTIME pstBegin, const LPSYSTEMTIME pstEnd,
                  WORD * pCount, LPSYSTEMTIME * rgstJobTimes)
{
    TRACE(CJob, GetRunTimes);
    HRESULT hr;

    WORD cLimit = *pCount;
    if (cLimit < 1 || cLimit > TASK_MAX_RUN_TIMES)
    {
        return E_INVALIDARG;
    }

    *rgstJobTimes = NULL;

    //
    // Get the list of run times.
    //
    CTimeRunList RunList;
    *pCount = 0;    // Number of elements in RunList

    hr = GetRunTimesP(pstBegin, pstEnd, pCount, cLimit, &RunList, NULL);
    if (hr != S_OK)
    {
        *pCount = 0;
        return hr;
    }
    schAssert(*pCount <= cLimit);

    //
    // Convert the time list to an array of SYSTEMTIMEs.
    //
#if DBG
    WORD cCountBefore = *pCount;
#endif
    hr = RunList.MakeSysTimeArray(rgstJobTimes, pCount);
    if (SUCCEEDED(hr))
    {
        schAssert(*pCount == cCountBefore);

        hr = (*pCount < cLimit) ? S_FALSE : S_OK;
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::GetRunTimesP, private
//
//  Synopsis:   Computes a set of run times for this job that fall between the
//              bracketing times inclusively, and adds them to the run list.
//
//  Arguments:  [pstBegin] - the start of the bracketing period
//              [pstEnd]   - the end of the bracketing period, may be NULL
//              [pCount]   - On both entry and exit, points to the number of
//                            run times in the list.
//              [cLimit]   - the maximum number of CRun objects that the list
//                            may contain.
//              [pRunList] - the list of run time objects, can be
//                            NULL if just checking to see if there will be
//                            *any* runs.  (Note: If it's NULL, duplicate run
//                            times are not detected, so pCount may be over-
//                            estimated on return.)
//              [ptszShortName] - the folder-relative job name.
//
//  Returns:    S_OK: Some (zero or more) runs have been added to the list.
//              SCHED_S_EVENT_TRIGGER: the job has an event trigger and none
//                                     of the other triggers had runs.
//              SCHED_S_TASK_NO_VALID_TRIGGERS: the triggers are disabled or
//                                              not set.
//              SCHED_S_TASK_DISABLED: the job is disabled.
//
//  Notes:      The job time list is callee allocated and caller freed. The
//              caller must use FreeList to free this list.
//-----------------------------------------------------------------------------
HRESULT
CJob::GetRunTimesP(const SYSTEMTIME * pstBegin, const SYSTEMTIME * pstEnd,
                   WORD * pCount, WORD cLimit, CTimeRunList * pRunList,
                   LPTSTR ptszShortName)
{
    HRESULT hr;

    schAssert(cLimit > 0);  // If cLimit is 0, it's not clear what to return
    schAssert(cLimit <= TASK_MAX_RUN_TIMES);
    schAssert(*pCount <= cLimit);

    //
    // Test for conditions that would prevent a run time from being returned.
    //
    if (IsFlagSet(TASK_FLAG_DISABLED))
    {
        return SCHED_S_TASK_DISABLED;
    }

    WORD cTriggers = m_Triggers.GetCount();

    //
    // Don't need any of the internal job flags for run instance processing.
    // That bit space is used for run processing specific flags defined in
    // runobj.hxx.
    //
    DWORD rgFlags = GetUserFlags();

    BOOL fEventTriggerFound = FALSE;
    BOOL fTimeTriggerFound = FALSE;

    //
    // Loop over the triggers.
    //
    for (WORD i = 0; i < cTriggers; i++)
    {
        hr = ::GetTriggerRunTimes(m_Triggers[i],
                                  pstBegin,
                                  pstEnd,
                                  pCount,
                                  cLimit,
                                  pRunList,
                                  ptszShortName,
                                  rgFlags,
                                  m_dwMaxRunTime,
                                  m_wIdleWait,
                                  m_wIdleDeadline);

        if (FAILED(hr))
        {
            ERR_OUT("CJob::GetRunTimes, ::GetRunTimes", hr);
            return(hr);
        }

        if (hr == SCHED_S_EVENT_TRIGGER)
        {
            fEventTriggerFound = TRUE;
        }
        else if (hr == S_OK)
        {
            fTimeTriggerFound = TRUE;

            if (*pCount >= cLimit && pRunList == NULL)
            {
                //
                // Special case where all we want is to test *if* there are runs,
                // and don't need the run times. Otherwise, we examine all
                // triggers because they won't return run times in any particular
                // order.
                //
                break;
            }
        }
    }

    //
    // Summarize the results in the return code
    //
    if (fTimeTriggerFound)
    {
        if (*pCount == 0 && fEventTriggerFound)
        {
            hr = SCHED_S_EVENT_TRIGGER;
            // (BUGBUG Here, we are assuming that *pCount was 0 initially.
            // Maybe add this to the comments and assertions at the start
            // of this function.  However, this might not be necessary if
            // *pCount is made a member of CRunList, as it should be.)
        }
        else
        {
            hr = S_OK;
        }
    }
    else if (fEventTriggerFound)
    {
        hr = SCHED_S_EVENT_TRIGGER;
    }
    else
    {
        hr = SCHED_S_TASK_NO_VALID_TRIGGERS;
    }

    return hr;
}


//+----------------------------------------------------------------------------
//
//  Synopsis:   Skips past the preceeding data and loads only the triggers
//
//  Notes:      This method will fail if not preceeded at some time during
//              the job object's lifetime by a call to LoadP.
//
//-----------------------------------------------------------------------------
HRESULT
CJob::LoadTriggers(void)
{
    // CODEWORK  Optimize this to use a single ReadFile, like LoadP().
    // Or, get rid of it altogether and just use LoadP, or an additional
    // flag to LoadP.

    //TRACE(CJob, LoadTriggers);

    if (m_ptszFileName == NULL || m_wTriggerOffset == 0)
    {
        return E_FAIL;
    }
    HRESULT hr;

    //
    // Open the file.
    //
    HANDLE hFile = CreateFile(m_ptszFileName, GENERIC_READ, FILE_SHARE_READ,
                              NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN,
                              NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ERR_OUT("CJob::Load, file open", hr);
        return hr;
    }

    //
    // Move to the trigger data.
    //
    DWORD dwBytes;

    dwBytes = SetFilePointer(hFile, m_wTriggerOffset, NULL, FILE_BEGIN);
    if (dwBytes == 0xffffffff)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ERR_OUT("CJob::LoadTriggers, move to trigger data", hr);
        goto cleanup;
    }

    //
    // Load triggers.
    //

    hr = this->_LoadTriggers(hFile);

cleanup:
    //
    // Close the file.
    //
    CloseHandle(hFile);
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::_LoadTriggersFromBuffer, private
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------
HRESULT
CJob::_LoadTriggersFromBuffer(CInputBuffer * pBuf)
{
    HRESULT hr = S_OK;
    WORD    cTriggers;

    // Read trigger count.
    //
    if (!pBuf->Read(&cTriggers, sizeof cTriggers))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        CHECK_HRESULT(hr);
        return hr;
    }

    // Verify buffer contains that many triggers.
    //
    BYTE *pTriggers = pBuf->CurrentPosition();  // save current position
    if (!pBuf->Advance(cTriggers * sizeof TASK_TRIGGER))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        CHECK_HRESULT(hr);
        return hr;
    }

    // Copy triggers into a properly aligned array.
    // CODEWORK: Align them in the original buffer instead of allocating
    // a separate one.
    //
    hr = m_Triggers.AllocAndCopy(cTriggers, pTriggers);
    if (FAILED(hr))
    {
        CHECK_HRESULT(hr);
        return hr;
    }

    if (cTriggers)
    {
        //
        // BUGBUG: temporary, remove the next time the job file format
        // is revised.
        //
        TASK_TRIGGER * ajt = m_Triggers.GetArray();
        for (WORD i = 0; i < cTriggers; i++)
        {
            ajt[i].Reserved1 = i;
        }
        //
        // end of temporary code.
        //

        this->SetFlag(JOB_I_FLAG_HAS_TRIGGERS);
    }
    else
    {
        //
        // No triggers - clear trigger flag.
        //
        this->ClearFlag(JOB_I_FLAG_HAS_TRIGGERS);
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::_LoadTriggers, private
//
//  Synopsis:
//
//  Arguments:  None.
//
//  Returns:
//
//  Notes:      None.
//
//-----------------------------------------------------------------------------
HRESULT
CJob::_LoadTriggers(HANDLE hFile)
{
    HRESULT hr = S_OK;
    DWORD   dwRead;
    WORD    cTriggers;

    // Read trigger count.
    //
    if (!ReadFile(hFile, &cTriggers, sizeof(cTriggers), &dwRead, NULL))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        CHECK_HRESULT(hr);
        return(hr);
    }

    if (dwRead != sizeof(cTriggers))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        CHECK_HRESULT(hr);
        return(hr);
    }

    // Free existing trigger array.
    //
    m_Triggers.FreeArray();

    // Get on with load.
    //
    if (cTriggers)
    {
        TASK_TRIGGER * ajt = (TASK_TRIGGER *)
            LocalAlloc(LMEM_FIXED, cTriggers * sizeof TASK_TRIGGER);
        if (ajt == NULL)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            CHECK_HRESULT(hr);
            return hr;
        }

        if (!ReadFile(hFile, ajt, cTriggers * sizeof TASK_TRIGGER, &dwRead,
                      NULL))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            CHECK_HRESULT(hr);
            LocalFree(ajt);
            return hr;
        }

        if (dwRead != cTriggers * sizeof TASK_TRIGGER)
        {
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            CHECK_HRESULT(hr);
            LocalFree(ajt);
            return hr;
        }

        for (WORD i = 0; i < cTriggers; i++)
        {
            //
            // BUGBUG: temporary, remove the next time the job file format
            // is revised.
            //
            ajt[i].Reserved1 = i;
            //
            // end of temporary code.
            //
        }

        m_Triggers.SetArray(cTriggers, ajt);

        this->SetFlag(JOB_I_FLAG_HAS_TRIGGERS);
    }
    else
    {
        //
        // No triggers - clear trigger flag.
        //

        this->ClearFlag(JOB_I_FLAG_HAS_TRIGGERS);
    }

    return(hr);
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::_SaveTriggers, private
//
//  Synopsis:
//
//  Arguments:  None.
//
//  Returns:
//
//  Notes:      None.
//
//-----------------------------------------------------------------------------
HRESULT
CJob::_SaveTriggers(HANDLE hFile)
{
    HRESULT hr = S_OK;
    DWORD   dwWritten;
    DWORD   cTriggerDataSize;
    WORD    cTriggers = m_Triggers.GetCount();

    // Write trigger count.
    //
    if (!WriteFile(hFile, &cTriggers, sizeof(cTriggers), &dwWritten, NULL))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        CHECK_HRESULT(hr);
        return(hr);
    }

    if (dwWritten != sizeof(cTriggers))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        CHECK_HRESULT(hr);
        return(hr);
    }

    // Write trigger data.
    //
    if (!WriteFile(hFile,
                   m_Triggers.GetArray(),
                   cTriggerDataSize = sizeof(TASK_TRIGGER) * cTriggers,
                   &dwWritten,
                   NULL))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        CHECK_HRESULT(hr);
        return(hr);
    }

    if (dwWritten != cTriggerDataSize)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        CHECK_HRESULT(hr);
    }

    return(hr);
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::SetTriggersDirty, protected
//
//  Synopsis:   Sets the triggers-dirty flag and clears the unchanged and
//              NetSchedule flags.
//
//  Notes:      IPersistFile::Save will call UpdateJobState if the trigger-
//              dirty flag is set. UpdateJobState updates the job's status
//              property.
//-----------------------------------------------------------------------------
void
CJob::SetTriggersDirty(void)
{
    //
    // The JOB_I_FLAG_TRIGGERS_DIRTY flag indicates the in-core object does
    // not match the persistent object. This flag is not saved persistently; it
    // is cleared on a Save.
    //
    SetFlag(JOB_I_FLAG_TRIGGERS_DIRTY);

    //
    // We set this flag here so that a rebuild will occur due to the possible
    // run time changes introduced by the trigger change.
    //
    SetFlag(JOB_I_FLAG_RUN_PROP_CHANGE);
    ClearFlag(JOB_I_FLAG_NO_RUN_PROP_CHANGE);
}

// Class members - *not* part of any interface.
//
//+----------------------------------------------------------------------------
//
//  Member:     CJob::SetTrigger, public
//
//  Synopsis:
//
//  Arguments:  [] -
//
//  Returns:
//
//  Notes:
//-----------------------------------------------------------------------------
HRESULT
CJob::SetTrigger(WORD iTrigger, PTASK_TRIGGER pTrigger)
{
    TASK_TRIGGER * pjt = this->_GetTrigger(iTrigger);

    schAssert(pjt != NULL);

    if (pjt == NULL)
    {
        CHECK_HRESULT(E_FAIL);
        return(E_FAIL);
    }

    //
    // Check version. Do not modify triggers created by a later version.
    //
    // BUGBUG : This doesn't seem quite right.
    //

    if (pTrigger->cbTriggerSize != sizeof(TASK_TRIGGER))
    {
        CHECK_HRESULT(E_INVALIDARG);
        return(E_INVALIDARG);
    }

    //
    // Data validation.
    //
    if (pTrigger->wStartHour > JOB_MAX_HOUR     ||
        pTrigger->wStartMinute > JOB_MAX_MINUTE)
    {
        return E_INVALIDARG;
    }
    if (!IsValidDate(pTrigger->wBeginMonth,
                     pTrigger->wBeginDay,
                     pTrigger->wBeginYear))
    {
        return E_INVALIDARG;
    }
    if (pTrigger->rgFlags & TASK_TRIGGER_FLAG_HAS_END_DATE &&
        !IsValidDate(pTrigger->wEndMonth,
                     pTrigger->wEndDay,
                     pTrigger->wEndYear))
    {
        return E_INVALIDARG;
    }
    //
    // If either MinutesDuration or MinutesInterval is nonzero, then
    // MinutesInterval must be less than MinutesDuration.
    //
    if ((pTrigger->MinutesDuration > 0 || pTrigger->MinutesInterval > 0) &&
        (pTrigger->MinutesInterval >= pTrigger->MinutesDuration))
    {
        return E_INVALIDARG;
    }

    //
    // Type consistency validation and value assignment.
    //
    switch (pTrigger->TriggerType)
    {
    case TASK_TIME_TRIGGER_DAILY:
        if (pTrigger->Type.Daily.DaysInterval == 0)
        {
            return E_INVALIDARG;
        }
        pjt->Type.Daily.DaysInterval = pTrigger->Type.Daily.DaysInterval;
        break;

    case TASK_TIME_TRIGGER_WEEKLY:
        if (pTrigger->Type.Weekly.WeeksInterval == 0    ||
            pTrigger->Type.Weekly.rgfDaysOfTheWeek == 0 ||
            pTrigger->Type.Weekly.rgfDaysOfTheWeek  > JOB_RGFDOW_MAX)
        {
            return E_INVALIDARG;
        }
        pjt->Type.Weekly.WeeksInterval = pTrigger->Type.Weekly.WeeksInterval;
        pjt->Type.Weekly.rgfDaysOfTheWeek =
                                      pTrigger->Type.Weekly.rgfDaysOfTheWeek;
        break;

    case TASK_TIME_TRIGGER_MONTHLYDATE:
        if (!IsValidMonthlyDateTrigger(pTrigger))
        {
            return E_INVALIDARG;
        }

        pjt->Type.MonthlyDate.rgfDays = pTrigger->Type.MonthlyDate.rgfDays;
        pjt->Type.MonthlyDate.rgfMonths = pTrigger->Type.MonthlyDate.rgfMonths;
        break;

    case TASK_TIME_TRIGGER_MONTHLYDOW:
        if (pTrigger->Type.MonthlyDOW.wWhichWeek < TASK_FIRST_WEEK       ||
            pTrigger->Type.MonthlyDOW.wWhichWeek > TASK_LAST_WEEK        ||
            pTrigger->Type.MonthlyDOW.rgfDaysOfTheWeek == 0             ||
            pTrigger->Type.MonthlyDOW.rgfDaysOfTheWeek > JOB_RGFDOW_MAX ||
            pTrigger->Type.MonthlyDOW.rgfMonths == 0                    ||
            pTrigger->Type.MonthlyDOW.rgfMonths > JOB_RGFMONTHS_MAX)
        {
            return E_INVALIDARG;
        }
        pjt->Type.MonthlyDOW.wWhichWeek = pTrigger->Type.MonthlyDOW.wWhichWeek;
        pjt->Type.MonthlyDOW.rgfDaysOfTheWeek =
                                    pTrigger->Type.MonthlyDOW.rgfDaysOfTheWeek;
        pjt->Type.MonthlyDOW.rgfMonths = pTrigger->Type.MonthlyDOW.rgfMonths;
        break;

    case TASK_TIME_TRIGGER_ONCE:
    case TASK_EVENT_TRIGGER_ON_IDLE:
    case TASK_EVENT_TRIGGER_AT_SYSTEMSTART:
    case TASK_EVENT_TRIGGER_AT_LOGON:
// Not yet implemented:
//    case TASK_EVENT_TRIGGER_ON_APM_RESUME:
        //
        // No type-specific data for these.
        //
        break;

    default:
        return E_INVALIDARG;
    }
    pjt->TriggerType      = pTrigger->TriggerType;
    pjt->cbTriggerSize    = pTrigger->cbTriggerSize;
    pjt->wBeginYear       = pTrigger->wBeginYear;
    pjt->wBeginMonth      = pTrigger->wBeginMonth;
    pjt->wBeginDay        = pTrigger->wBeginDay;
    pjt->wEndYear         = pTrigger->wEndYear;
    pjt->wEndMonth        = pTrigger->wEndMonth;
    pjt->wEndDay          = pTrigger->wEndDay;
    pjt->wStartHour       = pTrigger->wStartHour;
    pjt->wStartMinute     = pTrigger->wStartMinute;
    pjt->MinutesDuration  = pTrigger->MinutesDuration;
    pjt->MinutesInterval  = pTrigger->MinutesInterval;

    //
    // The upper word of pjt->rgFlags is reserved, so set only the lower
    // word and retain the upper word values.
    //
    pjt->rgFlags &= JOB_INTERNAL_FLAG_MASK;
    pjt->rgFlags = pTrigger->rgFlags & ~JOB_INTERNAL_FLAG_MASK;

    //
    // This call explicitly set the trigger values, so clear the
    // JOB_TRIGGER_I_FLAG_NOT_SET bit.
    //
    pjt->rgFlags &= ~JOB_TRIGGER_I_FLAG_NOT_SET;

    this->SetTriggersDirty();

    //
    // If GetNextRunTime returned SCHED_S_TASK_NO_MORE_RUNS prior to this
    // call, then JOB_I_FLAG_NO_MORE_RUNS is set. Clear it and then call
    // UpdateJobState to bring the status current.
    //

    this->ClearFlag(JOB_I_FLAG_NO_MORE_RUNS);

    this->UpdateJobState(FALSE);

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::GetTrigger
//
//  Synopsis:
//
//  Arguments:  [] -
//
//  Returns:    HRESULTS
//
//  Notes:
//
//-----------------------------------------------------------------------------
HRESULT
CJob::GetTrigger(WORD iTrigger, PTASK_TRIGGER pTrigger)
{
    TASK_TRIGGER * pjt = this->_GetTrigger(iTrigger);

    schAssert(pjt != NULL);

    if (pjt == NULL)
    {
        CHECK_HRESULT(E_FAIL);
        return(E_FAIL);
    }

    //
    // Do trigger type specific processing.
    //
    switch (pjt->TriggerType)
    {
    case TASK_TIME_TRIGGER_DAILY:
        pTrigger->Type.Daily.DaysInterval = pjt->Type.Daily.DaysInterval;
        break;

    case TASK_TIME_TRIGGER_WEEKLY:
        pTrigger->Type.Weekly.WeeksInterval = pjt->Type.Weekly.WeeksInterval;
        pTrigger->Type.Weekly.rgfDaysOfTheWeek =
                                              pjt->Type.Weekly.rgfDaysOfTheWeek;
        break;

    case TASK_TIME_TRIGGER_MONTHLYDATE:
        pTrigger->Type.MonthlyDate.rgfDays = pjt->Type.MonthlyDate.rgfDays;
        pTrigger->Type.MonthlyDate.rgfMonths = pjt->Type.MonthlyDate.rgfMonths;
        break;

    case TASK_TIME_TRIGGER_MONTHLYDOW:
        pTrigger->Type.MonthlyDOW.wWhichWeek = pjt->Type.MonthlyDOW.wWhichWeek;
        pTrigger->Type.MonthlyDOW.rgfDaysOfTheWeek =
                                            pjt->Type.MonthlyDOW.rgfDaysOfTheWeek;
        pTrigger->Type.MonthlyDOW.rgfMonths = pjt->Type.MonthlyDOW.rgfMonths;
        break;

    case TASK_TIME_TRIGGER_ONCE:
    case TASK_EVENT_TRIGGER_ON_IDLE:
    case TASK_EVENT_TRIGGER_AT_SYSTEMSTART:
    case TASK_EVENT_TRIGGER_AT_LOGON:
// Not yet implemented:
//    case TASK_EVENT_TRIGGER_ON_APM_RESUME:
        //
        // No trigger-specific data.
        //
        break;

    default:
        //
        // In future revisions, different trigger types would be handled
        // here.
        //
        return E_INVALIDARG;
    }

    pTrigger->TriggerType       = pjt->TriggerType;
    pTrigger->cbTriggerSize     = pjt->cbTriggerSize;
    pTrigger->wBeginYear        = pjt->wBeginYear;
    pTrigger->wBeginMonth       = pjt->wBeginMonth;
    pTrigger->wBeginDay         = pjt->wBeginDay;
    pTrigger->wEndYear          = pjt->wEndYear;
    pTrigger->wEndMonth         = pjt->wEndMonth;
    pTrigger->wEndDay           = pjt->wEndDay;
    pTrigger->wStartHour        = pjt->wStartHour;
    pTrigger->wStartMinute      = pjt->wStartMinute;
    pTrigger->MinutesDuration   = pjt->MinutesDuration;
    pTrigger->MinutesInterval   = pjt->MinutesInterval;
    pTrigger->rgFlags           = pjt->rgFlags;
    pTrigger->Reserved1         = 0;
    pTrigger->Reserved2         = pjt->Reserved2;
    pTrigger->wRandomMinutesInterval = pjt->wRandomMinutesInterval;

    //
    // If this trigger has not been set to non-default values, it will have
    // the flag bit JOB_TRIGGER_I_FLAG_NOT_SET set. Since this is an internal
    // value, replace it with TASK_TRIGGER_FLAG_DISABLED.
    //
    if (pTrigger->rgFlags & JOB_TRIGGER_I_FLAG_NOT_SET)
    {
        pTrigger->rgFlags &= ~JOB_INTERNAL_FLAG_MASK;
        pTrigger->rgFlags |= TASK_TRIGGER_FLAG_DISABLED;
    }
    else
    {
        pTrigger->rgFlags &= ~JOB_INTERNAL_FLAG_MASK;
    }

    //
    // Struct version check.
    //
    // In future revisions, different trigger structs would be handled
    // here.
    //
    //if (pTrigger->cbTriggerSize != sizeof(TASK_TRIGGER))
    //{
    //    ;
    //}

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::SetErrorRetryCount, public
//
//  Synopsis:   Set the number of times the service should attempt to run a
//              job that is failing to start.
//
//  Arguments:  [wRetryCount] - zero, of course, means don't retry.
//
//  Returns:    HRESULTS
//
//-----------------------------------------------------------------------------
HRESULT
CJob::SetErrorRetryCount(WORD wRetryCount)
{
    //TRACE(CJob, SetErrorRetryCount);

    m_wErrorRetryCount = wRetryCount;

    //
    // Not implemented yet
    //
    return E_NOTIMPL;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::GetErrorRetryCount, public
//
//  Synopsis:   Get the number of times the service will attempt to run a
//              job that is failing to start.
//
//  Arguments:  [pwRetryCount] - the retry count.
//
//  Returns:    HRESULTS
//
//-----------------------------------------------------------------------------
HRESULT
CJob::GetErrorRetryCount(WORD * pwRetryCount)
{
    //TRACE(CJob, GetErrorRetryCount);

    *pwRetryCount = m_wErrorRetryCount;

    //
    // Not implemented yet
    //
    return E_NOTIMPL;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::SetIdleWait, public
//
//  Synopsis:   Set the time to wait until idle, in minutes. This is the
//              amount of time after the last user keyboard or mouse moverment
//              until the idle state will be entered for this task.
//
//  Arguments:  [wIdleMinutes]     - the time to wait till idle in minutes.
//              [wDeadlineMinutes] - minutes to wait for [wIdleMinutes] of
//                                    idleness
//
//  Returns:    S_OK
//
//  Notes:      The task will wait for up to [wDeadlineMinutes] for an idle
//              period of [wIdleMinutes] to occur.
//
//              If [wDeadlineMinutes] is 0, the task will not run unless the
//              computer has been idle for at least [wIdleMinutes] by the
//              task's start time.
//
//-----------------------------------------------------------------------------
HRESULT
CJob::SetIdleWait(WORD wIdleMinutes, WORD wDeadlineMinutes)
{
    TRACE3(CJob, SetIdleWait);

    m_wIdleWait = wIdleMinutes;
    m_wIdleDeadline = wDeadlineMinutes;

    // Cause a wait list rebuild
    SetFlag(JOB_I_FLAG_PROPERTIES_DIRTY | JOB_I_FLAG_RUN_PROP_CHANGE);

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::GetIdleWait, public
//
//  Synopsis:   Get the idle time requirement and deadline, in minutes.
//
//  Arguments:  [pwMinutes]  - the returned idle time.
//              [pwDeadline] - the returned idle deadline
//
//  Returns:    S_OK
//
//-----------------------------------------------------------------------------
HRESULT
CJob::GetIdleWait(WORD * pwMinutes, WORD * pwDeadline)
{
    TRACE3(CJob, GetIdleWait);

    *pwMinutes = m_wIdleWait;
    *pwDeadline = m_wIdleDeadline;

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::SetErrorRetryInterval, public
//
//  Synopsis:   Set the interval, in minutes, between successive retries.
//
//  Arguments:  [wRetryInterval] - the retry interval.
//
//  Returns:    E_NOTIMPL
//
//-----------------------------------------------------------------------------
HRESULT
CJob::SetErrorRetryInterval(WORD wRetryInterval)
{
    //TRACE(CJob, SetErrorRetryInterval);

    m_wErrorRetryInterval = wRetryInterval;

    //
    // Not implemented yet
    //
    return E_NOTIMPL;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::GetErrorRetryInterval, public
//
//  Synopsis:   Get the interval, in minutes, between successive retries.
//
//  Arguments:  [pwRetryInterval] - the returned interval.
//
//  Returns:    E_NOTIMPL
//
//-----------------------------------------------------------------------------
HRESULT
CJob::GetErrorRetryInterval(WORD * pwRetryInterval)
{
    //TRACE(CJob, GetErrorRetryInterval);

    *pwRetryInterval = m_wErrorRetryInterval;

    //
    // Not implemented yet
    //
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\job\job.cxx ===
//+----------------------------------------------------------------------------
//
//  Job Scheduler Job Object Handler
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       job.cxx
//
//  Contents:   ITask interface methods
//
//  Classes:    CJob
//
//  Interfaces: ITask
//
//  History:    23-May-95 EricB created
//
//-----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "job.hxx"
#include "defines.hxx"

WCHAR                   wszEmpty[]              = L"";

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::Run
//
//  Synopsis:   Run the job now. Sets a service bit on the job file. The
//              running service will notice this bit being set and will run
//              this job.
//
//  Returns:    HRESULTS
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::Run(void)
{
    TRACE(CJob, Run)

    if (!IsFlagSet(JOB_I_FLAG_HAS_APPNAME))
    {
        return SCHED_E_TASK_NOT_READY;
    }

    //
    // Set the magic bit.
    //

    SetFlag(JOB_I_FLAG_RUN_NOW);

    //
    // Save the service flags to disk so that the change can be noted by the
    // service.  Preserve the net schedule flag, thus allowing a user to force
    // a run of an AT job without clearing the AT bit.
    //

    return SaveP(NULL, FALSE, SAVEP_PRESERVE_NET_SCHEDULE);
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::Terminate
//
//  Synopsis:   Abort this job, if it is running. Do so by setting an abort
//              flag on the job object. The scheduler service local to the
//              job object will detect this change and abort the job.
//
//  Arguments:  None.
//
//  Returns:    HRESULTS
//
//  Notes:      None.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::Terminate(void)
{
    TRACE(CJob, Terminate)

    if (m_cRunningInstances > 0)
    {
        //
        // Set the abort status bit and rewrite the state.  This will instruct
        // the service to process the job, detect the abort bit flag, and
        // abort the job.  As with the Run method, this doesn't zap the AT
        // flag.
        //

        SetFlag(JOB_I_FLAG_ABORT_NOW);

        return SaveP(NULL, FALSE, SAVEP_PRESERVE_NET_SCHEDULE);
    }
    else
    {
        return(SCHED_E_TASK_NOT_RUNNING);
    }
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::CreateTrigger
//
//  Synopsis:   Create a new trigger, add it to the job object, and return a
//              pointer to it.
//
//  Arguments:  [piNewTrigger] - the index of the new trigger, optional
//              [ppTrigger]    - a pointer to the new trigger
//
//  Returns:    HRESULTS
//
//  Notes:      The trigger is AddRef'd in CreateTriggerP
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::CreateTrigger(WORD * piNewTrigger, ITaskTrigger ** ppTrigger)
{
    TRACE3(CJob, CreateTrigger)

    *ppTrigger = NULL;              // Init in case of error.

    SYSTEMTIME st;
    GetLocalTime(&st);

    TASK_TRIGGER jt = {
        sizeof(TASK_TRIGGER),       // Trigger size.
        m_Triggers.GetCount(),      // Reserved (trigger index).
        st.wYear,                   // Beginning year.
        st.wMonth,                  // Beginning month.
        st.wDay,                    // Beginning day.
        0,                          // Ending year.
        0,                          // Ending month.
        0,                          // Ending day.
        st.wHour,                   // Starting hour.
        st.wMinute,                 // Starting minute.
        0,                          // Minutes duration.
        0,                          // Minutes interval.
        JOB_TRIGGER_I_FLAG_NOT_SET, // Flags.
        TASK_TIME_TRIGGER_DAILY,    // Trigger type.
        1,                          // Trigger union.
        0,                          // Reserved2. Unused.
        0                           // Random minutes interval.
    };

    CTrigger * pt = new CTrigger(jt.Reserved1, this);

    if (pt == NULL)
    {
        CHECK_HRESULT(E_OUTOFMEMORY);
        return(E_OUTOFMEMORY);
    }

    HRESULT hr = m_Triggers.Add(jt);

    if (FAILED(hr))
    {
        delete pt;
        CHECK_HRESULT(hr);
        return(hr);
    }

    this->SetFlag(JOB_I_FLAG_PROPERTIES_DIRTY);
    this->SetTriggersDirty();

    *piNewTrigger = jt.Reserved1;
    *ppTrigger    = pt;

    return(hr);
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::DeleteTrigger
//
//  Synopsis:   Remove a run trigger.
//
//  Arguments:  [iTrigger] - the index of the trigger to be removed
//
//  Returns:    HRESULTS
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::DeleteTrigger(WORD iTrigger)
{
    TRACE3(CJob, DeleteTrigger)

    TASK_TRIGGER * pjt = this->_GetTrigger(iTrigger);

    if (pjt != NULL)
    {
        m_Triggers.Remove(iTrigger);

        // Fixup remaining indices to account for deletion.
        //
        for (WORD i = iTrigger; i < m_Triggers.GetCount(); i++)
        {
            m_Triggers[i].Reserved1--;
        }

        this->SetTriggersDirty();

        if (!m_Triggers.GetCount())
        {
            this->ClearFlag(JOB_I_FLAG_HAS_TRIGGERS);
        }

        return(S_OK);
    }
    else
    {
        return(SCHED_E_TRIGGER_NOT_FOUND);
    }
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::_GetTrigger, private
//
//  Synopsis:   Return the TASK_TRIGGER associated with the index. The
//              TASK_TRIGGER reserved field specifies the trigger index.
//
//  Arguments:  [iTrigger] -- Trigger index.
//
//  Returns:    TASK_TRIGGER * -- Trigger found.
//              NULL           -- Trigger not found.
//
//-----------------------------------------------------------------------------
TASK_TRIGGER *
CJob::_GetTrigger(WORD iTrigger)
{
    for (WORD i = 0; i < m_Triggers.GetCount(); i++)
    {
        if (m_Triggers[i].Reserved1 == iTrigger)
        {
            return(&m_Triggers[i]);
        }
    }

    return(NULL);
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::GetTriggerCount
//
//  Synopsis:   Return the count of run triggers.
//
//  Arguments:  [pwCount] - the address where the count is to be returned
//
//  Returns:    HRESULTS
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::GetTriggerCount(WORD * pwCount)
{
    TRACE3(CJob, GetTriggerCount)

    *pwCount = m_Triggers.GetCount();

    return(S_OK);
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::GetTrigger
//
//  Synopsis:   Return an ITaskTrigger pointer to the indicated trigger.
//
//  Arguments:  [iTrigger] - the index of the trigger to fetch
//              [ppTrigger] - the returned trigger pointer
//
//  Returns:    HRESULTS
//
//  Notes:      The trigger is AddRef'd in GetTriggerObj(m_Triggers.GetTrigger)
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::GetTrigger(WORD iTrigger, ITaskTrigger ** ppTrigger)
{
    TRACE3(CJob, GetTrigger)

    *ppTrigger = NULL;              // Init in case of error.

    TASK_TRIGGER * pjt = this->_GetTrigger(iTrigger);

    if (pjt != NULL)
    {
        CTrigger * pt = new CTrigger(iTrigger, this);

        if (pt == NULL)
        {
            CHECK_HRESULT(E_OUTOFMEMORY);
            return(E_OUTOFMEMORY);
        }

        *ppTrigger = pt;
        return(S_OK);
    }

    return(SCHED_E_TRIGGER_NOT_FOUND);
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::GetTriggerString
//
//  Synopsis:   Return the indicated run trigger as a string.
//
//  Arguments:  [iTrigger]     - the index of the trigger to convert
//              [ppwszTrigger] - the returned string buffer
//
//  Returns:    HRESULTS
//
//  Notes:      The string is callee allocated and caller freed with
//              CoTaskMemFree.
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::GetTriggerString(WORD iTrigger, LPWSTR * ppwszTrigger)
{
    TRACE3(CJob, GetTriggerString)

    *ppwszTrigger = NULL;           // Init in case of error.

    TASK_TRIGGER * pjt = this->_GetTrigger(iTrigger);

    if (pjt != NULL)
    {
        return(::StringFromTrigger(pjt, ppwszTrigger, NULL));
    }

    return(SCHED_E_TRIGGER_NOT_FOUND);
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::SetApplicationName
//
//  Synopsis:   Set the Application Name String property
//
//  Arguments:  [pwszApplicationName] - the name of the app to execute.
//
//  Returns:    HRESULTS
//
//  Notes:      The string is caller allocated and freed.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::SetApplicationName(LPCWSTR pwszApplicationName)
{
    TRACE3(CJob, SetApplicationName)

    //
    // We don't use a try/catch
    // because the COM interface runs in the caller's context and it is their
    // responsibility to ensure good params. This latter statement is true for
    // all scheduler COM interface methods.
    //
    if (*pwszApplicationName == L'\0')
    {
        //
        // The caller wants the command set to an empty string.
        //

        ClearFlag(JOB_I_FLAG_HAS_APPNAME);

        //
        // We are using a null pointer for an empty string as an optimization.
        //
        if (m_pwszApplicationName == NULL)
        {
            //
            // Nothing to do.
            //
            return S_OK;
        }
        else
        {
            //
            // Setting this flag will instruct the persist code to
            // regenerate a GUID for this job. This is done for security
            // reasons.
            //
            // NB : This must be done for Win95 as well as NT.
            //

            SetFlag(JOB_I_FLAG_APPNAME_CHANGE);

            DELETE_CJOB_FIELD(m_pwszApplicationName);
            //
            // We want this change to trigger a wait list rebuild.
            //
            SetFlag(JOB_I_FLAG_RUN_PROP_CHANGE);
        }
    }
    else
    {
        //
        // Update the flags and status.
        //
        SetFlag(JOB_I_FLAG_HAS_APPNAME);

        if (IsStatus(SCHED_S_TASK_NOT_SCHEDULED))
        {
            //
            // Note that if the status went from SCHED_S_TASK_NOT_SCHEDULED to
            // SCHED_S_TASK_HAS_NOT_RUN or SCHED_S_TASK_READY, then we
            // want CheckDir to issue a wait list rebuild because the job has
            // gone from a non-runable to a runable state. Thus, in the if
            // clause below we set JOB_I_FLAG_RUN_PROP_CHANGE.
            //
            if (IsFlagSet(JOB_I_FLAG_HAS_TRIGGERS) &&
                !IsFlagSet(JOB_I_FLAG_NO_VALID_TRIGGERS))
            {
                if (m_stMostRecentRunTime.wYear == 0)
                {
                    //
                    // Job has never run if last-run-time property is null
                    // (all elements will be zero if null, testing year is
                    // sufficient).
                    //
                    SetStatus(SCHED_S_TASK_HAS_NOT_RUN);
                }
                else
                {
                    //
                    // Job has run in the past, so it is now waiting to run
                    // again.
                    //
                    SetStatus(SCHED_S_TASK_READY);
                }
                //
                // We want this change to trigger a wait list rebuild.
                //
                SetFlag(JOB_I_FLAG_RUN_PROP_CHANGE);
            }
        }

        TCHAR tszAppName[MAX_PATH];

        if (IsLocalFilename(m_ptszFileName))
        {
#if defined(UNICODE)
            lstrcpyn(tszAppName, pwszApplicationName, MAX_PATH);

            ProcessApplicationName(tszAppName,
                                   m_pwszWorkingDirectory ?
                                      m_pwszWorkingDirectory :
                                      wszEmpty);
#else
            UnicodeToAnsi(tszAppName, pwszApplicationName, MAX_PATH);

            CHAR szWorkingDir[MAX_PATH] = "";

            if (m_pwszWorkingDirectory)
            {
                UnicodeToAnsi(szWorkingDir, m_pwszWorkingDirectory, MAX_PATH);
            }

            ProcessApplicationName(tszAppName, szWorkingDir);
#endif // defined(UNICODE)
        }
        else
        {
#if defined(UNICODE)
            lstrcpyn(tszAppName, pwszApplicationName, MAX_PATH);
#else
            UnicodeToAnsi(tszAppName, pwszApplicationName, MAX_PATH);
#endif // defined(UNICODE)
            StripLeadTrailSpace(tszAppName);
            DeleteQuotes(tszAppName);
        }

        //
        // Allocate a new string, adding one for the null terminator
        //

        ULONG  cchAppName = lstrlen(tszAppName) + 1;
        LPWSTR pwszTmp = new WCHAR[cchAppName];

        if (pwszTmp == NULL)
        {
            ERR_OUT("CJob::SetApplicationName", E_OUTOFMEMORY);
            return E_OUTOFMEMORY;
        }

#if defined(UNICODE)
        lstrcpy(pwszTmp, tszAppName);
#else
        HRESULT hr = AnsiToUnicode(pwszTmp, tszAppName, cchAppName);

        if (FAILED(hr))
        {
            delete pwszTmp;
            return hr;
        }
#endif // defined(UNICODE)

        //
        // Setting this flag will instruct the persist code to
        // regenerate a GUID for this job. This is done for security
        // reasons.
        //
        // NB : This must be done for Win95 as well as NT.
        //
        // Ensure first, that the application has indeed changed.
        //

        if (m_pwszApplicationName != NULL && lstrcmpiW(
                                                m_pwszApplicationName,
                                                pwszTmp) != 0)
        {
            SetFlag(JOB_I_FLAG_APPNAME_CHANGE);
        }

        DELETE_CJOB_FIELD(m_pwszApplicationName);
        m_pwszApplicationName = pwszTmp;
    }

    SetFlag(JOB_I_FLAG_PROPERTIES_DIRTY);

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::GetApplicationName
//
//  Synopsis:   Get the ApplicationName String property
//
//  Arguments:  [ppwszApplicationName] - the returned string buffer
//
//  Returns:    HRESULTS
//
//  Notes:      The command string is passed to CreateProcess to be executed
//              at task run time.
//              The string is callee allocated and caller freed with
//              CoTaskMemFree.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::GetApplicationName(LPWSTR * ppwszApplicationName)
{
    TRACE3(CJob, GetApplicationName)
    WCHAR * pwszCmd;

    if (m_pwszApplicationName == NULL)
    {
        //
        // Return an empty string rather than a null pointer
        //
        pwszCmd = wszEmpty;
    }
    else
    {
        pwszCmd = m_pwszApplicationName;
    }

    // add one for the null.
    *ppwszApplicationName = (LPWSTR)CoTaskMemAlloc((s_wcslen(pwszCmd) + 1) *
                                           sizeof(WCHAR));

    if (*ppwszApplicationName == NULL)
    {
        return E_OUTOFMEMORY;
    }

    s_wcscpy(*ppwszApplicationName, pwszCmd);

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::SetParameters
//
//  Synopsis:   Set the Parameters String property
//
//  Arguments:  [pwszParameters] - the application parameters string
//
//  Returns:    HRESULTS
//
//  Notes:      The Parameters string is appended to the Application Name and
//              passed to CreateProcess as the command line to be executed at
//              task run time.
//              The string is caller allocated and freed.
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::SetParameters(LPCWSTR pwszParameters)
{
    TRACE3(CJob, SetParameters)

    if (*pwszParameters == L'\0')
    {
        //
        // The caller wants the Parameters set to an empty string.
        //
        // We are using a null pointer for an empty string as an optimization.
        //
        DELETE_CJOB_FIELD(m_pwszParameters);
    }
    else
    {
        //
        // Allocate a new string, adding one for the null terminator
        //
        LPWSTR pwszTmp = new WCHAR[s_wcslen(pwszParameters) + 1];
        if (pwszTmp == NULL)
        {
            ERR_OUT("CJob::SetParameters", E_OUTOFMEMORY);
            return E_OUTOFMEMORY;
        }

        s_wcscpy(pwszTmp, pwszParameters);

        DELETE_CJOB_FIELD(m_pwszParameters);

        m_pwszParameters = pwszTmp;
    }
    SetFlag(JOB_I_FLAG_PROPERTIES_DIRTY);
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::GetParameters
//
//  Synopsis:   Get the Parameters String property
//
//  Arguments:  [ppwszParameters] - the returned string buffer
//
//  Returns:    HRESULTS
//
//  Notes:      The Parameters string is appended to the Application Name and
//              passed to CreateProcess as the command line to be executed at
//              task run time.
//              The string is callee allocated and caller freed with
//              CoTaskMemFree.
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::GetParameters(LPWSTR * ppwszParameters)
{
    TRACE3(CJob, GetParameters)
    WCHAR * pwszTmp;

    if (m_pwszParameters == NULL)
    {
        //
        // Return an empty string rather than a null pointer
        //
        pwszTmp = wszEmpty;
    }
    else
    {
        pwszTmp = m_pwszParameters;
    }

    // add one for the null.
    *ppwszParameters = (LPWSTR)CoTaskMemAlloc((s_wcslen(pwszTmp) + 1) *
                                           sizeof(WCHAR));

    if (*ppwszParameters == NULL)
    {
        return E_OUTOFMEMORY;
    }

    s_wcscpy(*ppwszParameters, pwszTmp);

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::SetWorkingDirectory
//
//  Synopsis:   Set the Working Directory (current directory) property
//
//  Arguments:  [pwszWorkingDir] - the name to use
//
//  Returns:    HRESULTS
//
//  Notes:      The string is caller allocated and freed
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::SetWorkingDirectory(LPCWSTR pwszWorkingDirectory)
{
    TRACE3(CJob, SetWorkingDirectory)

    if (*pwszWorkingDirectory == L'\0')
    {
        //
        // The caller wants the WorkingDirectory set to an empty string.
        //
        DELETE_CJOB_FIELD(m_pwszWorkingDirectory);
    }
    else
    {
        //
        // Allocate a new string, adding one for the null terminator
        //
        LPWSTR pwszTmp = new WCHAR[s_wcslen(pwszWorkingDirectory) + 1];
        if (pwszTmp == NULL)
        {
            ERR_OUT("CJob::SetWorkingDirectory", E_OUTOFMEMORY);
            return E_OUTOFMEMORY;
        }

        s_wcscpy(pwszTmp, pwszWorkingDirectory);

        DELETE_CJOB_FIELD(m_pwszWorkingDirectory);

        m_pwszWorkingDirectory = pwszTmp;

        //
        // Remove double quotes from working directory path; they're not supported
        // by SetCurrentDirectory.
        //

#if defined(UNICODE)
        DeleteQuotes(m_pwszWorkingDirectory);
#else
        CHAR szWorkingDir[2 * MAX_PATH] = "";

        UnicodeToAnsi(szWorkingDir, m_pwszWorkingDirectory, 2 * MAX_PATH);
        DeleteQuotes(szWorkingDir);
        AnsiToUnicode(m_pwszWorkingDirectory,
                      szWorkingDir,
                      wcslen(m_pwszWorkingDirectory) + 1);
#endif // defined(UNICODE)

    }

    SetFlag(JOB_I_FLAG_PROPERTIES_DIRTY);
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::GetWorkingDir
//
//  Synopsis:   Get the Working Directory (current directory) property
//
//  Arguments:  [ppwszWorkingDirectory] - the returned string buffer
//
//  Returns:    HRESULTS
//
//  Notes:      The string is callee allocated and caller freed with
//              CoTaskMemFree.
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::GetWorkingDirectory(LPWSTR * ppwszWorkingDirectory)
{
    TRACE3(CJob, GetWorkingDirectory)
    WCHAR * pwszWorkingDir;

    if (m_pwszWorkingDirectory == NULL)
    {
        //
        // Return an empty string rather than a null pointer
        //
        pwszWorkingDir = wszEmpty;
    }
    else
    {
        pwszWorkingDir = m_pwszWorkingDirectory;
    }

    // add one for the null.
    *ppwszWorkingDirectory = (LPWSTR)CoTaskMemAlloc(
                               (s_wcslen(pwszWorkingDir) + 1) * sizeof(WCHAR));

    if (*ppwszWorkingDirectory == NULL)
    {
        return E_OUTOFMEMORY;
    }

    s_wcscpy(*ppwszWorkingDirectory, pwszWorkingDir);

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::SetComment
//
//  Synopsis:   Set the comment field.
//
//  Arguments:  [pwszComment] - the comment string value, caller alloc'd and
//                              freed
//
//  Returns:    HRESULTS
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::SetComment(LPCWSTR pwszComment)
{
    TRACE3(CJob, SetComment)

    if (*pwszComment == L'\0')
    {
        //
        // The caller wants the Comment set to an empty string.
        //
        DELETE_CJOB_FIELD(m_pwszComment);
    }
    else
    {
        //
        // Allocate a new string, adding one for the null terminator
        //
        LPWSTR pwszTmp = new WCHAR[s_wcslen(pwszComment) + 1];
        if (pwszTmp == NULL)
        {
            ERR_OUT("CJob::SetComment", E_OUTOFMEMORY);
            return E_OUTOFMEMORY;
        }

        s_wcscpy(pwszTmp, pwszComment);

        DELETE_CJOB_FIELD(m_pwszComment);

        m_pwszComment = pwszTmp;
    }

    SetFlag(JOB_I_FLAG_PROPERTIES_DIRTY);
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::GetComment
//
//  Synopsis:   Get the comment field property.
//
//  Arguments:  [ppwszComment] - the returned string buffer
//
//  Returns:    HRESULTS
//
//  Notes:      The string is callee allocated and caller freed with
//              CoTaskMemFree.
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::GetComment(LPWSTR * ppwszComment)
{
    TRACE3(CJob, GetComment)
    WCHAR * pwszCmt;

    if (m_pwszComment == NULL)
    {
        //
        // Return an empty string rather than a null pointer
        //
        pwszCmt = wszEmpty;
    }
    else
    {
        pwszCmt = m_pwszComment;
    }

    // add one for the null.
    *ppwszComment = (LPWSTR)CoTaskMemAlloc((s_wcslen(pwszCmt) + 1) *
                                           sizeof(WCHAR));

    if (*ppwszComment == NULL)
    {
        return E_OUTOFMEMORY;
    }

    s_wcscpy(*ppwszComment, pwszCmt);

    return S_OK;
}

#if !defined(_CHICAGO_)
//+----------------------------------------------------------------------------
//
//  Member:     CJob::_SetSignature
//
//  Synopsis:   Set the job's signature.
//
//  Arguments:  [pbSignature] - assumed to be SIGNATURE_SIZE bytes long.
//
//  Returns:    HRESULTS
//
//-----------------------------------------------------------------------------
HRESULT
CJob::_SetSignature(const BYTE * pbSignature)
{
    TRACE3(CJob, SetSignature)

    LPBYTE pb = new BYTE[SIGNATURE_SIZE];

    if (pb == NULL)
    {
        ERR_OUT("CJob::SetSignature", E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }

    CopyMemory(pb, pbSignature, SIGNATURE_SIZE);

    DELETE_CJOB_FIELD(m_pbSignature);

    m_pbSignature = pb;

    SetFlag(JOB_I_FLAG_PROPERTIES_DIRTY);
    return S_OK;
}
#endif // !defined(_CHICAGO_)

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::SetPriority
//
//  Synopsis:   Set the priority property
//
//  Arguments:  [dwPriority] - the priority value
//
//  Returns:    HRESULTS
//
//  Notes:      Controls the priority at which the job will run. Applies to NT
//              only, a no-op on Win95. This must be one of the four values
//              from CreateProcess's priority class.
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::SetPriority(DWORD dwPriority)
{
    TRACE3(CJob, SetPriority)
    //
    // Check for valid priority values
    //
    switch (dwPriority)
    {
    case IDLE_PRIORITY_CLASS:
    case NORMAL_PRIORITY_CLASS:
    case HIGH_PRIORITY_CLASS:
    case REALTIME_PRIORITY_CLASS:
        break;

    default:
        return E_INVALIDARG;
    }

    m_dwPriority = dwPriority;

    SetFlag(JOB_I_FLAG_PROPERTIES_DIRTY);
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::GetPriority
//
//  Synopsis:   Get the priority property
//
//  Arguments:  [pdwPriority] - priority return address
//
//  Returns:    HRESULTS
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::GetPriority(DWORD * pdwPriority)
{
    TRACE3(CJob, GetPriority)

    *pdwPriority = m_dwPriority;

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::SetMaxRunTime
//
//  Synopsis:   Set the MaximumRunTime property
//
//  Arguments:  [dwMaxRunTime] - new MaxRunTime value in milliseconds
//
//  Returns:    HRESULTS
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::SetMaxRunTime(DWORD dwMaxRunTime)
{
    TRACE3(CJob, SetMaxRunTime)

    m_dwMaxRunTime = dwMaxRunTime;

    // Cause a wait list rebuild
    SetFlag(JOB_I_FLAG_PROPERTIES_DIRTY | JOB_I_FLAG_RUN_PROP_CHANGE);

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::GetMaxRunTime
//
//  Synopsis:   Get the MaximumRunTime property
//
//  Arguments:  [pdwMaxRunTime] - MaxRunTime return address (milliseconds)
//
//  Returns:    HRESULTS
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::GetMaxRunTime(DWORD * pdwMaxRunTime)
{
    TRACE3(CJob, GetMaxRunTime)

    *pdwMaxRunTime = m_dwMaxRunTime;

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::SetFlags
//
//  Synopsis:   Set the bit flags for the various boolean properties
//
//  Arguments:  [fLogConfig] - Boolean: should changes be logged true/false.
//
//  Returns:    HRESULTS
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::SetFlags(DWORD rgFlags)
{
    TRACE3(CJob, SetFlags)

    if ((rgFlags ^ m_rgFlags) &
        (TASK_FLAG_DISABLED                     |
         TASK_FLAG_START_ONLY_IF_IDLE           |
         TASK_FLAG_KILL_ON_IDLE_END             |
         TASK_FLAG_DONT_START_IF_ON_BATTERIES   |
         TASK_FLAG_KILL_IF_GOING_ON_BATTERIES   |
         TASK_FLAG_RUN_ONLY_IF_DOCKED           |
         TASK_FLAG_RUN_IF_CONNECTED_TO_INTERNET |
         TASK_FLAG_RESTART_ON_IDLE_RESUME       |
         TASK_FLAG_SYSTEM_REQUIRED))
    {
        //
        // If any flag that could affect the CRun objects in the wait
        // list has changed, signal a wait list rebuild.
        // (Omitted flags: TASK_FLAG_HIDDEN, TASK_FLAG_INTERACTIVE,
        //   TASK_FLAG_DELETE_WHEN_DONE)
        // CODEWORK  Possible optimization: Omit some more flags and
        // defer reading their settings into the CRun object until the
        // time of running the job
        //
        SetFlag(JOB_I_FLAG_RUN_PROP_CHANGE);
    }

    //
    // Only set the lower word of the internal flag property. The upper word
    // is reserved for internal use.
    //
    rgFlags &= ~JOB_INTERNAL_FLAG_MASK;
    m_rgFlags &= JOB_INTERNAL_FLAG_MASK;
    SetFlag(rgFlags);

    SetFlag(JOB_I_FLAG_PROPERTIES_DIRTY);
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::GetFlags
//
//  Synopsis:   Get the bit flags for the various boolean properties
//
//  Arguments:  [prgFlags] - returned value placed here
//
//  Returns:    HRESULTS
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::GetFlags(DWORD * prgFlags)
{
    TRACE3(CJob, GetFlags)

    //
    // Only return the lower word of the internal flag property. The upper
    // word is reserved for internal use.
    // Also return whether this is an At job.
    //
    *prgFlags = m_rgFlags & (~JOB_INTERNAL_FLAG_MASK | JOB_I_FLAG_NET_SCHEDULE);

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::SetTaskFlags
//
//  Synopsis:   Sets the job's task flags.
//
//  Arguments:  [dwFlags] - flags to be set.
//
//  Returns:    S_OK
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::SetTaskFlags(DWORD dwFlags)
{
    TRACE3(CJob, SetTaskFlags)

    //
    // Only set the lower word of the internal flag property. The upper word
    // is reserved for internal use.
	// BUGBUG  return an error on invalid flag bits
    //
    m_rgTaskFlags = (m_rgTaskFlags & JOB_INTERNAL_FLAG_MASK) |
                    (dwFlags & ~JOB_INTERNAL_FLAG_MASK);

    SetFlag(JOB_I_FLAG_PROPERTIES_DIRTY);
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::GetTaskFlags
//
//  Synopsis:   Returns the job's task flags.
//
//  Arguments:  [pdwFlags] - return value pointer.
//
//  Returns:    HRESULTS
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::GetTaskFlags(DWORD * pdwFlags)
{
    TRACE3(CJob, GetTaskFlags)

    //
    // Only return the lower word of the internal flag property. The upper
    // word is reserved for internal use.
    //
    *pdwFlags = m_rgTaskFlags & ~JOB_INTERNAL_FLAG_MASK;

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::SetWorkItemData
//
//  Synopsis:   Sets the task data. Provides optional, per-task, binary
//              storage for the caller.
//
//  Arguments:  [cbData]  -- number of bytes in buffer.
//              [rgbData] -- buffer of data to copy.
//
//  Returns:    S_OK
//              E_INVALIDARG
//              E_OUTOFMEMORY
//
//  Notes:      The buffer is caller allocated and freed.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::SetWorkItemData(WORD cbData, BYTE rgbData[])
{
    TRACE3(CJob, SetWorkItemData)

    if ((cbData != 0 && rgbData == NULL) ||
        cbData == 0 && rgbData != NULL)
    {
        return E_INVALIDARG;
    }

    BYTE * pbData;

    if (cbData)
    {
        pbData = new BYTE[cbData];

        if (pbData == NULL)
        {
            return E_OUTOFMEMORY;
        }

        CopyMemory(pbData, rgbData, cbData);
    }
    else
    {
        pbData = NULL;
    }

    DELETE_CJOB_FIELD(m_pbTaskData);
    m_pbTaskData = pbData;
    m_cbTaskData = cbData;

    SetFlag(JOB_I_FLAG_PROPERTIES_DIRTY);

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::GetWorkItemData
//
//  Synopsis:   Gets the task data.
//
//  Arguments:  [pcbData]  -- returns the number of bytes in buffer.
//              [prgbData] -- returns the buffer of data.
//
//  Returns:    S_OK for success.
//              E_INVALIDARG
//              E_OUTOFMEMORY.
//
//  Notes:      The buffer is callee allocated and caller freed with
//              CoTaskMemFree. If there is no user data, then *pcBytes is set
//              to zero and *ppBytes is set to NULL.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::GetWorkItemData(PWORD pcbData, PBYTE * prgbData)
{
    TRACE3(CJob, GetWorkItemData)

    if (m_pbTaskData != NULL)
    {
        *prgbData = (PBYTE)CoTaskMemAlloc(m_cbTaskData);

        if (*prgbData == NULL)
        {
            return E_OUTOFMEMORY;
        }

        CopyMemory(*prgbData, m_pbTaskData, m_cbTaskData);
        *pcbData = m_cbTaskData;
    }
    else
    {
        *pcbData  = 0;
        *prgbData = NULL;
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::GetMostRecentRunTime
//
//  Synopsis:   Returns the time that the job last ran.
//
//  Arguments:  [pstLastRun] - value returned here.
//
//  Returns:    HRESULTS
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::GetMostRecentRunTime(SYSTEMTIME * pstLastRun)
{
    TRACE3(CJob, GetLastRunTime)

    *pstLastRun = m_stMostRecentRunTime;

    if (m_stMostRecentRunTime.wYear == 0)
    {
        //
        // Job has never run if last-run-time property is null
        // (all elements will be zero if null, testing year is
        // sufficient).
        //
        return SCHED_S_TASK_HAS_NOT_RUN;
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::GetNextRunTime
//
//  Synopsis:   Returns the next time that the job is scheduled to run.
//
//  Arguments:  [pstNextRun] - pointer to return value through
//
//  Returns:    S_OK: the next run time was returned.
//              S_FALSE: there are no more scheduled runs.
//              SCHED_S_EVENT_TRIGGER: there are only event triggers.
//              SCHED_S_TASK_NO_VALID_TRIGGERS: either there are no triggers or
//                  the triggers are disabled or not set.
//              HRESULT - failure code.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::GetNextRunTime(SYSTEMTIME * pstNextRun)
{
    TRACE3(CJob, GetNextRunTime)

    HRESULT hr;
    SYSTEMTIME stNow, stEmpty = { 0, 0, 0, 0, 0, 0, 0, 0 };
    GetLocalTime(&stNow);

    CTimeRunList RunList;

    WORD cRuns = 0;

    hr = GetRunTimesP(&stNow, NULL, &cRuns, 1, &RunList, NULL);

    if (S_OK != hr)
    {
        *pstNextRun = stEmpty;
        return hr;
    }
    else if (cRuns == 0)
    {
        *pstNextRun = stEmpty;
        return S_FALSE;
    }

    FILETIME ft;
    RunList.PeekHeadTime(&ft);

    if (!FileTimeToSystemTime(&ft, pstNextRun))
    {
        *pstNextRun = stEmpty;
        return HRESULT_FROM_WIN32(GetLastError());
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::GetExitCode
//
//  Synopsis:   Returns the exit code of the jobs last run.
//
//  Arguments:  [pExitCode] - return value pointer.
//
//  Returns:    HRESULT - error from the last attempt to start the job.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::GetExitCode(DWORD * pExitCode)
{
    TRACE3(CJob, GetExitCode)

    *pExitCode = m_ExitCode;

    return m_hrStartError;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::GetStatus
//
//  Synopsis:   Returns the current status of this job object.
//
//  Arguments:  [phrStatus] - yup, the return value.
//
//  Returns:    HRESULTS
//
//  Notes:      The running status is implicit in a non-zero instance count.
//              Otherwise, return the status property. Note also that the
//              job's status and other properties that are obtained by the
//              load from disk are a snapshot that can become stale.
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::GetStatus(HRESULT * phrStatus)
{
    TRACE3(CJob, GetStatus)

    if (m_cRunningInstances > 0)
    {
        *phrStatus = SCHED_S_TASK_RUNNING;
    }
    else
    {
        *phrStatus = m_hrStatus;
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::SetCreator
//
//  Synopsis:   Set the creator property.
//
//  Arguments:  [pwszCreator] -- Creator string.
//
//  Returns:    S_OK
//              E_INVALIDARG
//              E_OUTOFMEMORY
//
//  Notes:      None.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::SetCreator(LPCWSTR pwszCreator)
{
    TRACE3(CJob, SetCreator);

    LPWSTR pwsz;

    //
    // Handle empty string.
    //

    if (*pwszCreator)
    {
        pwsz = new WCHAR[wcslen(pwszCreator) + 1];

        if (pwsz == NULL)
        {
            return E_OUTOFMEMORY;
        }

        s_wcscpy(pwsz, pwszCreator);
    }
    else
    {
        pwsz = NULL;
    }

    DELETE_CJOB_FIELD(m_pwszCreator);

    m_pwszCreator = pwsz;

    SetFlag(JOB_I_FLAG_PROPERTIES_DIRTY);

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::GetCreator
//
//  Synopsis:   Fetch the creator property.
//
//  Arguments:  [ppwszCreator] -- Returned string.
//
//  Returns:    S_OK
//              E_INVALIDARG
//              E_OUTOFMEMORY
//
//  Notes:      None.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::GetCreator(LPWSTR * ppwszCreator)
{
    TRACE3(CJob, GetCreator);

    //
    // Handle empty string.
    //

    LPWSTR pwsz = (m_pwszCreator == NULL ? wszEmpty : m_pwszCreator);

    *ppwszCreator = (LPWSTR)CoTaskMemAlloc(
                            (s_wcslen(pwsz) + 1) * sizeof(WCHAR));

    if (*ppwszCreator == NULL)
    {
        return E_OUTOFMEMORY;
    }

    s_wcscpy(*ppwszCreator, pwsz);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\inc\resource.h ===
//+----------------------------------------------------------------------------
//
//  Job Scheduler Object Handler
//
//	Microsoft Windows
//	Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       resource.h
//
//  Contents:   resource IDs
//
//	History:	23-May-95 EricB created
//
//-----------------------------------------------------------------------------

#ifndef __RESOURCE_H__
#define __RESOURCE_H__

#define IDI_JOBSFLD                         100
#define IDI_JOB                             101
#define IDI_QUEUE                           102
#define IDI_SCHEDULER                       103

// string IDs

#define IDS_STATUS_WAITING				    0
#define IDS_STATUS_RUNNING				    1
#define IDS_STATUS_SUSPENDED			    2
#define IDS_STATUS_ABORTED				    3
#define IDS_STATUS_NEVER_RUN			    4
#define IDS_STATUS_ERROR_CANT_RUN		    5
#define IDS_STATUS_ERROR_FROM_RUN		    6
// note that 0x20 through 0x100 are reserved for the priority class strings
#define IDS_MULTIPLE_SELECTED               1034
#define IDS_DAILY                           1067
#define IDS_WEEKLY                          1068
#define IDS_MONTHLY                         1069
#define IDS_EVERY                           1070
#define IDS_EVERYOTHER                      1071
#define IDS_EVERY3RD                        1072
#define IDS_EVERY4TH                        1073
#define IDS_EVERY5TH                        1074
#define IDS_EVERY6TH                        1075
#define IDS_EVERY12TH                       1076
#define IDS_HOURS                           1077
#define IDS_MINUTES                         1078
#define IDS_FIRST                           1079
#define IDS_SECOND                          1080
#define IDS_THIRD                           1081
#define IDS_LAST                            1083
#define IDS_FORTH                           1082
#define IDS_DAY                             1084
#define IDS_SCHEDULER_NAME                  1085
#define IDS_IDLE_TRIGGER                    1090
#define IDS_STARTUP_TRIGGER                 1091
#define IDS_RESUME_TRIGGER                  1092
#define IDS_ONCE_DAY_FORMAT                 1093
#define IDS_MULTI_DAILY_FORMAT              1094
#define IDS_HAS_END_DATE_FORMAT             1095
#define IDS_NO_END_DATE_FORMAT              1096
#define IDS_HOURS_PAREN                     1097
#define IDS_MINUTES_PAREN                   1098
#define IDS_NETSCHED_COMMENT                1099
#define IDS_LOG_SEVERITY_WARNING            1100
#define IDS_LOG_SEVERITY_ERROR              1101
#define IDS_LOG_JOB_STATUS_STARTED          1102
#define IDS_LOG_JOB_STATUS_FINISHED         1103
#define IDS_LOG_JOB_STATUS_STARTED_NO_STOP  1104
#define IDS_LOG_JOB_ERROR_FAILED_START      1105
#define IDS_LOG_JOB_RESULT_FINISHED         1106
//#define           1107
//#define             1108
#define IDS_LOG_JOB_EXIT_CODE_MSG_NOT_FOUND 1109
#define IDS_RUNS_ONCE_FORMAT                1110
#define IDS_DAILY_FORMAT                    1111
#define IDS_EVERY_DAY                       1112
#define IDS_LIST_SEP                        1113
#define IDS_EVERY_WEEK_FORMAT               1114
#define IDS_WEEKLY_FORMAT                   1115
#define IDS_EVERY_MONTHLYDATE_FORMAT        1116
#define IDS_MONTHLYDATE_FORMAT              1117
#define IDS_EVERY_MONTHLYDOW_FORMAT         1118
#define IDS_MONTHLYDOW_FORMAT               1119
#define IDS_YEARLYDATE_FORMAT               1120
#define IDS_YEARLYDOW_FORMAT                1121
#define IDS_MULTI_DURATION_FORMAT           1122
#define IDS_TRIGGER_NOT_SET                 1123
#define IDS_EVERY_MONTHLYDATE_FORMAT_ETC    1124
#define IDS_MONTHLYDATE_FORMAT_ETC          1125
#define IDS_ERRMSG_PREFIX                   1126
#define IDS_NOT_FROM_CMD_LINE               1127
#define IDS_ONE_INSTANCE                    1128
#define IDS_BUILD_VERSION                   1129
#define IDS_LOGON_TRIGGER                   1130
#define IDS_LOG_JOB_WARNING_BAD_DIR         1131
#define IDS_LOG_JOB_WARNING_NOT_IDLE        1132
#define IDS_LOG_JOB_WARNING_ON_BATTERIES    1133
#define IDS_LOG_SERVICE_ERROR               1134
#define IDS_HELP_HINT_SEC_WRITE             1135
#define IDS_LOG_SERVICE_TITLE               1136
#define IDS_LOG_SERVICE_STARTED             1137
#define IDS_LOG_SERVICE_EXITED              1138
#define IDS_CRITICAL_ERROR                  1139
#define IDS_HELP_HINT_BADDIR                1141
#define IDS_LOG_JOB_WARNING_ABORTED         1142
#define IDS_LOG_JOB_WARNING_TIMEOUT         1143
#define IDS_LOG_EXIT_CODE_MSG_NOT_FOUND     1144
#define IDS_ERROR_FORMAT_WCODE_WHELP_I      1145
#define IDS_ERROR_FORMAT_WCODE_WOHELP_I     1146
#define IDS_ERROR_FORMAT_WOCODE_WHELP_I     1147
#define IDS_ERROR_FORMAT_WOCODE_WOHELP_I    1148
#define IDS_ERROR_FORMAT_WCODE_WHELP        1149
#define IDS_ERROR_FORMAT_WCODE_WOHELP       1150
#define IDS_ERROR_FORMAT_WOCODE_WHELP       1151
#define IDS_ERROR_FORMAT_WOCODE_WOHELP      1152
#define IDS_ERROR_NUMBER_FORMAT             1153
#define IDS_GENERIC_ERROR_MSG               1154
#define IDS_HELP_HINT_BROWSE                1155
#define IDS_HELP_HINT_LOGON                 1156
#define IDS_ACCOUNT_LOGON_FAILED            1157
#define IDS_NS_ACCOUNT_LOGON_FAILED         1158
#define IDS_FILE_ACCESS_DENIED              1159
#define IDS_FILE_ACCESS_DENIED_HINT         1160
#define IDS_FAILED_ACCOUNT_RETRIEVAL        1161
#define IDS_FAILED_NS_ACCOUNT_RETRIEVAL     1162
#define IDS_INITIALIZATION_FAILURE          1163
#define IDS_FATAL_ERROR                     1164
#define IDS_NON_FATAL_ERROR                 1165
#define IDS_HELP_HINT_REINSTALL             1166
#define IDS_HELP_HINT_RESTARTWINDOWS        1167
#define IDS_HELP_HINT_CALLPSS               1168
#define IDS_HELP_HINT_CLOSE_APPS            1169
#define IDS_HELP_HINT_TIMEOUT               1170
#define IDS_LOG_JOB_WARNING_CANNOT_LOAD     1171
#define IDS_CANT_GET_EXITCODE               1172
#define IDS_CANT_DELETE_JOB                 1173
#define IDS_CANT_UPDATE_JOB                 1174
#define IDS_HELP_HINT_STARTSVC              1175
#define IDS_LOG_SERVICE_PAUSED              1176
#define IDS_LOG_SERVICE_CONTINUED           1177
#define IDS_LOG_RUNS_MISSED                 1178
#define IDS_POPUP_RUNS_MISSED               1179
#define IDS_POPUP_SERVICE_TITLE             1180

#define IDS_NEW_JOB                         3330
#define IDS_NEW_QUEUE                       3331
#define IDS_WHEN_IDLE                       3332
#define IDS_MOSTRECENTLOGENTRYMARKER        3333

#define IERR_SECURITY_WRITE_ERROR           3400
#define IERR_SECURITY_DBASE_CORRUPTION      3401
#define IDS_HELP_HINT_INVALID_ACCT          3402
#define IDS_HELP_HINT_DBASE_CORRUPT         3403
#define IDS_HELP_HINT_ACCESS_DENIED         3404
#define IDS_HELP_HINT_SEC_GENERAL           3405
#define IDS_HELP_HINT_PARAMETERS            3406

#define IDS_Friendly_Name		    3407
#define IDS_LOCALIZED_NAME		    3408

#endif  // __RESOURCE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\job\security.cxx ===
//+----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       security.cxx
//
//  Contents:
//
//  Classes:
//
//  Interfaces:
//
//  History:    06-Jul-96   MarkBl  Created.
//              03-Mar-01   JBenton Prefix Bug 350196
//                          invalid pointer could be dereferenced on cleanup
//
//-----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "common.hxx"
#include "debug.hxx"
#include "security.hxx"
#include "proto.hxx"

typedef struct _MYSIDINFO {
    PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority;
    DWORD                     dwSubAuthority;
    PSID                      pSid;
} MYSIDINFO;

#define TASK_ALL    (GENERIC_READ    | GENERIC_WRITE |  \
                     GENERIC_EXECUTE | GENERIC_ALL)
#define TASK_READ   (GENERIC_READ)

DWORD   AllocateAndInitializeDomainSid(
            PSID        pDomainSid,
            MYSIDINFO * pDomainSidInfo);
HRESULT GetFileOwnerSid(
            LPCWSTR pwszFileName,
            PSID *  ppSid);


//+---------------------------------------------------------------------------
//
//  Function:   SetTaskFileSecurity
//
//  Synopsis:   Grant the following permissions to the task object:
//
//                  LocalSystem             All Access.
//                  Creator                 All Access.
//                  Domain Admininstrators  All Access.
//
//  Arguments:  [fIsATTask]    -- TRUE if the task is an AT-submitted task;
//                                FALSE otherwise.
//              [pwszTaskPath] -- Task object path.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
SetTaskFileSecurity(LPCWSTR pwszTaskPath, BOOL fIsATTask)
{
#define BASE_SID_COUNT      2
#define DOMAIN_SID_COUNT    1
#define TASK_ACE_COUNT      3

    FILESYSTEMTYPE FileSystemType;
    HRESULT hr;

    hr = GetFileSystemTypeFromPath(pwszTaskPath, &FileSystemType);

    if (FAILED(hr))
    {
        return(hr);
    }

    if (FileSystemType == FILESYSTEM_FAT)
    {
        //
        // No security on FAT. This isn't an error. Let the caller
        // think everything went fine.
        //

        return(S_OK);
    }

    //
    // Retrieve the SID of the file owner.
    //

    PSID pOwnerSid = NULL;

    hr = GetFileOwnerSid(pwszTaskPath, &pOwnerSid);

    if (FAILED(hr))
    {
        return(hr);
    }

    //
    // OK, the fun begins. Build a security descriptor and set file security.
    //

    PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;
    DWORD                Status;

    SID_IDENTIFIER_AUTHORITY NtAuth         = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY CreatorSidAuth = SECURITY_CREATOR_SID_AUTHORITY;

    MYSIDINFO rgBaseSidInfo[BASE_SID_COUNT] = {
        { &NtAuth,                          // Local System.
          SECURITY_LOCAL_SYSTEM_RID,
          NULL },
        { &NtAuth,                          // Built in domain.
          SECURITY_BUILTIN_DOMAIN_RID,
          NULL }
    };

    MYSIDINFO rgDomainSidInfo[DOMAIN_SID_COUNT] = {
        { NULL,                             // Domain administrators.
          DOMAIN_ALIAS_RID_ADMINS,
          NULL }
    };

    SECURITY_INFORMATION si = DACL_SECURITY_INFORMATION;

    //
    // Make sure we didn't goof.
    //

    schAssert(BASE_SID_COUNT == (sizeof(rgBaseSidInfo) / sizeof(MYSIDINFO)));
    schAssert(DOMAIN_SID_COUNT == (sizeof(rgDomainSidInfo) /
                                                sizeof(MYSIDINFO)));

    //
    // Create the base SIDs.
    //

    DWORD i;

    for (i = 0; i < BASE_SID_COUNT; i++)
    {
        if (!AllocateAndInitializeSid(rgBaseSidInfo[i].pIdentifierAuthority,
                                      1,
                                      rgBaseSidInfo[i].dwSubAuthority,
                                      0, 0, 0, 0, 0, 0, 0,
                                      &rgBaseSidInfo[i].pSid))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            CHECK_HRESULT(hr);
            break;
        }

        if (!IsValidSid(rgBaseSidInfo[i].pSid))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            CHECK_HRESULT(hr);
            break;
        }
    }

    if (SUCCEEDED(hr))
    {
        //
        // Create the domain SIDs.
        //

        for (i = 0; i < DOMAIN_SID_COUNT; i++)
        {
            DWORD dwError = AllocateAndInitializeDomainSid(
                                                rgBaseSidInfo[1].pSid,
                                                &rgDomainSidInfo[i]);

            if (dwError != ERROR_SUCCESS)
            {
                hr = HRESULT_FROM_WIN32(dwError);
                CHECK_HRESULT(hr);
                break;
            }
        }
    }

    //
    // Create the security descriptor.
    //
    // Possibly adjust the array size to account for two special cases:
    //     1. If this job is an AT job, only local system and administrators
    //        are to have access; don't grant users access. This case
    //        also encompasses case (2).
    //     2. The owner sid and the domain administrator SID will be equal
    //        if the user is an admin. If the user is an admin, ignore the
    //        administrator setting.
    //

    DWORD ActualTaskAceCount;

    if (fIsATTask)
    {
        ActualTaskAceCount = TASK_ACE_COUNT - 1;
    }
    else if (EqualSid(pOwnerSid, rgDomainSidInfo[0].pSid))
    {
        ActualTaskAceCount = TASK_ACE_COUNT - 1;
    }
    else
    {
        ActualTaskAceCount = TASK_ACE_COUNT;
    }

    PACCESS_ALLOWED_ACE rgAce[TASK_ACE_COUNT] = {
        NULL, NULL, NULL                   // Supply this to CreateSD so we
    };                                      // so we don't have to allocate
                                            // memory.
    MYACE rgMyAce[TASK_ACE_COUNT] = {
        { TASK_ALL,                         // Acess mask.
          NO_PROPAGATE_INHERIT_ACE,         // Inherit flags.
          rgBaseSidInfo[0].pSid },          // SID.
        { TASK_ALL,
          NO_PROPAGATE_INHERIT_ACE,
          rgDomainSidInfo[0].pSid },
        { TASK_ALL,
          NO_PROPAGATE_INHERIT_ACE,
          pOwnerSid }
    };

    schAssert(TASK_ACE_COUNT == (sizeof(rgAce)/sizeof(PACCESS_ALLOWED_ACE)) &&
              TASK_ACE_COUNT == (sizeof(rgMyAce) / sizeof(MYACE)));

    if (FAILED(hr))
    {
        goto CleanExit;
    }

    if ((pSecurityDescriptor = CreateSecurityDescriptor(ActualTaskAceCount,
                                                        rgMyAce,
                                                        rgAce,
                                                        &Status)) == NULL)
    {
        hr = HRESULT_FROM_WIN32(Status);
        goto CleanExit;
    }

    //
    // Finally, set permissions.
    //

    if (!SetFileSecurity(pwszTaskPath, si, pSecurityDescriptor))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        CHECK_HRESULT(hr);
        goto CleanExit;
    }

CleanExit:
    delete pOwnerSid;
    for (i = 0; i < BASE_SID_COUNT; i++)
    {
        if (rgBaseSidInfo[i].pSid != NULL)
        {
            FreeSid(rgBaseSidInfo[i].pSid);
        }
    }
    for (i = 0; i < DOMAIN_SID_COUNT; i++)
    {
        if (rgDomainSidInfo[i].pSid != NULL)
        {
            delete rgDomainSidInfo[i].pSid;
        }
    }
    if (pSecurityDescriptor != NULL)
    {
        DeleteSecurityDescriptor(pSecurityDescriptor);
    }

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   AllocateAndInitializeDomainSid
//
//  Synopsis:
//
//  Arguments:  [pDomainSid]     --
//              [pDomainSidInfo] --
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
DWORD
AllocateAndInitializeDomainSid(
    PSID        pDomainSid,
    MYSIDINFO * pDomainSidInfo)
{
    UCHAR DomainIdSubAuthorityCount;
    DWORD SidLength;

    //
    // Allocate a Sid which has one more sub-authority than the domain ID.
    //

    DomainIdSubAuthorityCount = *(GetSidSubAuthorityCount(pDomainSid));
    SidLength = GetSidLengthRequired(DomainIdSubAuthorityCount + 1);

    pDomainSidInfo->pSid = new BYTE[SidLength];

    if (pDomainSidInfo->pSid == NULL)
    {
        CHECK_HRESULT(E_OUTOFMEMORY);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Initialize the new SID to have the same inital value as the
    // domain ID.
    //

    if (!CopySid(SidLength, pDomainSidInfo->pSid, pDomainSid))
    {
        delete pDomainSidInfo->pSid;
        pDomainSidInfo->pSid = NULL;
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        return(GetLastError());
    }

    //
    // Adjust the sub-authority count and add the relative Id unique
    // to the newly allocated SID
    //

    (*(GetSidSubAuthorityCount(pDomainSidInfo->pSid)))++;
    *(GetSidSubAuthority(pDomainSidInfo->pSid,
                         DomainIdSubAuthorityCount)) =
                                            pDomainSidInfo->dwSubAuthority;

    return(ERROR_SUCCESS);
}

//+---------------------------------------------------------------------------
//
//  Function:   GetFileOwnerSid
//
//  Synopsis:
//
//  Arguments:  [pwszFileName] --
//              [ppSid]        --
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
GetFileOwnerSid(LPCWSTR pwszFileName, PSID * ppSid)
{
    DWORD   cbSizeNeeded;

    //
    // Retrieve the file owner. Call GetFileSecurity twice - first to get
    // the buffer size, then the actual information retrieval.
    //

    if (GetFileSecurity(pwszFileName,
                        OWNER_SECURITY_INFORMATION,
                        NULL,
                        0,
                        &cbSizeNeeded))
    {
        //
        // Didn't expect this to succeed!
        //

        CHECK_HRESULT(E_UNEXPECTED);
        return(E_UNEXPECTED);
    }

    DWORD                Status         = GetLastError();
    PSECURITY_DESCRIPTOR pOwnerSecDescr = NULL;
    HRESULT              hr             = S_OK;

    if ((Status == ERROR_INSUFFICIENT_BUFFER) && (cbSizeNeeded > 0))
    {
        //
        // Allocate the buffer space necessary and retrieve the info.
        //

        pOwnerSecDescr = (SECURITY_DESCRIPTOR *)new BYTE[cbSizeNeeded];

        if (pOwnerSecDescr == NULL)
        {
            CHECK_HRESULT(E_OUTOFMEMORY);
            return(E_OUTOFMEMORY);
        }

        if (!GetFileSecurity(pwszFileName,
                             OWNER_SECURITY_INFORMATION,
                             pOwnerSecDescr,
                             cbSizeNeeded,
                             &cbSizeNeeded))
        {
            delete pOwnerSecDescr;
            hr = HRESULT_FROM_WIN32(GetLastError());
            CHECK_HRESULT(hr);
            return(hr);
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        CHECK_HRESULT(hr);
        return(hr);
    }

    //
    // Retrieve & validate the owner sid.
    //
    // NB : After this, pOwnerSid will point into the security descriptor,
    //      pOwnerSecDescr; hence, the descriptor must exist for the
    //      lifetime of pOwnerSid.
    //

    DWORD cbOwnerSid;
    PSID  pOwnerSid;
    BOOL  fOwnerDefaulted;

    if (GetSecurityDescriptorOwner(pOwnerSecDescr,
                                   &pOwnerSid,
                                   &fOwnerDefaulted))
    {
        if (IsValidSid(pOwnerSid))
        {
            *ppSid = new BYTE[cbOwnerSid = GetLengthSid(pOwnerSid)];

            if (*ppSid != NULL)
            {
                if (!CopySid(cbOwnerSid, *ppSid, pOwnerSid))
                {
                    delete *ppSid;
                    *ppSid = NULL;
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    CHECK_HRESULT(hr);
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
                CHECK_HRESULT(hr);
            }

        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            CHECK_HRESULT(hr);
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        CHECK_HRESULT(hr);
    }

    delete pOwnerSecDescr;

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\job\triggers.cxx ===
//+----------------------------------------------------------------------------
//
//  Job Object Handler
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       triggers.cxx
//
//  Contents:   trigger object and trigger collection object
//
//  Classes:    CTrigger and CBagOTriggers
//
//  History:    27-June-95 EricB created
//              11-Nov-96  AnirudhS  GetRunTimes: Changed return codes; various
//                  other fixes.
//
//-----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "job.hxx"

// prototypes for local functions:
HRESULT AddToList(FILETIME, FILETIME, CRun *, WORD *);
void AddDaysToFileTime(LPFILETIME pft, WORD Days);

//+----------------------------------------------------------------------------
//
//  Member:     CTrigger::CTrigger
//
//  Synopsis:   Ctor
//
//-----------------------------------------------------------------------------
CTrigger::CTrigger(WORD iTrigger, CJob * pJob)
    : m_iTrigger(iTrigger),
      m_pJob(pJob),
      m_cReferences(1)
{
    schAssert(m_pJob != NULL);
    m_pJob->AddRef();
}

//+----------------------------------------------------------------------------
//
//  Member:     CTrigger::~CTrigger
//
//  Synopsis:   Dtor
//
//-----------------------------------------------------------------------------
CTrigger::~CTrigger(void)
{
    m_pJob->Release();
}

//+----------------------------------------------------------------------------
//
//  Member:     CTrigger::ITaskTrigger::GetTriggerString
//
//  Synopsis:   Returns a string representation of the trigger
//
//  Arguments:  [ppwszTrigger] - the place to return a string pointer
//
//  Returns:    HRESULTS
//
//  Notes:      The string is callee allocated and caller freed with
//              CoTaskMemFree.
//-----------------------------------------------------------------------------
STDMETHODIMP
CTrigger::GetTriggerString(LPWSTR * ppwszTrigger)
{
    //TRACE(CTrigger, GetTriggerString);
    return(m_pJob->GetTriggerString(m_iTrigger, ppwszTrigger));
}

//+----------------------------------------------------------------------------
//
//  Member:     CTrigger::ITaskTrigger::SetTrigger, public
//
//  Synopsis:   Sets the trigger values.
//
//  Arguments:  [pTrigger] - the struct containing the values
//
//  Returns:    HRESULTS
//
//  Notes:
//-----------------------------------------------------------------------------
STDMETHODIMP
CTrigger::SetTrigger(const PTASK_TRIGGER pTrigger)
{
    TRACE(CTrigger, SetTrigger);

	if( NULL == pTrigger )
	{
		return E_INVALIDARG;
	}
    //
    // Check struct version.
    //

    if (pTrigger->cbTriggerSize != sizeof(TASK_TRIGGER))
    {
        //
        // Don't attempt to modify triggers created by a later revision.
        //

        return E_INVALIDARG;
    }

    return(m_pJob->SetTrigger(m_iTrigger, pTrigger));
}

//+----------------------------------------------------------------------------
//
//  Member:     CTrigger::ITaskTrigger::GetTrigger
//
//  Synopsis:   Gets the trigger values.
//
//  Arguments:  [pTrigger] - pointer to caller supplied trigger structure
//
//  Returns:    HRESULTS
//
//  Notes:      pTrigger->cbTriggerSize must be set to sizeof(TASK_TRIGGER) on
//              function entry. This provides for trigger struct versioning.
//-----------------------------------------------------------------------------
STDMETHODIMP
CTrigger::GetTrigger(PTASK_TRIGGER pTrigger)
{
    //TRACE(CTrigger, GetTrigger);
	if( NULL == pTrigger )
	{
		return E_INVALIDARG;
	}

    return(m_pJob->GetTrigger(m_iTrigger, pTrigger));
}

//+----------------------------------------------------------------------------
//
//  Functions:  AddDaysToFileTime
//
//  Synopsis:   Convert the days value to filetime units and add it to
//              the filetime.
//
//-----------------------------------------------------------------------------
void
AddDaysToFileTime(LPFILETIME pft, WORD Days)
{
    if (!Days)
    {
        return; // Nothing to do.
    }
    //
    // ft = ft + Days * FILETIMES_PER_DAY;
    //
    ULARGE_INTEGER uli, uliSum;
    uli.LowPart  = pft->dwLowDateTime;
    uli.HighPart = pft->dwHighDateTime;
    uliSum.QuadPart = uli.QuadPart + (__int64)Days * FILETIMES_PER_DAY;
    pft->dwLowDateTime  = uliSum.LowPart;
    pft->dwHighDateTime = uliSum.HighPart;
}

//+----------------------------------------------------------------------------
//
//  Functions:  AddMinutesToFileTime
//
//  Synopsis:   Convert the minutes value to filetime units and add it to
//              the filetime.
//
//-----------------------------------------------------------------------------
void
AddMinutesToFileTime(LPFILETIME pft, DWORD Minutes)
{
    if (!Minutes)
    {
        return; // Nothing to do.
    }
    //
    // ft = ft + Minutes * FILETIMES_PER_MINUTE;
    //
    ULARGE_INTEGER uli, uliSum;
    uli.LowPart  = pft->dwLowDateTime;
    uli.HighPart = pft->dwHighDateTime;
    uliSum.QuadPart = uli.QuadPart + (__int64)Minutes * FILETIMES_PER_MINUTE;
    pft->dwLowDateTime  = uliSum.LowPart;
    pft->dwHighDateTime = uliSum.HighPart;
}

//+----------------------------------------------------------------------------
//
//  Function:   GetTriggerRunTimes
//
//  Synopsis:   Computes a set of run times for this trigger that fall between
//              the bracketing times -- pstBracketBegin is inclusive,
//              pstBracketEnd is exclusive -- and merges them with the list of
//              run times passed in.
//
//  Arguments:  [jt]              - Inspected trigger.
//              [pstBracketBegin] - the start of the bracketing period
//              [pstBracketEnd]   - the end of the bracketing period, may
//                                  be NULL
//              [pCount]          - on both entry and exit, points to the
//                                  number of CRun elements in the list.
//                                  CODEWORK: Make this a private member of
//                                  CRunList.
//              [cLimit]          - the maximum number of elements that the
//                                  list may grow to.
//              [pRunList]        - the list of run time objects, can
//                                  be NULL if just checking to see if there
//                                  will be *any* runs.  (Note: If it's NULL,
//                                  duplicate run times are not detected, so
//                                  pCount may be overestimated on return.)
//              [ptszJobName],
//              [dwJobFlags],
//              [dwMaxRunTime]    - the last 3 params are used for the CRun
//                                  objects as their member data.
//              [wIdleWait]       - the job's idle wait period
//              [wIdleDeadline]   - time to wait for idle wait period
//
//  Returns:    S_OK: The trigger is a time-based trigger and is enabled,
//                  and zero or more of its run times have been added to the
//                  list (subject to cLimit and the bracketing period); or,
//                  the trigger is an event trigger but will expire before
//                  the bracketing period.
//              SCHED_S_EVENT_TRIGGER: this is an event trigger that will be
//                  active (not expired) during the bracketing period.
//              SCHED_S_TASK_NO_VALID_TRIGGERS: the trigger is disabled or
//                                              not set.
//              Failure HRESULTs: Other failures.
//
//  Notes:      The trigger time list is callee allocated and caller freed. The
//              caller must use delete to free this list.
//-----------------------------------------------------------------------------
HRESULT
GetTriggerRunTimes(
    TASK_TRIGGER & jt,
    const SYSTEMTIME *  pstBracketBegin,
    const SYSTEMTIME *  pstBracketEnd,
    WORD *         pCount,
    WORD           cLimit,
    CTimeRunList * pRunList,
    LPTSTR         ptszJobName,
    DWORD          dwJobFlags,
    DWORD          dwMaxRunTime,
    WORD           wIdleWait,
    WORD           wIdleDeadline)
{
    TRACE_FUNCTION3(GetRunTimes);
    DWORD dwRet;

    schAssert(cLimit > 0);  // If cLimit is 0, it's not clear what to return
    schAssert(cLimit <= TASK_MAX_RUN_TIMES);
    schAssert(*pCount <= cLimit);

    //
    // Return if this trigger hasn't been set or if it is disabled.
    //
    if (jt.rgFlags & JOB_TRIGGER_I_FLAG_NOT_SET ||
        jt.rgFlags & TASK_TRIGGER_FLAG_DISABLED)
    {
        return SCHED_S_TASK_NO_VALID_TRIGGERS;
    }

    //
    // Event triggers don't have set run times.
    //
    switch (jt.TriggerType)
    {
    case TASK_EVENT_TRIGGER_ON_IDLE:
    case TASK_EVENT_TRIGGER_AT_SYSTEMSTART:
    case TASK_EVENT_TRIGGER_AT_LOGON:
    // Not yet implemented:
    // case TASK_EVENT_TRIGGER_ON_APM_RESUME:

        //
        // Check if the trigger expires before the beginning of the bracket
        //
        if (jt.rgFlags & TASK_TRIGGER_FLAG_HAS_END_DATE)
        {
            SYSTEMTIME stEnd;
            stEnd.wYear  = jt.wEndYear;
            stEnd.wMonth = jt.wEndMonth;
            stEnd.wDay   = jt.wEndDay;
            // IsFirstDateEarlier ignores other fields

            if (IsFirstDateEarlier(&stEnd, pstBracketBegin))
            {
                return S_OK;
            }
        }

        return SCHED_S_EVENT_TRIGGER;
    }

    SYSTEMTIME st = { 0, 0, 0, 0, 0, 0, 0, 0 };
    //
    // Convert to FILETIMEs and check if the trigger lifetime intersects the
    // requested run bracket.
    // If there is a trigger end date, then one of three conditions holds:
    // a. *pstBracketBegin > jt.End{Month/Day/Year}
    //    result, no runs
    // b. *pstBracketBegin < jt.End{Month/Day/Year} < *pstBracketEnd
    //    result, return all runs between *pstBracketBegin and
    //    jt.End{Month/Day/Year}
    // c. jt.End{Month/Day/Year} > *pstBracketEnd
    //    result, return all runs between *pstBracketBegin and *pstBracketEnd
    // In addition, if there is a bracket end we check:
    // d. *pstBracketEnd <= jt.Begin{Month/Day/Year}
    //    result, no runs
    //
    FILETIME ftTriggerBegin, ftTriggerEnd, ftBracketBegin, ftBracketEnd;

    if (!SystemTimeToFileTime(pstBracketBegin, &ftBracketBegin))
    {
        dwRet = GetLastError();
        ERR_OUT("GetRunTimes, convert pstBracketBegin", dwRet);
        return HRESULT_FROM_WIN32(dwRet);
    }

    st.wYear   = jt.wBeginYear;
    st.wMonth  = jt.wBeginMonth;
    st.wDay    = jt.wBeginDay;
    st.wHour   = jt.wStartHour;
    st.wMinute = jt.wStartMinute;

    if (!SystemTimeToFileTime(&st, &ftTriggerBegin))
    {
        dwRet = GetLastError();
        ERR_OUT("GetRunTimes, convert TriggerBegin", dwRet);
        return HRESULT_FROM_WIN32(dwRet);
    }

    st.wHour   = 23;    // set to the last hour of the day.
    st.wMinute = 59;    // set to the last minute of the day.
    st.wSecond = 59;    // set to the last second of the day.
	st.wMilliseconds = 0;

    if (jt.rgFlags & TASK_TRIGGER_FLAG_HAS_END_DATE)
    {
        st.wYear  = jt.wEndYear;
        st.wMonth = jt.wEndMonth;
        st.wDay   = jt.wEndDay;

        if (!SystemTimeToFileTime(&st, &ftTriggerEnd))
        {
            dwRet = GetLastError();
            ERR_OUT("GetRunTimes, convert TriggerEnd", dwRet);
            return HRESULT_FROM_WIN32(dwRet);
        }

        if (CompareFileTime(&ftTriggerEnd, &ftBracketBegin) < 0)
        {
            //
            // Trigger end time is before the run bracket begin time (case a.).
            //
            return S_OK;
        }
    }
    else    // no trigger end date.
    {
        //
        // Create an end date that is reasonably large.
        // BUGBUG Change this to MAX_FILETIME - but should be tested.
        //
        st.wMonth = 12;
        st.wDay = 31;
        st.wYear = 2200;

        if (!SystemTimeToFileTime(&st, &ftTriggerEnd))
        {
            dwRet = GetLastError();
            ERR_OUT("GetRunTimes, convert TriggerEnd", dwRet);
            return HRESULT_FROM_WIN32(dwRet);
        }
    }

    if (pstBracketEnd)
    {
        if (!SystemTimeToFileTime(pstBracketEnd, &ftBracketEnd))
        {
            dwRet = GetLastError();
            ERR_OUT("GetRunTimes, convert pstBracketEnd", dwRet);
            return HRESULT_FROM_WIN32(dwRet);
        }

        if (CompareFileTime(&ftTriggerBegin, &ftBracketEnd) >= 0)
        {
            //
            // The trigger start date is after the bracket end date, there are
            // no runs (case d.).
            //
            return S_OK;
        }

        if (CompareFileTime(&ftTriggerEnd, &ftBracketEnd) < 0)
        {
            //
            // Trigger end is before bracket end, so set bracket end to
            // trigger end (case b.).
            //
            ftBracketEnd = ftTriggerEnd;
        }
    }
    else
    {
        //
        // No bracket end, so use trigger end (case c.).
        //
        ftBracketEnd = ftTriggerEnd;
    }

    FILETIME ftRun, ftDurationStart, ftDurationEnd;
    WORD rgfRunDOW[JOB_DAYS_PER_WEEK], i;
    WORD rgfDaysOfMonth[JOB_DAYS_PER_MONTHMAX];
    WORD rgfMonths[JOB_MONTHS_PER_YEAR];
    WORD wDay, wBeginDOW, wCurDOW,  wCurDay, wLastDOM, wCurMonth, wCurYear;
    WORD cRunDOW, iRunDOW, IndexStart;
    BOOL fWrapped;
    fWrapped = FALSE;

    //
    // Calculate the trigger's first run time.
    //
    switch (jt.TriggerType)
    {
    case TASK_TIME_TRIGGER_ONCE:
        // fall through to daily:

    case TASK_TIME_TRIGGER_DAILY:
        //
        // The first run time is the trigger begin time.
        //
        ftRun = ftTriggerBegin;
        break;

    case TASK_TIME_TRIGGER_WEEKLY:
        //
        // At jobs clear the DOW bits, so make sure we don't have an expired
        // At job.
        //
        if (jt.Type.Weekly.rgfDaysOfTheWeek == 0)
        {
            return S_OK;
        }

        //
        // See what day of the week the trigger begin day is. SYSTEMTIME
        // defines Sunday = 0, Monday = 1, etc.
        //
        FileTimeToSystemTime(&ftTriggerBegin, &st);
        wBeginDOW = st.wDayOfWeek;
        //
        // Convert the trigger data run day bit array into a boolean array
        // so that the results can be compared with the SYSTEMTIME value.
        // This array will also be used in the main loop.
        //
        for (i = 0; i < JOB_DAYS_PER_WEEK; i++)
        {
            rgfRunDOW[i] = (jt.Type.Weekly.rgfDaysOfTheWeek >> i) & 0x1;
        }
        //
        // Find the first set day-of-the-week after the trigger begin day.
        //
        for (i = 0; i < JOB_DAYS_PER_WEEK; i++)
        {
            wCurDOW = wBeginDOW + i;
            if (wCurDOW >= JOB_DAYS_PER_WEEK)
            {
                wCurDOW -= JOB_DAYS_PER_WEEK;
            }
            if (rgfRunDOW[wCurDOW])
            {
                ftRun = ftTriggerBegin;
                AddDaysToFileTime(&ftRun, i);
                break;
            }
        }
        break;

    case TASK_TIME_TRIGGER_MONTHLYDATE:
        //
        // At jobs clear the days bits, so make sure we don't have an expired
        // At job.
        //
        if (jt.Type.MonthlyDate.rgfDays == 0)
        {
            return S_OK;
        }

        //
        // Convert the bit fields to boolean arrays.
        // These arrays will also be used in the main loop.
        //
        for (i = 0; i < JOB_DAYS_PER_MONTHMAX; i++)
        {
            rgfDaysOfMonth[i] = (WORD)(jt.Type.MonthlyDate.rgfDays >> i) & 0x1;
        }
        for (i = 0; i < JOB_MONTHS_PER_YEAR; i++)
        {
            rgfMonths[i] = (jt.Type.MonthlyDate.rgfMonths >> i) & 0x1;
        }

        wCurDay = jt.wBeginDay;
        wCurMonth = jt.wBeginMonth;
        wCurYear = jt.wBeginYear;
        BOOL fDayOverflow, fDayFound;
        fDayFound = FALSE;
        do
        {
            MonthDays(wCurMonth, wCurYear, &wLastDOM);
            //
            // Find the first run day after the trigger start day, including
            // the trigger start day.
            //
            for (i = 0; i < wLastDOM; i++)
            {
                if (wCurDay > wLastDOM)
                {
                    //
                    // Adjust for wrapping.
                    //
                    wCurDay = 1;
                    fWrapped = TRUE;
                }
                if (rgfDaysOfMonth[wCurDay - 1])
                {
                    fDayFound = TRUE;
                    break;
                }
                wCurDay++;
            }
            //
            // Find the first run month.
            //
            for (i = 0; i < JOB_MONTHS_PER_YEAR; i++)
            {
                if (wCurMonth > JOB_MONTHS_PER_YEAR)
                {
                    wCurMonth = 1;
                    wCurYear++;
                }
                //
                // Check for run month match. Note that rgfMonths is zero based
                // and wCurMonth is one based.
                //
                if (rgfMonths[wCurMonth - 1])
                {
                    if (fWrapped && !i)
                    {
                        //
                        // Even though we have a match for run month, the run
                        // date for the first month has passed, so move on to
                        // the next run month.
                        //
                        fWrapped = FALSE;
                    }
                    else
                    {
                        break;
                    }
                }
                wCurMonth++;
            }
            //
            // Check for days overflow.
            //
            MonthDays(wCurMonth, wCurYear, &wLastDOM);
            if (wCurDay > wLastDOM)
            {
                //
                // Note that this clause would be entered infinitely if there
                // were no valid dates. ITask::SetTrigger validates the data to
                // ensure that there are valid dates.
                //
                fDayOverflow = TRUE;
                fDayFound = FALSE;
                wCurDay = 1;
                wCurMonth++;
                if (wCurMonth > JOB_MONTHS_PER_YEAR)
                {
                    wCurMonth = 1;
                    wCurYear++;
                }
            }
            else
            {
                fDayOverflow = FALSE;
            }
        } while (fDayOverflow & !fDayFound);

        break;

    case TASK_TIME_TRIGGER_MONTHLYDOW:
        //
        // Convert the bit fields to boolean arrays.
        // These arrays will also be used in the main loop.
        //
        cRunDOW = 0;
        for (i = 0; i < JOB_DAYS_PER_WEEK; i++)
        {
            if ((jt.Type.MonthlyDOW.rgfDaysOfTheWeek >> i) & 0x1)
            {
                cRunDOW++;
                rgfRunDOW[i] = TRUE;
            }
            else
            {
                rgfRunDOW[i] = FALSE;
            }
        }
        for (i = 0; i < JOB_MONTHS_PER_YEAR; i++)
        {
            rgfMonths[i] = (jt.Type.MonthlyDOW.rgfMonths >> i) & 0x1;
        }
        //
        // See if the trigger start month is in rgfMonths and if not
        // move to the first month in rgfMonths after jt.BeginMonth.
        //
        wCurMonth = jt.wBeginMonth;
        wCurYear = jt.wBeginYear;
        BOOL fInStartMonth;
        IndexStart = 0;
CheckNextMonth:
        for (i = IndexStart; i < (JOB_MONTHS_PER_YEAR + IndexStart); i++)
        {
            //
            // Check for run month match. Note that rgfMonths is zero based
            // and wCurMonth is one based.
            //
            if (rgfMonths[wCurMonth - 1])
            {
                break;
            }

            wCurMonth++;
            if (wCurMonth > JOB_MONTHS_PER_YEAR)
            {
                wCurMonth -= JOB_MONTHS_PER_YEAR;
                wCurYear++;
            }
        }

        fInStartMonth = i == 0;

        //
        // See what day of the week the first day of the month is.
        //
        st.wMonth = wCurMonth;
        st.wDay = 1;
        st.wYear = wCurYear;

        //
        // Convert to FILETIME and back to SYSTEMTIME to get wDayOfWeek.
        //
        SystemTimeToFileTime(&st, &ftRun);
        FileTimeToSystemTime(&ftRun, &st);
        wBeginDOW = st.wDayOfWeek;

        //
        // Find the first run DayOftheWeek. If it is before the start
        // day, find the next and so on until after the start day.
        //
        iRunDOW = cRunDOW;

        for (i = 0; i < JOB_DAYS_PER_WEEK; i++)
        {
            wCurDOW = wBeginDOW + i;
            wCurDay = 1 + i;

            if (wCurDOW >= JOB_DAYS_PER_WEEK)
            {
                wCurDOW -= JOB_DAYS_PER_WEEK;
            }

            if (rgfRunDOW[wCurDOW])
            {
                iRunDOW--;
                wCurDay += (jt.Type.MonthlyDOW.wWhichWeek - 1)
                           * JOB_DAYS_PER_WEEK;

                MonthDays(wCurMonth, wCurYear, &wLastDOM);

                if (wCurDay > wLastDOM)
                {
                    //
                    // This case can be reached if
                    // jt.Type.MonthlyDOW.wWhichWeek == TASK_LAST_WEEK
                    // which means to always run on the last occurrence of
                    // this day for the month.
                    //
                    wCurDay -= JOB_DAYS_PER_WEEK;
                }

                if (fInStartMonth && wCurDay < jt.wBeginDay)
                {
                    if (iRunDOW)
                    {
                        //
                        // There are more runs this month, so check those.
                        //
                        continue;
                    }
                    else
                    {
                        //
                        // Start with the next run month.
                        //
                        IndexStart++;
                        goto CheckNextMonth;
                    }
                }
                break;
            }
        }
        wDay = 1 + i;
        break;

    default:
        return E_FAIL;
    }

    if (jt.TriggerType == TASK_TIME_TRIGGER_MONTHLYDATE ||
        jt.TriggerType == TASK_TIME_TRIGGER_MONTHLYDOW)
    {
        st.wYear   = wCurYear;
        st.wMonth  = wCurMonth;
        st.wDay    = wCurDay;
        st.wHour   = jt.wStartHour;
        st.wMinute = jt.wStartMinute;
        st.wSecond = st.wMilliseconds = 0;
        SystemTimeToFileTime(&st, &ftRun);
    }

    //
    // Set the initial duration period endpoints.
    //
    // ftDurationEnd = ftDurationStart + jt.MinutesDuration
    //                 * FILETIMES_PER_MINUTE;
    //
    ftDurationStart = ftDurationEnd = ftRun;
    AddMinutesToFileTime(&ftDurationEnd, jt.MinutesDuration);
    BOOL fPassedDurationEnd = FALSE;

    //
    // Main loop. Find all of the runs after the initial run.
    // Stop when the run goes past the bracket end.
    //
    while (CompareFileTime(&ftRun, &ftBracketEnd) < 0)
    {
        //
        // If the run falls within the run bracket, add it to the list.
        //
        if (CompareFileTime(&ftRun, &ftBracketBegin) >= 0)
        {
            if (pRunList != NULL)
            {
                FILETIME ftKillTime = MAX_FILETIME;
                if (jt.rgFlags & TASK_TRIGGER_FLAG_KILL_AT_DURATION_END)
                {
                    ftKillTime = ftDurationEnd;
                }

                FILETIME ftDeadline = ftTriggerEnd;
                if (dwJobFlags & TASK_FLAG_START_ONLY_IF_IDLE)
                {
                    FILETIME ftIdleDeadline = ftRun;

                    AddMinutesToFileTime(&ftIdleDeadline, wIdleDeadline);
                    ftDeadline = minFileTime(ftTriggerEnd, ftIdleDeadline);
                }

                HRESULT hr = pRunList->AddSorted(ftRun, ftDeadline, ftKillTime,
                                ptszJobName, dwJobFlags, dwMaxRunTime,
                                wIdleWait, pCount, cLimit);
                if (FAILED(hr))
                {
                    return hr;
                }
                schAssert(*pCount <= cLimit);

                if (hr == S_FALSE)
                {
                    //
                    // The run time is later than the last element in the list
                    // and the list has reached its size limit.  So don't
                    // bother computing any more run times.
                    //
                    return S_OK;
                }
            }
            else
            {
                if (*pCount < cLimit)
                {
                    (*pCount)++;
                }

                if (*pCount == cLimit)
                {
                    //
                    // Computing more run times will have no effect.
                    //
                    return S_OK;
                }
            }
        }

        //
        // Calculate the next run time.
        //

        //
        // If there is minutes repetition (MinutesInterval non-zero), then
        // compute all of the runs in the duration period.
        //

        if (jt.MinutesInterval)
        {
            //
            // Add the minutes interval.
            //
            AddMinutesToFileTime(&ftRun, jt.MinutesInterval);

            //
            // See if we are at the end of this duration period.
            //
            if (CompareFileTime(&ftDurationEnd, &ftRun) <= 0)
            {
                fPassedDurationEnd = TRUE;
            }
        }

        //
        // If there is no minutes repetition (MinutesInterval is zero) or we
        // have passed the end of the duration period, then calculate the next
        // duration start (which is also the next run).
        //
        if (!jt.MinutesInterval || fPassedDurationEnd)
        {
            switch (jt.TriggerType)
            {
            case TASK_TIME_TRIGGER_ONCE:
                return S_OK;

            case TASK_TIME_TRIGGER_DAILY:
                //
                // ftNextRun = ftCurRun + DaysInterval * FILETIMES_PER_DAY;
                //
                AddDaysToFileTime(&ftDurationStart, jt.Type.Daily.DaysInterval);
                break;

            case TASK_TIME_TRIGGER_WEEKLY:
                fWrapped = FALSE;
                //
                // Find the next DayOfWeek to run on.
                //
                for (i = 1; i <= JOB_DAYS_PER_WEEK; i++)
                {
                    wCurDOW++;
                    if (wCurDOW >= JOB_DAYS_PER_WEEK)
                    {
                        //
                        // We have wrapped into the next week.
                        //
                        wCurDOW -= JOB_DAYS_PER_WEEK;
                        fWrapped = TRUE;
                    }
                    if (rgfRunDOW[wCurDOW])
                    {
                        AddDaysToFileTime(&ftDurationStart, i);
                        break;
                    }
                }

                if (fWrapped)
                {
                    //
                    // Starting a new week, so add the weeks increment.
                    //
                    AddDaysToFileTime(&ftDurationStart,
                                      (jt.Type.Weekly.WeeksInterval - 1)
                                      * JOB_DAYS_PER_WEEK);
                }
                break;

            case TASK_TIME_TRIGGER_MONTHLYDATE:
                BOOL fDayFound;
                fWrapped = FALSE;
                fDayFound = FALSE;
                //
                // Find the next day to run.
                //
                do
                {
                    MonthDays(wCurMonth, wCurYear, &wLastDOM);
                    for (i = 1; i <= wLastDOM; i++)
                    {
                        wCurDay++;
                        if (wCurDay > wLastDOM)
                        {
                            //
                            // Adjust for wrapping.
                            //
                            wCurDay = 1;
                            fWrapped = TRUE;
                            wCurMonth++;
                            if (wCurMonth > JOB_MONTHS_PER_YEAR)
                            {
                                wCurMonth = 1;
                                wCurYear++;
                            }
                            MonthDays(wCurMonth, wCurYear, &wLastDOM);
                        }
                        if (rgfDaysOfMonth[wCurDay - 1])
                        {
                            fDayFound = TRUE;
                            break;
                        }
                    }
                    if (fWrapped || !fDayFound)
                    {
                        //
                        // The prior month is done, find the next month.
                        //
                        for (i = 1; i <= JOB_MONTHS_PER_YEAR; i++)
                        {
                            if (wCurMonth > JOB_MONTHS_PER_YEAR)
                            {
                                wCurMonth = 1;
                                wCurYear++;
                            }
                            if (rgfMonths[wCurMonth - 1])
                            {
                                fWrapped = FALSE;
                                break;
                            }
                            wCurMonth++;
                        }
                    }
                } while (!fDayFound);
                break;

            case TASK_TIME_TRIGGER_MONTHLYDOW:
                if (!iRunDOW)
                {
                    //
                    // All of the runs for the current month are done, find the
                    // next month.
                    //
                    for (i = 0; i < JOB_MONTHS_PER_YEAR; i++)
                    {
                        wCurMonth++;
                        if (wCurMonth > JOB_MONTHS_PER_YEAR)
                        {
                            wCurMonth = 1;
                            wCurYear++;
                        }
                        if (rgfMonths[wCurMonth - 1])
                        {
                            break;
                        }
                    }
                    //
                    // See what day of the week the first day of the month is.
                    //
                    st.wMonth = wCurMonth;
                    st.wDay = wDay = 1;
                    st.wYear = wCurYear;
                    SystemTimeToFileTime(&st, &ftRun);
                    FileTimeToSystemTime(&ftRun, &st);
                    wCurDOW = st.wDayOfWeek;
                    iRunDOW = cRunDOW;
                    //
                    // Start at the first run DOW for this next month.
                    //
                    IndexStart = 0;
                }
                else
                {
                    //
                    // Start at the next run DOW for the current month.
                    //
                    IndexStart = 1;
                }

                //
                // Find the next DayOfWeek to run on.
                //
                for (i = IndexStart; i <= JOB_DAYS_PER_WEEK; i++)
                {
                    if (i > 0)
                    {
                        wCurDOW++;
                        wDay++;
                    }
                    if (wCurDOW >= JOB_DAYS_PER_WEEK)
                    {
                        wCurDOW -= JOB_DAYS_PER_WEEK;
                    }
                    if (rgfRunDOW[wCurDOW])
                    {
                        //
                        // Found a run DayOfWeek.
                        //
                        iRunDOW--;
                        wCurDay = wDay + (jt.Type.MonthlyDOW.wWhichWeek - 1)
                                         * JOB_DAYS_PER_WEEK;
                        WORD wLastDOM;
                        MonthDays(wCurMonth, wCurYear, &wLastDOM);
                        if (wCurDay > wLastDOM)
                        {
                            //
                            // This case can be reached if
                            // jt.Type.MonthlyDOW.wWhichWeek == JOB_LAST_WEEK
                            // which means to always run on the last occurance
                            // of this day for the month.
                            //
                            wCurDay -= JOB_DAYS_PER_WEEK;
                        }
                        break;
                    }
                }
                break;

            default:
                return E_FAIL;
            }

            if (jt.TriggerType == TASK_TIME_TRIGGER_MONTHLYDATE ||
                jt.TriggerType == TASK_TIME_TRIGGER_MONTHLYDOW)
            {
                st.wYear   = wCurYear;
                st.wMonth  = wCurMonth;
                st.wDay    = wCurDay;
                st.wHour   = jt.wStartHour;
                st.wMinute = jt.wStartMinute;
                st.wSecond = st.wMilliseconds = 0;
                SystemTimeToFileTime(&st, &ftDurationStart);
            }

            //
            // Calc the next duration period endpoints.
            //
            ftRun = ftDurationEnd = ftDurationStart;

            AddMinutesToFileTime(&ftDurationEnd, jt.MinutesDuration);

            fPassedDurationEnd = FALSE;
        }

    } // while

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\job\persist.cxx ===
//+----------------------------------------------------------------------------
//
//  Job Object Handler
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       persist.cxx
//
//  Contents:   persistent storage methods
//
//  Classes:    CJob (continued)
//
//  Interfaces: IPersist, IPersistFile
//
//  History:    24-May-95 EricB created
//              19-Jul-97 AnirudhS  Rewrote SaveP and LoadP to minimize calls
//                  to ReadFile, WriteFile and LocalAlloc
//
//-----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include <align.h>
#include "job.hxx"
#include "defines.hxx"
#if !defined(_CHICAGO_)
#include "SASecRPC.h"     // Get/SetAccountInformation RPC definition.
#endif // !defined(_CHICAGO_)
#include "proto.hxx"
#include "security.hxx"
#include "..\svc_core\lsa.hxx"

#define JOB_SIGNATURE_VERSION               1   // data version we write
#define JOB_SIGNATURE_CLIENT_VERSION        1   // software version we are
#define JOB_SIGNATURE_MIN_CLIENT_VERSION    1   // min s/w version that can
                                                //   read data we write

struct JOB_SIGNATURE_HEADER
{
    WORD    wSignatureVersion;
    WORD    wMinClientVersion;
};

void    GenerateUniqueID(GUID * pUuid);
BOOL    ReadString(CInputBuffer * pBuf, LPWSTR *ppwsz);

//
// This array of members is used to iterate through the string fields
// of a CJob that are initially held in m_MainBlock.
//

LPWSTR CJob::* const CJob::s_StringField[] =
{
    &CJob::m_pwszApplicationName,
    &CJob::m_pwszParameters,
    &CJob::m_pwszWorkingDirectory,
    &CJob::m_pwszCreator,
    &CJob::m_pwszComment
};

// IPersist method

//+----------------------------------------------------------------------------
//
//  Member:     CJob::IPersist::GetClassID
//
//  Synopsis:   supplies VBScript class object CLSID
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::GetClassID(CLSID * pClsID)
{
    TRACE(CJob, GetClassID);
    *pClsID = CLSID_CTask;
    return S_OK;
}

// IPersistFile methods

//+----------------------------------------------------------------------------
//
//  Member:     CJob::IPersistFile::IsDirty
//
//  Synopsis:   checks for changes since it was last saved
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::IsDirty(void)
{
    TRACE3(CJob,IsDirty);
    return (IsFlagSet(JOB_I_FLAG_PROPERTIES_DIRTY) ||
            IsFlagSet(JOB_I_FLAG_TRIGGERS_DIRTY)   ||
            IsFlagSet(JOB_I_FLAG_SET_ACCOUNT_INFO)) ? S_OK : S_FALSE;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::IPersistFile::Load
//
//  Synopsis:   loads the job object indicated by the given filename
//
//  Arguments:  [pwszFileName] - name of the job object file
//              [dwMode]       - open mode, currently ignored.
//
//  Notes:      All OLE32 strings are UNICODE, including the filename passed
//              in the IPersistFile methods. One Win9x, all file names must
//              be in ANSI strings, thus the conversion and call to LoadP.
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::Load(LPCOLESTR pwszFileName, DWORD dwMode)
{
    HRESULT hr;
#if defined(UNICODE)

    hr = LoadP(pwszFileName, dwMode, TRUE, TRUE);

#else   // first convert filename to ANSI

    CHAR szFileName[MAX_PATH + 1];

    hr = UnicodeToAnsi(szFileName, pwszFileName, ARRAY_LEN(szFileName));
    if (FAILED(hr))
    {
        return STG_E_INVALIDPARAMETER;
    }

    hr = LoadP(szFileName, dwMode, TRUE, TRUE);

#endif
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::LoadP, private
//
//  Synopsis:   private load method that takes a TCHAR filename
//
//  Arguments:  [ptszFileName] - name of the job object file
//              [dwMode]       - open mode, currently ignored.
//              [fRemember]    - save the file name?
//              [fAllData]     - if TRUE, load the entire job. If false, load
//                               only the fixed length data at the head of the
//                               job file + the job command.
//
//-----------------------------------------------------------------------------
HRESULT
CJob::LoadP(
    LPCTSTR ptszFileName,
    DWORD   dwMode,
    BOOL    fRemember,
    BOOL    fAllData
    )
{
    TRACE3(CJob, LoadP);
    HRESULT hr = S_OK;
    BYTE * HeapBlock = NULL;
    //WCHAR tszFileName[MAX_PATH + 1] = L"";
    //
    // check the file name
    //
    //if (!CheckFileName((LPOLESTR)ptszFileName, tszFileName, NULL))
    //{
    //  return E_INVALIDARG;
    //}

    //
    // Save the file name?
    //
    if (fRemember)
    {
        LPTSTR ptsz = new TCHAR[lstrlen(ptszFileName) + 1];
        if (!ptsz)
        {
            ERR_OUT("CJob::LoadP", E_OUTOFMEMORY);
            return E_OUTOFMEMORY;
        }
        if (m_ptszFileName)
        {
            delete m_ptszFileName;
        }
        m_ptszFileName = ptsz;
        lstrcpy(m_ptszFileName, ptszFileName);
    }

    //
    // Open the file.
    //
    HANDLE hFile = CreateFile(ptszFileName,
                              GENERIC_READ,
                              FILE_SHARE_READ,
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL     |
                              FILE_FLAG_SEQUENTIAL_SCAN,
                              NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ERR_OUT("CJob::Load, file open", hr);
        return hr;
    }

    if (fRemember)
    {
        m_fFileCreated = TRUE;
    }

    //
    // Get the file size.
    //
    DWORD dwFileSize;
    {
        DWORD dwFileSizeHigh;
        DWORD dwError;
        dwFileSize = GetFileSize(hFile, &dwFileSizeHigh);
        if (dwFileSize == 0xFFFFFFFF &&
            (dwError = GetLastError()) != NO_ERROR)
        {
            hr = HRESULT_FROM_WIN32(dwError);
            ERR_OUT("CJob::Load, GetFileSize", hr);
            goto Cleanup;
        }

        if (dwFileSizeHigh > 0)
        {
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            schDebugOut((DEB_ERROR, "CJob::Load: file too big, SizeHigh = %u\n",
                         dwFileSizeHigh));
            goto Cleanup;
        }
    }

    if (dwFileSize < sizeof(FIXDLEN_DATA))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        schDebugOut((DEB_ERROR, "CJob::Load: file too small, size = %u\n",
                     dwFileSize));
        goto Cleanup;
    }

    //
    // Read the entire file into memory.
    //
    HeapBlock = new BYTE[dwFileSize];
    if (HeapBlock == NULL)
    {
        hr = E_OUTOFMEMORY;
        ERR_OUT("CJob::Load, buffer alloc", hr);
        goto Cleanup;
    }

    DWORD dwBytesRead;
    if (!ReadFile(hFile, HeapBlock, dwFileSize, &dwBytesRead, NULL))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ERR_OUT("CJob::Load, read file", hr);
        delete [] HeapBlock;
        goto Cleanup;
    }
    if (dwBytesRead != dwFileSize)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        ERR_OUT("CJob::Load bytes read", hr);
        delete [] HeapBlock;
        goto Cleanup;
    }

    //
    // Close the file.
    //
    CloseHandle(hFile);
    hFile = INVALID_HANDLE_VALUE;

    //
    // Free old values of properties that we are about to read, and switch
    // to the new heap block.
    //
    FreeProperties();
    m_MainBlock.Set(HeapBlock, dwFileSize);

    //
    // Get the fixed length Job data.
    // (We already verified that the file is at least as big as FIXDLEN_DATA.)
    //
    { // scope flData and CInputBuffer to avoid "initialization skipped" error
    const FIXDLEN_DATA& flData = *(FIXDLEN_DATA *)&HeapBlock[0];
    CInputBuffer Buf(&HeapBlock[sizeof FIXDLEN_DATA],
                     &HeapBlock[dwFileSize]);

    //
    // Check the version.
    //
    // Here is where, in future versions, we would look at the version
    // properties to determine how to read the job properties.
    // For now, though, we just reject old versions as being invalid.
    //
#ifdef IN_THE_FUTURE

    if (m_wVersion != flData.wVersion)
    {
        fNewVersion = TRUE;
        //
        // Add version specific processing here.
        //
    }

#else   // !IN_THE_FUTURE

    if (m_wFileObjVer != flData.wFileObjVer)
    {
        hr = SCHED_E_UNKNOWN_OBJECT_VERSION;
        ERR_OUT("CJob::Load invalid object version", 0);
        goto Cleanup;
    }

#endif  // !IN_THE_FUTURE

    //schDebugOut((DEB_TRACE, "Load: job object version: %d.%d, build %d\n",
    //             HIBYTE(flData.wVersion), LOBYTE(flData.wVersion),
    //             flData.wFileObjVer));

    m_wVersion            = flData.wVersion;
    m_wFileObjVer         = flData.wFileObjVer;
    m_uuidJob             = flData.uuidJob;
    m_wTriggerOffset      = flData.wTriggerOffset;
    m_wErrorRetryCount    = flData.wErrorRetryCount;
    m_wErrorRetryInterval = flData.wErrorRetryInterval;
    m_wIdleWait           = flData.wIdleWait;
    m_wIdleDeadline       = flData.wIdleDeadline;
    m_dwPriority          = flData.dwPriority;
    m_dwMaxRunTime        = flData.dwMaxRunTime;
    m_ExitCode            = flData.ExitCode;
    m_hrStatus            = flData.hrStatus;
    m_rgFlags             = flData.rgFlags;
    m_stMostRecentRunTime = flData.stMostRecentRunTime;

    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);

    if (!Buf.Read(&m_cRunningInstances, sizeof m_cRunningInstances))
    {
        ERR_OUT("CJob::Load, read Running Instance Count", 0);
        goto Cleanup;
    }

    //
    // Get the variable length Job properties.
    //
    // In all cases, retrieve the job application name.
    // (Notice that flData.wAppNameLenOffset is not honored.  We have to
    // leave it this way now for backward compatibility.)
    //
    if (!ReadString(&Buf, &m_pwszApplicationName))
    {
        goto Cleanup;
    }

    //
    // If a full load, retrieve the rest of the variable length data,
    // including the triggers.
    //
    if (fAllData)
    {
        // Strings
        if (!(ReadString(&Buf, &m_pwszParameters) &&
              ReadString(&Buf, &m_pwszWorkingDirectory) &&
              ReadString(&Buf, &m_pwszCreator) &&
              ReadString(&Buf, &m_pwszComment)
              ))
        {
            goto Cleanup;
        }

        // User Data size
        if (!Buf.Read(&m_cbTaskData, sizeof m_cbTaskData))
        {
            goto Cleanup;
        }

        // User Data
        if (m_cbTaskData == 0)
        {
            m_pbTaskData = NULL;
        }
        else
        {
            m_pbTaskData = Buf.CurrentPosition();
            if (!Buf.Advance(m_cbTaskData))
            {
                goto Cleanup;
            }
        }

        // Size of reserved data
        if (!Buf.Read(&m_cReserved, sizeof m_cReserved))
        {
            goto Cleanup;
        }

        // Reserved data
        //
        // If there is reserved data, it must begin with a structure
        // that we recognize.  In this version we recognize the
        // TASKRESERVED1 structure.
        //
        m_pbReserved = NULL;
        if (m_cReserved == 0)
        {
            //
            // There is no reserved data.  Initialize the members that
            // we would have read from the reserved data to defaults.
            //
            m_hrStartError = SCHED_S_TASK_HAS_NOT_RUN;
            m_rgTaskFlags = 0;
        }
        else if (m_cReserved < sizeof(TASKRESERVED1))
        {
            ERR_OUT("CJob::Load, invalid reserved data", hr);
            m_cReserved = 0;
            goto Cleanup;
        }
        else
        {
            m_pbReserved = Buf.CurrentPosition();
            if (!Buf.Advance(m_cReserved))
            {
                goto Cleanup;
            }

            //
            // Copy the portion of the Reserved Data that we understand
            // into private data members.
            // It may not be aligned properly, so use CopyMemory.
            //
            TASKRESERVED1 Reserved;
            CopyMemory(&Reserved, m_pbReserved, sizeof Reserved);
            m_hrStartError = Reserved.hrStartError;
            m_rgTaskFlags  = Reserved.rgTaskFlags;
        }

        //
        // Load trigger data.
        //
        hr = this->_LoadTriggersFromBuffer(&Buf);
        if (FAILED(hr))
        {
            ERR_OUT("Loading triggers from storage", hr);
            goto Cleanup;
        }

#if !defined(_CHICAGO_)

        //
        // If there is more data after the triggers, it must begin with a
        // signature header and a signature.  If there is less data than
        // that, treat it as though the file has no signature.
        // If a signature is present, but its "minimum client version" is
        // greater than our version, treat it as though the file has no
        // signature.
        //
        JOB_SIGNATURE_HEADER SignHead;
        if (Buf.Read(&SignHead, sizeof SignHead) &&
            SignHead.wMinClientVersion <= JOB_SIGNATURE_CLIENT_VERSION)
        {
            m_pbSignature = Buf.CurrentPosition();
            if (!Buf.Advance(SIGNATURE_SIZE))
            {
                schDebugOut((DEB_ERROR, "CJob::Load: si too small, ignoring\n"));
                m_pbSignature = NULL;
            }
        }
        // else m_pbSignature was set to NULL in FreeProperties

#endif  // !defined(_CHICAGO_)

    }
    } // end CInputBuffer and flData scope

    hr = S_OK;

Cleanup:

    //
    // Close the file.
    //
    if (hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFile);
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::SaveP, private
//
//  Synopsis:   saves the object to storage, takes a TCHAR file name
//
//  Arguments:  [ptszFileName] - if null, save to the previously loaded file.
//              [fRemember]    - if TRUE, the object becomes associated with
//                               the new filename.
//              [flOptions]    - can have the following bits set:
//                  SAVEP_VARIABLE_LENGTH_DATA:
//                               if set, saves all job data except the running
//                               instance count.  If not set, saves
//                               only the fixed length data at the beginning
//                               of the job. The file must already exist (the
//                               filename must be NULL) in this case.
//
//                  SAVEP_RUNNING_INSTANCE_COUNT:
//                               if set, the running instance count is saved
//
//                  SAVEP_PRESERVE_NET_SCHEDULE:
//                               if NOT set, the JOB_I_FLAG_NET_SCHEDULE flag
//                               is automatically cleared.
//
//  Returns:    HRESULT codes.
//
//-----------------------------------------------------------------------------
HRESULT
CJob::SaveP(LPCTSTR ptszFileName, BOOL fRemember, ULONG flOptions)
{
    TRACE3(CJob, SaveP);

    HRESULT hr            = S_OK;
    HANDLE  hFile;
#if !defined(_CHICAGO_)
    BOOL    fSetSecurity  = FALSE;
#endif // !defined(_CHICAGO_)

    //
    // Decide which name to save the file as.  Use the one passed in if
    // there is one, otherwise use the previously remembered one.
    //
    LPCTSTR ptszFileToSaveAs = ptszFileName ? ptszFileName : m_ptszFileName;
    if (!(ptszFileToSaveAs && *ptszFileToSaveAs))
    {
        //
        // Can't do a save if there is no file name.
        //
        return E_INVALIDARG;
    }

    //
    // Figure out whether we will create a new file or open an existing one.
    // If using the passed in filename, then this is a save-as (or if
    // fRemember is false, a save-copy-as) operation and a new file must
    // be created.
    // If using the previously remembered filename, then a new file must
    // be created iff the file wasn't saved before.
    //
    DWORD dwDisposition;
    DWORD dwAttributes;

    if (!(ptszFileToSaveAs == m_ptszFileName && m_fFileCreated))
    {
        dwDisposition = CREATE_NEW;

        if (!(flOptions & SAVEP_VARIABLE_LENGTH_DATA))
        {
            //
            // Creating a new file is only valid if all the data is to be
            // saved. Otherwise we would end up with a partial (invalid) file.
            //
            return E_INVALIDARG;
        }

        dwAttributes = FILE_ATTRIBUTE_NORMAL;

        if (IsFlagSet(TASK_FLAG_HIDDEN))
        {
            dwAttributes = FILE_ATTRIBUTE_HIDDEN;
        }

        //
        // Always write running instance count on file create.
        //
        flOptions |= SAVEP_RUNNING_INSTANCE_COUNT;

        //
        // On file creation, generate a unique ID for this job.
        // Done for Win95 as well as NT.
        //

        GenerateUniqueID(&m_uuidJob);

#if !defined(_CHICAGO_)
        //
        // Set security on file creation. This is done after all writes
        // have succeeded and the file has been closed.
        //

        fSetSecurity = TRUE;
#endif // !defined(_CHICAGO_)
    }
    else
    {
        //
        // This is a save to an existing file.
        //
        dwDisposition = OPEN_EXISTING;

        dwAttributes = GetFileAttributes(m_ptszFileName);
        if (dwAttributes == -1)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            ERR_OUT("CJob::Save, GetFileAttributes", hr);
            return hr;
        }

        DWORD dwOrgAttributes = dwAttributes;

        //
        // Remove the read-only attribute.
        //

        dwAttributes &= ~FILE_ATTRIBUTE_READONLY;

        //
        // If the hidden flag is set and the hidden attribute has
        // not been set yet, set it now.
        //

        if (IsFlagSet(TASK_FLAG_HIDDEN))
        {
            dwAttributes |= FILE_ATTRIBUTE_HIDDEN;
        }

        if (dwAttributes != dwOrgAttributes)
        {
            SetFileAttributes(m_ptszFileName, dwAttributes);
        }
    }

    //
    // Create/Open the file.
    //
    hFile = CreateFile(ptszFileToSaveAs,
                       GENERIC_WRITE,
                       0,
                       NULL,
                       dwDisposition,
                       dwAttributes              |
                       FILE_FLAG_SEQUENTIAL_SCAN,
                       NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ERR_OUT("CJob::Save, file open/create", hr);
        return hr;
    }

    if (fRemember || ptszFileToSaveAs == m_ptszFileName)
    {
        m_fFileCreated = TRUE;
    }

    //
    // Initialize the creator property if not already done so.
    // Set it to the caller's username.
    //

    if (m_pwszCreator == NULL)
    {
        //
        // Other than out of memory, if an error occurs, leave the
        // creator field alone.
        //

        TCHAR tszUserName[MAX_USERNAME + 1];
        DWORD ccUserName = MAX_USERNAME + 1;

        if (GetUserName(tszUserName, &ccUserName))
        {
            // NB : GetUserName returned char count includes the null
            //      character.
            //
            m_pwszCreator = new WCHAR[ccUserName];

            if (m_pwszCreator == NULL)
            {
                hr = E_OUTOFMEMORY;
                CHECK_HRESULT(hr);
                goto ErrExit;
            }

#if defined(UNICODE)
            lstrcpy(m_pwszCreator, tszUserName);
#else
            hr = AnsiToUnicode(m_pwszCreator, tszUserName, ccUserName);
            Win4Assert(SUCCEEDED(hr));
#endif // defined(UNICODE)
        }
    }

    { // scope to avoid "initialization skipped" error

    BOOL fUpdateJobState = FALSE;

    //
    // The disabled flag takes precedence over other states except running.
    //
    if (IsFlagSet(TASK_FLAG_DISABLED))
    {
        if (!IsStatus(SCHED_S_TASK_RUNNING))
        {
            SetStatus(SCHED_S_TASK_DISABLED);
        }
    }
    else
    {
        if (IsStatus(SCHED_S_TASK_DISABLED))
        {
            //
            // UpdateJobState will set the correct status if no longer
            // disabled.
            //
            fUpdateJobState = TRUE;
        }
    }

    //
    // Check to see if the triggers are dirty. If so, update the job status
    // and flags before writing it out.
    //
    if (IsFlagSet(JOB_I_FLAG_TRIGGERS_DIRTY))
    {
        fUpdateJobState = TRUE;
    }

    //
    // The flag value JOB_I_FLAG_RUN_PROP_CHANGE is never written to disk.
    // Instead, the need for a wait list rebuild is signalled by clearing
    // JOB_I_FLAG_NO_RUN_PROP_CHANGE. If JOB_I_FLAG_RUN_PROP_CHANGE were to be
    // written to disk, then CheckDir would see this bit set and do a wait
    // list rebuild, but it would also need to clear the bit to prevent
    // successive wait list rebuilds. However, the write to clear the bit
    // would cause an additional change notification and CheckDir call. So, to
    // avoid this thrashing, we signal a wait list rebuild by the absence of
    // the JOB_I_FLAG_NO_RUN_PROP_CHANGE bit.
    //
    if (IsFlagSet(JOB_I_FLAG_RUN_PROP_CHANGE))
    {
        ClearFlag(JOB_I_FLAG_RUN_PROP_CHANGE);
        ClearFlag(JOB_I_FLAG_NO_RUN_PROP_CHANGE);
        fUpdateJobState = TRUE;
    }

    if (fUpdateJobState)
    {
        UpdateJobState(FALSE);
    }

    //
    // Regenerate a unique id for the job (a GUID) when the application
    // changes. This is done for security reasons.
    //
    // NB : We need to do this for Win95 as well as NT since we may be
    //      editing an NT job from a Win95 machine.
    //

    if (IsFlagSet(JOB_I_FLAG_APPNAME_CHANGE))
    {
        GenerateUniqueID(&m_uuidJob);
        ClearFlag(JOB_I_FLAG_APPNAME_CHANGE);
    }

    if (!(flOptions & SAVEP_PRESERVE_NET_SCHEDULE))
    {
        ClearFlag(JOB_I_FLAG_NET_SCHEDULE);
    }

    //
    // Save Job fixed length data.
    //

    // Allocate a stack buffer which will be sufficient if we are not
    // saving variable length data.
    // Note that sizeof flStruct > sizeof FIXDLEN_DATA + sizeof WORD,
    // due to struct packing requirements, so don't use sizeof flStruct
    // to compute offsets.
    //
    struct FLSTRUCT
    {
        FIXDLEN_DATA flData;
        WORD         cRunningInstances;
    } flStruct;

    // This code depends on flData and cRunningInstances being contiguous
    schAssert(FIELD_OFFSET(FLSTRUCT, cRunningInstances) == sizeof FIXDLEN_DATA);

    flStruct.flData.wVersion            = m_wVersion;
    flStruct.flData.wFileObjVer         = m_wFileObjVer;
    flStruct.flData.uuidJob             = m_uuidJob;
    flStruct.flData.wAppNameLenOffset   = sizeof(FIXDLEN_DATA) +
                                 sizeof(m_cRunningInstances);
    flStruct.flData.wTriggerOffset      = m_wTriggerOffset;
    flStruct.flData.wErrorRetryCount    = m_wErrorRetryCount;
    flStruct.flData.wErrorRetryInterval = m_wErrorRetryInterval;
    flStruct.flData.wIdleWait           = m_wIdleWait;
    flStruct.flData.wIdleDeadline       = m_wIdleDeadline;
    flStruct.flData.dwPriority          = m_dwPriority;
    flStruct.flData.dwMaxRunTime        = m_dwMaxRunTime;
    flStruct.flData.ExitCode            = m_ExitCode;
    flStruct.flData.hrStatus            = m_hrStatus;
    //
    // Don't save the dirty & set account information flags.
    //
    flStruct.flData.rgFlags             = m_rgFlags & ~NON_PERSISTED_JOB_FLAGS;

    flStruct.flData.stMostRecentRunTime = m_stMostRecentRunTime;
    flStruct.cRunningInstances          = m_cRunningInstances;

    //
    // Compute the number of bytes to write to the file.  This will be
    // the size of the intermediate buffer to be allocated.
    //
    BYTE * pSource = (BYTE *) &flStruct;
    DWORD cbToWrite = sizeof(flStruct.flData);

    //
    // Save the running instance data only if (a) the file is being created,
    // or (b) the SAVEP_RUNNING_INSTANCE_COUNT option is set.
    // If SAVEP_VARIABLE_LENGTH_DATA is set, allocate temporary space for the
    // running instance count, regardless of whether we are going to write it.
    //
    if (flOptions & (SAVEP_RUNNING_INSTANCE_COUNT |
                     SAVEP_VARIABLE_LENGTH_DATA))
    {
        cbToWrite += sizeof(flStruct.cRunningInstances);
    }

    if (flOptions & SAVEP_VARIABLE_LENGTH_DATA)
    {
        //
        // Add the space needed to write the strings and their lengths.
        // Save the lengths for use later.
        //
        WORD acStringLen[ARRAY_LEN(s_StringField)]; // array of string lengths
        cbToWrite += sizeof acStringLen;

        for (int i = 0; i < ARRAY_LEN(acStringLen); i++)
        {
            LPWSTR pwsz = this->*s_StringField[i];
            acStringLen[i] = (pwsz && *pwsz) ? wcslen(pwsz) + 1 : 0;
            cbToWrite += acStringLen[i] * sizeof WCHAR;
        }

        //
        // Add the space needed to write the user data, the reserved data
        // and their lengths.
        //
        if (m_cReserved < sizeof TASKRESERVED1)
        {
            schAssert(m_cReserved == 0);
            m_cReserved = sizeof TASKRESERVED1;
        }
        cbToWrite += sizeof(m_cbTaskData) + m_cbTaskData
                   + sizeof(m_cReserved) + m_cReserved;

        //
        // cbToWrite is now the offset to the trigger data.  Save it.
        //
        schAssert(cbToWrite <= MAXUSHORT);    // BUGBUG Do NOT just assert.
			// Also return a "limit exceeded" error.
        flStruct.flData.wTriggerOffset = m_wTriggerOffset = (WORD) cbToWrite;

        //
        // Add the space needed to write the triggers and their count.
        //
        WORD cTriggers = m_Triggers.GetCount();
        cbToWrite += sizeof cTriggers + cTriggers * sizeof TASK_TRIGGER;

#if !defined(_CHICAGO_)
        //
        // If the job has a signature, add the space needed to write it.
        //
        if (m_pbSignature != NULL)
        {
            cbToWrite += sizeof(JOB_SIGNATURE_HEADER) + SIGNATURE_SIZE;
        }
#endif  // !defined(_CHICAGO_)

        //
        // We have now computed the required space.  Allocate a buffer of
        // that size.
        //
        pSource = new BYTE[cbToWrite];
        if (pSource == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto ErrExit;
        }

        //
        // Copy data into the buffer.
        //
        BYTE * pCurrent = pSource;  // current write position

        #define WRITE_DATA(pSrc, cbSize)                \
            CopyMemory(pCurrent, (pSrc), (cbSize));     \
            pCurrent += (cbSize);

        // FIXDLEN_DATA and Running Instance Count
        WRITE_DATA(&flStruct, sizeof flStruct.flData +
                              sizeof flStruct.cRunningInstances);

        // Strings
        for (i = 0; i < ARRAY_LEN(acStringLen); i++)
        {
            schAssert(POINTER_IS_ALIGNED(pCurrent, ALIGN_WORD));
            *(WORD *) pCurrent = acStringLen[i];
            pCurrent += sizeof WORD;

            WRITE_DATA(this->*s_StringField[i],
                       acStringLen[i] * sizeof WCHAR);
        }

        // User data
        schAssert(POINTER_IS_ALIGNED(pCurrent, ALIGN_WORD));
        *(WORD *) pCurrent = m_cbTaskData;
        pCurrent += sizeof WORD;

        WRITE_DATA(m_pbTaskData, m_cbTaskData);
        // Note that pCurrent may no longer be WORD-aligned

        // Reserved data
        WRITE_DATA(&m_cReserved, sizeof m_cReserved);

        // Copy private members into the reserved data block to save
        TASKRESERVED1 Reserved1 = { m_hrStartError, m_rgTaskFlags };
        if (m_pbReserved == NULL)
        {
            schAssert(m_cReserved == sizeof Reserved1);
            WRITE_DATA(&Reserved1, m_cReserved);
        }
        else
        {
            schAssert(m_cReserved >= sizeof Reserved1);
            CopyMemory(m_pbReserved, &Reserved1, sizeof Reserved1);
            WRITE_DATA(m_pbReserved, m_cReserved);
        }

        // Triggers
        WRITE_DATA(&cTriggers, sizeof cTriggers);
        WRITE_DATA(m_Triggers.GetArray(), sizeof TASK_TRIGGER * cTriggers);

#if !defined(_CHICAGO_)
        // Signature
        if (m_pbSignature != NULL)
        {
            JOB_SIGNATURE_HEADER SignHead;
            SignHead.wSignatureVersion = JOB_SIGNATURE_VERSION;
            SignHead.wMinClientVersion = JOB_SIGNATURE_MIN_CLIENT_VERSION;

            WRITE_DATA(&SignHead, sizeof SignHead);
            WRITE_DATA(m_pbSignature, SIGNATURE_SIZE);
        }
#endif  // !defined(_CHICAGO_)

        #undef WRITE_DATA

        schAssert(pCurrent == pSource + cbToWrite);
    }

    //
    // Actually write the data to the file
    //
    if ((flOptions & SAVEP_VARIABLE_LENGTH_DATA) &&
        !(flOptions & SAVEP_RUNNING_INSTANCE_COUNT))
    {
        //
        // Write FIXDLEN_DATA, skip over the running instance count, and
        // write the variable length data
        //
        DWORD cbWritten;
        if (!WriteFile(hFile, pSource, sizeof FIXDLEN_DATA, &cbWritten, NULL)
            || cbWritten != sizeof FIXDLEN_DATA)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            ERR_OUT("CJob::Save, write of Job fixed length data", hr);
            goto Cleanup;
        }

        DWORD dwNewPos = SetFilePointer(hFile,
                                        sizeof(m_cRunningInstances),
                                        NULL,
                                        FILE_CURRENT);
        if (dwNewPos == 0xffffffff)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            ERR_OUT("CJob::Save, moving past running instance count", hr);
            goto Cleanup;
        }

        cbToWrite -= (sizeof FIXDLEN_DATA + sizeof m_cRunningInstances);

        if (!WriteFile(hFile,
                       pSource + (sizeof FIXDLEN_DATA + sizeof m_cRunningInstances),
                       cbToWrite,
                       &cbWritten,
                       NULL)
            || cbWritten != cbToWrite)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            ERR_OUT("CJob::Save, write of Job variable length data", hr);
            goto Cleanup;
        }
    }
    else
    {
        //
        // We can do it all in a single WriteFile.
        //
        DWORD cbWritten;
        if (!WriteFile(hFile, pSource, cbToWrite, &cbWritten, NULL)
            || cbWritten != cbToWrite)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            ERR_OUT("CJob::Save, write of Job", hr);
            goto Cleanup;
        }
    }

    if ((flOptions & SAVEP_VARIABLE_LENGTH_DATA) &&
        !SetEndOfFile(hFile))
    {
        ERR_OUT("CJob::Save, SetEOF", HRESULT_FROM_WIN32(GetLastError()));
    }

Cleanup:

    CloseHandle(hFile);
    hFile = NULL;

    if (pSource != (BYTE *) &flStruct)
    {
        delete [] pSource;
    }

    if (FAILED(hr))
    {
        goto ErrExit;
    }

    } // end scope

    //
    // Notify the shell of the changes.
    //
    if (ptszFileName != NULL)
    {
        SHChangeNotify(SHCNE_CREATE, SHCNF_PATH, ptszFileName, NULL);
    }
    else
    {
        SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_PATH, m_ptszFileName, NULL);
    }

    //
    // If doing a Save-As, save the new filename.
    //
    if (fRemember && ptszFileName != NULL)
    {
        delete m_ptszFileName;
        m_ptszFileName = new TCHAR[lstrlen(ptszFileName) + 1];
        if (!m_ptszFileName)
        {
            ERR_OUT("CJob::SaveP", E_OUTOFMEMORY);
            hr = E_OUTOFMEMORY;
            goto ErrExit;
        }

        lstrcpy(m_ptszFileName, ptszFileName);
    }

    if (ptszFileName == NULL || fRemember)
    {
        //
        // BUGBUG: this is not strictly accurate.  There could be a dirty
        // string prop that wouldn't be saved during a light save
        // (SAVEP_VARIABLE_LENGTH_DATA not specified).  This source of
        // potential error could be alleviated by breaking
        // JOB_I_FLAG_PROPERTIES_DIRTY into two flags:
        // JOB_I_FLAG_FIXED_PROPS_DIRTY & JOB_I_FLAG_VAR_PROPS_DIRTY
        //
        ClearFlag(JOB_I_FLAG_PROPERTIES_DIRTY);

        if (flOptions & SAVEP_VARIABLE_LENGTH_DATA)
        {
            ClearFlag(JOB_I_FLAG_TRIGGERS_DIRTY);
        }
    }

#if !defined(_CHICAGO_)
    //
    // Set default privileges on the file. This is done only for new
    // files created as a result of save.
    //

    if (fSetSecurity)
    {
        //
        // NB : Logic prior to CreateFile guarantees the file name
        //      will not be NULL.
        //

        hr = SetTaskFileSecurity(ptszFileToSaveAs,
                                 this->IsFlagSet(JOB_I_FLAG_NET_SCHEDULE));

        if (FAILED(hr))
        {
            goto ErrExit;
        }
    }
#endif // !defined(_CHICAGO_)

    return S_OK;

ErrExit:
    if (hFile != NULL) CloseHandle(hFile);

    if (dwDisposition == CREATE_NEW)
    {
        if (!DeleteFile(ptszFileToSaveAs))
        {
            ERR_OUT("CJob::SaveP: DeleteFile", GetLastError());
        }
    }
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::IPersistFile::SaveCompleted
//
//  Synopsis:   indicates the caller has saved the file with a call to
//              IPersistFile::Save and is finished working with it
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::SaveCompleted(LPCOLESTR pwszFileName)
{
    TRACE(CJob, SaveCompleted);
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::IPersistFile::GetCurFile
//
//  Synopsis:   supplies either the absolute path of the currently loaded
//              script file or the default filename prompt, if there is no
//              currently-associated file
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::GetCurFile(LPOLESTR * ppwszFileName)
{
    TRACE(CJob, GetCurFile);

    HRESULT hr;
    TCHAR * ptszName, tszDefaultName[SCH_SMBUF_LEN];
    WCHAR * pwszName, * pwszBuf = NULL;

    if (!m_ptszFileName || m_ptszFileName[0] == TEXT('\0'))
    {
        //
        // No file currently loaded, return default prompt 'cause that is
        // what the OLE spec says to do.
        //
        lstrcpy(tszDefaultName, TEXT("*.") TSZ_JOB);
        ptszName = tszDefaultName;
        hr = S_FALSE;
    }
    else
    {
        ptszName = m_ptszFileName;
        hr = S_OK;
    }

#if defined(UNICODE)

    pwszName = ptszName;

#else   // convert ANSI file name to UNICODE

    int cch = lstrlen(ptszName) + 1;  // include null in count
    pwszBuf = new WCHAR[cch];
    if (!pwszBuf)
    {
        ERR_OUT("CJob::GetCurFile", E_OUTOFMEMORY);
        *ppwszFileName = NULL;
        return E_OUTOFMEMORY;
    }

    hr = AnsiToUnicode(pwszBuf, ptszName, cch);
    if (FAILED(hr))
    {
        CHECK_HRESULT(hr)
        delete pwszBuf;
        return E_FAIL;
    }

    pwszName = pwszBuf;

#endif

    int size = wcslen(pwszName);
    LPOLESTR pwz;
    pwz = (LPOLESTR)CoTaskMemAlloc((size + 1) * sizeof(WCHAR));
    if (!pwz)
    {

#if !defined(UNICODE)

        delete pwszBuf;

#endif

        *ppwszFileName = NULL;
        return E_OUTOFMEMORY;
    }

    wcscpy(pwz, pwszName);
    *ppwszFileName = pwz;

#if !defined(UNICODE)

    delete pwszBuf;

#endif

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::FreeProperties
//
//  Synopsis:   Frees variable length property memory
//
//-----------------------------------------------------------------------------
void
CJob::FreeProperties(void)
{
    for (int iProperty = 0;
         iProperty < ARRAY_LEN(s_StringField);
         iProperty++)
    {
        DELETE_CJOB_FIELD(this->*s_StringField[iProperty])
    }

    DELETE_CJOB_FIELD(m_pbTaskData)
    m_cbTaskData = 0;

    DELETE_CJOB_FIELD(m_pbReserved)
    m_cReserved = 0;

#if !defined(_CHICAGO_)
    DELETE_CJOB_FIELD(m_pbSignature)
    m_pbSignature = 0;
#endif
}

//+----------------------------------------------------------------------------
//
//  Function:   ReadString
//
//  Synopsis:   Reads a wide char string in from an in-memory buffer
//
//-----------------------------------------------------------------------------
BOOL
ReadString(CInputBuffer * pBuf, LPWSTR *ppwsz)
{
    schAssert(POINTER_IS_ALIGNED(pBuf->CurrentPosition(), ALIGN_WORD));
    schAssert(*ppwsz == NULL);

    //
    // Read the string length
    //
    WORD cch;
    if (!pBuf->Read(&cch, sizeof cch))
    {
        ERR_OUT("ReadString, file lacks string length", 0);
        return FALSE;
    }

    if (cch != 0)
    {
        LPWSTR pwsz = (LPWSTR) pBuf->CurrentPosition();

        //
        // The string length mustn't exceed the buffer size
        //
        if (!pBuf->Advance(cch * sizeof WCHAR))
        {
            ERR_OUT("ReadString, string overruns file size", 0);
            return FALSE;
        }

        //
        // Verify null termination
        //
        if (pwsz[cch-1] != L'\0')
        {
            ERR_OUT("ReadString, string not null terminated", 0);
            return FALSE;
        }

        *ppwsz = pwsz;
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Function:   GenerateUniqueID
//
//  Synopsis:   Intialize the UUID passed to a unique ID. On NT, UuidCreate
//              initializes it. If UuidCreate fails, default to our custom
//              ID generation code which is used always on Win95.
//
//  Arguments:  [pUuid] -- Ptr to UUID to initialize.
//
//  Returns:    None.
//
//  Notes:      None.
//
//-----------------------------------------------------------------------------
void
GenerateUniqueID(GUID * pUuid)
{
    schAssert(pUuid != NULL);

#if !defined(_CHICAGO_)

    //
    // Call UuidCreate only on NT. If this should fail, drop down to
    // our own id generation.
    //

    if (UuidCreate(pUuid) == RPC_S_OK)
    {
        return;
    }
#endif // !defined(_CHICAGO_)

    //
    // Must generate our own unique id.
    //
    // Set Data 1 to the windows tick count.
    //

    pUuid->Data1 = GetTickCount();

    //
    // Set Data2 & Data3 to the current system time milliseconds
    // and seconds values respectively.
    //

    SYSTEMTIME systime;
    GetSystemTime(&systime);

    pUuid->Data2 = systime.wMilliseconds;
    pUuid->Data3 = systime.wSecond;

    //
    // Write the passed uuid ptr address into the first 4 bytes of
    // Data4. Then write the current system time minute value into
    // the following 2. The remaining 2 we'll leave as-is.
    //

    CopyMemory(&pUuid->Data4, &pUuid, sizeof(GUID *));
    CopyMemory((&pUuid->Data4) + sizeof(GUID *), &systime.wMinute,
                    sizeof(systime.wMinute));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\pch\headers.cxx ===
#include "headers.hxx"
#pragma hdrstop

//
// This is a dummy file to force the creation of the global precompiled
// header.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\schedui\advanced.cxx ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       advanced.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    3/13/1996   RaviR   Created
//				11/16/00	Dgrube  Remove     Win4Assert(m_pjt->MinutesInterval >= 0);
//							Win4Assert(m_pjt->MinutesDuration >= 0); Since they are
//							DWORD this is always true and is causing compiler erros
//
//____________________________________________________________________________


#include "..\pch\headers.hxx"
#pragma hdrstop

#include "..\folderui\dbg.h"
#include "..\folderui\macros.h"
#include "..\inc\resource.h"
#include "..\inc\dll.hxx"

#include "dlg.hxx"
#include "rc.h"
#include <mstask.h>
#include "uiutil.hxx"
#include "strings.hxx"
#include "timeutil.hxx"
#include "helpids.h"


//
//  (Control id, help id) list for context sensitivity help.
//

ULONG s_aAdvancedDlgHelpIds[] =
{
    dlg_advanced,               Hdlg_advanced,
    lbl_start_date,             Hlbl_start_date,
    dp_start_date,              Hdp_start_date,
    chk_repeat_task,            Hchk_repeat_task,
    txt_repeat_task,            Htxt_repeat_task,
    spin_repeat_task,           Hspin_repeat_task,
    cbx_time_unit,              Hcbx_time_unit,
    dp_end_date,                Hdp_end_date,
    chk_terminate_at_end,       Hchk_terminate_at_end,
    rb_end_time,                Hrb_end_time,
    rb_end_duration,            Hrb_end_duration,
    dp_end_time,                Hdp_end_time,
    txt_end_duration_hr,        Htxt_end_duration_hr,
    spin_end_duration_hr,       Hspin_end_duration_hr,
    txt_end_duration_min,       Htxt_end_duration_min,
    spin_end_duration_min,      Hspin_end_duration_min,
    grp_repeat_until,           Hgrp_repeat_until,
    lbl_hours,                  Hlbl_hours,
    lbl_min,                    Hlbl_min,
    chk_end_date,               Hchk_end_date,
    lbl_every,                  Hlbl_every,
    lbl_until,                  Hlbl_until,
    0,0
};

extern "C" TCHAR szMstaskHelp[];


//
//  externs
//

extern HINSTANCE g_hInstance;



#define INDEX_MINUTES   0
#define INDEX_HOURS     1


const size_t c_MinsPerDay = (60 * 24);


class CAdvScheduleDlg : public CDlg
{
public:

    CAdvScheduleDlg(PTASK_TRIGGER pjt) : m_pjt(pjt), CDlg() {}
    virtual ~CAdvScheduleDlg() {}

protected:

    virtual INT_PTR RealDlgProc(UINT uMsg, WPARAM wParam, LPARAM lParam);

private:

    LRESULT _OnInitDialog(LPARAM lParam);
    LRESULT _OnCommand(int id, HWND hwndCtl, UINT codeNotify);
    BOOL    _OnOK(void);
    void    _EnableRepeatCtrls(BOOL fEnable);
    LRESULT _OnSetIniChange(WPARAM wParam, LPARAM lParam);
    LRESULT _OnHelp(HANDLE hRequesting, UINT uiHelpCommand);

    void    _ErrorDialog(int idsErr, LONG error = 0, UINT idsHelpHint = 0)
                  { SchedUIErrorDialog(Hwnd(), idsErr, error, idsHelpHint); }

    PTASK_TRIGGER    m_pjt;

    //
    // Time format string for use with Date picker control
    //

    TCHAR           m_tszTimeFormat[MAX_DP_TIME_FORMAT];
};


INT_PTR
AdvancedDialog(
    HWND          hParent,
    PTASK_TRIGGER pjt)
{
    CAdvScheduleDlg * pAdvScheduleDlg = new CAdvScheduleDlg(pjt);

    if (pAdvScheduleDlg != NULL)
    {
        return pAdvScheduleDlg->DoModal(dlg_advanced, hParent);
    }

    return FALSE;
}


INT_PTR
CAdvScheduleDlg::RealDlgProc(
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam)
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        return _OnInitDialog(lParam);

    case WM_COMMAND:
        return(_OnCommand(GET_WM_COMMAND_ID(wParam, lParam),
                          GET_WM_COMMAND_HWND(wParam, lParam),
                          GET_WM_COMMAND_CMD(wParam, lParam)));

    case WM_DESTROY:
        SetWindowLongPtr(Hwnd(), DWLP_USER, 0L);
        delete this;
        break;

    case WM_SETTINGCHANGE: // WM_WININICHANGE
        _OnSetIniChange(wParam, lParam);
        break;

    case WM_HELP:
        return _OnHelp(((LPHELPINFO) lParam)->hItemHandle, HELP_WM_HELP);

    case WM_CONTEXTMENU:
        return _OnHelp((HANDLE) wParam, HELP_CONTEXTMENU);

    default:
        return FALSE;
    }

    return TRUE;
}



LRESULT
CAdvScheduleDlg::_OnSetIniChange(
    WPARAM  wParam,
    LPARAM  lParam)
{
    TRACE(CAdvScheduleDlg, _OnSetIniChange);

    DateTime_SetFormat(_hCtrl(dp_start_date), NULL);
    DateTime_SetFormat(_hCtrl(dp_end_date), NULL);

    UpdateTimeFormat(m_tszTimeFormat, ARRAYLEN(m_tszTimeFormat));
    DateTime_SetFormat(_hCtrl(dp_end_time), m_tszTimeFormat);
    return 0;
}


LRESULT
CAdvScheduleDlg::_OnHelp(
    HANDLE hRequesting,
    UINT uiHelpCommand)
{
    WinHelp((HWND) hRequesting,
            szMstaskHelp,
            uiHelpCommand,
            (DWORD_PTR)(LPSTR)s_aAdvancedDlgHelpIds);
    return TRUE;
}



LRESULT
CAdvScheduleDlg::_OnInitDialog(
    LPARAM lParam)
{
    //
    // Initialize time format string m_tszTimeFormat
    //

    UpdateTimeFormat(m_tszTimeFormat, ARRAYLEN(m_tszTimeFormat));

    //
    //  Init the time unit combo box
    //

    HWND hCombo = GetDlgItem(Hwnd(), cbx_time_unit);

    TCHAR tcBuff[100];

    LoadString(g_hInstance, IDS_MINUTES, tcBuff, 100);
    ComboBox_AddString(hCombo, tcBuff);

    LoadString(g_hInstance, IDS_HOURS, tcBuff, 100);
    ComboBox_AddString(hCombo, tcBuff);

    //
    // Init all the spin controls, and the associated edit controls
    //

    Spin_SetRange(Hwnd(), spin_repeat_task, 1, 9999);
    Spin_SetRange(Hwnd(), spin_end_duration_hr, 0, 9999);
    Spin_SetRange(Hwnd(), spin_end_duration_min, 0, 59);

    SendDlgItemMessage(Hwnd(), txt_repeat_task, EM_LIMITTEXT, 4, 0);
    SendDlgItemMessage(Hwnd(), txt_end_duration_hr, EM_LIMITTEXT, 4, 0);
    SendDlgItemMessage(Hwnd(), txt_end_duration_min, EM_LIMITTEXT, 2, 0);

    //
    //  Set the start and end dates.
    //

    SYSTEMTIME  st;

    ZeroMemory(&st, sizeof st);
    st.wYear        = m_pjt->wBeginYear;
    st.wMonth       = m_pjt->wBeginMonth;
    st.wDay         = m_pjt->wBeginDay;

    if (DateTime_SetSystemtime(_hCtrl(dp_start_date), GDT_VALID, &st) == FALSE)
    {
        DEBUG_OUT((DEB_USER1, "DateTime_SetSystemtime failed, err %uL.\n", GetLastError()));
    }

    if (m_pjt->rgFlags & TASK_TRIGGER_FLAG_HAS_END_DATE)
    {
        CheckDlgButton(Hwnd(), chk_end_date, BST_CHECKED);

        st.wYear        = m_pjt->wEndYear;
        st.wMonth       = m_pjt->wEndMonth;
        st.wDay         = m_pjt->wEndDay;

        if (DateTime_SetSystemtime(_hCtrl(dp_end_date), GDT_VALID, &st)
            == FALSE)
        {
            DEBUG_OUT((DEB_USER1, "DateTime_SetSystemtime failed.\n"));
        }
    }
    else
    {
        CheckDlgButton(Hwnd(), chk_end_date, BST_UNCHECKED);

        DateTime_SetFormat(_hCtrl(dp_end_date), tszBlank);

        EnableWindow(_hCtrl(dp_end_date), FALSE);
    }

    if (m_pjt->TriggerType == TASK_TIME_TRIGGER_ONCE)
    {
        EnableWindow(_hCtrl(lbl_start_date), FALSE);
        EnableWindow(_hCtrl(dp_start_date), FALSE);
        EnableWindow(_hCtrl(chk_end_date), FALSE);
        EnableWindow(_hCtrl(dp_end_date), FALSE);
    }

    //
    //  Set repetition
    //

    if (m_pjt->MinutesInterval > 0)
    {
        CheckDlgButton(Hwnd(), chk_repeat_task, BST_CHECKED);

        if (m_pjt->MinutesInterval % 60)
        {
            Spin_SetPos(Hwnd(), spin_repeat_task, (WORD)m_pjt->MinutesInterval);
            ComboBox_SetCurSel(hCombo, INDEX_MINUTES);
        }
        else
        {
            Spin_SetPos(Hwnd(), spin_repeat_task,
                        (WORD)(m_pjt->MinutesInterval / 60));

            ComboBox_SetCurSel(hCombo, INDEX_HOURS);
        }

        //
        //  Set end time / duration
        //

        CheckRadioButton(Hwnd(), rb_end_time, rb_end_duration,
                                                    rb_end_duration);

        WORD wHours = (WORD) (m_pjt->MinutesDuration / 60);
        WORD wMins  = (WORD) (m_pjt->MinutesDuration % 60);

        if (wHours > 9999)
        {
            wMins += (wHours - 9999) * 60;
        }

        Spin_SetPos(Hwnd(), spin_end_duration_hr, wHours);
        Spin_SetPos(Hwnd(), spin_end_duration_min, wMins);

        DateTime_SetFormat(_hCtrl(dp_end_time), tszBlank);
        EnableWindow(_hCtrl(dp_end_time), FALSE);

        //
        //  Set terminate at end
        //

        if (m_pjt->rgFlags & TASK_TRIGGER_FLAG_KILL_AT_DURATION_END)
        {
            CheckDlgButton(Hwnd(), chk_terminate_at_end, BST_CHECKED);
        }
    }
    else
    {
        CheckDlgButton(Hwnd(), chk_repeat_task, BST_UNCHECKED);

        _EnableRepeatCtrls(FALSE);
    }

    return TRUE;
}


void
CAdvScheduleDlg::_EnableRepeatCtrls(
    BOOL fEnable)
{
    int aCtrls[] =
    {
        lbl_every,
        txt_repeat_task,
        spin_repeat_task,
        cbx_time_unit,
        lbl_until,
        rb_end_time,
        rb_end_duration,
        txt_end_duration_hr,
        spin_end_duration_hr,
        lbl_hours,
        txt_end_duration_min,
        spin_end_duration_min,
        lbl_min,
        chk_terminate_at_end,
        dp_end_time // CAUTION: last position is special, see comment below
    };

    int cCtrls;

    //
    // If we're disabling repeat controls, disable them all, i.e. set cCtrls
    // the number of repeat controls.
    //
    // Otherwise if we're enabling controls, set cCtrls to the number of
    // repeat controls less one.  This will prevent the end time date-
    // picker control from being enabled.  We need to do this because when
    // these controls are being enabled, the Duration radio button is
    // always checked, therefore the end time date picker should always
    // remain disabled.
    //

    if (fEnable == FALSE)
    {
        cCtrls = ARRAYLEN(aCtrls);
        DateTime_SetFormat(_hCtrl(dp_end_time), tszBlank);

        SetDlgItemText(Hwnd(), txt_repeat_task, TEXT(""));
        SetDlgItemText(Hwnd(), txt_end_duration_hr, TEXT(""));
        SetDlgItemText(Hwnd(), txt_end_duration_min, TEXT(""));
        SetDlgItemText(Hwnd(), cbx_time_unit, TEXT(""));
    }
    else
    {
        cCtrls = ARRAYLEN(aCtrls) - 1;
        Spin_SetPos(Hwnd(), spin_repeat_task, 10);

        ComboBox_SetCurSel(_hCtrl(cbx_time_unit), INDEX_MINUTES);

        CheckRadioButton(Hwnd(), rb_end_time, rb_end_duration,
                                                        rb_end_duration);

        Spin_SetPos(Hwnd(), spin_end_duration_hr, 1);
        Spin_SetPos(Hwnd(), spin_end_duration_min, 0);
    }


    for (int i=0; i < cCtrls; i++)
    {
        EnableWindow(_hCtrl(aCtrls[i]), fEnable);
    }
}



LRESULT
CAdvScheduleDlg::_OnCommand(
    int  id,
    HWND hwndCtl,
    UINT codeNotify)
{
    SYSTEMTIME st;
    GetSystemTime(&st);

    switch (id)
    {
    case chk_end_date:
        if (IsDlgButtonChecked(Hwnd(), chk_end_date) == BST_CHECKED)
        {
            FILETIME ftNow, ftStart;
            SYSTEMTIME stStart, stEnd;
			
            CopyMemory(&stEnd, &st, sizeof(SYSTEMTIME));

            if (DateTime_GetSystemtime(_hCtrl(dp_start_date), &stStart) == GDT_VALID)
            {
                // compare start time to current date, set End == max of the two
                SystemTimeToFileTime(&stStart, &ftStart);
                SystemTimeToFileTime(&st, &ftNow);
                if (CompareFileTime(&ftStart, &ftNow) <= 0)
                {
                    FileTimeToSystemTime(&ftNow, &stEnd);
                }
                else
                {
                    FileTimeToSystemTime(&ftStart, &stEnd);
                }
            }
            DateTime_SetSystemtime(_hCtrl(dp_end_date), GDT_VALID, &stEnd);
            DateTime_SetFormat(_hCtrl(dp_end_date), tszEmpty);
            EnableWindow(_hCtrl(dp_end_date), TRUE);
        }
        else
        {
            DateTime_SetFormat(_hCtrl(dp_end_date), tszBlank);
            EnableWindow(_hCtrl(dp_end_date), FALSE);
        }
        break;

    case chk_repeat_task:
        if (IsDlgButtonChecked(Hwnd(), chk_repeat_task) == BST_CHECKED)
        {
            _EnableRepeatCtrls(TRUE);
        }
        else
        {
            _EnableRepeatCtrls(FALSE);
        }
        break;

    case rb_end_time:
        //if (IsDlgButtonChecked(Hwnd(), rb_end_time) == BST_CHECKED)
        {
            EnableWindow(_hCtrl(dp_end_time), TRUE);
            DateTime_SetFormat(_hCtrl(dp_end_time), m_tszTimeFormat);

            Spin_Disable(Hwnd(), spin_end_duration_hr);
            Spin_Disable(Hwnd(), spin_end_duration_min);
        }
        break;

    case rb_end_duration:
        //if (IsDlgButtonChecked(Hwnd(), rb_end_duration) == BST_CHECKED)
        {
            Spin_Enable(Hwnd(), spin_end_duration_hr, 1);
            Spin_Enable(Hwnd(), spin_end_duration_min, 0);

            DateTime_SetFormat(_hCtrl(dp_end_time), tszBlank);
            EnableWindow(_hCtrl(dp_end_time), FALSE);
        }
        break;

    case IDOK:
        if (_OnOK() == TRUE)
        {
            EndDialog(Hwnd(), TRUE);
        }
        break;

    case IDCANCEL:
        EndDialog(Hwnd(), FALSE);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}


BOOL
CAdvScheduleDlg::_OnOK(void)
{
    WORD wTemp = 0;
    SYSTEMTIME stStart, stEnd;

    if (DateTime_GetSystemtime(_hCtrl(dp_start_date), &stStart) == GDT_VALID)
    {
        m_pjt->wBeginYear   =  stStart.wYear;
        m_pjt->wBeginMonth  =  stStart.wMonth;
        m_pjt->wBeginDay    =  stStart.wDay;
    }
    else
    {
        DEBUG_OUT((DEB_USER1, "DateTime_GetSystemtime failed.\n"));
    }

    if (IsDlgButtonChecked(Hwnd(), chk_end_date) == BST_CHECKED)
    {
        if (DateTime_GetSystemtime(_hCtrl(dp_end_date), &stEnd) == GDT_VALID)
        {
            m_pjt->wEndYear   =  stEnd.wYear;
            m_pjt->wEndMonth  =  stEnd.wMonth;
            m_pjt->wEndDay    =  stEnd.wDay;
        }
        else
        {
            DEBUG_OUT((DEB_USER1, "DateTime_GetSystemtime failed.\n"));
        }

        m_pjt->rgFlags |= TASK_TRIGGER_FLAG_HAS_END_DATE;

        //
        //  Ensure end date is after start date
        //

        stStart.wDayOfWeek = 0;
        stEnd.wDayOfWeek = 0;

        if (CompareSystemDate(stStart, stEnd) > 0)
        {
            _ErrorDialog(IERR_ENDDATE_LT_STARTDATE);
            return FALSE;
        }
    }
    else
    {
        m_pjt->rgFlags &= ~TASK_TRIGGER_FLAG_HAS_END_DATE;
    }

    if (IsDlgButtonChecked(Hwnd(), chk_repeat_task) == BST_CHECKED)
    {
        //
        //  Determine MinutesInterval
        //

        m_pjt->MinutesInterval = Spin_GetPos(Hwnd(), spin_repeat_task);

        switch (ComboBox_GetCurSel(_hCtrl(cbx_time_unit)))
        {
        case INDEX_MINUTES:
            break;

        case INDEX_HOURS:
            m_pjt->MinutesInterval *= 60;
            break;
        }

        //
        //  Determine MinutesDuration
        //

        if (IsDlgButtonChecked(Hwnd(), rb_end_time) == BST_CHECKED)
        {
            SYSTEMTIME stEndTime;

            if (DateTime_GetSystemtime(_hCtrl(dp_end_time), &stEndTime)
                == GDT_VALID)
            {
                DWORD dwMin = 0;

                DWORD dwStartMin = m_pjt->wStartHour * 60 + m_pjt->wStartMinute;
                DWORD dwEndMin = stEndTime.wHour * 60 + stEndTime.wMinute;

                if (dwEndMin > dwStartMin)
                {
                    dwMin = dwEndMin - dwStartMin;
                }
                else
                {
                    dwMin = c_MinsPerDay - (dwStartMin - dwEndMin);
                }

                m_pjt->MinutesDuration = dwMin;
            }
            else
            {
                DEBUG_OUT((DEB_USER1, "DateTime_GetSystemtime failed.\n"));
            }
        }
        else
        {
            ULONG ulDuration = Spin_GetPos(Hwnd(), spin_end_duration_min);

            if (HIWORD(ulDuration))
            {
                ulDuration = 59;
            }
            m_pjt->MinutesDuration = ulDuration + 60 *
                        Spin_GetPos(Hwnd(), spin_end_duration_hr);
        }

        if (m_pjt->MinutesDuration <= m_pjt->MinutesInterval)
        {
            _ErrorDialog(IERR_DURATION_LT_INTERVAL);
            return FALSE;
        }

        if (IsDlgButtonChecked(Hwnd(), chk_terminate_at_end) == BST_CHECKED)
        {
            m_pjt->rgFlags |= TASK_TRIGGER_FLAG_KILL_AT_DURATION_END;
        }
        else
        {
            m_pjt->rgFlags &= ~TASK_TRIGGER_FLAG_KILL_AT_DURATION_END;
        }

    }
    else
    {
        m_pjt->MinutesInterval = 0;
        m_pjt->MinutesDuration = 0;

        m_pjt->rgFlags &= ~TASK_TRIGGER_FLAG_KILL_AT_DURATION_END;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\job\util.cxx ===
//+----------------------------------------------------------------------------
//
//  Job Schedule Application Job Object Handler
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       util.cxx
//
//  Contents:   job & trigger objects IUnknown methods, class factory, DLL fcns,
//              plus misc utility fcns
//
//  Classes:    CJob (continued), CJobCF, CTrigger
//
//  Interfaces: IUnknown, IClassFactory
//
//  History:    24-May-95 EricB created
//
//-----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "job.hxx"

#if !defined(_CHICAGO_)     // this is not needed for Chicago version

//+----------------------------------------------------------------------------
//
//  Member:     CJob::GetAtInfo
//
//  Synopsis:   for a downlevel job, return its data in an AT_INFO struct.
//
//  Arguments:  [pAt] - pointer to the AT_INFO struct
//              [pwszCommand] - buffer for the command string
//              [pcchCommand] - on input, size of supplied buffer, on output,
//                              size needed/used.
//
//  Returns:    HRESULTS - ERROR_INSUFFICIENT_BUFFER if too small
//                       - SCHED_E_NOT_AN_AT_JOB if not an AT job
//
//  Notes:      This method is not exposed to external clients, thus it is not
//              part of a public interface.
//-----------------------------------------------------------------------------
HRESULT
CJob::GetAtInfo(PAT_INFO pAt, LPWSTR pwszCommand, DWORD * pcchCommand)
{
    TRACE(CJob, GetAtInfo);
    HRESULT hr = S_OK;

    if (!(m_rgFlags & JOB_I_FLAG_NET_SCHEDULE))
    {
        schDebugOut((DEB_ERROR,
            "CJob::GetAtInfo: Task object is not an AT job!\n"));
        return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }

    //
    // The ApplicationName and Parameters properties need to be concatonated
    // and returned as pwszCommand. If there is any white space in the app
    // name string, then it must be enclosed in quotes.
    //

    LPWSTR pwszAppName, pwszParams;

    hr = GetApplicationName(&pwszAppName);
    if (FAILED(hr))
    {
        ERR_OUT("GetAtInfo: GetApplicationName", hr);
        return hr;
    }

    hr = GetParameters(&pwszParams);
    if (FAILED(hr))
    {
        ERR_OUT("GetAtInfo: GetParameters", hr);
        CoTaskMemFree(pwszAppName);
        return hr;
    }

    //
    // Check for whitespace in the app name.
    //
    BOOL fAppNameHasSpaces = HasSpaces(pwszAppName);

    //
    // If there is app name whitespace, add two for the quotes to be added.
    //
    DWORD cchApp = wcslen(pwszAppName) + (fAppNameHasSpaces ? 2 : 0);
    DWORD cchParam = wcslen(pwszParams);
    //
    // Add one for the terminating null.
    //
    DWORD cch = cchApp + cchParam + 1;

    if (cch > *pcchCommand)
    {
        *pcchCommand = cch;
        CoTaskMemFree(pwszAppName);
        CoTaskMemFree(pwszParams);
        return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }
    *pcchCommand = cch;

    if (fAppNameHasSpaces)
    {
        wcscpy(pwszCommand, L"\"");
        wcscat(pwszCommand, pwszAppName);
        wcscat(pwszCommand, L"\"");
    }
    else
    {
        wcscpy(pwszCommand, pwszAppName);
    }

    if (cchParam > 0)
    {
        wcscat(pwszCommand, L" ");
        wcscat(pwszCommand, pwszParams);
    }

    CoTaskMemFree(pwszAppName);
    CoTaskMemFree(pwszParams);

    //
    // An AT job can have one or two triggers of type TASK_TIME_TRIGGER_WEEKLY
    // and/or TASK_TIME_TRIGGER_MONTHLYDATE.  It may also have, instead, a single trigger
    // of type TASK_TIME_TRIGGER_ONCE, which indicates it runs either today or
    // tomorrow, only.
    //
    WORD cTriggers = m_Triggers.GetCount();

    if (cTriggers == 0 || cTriggers > 2)
    {
        ERR_OUT("GetAtInfo: Incorrect Trigger Count", E_FAIL);
        return E_FAIL;
    }

    PTASK_TRIGGER pjt;

    pjt = _GetTrigger(0);
    if (pjt == NULL)
    {
        schAssert(!"GetCount > 0 but no trigger 0");
        return E_FAIL;
    }

    pAt->JobTime = (pjt->wStartHour * JOB_MINS_PER_HOUR +
                    pjt->wStartMinute) * JOB_MILLISECONDS_PER_MINUTE;

    pAt->DaysOfMonth = pAt->DaysOfWeek = 0;

    switch (pjt->TriggerType)
    {
    case TASK_TIME_TRIGGER_WEEKLY:
        //
        // Convert Scheduler DOW to AT_INFO DOW:
        // Scheduler rgfDaysOfTheWeek: Sunday = bit 0, Monday = bit 1.
        // AT_INFO DaysOfWeek: Monday = bit 0, Sunday = bit 6.
        //
        pAt->DaysOfWeek = pjt->Type.Weekly.rgfDaysOfTheWeek >> 1;

        if (pjt->Type.Weekly.rgfDaysOfTheWeek & 0x0001)
        {
            pAt->DaysOfWeek |= 0x0040;
        }
        break;

    case TASK_TIME_TRIGGER_MONTHLYDATE:
        pAt->DaysOfMonth = pjt->Type.MonthlyDate.rgfDays;
        break;

    case TASK_TIME_TRIGGER_ONCE:
        // Day of Month & Week are NULL if the job runs only once.
        break;

    default:
        schAssert(FALSE && "GetAtInfo: wrong trigger type");
        ERR_OUT("GetAtInfo: wrong trigger type", hr);
        return E_FAIL;
    }

    if (cTriggers == 2)
    {
        pjt = _GetTrigger(1);

        switch (pjt->TriggerType)
        {
        case TASK_TIME_TRIGGER_WEEKLY:
            //
            // Convert Scheduler DOW to AT_INFO DOW:
            // Scheduler rgfDaysOfTheWeek: Sunday = bit 0, Monday = bit 1.
            // AT_INFO DaysOfWeek: Monday = bit 0, Sunday = bit 6.
            //
            pAt->DaysOfWeek = pjt->Type.Weekly.rgfDaysOfTheWeek >> 1;

            if (pjt->Type.Weekly.rgfDaysOfTheWeek & 0x0001)
            {
                pAt->DaysOfWeek |= 0x0040;
            }
            break;

        case TASK_TIME_TRIGGER_MONTHLYDATE:
            pAt->DaysOfMonth = pjt->Type.MonthlyDate.rgfDays;
            break;

        case TASK_TIME_TRIGGER_ONCE:
            schAssert(FALSE && "GetAtInfo: Once triggers not allowed in multiple triggers!");
            ERR_OUT("GetAtInfo: Once triggers not allowed in multiple triggers!", 0);
            return E_FAIL;
            break;

        default:
            schAssert(FALSE && "GetAtInfo: wrong trigger type");
            ERR_OUT("GetAtInfo: wrong trigger type", 0);
            return E_FAIL;
        }
    }

    //
    // Set the AT_INFO.Flags.
    //

    pAt->Flags = 0;

    if (!(m_rgFlags & TASK_FLAG_INTERACTIVE))
    {
        pAt->Flags |= JOB_NONINTERACTIVE;
    }

    if (!(pjt->rgFlags & TASK_TRIGGER_FLAG_HAS_END_DATE) &&
         (pjt->TriggerType != TASK_TIME_TRIGGER_ONCE))
    {
        pAt->Flags |= JOB_RUN_PERIODICALLY;
    }

    //
    // Check whether job runs today, or is even running in a time window
    // that is valid for a NetScheduleJob.
    //

    SYSTEMTIME stNow, stMidnight, stTomorrow;
    GetLocalTime(&stNow);

    WORD cRuns = 0;

    // Check to see if there is a run today and set the flag JOB_RUNS_TODAY

    stMidnight = stNow;
    stMidnight.wHour = stMidnight.wMinute = stMidnight.wSecond
        = stMidnight.wMilliseconds = 0;
    IncrementDay(&stMidnight);

    // Zero out cRuns - we used it, and it is not initialized in GetRunTimesP
    cRuns = 0;

    hr = GetRunTimesP(&stNow, &stMidnight, &cRuns, 1, NULL, NULL);

    if (FAILED(hr))
    {
        ERR_OUT("GetAtInfo: GetRunTimes", hr);
        return hr;
    }

    if (cRuns > 0)
    {
        pAt->Flags |= JOB_RUNS_TODAY;
    }

    //
    // Check exit status of last run and set TASK_EXEC_ERROR as needed.
    //
    if (IsFlagSet(JOB_I_FLAG_LAST_LAUNCH_FAILED) ||
        IsFlagSet(JOB_I_FLAG_ERROR_IN_LAST_RUN))
    {
        pAt->Flags |= JOB_EXEC_ERROR;
    }

    //
    // Safety check - if the trigger is a ONCE trigger, the job
    // must within the next 24 hours.  If it is farther out
    // than 24 hours, it is an error condition - bail.
    //

    if (pjt->TriggerType == TASK_TIME_TRIGGER_ONCE &&
        !(pAt->Flags & JOB_EXEC_ERROR))
    {
       stTomorrow = stNow;
       IncrementDay(&stTomorrow);

       hr = GetRunTimesP(&stNow, &stTomorrow, &cRuns, 1, NULL, NULL);
       if (FAILED(hr))
       {
          ERR_OUT("GetAtInfo: GetRunTimes for Once Trigger", hr);
          return hr;
       }
       if (cRuns == 0)
       {
          ERR_OUT("GetAtInfo: Once trigger outside permitted time interval", 0);
          return E_FAIL;
       }
    }

    //
    // Omit jobs whose end date has passed (usually jobs that haven't yet
    // been deleted because they're still running)
    //
    if (pjt->rgFlags & TASK_TRIGGER_FLAG_HAS_END_DATE)
    {
        SYSTEMTIME  stEnd;
        stEnd.wYear      = pjt->wEndYear;
        stEnd.wMonth     = pjt->wEndMonth;
        stEnd.wDayOfWeek = 0;
        stEnd.wDay       = pjt->wEndDay;
        stEnd.wHour      = pjt->wStartHour;
        stEnd.wMinute    = pjt->wStartMinute;
        stEnd.wSecond    = 0;
        stEnd.wMilliseconds = 0;
        if (IsFirstTimeEarlier(&stEnd, &stNow) &&
            !(pAt->Flags & JOB_EXEC_ERROR))
        {
            return E_FAIL;
        }
    }

    return S_OK;
}

#endif // !defined(_CHICAGO_)

//+----------------------------------------------------------------------------
//
//  Member:     CJob::UpdateJobState
//
//  Synopsis:   Update the job flags and status depending on whether there are
//              valid triggers with more run times.
//
//  Arguments:  [fRunning] - optional param, defaults to false.
//                           CSchedWorker::RunJobs sets this to true while
//                           setting the new job status to
//                           SCHED_S_TASK_RUNNING. So, don't change the job's
//                           status if fRunning.
//
//  Returns:    HRESULTS
//
//  Notes:      The triggers have to be loaded.
//-----------------------------------------------------------------------------
HRESULT
CJob::UpdateJobState(BOOL fRunning)
{
    //TRACE(CJob, UpdateJobState);

    if (!IsFlagSet(JOB_I_FLAG_HAS_APPNAME))
    {
        //
        // The job can't run without an appname.
        //
        SetStatus(SCHED_S_TASK_NOT_SCHEDULED);
        return S_OK;
    }

    SYSTEMTIME stNow;
    GetLocalTime(&stNow);

    if (fRunning)
    {
        //
        // Increment the minute value so that the current run won't be returned.
        //
        stNow.wMinute++;
        if (stNow.wMinute >= JOB_MINS_PER_HOUR)
        {
            stNow.wHour++;
            stNow.wMinute = 0;
            if (stNow.wHour >= JOB_HOURS_PER_DAY)
            {
                stNow.wHour = 0;
                IncrementDay(&stNow);
            }
        }
    }

    WORD cRuns = 0;
    HRESULT hr;

    hr = GetRunTimesP(&stNow, NULL, &cRuns, 1, NULL, NULL);
    if (FAILED(hr))
    {
        ERR_OUT("CJob::UpdateJobState", hr);
        return hr;
    }

    //
    // Update the job flags and status properties.
    //
    if (hr == SCHED_S_TASK_NO_VALID_TRIGGERS)
    {
        SetFlag(JOB_I_FLAG_NO_VALID_TRIGGERS);

        SetStatus(SCHED_S_TASK_NOT_SCHEDULED);
    }
    else
    {
        ClearFlag(JOB_I_FLAG_NO_VALID_TRIGGERS);

        if (cRuns == 0 && hr != SCHED_S_EVENT_TRIGGER)
        {
            SetFlag(JOB_I_FLAG_NO_MORE_RUNS);
        }
        else
        {
            ClearFlag(JOB_I_FLAG_NO_MORE_RUNS);

            //
            // If the job isn't currently running and had not been ready to run but
            // now have both valid triggers and valid properties, set the status.
            // TODO: test TASK_FLAG_HAS_OBJPATH and TASK_FLAG_HAS_ACCOUNT when those
            //       properties are functional.
            //
            if (!fRunning && IsFlagSet(JOB_I_FLAG_HAS_APPNAME))
            {
                if (m_stMostRecentRunTime.wYear == 0)
                {
                    //
                    // Job has never run if last-run-time property is null (all
                    // elements will be zero if null, testing year is sufficient).
                    //
                    SetStatus(SCHED_S_TASK_HAS_NOT_RUN);
                }
                else
                {
                    //
                    // Job has run in the past, so it is now waiting to run again.
                    //
                    SetStatus(SCHED_S_TASK_READY);
                }
            }
        }
    }

    //
    // The disabled flag takes precedence over other states.
    //
    if (IsFlagSet(TASK_FLAG_DISABLED))
    {
        SetStatus(SCHED_S_TASK_DISABLED);
    }
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::PostRunUpdate
//
//  Synopsis:   update the status of a job object after a run exits
//
//  Arguments:  [ExitCode]    - the run's exit code
//              [fFinishedOK] - only set the job object's exit code if TRUE.
//
//  Returns:    HRESULTS
//
//  Notes:      Set the ExitCode and Status values for the job and log the run
//              if the LogRunHistory property is set.
//              This method is not exposed to external clients, thus it is not
//              part of a public interface.
//              If any of the variable length properties or the triggers are
//              needed, then the caller will need to do a full activation of
//              the job.
//
//-----------------------------------------------------------------------------
HRESULT
CJob::PostRunUpdate(long ExitCode, BOOL fFinishedOK)
{
    schDebugOut((DEB_ITRACE, "PostRunUpdate: decrementing running instance "
                 "count (%d before decrement)\n", m_cRunningInstances));
    if (m_cRunningInstances > 0)
    {
        m_cRunningInstances--;
    }

    //
    // Don't update the status unless the running instance count is back to
    // zero.
    //
    if (m_cRunningInstances == 0)
    {
        if (IsFlagSet(JOB_I_FLAG_NO_VALID_TRIGGERS))
        {
            SetStatus(SCHED_S_TASK_NO_VALID_TRIGGERS);
        }
        else
        {
            SetStatus(SCHED_S_TASK_READY);
        }
    }

    if (fFinishedOK)
    {
        m_ExitCode = ExitCode;
    }

    ClearFlag(JOB_I_FLAG_ABORT_NOW);

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::IfEventJobAddToList
//
//  Synopsis:   Check if the job has any triggers of the specified event type.
//              If so, allocate and initialize a CRun object and add it to the
//              list.  Add it to pIdleWaitList if it needs to wait for an
//              idle period, otherwise add it to pRunList.
//
//  Arguments:  [EventType]        - the event trigger type
//              [ptszJobName] - the short job name to pass to CRun.
//              [pRunList]    - a pointer to a run list object.
//              [pIdleWaitList] - a pointer to a run list object sorted by
//                  idle wait times.
//
//  Returns:    S_OK if the event trigger is found, S_FALSE if not, or a
//              fatal error code.
//
//  Assumes:    Triggers have already been loaded.
//              If EventType is not TASK_EVENT_TRIGGER_ON_IDLE, this method is
//              only called when the event has occurred.  (If EventType is
//              TASK_EVENT_TRIGGER_ON_IDLE, this method is called when
//              building the wait list from the tasks folder's contents.)
//
//-----------------------------------------------------------------------------
HRESULT
CJob::IfEventJobAddToList(TASK_TRIGGER_TYPE EventType, LPCTSTR ptszJobName,
                          CRunList * pRunList, CIdleRunList * pIdleWaitList)
{
    schAssert(EventType == TASK_EVENT_TRIGGER_ON_IDLE ||
              EventType == TASK_EVENT_TRIGGER_AT_SYSTEMSTART ||
              EventType == TASK_EVENT_TRIGGER_AT_LOGON);

    if (! IsFlagSet(JOB_I_FLAG_HAS_TRIGGERS))
    {
        // (An optimization; the function would still work without it)
        return S_FALSE;
    }

    if (EventType == TASK_EVENT_TRIGGER_ON_IDLE && m_wIdleWait == 0)
    {
        //
        // We ignore all idle triggers if the idle wait time is 0.
        //
        return S_FALSE;
    }

    //
    // Will the job need to wait for an idle period before being started?
    //
    BOOL fNeedIdleWait = ((EventType == TASK_EVENT_TRIGGER_ON_IDLE ||
                           IsFlagSet(TASK_FLAG_START_ONLY_IF_IDLE))
                          && m_wIdleWait > 0);

    HRESULT hr;
    FILETIME ftNow = GetLocalTimeAsFileTime();
    // BUGBUG  ftNow should be passed in, and the same ftNow should be used
    // when checking against the deadlines.  Otherwise a run can be missed
    // if we're slow here and the deadline elapses.

    //
    // See if the job has any triggers of the specified type.
    // Find the latest deadline of these triggers.
    //
    FILETIME   ftLatestDeadline = { 0, 0 };
    for (WORD i = 0; i < m_Triggers.GetCount(); i++)
    {
        if (m_Triggers[i].TriggerType != EventType)
        {
            continue;
        }

        //
        // If the trigger is an idle trigger then the trigger's deadline
        // is simply midnight on the trigger's end date.
        //
        // If the job does not have TASK_FLAG_START_ONLY_IF_IDLE then
        // the trigger's deadline is simply midnight on the trigger's
        // end date.
        //
        // If the job does have TASK_FLAG_START_ONLY_IF_IDLE then the
        // trigger's deadline is
        //   min( trigger's end date,
        //        job's start time + trigger's MinutesDuration)
        //
        FILETIME ftDeadline             // This trigger's deadline
            = MAX_FILETIME;             // End date if no end date set

        if (m_Triggers[i].rgFlags & TASK_TRIGGER_FLAG_HAS_END_DATE)
        {
            SYSTEMTIME stEnd =          // This trigger's end date
            {
                m_Triggers[i].wEndYear,
                m_Triggers[i].wEndMonth,
                0,          // wDayOfWeek
                m_Triggers[i].wEndDay,
                23,         // wHour
                59,         // wMinute
                0,          // wSecond
                0           // wMilliseconds
            };

            if (!SystemTimeToFileTime(&stEnd, &ftDeadline))
            {
                // Presume the trigger had an invalid end date.
                // Ignore the trigger.  BUGBUG return an error ?
                continue;
            }
        }

        if (EventType != TASK_EVENT_TRIGGER_ON_IDLE && fNeedIdleWait)
        {
            //
            // Calculate (job's start time + trigger's MinutesDuration)
            // This method is only called when the event that fires the
            // trigger has occurred, so the job's start time is now.
            //
            FILETIME ftDurationEnd = ftNow;
            AddMinutesToFileTime(&ftDurationEnd, m_Triggers[i].MinutesDuration);

            ftDeadline = minFileTime(ftDeadline, ftDurationEnd);
        }

        ftLatestDeadline = maxFileTime(ftLatestDeadline, ftDeadline);
    }

    if (CompareFileTime(&ftLatestDeadline, &ftNow) < 0)
    {
        //
        // All the triggers of this type have expired.
        //
        return S_FALSE;
    }


    //
    // Add the job to the appropriate run list.
    //
    CRun * pNewRun;
    if (fNeedIdleWait)
    {
        DBG_OUT("Adding idle job to list.");
        pNewRun = new CRun(m_dwMaxRunTime, GetUserFlags(), m_wIdleWait,
                           ftLatestDeadline,
                           (EventType == TASK_EVENT_TRIGGER_ON_IDLE));
    }
    else
    {
        pNewRun = new CRun(m_dwMaxRunTime, GetUserFlags(), MAX_FILETIME,
                           FALSE);
    }

    if (pNewRun == NULL)
    {
        ERR_OUT("CJob::IfEventJobAddToList new CRun", E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }

    // Complete job info object initialization.
    //
    hr = pNewRun->Initialize(ptszJobName);

    if (FAILED(hr))
    {
        ERR_OUT("CJob::IfEventJobAddToList, CRun->Initialize", hr);
        delete pNewRun;
        return hr;
    }

    if (fNeedIdleWait)
    {
        pIdleWaitList->AddSortedByIdleWait(pNewRun);
    }
    else
    {
        pRunList->Add(pNewRun);
    }
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::IfStartupJobAddToList
//
//  Synopsis:   Check if the job has any startup triggers. If so, allocate and
//              initialize a CRun object and add it to the list.
//
//  Arguments:  [ptszJobName] - the short job name to pass to CRun.
//              [pRunList]    - a pointer to a run list object.
//
//  Returns:    S_OK if the event trigger is found, S_FALSE if not, or a
//              fatal error code.
//
//  Assumes:    Triggers have already been loaded.
//
//-----------------------------------------------------------------------------
HRESULT
CJob::IfStartupJobAddToList(LPTSTR ptszJobName, CRunList * pRunList,
                            CIdleRunList * pIdleWaitList)
{
    return IfEventJobAddToList(TASK_EVENT_TRIGGER_AT_SYSTEMSTART, ptszJobName,
                               pRunList, pIdleWaitList);
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::IfLogonJobAddToList
//
//  Synopsis:   Check if the job has any logon triggers. If so, allocate and
//              initialize a CRun object and add it to the list.
//
//  Arguments:  [ptszJobName] - the short job name to pass to CRun.
//              [pRunList]    - a pointer to a run list object.
//
//  Returns:    S_OK if the event trigger is found, S_FALSE if not, or a
//              fatal error code.
//
//  Assumes:    Triggers have already been loaded.
//
//-----------------------------------------------------------------------------
HRESULT
CJob::IfLogonJobAddToList(LPTSTR ptszJobName, CRunList * pRunList,
                          CIdleRunList * pIdleWaitList)
{
    return IfEventJobAddToList(TASK_EVENT_TRIGGER_AT_LOGON, ptszJobName,
                               pRunList, pIdleWaitList);
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::IfIdleJobAddToList
//
//  Synopsis:   Check if the job has any idle triggers. If so, allocate and
//              initialize a CRun object and add it to the list.
//
//  Arguments:  [ptszJobName] - the short job name to pass to CRun.
//              [pIdleWaitList] - a pointer to a run list object.
//
//  Returns:    S_OK if the event trigger is found, S_FALSE if not, or a
//              fatal error code.
//
//  Assumes:    Triggers have already been loaded.
//
//-----------------------------------------------------------------------------
HRESULT
CJob::IfIdleJobAddToList(LPTSTR ptszJobName, CIdleRunList * pIdleWaitList)
{
    return IfEventJobAddToList(TASK_EVENT_TRIGGER_ON_IDLE, ptszJobName,
                               NULL, pIdleWaitList);
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::Delete
//
//  Synopsis:   Remove the file object for this job.
//
//-----------------------------------------------------------------------------
HRESULT
CJob::Delete(void)
{
#if defined(UNICODE)
    schDebugOut((DEB_ITRACE, "CJob:Delete on %S\n", m_ptszFileName));
#else
    schDebugOut((DEB_ITRACE, "CJob:Delete on %s\n", m_ptszFileName));
#endif

    if (m_ptszFileName == NULL)
    {
        return E_INVALIDARG;
    }

    if (!DeleteFile(m_ptszFileName))
    {
        schDebugOut((DEB_ITRACE, "DeleteFile failed with error %d\n",
                     GetLastError()));
        return HRESULT_FROM_WIN32(GetLastError());
    }
    return S_OK;
}


//+----------------------------------------------------------------------------
//
//      CJob::IUnknown methods
//
//-----------------------------------------------------------------------------

//+----------------------------------------------------------------------------
//
//  Member:     CJob::IUnknown::QueryInterface
//
//  Synopsis:   Returns requested interface pointer
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::QueryInterface(REFIID riid, void ** ppvObject)
{
    //schDebugOut((DEB_ITRACE, "CJob::QueryInterface\n"));
    if (IID_IUnknown == riid)
    {
        *ppvObject = (IUnknown *)(ITask *)this;
    }
    else if (IID_ITask == riid)
    {
        *ppvObject = (IUnknown *)(ITask *)this;
    }
    else if (IID_IScheduledWorkItem == riid)
    {
        *ppvObject = (IUnknown *)(IScheduledWorkItem *)this;
    }
    else if (IID_IPersist == riid)
    {
        *ppvObject = (IUnknown *)(IPersist *)this;
    }
    else if (IID_IPersistFile == riid)
    {
        *ppvObject = (IUnknown *)(IPersistFile *)this;
    }
    else if (IID_IProvideTaskPage == riid)
    {
        *ppvObject = (IUnknown *)(IProvideTaskPage *)this;
    }
    else
    {
#if DBG == 1
        //WCHAR * pwsz;
        //StringFromIID(riid, &pwsz);
        //schDebugOut((DEB_NOPREFIX, "%S, refused\n", pwsz));
        //CoTaskMemFree(pwsz);
#endif
        *ppvObject = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::IUnknown::AddRef
//
//  Synopsis:   increments reference count
//
//  Returns:    the reference count
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CJob::AddRef(void)
{
    //schDebugOut((DEB_ITRACE, "CJob::AddRef refcount going in %d\n", m_cReferences));
    return InterlockedIncrement((long *)&m_cReferences);
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::IUnknown::Release
//
//  Synopsis:   Decrements the object's reference count and frees it when
//              no longer referenced.
//
//  Returns:    the reference count
//
//  Notes:      BUGBUG: do we need to check the refcount on the triggers
//              before freeing the job object?
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CJob::Release(void)
{
    //schDebugOut((DEB_ITRACE, "CJob::Release ref count going in %d\n", m_cReferences));
    unsigned long uTmp;
    if ((uTmp = InterlockedDecrement((long *)&m_cReferences)) == 0)
    {
        delete this;
    }
    return uTmp;
}

//+----------------------------------------------------------------------------
//
//      CJobCF - class factory for the Job object
//
//-----------------------------------------------------------------------------

//+----------------------------------------------------------------------------
//
//  Member:     CJobCF::Create
//
//  Synopsis:   creates a new class factory object
//
//-----------------------------------------------------------------------------
IClassFactory *
CJobCF::Create(void)
{
    //schDebugOut((DEB_ITRACE, "CJobCF::Create\n"));
    return new CJobCF;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJobCF::CJobCF
//
//  Synopsis:   ctor
//
//-----------------------------------------------------------------------------
CJobCF::CJobCF(void)
{
    m_uRefs = 1;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJobCF::~CJobCF
//
//  Synopsis:   dtor
//
//-----------------------------------------------------------------------------
CJobCF::~CJobCF(void)
{
    //schDebugOut((DEB_ITRACE, "~CJobCF: DLL ref count going in %d\n",
    //           g_cDllRefs));
}

//+----------------------------------------------------------------------------
//
//  Member:     CJobCF::IUnknown::QueryInterface
//
//  Synopsis:   Returns requested interface pointer
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJobCF::QueryInterface(REFIID riid, void ** ppvObject)
{
    //schDebugOut((DEB_ITRACE, "CJobCF::QueryInterface"));
    if (IID_IUnknown == riid)
    {
        *ppvObject = (IUnknown *)this;
    }
    else if (IsEqualIID(IID_IClassFactory, riid))
    {
        *ppvObject = (IClassFactory *)this;
    }
    else
    {
#if DBG == 1
        //WCHAR * pwsz;
        //StringFromIID(riid, &pwsz);
        //schDebugOut((DEB_NOPREFIX, "%S, refused\n", pwsz));
        //CoTaskMemFree(pwsz);
#endif
        *ppvObject = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJobCF::IUnknown::AddRef
//
//  Synopsis:   increments reference count
//
//  Returns:    the reference count
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CJobCF::AddRef(void)
{
    //schDebugOut((DEB_ITRACE, "CJobCF::AddRef\n"));
    return InterlockedIncrement((long *)&m_uRefs);
}

//+----------------------------------------------------------------------------
//
//  Member:     CJobCF::IUnknown::Release
//
//  Synopsis:   Decrements the object's reference count and frees it when
//              no longer referenced.
//
//  Returns:    the reference count
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CJobCF::Release(void)
{
    //schDebugOut((DEB_ITRACE, "CJobCF::Release ref count going in %d\n",
    //           m_uRefs));
    unsigned long uTmp;
    if ((uTmp = InterlockedDecrement((long *)&m_uRefs)) == 0)
    {
        delete this;
    }
    return uTmp;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJobCF::IClassFactory::CreateInstance
//
//  Synopsis:   create an incore instance of the job class object
//
//  Arguments:  [pUnkOuter] - aggregator
//              [riid]      - requested interface
//              [ppvObject] - receptor for itf ptr
//
//  Returns:    HRESULTS
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJobCF::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObject)
{
    //schDebugOut((DEB_ITRACE, "CJobCF::CreateInstance\n"));
    SCODE sc = S_OK;
    ITask * pJob = CJob::Create();
    if (pJob == NULL)
    {
        *ppvObject = NULL;
        return E_OUTOFMEMORY;
    }
    sc = pJob->QueryInterface(riid, ppvObject);
    if (FAILED(sc))
    {
        *ppvObject = NULL;
        return sc;
    }
    // we got a refcount of one when launched, and the above QI increments it
    // to 2, so call release to take it back to 1
    pJob->Release();
    return sc;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJobCF::IClassFactory::LockServer
//
//  Synopsis:   Called with fLock set to TRUE to indicate that the server
//              should continue to run even if none of its objects are active
//
//  Arguments:  [fLock] - increment/decrement the instance count
//
//  Returns:    HRESULTS
//
//  Notes:      This function is a no-op since the server is in-proc.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJobCF::LockServer(BOOL fLock)
{
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  CTrigger::IUnknown methods
//
//  Notes:  A trigger is not a first class COM object. They do not exist as
//          separate entities outside of Job objects; you cannot do a
//          CoCreateInstance on one and they do not go away when their ref
//          count goes to zero. When a job object is instanciated, its triggers
//          are also instanciated and they are freed from memory when the job
//          object is freed from memory. Trigger ref counting is used only to
//          prevent a client from deleting a trigger while it is holding a
//          pointer to that trigger.
//
//          Note also that the containing job object is AddRef'd and Release'd
//          along with each trigger so that the job object will not be deleted
//          while clients are holding trigger pointers.
//
//-----------------------------------------------------------------------------

//+----------------------------------------------------------------------------
//
//  Member:     CTrigger::IUnknown::QueryInterface
//
//  Synopsis:   Returns requested interface pointer
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTrigger::QueryInterface(REFIID riid, void ** ppvObject)
{
    if (IID_IUnknown == riid)
    {
        *ppvObject = (IUnknown *)(ITaskTrigger *)this;
    }
    else
    if (IID_ITaskTrigger == riid)
    {
        *ppvObject = (IUnknown *)(ITaskTrigger *)this;
    }
    else
    {
        *ppvObject = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CTrigger::IUnknown::AddRef
//
//  Synopsis:   increments reference count
//
//  Returns:    the reference count
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CTrigger::AddRef(void)
{
    return InterlockedIncrement((long *)&m_cReferences);
}

//+----------------------------------------------------------------------------
//
//  Member:     CTrigger::IUnknown::Release
//
//  Synopsis:   Decrements the object's reference count.
//
//  Returns:    the reference count
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CTrigger::Release(void)
{
    unsigned long uTmp;

    if ((uTmp = InterlockedDecrement((long *)&m_cReferences)) == 0)
    {
        delete this;
    }

    return uTmp;
}


//+--------------------------------------------------------------------------
//
//  Function:   IsValidMonthlyDateTrigger
//
//  Synopsis:   Return TRUE if [pTrigger] has a valid combination of month
//              and day bits set.
//
//  History:    10-07-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
IsValidMonthlyDateTrigger(
    PTASK_TRIGGER pTrigger)
{
    if (pTrigger->Type.MonthlyDate.rgfDays > JOB_RGFDAYS_MAX ||
        pTrigger->Type.MonthlyDate.rgfMonths == 0            ||
        pTrigger->Type.MonthlyDate.rgfMonths > JOB_RGFMONTHS_MAX)
    {
        return FALSE;
    }

    if (pTrigger->Type.MonthlyDate.rgfDays == 0)
    {
        //
        // rgfDays must be non-zero.
        //
        return FALSE;
    }

    //
    // More detailed testing to see if non-existent dates have been
    // specified, for example: Feb. 30th, without specifying valid dates.
    // That is, it is OK to specify invalid dates as long as there are
    // valid dates. E.g., someone may want to specify: run on the 25th
    // through 31st of every month. While that is acceptable, saying run
    // only on Feb 31st is invalid.
    //

    if (pTrigger->Type.MonthlyDate.rgfDays & 0x40000000 &&
        pTrigger->Type.MonthlyDate.rgfMonths & (TASK_FEBRUARY | TASK_APRIL |
                                                TASK_JUNE | TASK_SEPTEMBER |
                                                TASK_NOVEMBER) &&
        !(pTrigger->Type.MonthlyDate.rgfMonths & ~(TASK_FEBRUARY  |
                                                   TASK_APRIL     |
                                                   TASK_JUNE      |
                                                   TASK_SEPTEMBER |
                                                   TASK_NOVEMBER)))
    {
        //
        // None of these months have a 31st day.
        //
        return FALSE;
    }

    if (pTrigger->Type.MonthlyDate.rgfDays & 0x20000000 &&
        pTrigger->Type.MonthlyDate.rgfMonths & TASK_FEBRUARY &&
        !(pTrigger->Type.MonthlyDate.rgfMonths & ~TASK_FEBRUARY))
    {
        //
        // February does not have a 30th day. Allow for the specification
        // of the 29th to run on leap year.
        //
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\schedui\errhdlr.cxx ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       uiutil.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    3/20/1996   RaviR   Created
//
//____________________________________________________________________________

#include "..\pch\headers.hxx"
#pragma hdrstop

#include "..\folderui\macros.h"
#include "..\inc\resource.h"
#include "rc.h"
#include <mstask.h>     // Necessary for schedui.hxx inclusion.
#include "schedui.hxx"
#include <misc.hxx>

#define ERROR_STRING_BUFFER_SIZE    2048
#define ERROR_TITLE_BUFFER_SIZE     256

extern HINSTANCE g_hInstance;

void
SchedUIErrorDialog(
    HWND    hwnd,
    int     idsErrMsg,
    LONG    error,
    UINT    idsHelpHint)
{
    TCHAR szBuf1[ERROR_TITLE_BUFFER_SIZE];

    //
    // Obtain the error message string.
    //

    LPTSTR ptszErrMsg = ComposeErrorMsg(idsErrMsg,
                                        (DWORD)error,
                                        idsHelpHint,
                                        FALSE);
    if (ptszErrMsg == NULL)
    {
        return;
    }

    LoadString(g_hInstance, IDS_SCHEDULER_NAME, szBuf1, ARRAYLEN(szBuf1));

    MessageBox(hwnd, ptszErrMsg, szBuf1,
               MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

    LocalFree(ptszErrMsg);
}




//+--------------------------------------------------------------------------
//
//  Function:   SchedUIMessageDialog
//
//  Synopsis:   Display a message box and return result of user selection.
//
//  Arguments:  [hwnd]      - parent window
//              [idsMsg]    - resource id of string to load
//              [uType]     - MB_* flags
//              [pszInsert] - NULL or string to insert
//
//  Returns:    Result of MessageBox call
//
//  History:    5-19-1997   DavidMun   Commented, added pszInsert
//
//---------------------------------------------------------------------------

int
SchedUIMessageDialog(
    HWND    hwnd,
    int     idsMsg,
    UINT    uType,
    LPTSTR  pszInsert)
{
    TCHAR szBuf1[ERROR_STRING_BUFFER_SIZE];
    TCHAR szBuf2[ERROR_STRING_BUFFER_SIZE];

    if (pszInsert != 0)
    {
        LoadString(g_hInstance, idsMsg, szBuf1, ARRAYLEN(szBuf1));
        wsprintf(szBuf2, szBuf1, pszInsert);
    }
    else
    {
        LoadString(g_hInstance, idsMsg, szBuf2, ARRAYLEN(szBuf2));
    }

    LoadString(g_hInstance, IDS_SCHEDULER_NAME, szBuf1, ARRAYLEN(szBuf1));

    return MessageBox(hwnd, szBuf2, szBuf1, uType);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\schedui\defines.h ===
#define MAX_PROP_PAGES  20

//
// Used by General, Schedule & Settings page to query each other
// through PSM_QUERYSIBLINGS to see if they are ready to be saved
// to storage.
//

//
// Used by General, Schedule & Settings pages to query each other
// to see if they are ready to be saved to storage. Do this by sending
// the PSM_QUERYSIBLINGS message to each of the page with wParam set to
// QUERY_READY_TO_BE_SAVED & lParam set to 0. A return value of 0 by all
// pages imples they are all ready to be saved.
//

#define QUERY_READY_TO_BE_SAVED                     7341

//
// Used by general and schedule page to share the icon helper object.
//

#define GET_ICON_HELPER                             7342

//
// Used by all pages to set task application & account change status
// flags to pass in to the common save code (JFSaveJob).
//

#define QUERY_TASK_APPLICATION_DIRTY_STATUS         7345
#define QUERY_TASK_ACCOUNT_INFO_DIRTY_STATUS        7346
#define QUERY_SUPPRESS_ACCOUNT_INFO_REQUEST_FLAG    7347
#define RESET_TASK_APPLICATION_DIRTY_STATUS         7348
#define RESET_TASK_ACCOUNT_INFO_DIRTY_STATUS        7349
#define RESET_SUPPRESS_ACCOUNT_INFO_REQUEST_FLAG    7350

//
// Used to instruct the general page to refresh account information visuals.
//

#define TASK_ACCOUNT_CHANGE_NOTIFY                  7351
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\sched\schedui\general.cxx ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       general.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  Notes:      For the first release of the scheduling agent, all security
//              operations are disabled under Win95, even Win95 to NT.
//
//  History:    3/4/1996   RaviR   Created
//              1-30-1997   DavidMun   params edit becomes working dir
//              02/29/01   JBenton BUG 280401 app icon was not being updated
//                                 on prop sheet in case of service not running
//
//____________________________________________________________________________


#include "..\pch\headers.hxx"
#pragma hdrstop

#include "..\inc\dll.hxx"
#include "..\folderui\dbg.h"
#include "..\folderui\macros.h"
#include "dlg.hxx"

#include "..\folderui\jobicons.hxx"
#include "..\inc\resource.h"
#include "..\inc\defines.hxx"
#include "..\inc\common.hxx"
#include "..\inc\misc.hxx"
#include "..\inc\policy.hxx"

#if !defined(_CHICAGO_)

#define  SECURITY_WIN32
#include <security.h>            // GetUserNameEx
#undef   SECURITY_WIN32

#include "..\inc\network.hxx"
#endif // !defined(_CHICAGO_)
#include "rc.h"
#include "defines.h"
#include <mstask.h>
#include "uiutil.hxx"
#include "commdlg.h"
#include "helpids.h"
#include "iconhlpr.hxx"
#include "schedui.hxx"
#include "sageset.hxx"

//
//  extern
//

extern HINSTANCE g_hInstance;

#if !defined(_CHICAGO_)
//
// Forward references
//
// CenterDialog - Centers a dialog on screen. Used by the security-related
//                  subdialogs.
//

void
CenterDialog(HWND hDlg);

void
GetDefaultDomainAndUserName(
    LPTSTR ptszDomainAndUserName,
    ULONG  cchBuf);


//
// Launches the modal set password dialog.
//

INT_PTR
LaunchSetPasswordDlg(
    HWND          hWnd,
    AccountInfo * pAccountInfo);

INT_PTR APIENTRY
SetPasswordDlgProc(
    HWND   hDlg,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam);

INT_PTR APIENTRY
SetAccountInformationDlgProc(
    HWND   hDlg,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam);
#endif // !defined(_CHICAGO_)

int
SchedGetDlgItemTextLength(
    HWND hwnd,
    int id);

//
//  (Control id, help id) list for context sensitivity help.
//

ULONG s_aGeneralPageHelpIds[] =
{
    idc_icon,           Hidc_icon,
    lbl_job_name,       Hlbl_job_name,
    lbl_comments,       Hlbl_comments,
    txt_comments,       Htxt_comments,
    lbl_app_name,       Hlbl_app_name,
    txt_app_name,       Htxt_app_name,
    btn_browse,         Hbtn_browse,
    lbl_workingdir,     Hlbl_workingdir,
    txt_workingdir,     Htxt_workingdir,
    lbl_run_as,         Hlbl_execute_as,
    txt_run_as,         Htxt_execute_as,
    btn_passwd,         Hbtn_passwd,
    chk_enable_job,     Hchk_enable_job,
    btn_settings,       Hbtn_settings,
    0,0
};


const ULONG s_aSetPasswordDlgHelpIds[] =
{
    set_passwd_dlg,     Hset_passwd_dlg,
    lbl_sp_passwd,      Hlbl_sp_passwd,
    edt_sp_passwd,      Hedt_sp_passwd,
    lbl_sp_cfrmpasswd,  Hlbl_sp_cfrmpasswd,
    edt_sp_cfrmpasswd,  Hedt_sp_cfrmpasswd,
    0,0
};


extern "C" TCHAR szMstaskHelp[];

const TCHAR SAGERUN_PARAM[] = TEXT("/SAGERUN:");

TCHAR szMstaskHelp[]  = TEXT("%windir%\\help\\mstask.hlp");

//____________________________________________________________________________
//____________________________________________________________________________
//________________                      ______________________________________
//________________  class CGeneralPage  ______________________________________
//________________                      ______________________________________
//____________________________________________________________________________
//____________________________________________________________________________


class CGeneralPage : public CPropPage
{
public:

    CGeneralPage(ITask * pIJob, LPTSTR ptszTaskPath, BOOL fPersistChanges);

    ~CGeneralPage();

private:

    virtual LRESULT _OnInitDialog(LPARAM lParam);
    virtual LRESULT _OnCommand(int id, HWND hwndCtl, UINT codeNotify);
    virtual LRESULT _OnApply(void);
    virtual LRESULT _OnCancel(void);
    virtual LRESULT _OnPSMQuerySibling(WPARAM wParam, LPARAM lParam);
    virtual LRESULT _OnPSNKillActive(LPARAM lParam);
    virtual LRESULT _OnHelp(HANDLE hRequesting, UINT uiHelpCommand);

    VOID    _ExpandAppName(LPTSTR tszApp);
    VOID    _ExpandWorkingDir();
    VOID    _GetAppAndArgs(LPTSTR tszApp, LPTSTR * pptszArg);
    VOID    _UpdateAppNameAndIcon(LPWSTR wszApp, LPWSTR * ppwszArg);
    VOID    _UpdateAppIcon(LPCTSTR tszApp);
    VOID    _SetAppEdit(LPCTSTR tszApp, LPCTSTR tszArgs);
    BOOL    _JobObjectIsLocal();
#if !defined(_CHICAGO_)
    void    _UpdateRunAsControl(void);
#endif // !defined(_CHICAGO_)
    BOOL    _Browse(TCHAR szFilePath[]);

    void    _ErrorDialog(int idsErr, LONG error = 0, UINT idsHelpHint = 0)
                 { SchedUIErrorDialog(Hwnd(), idsErr, error, idsHelpHint); }

#if !defined(_CHICAGO_)
    AccountInfo     m_AccountInfo;          // Account/password change info.
#endif // !defined(_CHICAGO_)

    ITask         * m_pIJob;

    // Flag values.  Note the compiler allocates a single dword for these

    DWORD           m_CommentDirty : 1;     //
    DWORD           m_AppNameDirty : 1;     //
    DWORD           m_WorkingDirDirty : 1;  // A value of 1 => dirty
    DWORD           m_RunAsDirty : 1;       //
    DWORD           m_updateIcon : 1;       // 1 => update needed
    DWORD           m_ChangeFromSetText : 1;// 0 => en_change from user

    //
    //  icon helper
    //

    CIconHelper   * m_pIconHelper;

    //
    //  Should we save on Apply or OK.
    //

    BOOL            m_fPersistChanges;

    BOOL            m_fEnableJob;

    //
    // Saved or new sage settings parameter
    //

    TCHAR           m_tszSageRunParam[20]; // /SAGERUN:4294967295

#if !defined(_CHICAGO_)
    //
    // The RunAs edit control can be updated by the user, or automatically
    // with apply via the set account information dialog. In response to
    // user edits, we want to apply the changes. For the automatic RunAs
    // update, we've already applied the changes, therefore, this flag
    // exists to not re-dirty the page.
    //

    BOOL            m_fApplyRunAsEditChange;

    //
    //  The other pages need to query the general page if there is an
    //  application or security account change for the common security
    //  code in the page's save path (JFSaveJob). The record of this
    //  dirty information must be retained post-Apply; therefore, these
    //  slightly redundant flags are necessary.
    //

    BOOL            m_fTaskApplicationChange;
    BOOL            m_fTaskAccountChange;

    //
    //  Set this flag to TRUE if we have launched the set password dialog.
    //  Othwerwise, the user may get a redundant set account information
    //  dialog on apply.
    //

    BOOL            m_fSuppressAcctInfoRequestOnApply;
#endif // !defined(_CHICAGO_)

}; // class CGeneralPage


inline
CGeneralPage::CGeneralPage(
    ITask * pIJob,
    LPTSTR  ptszTaskPath,
    BOOL    fPersistChanges)
        :
        m_pIJob(pIJob),
        m_pIconHelper(NULL),
        m_fPersistChanges(fPersistChanges),
        m_ChangeFromSetText(FALSE),
#if !defined(_CHICAGO_)
        m_fApplyRunAsEditChange(TRUE),
        m_fTaskApplicationChange(FALSE),
        m_fTaskAccountChange(FALSE),
        m_fSuppressAcctInfoRequestOnApply(FALSE),
#endif // !defined(_CHICAGO_)
        CPropPage(MAKEINTRESOURCE(general_page), ptszTaskPath)
{
    TRACE(CGeneralPage, CGeneralPage);

    Win4Assert(m_pIJob != NULL);

    m_pIJob->AddRef();
    m_tszSageRunParam[0] = TEXT('\0');

#if !defined(_CHICAGO_)
    InitializeAccountInfo(&m_AccountInfo);
#endif // !defined(_CHICAGO_)
}


inline
CGeneralPage::~CGeneralPage()
{
    TRACE(CGeneralPage, ~CGeneralPage);

    if (m_pIconHelper != NULL)
    {
        m_pIconHelper->Release();
    }

    if (m_pIJob != NULL)
    {
        m_pIJob->Release();
    }

#if !defined(_CHICAGO_)
    ResetAccountInfo(&m_AccountInfo);
#endif // !defined(_CHICAGO_)
}


//+--------------------------------------------------------------------------
//
//  Member:     CGeneralPage::_JobObjectIsLocal
//
//  Synopsis:   Return TRUE if job object being edited lives on the local
//              machine, FALSE otherwise.
//
//  History:    2-01-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

inline BOOL
CGeneralPage::_JobObjectIsLocal()
{
    return IsLocalFilename(GetTaskPath());
}


LRESULT
CGeneralPage::_OnInitDialog(
    LPARAM lParam)
{
    TRACE(CGeneralPage, _OnInitDialog);

    HRESULT     hr              = S_OK;
    LPWSTR      pwsz            = NULL;
    BOOL        fEnableSecurity = FALSE;
    TCHAR       tszApp[MAX_PATH + 1] = TEXT("");

    //
    // Note that we don't limit the txt_app_name control.  App names are
    // limited to MAX_PATH characters, but app parameters are not.
    //
    Edit_LimitText(_hCtrl(txt_comments), MAX_PATH);
    Edit_LimitText(_hCtrl(txt_workingdir), MAX_PATH);
    Edit_LimitText(_hCtrl(txt_run_as), MAX_USERNAME);

    //
    // Policy - if this reg key is valid, disable browse
    //

    if (RegReadPolicyKey(TS_KEYPOLICY_DENY_BROWSE))
    {
        DEBUG_OUT((DEB_ITRACE, "Policy ALLOW_BROWSE active, no browse or edit\n"));
        EnableWindow(_hCtrl(btn_browse), FALSE);
        ShowWindow(_hCtrl(btn_browse), SW_HIDE);
        EnableWindow(_hCtrl(txt_app_name), FALSE);
        EnableWindow(_hCtrl(txt_workingdir), FALSE);
    }

    do
    {
#if !defined(_CHICAGO_)
        //
        // NB : For the first release of the scheduling agent, all security
        //      operations are disabled under Win95, even Win95 to NT.
        //

        //
        // Determine if the security settings should be shown or not.
        // The task object must reside within a tasks folder & exist
        // on an NT machine.
        //

        fEnableSecurity = (this->GetPlatformId() == VER_PLATFORM_WIN32_NT &&
                           this->IsTaskInTasksFolder());
#else
        fEnableSecurity = FALSE;
#endif // !defined(_CHICAGO_)

        if (!fEnableSecurity)
        {
            DestroyWindow(_hCtrl(lbl_run_as));
            DestroyWindow(_hCtrl(txt_run_as));
            DestroyWindow(_hCtrl(btn_passwd));
        }

        // See if the schedule page has already created the icon
        // helper, if not create it here.

        m_pIconHelper = (CIconHelper *)PropSheet_QuerySiblings(
                                GetParent(Hwnd()), GET_ICON_HELPER, 0);

        if (m_pIconHelper == NULL)
        {
            m_pIconHelper = new CIconHelper();

            if (m_pIconHelper == NULL)
            {
                hr = E_OUTOFMEMORY;
                break;
            }
        }
        else
        {
            m_pIconHelper->AddRef();
        }

        //
        // Set job name (static text showing path to .job object)
        //

        SetDlgItemText(Hwnd(), lbl_job_name, this->GetTaskPath());

        //
        // Set comments
        //

        hr = m_pIJob->GetComment(&pwsz);

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

        I_SetDlgItemText(Hwnd(), txt_comments, pwsz);
        CoTaskMemFree(pwsz);

        //
        // Get application name preparatory to setting it.
        //

        hr = m_pIJob->GetApplicationName(&pwsz);

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

#if defined(_CHICAGO_)
        //
        // Show the settings button only on Win95 and only if the task's
        // application is Sage-aware. Using the ApplicationName property in
        // pwsz, before it is freed below.
        //
        hr = UnicodeToAnsi(tszApp, pwsz, MAX_PATH+1);

        if (SUCCEEDED(hr) && !IsSageAware(tszApp, NULL, NULL))
        {
            //
            // The app isn't Sage-aware, so hide the Settings button and
            // move the Browse button to the Settings button position.
            //
            HWND hBrowseBtn = GetDlgItem(Hwnd(), btn_browse);
            HWND hSettingsBtn = GetDlgItem(Hwnd(), btn_settings);

            WINDOWPLACEMENT wp;
            wp.length = sizeof(WINDOWPLACEMENT);

            GetWindowPlacement(hSettingsBtn, &wp);

            ShowWindow(hSettingsBtn, SW_HIDE);

            MoveWindow(hBrowseBtn,
                       wp.rcNormalPosition.left,
                       wp.rcNormalPosition.top,
                       wp.rcNormalPosition.right - wp.rcNormalPosition.left,
                       wp.rcNormalPosition.bottom - wp.rcNormalPosition.top,
                       FALSE);
        }
#else
        lstrcpyn(tszApp, pwsz, MAX_PATH + 1);
#endif // defined(_CHICAGO_)

        //
        // If the application name fetched from the job object has spaces in
        // it, add quotes around the tchar version.
        //

        if (wcschr(pwsz, L' '))
        {
            AddQuotes(tszApp, MAX_PATH + 1);
        }
        CoTaskMemFree(pwsz);

        //
        // Now get the parameters and append a space and the tchar
        // representation to the app name.
        //

        hr = m_pIJob->GetParameters(&pwsz);
        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);


#if !defined(UNICODE)
        TCHAR tszArg[MAX_PATH + 1];
        UnicodeToAnsi(tszArg, pwsz, MAX_PATH + 1);
#else
        TCHAR * tszArg = pwsz;
#endif // !defined(UNICODE)

        //
        // If the /SAGERUN:n parameter appears in the arguments, save it in
        // an internal buffer, but don't show it in the UI.
        //

        LPTSTR ptszSageRun = _tcsstr(tszArg, SAGERUN_PARAM);

        if (ptszSageRun)
        {
            lstrcpyn(m_tszSageRunParam,
                     ptszSageRun,
                     ARRAYLEN(m_tszSageRunParam));

            *ptszSageRun = TEXT('\0');
            StripLeadTrailSpace(tszArg); // get rid of spaces before /sagerun
        }

        _SetAppEdit(tszApp, tszArg);

        CoTaskMemFree(pwsz);

        //
        // Set the working directory
        //

        hr = m_pIJob->GetWorkingDirectory(&pwsz);
        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

        if (wcschr(pwsz, L' '))
        {
            WCHAR wszWorkingDir[MAX_PATH + 1] = L"\"";

            wcsncpy(wszWorkingDir + 1, pwsz, MAX_PATH - 1);
            wcscat(wszWorkingDir, L"\"");
            I_SetDlgItemText(Hwnd(), txt_workingdir, wszWorkingDir);
        }
        else
        {
            I_SetDlgItemText(Hwnd(), txt_workingdir, pwsz);
        }
        CoTaskMemFree(pwsz);

        //
        //  Set the job enabled check box
        //

        DWORD dwFlags;

        hr = m_pIJob->GetFlags(&dwFlags);

        m_fEnableJob = (dwFlags & TASK_FLAG_DISABLED) ? FALSE : TRUE;

        CheckDlgButton(m_hPage, chk_enable_job, m_fEnableJob);

        if (!this->IsTaskInTasksFolder())
        {
            EnableWindow(_hCtrl(chk_enable_job), FALSE);
            m_fEnableJob = FALSE;
        }

#if !defined(_CHICAGO_)
        if (fEnableSecurity)
        {
            //
            // Set account name (run as)
            //

            hr = m_pIJob->GetAccountInformation(&pwsz);

            if (SUCCEEDED(hr))
            {
                I_SetDlgItemText(Hwnd(), txt_run_as, pwsz);
                m_AccountInfo.pwszAccountName = pwsz;
                EnableWindow(_hCtrl(btn_passwd), TRUE);
            }
            else if (hr == SCHED_E_ACCOUNT_INFORMATION_NOT_SET)
            {
                hr = S_OK;

                //
                // Set the run as field to the current user's name and
                // enable the set/change password button.
                // Leave it blank for AT jobs - else they look like they've
                // been set to run as this user, which is very confusing
                // (see bug 376163).  BUGBUG  Better behavior would be to
                // display a status message that this is an AT job and will
                // be upgraded if modified.
                //

                TCHAR tszUserName[MAX_USERNAME + 1] = TEXT("");

                if (! (dwFlags & JOB_I_FLAG_NET_SCHEDULE))
                {
                    GetDefaultDomainAndUserName(tszUserName, MAX_USERNAME + 1);
                }
                SetDlgItemText(Hwnd(), txt_run_as, tszUserName);
                EnableWindow(_hCtrl(btn_passwd), TRUE);
            }
            else
            {
                //
                // Disable the run as and set/change password button ctrls &
                // put up an error dialog letting the user know that security
                // services are unavailable.
                //
                // Actually, the set/change password button is already
                // disabled.
                //

                CHECK_HRESULT(hr);
                EnableWindow(_hCtrl(lbl_run_as), FALSE);
                EnableWindow(_hCtrl(txt_run_as), FALSE);
            }
        }
#endif // !defined(_CHICAGO_)

    } while (0);

    if (FAILED(hr))
    {
        if (hr == E_OUTOFMEMORY)
        {
            _ErrorDialog(IERR_OUT_OF_MEMORY);
        }
        else
        {
            _ErrorDialog(IERR_GENERAL_PAGE_INIT, hr);
        }

		//
		// Show application icon
		//
        m_updateIcon = 1;
        _UpdateAppIcon(tszApp);

        EnableWindow(Hwnd(), FALSE);

        return FALSE;
    }

    //
    // Show application icon
    //

    m_updateIcon = 1;
    _UpdateAppIcon(tszApp);


    //
    // Need to initialize these here since doing a SetDlgItemText causes
    // a WM_COMMAND msg with EN_CHANGE to be called for edit boxes.
    //

    m_CommentDirty = 0;
    m_AppNameDirty = 0;
    m_WorkingDirDirty = 0;
    m_RunAsDirty = 0;

    m_fDirty = FALSE;

    return TRUE;
}




#if !defined(_CHICAGO_)

//+--------------------------------------------------------------------------
//
//  Function:   GetDefaultDomainAndUserName
//
//  Synopsis:   Fill [ptszDomainAndUserName] with "domain\user" string
//
//  Arguments:  [ptszDomainAndUserName] - buffer to receive string
//              [cchBuf]                - should be at least MAX_USERNAME
//
//  Modifies:   *[ptszDomainAndUserName].
//
//  History:    06-03-1997   DavidMun   Created
//
//  Notes:      If an error occurs while retrieving the domain name, only
//              the user name is returned.  If even that cannot be
//              retrieved, the buffer is set to an empty string.
//
//---------------------------------------------------------------------------

VOID
GetDefaultDomainAndUserName(
    LPTSTR ptszDomainAndUserName,
    ULONG  cchBuf)
{
    TRACE_FUNCTION(GetDefaultDomainAndUserName);

    if (!GetUserNameEx(NameSamCompatible,
                       ptszDomainAndUserName,
                       &cchBuf))
    {
        DEBUG_OUT((DEB_ERROR,
                   "GetDefaultDomainAndUserName: GetUserNameEx failed %d\n",
                   GetLastError()));

        ptszDomainAndUserName[0] = L'\0';
    }
}


#endif // !defined(_CHICAGO_)




void
CGeneralPage::_UpdateAppIcon(
    LPCTSTR ptszAppName)
{
    if (m_updateIcon == 0)
    {
        return;
    }

    m_updateIcon = 0;

    if (ptszAppName)
    {
        m_pIconHelper->SetAppIcon((LPTSTR)ptszAppName);
    }

    BOOL fEnabled;

    if (this->IsTaskInTasksFolder())
    {
        fEnabled = (IsDlgButtonChecked(m_hPage, chk_enable_job)
                    == BST_CHECKED);
    }
    else
    {
        fEnabled = FALSE;
    }

    m_pIconHelper->SetJobIcon(fEnabled);

    SendDlgItemMessage(Hwnd(), idc_icon, STM_SETICON,
                    (WPARAM)m_pIconHelper->hiconJob, 0L);
}


BOOL
CGeneralPage::_Browse(
    TCHAR szFilePath[]) // of size MAX_PATH
{
    TCHAR szDefExt[5];
    TCHAR szBrowserDir[MAX_PATH];
    TCHAR szFilters[MAX_PATH];
    TCHAR szTitle[100];

    DWORD dwFlags = OFN_HIDEREADONLY | OFN_FILEMUSTEXIST | OFN_NOCHANGEDIR;

    LoadString(g_hInstance, IDS_EXE, szDefExt, ARRAYLEN(szDefExt));
    LoadString(g_hInstance, IDS_BROWSE, szTitle, ARRAYLEN(szTitle));

    ZeroMemory(szFilters, ARRAYLEN(szFilters));
    if (!LoadString(g_hInstance,
                    IDS_PROGRAMSFILTER,
                    szFilters,
                    ARRAYLEN(szFilters)))
    {
		CHECK_HRESULT( HRESULT_FROM_WIN32(GetLastError()) );
        return FALSE;
    }

    GetCurrentDirectory(MAX_PATH, szBrowserDir);

    OPENFILENAME ofn;
    ZeroMemory(&ofn, sizeof(ofn));

    szFilePath[0] = TEXT('\0');

    // Setup info for comm dialog.
    ofn.lStructSize       = CDSIZEOF_STRUCT(OPENFILENAME, lpTemplateName);
    ofn.hwndOwner         = Hwnd();
    ofn.hInstance         = g_hInstance;
    ofn.lpstrFilter       = szFilters;
    ofn.nFilterIndex      = 1;
    ofn.lpstrFile         = szFilePath;
    ofn.nMaxFile          = MAX_PATH;
    ofn.lpstrInitialDir   = szBrowserDir;
    ofn.lpstrTitle        = szTitle;
    ofn.Flags             = dwFlags;
    ofn.lpstrDefExt       = szDefExt;

    // Call it.
    if (GetOpenFileName(&ofn) == FALSE)
    {
        DEBUG_OUT((DEB_ERROR, "GetOpenFileName failed<0x%x>\n",
                                            CommDlgExtendedError()));

        return FALSE;
    }
    return TRUE;
}


LRESULT
CGeneralPage::_OnCommand(
    int     id,
    HWND    hwndCtl,
    UINT    codeNotify)
{
    TRACE(CGeneralPage, _OnCommand);

    if ((id == btn_browse) && (codeNotify == BN_CLICKED))
    {
        // popup the file browse dialog

        TCHAR tszFilePath[MAX_PATH+1];

        if (_Browse(tszFilePath))
        {
            if (_tcschr(tszFilePath, TEXT(' ')))
            {
                AddQuotes(tszFilePath, MAX_PATH);
            }
            SetDlgItemText(Hwnd(), txt_app_name, tszFilePath);
            SendMessage(Hwnd(),
                        WM_NEXTDLGCTL,
                        (WPARAM)_hCtrl(txt_workingdir),
                        TRUE);
            _UpdateAppIcon(tszFilePath);
            _EnableApplyButton();
        }
    }
#if defined(_CHICAGO_)
    else if (id == btn_settings && codeNotify == BN_CLICKED)
    {
        TCHAR tszApp[MAX_PATH + 1];

        _GetAppAndArgs(tszApp, NULL);

        // invoke the application to do its settings.

        BOOL fHadSageRun = (*m_tszSageRunParam != '\0');

        DoSageSettings(tszApp, m_tszSageRunParam);

        //
        // If the DoSageSettings func created a /sagerun parameter,
        // mark the app name as dirty, since the sagerun parameter doesn't
        // appear in the UI, therefore we won't be doing a settext with
        // it and automatically dirtying.
        //

        if (!fHadSageRun && *m_tszSageRunParam)
        {
            m_AppNameDirty = 1;
            _EnableApplyButton();
        }
    }
#endif // defined(_CHICAGO_)
#if !defined(_CHICAGO_)
    else if (id == btn_passwd && codeNotify == BN_CLICKED)
    {
        // popup the set password dialog
        LaunchSetPasswordDlg(Hwnd(), &m_AccountInfo);

        //
        // Since we've launched the set password dialog, we want
        // to suppress the set account information dialog which
        // otherwise may come up on apply.
        //

        m_fSuppressAcctInfoRequestOnApply = TRUE;

        _EnableApplyButton();
    }
#endif // !defined(_CHICAGO_)
    else if (codeNotify == EN_CHANGE)
    {
        switch (id)
        {
        case txt_comments:
            m_CommentDirty = 1;
            break;

        case txt_app_name:
            //
            // If we just did a SetDlgItemText, then this change notification
            // should be ignored.
            //
            if (m_ChangeFromSetText)
            {
                m_ChangeFromSetText = 0;
            }
            else
            {
                m_AppNameDirty = 1;
                m_updateIcon = 1;
            }
            break;

        case txt_workingdir:
            m_WorkingDirDirty = 1;
            break;

        case txt_run_as:
#if !defined(_CHICAGO_)
                //
                // If m_fApplyRunAsEditChange is TRUE, the user has edited
                // the RunAs control, therefore, we want to apply changes.
                // If FALSE, the RunAs control has been automatically updated
                // by the UI as a result of an apply. In this case, we do
                // not want to apply the change, as it already has been.
                //

                if (m_fApplyRunAsEditChange)
                {
                    m_RunAsDirty = 1;
                    EnableWindow(_hCtrl(btn_passwd), TRUE);
                    break;
                }
                else
                {
                    Win4Assert(!m_fDirty);
                    return TRUE;
                }
#endif // !defined(_CHICAGO_)

        default:
            return FALSE;
        }

        _EnableApplyButton();
    }
    else if (codeNotify == EN_KILLFOCUS &&
             id == txt_app_name)
    {
        if (m_AppNameDirty == 1)
        {
            TCHAR tszApp[MAX_PATH + 1];

            _GetAppAndArgs(tszApp, NULL);
            if (_JobObjectIsLocal())
            {
                _ExpandAppName(tszApp);
            }
            _UpdateAppIcon(tszApp);
        }
    }
    else if (id == chk_enable_job)
    {
        _EnableApplyButton();
        m_updateIcon = 1;
        _UpdateAppIcon(NULL);
    }

    return TRUE;
}



LRESULT
CGeneralPage::_OnApply(void)
{
    TRACE(CGeneralPage, _OnApply);
    //DbxDisplay("CGeneralPage::_OnApply");

    if (m_fDirty == FALSE)
    {
        return TRUE;
    }

    HRESULT     hr = S_OK;
    WCHAR       wcBuff[MAX_PATH+1];
    LPWSTR      pwszArg = NULL;

    do
    {
        if (m_CommentDirty == 1)
        {
            wcBuff[0] = L'\0';

            I_GetDlgItemText(Hwnd(), txt_comments, wcBuff, MAX_PATH+1);

            hr = m_pIJob->SetComment(wcBuff);

            CHECK_HRESULT(hr);
            BREAK_ON_FAIL(hr);

            m_CommentDirty = 0;
        }

#if !defined(_CHICAGO_)
        m_fTaskApplicationChange = FALSE;
#endif // !defined(_CHICAGO_)

        if (m_AppNameDirty == 1)
        {
            WCHAR wszApp[MAX_PATH + 1];

            _UpdateAppNameAndIcon(wszApp, &pwszArg);
            if (pwszArg == NULL)
            {
                break;
            }

            hr = m_pIJob->SetApplicationName(wszApp);
            CHECK_HRESULT(hr);
            BREAK_ON_FAIL(hr);

            //
            // Since the application name has changed, it may no longer name
            // (or may now name) a sage-aware application.  Make sure that
            // the sagerun argument is appended only if it should be.
            //
            // BUGBUG IsSageAware and CreateSageRunKey use HKLM, so they're
            // broken for remote case.  If this is fixed, enable this code
            // on NT if the target machine is win9x.
            //
            // BUGBUG pwszArg is limited to MAX_PATH characters on Win9x.
            //

#if defined(_CHICAGO_)
            int iSageRun;

            if (IsSageAwareW(wszApp, pwszArg, &iSageRun))
            {
                wsprintf(m_tszSageRunParam,
                         TEXT("%s%u"),
                         SAGERUN_PARAM,
                         iSageRun);

                CHAR szApp[MAX_PATH + 1];

                UnicodeToAnsi(szApp, wszApp, ARRAYLEN(szApp));

                LPSTR pszFileName = PathFindFileName(szApp);

                if (pszFileName)
                {
                    CreateSageRunKey(pszFileName, iSageRun);
                }
            }
            else
            {
                *m_tszSageRunParam = TEXT('\0');
            }

            WCHAR wszArg[MAX_PATH + 1];

            ULONG cchArg = wcslen(pwszArg);

            if (*m_tszSageRunParam &&
                lstrlen(m_tszSageRunParam) + cchArg + 1 < ARRAYLEN(wszArg))
            {
                wcscpy(wszArg, pwszArg);
                if (cchArg)
                {
                    wszArg[cchArg++] = L' ';
                }
                AnsiToUnicode(&wszArg[cchArg],
                              m_tszSageRunParam,
                              ARRAYLEN(wszArg) - cchArg);
                hr = m_pIJob->SetParameters(wszArg);
            }
            else
            {
                hr = m_pIJob->SetParameters(pwszArg);
            }
#else
            hr = m_pIJob->SetParameters(pwszArg);
#endif // defined(_CHICAGO_)

            CHECK_HRESULT(hr);
            BREAK_ON_FAIL(hr);

            m_AppNameDirty           = 0;
#if !defined(_CHICAGO_)
            m_fTaskApplicationChange = TRUE;
#endif // !defined(_CHICAGO_)
        }

        if (m_WorkingDirDirty == 1)
        {
            wcBuff[0] = L'\0';

            _ExpandWorkingDir();
            I_GetDlgItemText(Hwnd(), txt_workingdir, wcBuff, MAX_PATH+1);

            hr = m_pIJob->SetWorkingDirectory(wcBuff);

            CHECK_HRESULT(hr);
            BREAK_ON_FAIL(hr);

            m_WorkingDirDirty = 0;
        }

        //
        // For the first release of the scheduling agent, all security
        // operations are disabled under Win95, even Win95 to NT.
        //

#if !defined(_CHICAGO_)
        m_fTaskAccountChange = FALSE;
        if (m_RunAsDirty == 1 || m_AccountInfo.pwszPassword != tszEmpty)
        {
            wcBuff[0] = L'\0';
            DWORD ccAccountName = I_GetDlgItemText(Hwnd(),
                                                   txt_run_as,
                                                   wcBuff,
                                                   MAX_USERNAME + 1);

            if ((m_RunAsDirty == 1 && m_AccountInfo.pwszAccountName == NULL) ||
                (m_RunAsDirty == 1 && m_AccountInfo.pwszAccountName != NULL &&
                 lstrcmpiW(m_AccountInfo.pwszAccountName, wcBuff) != 0))
            {
                //
                // The user has changed the account name. Check if they have
                // specified a password.
                //

                if (m_AccountInfo.pwszPassword == tszEmpty)
                {
                    //
                    // User hasn't specified a password. Launch the set
                    // password dialog.
                    //

                    LaunchSetPasswordDlg(Hwnd(), &m_AccountInfo);

                    //
                    // Since we've launched the set password dialog, we want
                    // to suppress the set account information dialog which
                    // otherwise may come up on apply.
                    //

                    m_fSuppressAcctInfoRequestOnApply = TRUE;
                }
            }

            if (m_AccountInfo.pwszPassword != tszEmpty)
            {
                hr = m_pIJob->SetAccountInformation(
                                            wcBuff,
                                            m_AccountInfo.pwszPassword);

                if (FAILED(hr))
                {
                    CHECK_HRESULT(hr);
                    break;
                }

                m_RunAsDirty         = 0;
                m_AccountInfo.fDirty = FALSE;
                m_fTaskAccountChange = TRUE;
            }
        }
#endif // !defined(_CHICAGO_)

        //
        //  Save the job enabled state
        //

        if (this->IsTaskInTasksFolder())
        {
            DWORD dwFlags;

            hr = m_pIJob->GetFlags(&dwFlags);

            BOOL fTemp = (IsDlgButtonChecked(m_hPage, chk_enable_job)
                                                        == BST_CHECKED);

            if (m_fEnableJob != fTemp)
            {
                m_fEnableJob = fTemp;

                if (m_fEnableJob == TRUE)
                {
                    dwFlags &= ~TASK_FLAG_DISABLED;
                }
                else
                {
                    dwFlags |= TASK_FLAG_DISABLED;
                }

                hr = m_pIJob->SetFlags(dwFlags);

                CHECK_HRESULT(hr);
                BREAK_ON_FAIL(hr);
            }
        }

        //
        // reset dirty flag
        //

        m_fDirty = FALSE;

        //
        //  If evrything went well see if the other pages are ready to
        //  save the job to storage.
        //

        if ((m_fPersistChanges == TRUE)  &&
            (PropSheet_QuerySiblings(GetParent(Hwnd()),
                                        QUERY_READY_TO_BE_SAVED, 0))
            == 0)
        {
            //
            // Save the job file to storage.
            //
            // For the first release of the scheduling agent, all security
            // operations are disabled under Win95, even Win95 to NT.
            //

            hr = JFSaveJob(Hwnd(),
                           m_pIJob,
#if !defined(_CHICAGO_)
                           this->GetPlatformId() == VER_PLATFORM_WIN32_NT &&
                            this->IsTaskInTasksFolder(),
                           m_fTaskAccountChange,
                           m_fTaskApplicationChange,
                           m_fSuppressAcctInfoRequestOnApply);
#else
                           FALSE,
                           FALSE,
                           FALSE,
                           TRUE);
#endif // !defined(_CHICAGO_)

            CHECK_HRESULT(hr);
            BREAK_ON_FAIL(hr);

#if !defined(_CHICAGO_)
            m_fTaskApplicationChange          = FALSE;
            m_fTaskAccountChange              = FALSE;
            m_fSuppressAcctInfoRequestOnApply = FALSE;

            // Will result in refresh of the run as edit control.
            //
            _UpdateRunAsControl();
#endif // !defined(_CHICAGO_)
        }

    } while (0);

    delete [] pwszArg;

    if (FAILED(hr))
    {
        if (hr == E_OUTOFMEMORY)
        {
            _ErrorDialog(IERR_OUT_OF_MEMORY);
        }
        else if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
        {
            _ErrorDialog(IERR_FILE_NOT_FOUND);
        }
        else if (hr == HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED))
        {
            _ErrorDialog(IERR_ACCESS_DENIED);
        }
        else
        {
            _ErrorDialog(IERR_INTERNAL_ERROR, hr);
        }
    }

    return SUCCEEDED(hr);
}




//+--------------------------------------------------------------------------
//
//  Member:     CGeneralPage::_UpdateAppNameAndIcon
//
//  Synopsis:   Update the application name edit control with an expanded
//              path for the app, then update the icon for the new path.
//
//  Arguments:  [wszApp]  - NULL or buffer to receive WCHAR app name
//              [ppwszArgs] - NULL or address of pointer to buffer to receive
//                  WCHAR arguments.  Must be deallocated with delete[].
//
//  Modifies:   *[wszApp], *[ppwszArgs]
//
//  History:    1-31-1997   DavidMun   Created
//
//  Notes:      App path is only expanded if job object is local.
//
//---------------------------------------------------------------------------

VOID
CGeneralPage::_UpdateAppNameAndIcon(
    LPWSTR wszApp,
    LPWSTR * ppwszArgs)
{
    TCHAR tszApp[MAX_PATH + 1];
    LPTSTR ptszArgs = NULL;
    TCHAR tszAppAndArg[MAX_PATH + 1];

    _GetAppAndArgs(tszApp, &ptszArgs);
    if (ptszArgs == NULL)
    {
        return;
    }

    if (_JobObjectIsLocal())
    {
        _ExpandAppName(tszApp);

        m_updateIcon = 1;
        _UpdateAppIcon(tszApp);

        //
        // If the working directory is empty and the app is on the local
        // machine, provide a default of the directory where the app lives.
        //

        TCHAR tszWorkingDir[MAX_PATH + 1];
        GetDlgItemText(Hwnd(), txt_workingdir, tszWorkingDir, MAX_PATH + 1);
        StripLeadTrailSpace(tszWorkingDir);
        DeleteQuotes(tszWorkingDir);

        if (!*tszWorkingDir && IsLocalFilename(tszApp))
        {
            lstrcpy(tszWorkingDir, tszApp);
            DeleteQuotes(tszWorkingDir);

            // Get rid of the filename at the end of the string

            PathRemoveFileSpec(tszWorkingDir);

            if (HasSpaces(tszWorkingDir))
            {
                AddQuotes(tszWorkingDir, MAX_PATH + 1);
            }
            SetDlgItemText(Hwnd(), txt_workingdir, tszWorkingDir);
        }

        m_ChangeFromSetText = 1;
        _SetAppEdit(tszApp, ptszArgs);
    }

    if (wszApp)
    {
#if !defined(UNICODE)
        AnsiToUnicode(wszApp, tszApp, MAX_PATH + 1);
#else
        lstrcpy(wszApp, tszApp);
#endif // defined(UNICODE)
    }

    if (ppwszArgs)
    {
#if !defined(UNICODE)
        LONG cch = lstrlen(ptszArgs) + 1;
        *ppwszArgs = new WCHAR[cch];
        if (*ppwszArgs != NULL)
        {
            AnsiToUnicode(*ppwszArgs, ptszArgs, cch);
        }
        delete [] ptszArgs;
#else
        *ppwszArgs = ptszArgs;
#endif // defined(UNICODE)
    }
    else
    {
        delete [] ptszArgs;
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CGeneralPage::_ExpandWorkingDir
//
//  Synopsis:   Replace the string in the working directory edit control
//              with one which has expanded environment strings.
//
//  History:    06-04-1997   DavidMun   Created
//
//  Notes:      Note that this will result in the working dir being marked
//              as dirty.
//
//---------------------------------------------------------------------------

VOID
CGeneralPage::_ExpandWorkingDir()
{
    TCHAR tszApp[MAX_PATH + 1];
    TCHAR tszAppAndArg[MAX_PATH + 1];

    //
    // If editing a remote job, don't touch the working dir, since we
    // can't expand using its environment variables.
    //

    if (!_JobObjectIsLocal())
    {
        return;
    }

    TCHAR tszWorkingDir[MAX_PATH + 1];

    GetDlgItemText(Hwnd(), txt_workingdir, tszWorkingDir, MAX_PATH + 1);
    StripLeadTrailSpace(tszWorkingDir);
    DeleteQuotes(tszWorkingDir);

    TCHAR tszExpandedWorkingDir[MAX_PATH + 1];

    ULONG cchWritten;

    cchWritten = ExpandEnvironmentStrings(tszWorkingDir,
                                          tszExpandedWorkingDir,
                                          ARRAYLEN(tszExpandedWorkingDir));

    //
    // If the call succeeded, write the update string to the working dir
    // edit control.  If there were no environment variables to replace,
    // the string will be unchanged.
    //
    // Note that writing to the edit control will cause an EN_CHANGE which
    // will result in m_WorkingDirDirty being set.
    //

    if (cchWritten && cchWritten <= ARRAYLEN(tszExpandedWorkingDir))
    {
        SetDlgItemText(Hwnd(), txt_workingdir, tszExpandedWorkingDir);
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CGeneralPage::_GetAppAndArgs
//
//  Synopsis:   Fetch the string in the application name edit control and
//              split it into the app name part and the arguments part.
//
//  Arguments:  [tszApp]  - NULL or buffer for app name
//              [pptszArgs] - NULL or address of pointer to buffer for args,
//                  must be deallocated with delete[]
//
//  Modifies:   *[tszApp], *[pptszArgs]
//
//  History:    1-31-1997   DavidMun   Created
//
//  Notes:      Application name is space delimited and must be surrounded
//              by double quotes if it contains spaces.  For example:
//
//              text in edit ctrl        'filename' 'arguments'
//              ---------------------    -------------------------
//              notepad.exe foo.txt   => 'notepad.exe' 'foo.txt'
//              "notepad.exe"foo.txt  => '"notepad.exe"foo.txt' ''
//              "notepad.exe" foo.txt => '"notepad.exe"' 'foo.txt'
//              "no  pad.exe" foo.txt => '"no  pad.exe"' 'foo.txt'
//              no  pad.exe foo.txt   => 'no' '  pad.exe foo.txt'
//
//---------------------------------------------------------------------------

VOID
CGeneralPage::_GetAppAndArgs(
    LPTSTR tszApp,
    LPTSTR * pptszArgs)
{
    //
    // Split application name into executable name & parameters.  First
    // strip lead/trail spaces and null terminate at the first whitespace
    // outside a quote.
    //

    int cch = SchedGetDlgItemTextLength(Hwnd(), txt_app_name) + 1;
    if (cch <= 1)
    {
        DEBUG_OUT((DEB_ERROR,
                   "SchedGetDlgItemTextLength failed %d\n",
                   GetLastError()));
    }

    TCHAR *ptszBoth = new TCHAR[cch];
    if (ptszBoth == NULL)
    {
        DEBUG_OUT((DEB_ERROR,
                   "_GetAppAndArgs alloc failed %d\n",
                   GetLastError()));
        return;
    }

    GetDlgItemText(Hwnd(), txt_app_name, ptszBoth, cch);
    StripLeadTrailSpace(ptszBoth);

    LPTSTR  ptsz;
    BOOL    fInQuote = FALSE;

    for (ptsz = ptszBoth; *ptsz; ptsz = NextChar(ptsz))
    {
        if (*ptsz == TEXT('"'))
        {
            fInQuote = !fInQuote;
        }
        else if (*ptsz == TEXT(' '))
        {
            if (!fInQuote)
            {
                *ptsz++ = L'\0';
                break;
            }
        }
    }

    //
    // Return app name if caller wants it.
    //

    if (tszApp)
    {
        lstrcpy(tszApp, ptszBoth);
    }

    //
    // Now ptsz points to the first char past the application
    // name.  If there are no arguments, then ptsz is pointing
    // to the end of the string.  Otherwise it's pointing to the
    // start of the argument string.  Return this if caller wants it.
    //

    if (pptszArgs)
    {
        *pptszArgs = new TCHAR[cch - (ptsz - ptszBoth)];
        if (*pptszArgs == NULL)
        {
            DEBUG_OUT((DEB_ERROR,
                       "_GetAppAndArgs second alloc failed %d\n",
                       GetLastError()));
        }
        else
        {
            lstrcpy(*pptszArgs, ptsz);
        }
    }

    delete [] ptszBoth;
}




//+--------------------------------------------------------------------------
//
//  Member:     CGeneralPage::_ExpandAppName
//
//  Synopsis:   Change filename in [tszApp] to full path.
//
//  Arguments:  [tszApp] - filename to modify
//
//  Modifies:   *[tszApp]
//
//  History:    1-31-1997   DavidMun   Created
//
//  Notes:      CAUTION: Should be called only for job objects on the
//              LOCAL MACHINE.
//
//---------------------------------------------------------------------------

VOID
CGeneralPage::_ExpandAppName(
    LPTSTR tszApp)
{
    TCHAR tszWorkingDir[MAX_PATH + 1];
    BOOL fFound;

    GetDlgItemText(Hwnd(), txt_workingdir, tszWorkingDir, MAX_PATH + 1);
    fFound = ProcessApplicationName(tszApp, tszWorkingDir);

    if (_tcschr(tszApp, TEXT(' ')))
    {
        AddQuotes(tszApp, MAX_PATH);
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CGeneralPage::_SetAppEdit
//
//  Synopsis:   Set the application edit control to contain the concatenated
//              text in [tszApp] and [tszArgs].
//
//  Arguments:  [tszApp]  - application name
//              [tszArgs] - arguments
//
//  History:    1-31-1997   DavidMun   Created
//
//  Notes:      No modification (adding quotes, etc.) is done to [tszApp].
//              Caller should set m_ChangeFromSetText = 1 if calling from
//              outside of wm_initdialog processing.
//
//---------------------------------------------------------------------------

VOID
CGeneralPage::_SetAppEdit(LPCTSTR tszApp, LPCTSTR tszArgs)
{
    HWND hwndAppName = GetDlgItem(Hwnd(), txt_app_name);

    Edit_SetText(hwndAppName, tszApp);

    if (tszArgs && *tszArgs)
    {
        ULONG cchApp = lstrlen(tszApp);

        Edit_SetSel(hwndAppName, cchApp, cchApp);
        Edit_ReplaceSel(hwndAppName, TEXT(" "));
        Edit_SetSel(hwndAppName, cchApp + 1, cchApp + 1);
        Edit_ReplaceSel(hwndAppName, tszArgs);
    }
}




LRESULT CGeneralPage::_OnCancel(void)
{
    return 0;
}



LRESULT
CGeneralPage::_OnPSMQuerySibling(
    WPARAM  wParam,
    LPARAM  lParam)
{
    TRACE(CGeneralPage, _OnPSMQuerySibling);

    INT_PTR iRet = 0;

    switch (wParam)
    {
    case QUERY_READY_TO_BE_SAVED:
        iRet = (int)m_fDirty;
        break;

    case GET_ICON_HELPER:
        iRet = (INT_PTR)m_pIconHelper;
        break;

#if !defined(_CHICAGO_)
    case QUERY_TASK_APPLICATION_DIRTY_STATUS:
        *((BOOL *)lParam) = m_fTaskApplicationChange;
        iRet = 1;
        break;

    case QUERY_TASK_ACCOUNT_INFO_DIRTY_STATUS:
        *((BOOL *)lParam) = m_fTaskAccountChange;
        iRet = 1;
        break;

    case QUERY_SUPPRESS_ACCOUNT_INFO_REQUEST_FLAG:
        *((BOOL *)lParam) = m_fSuppressAcctInfoRequestOnApply;
        iRet = 1;
        break;

    case RESET_TASK_APPLICATION_DIRTY_STATUS:
        m_fTaskApplicationChange = FALSE;
        iRet = 1;
        break;

    case RESET_TASK_ACCOUNT_INFO_DIRTY_STATUS:
        m_fTaskAccountChange = FALSE;
        iRet = 1;
        break;

    case RESET_SUPPRESS_ACCOUNT_INFO_REQUEST_FLAG:
        m_fSuppressAcctInfoRequestOnApply = FALSE;
        iRet = 1;
        break;

    case TASK_ACCOUNT_CHANGE_NOTIFY:
        Win4Assert(!m_fDirty);
        _UpdateRunAsControl();
        iRet = 1;
        break;
#endif // !defined(_CHICAGO_)

    }

    SetWindowLongPtr(Hwnd(), DWLP_MSGRESULT, iRet);
    return iRet;
}



#if !defined(_CHICAGO_)
void
CGeneralPage::_UpdateRunAsControl(void)
{
    LPWSTR pwsz;

    if (SUCCEEDED(m_pIJob->GetAccountInformation(&pwsz)))
    {
        //
        // Instruct the EN_CHANGE processing of the RunAs edit control
        // to not apply this change.
        //

        m_fApplyRunAsEditChange = FALSE;
        I_SetDlgItemText(Hwnd(), txt_run_as, pwsz);
        m_fApplyRunAsEditChange = TRUE;
        CoTaskMemFree(pwsz);
    }
}
#endif // !defined(_CHICAGO_)


LRESULT
CGeneralPage::_OnPSNKillActive(
    LPARAM lParam)
{
    TRACE(CGeneralPage, _OnPSNKillActive);

    if (m_AppNameDirty)
    {
        _UpdateAppNameAndIcon(NULL, NULL);
    }

    if (m_WorkingDirDirty)
    {
        _ExpandWorkingDir();
    }
    return CPropPage::_OnPSNKillActive(lParam);
}



LRESULT
CGeneralPage::_OnHelp(
    HANDLE hRequesting,
    UINT uiHelpCommand)
{
    WinHelp((HWND)hRequesting,
            szMstaskHelp,
            uiHelpCommand,
            (DWORD_PTR)(LPSTR)s_aGeneralPageHelpIds);
    return TRUE;
}


HRESULT
GetGeneralPage(
    ITask           * pIJob,
    LPTSTR            ptszTaskPath,
    BOOL              fPersistChanges,
    HPROPSHEETPAGE  * phpage)
{
    TRACE_FUNCTION(GetGeneralPage);

    Win4Assert(pIJob != NULL);
    Win4Assert(phpage != NULL);

    HRESULT         hr      = S_OK;
    LPOLESTR        polestr = NULL;
    IPersistFile  * ppf     = NULL;
    LPTSTR          ptszPath = NULL;

    do
    {
        //
        // Get the job name.
        //

        if (ptszTaskPath != NULL)
        {
            //
            // use passed-in path
            //

            ptszPath = ptszTaskPath;
        }
        else
        {
            //
            // Obtain the job path from the interfaces.
            //

            hr = GetJobPath(pIJob, &ptszPath);
        }

        BREAK_ON_FAIL(hr);

        CGeneralPage * pPage = new CGeneralPage(
                                        pIJob,
                                        ptszPath,
                                        fPersistChanges);

        if (pPage == NULL)
        {
            hr = E_OUTOFMEMORY;
            CHECK_HRESULT(hr);
            break;
        }

        HPROPSHEETPAGE hpage = CreatePropertySheetPage(&pPage->m_psp);

        if (hpage == NULL)
        {
            delete pPage;
            hr = E_OUTOFMEMORY;
            CHECK_HRESULT(hr);
            break;
        }

        *phpage = hpage;

    } while (0);

    //
    // If we made a copy of pIJob's path string, free it.
    //

    if (ptszPath != ptszTaskPath)
    {
        delete [] ptszPath;
    }

    if (ppf != NULL)
    {
        ppf->Release();
    }

    return hr;
}



HRESULT
AddGeneralPage(
    PROPSHEETHEADER &psh,
    ITask          * pIJob)
{
    TRACE_FUNCTION(AddGeneralPage);

    HPROPSHEETPAGE hpage = NULL;

    HRESULT hr = GetGeneralPage(pIJob, NULL, TRUE, &hpage);

    if (SUCCEEDED(hr))
    {
        psh.phpage[psh.nPages++] = hpage;
    }

    return hr;
}



HRESULT
AddGeneralPage(
    LPFNADDPROPSHEETPAGE    lpfnAddPage,
    LPARAM                  cookie,
    ITask                 * pIJob)
{
    HPROPSHEETPAGE hpage = NULL;

    HRESULT hr = GetGeneralPage(pIJob, NULL, TRUE, &hpage);

    if (SUCCEEDED(hr))
    {
        if (!lpfnAddPage(hpage, cookie))
        {
            DestroyPropertySheetPage(hpage);

            hr = E_FAIL;
            CHECK_HRESULT(hr);
        }
    }

    return hr;
}


#if !defined(_CHICAGO_)
//+---------------------------------------------------------------------------
//
//  Function:   ResetAccountInfo
//
//  Synopsis:   Deallocate and initialize the account information specified.
//
//  Arguments:  [pAccountInfo] -- Account info structure.
//
//  Returns:    None.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
void
ResetAccountInfo(
    AccountInfo * pAccountInfo)
{
    //
    // Delete the account name.
    //

    if (pAccountInfo->pwszAccountName != NULL)
    {
        //
        // NB : pwszAccountName always allocated by CoTaskMemAlloc.
        //

        CoTaskMemFree(pAccountInfo->pwszAccountName);
        pAccountInfo->pwszAccountName = NULL;
    }

    //
    // Zero, delete the password. Except when the password is set to the
    // static empty string.
    //

    if (pAccountInfo->pwszPassword != NULL &&
        pAccountInfo->pwszPassword !