 DefAllocatorFree,
            0,
            AllocatorFraming->FrameSize,
            AllocatorFraming->FileAlignment,
            (USHORT) AllocatorFraming->Frames );
        DefAllocatorInstance->DefaultAllocate =
            (PFNKSDEFAULTALLOCATE) ExAllocateFromPagedLookasideList;
        DefAllocatorInstance->DefaultFree =
            (PFNKSDEFAULTFREE) ExFreeToPagedLookasideList;
        DefAllocatorInstance->DeleteAllocator =
            (PFNKSDELETEALLOCATOR) ExDeletePagedLookasideList;
        break;

    default://ALLOCATOR_TYPE_EXTERNAL

        Status = InitializeAllocator(
            InitializeContext,
            AllocatorFraming,
            &DefAllocatorInstance->Context);
        if (!NT_SUCCESS(Status)) {
            KsFreeObjectHeader(DefAllocatorInstance->Header);
            ExFreePool(DefAllocatorInstance);
            return Status;
        }
        DefAllocatorInstance->DefaultAllocate = DefaultAllocate;
        DefAllocatorInstance->DefaultFree = DefaultFree;
        DefAllocatorInstance->DeleteAllocator = DeleteAllocator;
        break;

    }

    // Enable the internal event used to kick off a work item whenever 
    // an element is freed up. This allows the DISPATCH_LEVEL calls to
    // eventually service any pending allocator IRP's.
    
    ExInitializeWorkItem(
        &DefAllocatorInstance->FreeWorkItem,
        (PWORKER_THREAD_ROUTINE) FreeWorker,
        (PVOID) DefAllocatorInstance );

    DefAllocatorInstance->FreeWorkItem.List.Blink = NULL;
    DefAllocatorInstance->EventData.WorkItem.Reserved = 0;
    DefAllocatorInstance->EventData.WorkItem.WorkQueueItem = 
        &DefAllocatorInstance->FreeWorkItem;
    DefAllocatorInstance->EventData.WorkItem.WorkQueueType = CriticalWorkQueue;
    DefAllocatorInstance->EventData.NotificationType = KSEVENTF_WORKITEM;
    KeInitializeEvent(&DefAllocatorInstance->Event, NotificationEvent, FALSE);
    DefAllocatorInstance->ReferenceCount = 0;
    DefAllocatorInstance->ClosingAllocator = FALSE;

    Event.Set = KSEVENTSETID_StreamAllocator;
    Event.Id = KSEVENT_STREAMALLOCATOR_INTERNAL_FREEFRAME;
    Event.Flags = KSEVENT_TYPE_ENABLE;

    Status = KsSynchronousIoControlDevice(
        irpSp->FileObject,
        KernelMode,
        IOCTL_KS_ENABLE_EVENT,
        &Event,
        sizeof( Event ),
        &DefAllocatorInstance->EventData,
        sizeof( DefAllocatorInstance->EventData ),
        &BytesReturned );
    ASSERT(Status != STATUS_PENDING);

    if (!NT_SUCCESS(Status)) {
        DefAllocatorInstance->DeleteAllocator(DefAllocatorInstance->Context);
        KsFreeObjectHeader(DefAllocatorInstance->Header);
        ExFreePool(DefAllocatorInstance);
    }

    return Status;
}


NTSTATUS
DefAllocatorIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    The IRP handler for IRP_MJ_DEVICE_CONTROL for the default Allocator. Handles
    the properties, methods, and events supported by this implementation.

Arguments:

    DeviceObject -
        The device object to which the Allocator is attached. This is not used.

    Irp -
        The specific device control IRP to be processed.

Return Value:

    Returns the status of the processing, which may be pending.

--*/
{
    NTSTATUS Status;
    PIO_STACK_LOCATION irpSp;
    PKSDEFAULTALLOCATOR_INSTANCEHDR DefAllocatorInstance;

    PAGED_CODE();
    
    irpSp = IoGetCurrentIrpStackLocation( Irp );
    DefAllocatorInstance =
        (PKSDEFAULTALLOCATOR_INSTANCEHDR) irpSp->FileObject->FsContext;

    switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {

    case IOCTL_KS_PROPERTY:

        Status = 
            KsPropertyHandler( Irp, 
                               SIZEOF_ARRAY( DefAllocatorPropertyTable ),
                               (PKSPROPERTY_SET) DefAllocatorPropertyTable );

        break;

    case IOCTL_KS_METHOD:

        Status = 
            KsMethodHandler( Irp, 
                             SIZEOF_ARRAY( DefAllocatorMethodTable ),
                             (PKSMETHOD_SET) DefAllocatorMethodTable );
        break;
        
    case IOCTL_KS_ENABLE_EVENT:

        Status = KsEnableEvent( Irp,
                                SIZEOF_ARRAY( DefAllocatorEventSetTable ),
                                (PKSEVENT_SET) DefAllocatorEventSetTable,
                                &DefAllocatorInstance->EventQueue,
                                KSEVENTS_SPINLOCK,
                                &DefAllocatorInstance->EventLock );
        break;
                               
    case IOCTL_KS_DISABLE_EVENT:

        Status = 
           KsDisableEvent( Irp,
                           &DefAllocatorInstance->EventQueue,
                           KSEVENTS_SPINLOCK,
                           &DefAllocatorInstance->EventLock );
        break;

    default:

        Status = STATUS_INVALID_DEVICE_REQUEST;
        break;

    }
    //
    // Allocation requests may be returned STATUS_PENDING.
    //
    Irp->IoStatus.Status = Status;
    if (Status != STATUS_PENDING) {
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
    }

    return Status;

}


NTSTATUS
DefAllocatorClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    The IRP handler for IRP_MJ_CLOSE for the default Allocator. Cleans up the
    lookaside list, and instance data. 

Arguments:

    DeviceObject -
        The device object to which the Allocator is attached. This is not used.

    Irp -
        The specific close IRP to be processed.

Return Value:

    Returns STATUS_SUCCESS.

--*/
{
    PIO_STACK_LOCATION irpSp;
    PKSDEFAULTALLOCATOR_INSTANCEHDR DefAllocatorInstance;

    PAGED_CODE();
    
    irpSp = IoGetCurrentIrpStackLocation( Irp );
    DefAllocatorInstance =
        (PKSDEFAULTALLOCATOR_INSTANCEHDR) irpSp->FileObject->FsContext;
    //
    // Free any outstanding events which have been enabled.
    //
    KsFreeEventList( irpSp->FileObject,
                     &DefAllocatorInstance->EventQueue,
                     KSEVENTS_SPINLOCK,
                     &DefAllocatorInstance->EventLock );
    //
    // If a worker is running, or is queued to run, then wait for
    // completion.
    //
    DefAllocatorInstance->ClosingAllocator = TRUE;
    if (DefAllocatorInstance->FreeWorkItem.List.Blink ||
        DefAllocatorInstance->ReferenceCount) {
        KeWaitForSingleObject(
            &DefAllocatorInstance->Event,
            Executive,
            KernelMode,
            FALSE,
            NULL);
    }
    //
    // Free the object header that was allocated on Create, and the FsContext.
    //
    DefAllocatorInstance->DeleteAllocator(DefAllocatorInstance->Context);
    KsFreeObjectHeader(DefAllocatorInstance->Header);
    ExFreePool( DefAllocatorInstance );
    
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return STATUS_SUCCESS;

}


NTSTATUS
iMethodAlloc(
    IN PIRP Irp,
    IN PKSMETHOD Method,
    OUT PVOID* Data
    )
/*++

Routine Description:

    Attempts to allocate memory using the internal direct function call
    allocation routine. Callers to this function take action of failure
    to allocate a frame by placing the request on a queue.

Arguments:

    Irp -
        The specific alloc method IRP to be processed.

    Method -
        Points to the method identifier parameter.

    Data -
        Points to the place in which to put the returned pointer to the memory
        block allocated.

Return Value:

    If memory is allocated, sets the pointer and return size in the IRP, and
    returns STATUS_SUCCESS. Else returns STATUS_INSUFFICIENT_RESOURCES. Does
    not complete the IRP.

--*/
{
    NTSTATUS Status;
    PIO_STACK_LOCATION irpSp;
    PVOID Buffer;

    PAGED_CODE(); 
    
    irpSp = IoGetCurrentIrpStackLocation( Irp );
    
    Status = iAlloc( irpSp->FileObject, &Buffer );
    
    //
    // The Irp is only completed if the frame allocation succeeds, else it
    // is queued. So fill in the return size (a pointer to the frame is
    // returned) on success.
    //
    
    //
    // Note that iAlloc will return the proper status if we are unable
    // to allocate a frame because of pool resources.
    //
    
    if (Buffer) {
        *Data = Buffer;
        Irp->IoStatus.Information = sizeof( *Data );
    }

    return Status;
}


NTSTATUS
MethodAlloc(
    IN PIRP Irp,
    IN PKSMETHOD Method,
    OUT PVOID* Data
    )
/*++

Routine Description:

    This function is the method handler for KSMETHOD_STREAMALLOCATOR_ALLOC, and
    calls the internal allocation method. If the allocation fails, this function
    will make the IRP pending. The IRP will be completed when a buffer is
    available.

Arguments:

    Irp -
        The IRP containing the allocation method request.

    Method -
        The method parameter of the allocation request.

    Data -
        The data paramter of the allocation request.

Return Value:

    Returns STATUS_SUCCESS if the buffer was allocated, else STATUS_PENDING.

--*/
{
    NTSTATUS Status;
    
    PAGED_CODE();

    //
    // Do not let user mode have direct access to this.
    //
    if (Irp->RequestorMode != KernelMode) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }
    
    //
    // First just try to allocate a frame. If this succeeds, then a 
    // successful return can be generated. If not, the Irp is just 
    // queued if we are out of entries, otherwise we complete the IRP
    // with a failure status.
    //
    Status = iMethodAlloc( Irp, Method, Data );
    
    if (Status == STATUS_NO_MORE_ENTRIES) {
        PIO_STACK_LOCATION              irpSp;
        PKSDEFAULTALLOCATOR_INSTANCEHDR DefAllocatorInstance;
        
        irpSp = IoGetCurrentIrpStackLocation( Irp );
        DefAllocatorInstance =
            (PKSDEFAULTALLOCATOR_INSTANCEHDR) irpSp->FileObject->FsContext;
            
        //
        // The new frame waiter is added to the end of the queue so that
        // all requests are serviced approximately in order.
        //
        KsAddIrpToCancelableQueue( &DefAllocatorInstance->WaiterQueue, 
                                   &DefAllocatorInstance->WaiterLock,
                                   Irp, KsListEntryTail, KsCancelRoutine );
                                   
        Status = STATUS_PENDING;
    }
    return Status;    
}


VOID
ServiceAllocRequests(
    PKSDEFAULTALLOCATOR_INSTANCEHDR DefAllocatorInstance
    )
/*++

Routine Description:

    Attempts to fulfill all outstanding allocation requests.

Arguments:

    DefAllocatorInstance -
        Contains the allocator instance information.

Return Value:

    Nothing.

--*/
{
    PIRP AllocIrp;

    //
    // Note that this may be competing for the free item with the DISPATCH_LEVEL 
    // interface.  If an Irp can be pulled off of the queue, then it can be
    // completed, otherwise it's already been grabbed by another waiter.
    //
    while (AllocIrp = 
        KsRemoveIrpFromCancelableQueue( &DefAllocatorInstance->WaiterQueue,
                                        &DefAllocatorInstance->WaiterLock,
                                        KsListEntryHead,
                                        KsAcquireOnly )) {
        //
        // Try to complete the I/O by processing the request again. If it
        // fails to allocate the frame, just put the waiter back on the list.
        //
        if (STATUS_SUCCESS == 
                    KsDispatchSpecificMethod( AllocIrp, iMethodAlloc )) {
            KsRemoveSpecificIrpFromCancelableQueue( AllocIrp );
            AllocIrp->IoStatus.Status = STATUS_SUCCESS;
            IoCompleteRequest( AllocIrp, IO_NO_INCREMENT );
        } else {
            KsReleaseIrpOnCancelableQueue( AllocIrp, NULL );
            break;
        }
    }
}


VOID
FreeWorker(
    PKSDEFAULTALLOCATOR_INSTANCEHDR DefAllocatorInstance
    )
/*++

Routine Description:

    The worker callback function which is used to attempt to fulfill any
    outstanding allocation requests.

Arguments:

    DefAllocatorInstance -
        Contains the allocator instance information.

Return Value:

    Nothing.

--*/
{
    //
    // Ensure that the reference count is updated first, so that the
    // DefAllocatorClose check won't skip a wait.
    //
    InterlockedIncrement(&DefAllocatorInstance->ReferenceCount);
    DefAllocatorInstance->FreeWorkItem.List.Blink = NULL;
    ServiceAllocRequests(DefAllocatorInstance);
    //
    // Only set the event if another work item is not about to increment
    // the reference count on the way into this function.
    //
    if (!InterlockedDecrement(&DefAllocatorInstance->ReferenceCount) &&
        !DefAllocatorInstance->FreeWorkItem.List.Blink &&
        DefAllocatorInstance->ClosingAllocator) {
        KeSetEvent(&DefAllocatorInstance->Event, IO_NO_INCREMENT, FALSE);
    }
}


NTSTATUS
MethodFree(
    IN PIRP Irp,
    IN PKSMETHOD Method,
    IN PVOID Data
    )

/*++

Routine Description:

    This function is the method handler for KSMETHOD_STREAMALLOCATOR_FREE.
    Attempts to free memory using the internal direct function call free
    routine.

Arguments:

    Irp -
        The specific free method IRP to be processed.

    Method -
        Points to the method identifier parameter.

    Data -
        Points to the memory block pointer to free.

Return Value:

    Returns STATUS_SUCCESS.

--*/

{
    PIO_STACK_LOCATION irpSp;

    PAGED_CODE();

    //
    // Do not let user mode have direct access to this.
    //
    if (Irp->RequestorMode != KernelMode) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    iFree( irpSp->FileObject, *((PVOID *)Data ) );
    //
    // Since a free frame has just been added, try servicing any free requests.
    //
    ServiceAllocRequests( (PKSDEFAULTALLOCATOR_INSTANCEHDR) irpSp->FileObject->FsContext );
    return STATUS_SUCCESS;
}


NTSTATUS
DefAllocatorGetFunctionTable(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PKSSTREAMALLOCATOR_FUNCTIONTABLE FunctionTable
    )

/*++

Routine Description:

    This function is the method handler for
    KSMETHOD_STREAMALLOCATOR_FUNCTIONTABLE. Returns the allocate and free
    functions.

Arguments:
    Irp -
        The specific property IRP to be processed.

    Property -
        Points to the property identifier parameter.

    FunctionTable -
        Points to the function table to fill in.

Return Value:

--*/

{
    PAGED_CODE();

    //
    // Fill caller's function table with the DISPATCH_LEVEL interfaces
    // for allocate and free.
    //
    FunctionTable->AllocateFrame = iAlloc;
    FunctionTable->FreeFrame = iFreeAndStartWorker;
    //
    // This field has already been set by the property handling.
    // Irp->IoStatus.Information = sizeof( *FunctionTable );
    //

    return STATUS_SUCCESS;
}


NTSTATUS
DefAllocatorGetStatus(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PKSSTREAMALLOCATOR_STATUS Status
    )

/*++

Routine Description:

    This function is the method handler for KSPROPERTY_STREAMALLOCATOR_STATUS
    which returns the current status of the given allocator.

Arguments:
    Irp -
        The specific property IRP to be processed.

    Property -
        Points to the property identifier parameter.

    Status -
        Points to the status structure.

Return Value:

--*/

{
    PIO_STACK_LOCATION irpSp;
    PKSDEFAULTALLOCATOR_INSTANCEHDR DefAllocatorInstance;

    PAGED_CODE();
    
    irpSp = IoGetCurrentIrpStackLocation( Irp );
    DefAllocatorInstance =
        (PKSDEFAULTALLOCATOR_INSTANCEHDR) irpSp->FileObject->FsContext;
    
    //
    // Return the allocator status information.
    //    
    
    Status->AllocatedFrames = DefAllocatorInstance->AllocatedFrames;
    Status->Framing = DefAllocatorInstance->Framing;
    Status->Reserved = 0;
    //
    // This field has already been set by the property handling.
    // Irp->IoStatus.Information = sizeof( *Status );
    //
    
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\input\upgrade\upgrade.c ===
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <tchar.h>
#include <regstr.h>

// this will change when the .h is moved to a public location
#include "comp.h"

HINSTANCE hInstance;

PCOMPAIBILITYCALLBACK CompatCallback;
LPVOID                CompatContext;

#define szServicesPath REGSTR_PATH_SERVICES TEXT("\\")
#define szDeviceMap    TEXT("HARDWARE\\DEVICEMAP")

typedef struct _INPUT_DRIVER_DATA {
    LPTSTR Service;

    BOOL DisableReplacements;

    LPTSTR DeviceMapSubKey;

} INPUT_DRIVER_DATA;

INPUT_DRIVER_DATA DriverData[] = {
    { TEXT("sermouse"), FALSE, NULL },
    { TEXT("i8042prt"), TRUE, TEXT("KeyboardPort") },
    { TEXT("mouclass"), TRUE, TEXT("PointerClass") },
    { TEXT("kbdclass"), TRUE, TEXT("KeyboardClass") },
};

#define NUM_DRIVER_DATA (sizeof(DriverData) / sizeof(INPUT_DRIVER_DATA))

LPENUM_SERVICE_STATUS
AllocEnumServiceStatus(SC_HANDLE hSCManager, LPDWORD Count)
{
    LPENUM_SERVICE_STATUS ess;
    DWORD size;
    DWORD resume;

    EnumServicesStatus(hSCManager,
                       SERVICE_DRIVER,
                       SERVICE_ACTIVE,
                       NULL,
                       0,
                       &size,
                       Count,
                       &resume);

    if (size == 0) {
        return NULL;
    }

    ess = (LPENUM_SERVICE_STATUS) LocalAlloc(LPTR, size);
    if (!ess) {
        return NULL;
    }

    EnumServicesStatus(hSCManager,
                       SERVICE_DRIVER,
                       SERVICE_ACTIVE,
                       ess,
                       size,
                       &size,
                       Count,
                       &resume);

    return ess;
}

LPQUERY_SERVICE_CONFIG 
GetServiceConfig(SC_HANDLE hService)
{
    LPQUERY_SERVICE_CONFIG pConfig;
    DWORD configSize;

    QueryServiceConfig(hService, NULL, 0, &configSize);

    pConfig = (LPQUERY_SERVICE_CONFIG) LocalAlloc(LPTR, configSize);
    if (pConfig == NULL) {
        return NULL;
    }

    if (!QueryServiceConfig(hService, pConfig, configSize, &configSize)) {
        LocalFree(pConfig);
        pConfig = NULL;
    }

    return pConfig;
}

BOOL
ValidImagePath(LPTSTR Service, LPTSTR ImagePath, LPTSTR *ImageName)
{
    LPTSTR pszDriver, pszDriverEnd, pszDriverBegin;

    if (!ImagePath) {
        return FALSE;
    }

    if (lstrlen(ImagePath) == 0) {
        return TRUE;
    }

    if (_tcschr(ImagePath, TEXT('\\')) == 0) {
        return FALSE;
    }

    pszDriver = ImagePath;
    pszDriverEnd = pszDriver + lstrlen(pszDriver);

    while(pszDriverEnd != pszDriver &&
          *pszDriverEnd != TEXT('.')) {
        pszDriverEnd--;
    }

    // pszDriverEnd points to either the beginning of the string or '.'
    pszDriverBegin = pszDriverEnd;

    while(pszDriverBegin != pszDriver &&
          *pszDriverBegin != TEXT('\\')) {
        pszDriverBegin--;
    }

    pszDriverBegin++;

    //
    // If pszDriver and pszDriverEnd are different, we now
    // have the driver name.
    //
    if (pszDriverBegin > pszDriver && 
        pszDriverEnd > pszDriverBegin) {

        LONG len, res;
        LPTSTR image;

        len = ((LONG) (pszDriverEnd - pszDriverBegin)) + 1;

        image = (LPTSTR) LocalAlloc(LPTR, len * sizeof(TCHAR));
        if (!image) {
            return FALSE;
        }
        
        // want to copy up to, but not including, the ','
        lstrcpyn(image, pszDriverBegin, len);
        res = lstrcmpi(image, Service); 

        if (ImageName != NULL) {
            *ImageName = image;
        } 
        else {
            LocalFree(image);
        }

        return res == 0;
    }
    else {
        return FALSE;
    }

}

VOID
SetServiceStartValue(LPTSTR Service, DWORD StartValue)
{
    COMPATIBILITY_ENTRY ce;
    TCHAR szStart[] = TEXT("Start");
    LPTSTR regPath;
    DWORD len;

    len = lstrlen(Service) + lstrlen(szServicesPath) + 1;
    len *= sizeof(TCHAR);

    regPath = (LPTSTR) LocalAlloc(LPTR, len);
    if (!regPath) {
        return;
    }

    lstrcpy(regPath, szServicesPath);
    lstrcat(regPath, Service);

    ZeroMemory(&ce, sizeof(COMPATIBILITY_ENTRY));
    // Description and TextName are need even though this is hidden
    ce.Description = Service; 
    ce.TextName = Service;
    ce.RegKeyName = regPath;
    ce.RegValName = szStart;
    ce.RegValDataSize = sizeof(DWORD);
    ce.RegValData = (LPVOID) &StartValue;
    ce.Flags |= COMPFLAG_HIDE;

    CompatCallback(&ce, CompatContext);

    LocalFree(regPath);
}

VOID
SetServiceImagePath(LPTSTR Service)
{
    COMPATIBILITY_ENTRY ce;
    TCHAR szImagePath[] = TEXT("ImagePath");
    TCHAR szPath[] = TEXT("System32\\Drivers\\");
    LPTSTR imagePath, regPath;
    DWORD len;

    len = lstrlen(Service) + lstrlen(szServicesPath) + 1;
    len *= sizeof(TCHAR);

    regPath = (LPTSTR) LocalAlloc(LPTR, len);
    if (!regPath) {
        return;
    }

    len = lstrlen(szPath) + lstrlen(Service) + lstrlen(TEXT(".sys")) + 1;
    len *= sizeof(TCHAR);

    imagePath = (LPTSTR) LocalAlloc(LPTR, len);
    if (!imagePath) {
        LocalFree(regPath);
        return;
    }

    lstrcpy(regPath, szServicesPath);
    lstrcat(regPath, Service);

    lstrcpy(imagePath, szPath);
    lstrcat(imagePath, Service);
    lstrcat(imagePath, TEXT(".sys"));

    ZeroMemory(&ce, sizeof(COMPATIBILITY_ENTRY));
    // Description and TextName are need even though this is hidden
    ce.Description = Service;
    ce.TextName = Service;
    ce.RegKeyName = regPath;
    ce.RegValName = szImagePath;
    ce.RegValDataSize = len; 
    ce.RegValData = (LPVOID) imagePath;
    ce.Flags |= COMPFLAG_HIDE;

    CompatCallback(&ce, CompatContext);

    LocalFree(regPath);
    LocalFree(imagePath);
}

SC_HANDLE
CheckService(SC_HANDLE hSCManager, LPTSTR Service, BOOL *Disabled)
{
    SC_HANDLE hService;
    LPQUERY_SERVICE_CONFIG pConfig;

    hService = OpenService(hSCManager, Service, SERVICE_QUERY_CONFIG);
    if (hService) {
        pConfig = GetServiceConfig(hService);
        if (pConfig) {

            if (pConfig->dwStartType == SERVICE_DISABLED && 
                pConfig->lpBinaryPathName &&
                lstrlen(pConfig->lpBinaryPathName) == 0) {
                //
                // The service has been preinstalled in the registry, but never
                // installed on the machine (indicated byno image path,
                // disabled).  Setting its start value to demand start will not
                // cause any conflicts at all in the PNP world of input drivers.
                //
                SetServiceStartValue(Service, SERVICE_DEMAND_START);
            }
            else {
                if (pConfig->dwStartType != SERVICE_SYSTEM_START &&
                    pConfig->dwStartType != SERVICE_DEMAND_START) {
                    if (Disabled) {
                        *Disabled = TRUE;
                    }
                    SetServiceStartValue(Service, SERVICE_DEMAND_START);
                }
    
                if (!ValidImagePath(Service, pConfig->lpBinaryPathName, NULL)) {
                    SetServiceImagePath(Service);
                }
    
            
            }

            LocalFree(pConfig);
            pConfig = NULL;
        }
    }

    return hService;                                   
}

BOOL
KnownInputDriver(LPTSTR Service)
{
    int i = 0;

    for ( ; i < NUM_DRIVER_DATA; i++) {
        if (lstrcmpi(Service, DriverData[i].Service) == 0) {
            return TRUE;
        }
    }

    return FALSE;
}

VOID
EnumAndDisableFromDeviceMap(SC_HANDLE hSCManager, LPTSTR Key)
{
    HKEY hMap, hSubKey;                                                     
    DWORD dwIndex = 0, dwType, err, dwValueNameSize, dwDataSize;
    TCHAR szValueName[255], szData[255];

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     szDeviceMap,
                     0,
                     KEY_READ,
                     &hMap) != ERROR_SUCCESS) {
        return;
    }
    
    if (RegOpenKeyEx(hMap, Key, 0, KEY_READ, &hSubKey) != ERROR_SUCCESS) {
        RegCloseKey(hMap);
        return;
    }

    RegCloseKey(hMap);

    do {
        dwValueNameSize = sizeof(szValueName) / sizeof(TCHAR);
        dwDataSize = sizeof(szData);

        err = RegEnumValue(hSubKey,
                           dwIndex++,
                           szValueName,
                           &dwValueNameSize,
                           0,
                           &dwType,
                           (LPBYTE) szData,
                           &dwDataSize);

        if (err == ERROR_SUCCESS) {
            LPTSTR service = _tcsrchr(szData, TEXT('\\'));

            if (service) {
                service++;
                if (!KnownInputDriver(service)) {
                    SetServiceStartValue(service, SERVICE_DISABLED);
                }
            }
        }
    } while (err == ERROR_SUCCESS);

    RegCloseKey(hSubKey);
}

BOOL
InputUpgradeCheck(PCOMPAIBILITYCALLBACK CompatibilityCallback, LPVOID Context)
{
    SC_HANDLE hSCManager, hService;
    BOOL disabled;
    int i;

    LPENUM_SERVICE_STATUS ess = NULL;
    DWORD count, resume;

    CompatCallback = CompatibilityCallback;
    CompatContext = Context;

    hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (hSCManager == NULL) {
        return TRUE;
    }

    for (i = 0; i < NUM_DRIVER_DATA; i++) {
        disabled = FALSE;
        hService = CheckService(hSCManager, DriverData[i].Service, &disabled);
        if (hService) {
            if (disabled && DriverData[i].DisableReplacements) {
                // search and destroy
                EnumAndDisableFromDeviceMap(hSCManager,
                                            DriverData[i].DeviceMapSubKey); 
            }
            CloseServiceHandle(hService); 
        }
    }

    CloseServiceHandle(hSCManager);
    return TRUE;
}

BOOL APIENTRY 
DllMain(HINSTANCE hDll,
        DWORD dwReason, 
        LPVOID lpReserved)
{
    switch (dwReason) {
    case DLL_PROCESS_ATTACH:
        hInstance = hDll;
        break;

    case DLL_PROCESS_DETACH:
        break;

    case DLL_THREAD_DETACH:
        break;

    case DLL_THREAD_ATTACH:
        break;

    default:
        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\ks\automat.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    automat.cpp

Abstract:

    This module contains functions relating to the use of kernel streaming
    automation tables.

Author:

    Dale Sather  (DaleSat) 31-Jul-1998

--*/

#include "ksp.h"
#include <kcom.h>

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA

//
// KSPAUTOMATION_SET is a template for any one of the three automation set
// types (KSPROPERTY_SET, KSMETHOD_SET, KSEVENT_SET).  Use of this structure
// allows functions to handle all three types of sets generically.
//
typedef struct KSPAUTOMATION_SET_ { 
    GUID* Set;
    ULONG ItemsCount;
    PULONG Items;
} KSPAUTOMATION_SET, *PKSPAUTOMATION_SET;

//
// KSPAUTOMATION_TYPE is a template for the fields in an automation table
// relating to any one of the three automation types (properties, methods,
// events).  Use of this structure allows functions to handle all three types 
// in a generic manner.
//
typedef struct {
    ULONG SetsCount;
    ULONG ItemSize;
    PKSPAUTOMATION_SET Sets;
} KSPAUTOMATION_TYPE, *PKSPAUTOMATION_TYPE;


void
KspCountSetsAndItems(
    IN const KSPAUTOMATION_TYPE* AutomationTypeA,
    IN const KSPAUTOMATION_TYPE* AutomationTypeB,
    IN ULONG SetSize,
    OUT PULONG SetsCount,
    OUT PULONG ItemsCount,
    OUT PULONG ItemSize
    )

/*++

Routine Description:

    This routine counts property/method/event sets and items for two tables
    that are to be merged.  Table A is the dominant table.

Arguments:

    AutomationTypeA -
        Contains a pointer to a structure that serves as a template for
        KSAUTOMATION_TABLE fields regarding properties, methods or events.
        This structure describes a table of sets of items.  Of the two
        tables, A and B, A is dominant.

    AutomationTypeB -
        Contains a pointer to a structure that serves as a template for
        KSAUTOMATION_TABLE fields regarding properties, methods or events.
        This structure describes a table of sets of items.  Of the two
        tables, A and B, A is dominant.

    SetSize -
        Contains the size in bytes of a set structure.  This varies between
        properties, methods and events.

    SetsCount -
        Contains a pointer to the location at which the count of sets is to
        be deposited.

    ItemsCount -
        Contains a pointer to the location at which the count of items is to
        be deposited.

    ItemSize -
        Contains a pointer to the location at which the size of an item
        structure is to be deposited.  This will be the maximum of the item
        sizes from AutomationTypeA and AutomationTypeB.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KspCountSetsAndItems]"));

    PAGED_CODE();

    ASSERT(AutomationTypeA);
    ASSERT(AutomationTypeB);
    ASSERT(SetSize);
    ASSERT(SetsCount);
    ASSERT(ItemsCount);
    ASSERT(ItemSize);

    //
    // Do a max of the sizes just to be nice.
    //
    if (AutomationTypeA->ItemSize > AutomationTypeB->ItemSize) {
        *ItemSize = AutomationTypeA->ItemSize;
    } else {
        *ItemSize = AutomationTypeB->ItemSize;
    }

    //
    // For updating item pointers, produce an offset in units sizeof(ULONG).
    //
    ASSERT(AutomationTypeA->ItemSize % sizeof(ULONG) == 0);
    ASSERT(AutomationTypeB->ItemSize % sizeof(ULONG) == 0);
    ULONG itemIncrA = AutomationTypeA->ItemSize / sizeof(ULONG);
    ULONG itemIncrB = AutomationTypeB->ItemSize / sizeof(ULONG);

    //
    // Count all the sets and items in the A table.
    //
    ULONG setsCount = AutomationTypeA->SetsCount;
    ULONG itemsCount = 0;

    PKSPAUTOMATION_SET setA = AutomationTypeA->Sets;
    for (ULONG count = AutomationTypeA->SetsCount;
         count--;
         setA = PKSPAUTOMATION_SET(PUCHAR(setA) + SetSize)) {
        itemsCount += setA->ItemsCount;
    }

    //
    // Count all the sets and properties in the B table, checking for
    // duplicates.
    //
    PKSPAUTOMATION_SET setB = AutomationTypeB->Sets;
    for (count = AutomationTypeB->SetsCount;
         count--;
         setB = PKSPAUTOMATION_SET(PUCHAR(setB) + SetSize)) {
        PKSPAUTOMATION_SET setAMatch = NULL;
        PKSPAUTOMATION_SET setA = AutomationTypeA->Sets;
        for (ULONG count1 = AutomationTypeA->SetsCount;
            count1--; 
            setA = PKSPAUTOMATION_SET(PUCHAR(setA) + SetSize)) {
            if (IsEqualGUIDAligned(*setA->Set,*setB->Set)) {
                setAMatch = setA;
                break;
            }
        }

        if (setAMatch) {
            //
            // Found a matching set.  Don't count the B set, and check each
            // property to see if it's a duplicate.
            //
            PULONG itemB = setB->Items;
            for (ULONG count2 = setB->ItemsCount; 
                 count2--; 
                 itemB += itemIncrB) {
                //
                // Count the item.  We'll discount it later if it's a dup.
                //
                itemsCount++;

                //
                // Look for a dup.
                //
                PULONG itemA = setAMatch->Items;
                for (ULONG count3 = setA->ItemsCount;
                     count3--;
                     itemA += itemIncrA) {
                    if (*itemA == *itemB) {
                        //
                        // Found a match:  discount this item.
                        //
                        itemsCount--;
                        break;
                    }
                }
            }
        } else {
            //
            // Did not find a matching set.  Count the B set and its 
            // properties.
            //
            setsCount++;
            itemsCount += setB->ItemsCount;
        }
    }

    *SetsCount = setsCount;
    *ItemsCount = itemsCount;
}

void
KspCopyAutomationType(
    IN const KSPAUTOMATION_TYPE* pSourceAutomationType,
    IN OUT PKSPAUTOMATION_TYPE AutomationTypeAB,
    IN ULONG SetSize,
    IN OUT PVOID * Destination
     )
/*++

Routine Description:

    This routine copies a table of properties, methods or events to destination

Arguments:

    SourceAutomationType -
        Contains a pointer to a structure that serves as a template for
        KSAUTOMATION_TABLE fields regarding properties, methods or events.
        This structure describes a table of sets of items.

    AutomationTypeAB -
        Contains a pointer to a structure serves as a template for
        KSAUTOMATION_TABLE fields regarding properties, methods or events.
        This structure describes the copied table of of sets of items.        

    SetSize -
        Contains the size in bytes of a set structure.  This varies between
        properties, methods and events.

    Destination -
        Contains a pointer a pointer to the buffer into which the table is to
        be deposited.  *Destination is updated to pointer following the 
        deposited table.  The buffer must be large enough to accommodate
        the table.

Return Value:

    None.


--*/
{
    PUCHAR destination=(PUCHAR)*Destination;    
    PKSPAUTOMATION_SET setS=(PKSPAUTOMATION_SET)pSourceAutomationType->Sets;
    PKSPAUTOMATION_SET setD;

    //
    // set the new Sets pointer in the new type
    //
    AutomationTypeAB->Sets = setD = (PKSPAUTOMATION_SET)destination;

    //
    // adjust the room to account for sets followed by items
    //
    destination += SetSize * AutomationTypeAB->SetsCount;
    
    for (ULONG count = pSourceAutomationType->SetsCount;
        count--;
        setS = PKSPAUTOMATION_SET(PUCHAR(setS) + SetSize)) {
        //
        // Copy the set structure.
        //
        RtlCopyMemory(setD,setS,SetSize);

        //
        // set the new Items pointer in the new set
        //
        setD->Items = (PULONG) destination;

        //
        // copy all items
        //
        LONG cbItems = AutomationTypeAB->ItemSize * setD->ItemsCount;
           RtlCopyMemory(setD->Items,setS->Items,cbItems);
        destination += cbItems;
       }
       *Destination = (PVOID) destination;
}


void
KspMergeAutomationTypes(
    IN const KSPAUTOMATION_TYPE* AutomationTypeA,
    IN const KSPAUTOMATION_TYPE* AutomationTypeB,
    IN OUT PKSPAUTOMATION_TYPE AutomationTypeAB,
    IN ULONG SetSize,
    IN OUT PVOID* Destination
    )

/*++

Routine Description:

    This routine merges tables of properties, methods or events.  Table A is
    the dominant table.

Arguments:

    AutomationTypeA -
        Contains a pointer to a structure that serves as a template for
        KSAUTOMATION_TABLE fields regarding properties, methods or events.
        This structure describes a table of sets of items.  Of the two
        tables, A and B, A is dominant.

    AutomationTypeB -
        Contains a pointer to a structure that serves as a template for
        KSAUTOMATION_TABLE fields regarding properties, methods or events.
        This structure describes a table of sets of items.  Of the two
        tables, A and B, A is dominant.

    AutomationTypeAB -
        Contains a pointer to a structure serves as a template for
        KSAUTOMATION_TABLE fields regarding properties, methods or events.
        This structure describes the merged table of of sets of items.

    SetSize -
        Contains the size in bytes of a set structure.  This varies between
        properties, methods and events.

    Destination -
        Contains a pointer a pointer to the buffer into which the table is to
        be deposited.  *Destination is updated to pointer to the first aligned
        byte following the deposited table.  The buffer must be large enough
        to accommodate the table.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KspMergeAutomationTypes]"));

    PAGED_CODE();

    ASSERT(AutomationTypeA);
    ASSERT(AutomationTypeB);
    ASSERT(AutomationTypeAB);
    ASSERT(Destination);
    ASSERT(*Destination);

    //
    // For updating item pointers, produce an offset in units sizeof(ULONG).
    //
    ASSERT(AutomationTypeA->ItemSize % sizeof(ULONG) == 0);
    ASSERT(AutomationTypeB->ItemSize % sizeof(ULONG) == 0);
    ULONG itemIncrA = AutomationTypeA->ItemSize / sizeof(ULONG);
    ULONG itemIncrB = AutomationTypeB->ItemSize / sizeof(ULONG);

    //
    // Find start of set and item tables.
    //
    PKSPAUTOMATION_SET setAB = PKSPAUTOMATION_SET(*Destination);
    PUCHAR destination = PUCHAR(*Destination) + (SetSize * AutomationTypeAB->SetsCount);

    AutomationTypeAB->Sets = setAB;

    BOOLEAN duplicateSetsExist = FALSE;

    //
    // Copy all the sets in the A table.
    //
    PKSPAUTOMATION_SET setA = AutomationTypeA->Sets;
    for (ULONG count = AutomationTypeA->SetsCount;
         count--;
         setA = PKSPAUTOMATION_SET(PUCHAR(setA) + SetSize)) {
        //
        // Copy the set structure.
        //
        RtlCopyMemory(setAB,setA,SetSize);

        //
        // Set the items pointer in the new set.
        //
        setAB->Items = PULONG(destination);

        //
        // Copy all the items from the A table.
        //
        PULONG itemA = setA->Items;
        for (ULONG count1 = setA->ItemsCount;
             count1--;
             itemA += itemIncrA) {
            RtlCopyMemory(destination,itemA,AutomationTypeA->ItemSize);
            destination += AutomationTypeAB->ItemSize;
        }

        //
        // See if the same set exists in the B table.
        //
        PKSPAUTOMATION_SET setBMatch = NULL;
        PKSPAUTOMATION_SET setB = AutomationTypeB->Sets;
        for (count1 = AutomationTypeB->SetsCount;
             count1--; 
             setB = PKSPAUTOMATION_SET(PUCHAR(setB) + SetSize)) {
            if (IsEqualGUIDAligned(*setA->Set,*setB->Set)) {
                setBMatch = setB;
                duplicateSetsExist = TRUE;
                break;
            }
        }

        if (setBMatch) {
            //
            // The same set is in the B table.  Add its unique items.
            //
            PULONG itemB = setBMatch->Items;
            for (count1 = setB->ItemsCount;
                 count1--;
                 itemB += itemIncrB) {
                //
                // Look for a dup.
                //
                PULONG itemAMatch = NULL;
                PULONG itemA = setA->Items;
                for (ULONG count2 = setA->ItemsCount;
                     count2--;
                     itemA += itemIncrA) {
                    if (*itemA == *itemB) {
                        itemAMatch = itemA;
                        break;
                    }
                }

                if (! itemAMatch) {
                    //
                    // No dup.  Copy the item.
                    //
                    RtlCopyMemory(destination,itemB,AutomationTypeB->ItemSize);
                    destination += AutomationTypeAB->ItemSize;
                    setAB->ItemsCount++;
                }
            }
        }

        setAB = PKSPAUTOMATION_SET(PUCHAR(setAB) + SetSize);
    }

    //
    // Copy all the unique sets in the B table.
    //
    PKSPAUTOMATION_SET setB = AutomationTypeB->Sets;
    for (count = AutomationTypeB->SetsCount;
         count--;
         setB = PKSPAUTOMATION_SET(PUCHAR(setB) + SetSize)) {
        //
        // Look for a duplicate set in the A table.  We only need to search
        // if duplicates were found when we were copying the A table.
        //
        PKSPAUTOMATION_SET setAMatch = NULL;
        if (duplicateSetsExist) {
            PKSPAUTOMATION_SET setA = AutomationTypeA->Sets;
            for (ULONG count1 = AutomationTypeA->SetsCount;
                 count1--;
                 setA = PKSPAUTOMATION_SET(PUCHAR(setA) + SetSize)) {
                if (IsEqualGUIDAligned(*setA->Set,*setB->Set)) {
                    setAMatch = setA;
                    break;
                }
            }
        }

        if (! setAMatch) {
            //
            // The set is unique.  Copy the set structure.
            //
            RtlCopyMemory(setAB,setB,SetSize);

            //
            // Set the items pointer in the new set.
            //
            setAB->Items = PULONG(destination);

            //
            // Copy all the items from the B table.
            //
            PULONG itemB = setB->Items;
            for (ULONG count1 = setB->ItemsCount;
                 count1--;
                 itemB += itemIncrB) {
                RtlCopyMemory(destination,itemB,AutomationTypeB->ItemSize);
                destination += AutomationTypeAB->ItemSize;
            }

            setAB = PKSPAUTOMATION_SET(PUCHAR(setAB) + SetSize);
        }
    }

    *Destination = PVOID(destination);
}


KSDDKAPI
NTSTATUS
NTAPI
KsMergeAutomationTables(
    OUT PKSAUTOMATION_TABLE* AutomationTableAB,
    IN PKSAUTOMATION_TABLE AutomationTableA OPTIONAL,
    IN PKSAUTOMATION_TABLE AutomationTableB OPTIONAL,
    IN KSOBJECT_BAG Bag OPTIONAL
    )

/*++

Routine Description:

    This routine merges two automation tables.  Table A is dominant with
    respect to duplicate entries.  The resulting table is placed in a single
    contiguous memory block allocated using ExAllocatePool.  If the bag
    argument is supplied.  The new table is added to the bag for later
    cleanup.  The input tables are not removed from the bag.  This must be
    done by the caller, if appropriate.

Arguments:

    AutomationTableAB -
        Contains a pointer to the location at which a pointer to the merged
        table will be deposited.  Table A is the dominant table.  Any
        duplicate entries will appear as they do in the A table.

    AutomationTableA -
        Contains a pointer to one of the tables to be merged.  This is the
        dominant table, so any duplicated entries will be copied from this
        table.

    AutomationTableB -
        Contains a pointer to one of the tables to be merged.  This is the
        recessive table, so any duplicated entries will be overridden by
        the entry from the other table.

    Bag -
        Contains an optional object bag to which the new table should be added.

Return Value:

    STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES.

--*/

{
    //
    // This point to the non-Null table when exact one is NULL.
    //
    PKSAUTOMATION_TABLE pSourceAutomationTable=NULL; 
    
    _DbgPrintF(DEBUGLVL_BLAB,("[KsMergeAutomationTables]"));

    PAGED_CODE();

    ASSERT(AutomationTableAB);

    ULONG propertySetsCount;
    ULONG propertyItemsCount;
    ULONG propertyItemsSize;
    ULONG methodSetsCount;
    ULONG methodItemsCount;
    ULONG methodItemsSize;
    ULONG eventSetsCount;
    ULONG eventItemsCount;
    ULONG eventItemsSize;

    if ( AutomationTableA == NULL && AutomationTableB == NULL ) {
        *AutomationTableAB = NULL;
        return STATUS_SUCCESS;
    }
    
    if ( AutomationTableA != NULL && AutomationTableB != NULL ) {
        //
        // Figure out how many property sets and items there will be.
        //
        KspCountSetsAndItems(
            PKSPAUTOMATION_TYPE(&AutomationTableA->PropertySetsCount),
            PKSPAUTOMATION_TYPE(&AutomationTableB->PropertySetsCount),
            sizeof(KSPROPERTY_SET),
            &propertySetsCount,
            &propertyItemsCount,
            &propertyItemsSize);

        //
        // Figure out how many method sets and items there will be.
        //
        KspCountSetsAndItems(
            PKSPAUTOMATION_TYPE(&AutomationTableA->MethodSetsCount),
            PKSPAUTOMATION_TYPE(&AutomationTableB->MethodSetsCount),
            sizeof(KSMETHOD_SET),
            &methodSetsCount,
            &methodItemsCount,
            &methodItemsSize);

        //
        // Figure out how many events sets and items there will be.
        //
        KspCountSetsAndItems(
            PKSPAUTOMATION_TYPE(&AutomationTableA->EventSetsCount),
            PKSPAUTOMATION_TYPE(&AutomationTableB->EventSetsCount),
            sizeof(KSEVENT_SET),
            &eventSetsCount,
            &eventItemsCount,
            &eventItemsSize);
    } else {
        //
        // Either TableA or TableB is NULL, but not both
        //
        if ( AutomationTableA != NULL ) {
            pSourceAutomationTable = AutomationTableA;
        } else {
            pSourceAutomationTable = AutomationTableB;
        }
        ASSERT( pSourceAutomationTable != NULL );

        propertySetsCount = pSourceAutomationTable->PropertySetsCount;
        propertyItemsSize = pSourceAutomationTable->PropertyItemSize;
        propertyItemsCount = 0;
        
        PKSPAUTOMATION_SET setS = 
            PKSPAUTOMATION_SET(pSourceAutomationTable->PropertySets);

        for (ULONG count = propertySetsCount;
            count--;
            setS = PKSPAUTOMATION_SET(PUCHAR(setS) + sizeof(KSPROPERTY_SET))) {

            propertyItemsCount += setS->ItemsCount;

        }
          
        methodSetsCount = pSourceAutomationTable->MethodSetsCount;
        methodItemsSize = pSourceAutomationTable->MethodItemSize;
        methodItemsCount = 0;

        setS = PKSPAUTOMATION_SET(pSourceAutomationTable->MethodSets);
        for (ULONG count = methodSetsCount;
            count--;
            setS = PKSPAUTOMATION_SET(PUCHAR(setS) + sizeof(KSMETHOD_SET))) {

            methodItemsCount += setS->ItemsCount;

        }
        
        eventSetsCount = pSourceAutomationTable->EventSetsCount;
        eventItemsSize = pSourceAutomationTable->EventItemSize;
        eventItemsCount = 0;
        
        setS = PKSPAUTOMATION_SET(pSourceAutomationTable->EventSets);
        for (ULONG count = eventSetsCount;
            count--;
            setS = PKSPAUTOMATION_SET(PUCHAR(setS) + sizeof(KSEVENT_SET))) {

            eventItemsCount += setS->ItemsCount;

        }
    }

    //
    // Calculate the total size.
    //
    ULONG size = 
        sizeof(KSAUTOMATION_TABLE) +
        (propertySetsCount * sizeof(KSPROPERTY_SET)) +
        (propertyItemsCount * propertyItemsSize) +
        (methodSetsCount * sizeof(KSMETHOD_SET)) +
        (methodItemsCount * methodItemsSize) +
        (eventSetsCount * sizeof(KSEVENT_SET)) +
        (eventItemsCount * eventItemsSize);

    //
    // Allocate the required memory (paged is fine for everything but event
    // sets).  The event entries point into the automation table.  The remove
    // handler is passed this and is called with spinlocks held.  The event
    // information must not be paged!
    //
    PVOID destination = ExAllocatePoolWithTag(PagedPool,size,POOLTAG_AUTOMATION);

    NTSTATUS status;
    if (destination) {
        if (Bag) {
            status = KsAddItemToObjectBag(Bag,destination,NULL);
            if (! NT_SUCCESS(status)) {
                ExFreePool(destination);
            }
        } else {
            status = STATUS_SUCCESS;
        }
    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (NT_SUCCESS(status)) {
        //
        // Initialize the table.
        //
        RtlZeroMemory(destination,size);

        PKSAUTOMATION_TABLE automationTable = PKSAUTOMATION_TABLE(destination);
        *AutomationTableAB = automationTable;
        destination = PVOID(automationTable + 1);

        automationTable->PropertySetsCount = propertySetsCount;
        automationTable->PropertyItemSize = propertyItemsSize;
        automationTable->MethodSetsCount = methodSetsCount;
        automationTable->MethodItemSize = methodItemsSize;
        automationTable->EventSetsCount = eventSetsCount;
        automationTable->EventItemSize = eventItemsSize;

        if ( pSourceAutomationTable == NULL ) {
            //
            // both tableA and tableB are non-NULL, do the merge
            //
            //
            // Deposit the property tables.
            //
            KspMergeAutomationTypes(
                PKSPAUTOMATION_TYPE(&AutomationTableA->PropertySetsCount),
                PKSPAUTOMATION_TYPE(&AutomationTableB->PropertySetsCount),
                PKSPAUTOMATION_TYPE(&automationTable->PropertySetsCount),
                sizeof(KSPROPERTY_SET),
                &destination);

            //
            // Deposit the method tables.
            //
            KspMergeAutomationTypes(
                PKSPAUTOMATION_TYPE(&AutomationTableA->MethodSetsCount),
                PKSPAUTOMATION_TYPE(&AutomationTableB->MethodSetsCount),
                PKSPAUTOMATION_TYPE(&automationTable->MethodSetsCount),
                sizeof(KSMETHOD_SET),
                &destination);

            //
            // Deposit the event tables.
            //
            KspMergeAutomationTypes(
                PKSPAUTOMATION_TYPE(&AutomationTableA->EventSetsCount),
                PKSPAUTOMATION_TYPE(&AutomationTableB->EventSetsCount),
                PKSPAUTOMATION_TYPE(&automationTable->EventSetsCount),
                sizeof(KSEVENT_SET),
                &destination);

        } else {
            //
            // No merge, just copy, pSourceAutomationTable != NULL
            //
            KspCopyAutomationType(
                PKSPAUTOMATION_TYPE(&pSourceAutomationTable->PropertySetsCount),
                PKSPAUTOMATION_TYPE(&automationTable->PropertySetsCount),
                sizeof(KSPROPERTY_SET),
                &destination);

            KspCopyAutomationType(
                PKSPAUTOMATION_TYPE(&pSourceAutomationTable->MethodSetsCount),
                PKSPAUTOMATION_TYPE(&automationTable->MethodSetsCount),
                sizeof(KSMETHOD_SET),
                &destination);

            KspCopyAutomationType(
                PKSPAUTOMATION_TYPE(&pSourceAutomationTable->EventSetsCount),
                PKSPAUTOMATION_TYPE(&automationTable->EventSetsCount),
                sizeof(KSEVENT_SET),
                &destination);

        }

        //
        // We should have used exactly the calculated size.
        //
        ASSERT(ULONG(PUCHAR(destination) - PUCHAR(automationTable)) == size);

        //
        // Remove the source tables from the bag.  This does nothing if they
        // aren't in the bag.
        //
        if (Bag) {
            if (AutomationTableA) {
                KsRemoveItemFromObjectBag(Bag,AutomationTableA,TRUE);
            }
            if (AutomationTableB) {
                KsRemoveItemFromObjectBag(Bag,AutomationTableB,TRUE);
            }
        }
    }

    return status;
}


NTSTATUS
KspHandleAutomationIoControl(
    IN PIRP Irp,
    IN const KSAUTOMATION_TABLE* AutomationTable OPTIONAL,
    IN PLIST_ENTRY EventList OPTIONAL,
    IN PKSPIN_LOCK EventListLock OPTIONAL,
    IN const KSAUTOMATION_TABLE*const* NodeAutomationTables OPTIONAL,
    IN ULONG NodesCount
    )

/*++

Routine Description:

    This routine handles automation IOCTLs using an automation table.  It is
    supplied for clients that are dispatching IOCTLs themselves.  Clients using
    the KS-implemented objects do not need to call this function.

Arguments:

    Irp -
        Contains a pointer to the request to be handled.

    AutomationTable -
        Contains an optional pointer to the automation table to be used to
        handle the IRP.  If this argument is NULL, this function always returns
        STATUS_NOT_FOUND.

    EventList -
        Contains an optional pointer to a list of events from which disabled 
        events are to be removed.

    EventListLock -
        Contains an optional pointer to a spin lock used for synchronizing
        access to the event list.  This argument should be supplied if and
        only if EventList is supplied.

    NodeAutomationTables -
        Optional table of automation tables for nodes.

    NodesCount -
        Count of nodes.

Return Value:

    Status.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsHandleAutomationIoControl]"));

    PAGED_CODE();

    ASSERT(Irp);
    ASSERT((EventList == NULL) == (EventListLock == NULL));

    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

    NTSTATUS status = STATUS_NOT_FOUND;
    switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {
    case IOCTL_KS_PROPERTY:
        _DbgPrintF(DEBUGLVL_BLAB,("[KsHandleAutomationIoControl] IOCTL_KS_PROPERTY"));

        if ((AutomationTable &&
            AutomationTable->PropertySetsCount) ||
            (NodesCount && NodeAutomationTables)) {
            status =
                KspPropertyHandler(
                    Irp,
                    AutomationTable ? AutomationTable->PropertySetsCount : 0,
                    AutomationTable ? AutomationTable->PropertySets : NULL,
                    NULL,
                    AutomationTable ? AutomationTable->PropertyItemSize : 0,
                    NodeAutomationTables,
                    NodesCount);
        }
        break;

    case IOCTL_KS_METHOD:
        _DbgPrintF(DEBUGLVL_BLAB,("[KsHandleAutomationIoControl] IOCTL_KS_METHOD"));

        if ((AutomationTable &&
            AutomationTable->MethodSetsCount) ||
            (NodesCount && NodeAutomationTables)) {
            status =
                KspMethodHandler(
                    Irp,
                    AutomationTable ? AutomationTable->MethodSetsCount : 0,
                    AutomationTable ? AutomationTable->MethodSets : NULL,
                    NULL,
                    AutomationTable ? AutomationTable->MethodItemSize : 0,
                    NodeAutomationTables,
                    NodesCount);
        }
        break;

    case IOCTL_KS_ENABLE_EVENT:
        _DbgPrintF(DEBUGLVL_BLAB,("[KsHandleAutomationIoControl] IOCTL_KS_ENABLE_EVENT"));

        if ((AutomationTable &&
            AutomationTable->EventSetsCount) ||
            (NodesCount && NodeAutomationTables)) {
            status =
                KspEnableEvent(
                    Irp,
                    AutomationTable ? AutomationTable->EventSetsCount : 0,
                    AutomationTable ? AutomationTable->EventSets : NULL,
                    EventList,
                    KSEVENTS_SPINLOCK,
                    EventListLock,
                    NULL,
                    AutomationTable ? AutomationTable->EventItemSize : 0,
                    NodeAutomationTables,
                    NodesCount,
                    TRUE);
        }
        break;

    case IOCTL_KS_DISABLE_EVENT:
        _DbgPrintF(DEBUGLVL_BLAB,("[KsHandleAutomationIoControl] IOCTL_KS_DISABLE_EVENT"));

        if (EventList &&
            ((AutomationTable &&
            AutomationTable->EventSetsCount) ||
            (NodesCount && NodeAutomationTables))) {
            status =
                KsDisableEvent(
                    Irp,
                    EventList,
                    KSEVENTS_SPINLOCK,
                    EventListLock);
        }
        break;

    default:
        _DbgPrintF(DEBUGLVL_BLAB,("[KsHandleAutomationIoControl] UNKNOWN IOCTL %d",irpSp->Parameters.DeviceIoControl.IoControlCode));
        status = STATUS_INVALID_DEVICE_REQUEST;
    }

    return status;
}


NTSTATUS
KspCreateAutomationTableTable(
    OUT PKSAUTOMATION_TABLE ** AutomationTableTable,
    IN ULONG DescriptorCount,
    IN ULONG DescriptorSize,
    IN const KSAUTOMATION_TABLE*const* DescriptorAutomationTables,
    IN const KSAUTOMATION_TABLE* BaseAutomationTable OPTIONAL,
    IN KSOBJECT_BAG Bag
    )

/*++

Routine Description:

    This routine creates a table of automation tables from an array of 
    descriptors.  Shared descriptors result in shared tables.

Arguments:

    AutomationTableTable -
        Contains a pointer to the location at which a pointer to the new table
        of automation tables will be deposited.  The table itself (an array of
        PKSAUTOMATION_TABLE) is allocated from paged pool, as is each new
        automation table that is created.  If no BaseAutomationTable argument
        is supplied, the automation tables from DescriptorAutomationTables will
        be referenced from the table of tables, and no new automation tables
        will be allocated.  All the allocated items are added to the object bag
        if it is supplied.

    DescriptorCount -
        Contains the number of descriptor structures in the array referenced by
        the DescriptorAutomationTables argument.

    DescriptorSize -
        Contains the size in bytes of each descriptor in the array referenced
        by the DescriptorAutomationTables argument.  This is used as a 'stride'
        to find automation table pointers in the array.

    DescriptorAutomationTables -
        Contains a pointer to the automation table pointer in the first
        descriptor in an array of descriptors.  The addresses of subsequent
        automation table pointers in the descriptor array are generated by
        iteratively adding the descriptor size.

    BaseAutomationTable -
        Contains an optional pointer to an automation table that is to be
        merged with each table from the descriptor array.

    Bag -
        Contains an optional pointer to an object bag to which all allocated
        items will be added.

Return Value:

    Status.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KspCreateAutomationTableTable]"));

    PAGED_CODE();

    ASSERT(AutomationTableTable);
    ASSERT(DescriptorAutomationTables);
    ASSERT(Bag);

    //
    // Allocate memory for automation table pointers.
    //
    *AutomationTableTable = (PKSAUTOMATION_TABLE *)
        ExAllocatePoolWithTag(
            PagedPool,
            sizeof(PKSAUTOMATION_TABLE) * DescriptorCount,
            POOLTAG_AUTOMATIONTABLETABLE);

    //
    // Initialize the automation tables.
    //
    NTSTATUS status = STATUS_SUCCESS;
    if (*AutomationTableTable) {
        status = KsAddItemToObjectBag(Bag,*AutomationTableTable,NULL);
    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (NT_SUCCESS(status)) {
        //
        // Zero it first so the cleanup is not confused.
        //
        RtlZeroMemory(
            *AutomationTableTable,
            sizeof(PKSAUTOMATION_TABLE) * DescriptorCount);

        //
        // Generate the automation table for each descriptor.
        //
        PKSAUTOMATION_TABLE * table = *AutomationTableTable;
        const KSAUTOMATION_TABLE *const* descriptorTable =
            DescriptorAutomationTables;
        for (ULONG count = DescriptorCount;
             count--;
             table++,
             descriptorTable = (PKSAUTOMATION_TABLE *)
                (PUCHAR(descriptorTable) + DescriptorSize)) {
            if (*descriptorTable) {
                //
                // Look for previous descriptor with the same table.
                //
                PKSAUTOMATION_TABLE *tableMatch = 
                    *AutomationTableTable;
                const KSAUTOMATION_TABLE *const* descriptorTableMatch =
                    DescriptorAutomationTables;
                for (;
                     descriptorTableMatch != descriptorTable;
                     tableMatch++,
                     descriptorTableMatch = (PKSAUTOMATION_TABLE *)
                        (PUCHAR(descriptorTableMatch) + DescriptorSize)) {
                    if (*descriptorTableMatch == *descriptorTable) {
                        break;
                    }
                }

                if (descriptorTableMatch != descriptorTable) {
                    //
                    // Match found...reuse the automation table.
                    //
                    *table = *tableMatch;
                } else {
                    //
                    // No match found.
                    //
                    if (BaseAutomationTable) {
                        //
                        // Merge with the base table.
                        //
                        status =
                            KsMergeAutomationTables(
                                table,
                                const_cast<PKSAUTOMATION_TABLE>(*descriptorTable),
                                const_cast<PKSAUTOMATION_TABLE>(BaseAutomationTable),
                                Bag);
                    } else {
                        //
                        // No base table...use the descriptor's.
                        //
                        *table = const_cast<PKSAUTOMATION_TABLE>(*descriptorTable);
                    }

                    if (! NT_SUCCESS(status)) {
                        break;
                    }
                }
            } else {
                //
                // Null table in the descriptor...just use the base table.
                //
                *table = PKSAUTOMATION_TABLE(BaseAutomationTable);
            }
        }

        if (! NT_SUCCESS(status)) {
            *AutomationTableTable = NULL;
        }
    } else {
        //
        // Come to this path possibly due to allocation failure. Chech before freeing.
        //
        if ( *AutomationTableTable ) {
            ExFreePool(*AutomationTableTable);
            *AutomationTableTable = NULL;
        }
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\ks\clock.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    clock.c

Abstract:

    This module contains the helper functions for clocks.

--*/

#include "ksp.h"
#include <limits.h>

#ifndef _WIN64
#ifdef ExInterlockedCompareExchange64
#undef ExInterlockedCompareExchange64
NTKERNELAPI
LONGLONG
FASTCALL
ExInterlockedCompareExchange64 (
    IN PLONGLONG Destination,
    IN PLONGLONG Exchange,
    IN PLONGLONG Comperand,
    IN PKSPIN_LOCK Lock
    );
#endif
#endif


#define KSSIGNATURE_DEFAULT_CLOCK 'cdSK'
#define KSSIGNATURE_DEFAULT_CLOCKINST 'icSK'

NTSTATUS
DefClockIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
NTSTATUS
DefClockClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
NTSTATUS
DefPowerDispatch(
    IN PKSIDEFAULTCLOCK DefaultClock,
    IN PIRP Irp
    );

#ifdef ALLOC_PRAGMA
#if 0
#pragma alloc_text(PAGE, KsiFastPropertyDefaultClockGetTime)
#pragma alloc_text(PAGE, KsiFastPropertyDefaultClockGetPhysicalTime)
#pragma alloc_text(PAGE, KsiFastPropertyDefaultClockGetCorrelatedTime)
#pragma alloc_text(PAGE, KsiFastPropertyDefaultClockGetCorrelatedPhysicalTime)
#endif
#pragma alloc_text(PAGE, KsiPropertyDefaultClockGetTime)
#pragma alloc_text(PAGE, KsiPropertyDefaultClockGetPhysicalTime)
#pragma alloc_text(PAGE, KsiPropertyDefaultClockGetCorrelatedTime)
#pragma alloc_text(PAGE, KsiPropertyDefaultClockGetCorrelatedPhysicalTime)
#pragma alloc_text(PAGE, KsiPropertyDefaultClockGetResolution)
#pragma alloc_text(PAGE, KsiPropertyDefaultClockGetState)
#pragma alloc_text(PAGE, KsiPropertyDefaultClockGetFunctionTable)
#pragma alloc_text(PAGE, KsCreateClock)
#pragma alloc_text(PAGE, KsValidateClockCreateRequest)
#pragma alloc_text(PAGE, KsAllocateDefaultClockEx)
#pragma alloc_text(PAGE, KsAllocateDefaultClock)
#pragma alloc_text(PAGE, KsFreeDefaultClock)
#pragma alloc_text(PAGE, KsCreateDefaultClock)
#pragma alloc_text(PAGE, DefClockIoControl)
#pragma alloc_text(PAGE, DefClockClose)
#pragma alloc_text(PAGE, DefPowerDispatch)
#endif // ALLOC_PRAGMA

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA
static const WCHAR ClockString[] = KSSTRING_Clock;

static DEFINE_KSDISPATCH_TABLE(
    DefClockDispatchTable,
    DefClockIoControl,
    KsDispatchInvalidDeviceRequest,
    KsDispatchInvalidDeviceRequest,
    KsDispatchInvalidDeviceRequest,
    DefClockClose,
    KsDispatchQuerySecurity,
    KsDispatchSetSecurity,
    KsDispatchFastIoDeviceControlFailure,
    KsDispatchFastReadFailure,
    KsDispatchFastWriteFailure);

static DEFINE_KSPROPERTY_CLOCKSET(
    DefClockPropertyItems,
    KsiPropertyDefaultClockGetTime,
    KsiPropertyDefaultClockGetPhysicalTime,
    KsiPropertyDefaultClockGetCorrelatedTime,
    KsiPropertyDefaultClockGetCorrelatedPhysicalTime,
    KsiPropertyDefaultClockGetResolution,
    KsiPropertyDefaultClockGetState,
    KsiPropertyDefaultClockGetFunctionTable);

#if 0
static DEFINE_KSPROPERTY_TABLE(DefClockFastPropertyItems) {
    DEFINE_KSFASTPROPERTY_ITEM(
        KSPROPERTY_CLOCK_TIME,
        KsiFastPropertyDefaultClockGetTime,
        NULL
    ),
    DEFINE_KSFASTPROPERTY_ITEM(
        KSPROPERTY_CLOCK_PHYSICALTIME,
        KsiFastPropertyDefaultClockGetPhysicalTime,
        NULL
    ),
    DEFINE_KSFASTPROPERTY_ITEM(
        KSPROPERTY_CLOCK_CORRELATEDTIME,
        KsiFastPropertyDefaultClockGetCorrelatedTime,
        NULL
    ),
    DEFINE_KSFASTPROPERTY_ITEM(
        KSPROPERTY_CLOCK_CORRELATEDPHYSICALTIME,
        KsiFastPropertyDefaultClockGetCorrelatedPhysicalTime,
        NULL
    )
};
#endif

static DEFINE_KSPROPERTY_SET_TABLE(DefClockPropertySets) {
#if 0
    DEFINE_KSPROPERTY_SET(
        &KSPROPSETID_Clock,
        SIZEOF_ARRAY(DefClockPropertyItems),
        DefClockPropertyItems,
        SIZEOF_ARRAY(DefClockFastPropertyItems),
        DefClockFastPropertyItems
    )
#else
    DEFINE_KSPROPERTY_SET(
        &KSPROPSETID_Clock,
        SIZEOF_ARRAY(DefClockPropertyItems),
        DefClockPropertyItems,
        0, NULL
    )
#endif
};

static DEFINE_KSEVENT_TABLE(DefClockEventItems) {
    DEFINE_KSEVENT_ITEM(
        KSEVENT_CLOCK_INTERVAL_MARK,
        sizeof(KSEVENT_TIME_INTERVAL),
        sizeof(KSINTERVAL),
        (PFNKSADDEVENT)KsiDefaultClockAddMarkEvent,
        NULL,
        NULL),
    DEFINE_KSEVENT_ITEM(
        KSEVENT_CLOCK_POSITION_MARK,
        sizeof(KSEVENT_TIME_MARK),
        sizeof(LONGLONG),
        (PFNKSADDEVENT)KsiDefaultClockAddMarkEvent,
        NULL,
        NULL)
};

static DEFINE_KSEVENT_SET_TABLE(DefClockEventSets) {
    DEFINE_KSEVENT_SET(
        &KSEVENTSETID_Clock,
        SIZEOF_ARRAY(DefClockEventItems),
        DefClockEventItems
    )
};
#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif // ALLOC_DATA_PRAGMA


VOID
DefClockKillTimer(
    IN PKSIDEFAULTCLOCK DefaultClock,
    IN BOOL ForceCancel
    )
/*++

Routine Description:

    Cancels the current timer if no outstanding events are on the notification
    list. Takes into account the possibility of new events being enabled as
    this timer is being disabled.

    This may only be called at PASSIVE_LEVEL.

Arguments:

    DefaultClock -
        Contains the default clock structure with the timer to cancel.

    ForceCancel -
        Indicates that the timer should be canceled even if events remain
        on the list.

Return Value:

    Nothing.

--*/
{
    KIRQL Irql;

    //
    // Lock the event list to so that its contents can be checked. This
    // function assumes that any entries left on the list must belong to
    // some other instance of the clock. So an empty list means that no
    // timer should be running, but if anything is in the list, then there
    // must be another client, and the timer should be left.
    //
    KeAcquireSpinLock(&DefaultClock->EventQueueLock, &Irql);
    if (ForceCancel || IsListEmpty(&DefaultClock->EventQueue)) {
        if (DefaultClock->CancelTimer) {
            if (DefaultClock->CancelTimer(DefaultClock->Context, &DefaultClock->QueueTimer)) {
                //
                // This does not need to be an interlocked operation, because
                // all access is protected by the shared queue lock.
                //
                DefaultClock->ReferenceCount--;
            }
        } else if (KeCancelTimer(&DefaultClock->QueueTimer)) {
            DefaultClock->ReferenceCount--;
        }
    }
    KeReleaseSpinLock(&DefaultClock->EventQueueLock, Irql);
}


VOID
DefResetTimer(
    IN PKSIDEFAULTCLOCK DefaultClock,
    IN LONGLONG CurrentTime,
    IN LONGLONG NextTimeDelta
    )
/*++

Routine Description:

    Cancels the current timer and inserts a new one. Does not wait for any
    current timer Dpc to complete. Assumes that the queue lock has been taken
    so that canceling and queuing does not overlap, so it does not have to
    wait for any Dpc.

Arguments:

    DefaultClock -
        Contains an initialize Default Clock structure which is shared amongst
        any instance of the default clock for the parent.

    CurrentTime -
        Contains the current time off which the delta is based. This is used
        to store the LastDueTime.

    NextTimeDelta -
        Specifies the next delta at which the shared timer should fire. This
        must be a delta rather than an absolute value since Ke rounds absolute
        values to the previous SystemTime, and absolute times are fixed to the
        clock, which can be changed.

Return Value:

    Nothing.

--*/
{
    if (DefaultClock->CancelTimer) {
        //
        // Use the external timing service.
        //
        if (DefaultClock->CancelTimer(
            DefaultClock->Context,
            &DefaultClock->QueueTimer)) {
            //
            // The current timer was able to be canceled before it went off,
            // so decrement the reference count which would have normally been
            // decremented by the timer code. Since the function must be called
            // with the queue lock, this access is protected.
            //
            DefaultClock->ReferenceCount--;
        }
        //
        // Since the queue lock is taken, there is no need to increment the
        // reference count first, then decrement on a possible failure to
        // add the timer. This is because the only thing which would be checking
        // the reference count and cause an adverse affect is in the Dpc, which
        // also must have the queue lock when decrementing the reference count,
        // or KsFreeDefaultClock, which would not be called when an instance of
        // a clock is still outstanding. Since this code is executing, obviously
        // there is an outstanding instance of the clock.
        //
        if (!DefaultClock->SetTimer(
            DefaultClock->Context,
            &DefaultClock->QueueTimer,
            *(PLARGE_INTEGER)&NextTimeDelta,
            &DefaultClock->QueueDpc)) {
            //
            // The delta is negative. This value is used when determining if
            // a new timer should be set when an event is added.
            //
            DefaultClock->LastDueTime = CurrentTime - NextTimeDelta;
            DefaultClock->ReferenceCount++;
        } else {
            //
            // Adding the timer failed, so at least indicate that no Dpc is
            // outstanding.
            //
            DefaultClock->LastDueTime = 0;
        }
    } else {
        //
        // Use the built in timer services. The process is the same, just
        // the function parameters are altered. See comments above.
        //
        if (KeCancelTimer(&DefaultClock->QueueTimer)) {
            DefaultClock->ReferenceCount--;
        }
        if (!KeSetTimerEx(&DefaultClock->QueueTimer,
            *(PLARGE_INTEGER)&NextTimeDelta,
            0,
            &DefaultClock->QueueDpc)) {
            DefaultClock->LastDueTime = CurrentTime - NextTimeDelta;
            DefaultClock->ReferenceCount++;
        } else {
            DefaultClock->LastDueTime = 0;
        }
    }
}


LONGLONG
FASTCALL
QueryExternalTimeSynchronized(
    IN PKSIDEFAULTCLOCK DefaultClock,
    OUT LONGLONG* PhysicalTime
    )
/*++

Routine Description:

    Queries the external time source, if it is still present, for the
    current correlated presentation and physical time. If the function
    is no longer available, returns zero. Assumes that the caller has
    already checked the KSIDEFAULTCLOCK.ExternalTimeValid structure
    element to ensure that the function should be used if still present.
    Freeing the clock by the owner invalidates this function, and is
    synchronized with this routine.

Arguments:

    DefaultClock -
        Contains the default clock shared structure which references the
        time function.

    PhysicalTime -
        The place in which to put the physical time.

Return Value:

    Returns the current presentation time.

--*/
{
    LONGLONG PresentationTime;

    //
    // Synchronize with possible freeing of the clock by the owner.
    // As soon as this value is incremented, if the KsFreeDefaultClock
    // routine has not removed any external clock, it will wait, unless
    // this routine gets out of the query before the free routine
    // decrements the reference count.
    //
    InterlockedIncrement(&DefaultClock->ExternalTimeReferenceCount);
    //
    // If the free routine is definitely trying to free the clock, do not
    // reference the external time routine.
    //
    if (DefaultClock->ExternalTimeValid) {
        PresentationTime = DefaultClock->CorrelatedTime(
            DefaultClock->Context,
            PhysicalTime);

    } else {
        *PhysicalTime = 0;
        PresentationTime = 0;
    }
    //
    // If the free routine decremented the count first, it is waiting
    // for the last caller which may have passed the above FREEING_CLOCK
    // conditional to exit this routine. It is waiting for this event to
    // be signalled so that it can return to the caller.
    //
    if (!InterlockedDecrement(&DefaultClock->ExternalTimeReferenceCount)) {
        //
        // Later callers will also signal this event, but there won't
        // be any thread waiting on it, and it will not matter.
        //
        KeSetEvent(&DefaultClock->FreeEvent, IO_NO_INCREMENT, FALSE);
    }
    return PresentationTime;
}


LONGLONG
FASTCALL
DefGetTime(
    IN PFILE_OBJECT FileObject
    )
/*++

Routine Description:

    The underlying function to actually retrieve the current time on the
    default clock. This is called by both the Get Time property, and as the
    direct function call table entry. It determines the state of the clock and
    returns the time based on the state. If the clock is not running, it returns
    the last position the clock was in before it was stopped. Else it returns
    the current position.

    The function assumes that the ClockInst->DefaultClock->LastRunningTime is
    updated before changing the clock state. So even if the clock's state were
    to change in the middle of the call, the time returned would be fairly
    accurate.

Arguments:

    FileObject -
        Contains the file object which was created for this instance of the
        clock.

Return Value:

    Returns the current logical time in 100-nanosecond units.

--*/
{
    ULONGLONG Zero;
    PKSCLOCKINSTANCE ClockInst;

    ClockInst = (PKSCLOCKINSTANCE)FileObject->FsContext;
    if (ClockInst->DefaultClock->CorrelatedTime) {
        LONGLONG PhysicalTime;

        //
        // Current time, no matter what the state, is completely dependent
        // on the external function in this case.
        //
        return QueryExternalTimeSynchronized(
            ClockInst->DefaultClock,
            &PhysicalTime);
    }
    //
    // This is used in the compare/exchange, and represents both the value to
    // compare against, and the exchange value. This means that if the compare
    // succeeds, the value exchanged will be the exact same value that is
    // already present, and therefore no actual value change will occur. That
    // is the point, since the compare/exchange is only being used to extract
    // the current value in an interlocked manner, not to actually change it.
    //
    Zero = 0;
    //
    // It is assumed that reading a ULONG value can be done without interlocking.
    //
    switch (ClockInst->DefaultClock->State) {
        LARGE_INTEGER PerformanceTime;

    //case KSSTATE_STOP:
    //case KSSTATE_ACQUIRE:
    //case KSSTATE_PAUSE:
    default:
        //
        // Get the last running clock value. The last running time already has
        // been adjusted for clock frequency. Does not matter if the exchange
        // succeeds or fails, just the result. If the compare happens to succeed,
        // then the value is just replaced with the same value, so no change is
        // actually made.
        //
        return ExInterlockedCompareExchange64(
            (PULONGLONG)&ClockInst->DefaultClock->LastRunningTime,
            &Zero,
            &Zero,
            &ClockInst->DefaultClock->TimeAccessLock);

    case KSSTATE_RUN:
        //
        // Get the current performance time, and subtract the current delta to
        // return the real clock time. Does not matter if the exchange succeeds
        // or fails, just the result. If the compare happens to succeed, then
        // the value is just replaced with the same value, so no change is
        // actually made.
        //
        PerformanceTime = KeQueryPerformanceCounter(NULL);
        return KSCONVERT_PERFORMANCE_TIME(ClockInst->DefaultClock->Frequency, PerformanceTime) -
            ExInterlockedCompareExchange64(
                (PULONGLONG)&ClockInst->DefaultClock->RunningTimeDelta,
                &Zero,
                &Zero,
                &ClockInst->DefaultClock->TimeAccessLock);

    }
}


LONGLONG
FASTCALL
DefGetPhysicalTime(
    IN PFILE_OBJECT FileObject
    )
/*++

Routine Description:

    The underlying function to actually retrieve the current physical time on
    the default clock. This is called by both the Get Physical Time property,
    and as the direct function call table entry. It just returns the current
    system time minus any suspended time delta.

Arguments:

    FileObject -
        Contains the file object which was created for this instance of the
        clock.

Return Value:

    Returns the current physical time in 100-nanosecond units.

--*/
{
    PKSCLOCKINSTANCE ClockInst;
    LARGE_INTEGER PerformanceTime;

    ClockInst = (PKSCLOCKINSTANCE)FileObject->FsContext;
    if (ClockInst->DefaultClock->CorrelatedTime) {
        QueryExternalTimeSynchronized(
            ClockInst->DefaultClock,
            &PerformanceTime.QuadPart);
        return PerformanceTime.QuadPart;
    }
    PerformanceTime = KeQueryPerformanceCounter(NULL);
    return KSCONVERT_PERFORMANCE_TIME(ClockInst->DefaultClock->Frequency, PerformanceTime) - ClockInst->DefaultClock->SuspendDelta;
}


LONGLONG
FASTCALL
DefGetCorrelatedTime(
    IN PFILE_OBJECT FileObject,
    OUT PLONGLONG SystemTime
    )
/*++

Routine Description:

    The underlying function to actually retrieve the current time on the
    default clock along with the correlated time as an atomic operation. This
    is called by both the Get Correlated Time property, and as the direct
    function call table entry.

Arguments:

    FileObject -
        Contains the file object which was created for this instance of the
        clock.

    SystemTime -
        The place in which to put the correlated system time in 100ns units.

Return Value:

    Returns the current time in 100-nanosecond units.

--*/
{
    ULONGLONG Zero;
    LARGE_INTEGER PerformanceTime;
    PKSCLOCKINSTANCE ClockInst;
    LONGLONG StreamTime;

    ClockInst = (PKSCLOCKINSTANCE)FileObject->FsContext;
    PerformanceTime = KeQueryPerformanceCounter(NULL);

    if (ClockInst->DefaultClock->CorrelatedTime) {
        LONGLONG PresentationTime;
        LONGLONG PhysicalTime;

        //
        // Current time, no matter what the state, is completely dependent
        // on the external function in this case.
        //
        PresentationTime = QueryExternalTimeSynchronized(
            ClockInst->DefaultClock,
            &PhysicalTime);
        *SystemTime = KSCONVERT_PERFORMANCE_TIME(ClockInst->DefaultClock->Frequency, PerformanceTime);
        return PresentationTime;
    }
    Zero = 0;
    *SystemTime = KSCONVERT_PERFORMANCE_TIME(ClockInst->DefaultClock->Frequency, PerformanceTime);
    //
    // It is assumed that reading a ULONG value can be done without interlocking.
    //
    switch (ClockInst->DefaultClock->State) {

    //case KSSTATE_STOP:
    //case KSSTATE_ACQUIRE:
    //case KSSTATE_PAUSE:
    default:
        //
        // If the state was recently changed, this will still return a very
        // close number. Since this query is only made in a non-running
        // situation, it's accuracy does not matter as much.
        //
        return ExInterlockedCompareExchange64(
            (PULONGLONG)&ClockInst->DefaultClock->LastRunningTime,
            &Zero,
            &Zero,
            &ClockInst->DefaultClock->TimeAccessLock);

    case KSSTATE_RUN:
        //
        // Else return a number based on the previous clock time so that they
        // are exactly correlated.
        //

        // Prevent time from going backwards as seen by clients
        // This could be prevented if SetTime from user mode via ksclockf used CORRELATED time

        StreamTime = *SystemTime - ExInterlockedCompareExchange64(
                                      (PULONGLONG)&ClockInst->DefaultClock->RunningTimeDelta,
                                      &Zero,
                                      &Zero,
                                      &ClockInst->DefaultClock->TimeAccessLock);

        if (StreamTime <= ClockInst->DefaultClock->LastStreamTime) {
#ifdef CREATE_A_FLURRY_OF_TIMING_SPEW
           DbgPrint( "KsClock: TIME REGRESSED  LastStreamTime=%10I64d, StreamTime=%10I64d!!!\n",
                     ClockInst->DefaultClock->LastStreamTime,
                     StreamTime);
#endif
           StreamTime = ClockInst->DefaultClock->LastStreamTime + 1;
        }

        ExInterlockedCompareExchange64(
            (PULONGLONG)&ClockInst->DefaultClock->LastStreamTime,
            (PULONGLONG)&StreamTime,
            (PULONGLONG)&ClockInst->DefaultClock->LastStreamTime,
            &ClockInst->DefaultClock->TimeAccessLock);

        return StreamTime;

    }

}


LONGLONG
FASTCALL
DefGetCorrelatedPhysicalTime(
    IN PFILE_OBJECT FileObject,
    OUT PLONGLONG SystemTime
    )
/*++

Routine Description:

    The underlying function to actually retrieve the current physical time on
    the default clock along with the correlated time as an atomic operation.
    This is called by both the Get Correlated Physical Time property, and as
    the direct function call table entry.

Arguments:

    FileObject -
        Contains the file object which was created for this instance of the
        clock.

    SystemTime -
        The place in which to put the correlated system time in 100ns units.

Return Value:

    Returns the current physical time in 100-nanosecond units.

--*/
{
    PKSCLOCKINSTANCE ClockInst;
    LARGE_INTEGER PerformanceTime;

    ClockInst = (PKSCLOCKINSTANCE)FileObject->FsContext;
    PerformanceTime = KeQueryPerformanceCounter(NULL);
    if (ClockInst->DefaultClock->CorrelatedTime) {
        LONGLONG PhysicalTime;

        QueryExternalTimeSynchronized(
            ClockInst->DefaultClock,
            &PhysicalTime);
        *SystemTime = KSCONVERT_PERFORMANCE_TIME(ClockInst->DefaultClock->Frequency, PerformanceTime);
        return PhysicalTime;
    }
    *SystemTime = KSCONVERT_PERFORMANCE_TIME(ClockInst->DefaultClock->Frequency, PerformanceTime);
    //
    // Just return the same number if the default clock is being used,
    // removing any suspend time accumulated.
    //
    return *SystemTime - ClockInst->DefaultClock->SuspendDelta;
}

#if 0

KSDDKAPI
BOOLEAN
NTAPI
KsiFastPropertyDefaultClockGetTime(
    IN PFILE_OBJECT FileObject,
    IN PKSPROPERTY UNALIGNED Property,
    IN ULONG PropertyLength,
    OUT PLONGLONG UNALIGNED Time,
    IN ULONG DataLength,
    OUT PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description:

    Handles the fast version of Get Time property by calling the underlying
    DefGetTime function to return the current time.

Arguments:

    FileObject -
        The file object associated with this default clock instance.

    Property -
        Contains the property identifier parameter.

    PropertyLength -
        Contains the length of the property buffer.

    Time -
        The place in which to put the current time.

    DataLength -
        Contains the length of the time buffer.

    IoStatus -
        Contains the status structure to fill in.

Return Value:

    Return TRUE on success, else FALSE on an access violation.

--*/
{
    LONGLONG LocalTime;

    PAGED_CODE();
    LocalTime = DefGetTime(FileObject);
    //
    // The parameters have been previously probed by the general handler function.
    //
    try {
        RtlCopyMemory(Time, &LocalTime, sizeof(*Time));
    } except (EXCEPTION_EXECUTE_HANDLER) {
        return FALSE;
    }
    //IoStatus->Information = sizeof(*Time);
    IoStatus->Status = STATUS_SUCCESS;
    return TRUE;
}


KSDDKAPI
BOOLEAN
NTAPI
KsiFastPropertyDefaultClockGetPhysicalTime(
    IN PFILE_OBJECT FileObject,
    IN PKSPROPERTY UNALIGNED Property,
    IN ULONG PropertyLength,
    OUT PLONGLONG UNALIGNED Time,
    IN ULONG DataLength,
    OUT PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description:

    Handles the fast version of Get Physical Time property.

Arguments:

    FileObject -
        The file object associated with this default clock instance.

    Property -
        Contains the property identifier parameter.

    PropertyLength -
        Contains the length of the property buffer.

    Time -
        The place in which to put the current time.

    DataLength -
        Contains the length of the time buffer.

    IoStatus -
        Contains the status structure to fill in.

Return Value:

    Return TRUE on success, else FALSE on an access violation.

--*/
{
    LONGLONG LocalTime;

    PAGED_CODE();
    LocalTime = DefGetPhysicalTime(IoGetCurrentIrpStackLocation(Irp)->FileObject);
    //
    // The parameters have been previously probed by the general handler function.
    //
    try {
        RtlCopyMemory(Time, &LocalTime, sizeof(*Time));
    } except (EXCEPTION_EXECUTE_HANDLER) {
        return FALSE;
    }
    //IoStatus->Information = sizeof(*Time);
    IoStatus->Status = STATUS_SUCCESS;
    return TRUE;
}


KSDDKAPI
BOOLEAN
NTAPI
KsiFastPropertyDefaultClockGetCorrelatedTime(
    IN PFILE_OBJECT FileObject,
    IN PKSPROPERTY UNALIGNED Property,
    IN ULONG PropertyLength,
    OUT PKSCORRELATED_TIME UNALIGNED CorrelatedTime,
    IN ULONG DataLength,
    OUT PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description:

    Handles the fast version of Get Correlated Time property.

Arguments:

    FileObject -
        The file object associated with this default clock instance.

    Property -
        Contains the property identifier parameter.

    PropertyLength -
        Contains the length of the property buffer.

    CorrelatedTime -
        The place in which to put the correlated time.

    DataLength -
        Contains the length of the time buffer.

    IoStatus -
        Contains the status structure to fill in.

Return Value:

    Return TRUE on success, else FALSE on an access violation.

--*/
{
    KSCORRELATED_TIME LocalCorrelatedTime;

    PAGED_CODE();
    LocalCorrelatedTime->Time = DefGetCorrelatedTime(FileObject, &LocalCorrelatedTime->SystemTime);
    //
    // The parameters have been previously probed by the general handler function.
    //
    try {
        RtlCopyMemory(CorrelatedTime, &LocalCorrelatedTime, sizeof(*CorrelatedTime));
    } except (EXCEPTION_EXECUTE_HANDLER) {
        return FALSE;
    }
    //IoStatus->Information = sizeof(*CorrelatedTime);
    IoStatus->Status = STATUS_SUCCESS;
    return TRUE;
}


KSDDKAPI
BOOLEAN
NTAPI
KsiFastPropertyDefaultClockGetCorrelatedPhysicalTime(
    IN PFILE_OBJECT FileObject,
    IN PKSPROPERTY UNALIGNED Property,
    IN ULONG PropertyLength,
    OUT PKSCORRELATED_TIME UNALIGNED CorrelatedTime,
    IN ULONG DataLength,
    OUT PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description:

    Handles the fast version of Get Correlated Physical Time property.

Arguments:

    FileObject -
        The file object associated with this default clock instance.

    Property -
        Contains the property identifier parameter.

    PropertyLength -
        Contains the length of the property buffer.

    CorrelatedTime -
        The place in which to put the correlated time.

    DataLength -
        Contains the length of the time buffer.

    IoStatus -
        Contains the status structure to fill in.

Return Value:

    Return TRUE on success, else FALSE on an access violation.

--*/
{
    KSCORRELATED_TIME LocalCorrelatedTime;

    PAGED_CODE();
    LocalCorrelatedTime->Time = DefGetCorrelatedPhysicalTime(FileObject, &LocalCorrelatedTime->SystemTime);
    //
    // The parameters have been previously probed by the general handler function.
    //
    try {
        RtlCopyMemory(CorrelatedTime, &LocalCorrelatedTime, sizeof(*CorrelatedTime));
    } except (EXCEPTION_EXECUTE_HANDLER) {
        return FALSE;
    }
    //IoStatus->Information = sizeof(*CorrelatedTime);
    IoStatus->Status = STATUS_SUCCESS;
    return TRUE;
}
#endif


KSDDKAPI
NTSTATUS
NTAPI
KsiPropertyDefaultClockGetTime(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PLONGLONG Time
    )
/*++

Routine Description:

    Handles the Get Time property by calling the underlying DefGetTime
    function to return the current time.

Arguments:

    Irp -
        Contains the Get Time property IRP.

    Property -
        Contains the property identifier parameter.

    Time -
        The place in which to put the current time.

Return Value:

    Return STATUS_SUCCESS.

--*/
{
    PAGED_CODE();
    *Time = DefGetTime(IoGetCurrentIrpStackLocation(Irp)->FileObject);
    //Irp->IoStatus.Information = sizeof(*Time);
    return STATUS_SUCCESS;
}


KSDDKAPI
NTSTATUS
NTAPI
KsiPropertyDefaultClockGetPhysicalTime(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PLONGLONG Time
    )
/*++

Routine Description:

    Handles the Get Physical Time property.

Arguments:

    Irp -
        Contains the Get Physical Time property IRP.

    Property -
        Contains the property identifier parameter.

    Time -
        The place in which to put the current physical time.

Return Value:

    Return STATUS_SUCCESS.

--*/
{
    PAGED_CODE();
    *Time = DefGetPhysicalTime(IoGetCurrentIrpStackLocation(Irp)->FileObject);
    //Irp->IoStatus.Information = sizeof(*Time);
    return STATUS_SUCCESS;
}


KSDDKAPI
NTSTATUS
NTAPI
KsiPropertyDefaultClockGetCorrelatedTime(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PKSCORRELATED_TIME Time
    )
/*++

Routine Description:

    Handles the Get Correlated Time property.

Arguments:

    Irp -
        Contains the Get Correlated Time property IRP.

    Property -
        Contains the property identifier parameter.

    Time -
        The place in which to put the current time and correlated system time.

Return Value:

    Return STATUS_SUCCESS.

--*/
{
    PAGED_CODE();
    Time->Time = DefGetCorrelatedTime(IoGetCurrentIrpStackLocation(Irp)->FileObject, &Time->SystemTime);
    //Irp->IoStatus.Information = sizeof(*Time);
    return STATUS_SUCCESS;
}


KSDDKAPI
NTSTATUS
NTAPI
KsiPropertyDefaultClockGetCorrelatedPhysicalTime(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PKSCORRELATED_TIME Time
    )
/*++

Routine Description:

    Handles the Get Correlated Time property.

Arguments:

    Irp -
        Contains the Get Correlated Time property IRP.

    Property -
        Contains the property identifier parameter.

    Time -
        The place in which to put the current time and correlated system time.

Return Value:

    Return STATUS_SUCCESS.

--*/
{
    PAGED_CODE();
    Time->Time = DefGetCorrelatedPhysicalTime(IoGetCurrentIrpStackLocation(Irp)->FileObject, &Time->SystemTime);
    //Irp->IoStatus.Information = sizeof(*Time);
    return STATUS_SUCCESS;
}


KSDDKAPI
NTSTATUS
NTAPI
KsiPropertyDefaultClockGetResolution(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PKSRESOLUTION Resolution
    )
/*++

Routine Description:

    Handles the Get Resolution property.

Arguments:

    Irp -
        Contains the Get Resolution property IRP.

    Property -
        Contains the property identifier parameter.

    Resolution -
        The place in which to put the granularity and error. This is the
        number of 100ns units of granularity that the clock allows, and
        maximum notification error above and beyond that granularity.

Return Value:

    Return STATUS_SUCCESS.

--*/
{
    PKSCLOCKINSTANCE ClockInst;

    PAGED_CODE();
    ClockInst = (PKSCLOCKINSTANCE)IoGetCurrentIrpStackLocation(Irp)->FileObject->FsContext;
    //
    // The resolution may be based on the PC timer, or on some external
    // clock.
    //
    *Resolution = ClockInst->DefaultClock->Resolution;
    //Irp->IoStatus.Information = sizeof(*Resolution);
    return STATUS_SUCCESS;
}


KSDDKAPI
NTSTATUS
NTAPI
KsiPropertyDefaultClockGetState(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PKSSTATE State
    )
/*++

Routine Description:

    Handles the Get State property.

Arguments:

    Irp -
        Contains the Get State property IRP.

    Property -
        Contains the property identifier parameter.

    State -
        The place in which to put the clock state. This is a reflection of the
        current state of the underlying pin which presented the clock.

Return Value:

    Return STATUS_SUCCESS.

--*/
{
    PKSCLOCKINSTANCE ClockInst;

    PAGED_CODE();
    ClockInst = (PKSCLOCKINSTANCE)IoGetCurrentIrpStackLocation(Irp)->FileObject->FsContext;
    //
    // It is assumed that reading a ULONG value can be done without interlocking.
    //
    *State = ClockInst->DefaultClock->State;
    //Irp->IoStatus.Information = sizeof(*State);
    return STATUS_SUCCESS;
}


KSDDKAPI
NTSTATUS
NTAPI
KsiPropertyDefaultClockGetFunctionTable(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PKSCLOCK_FUNCTIONTABLE FunctionTable
    )
/*++

Routine Description:

    Handles the Get Function Table property.

Arguments:

    Irp -
        Contains the Get Function Table property IRP.

    Property -
        Contains the property identifier parameter.

    FunctionTable -
        The place in which to put the function table entries.

Return Value:

    Return STATUS_SUCCESS.

--*/
{
    PAGED_CODE();
    FunctionTable->GetTime = DefGetTime;
    FunctionTable->GetPhysicalTime = DefGetPhysicalTime;
    FunctionTable->GetCorrelatedTime = DefGetCorrelatedTime;
    FunctionTable->GetCorrelatedPhysicalTime = DefGetCorrelatedPhysicalTime;
    //Irp->IoStatus.Information = sizeof(*FunctionTable);
    return STATUS_SUCCESS;
}


VOID
DefGenerateEvent(
    IN PKDPC Dpc,
    IN PKSIDEFAULTCLOCK DefaultClock,
    IN ULONG LowPart,
    IN LONG HighPart
    )
/*++

Routine Description:

    The Dpc routine for the timer used to generate position notifications. The
    function walks through the list of events to generate, with the assumption
    that no non-position events are in the list. If an expired event is found,
    the event is signalled. If the event is cyclic, the frequency is added to
    the current expiration time until the time is greater than the current time.

    While walking through the list the next expiration time is kept track of.
    If a new timer needs to be set, then one is set.

    If the clock is is stopped before an event which is due actually fires, then
    the event may not fire until the clock is started again. Since positional
    events normally imply a moving timestream, this should not cause a problem.
    Additionally, checking the state, then taking the lock later should not be a
    problem as the difference between the DefaultClock->RunningTimeDelta and the
    DefaultClock->LastRunningTime should be small.

Arguments:

    Dpc -
        Not used.

    DefaultClock -
        This is the context parameter of the Dpc. It contains a pointer to the
        shared default clock information block.

    LowPart -
        Not used.

    HighPart -
        Not used.

Return Value:

    Nothing.

--*/
{
    ULONGLONG Zero;
    LONGLONG RunningTimeDelta;

    Zero = 0;
    RunningTimeDelta = ExInterlockedCompareExchange64(
        (PULONGLONG)&DefaultClock->RunningTimeDelta,
        &Zero,
        &Zero,
        &DefaultClock->TimeAccessLock);
    //
    // Need to acquire the lock first in order to synchronize with any other
    // processor changing the current clock state. Then just hang onto the
    // lock while enumerating the event list.
    //
    KeAcquireSpinLockAtDpcLevel(&DefaultClock->EventQueueLock);
    //
    // This can now be reset so that a new event will know whether or not
    // a Dpc is already outstanding.
    //
    DefaultClock->LastDueTime = 0;
    //
    // It is assumed that reading a ULONG value can be done without interlocking.
    //
    if (DefaultClock->State == KSSTATE_RUN) {
        LONGLONG NextTime;
        PLIST_ENTRY ListEntry;
        LARGE_INTEGER PerformanceTime;
        LONGLONG InterruptTime;

        if (DefaultClock->CorrelatedTime) {
            InterruptTime = QueryExternalTimeSynchronized(
                DefaultClock,
                &PerformanceTime.QuadPart);
        } else {
            //
            // Adjust the interrupt time by the delta to get a number which can be
            // used in checking the items on the event list.
            //
            PerformanceTime = KeQueryPerformanceCounter(NULL);
            InterruptTime = KSCONVERT_PERFORMANCE_TIME(DefaultClock->Frequency, PerformanceTime) -
                RunningTimeDelta;
        }
        //
        // Initialize the next event time to a really large value, which will
        // be checked at the end to see if another timer should be set. If this
        // time happens to be used as the event time, then no timer will be
        // set. However, this time is not likely to be used, since time scales
        // normally start with zero.
        //
        NextTime = _I64_MAX;
        for (ListEntry = DefaultClock->EventQueue.Flink; ListEntry != &DefaultClock->EventQueue;) {
            PKSEVENT_ENTRY EventEntry;
            PKSINTERVAL Interval;

            EventEntry = CONTAINING_RECORD(ListEntry, KSEVENT_ENTRY, ListEntry);
            //
            // Pre-increment since KsGenerateEvent can remove this item
            // from the list in the case of a one-shot event.
            //    
            ListEntry = ListEntry->Flink;
            //
            // The event-specific data was added onto the end of the entry.
            //
            Interval = (PKSINTERVAL)(EventEntry + 1);
            //
            // Time for this event to go off.
            //
            if (Interval->TimeBase <= InterruptTime) {
                //
                // There are only two events, an interval, and a non-interval.
                // Rather than waste space keeping an extra EventId element
                // in the extra data of each event, use the internal one
                // defined by KSIEVENT_ENTRY.
                //
                if (CONTAINING_RECORD(EventEntry, KSIEVENT_ENTRY, EventEntry)->Event.Id == KSEVENT_CLOCK_INTERVAL_MARK) {
                    LONGLONG    Intervals;

                    //
                    // An interval timer should only go off once per time,
                    // so update it to the next timeout.
                    //
                    Intervals = (InterruptTime - Interval->TimeBase) / Interval->Interval + 1;
                    Interval->TimeBase += Intervals * Interval->Interval;
                    //
                    // Update the next timer value if a closer timeout value was
                    // found. If this is for some reason a One Shot event, even
                    // though it is an interval event, don't use it to set up
                    // the next timer.
                    //
                    if (!(EventEntry->Flags & KSEVENT_ENTRY_ONESHOT) && (Interval->TimeBase < NextTime)) {
                        NextTime = Interval->TimeBase;
                    }
                } else {
                    //
                    // Else a non-interval should only go off once, so make
                    // its next time a value which will never be reached again,
                    // even if the clock is set back.
                    //
                    Interval->TimeBase = _I64_MAX;
                }
                //
                // N.B.: If this event is a one-shot event, the EventEntry 
                // may be removed after it is signalled -- this is often the
                // case for SMP systems.  Do not touch the EventEntry after
                // calling KsGenerateEvent().
                //    
                KsGenerateEvent(EventEntry);
            } else if (Interval->TimeBase < NextTime) {
                //
                // Update the next timer value if a closer timeout value was
                // found.
                //
                NextTime = Interval->TimeBase;
            }
        }
        //
        // If a new timeout was found then kill any current timer and set a new
        // one. Don't bother checking to see if the current timer is equivalent
        // to the one about to be scheduled, as this only occurs if a new event
        // is enabled which is due before any current event, after the timer has
        // expired, but before this Dpc has acquired the event queue lock.
        //
        if (NextTime < _I64_MAX) {
            DefResetTimer(
                DefaultClock,
                InterruptTime + RunningTimeDelta,
                InterruptTime - NextTime);
        }
    }
    //
    // This reference count decrement is done while holding the spinlock
    // so that it is synchronized.
    //
    if (!--DefaultClock->ReferenceCount) {
        //
        // The owner of the clock has abandoned this default clock instance,
        // and this is the last Dpc to run, so free the memory that it left
        // around. The memory was left because the owner noticed that the
        // ReferenceCount was not zero, and therefore one or more Dpc's
        // were outstanding.
        //
//      KeReleaseSpinLockFromDpcLevel(&DefaultClock->EventQueueLock);
        ExFreePool(DefaultClock);
    } else {
        //
        // Else there is still interest in this default clock instance.
        //
        KeReleaseSpinLockFromDpcLevel(&DefaultClock->EventQueueLock);
    }
}


KSDDKAPI
NTSTATUS
NTAPI
KsiDefaultClockAddMarkEvent(
    IN PIRP Irp,
    IN PKSEVENT_TIME_INTERVAL EventTime,
    IN PKSEVENT_ENTRY EventEntry
    )
/*++

Routine Description:

    The Add Event handler for position notification events. If the clock is
    running, also sets a new timer for the expiration time if it is shorter
    than the current timer expiration time.

Arguments:

    Irp -
        The IRP containing the event to add.

    EventTime -
        The event data. Although this points to a structure of two elements,
        the second element is not accessed if this is not a cyclic request.

    EventEntry -
        The event list entry.

Return Value:

    Returns STATUS_SUCCESS.

--*/
{
    PKSCLOCKINSTANCE ClockInst;
    KIRQL Irql;
    PKSINTERVAL Interval;

    ClockInst = (PKSCLOCKINSTANCE)IoGetCurrentIrpStackLocation(Irp)->FileObject->FsContext;
    //
    // Space for the interval is located at the end of the basic event structure.
    //
    Interval = (PKSINTERVAL)(EventEntry + 1);
    //
    // Either just an event time was passed, or a time base plus an interval. In
    // both cases the first LONGLONG is present and saved.
    //
    Interval->TimeBase = EventTime->TimeBase;
    if (EventEntry->EventItem->EventId == KSEVENT_CLOCK_INTERVAL_MARK) {
        Interval->Interval = EventTime->Interval;
    }
    //
    // Acquire the lock which is used for both events and in changing the state, and
    // add the new event item.
    //
    KeAcquireSpinLock(&ClockInst->DefaultClock->EventQueueLock, &Irql);
    InsertTailList(&ClockInst->DefaultClock->EventQueue, &EventEntry->ListEntry);
    //
    // If the clock is running, then the next timer expiration may need to be updated
    // due to this new item.
    //
    // It is assumed that reading a ULONG value can be done without interlocking.
    //
    if (ClockInst->DefaultClock->State == KSSTATE_RUN) {
        ULONGLONG Zero;
        LONGLONG CurrentTime;
        LONGLONG RunningTimeDelta;
        LARGE_INTEGER PerformanceTime;

        if (ClockInst->DefaultClock->CorrelatedTime) {
            CurrentTime = QueryExternalTimeSynchronized(
                ClockInst->DefaultClock,
                &PerformanceTime.QuadPart);
        } else {
            PerformanceTime = KeQueryPerformanceCounter(NULL);
            CurrentTime = KSCONVERT_PERFORMANCE_TIME(ClockInst->DefaultClock->Frequency, PerformanceTime);
        }
        //
        // Obtain the current time delta without corrupting it, then determine if the
        // current timer has already gone off, or will go off before this event needs
        // to have it go off. Since the event queue lock has been acquired, the
        // DefaultClock->LastDueTime can be directly accessed to determine this.
        //
        Zero = 0;
        RunningTimeDelta = ExInterlockedCompareExchange64(
            (PULONGLONG)&ClockInst->DefaultClock->RunningTimeDelta,
            &Zero,
            &Zero,
            &ClockInst->DefaultClock->TimeAccessLock);
        //
        // Create an absolute number that can be easily compared against.
        //
        RunningTimeDelta += Interval->TimeBase;
        //
        // LastDueTime is reset within the Dpc.
        //
        if (!ClockInst->DefaultClock->LastDueTime || 
            (ClockInst->DefaultClock->LastDueTime > RunningTimeDelta)) {
            //
            // Ensure that this will be a relative timer, even if this
            // delays the timeout by 100ns.
            //
            if (RunningTimeDelta <= CurrentTime) {
                RunningTimeDelta = -1;
            }
            DefResetTimer(
                ClockInst->DefaultClock,
                CurrentTime,
                RunningTimeDelta);
        }
    }
    KeReleaseSpinLock(&ClockInst->DefaultClock->EventQueueLock, Irql);
    return STATUS_SUCCESS;
}


KSDDKAPI
NTSTATUS
NTAPI
KsCreateClock(
    IN HANDLE ConnectionHandle,
    IN PKSCLOCK_CREATE ClockCreate,
    OUT PHANDLE ClockHandle
    )
/*++

Routine Description:

    Creates a handle to a clock instance. This may only be called at
    PASSIVE_LEVEL.

Arguments:

    ConnectionHandle -
        Contains the handle to the connection on which to create the
        clock.

    ClockCreate -
        Specifies clock create parameters. This currently consists of
        a flags item, which must be set to zero.

    ClockHandle -
        Place in which to put the clock handle.

Return Value:

    Returns STATUS_SUCCESS, else an error on clock creation failure.

--*/
{
    PAGED_CODE();
    return KsiCreateObjectType(
        ConnectionHandle,
        (PWCHAR)ClockString,
        ClockCreate,
        sizeof(*ClockCreate),
        GENERIC_READ,
        ClockHandle);
}


KSDDKAPI
NTSTATUS
NTAPI
KsValidateClockCreateRequest(
    IN PIRP Irp,
    OUT PKSCLOCK_CREATE* ClockCreate
    )
/*++

Routine Description:

    Validates the clock creation request and returns the create structure
    associated with the request.

    This may only be called at PASSIVE_LEVEL.

Arguments:

    Irp -
        Contains the IRP with the clock create request being handled.

    ClockCreate -
        Place in which to put the clock create structure pointer passed to
        the create request.

Return Value:

    Returns STATUS_SUCCESS, else an error.

--*/
{
    NTSTATUS Status;
    ULONG CreateParameterLength;

    PAGED_CODE();
    CreateParameterLength = sizeof(**ClockCreate);
    Status = KsiCopyCreateParameter(
        Irp,
        &CreateParameterLength,
        ClockCreate);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    //
    // No flags have been defined yet.
    //
    if ((*ClockCreate)->CreateFlags) {
        return STATUS_INVALID_PARAMETER;
    }
    return STATUS_SUCCESS;
}


VOID
DefRescheduleDefaultClockTimer(
    IN PKSIDEFAULTCLOCK DefaultClock
    )
/*++

Routine Description:

    Reschedules the shared event notification timer based on current clock state
    and time. If the filter state changes, or the current logical time changes,
    then this function should be used to reset the next clock timer.

    This may be called at <= DISPATCH_LEVEL.

Arguments:

    DefaultClock -
        Contains the shared clock information structure whose timer is to be
        reset.

Return Value:

    Nothing.

--*/
{
    KIRQL Irql;

    //
    // Synchronize with any timer Dpc before scheduling a new one. This just
    // schedules for an immediate timeout without attempting to look for the
    // best time. The timer Dpc will figure out the next best time anyway, so
    // there is no real need to figure it out again.
    //
    KeAcquireSpinLock(&DefaultClock->EventQueueLock, &Irql);
    DefResetTimer(DefaultClock, 0, -1);
    KeReleaseSpinLock(&DefaultClock->EventQueueLock, Irql);
}


KSDDKAPI
NTSTATUS
NTAPI
KsAllocateDefaultClockEx(
    OUT PKSDEFAULTCLOCK* DefaultClock,
    IN PVOID Context OPTIONAL,
    IN PFNKSSETTIMER SetTimer OPTIONAL,
    IN PFNKSCANCELTIMER CancelTimer OPTIONAL,
    IN PFNKSCORRELATEDTIME CorrelatedTime OPTIONAL,
    IN const KSRESOLUTION* Resolution OPTIONAL,
    IN ULONG Flags
    )
/*++

Routine Description:

    Allocates and initializes the default clock structure. The internal
    DefaultClock.ReferenceCount element is initialized to 1 by this function.
    This element is incremented and decremented as each notification DPC is
    queued and completes. When the structure is to be freed using
    KsFreeDefaultClock, this is used to determine if the owner of the clock
    should free the structure, or if a pending DPC should free it
    asynchronously.

    This may only be called at PASSIVE_LEVEL.

Arguments:

    DefaultClock -
        The place in which to return a pointer to the shared default clock
        structure. Sets the current time to zero, and the state to KSSTATE_STOP.

    Context -
        Optionally contains the context of the alternate time facilities.
        This must be set if a timer or correlated time function is used.

    SetTimer -
        Optionally contains an alternate function to use in generating
        DPC timer callbacks based on a Presentation Time. If this is set,
        this function will be used to set timers based on deltas to the
        current Presentation Time in order to generate event notifications.
        If an alternate function is passed in to set timers, a corresponding
        CancelTimer function must also be passed. This is set to NULL if
        the default KeSetTimerEx function is to be used to approximate the
        next notification time. This would normally be set only if a
        CorrelatedTime function was being used. The function must have the
        same characteristics as the default function.

    CancelTimer -
        Optionally contains an alternate function to use in cancelling
        outstanding timer callbacks. If an alternate function is passed
        in to cancel timers, a corresponding SetTimer function must also be
        passed. This is set to NULL if the default KeCancelTimer function
        is to be used. The function must have the same characteristics as
        the default function.

    CorrelatedTime -
        Optionally contains an alternate function to retrieve both the
        Presentation and Physical Time in a correlated manner. This allows
        the clock owner to completely determine the current time. This is
        set to NULL if the default KeQueryPerformanceCounter function is
        to be used to regulate time progression.

    Resolution -
        Optionally contains an alternate Granularity and/or Error factor
        for the clock. This can only be used only if an alternate timer or
        correlated time function are being provided. An alternate Granularity
        may be specified if an alternate correlated time is being used, else
        the structure element must be zero. An alternate Error may be
        specified if an alternate timer is being used, else the structure
        element must be zero.

    Flags -
        Reserved, set to zero.

Return Value:

    Returns STATUS_SUCCESS, else a memory error.

--*/
{
    PKSIDEFAULTCLOCK LocalDefaultClock;

    PAGED_CODE();
    ASSERT(!Flags);
    LocalDefaultClock = ExAllocatePoolWithTag(
        NonPagedPool,
        sizeof(*LocalDefaultClock),
        KSSIGNATURE_DEFAULT_CLOCK);
    if (!LocalDefaultClock) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    //
    // This may not be used if a correlated time function is used.
    //
    KeQueryPerformanceCounter((PLARGE_INTEGER)&LocalDefaultClock->Frequency);
    LocalDefaultClock->LastDueTime = 0;
    //
    // This value remains zero when an external time is used.
    //
    LocalDefaultClock->RunningTimeDelta = 0;
    //
    // LastStreamTime is used to prevent StreamTime from going backwards
    //
    LocalDefaultClock->LastStreamTime = _I64_MIN;
    //
    // This value is not used when an external time is used.
    //
    LocalDefaultClock->LastRunningTime = 0;
    KeInitializeSpinLock(&LocalDefaultClock->TimeAccessLock);
    InitializeListHead(&LocalDefaultClock->EventQueue);
    KeInitializeSpinLock(&LocalDefaultClock->EventQueueLock);
    KeInitializeTimerEx(&LocalDefaultClock->QueueTimer, NotificationTimer);
    KeInitializeDpc(&LocalDefaultClock->QueueDpc, (PKDEFERRED_ROUTINE)DefGenerateEvent, LocalDefaultClock);
    //
    // The owner of the clock initially has 1 reference count on this
    // structure. The structure will stay around at least until KsFreeDefaultClock
    // is called. It may remain longer if an outstanding Dpc is present.
    //
    LocalDefaultClock->ReferenceCount = 1;
    LocalDefaultClock->State = KSSTATE_STOP;
    //
    // These two values are not used when an external time reference is used.
    //
    LocalDefaultClock->SuspendDelta = 0;
    LocalDefaultClock->SuspendTime = 0;
    //
    // These functions may be substituted by the clock owner.
    //
    ASSERT(((SetTimer && CancelTimer) || (!SetTimer && !CancelTimer)) && "The clock owner did not pass valid timer paramters");
    LocalDefaultClock->SetTimer = SetTimer;
    LocalDefaultClock->CancelTimer = CancelTimer;
    //
    // If this is set, then an external timer source is used, else the
    // normal PC timer time is used.
    //
    LocalDefaultClock->CorrelatedTime = CorrelatedTime;
    //
    // This is only used when an external clock is in used in order to
    // know when to wait for any current clock queries to complete.
    //
    KeInitializeEvent(&LocalDefaultClock->FreeEvent, NotificationEvent, FALSE);
    LocalDefaultClock->ExternalTimeReferenceCount = 1;
    //
    // This is used for quick checking to see if an external clock is
    // supposed to be used for queries. If there is no external time
    // function, it is not referenced.
    //
    LocalDefaultClock->ExternalTimeValid = TRUE;
    ASSERT((Context || (!SetTimer && !CorrelatedTime)) && "The clock owner must specify an owner context");
    LocalDefaultClock->Context = Context;
    //
    // Default the resolution to the PC timer, which may be substituted.
    // Initialize the numbers to the defaults first.
    //
    // This clock provides a resolution based on the number of clock
    // ticks which can occur each second, and a notification error
    // based on the system time increment minus the calculated
    // granularity.
    //
    LocalDefaultClock->Resolution.Granularity = (LONGLONG)NANOSECONDS / LocalDefaultClock->Frequency;
    if (!LocalDefaultClock->Resolution.Granularity) {
        LocalDefaultClock->Resolution.Granularity = 1;
    }
    LocalDefaultClock->Resolution.Error = KeQueryTimeIncrement() - LocalDefaultClock->Resolution.Granularity;
    //
    // If there is a Resolution structure, then some of the numbers may
    // be changed.
    //
    if (Resolution) {
        ASSERT((CorrelatedTime || SetTimer) && "The clock owner can only specify an Resolution if alternates are being used");
        //
        // If external time is being used, then the caller may set a
        // granularity for that the time increment, else the default
        // is used.
        //
        if (CorrelatedTime) {
            LocalDefaultClock->Resolution.Granularity = Resolution->Granularity;
        } else {
            ASSERT(!Resolution->Granularity && "The clock owner must set Granularity to zero if not used");
        }
        //
        // If external notification is being used, then the caller may set
        // the Error, else the default is used.
        //
        if (SetTimer) {
            LocalDefaultClock->Resolution.Error = Resolution->Error;
        } else {
            ASSERT(!Resolution->Error && "The clock owner must set Error to zero if not used");
        }
    }
    *DefaultClock = (PKSDEFAULTCLOCK)LocalDefaultClock;
    return STATUS_SUCCESS;
}


KSDDKAPI
NTSTATUS
NTAPI
KsAllocateDefaultClock(
    OUT PKSDEFAULTCLOCK* DefaultClock
    )
/*++

Routine Description:

    Uses KsAllocateDefaultClockEx, defaulting the time parameters.

    This may only be called at PASSIVE_LEVEL.

Arguments:

    DefaultClock -
        The place in which to return a pointer to the shared default clock
        structure. Sets the current time to zero, and the state to KSSTATE_STOP.

Return Value:

    Returns STATUS_SUCCESS, else a memory error.

--*/
{
    return KsAllocateDefaultClockEx(DefaultClock, NULL, NULL, NULL, NULL, NULL, 0);
}


LONG
FASTCALL
DecrementReferenceCount(
    IN PKSIDEFAULTCLOCK DefaultClock
    )
/*++

Routine Description:

    Decrements the reference count on the default clock, deleting it
    when the count reaches zero. This acquires the queue lock in order
    to synchronize with other access the reference count. Functions which
    already have the queue lock acquired don't use this function.

    This may be called at <= DISPATCH_LEVEL.

Arguments:

    DefaultClock -
        Contains the default clock shared structure.

Return Value:

    Returns the current reference count on the default clock.

--*/
{
    LONG ReferenceCount;
    KIRQL Irql;

    //
    // Synchronize with other access to this reference count. This allows
    // other access to not need interlocked functions to modify the count,
    // since they are already synchronizing with the queue lock anyway.
    //
    KeAcquireSpinLock(&DefaultClock->EventQueueLock, &Irql);
    DefaultClock->ReferenceCount--;
    //
    // Store this in case the object gets deleted immediately after this
    // point.
    //
    ReferenceCount = DefaultClock->ReferenceCount;
    KeReleaseSpinLock(&DefaultClock->EventQueueLock, Irql);
    //
    // If no more references are outstanding on this object, delete it.
    //
    if (!ReferenceCount) {
        ExFreePool(DefaultClock);
    }
    return ReferenceCount;
}


LONG
FASTCALL
IncrementReferenceCount(
    IN PKSIDEFAULTCLOCK DefaultClock
    )
/*++

Routine Description:

    Increments the reference count on the default clock. Localizes the
    nonpaged code to this function.

    This may be called at <= DISPATCH_LEVEL.

Arguments:

    DefaultClock -
        Contains the default clock shared structure.

Return Value:

    Returns the current reference count on the default clock.

--*/
{
    KIRQL Irql;

    //
    // Synchronize with other access to this reference count. This allows
    // other access to not need interlocked functions to modify the count,
    // since they are already synchronizing with the queue lock anyway.
    //
    KeAcquireSpinLock(&DefaultClock->EventQueueLock, &Irql);
    DefaultClock->ReferenceCount++;
    KeReleaseSpinLock(&DefaultClock->EventQueueLock, Irql);
    //
    // The object cannot be deleted at this point, since it was just
    // referenced, at least given the way the rest of the reference
    // counting works.
    //
    return DefaultClock->ReferenceCount;
}


KSDDKAPI
VOID
NTAPI
KsFreeDefaultClock(
    IN PKSDEFAULTCLOCK DefaultClock
    )
/*++

Routine Description:

    Frees a default clock structure previously allocated with
    KsAllocateDefaultClock, taking into account any currently running timer
    Dpc's. Does not assume that all instances of the clock have been closed.
    This may actually just decrement the internal reference counter, and
    allow a pending DPC to free the structure asynchronously.

    This may only be called at PASSIVE_LEVEL.

Arguments:

    DefaultClock -
        Points to the clock structure to free.

Return Value:

    Nothing.

--*/
{
    PKSIDEFAULTCLOCK LocalDefaultClock;

    PAGED_CODE();
    //
    // Kill the shared timer Dpc if needed.
    //
    LocalDefaultClock = (PKSIDEFAULTCLOCK)DefaultClock;
    //
    // Remove external dependencies, and limit ramifications.
    //
    LocalDefaultClock->State = KSSTATE_STOP;
    DefClockKillTimer(LocalDefaultClock, TRUE);
    //
    // All use of this pointer needs to be synchronized with its
    // removal.
    //
    if (LocalDefaultClock->CorrelatedTime) {
        //
        // Stop any new clock queries, then wait for any current
        // ones to complete.
        //
        LocalDefaultClock->ExternalTimeValid = FALSE;
        //
        // If a current time query is in progress, wait for it
        // to complete before returning to the caller. All new
        // queries will be stopped by resetting EXTERNAL_CLOCK_VALID.
        //
        if (InterlockedDecrement(&LocalDefaultClock->ExternalTimeReferenceCount)) {
            KeWaitForSingleObject(&LocalDefaultClock->FreeEvent, Executive, KernelMode, FALSE, NULL);
        }
    }
    //
    // Only actually free the structure if no Dpc or handle is outstanding.
    // Else the last Dpc or IRP_MJ_CLOSE will free the structure.
    //
    DecrementReferenceCount(LocalDefaultClock);
}


KSDDKAPI
NTSTATUS
NTAPI
KsCreateDefaultClock(
    IN PIRP Irp,
    IN PKSDEFAULTCLOCK DefaultClock
    )
/*++

Routine Description:

    Given an IRP_MJ_CREATE request, creates a default clock which uses the
    system clock as a time base, and associates the
    IoGetCurrentIrpStackLocation(Irp)->FileObject with this clock using an
    internal dispatch table (KSDISPATCH_TABLE). This can be done after
    using KsAllocateDefaultClock to create and initialize the internal
    structures for a default clock instance. After that, many file objects
    can be created against the same underlying default clock instance.

    Assumes that the KSCREATE_ITEM_IRP_STORAGE(Irp) points to the create
    item for this clock, and assigns a pointer to it in the FsContext.
    This is used for any security descriptor queries or changes. This may
    only be called at PASSIVE_LEVEL.

Arguments:

    Irp -
        Contains the IRP with the clock create request being handled.

    DefaultClock -
        Contains an initialize Default Clock structure which is shared amongst
        any instance of the default clock for the parent. This should have been
        previously allocated with KsAllocateDefaultClock.

Return Value:

    Returns STATUS_SUCCESS, else a error. Does not complete the IRP or set the
    status in the IRP.

--*/
{
    NTSTATUS Status;
    PKSCLOCK_CREATE LocalClockCreate;
    PKSCLOCKINSTANCE ClockInst;
    PIO_STACK_LOCATION IrpStack;

    PAGED_CODE();
    if (!NT_SUCCESS(Status = KsValidateClockCreateRequest(Irp, &LocalClockCreate))) {
        return Status;
    }
    ClockInst = ExAllocatePoolWithTag(
        NonPagedPool,
        sizeof(*ClockInst),
        KSSIGNATURE_DEFAULT_CLOCKINST);
    if (!ClockInst) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    Status = KsAllocateObjectHeader(
        &ClockInst->Header,
        0,
        NULL,
        Irp,
        (PKSDISPATCH_TABLE)&DefClockDispatchTable);
    if (!NT_SUCCESS(Status)) {
        ExFreePool(ClockInst);
        return Status;
    }
    ClockInst->DefaultClock = (PKSIDEFAULTCLOCK)DefaultClock;
    IncrementReferenceCount(ClockInst->DefaultClock);
    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    IrpStack->FileObject->FsContext = ClockInst;
    KsSetPowerDispatch(ClockInst->Header, (PFNKSCONTEXT_DISPATCH)DefPowerDispatch, ClockInst->DefaultClock);
    return STATUS_SUCCESS;
}


NTSTATUS
DefClockIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    The IRP handler for IRP_MJ_DEVICE_CONTROL for the default Clock. Handles
    the properties and events supported by this implementation.

Arguments:

    DeviceObject -
        The device object to which the Clock is attached. This is not used.

    Irp -
        The specific device control IRP to be processed.

Return Value:

    Returns the status of the processing.

--*/
{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpStack;

    PAGED_CODE();
    IrpStack = IoGetCurrentIrpStackLocation(Irp);

    switch (IrpStack->Parameters.DeviceIoControl.IoControlCode) {

    case IOCTL_KS_PROPERTY:

        Status = KsPropertyHandler(Irp, SIZEOF_ARRAY(DefClockPropertySets), (PKSPROPERTY_SET)DefClockPropertySets);
        break;

    case IOCTL_KS_ENABLE_EVENT:

        Status = KsEnableEvent(Irp, SIZEOF_ARRAY(DefClockEventSets), (PKSEVENT_SET)DefClockEventSets, NULL, 0, NULL);
        break;

    case IOCTL_KS_DISABLE_EVENT:
    {
        PKSCLOCKINSTANCE ClockInst;

        ClockInst = (PKSCLOCKINSTANCE)IrpStack->FileObject->FsContext;
        Status = KsDisableEvent(Irp, &ClockInst->DefaultClock->EventQueue, KSEVENTS_SPINLOCK, &ClockInst->DefaultClock->EventQueueLock);
        break;
    }

    default:
        Status = STATUS_INVALID_DEVICE_REQUEST;
        break;

    }

    Irp->IoStatus.Status = Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return Status;
}


NTSTATUS
DefClockClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    The IRP handler for IRP_MJ_CLOSE for the default Clock. Cleans up the
    event list, and instance data, and cancels notification timer if no longer
    needed. This just removes an open instance and therefore a reference on
    a shared clock structure, not the shared structure itself.

Arguments:

    DeviceObject -
        The device object to which the Clock is attached. This is not used.

    Irp -
        The specific close IRP to be processed.

Return Value:

    Returns STATUS_SUCCESS.

--*/
{
    PIO_STACK_LOCATION IrpStack;
    PKSCLOCKINSTANCE ClockInst;

    PAGED_CODE();
    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    ClockInst = (PKSCLOCKINSTANCE)IrpStack->FileObject->FsContext;
    KsSetPowerDispatch(ClockInst->Header, NULL, NULL);
    //
    // Free the events which may have been left for this file object.
    //
    KsFreeEventList(IrpStack->FileObject, &ClockInst->DefaultClock->EventQueue, KSEVENTS_SPINLOCK, &ClockInst->DefaultClock->EventQueueLock);
    //
    // Kill the shared timer Dpc if needed.
    //
    DefClockKillTimer(ClockInst->DefaultClock, FALSE);
    //
    // This may just be a dangling handle open on a clock, whose actual
    // owner has already been closed. So delete the clock if needed.
    //
    // Only actually free the structure if no Dpc or handle is outstanding.
    // Else the last Dpc or IRP_MJ_CLOSE will free the structure.
    //
    DecrementReferenceCount(ClockInst->DefaultClock);
    KsFreeObjectHeader(ClockInst->Header);
    ExFreePool(ClockInst);
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}


NTSTATUS
DefPowerDispatch(
    IN PKSIDEFAULTCLOCK DefaultClock,
    IN PIRP Irp
    )
/*++

Routine Description:

    The IRP power callback handler for the default Clock. Stores the current
    system time during suspend operations so that a delta can be maintained
    when a wake state occurs.

Arguments:

    DefaultClock -
        The context parameter set on the KsSetPowerDispatch function.

    Irp -
        The specific power IRP to be processed.

Return Value:

    Returns STATUS_SUCCESS. This is not used.

--*/
{
    PIO_STACK_LOCATION IrpStack;

    PAGED_CODE();
    //
    // If an external time source is used, then it must decide what, if
    // anything, to do during a suspend.
    //
    if (DefaultClock->CorrelatedTime) {
        return STATUS_SUCCESS;
    }
    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    if ((IrpStack->MinorFunction == IRP_MN_SET_POWER) && (IrpStack->Parameters.Power.Type == SystemPowerState)) {
        LARGE_INTEGER PerformanceTime;
        LONGLONG SystemTime;

        //
        // Acquire the current time so that a delta can be calculated either
        // now or later.
        //
        PerformanceTime = KeQueryPerformanceCounter(NULL);
        SystemTime = KSCONVERT_PERFORMANCE_TIME(DefaultClock->Frequency, PerformanceTime);
        if (IrpStack->Parameters.Power.State.SystemState <= PowerSystemWorking) {
            //
            // The system has woken up. Determine how long it was suspended.
            // Ensure that this is not just a spurious power Irp, and that
            // there is indeed a delta to calculate.
            //
            if (DefaultClock->SuspendTime) {
                //
                // This does not attempt to serialize access to the SuspendDelta
                // because if a clock client queried for the physical time before
                // the delta was adjusted, it would be just about as incorrect as
                // accessing it during the addition. Either way they get a wrong
                // number until the delta is updated. The only other way of dealing
                // with this would be to stall access to the physical time until
                // this power Irp had been received, but of course that could
                // induce deadlock with another client querying during it's own
                // power Irp processing.
                //
                DefaultClock->SuspendDelta += (SystemTime - DefaultClock->SuspendTime);
                //
                // Reset this value so that spurious power Irps can be
                // detected.
                //
                DefaultClock->SuspendTime = 0;
            }
        } else {
            //
            // About to power down to some inactive state. Store the current
            // system time so that it can be added to the physical time
            // delta when power comes back up.
            //
            DefaultClock->SuspendTime = SystemTime;
        }
    }
    return STATUS_SUCCESS;
}


KSDDKAPI
KSSTATE
NTAPI
KsGetDefaultClockState(
    IN PKSDEFAULTCLOCK DefaultClock
    )
/*++

Routine Description:

    Gets the current state of the clock.

    This may be called at DISPATCH_LEVEL.

Arguments:

    DefaultClock -
        Contains an initialize Default Clock structure which is shared amongst
        any instance of the default clock for the parent.

Return Value:

    Returns the current clock state.

--*/
{
    //
    // It is assumed that reading a ULONG value can be done without interlocking.
    //
    return ((PKSIDEFAULTCLOCK)DefaultClock)->State;
}


KSDDKAPI
VOID
NTAPI
KsSetDefaultClockState(
    IN PKSDEFAULTCLOCK DefaultClock,
    IN KSSTATE State
    )
/*++

Routine Description:

    Sets the current state of the clock, which is used to reflect the current
    state of the underlying filter pin.

    The owner of the default clock is expected to serialize access to this
    function and to KsSetDefaultClockTime.

    This may be called at DISPATCH_LEVEL.

Arguments:

    DefaultClock -
        Contains an initialize Default Clock structure which is shared amongst
        any instance of the default clock for the parent.

    State -
        Contains the new state to set the clock to.

Return Value:

    Nothing.

--*/
{
    PKSIDEFAULTCLOCK LocalDefaultClock;

    //
    // It is assumed that reading a ULONG value can be done without interlocking.
    //
    LocalDefaultClock = (PKSIDEFAULTCLOCK)DefaultClock;
    if (State != LocalDefaultClock->State) {
        LARGE_INTEGER PerformanceTime;
        LONGLONG InterruptTime;

        if (LocalDefaultClock->CorrelatedTime) {
            //
            // This just keeps the RunningTimeDelta at zero without having
            // to do any additional code.
            //
            InterruptTime = 0;
        } else {
            PerformanceTime = KeQueryPerformanceCounter(NULL);
            InterruptTime = KSCONVERT_PERFORMANCE_TIME(LocalDefaultClock->Frequency, PerformanceTime);
        }

        if (State != KSSTATE_RUN) {
           LONGLONG ResetValue = _I64_MIN;

#ifdef CREATE_A_FLURRY_OF_TIMING_SPEW
           DbgPrint( "KsClock: Resetting LastStreamTime to _I64_MIN\n");
#endif
           ExInterlockedCompareExchange64(
               (PULONGLONG)&LocalDefaultClock->LastStreamTime,
               (PULONGLONG)&ResetValue,
               (PULONGLONG)&LocalDefaultClock->LastStreamTime,
               &LocalDefaultClock->TimeAccessLock);
        }

        switch (State) {

        //case KSSTATE_STOP:
        //case KSSTATE_ACQUIRE:
        //case KSSTATE_PAUSE:
        default:
            ASSERT(((State == KSSTATE_STOP) || (State == KSSTATE_ACQUIRE) || (State == KSSTATE_PAUSE)) && "The driver passed an invalid new State");
            //
            // If the clock is actually running, then set the last running time,
            // and set the new state. Synchronize with any Dpc running by acquiring
            // the lock during the state change itself. The assumption is that
            // this function itself is serialized by the clock owner.
            //
            if (LocalDefaultClock->State == KSSTATE_RUN) {
                KIRQL Irql;

                InterruptTime -= LocalDefaultClock->RunningTimeDelta;
                ExInterlockedCompareExchange64(
                    (PULONGLONG)&LocalDefaultClock->LastRunningTime,
                    (PULONGLONG)&InterruptTime,
                    (PULONGLONG)&LocalDefaultClock->LastRunningTime,
                    &LocalDefaultClock->TimeAccessLock);
                KeAcquireSpinLock(&LocalDefaultClock->EventQueueLock, &Irql);
                //
                // This must be set while the spinlock is taken so that any Dpc
                // waits and does not check the state when deciding what to do
                // next. It is assumed that writing a ULONG value can be done
                // without interlocking.
                //
                LocalDefaultClock->State = State;
                if (LocalDefaultClock->CancelTimer) {
                    if (LocalDefaultClock->CancelTimer(LocalDefaultClock->Context, &LocalDefaultClock->QueueTimer)) {
                        LocalDefaultClock->ReferenceCount--;
                    }
                } else if (KeCancelTimer(&LocalDefaultClock->QueueTimer)) {
                    LocalDefaultClock->ReferenceCount--;
                }
                KeReleaseSpinLock(&LocalDefaultClock->EventQueueLock, Irql);
            } else {
                //
                // Else there is no Dpc to synchronize with, so just set the state.
                // It is assumed that writing a ULONG value can be done without
                // interlocking.
                //
                LocalDefaultClock->State = State;
            }
            break;

        case KSSTATE_RUN:
            //
            // Moving from a non-running state now. Set the new delta based on
            // the current performance time and set the state. No need to
            // synchronize with any Dpc.
            //
            InterruptTime -= LocalDefaultClock->LastRunningTime;
            ExInterlockedCompareExchange64(
                (PULONGLONG)&LocalDefaultClock->RunningTimeDelta,
                (PULONGLONG)&InterruptTime,
                (PULONGLONG)&LocalDefaultClock->RunningTimeDelta,
                &LocalDefaultClock->TimeAccessLock);
            //
            // There is no Dpc to synchronize with, so just set the state.
            // It is assumed that writing a ULONG value can be done without
            // interlocking.
            //
            LocalDefaultClock->State = State;
            DefRescheduleDefaultClockTimer(LocalDefaultClock);
            break;

        }
    }
}


KSDDKAPI
LONGLONG
NTAPI
KsGetDefaultClockTime(
    IN PKSDEFAULTCLOCK DefaultClock
    )
/*++

Routine Description:

    Gets the current time of the clock.

    This may be called at DISPATCH_LEVEL.

Arguments:

    DefaultClock -
        Contains an initialize Default Clock structure which is shared amongst
        any instance of the default clock for the parent.

Return Value:

    Returns the current clock time.

--*/
{
    ULONGLONG Zero;
    LARGE_INTEGER PerformanceTime;
    PKSIDEFAULTCLOCK LocalDefaultClock;

    LocalDefaultClock = (PKSIDEFAULTCLOCK)DefaultClock;
    if (LocalDefaultClock->CorrelatedTime) {
        LONGLONG PhysicalTime;

        //
        // Current time, no matter what the state, is completely dependent
        // on the external function in this case.
        //
        return QueryExternalTimeSynchronized(
            LocalDefaultClock,
            &PhysicalTime);
    }
    //
    // This is used in the compare/exchange, and represents both the value to
    // compare against, and the exchange value. This means that if the compare
    // succeeds, the value exchanged will be the exact same value that is
    // already present, and therefore no actual value change will occur. That
    // is the point, since the compare/exchange is only being used to extract
    // the current value in an interlocked manner, not to actually change it.
    //
    Zero = 0;
    //
    // It is assumed that reading a ULONG value can be done without interlocking.
    //
    switch (LocalDefaultClock->State) {

    //case KSSTATE_STOP:
    //case KSSTATE_ACQUIRE:
    //case KSSTATE_PAUSE:
    default:
        //
        // Get the last running clock value. The last running time already has
        // been adjusted for clock frequency. Does not matter if the exchange
        // succeeds or fails, just the result. If the compare happens to succeed,
        // then the value is just replaced with the same value, so no change is
        // actually made.
        //
        return ExInterlockedCompareExchange64(
            (PULONGLONG)&LocalDefaultClock->LastRunningTime,
            &Zero,
            &Zero,
            &LocalDefaultClock->TimeAccessLock);

    case KSSTATE_RUN:
        //
        // Get the current performance time, and subtract the current delta to
        // return the real clock time. Does not matter if the exchange succeeds
        // or fails, just the result. If the compare happens to succeed, then
        // the value is just replaced with the same value, so no change is
        // actually made.
        //
        PerformanceTime = KeQueryPerformanceCounter(NULL);
        return KSCONVERT_PERFORMANCE_TIME(LocalDefaultClock->Frequency, PerformanceTime) -
            ExInterlockedCompareExchange64(
                (PULONGLONG)&LocalDefaultClock->RunningTimeDelta,
                &Zero,
                &Zero,
                &LocalDefaultClock->TimeAccessLock);

    }
}


KSDDKAPI
VOID
NTAPI
KsSetDefaultClockTime(
    IN PKSDEFAULTCLOCK DefaultClock,
    IN LONGLONG Time
    )
/*++

Routine Description:

    Sets the current time of the clock. This modifies the current time returned
    by the clock.

    The owner of the default clock is expected to serialize access to this
    function and to KsSetDefaultClockState.

    If an external clock is used, this function can still be used to force a
    resetting of the current timer when an external timer is not being used.
    In this case the time provided is ignored and must be set to zero.

    This may be called at DISPATCH_LEVEL.

Arguments:

    DefaultClock -
        Contains an initialize Default Clock structure which is shared amongst
        any instance of the default clock for the parent.

    Time -
        Contains the new time to set the clock to.

Return Value:

    Nothing.

--*/
{
    PKSIDEFAULTCLOCK LocalDefaultClock;

    LocalDefaultClock = (PKSIDEFAULTCLOCK)DefaultClock;
    ASSERT((!LocalDefaultClock->CorrelatedTime || !Time) && "The clock owner passed an invalid time value");
    switch (LocalDefaultClock->State) {

    //case KSSTATE_STOP:
    //case KSSTATE_ACQUIRE:
    //case KSSTATE_PAUSE:
    default:
        //
        // If the clock is not running, just set the last position.
        //
        ExInterlockedCompareExchange64(
            (PULONGLONG)&LocalDefaultClock->LastRunningTime,
            (PULONGLONG)&Time,
            (PULONGLONG)&LocalDefaultClock->LastRunningTime,
            &LocalDefaultClock->TimeAccessLock);
        break;

    case KSSTATE_RUN:
        //
        // Else query the current performance time in order to generate the
        // new time base delta. If an external time source is used, the
        // Time parameter is zero.
        //

#if 1
        if (!LocalDefaultClock->CorrelatedTime) {
            LARGE_INTEGER PerformanceTime;
            LONGLONG TimeTold = Time;

            PerformanceTime = KeQueryPerformanceCounter(NULL);
            Time = KSCONVERT_PERFORMANCE_TIME(LocalDefaultClock->Frequency, PerformanceTime) - Time;

        #ifdef CREATE_A_FLURRY_OF_TIMING_SPEW
        DbgPrint("KsClock: TPassed=%I64d, T=%I64d,  PerfT=%I64d\n", 
                     TimeTold,
                     Time,
                     PerformanceTime.QuadPart
                 );
        #endif
            ExInterlockedCompareExchange64(
               (PULONGLONG)&LocalDefaultClock->RunningTimeDelta,
               (PULONGLONG)&Time,
               (PULONGLONG)&LocalDefaultClock->RunningTimeDelta,
               &LocalDefaultClock->TimeAccessLock);            

        }

#else

        if (!LocalDefaultClock->CorrelatedTime) {
            LARGE_INTEGER PerformanceTime;
            LONGLONG SystemTime, ToldSystemTime;
            LONGLONG liTimeGlitch;
            KIRQL  irql;    

            //
            // There are severe jitters sometimes ( 200ms ) for the caller
            // to reach us from ring3. We got the 
            // time so late that we need to smooth it out
            // instead of abruptly change the value.
            //
            PerformanceTime = KeQueryPerformanceCounter(NULL);
            SystemTime = KSCONVERT_PERFORMANCE_TIME(LocalDefaultClock->Frequency, PerformanceTime);

            KeAcquireSpinLock( &LocalDefaultClock->TimeAccessLock, &irql );

            ToldSystemTime = Time + LocalDefaultClock->RunningTimeDelta;

            liTimeGlitch = SystemTime - ToldSystemTime;

            #define MAX_TIME_ADJUSTMENT 10*10000 // 10 mS.
            
            if ( ( liTimeGlitch <= MAX_TIME_ADJUSTMENT &&
                   liTimeGlitch >= -MAX_TIME_ADJUSTMENT) ||
                 ( 0 == LocalDefaultClock->RunningTimeDelta ) ) {
                LocalDefaultClock->RunningTimeDelta += liTimeGlitch;
            }
            
            else if ( liTimeGlitch > MAX_TIME_ADJUSTMENT ) {              
                LocalDefaultClock->RunningTimeDelta += MAX_TIME_ADJUSTMENT;
            }

            else /*if ( liTimeGlitch < -MAX_TIME_ADJUSTMENT )*/ {
                LocalDefaultClock->RunningTimeDelta -= MAX_TIME_ADJUSTMENT;
            }

            // johnlee testing
            DbgPrint( "KsClock: TPass=%10I64d, TGlitch=%10I64d, TSys=%10I64d TStart=%10I64d\n",
                      Time,
                      liTimeGlitch,
                      SystemTime,
                      LocalDefaultClock->RunningTimeDelta);

            KeReleaseSpinLock( &LocalDefaultClock->TimeAccessLock, irql );            

        }
#endif
        //
        // Since this is a new time, the current timer Dpc is incorrect.
        //
        DefRescheduleDefaultClockTimer(LocalDefaultClock);
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\ks\device.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    device.c

Abstract:

    This module contains the unused device entry point.

--*/

#define IRPMJFUNCDESC
#define KSDEBUG_INIT

#include "ksp.h"

#ifdef ALLOC_PRAGMA
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPathName
    );

#pragma alloc_text(INIT, DriverEntry)
#endif // ALLOC_PRAGMA


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPathName
    )
/*++

Routine Description:

    Unused entry point.

Arguments:

    DriverObject -
        Not used.

    RegistryPathName -
        Not used.

Return Value:

    Returns STATUS_SUCCESS, but is not called.

--*/
{
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\ks\busenum.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    busenum.c

Abstract:

    Demand load device enumerator services.
    
Author:

    Bryan A. Woodruff (bryanw) 20-Feb-1997

--*/

#include <strsafe.h>
#include "ksp.h"

typedef struct _WORKER_CONTEXT
{
    PIRP        Irp;
    KEVENT      CompletionEvent;
    NTSTATUS    Status;

} WORKER_CONTEXT, *PWORKER_CONTEXT;

#ifdef ALLOC_PRAGMA
NTSTATUS 
IssueReparseForIrp(
    IN PIRP Irp,
    IN PDEVICE_REFERENCE DeviceReference
    );
VOID
CompletePendingIo(
    IN PDEVICE_REFERENCE DeviceReference,
    IN PFAST_MUTEX DeviceListMutex,
    IN NTSTATUS Status
    );
LARGE_INTEGER
ComputeNextSweeperPeriod(
    IN PFDO_EXTENSION FdoExtension
    );
VOID
EnableDeviceInterfaces(
    IN PDEVICE_REFERENCE DeviceReference,
    IN BOOLEAN EnableState
    );
VOID 
InterfaceReference(
    IN PPDO_EXTENSION PdoExtension
    );
VOID 
InterfaceDereference(
    IN PPDO_EXTENSION PdoExtension
    );
VOID 
ReferenceDeviceObject(
    IN PPDO_EXTENSION PdoExtension
    );
VOID 
DereferenceDeviceObject(
    IN PPDO_EXTENSION PdoExtension
    );
NTSTATUS 
QueryReferenceString(
    IN PPDO_EXTENSION PdoExtension,
    IN OUT PWCHAR *String
    );
NTSTATUS
OpenDeviceInterfacesKey(
    OUT PHANDLE DeviceInterfacesKey,
    IN PUNICODE_STRING BaseRegistryPath
    );
NTSTATUS 
EnumerateRegistrySubKeys(
    IN HANDLE ParentKey,
    IN PWCHAR Path OPTIONAL,
    IN PFNREGENUM_CALLBACK EnumCallback,
    IN PVOID EnumContext
    );
NTSTATUS 
EnumerateDeviceReferences(
    IN HANDLE DeviceListKey,
    IN PUNICODE_STRING KeyName,
    IN PVOID EnumContext
    );
VOID
KspInstallBusEnumInterface(
    IN PWORKER_CONTEXT WorkerContext
    );
VOID
KspRemoveBusEnumInterface(
    IN PWORKER_CONTEXT WorkerContext
    );

#pragma alloc_text( PAGE, BuildBusId )
#pragma alloc_text( PAGE, BuildInstanceId )
#pragma alloc_text( PAGE, ClearDeviceReferenceMarks )
#pragma alloc_text( PAGE, CreateDeviceAssociation )
#pragma alloc_text( PAGE, CreateDeviceReference )
#pragma alloc_text( PAGE, CreatePdo )
#pragma alloc_text( PAGE, RemoveInterface )
#pragma alloc_text( PAGE, InstallInterface )
#pragma alloc_text( PAGE, KspRemoveBusEnumInterface )
#pragma alloc_text( PAGE, KsRemoveBusEnumInterface )
#pragma alloc_text( PAGE, ScanBus )
#pragma alloc_text( PAGE, QueryDeviceRelations )
#pragma alloc_text( PAGE, QueryId )
#pragma alloc_text( PAGE, RegisterDeviceAssociation )
#pragma alloc_text( PAGE, RemoveDevice )
#pragma alloc_text( PAGE, RemoveDeviceAssociations )
#pragma alloc_text( PAGE, RemoveUnreferencedDevices )
#pragma alloc_text( PAGE, SweeperWorker )
#pragma alloc_text( PAGE, EnableDeviceInterfaces )
#pragma alloc_text( PAGE, IssueReparseForIrp )
#pragma alloc_text( PAGE, CompletePendingIo )
#pragma alloc_text( PAGE, InterfaceReference )
#pragma alloc_text( PAGE, InterfaceDereference )
#pragma alloc_text( PAGE, ReferenceDeviceObject )
#pragma alloc_text( PAGE, ComputeNextSweeperPeriod )
#pragma alloc_text( PAGE, DereferenceDeviceObject )
#pragma alloc_text( PAGE, QueryReferenceString )
#pragma alloc_text( PAGE, StartDevice )
#pragma alloc_text( PAGE, OpenDeviceInterfacesKey )
#pragma alloc_text( PAGE, EnumerateRegistrySubKeys )
#pragma alloc_text( PAGE, EnumerateDeviceReferences )
#pragma alloc_text( PAGE, KsCreateBusEnumObject )
#pragma alloc_text( PAGE, KsGetBusEnumPnpDeviceObject )
#pragma alloc_text( PAGE, KspInstallBusEnumInterface )
#pragma alloc_text( PAGE, KsInstallBusEnumInterface )
#pragma alloc_text( PAGE, KsIsBusEnumChildDevice )
#pragma alloc_text( PAGE, KsServiceBusEnumCreateRequest )
#pragma alloc_text( PAGE, KsServiceBusEnumPnpRequest )
#pragma alloc_text( PAGE, KsGetBusEnumIdentifier )
#pragma alloc_text( PAGE, KsGetBusEnumParentFDOFromChildPDO )
#endif

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA

static const WCHAR BusIdFormat[] = L"%s\\%s%c";

static const WCHAR BusReferenceStringFormat[] = L"%s&%s";

static const WCHAR DeviceCreateFileFormat[] = L"%s\\%s";

#if !defined( INVALID_HANDLE_VALUE )
    #define INVALID_HANDLE_VALUE ((HANDLE)-1)
#endif

static const WCHAR DeviceReferencePrefix[] = L"\\Device\\KSENUM#%08x";
static const WCHAR ServicesPath[] = L"\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Services";
#if !defined( WIN9X_KS )
static const WCHAR ServicesRelativePathFormat[] = L"%s\\%s\\%s";
static const WCHAR ServicesPathFormat[] = L"%s\\%s";
#else
static const WCHAR ServicesRelativePathFormat[] = L"%s\\%s";
static const WCHAR ServicesPathFormat[] = L"%s";
#endif

static ULONG UniqueId = 0;

#define _100NS_IN_MS (10*1000)

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif // ALLOC_DATA_PRAGMA


KSDDKAPI
NTSTATUS
NTAPI
KsCreateBusEnumObject(
    IN PWCHAR BusIdentifier,
    IN PDEVICE_OBJECT BusDeviceObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN PDEVICE_OBJECT PnpDeviceObject OPTIONAL,
    IN REFGUID InterfaceGuid OPTIONAL,
    IN PWCHAR ServiceRelativePath OPTIONAL
    )

/*++

Routine Description:
    The demand-load bus enumerator object extends a Plug and Play device by 
    servicing bus enumerator queries via the KsServiceBusEnumPnpRequest() 
    function for the given functional device object.  This function creates
    a demand-load bus enumerator object and initializes it for use with the
    demand-load bus enumerator services.

Arguments:
    IN PWCHAR BusIdentifier -
        a string prefix (wide-character) identifier for the bus such 
        as L"SW" or L"KSDSP".  This prefix is used to create the unique 
        hardware identifier for the device such as 
        SW\{cfd669f1-9bc2-11d0-8299-0000f822fe8a}.

    IN PDEVICE_OBJECT BusDeviceObject -
        The functional device object for this bus.  This is the device object
        created and attached the physical device object for this device.  
        
        N.B. The first PVOID of the device extension of this device object 
        must be reserved for the resultant demand-load bus enumerator object.

    IN PDEVICE_OBJECT PhysicalDeviceObject -
        The Plug and Play supplied physical device object for this device.

    IN PDEVICE_OBJECT PnpDeviceObject OPTIONAL -
        Optionally specifies the driver stack to forward Plug and Play IRPs.  
        If this parameter is not specified, the BusDeviceObject is attached to
        the PhysicalDeviceObject and the resulting device object from that
        operation is used to forward IRPs.

    IN REFGUID InterfaceGuid OPTIONAL -
        An interface GUID with which the demand-load bus enum object is
        associated.  This associates the bus with a device interface which
        is enumerable through Io* or SetupApi* services for device interfaces.
        This allows a driver to expose an interface with which clients 
        (user-mode or kernel-mode) can register new demand-load devices.

    IN PWCHAR ServiceRelativePath OPTIONAL -
        If specified, provides a path where a hierarchy of interfaces and 
        device identifiers is stored.  For example "Devices" will store
        the list of supported intefaces and devices in a path relative
        to the services key for this bus such as:
        
        REGISTRY\MACHINE\SYSTEM\CurrentControlSet\Services\SWENUM\Devices.

Return:
    STATUS_SUCCESS if successful, otherwise an appropriate error code.

--*/


{

    NTSTATUS            Status;
    PFDO_EXTENSION      FdoExtension;
    ULONG               FdoExtensionSize;
    USHORT              Length;

    PAGED_CODE();
    
    _DbgPrintF( DEBUGLVL_VERBOSE, ("KsCreateBusEnumObject()") );
    
    //
    // Note, FDO_EXTENSION includes the size of the UNICODE_NULL
    // for BusPrefix.
    //
    FdoExtensionSize =
        sizeof( FDO_EXTENSION ) +
            (wcslen( BusIdentifier ) * sizeof( WCHAR ));

    FdoExtension =
        ExAllocatePoolWithTag( 
            NonPagedPool, 
            FdoExtensionSize,
            POOLTAG_DEVICE_FDOEXTENSION );
    
    if (NULL == FdoExtension) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }        

    //
    // N.B.: 
    //
    // SWENUM uses the first PVOID in the device extension -- any 
    // client using SWENUM services must reserve this area for 
    // SWENUM storage.
    //     

    ASSERT( (*(PVOID *)BusDeviceObject->DeviceExtension) == NULL );    
    *(PFDO_EXTENSION *)BusDeviceObject->DeviceExtension = FdoExtension;
    RtlZeroMemory( FdoExtension, sizeof( FDO_EXTENSION ) );

    if (FAILED( StringCbCopy(
                    FdoExtension->BusPrefix,
                    FdoExtensionSize -
                        sizeof( FDO_EXTENSION ) + sizeof( WCHAR ),
                    BusIdentifier ) )) {
        ExFreePool( FdoExtension );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Save the registry path location to the device listing
    //
    
    Length = 
        BusDeviceObject->DriverObject->DriverExtension->ServiceKeyName.MaximumLength +
        sizeof( ServicesPath ) +
        sizeof( UNICODE_NULL );
    
    if (ServiceRelativePath) {
        Length += wcslen( ServiceRelativePath ) * sizeof( WCHAR );
    }
    
    FdoExtension->BaseRegistryPath.Buffer =
        ExAllocatePoolWithTag( 
            PagedPool, 
            Length,
            POOLTAG_DEVICE_DRIVER_REGISTRY );

    if (NULL == FdoExtension->BaseRegistryPath.Buffer) {
        ExFreePool( FdoExtension );
        return STATUS_INSUFFICIENT_RESOURCES;
    }
            
    FdoExtension->BaseRegistryPath.MaximumLength = Length;
        
    //
    // If the caller specified a service relative path, then append this
    // to the HKLM\CurrentControlSet\Services\{service-name} path.
    //       
#if defined( WIN9X_KS)
    if (ServiceRelativePath) {
        if (FAILED(
                StringCbPrintf(
                    FdoExtension->BaseRegistryPath.Buffer,
                    FdoExtension->BaseRegistryPath.MaximumLength,
                    ServicesRelativePathFormat,
                    BusDeviceObject->DriverObject->DriverExtension->ServiceKeyName.Buffer,
                    ServiceRelativePath ) )) {
            ExFreePool( FdoExtension->BaseRegistryPath.Buffer );
            ExFreePool( FdoExtension );
            return STATUS_UNSUCCESSFUL;
        }

    } else {
        if (FAILED(
                StringCbPrintf(
                    FdoExtension->BaseRegistryPath.Buffer,
                    FdoExtension->BaseRegistryPath.MaximumLength,
                    ServicesPathFormat,
                    BusDeviceObject->DriverObject->DriverExtension->ServiceKeyName.Buffer ) )) {
            ExFreePool( FdoExtension->BaseRegistryPath.Buffer );
            ExFreePool( FdoExtension );
            return STATUS_UNSUCCESSFUL;
        }
#else        
    if (ServiceRelativePath) {
        if (FAILED(
                StringCbPrintf(
                    FdoExtension->BaseRegistryPath.Buffer,
                    FdoExtension->BaseRegistryPath.MaximumLength,
                    ServicesRelativePathFormat,
                    ServicesPath,
                    BusDeviceObject->DriverObject->DriverExtension->ServiceKeyName.Buffer,
                    ServiceRelativePath ) )) {
            ExFreePool( FdoExtension->BaseRegistryPath.Buffer );
            ExFreePool( FdoExtension );
            return STATUS_UNSUCCESSFUL;
        }
    } else {
        if (FAILED(
                StringCbPrintf(
                    FdoExtension->BaseRegistryPath.Buffer,
                    FdoExtension->BaseRegistryPath.MaximumLength,
                    ServicesPathFormat,
                    ServicesPath,
                    BusDeviceObject->DriverObject->DriverExtension->ServiceKeyName.Buffer ) )) {
            ExFreePool( FdoExtension->BaseRegistryPath.Buffer );
            ExFreePool( FdoExtension );
            return STATUS_UNSUCCESSFUL;
        }
    }
#endif

    FdoExtension->BaseRegistryPath.Length =
        wcslen( FdoExtension->BaseRegistryPath.Buffer ) * sizeof( WCHAR );

    //
    // Automatically register the interface to this DO if specified.
    //    
    
    if (InterfaceGuid) {
        Status = 
            IoRegisterDeviceInterface(
                PhysicalDeviceObject,
                InterfaceGuid,
                NULL,
                &FdoExtension->linkName);

        //
        // Set up the device interface association (e.g. symbolic link).
        //
        
        if (NT_SUCCESS( Status )) {
            _DbgPrintF( 
                DEBUGLVL_VERBOSE, 
                ("linkName = %S", FdoExtension->linkName.Buffer) );

            Status = 
                IoSetDeviceInterfaceState(
                    &FdoExtension->linkName, 
                    TRUE );
            _DbgPrintF(               
                DEBUGLVL_VERBOSE, 
                ("IoSetDeviceInterfaceState = %x", Status) );
        
            if (!NT_SUCCESS( Status )) {
                ExFreePool( FdoExtension->linkName.Buffer );
            }        
        }

        if (!NT_SUCCESS( Status )) {
            ExFreePool( FdoExtension->BaseRegistryPath.Buffer );
            ExFreePool( FdoExtension );
            return Status;
        }
    } else {
        Status = STATUS_SUCCESS;
    }    

    //
    // Initialize critical members of the device extension.
    //

    ExInitializeFastMutex( &FdoExtension->DeviceListMutex );
    KeInitializeTimer( &FdoExtension->SweeperTimer );
    KeInitializeDpc( 
        &FdoExtension->SweeperDpc, 
        SweeperDeferredRoutine, 
        FdoExtension );
    ExInitializeWorkItem( 
        &FdoExtension->SweeperWorkItem,         
        SweeperWorker,
        FdoExtension );
        
    FdoExtension->ExtensionType = ExtensionTypeFdo;
    FdoExtension->PhysicalDeviceObject = PhysicalDeviceObject;
    FdoExtension->FunctionalDeviceObject = BusDeviceObject;
    InitializeListHead( &FdoExtension->DeviceReferenceList );
    
    //
    // If the caller has not specified a PnpDeviceObject, then go
    // ahead and attach the bus device object to the PDO.  Otherwise,
    // it is assumed that the caller has done or will do so.
    //
    
    if (PnpDeviceObject) {
        FdoExtension->PnpDeviceObject = PnpDeviceObject;
    } else {
        FdoExtension->PnpDeviceObject =
            IoAttachDeviceToDeviceStack( 
                BusDeviceObject, 
                PhysicalDeviceObject );
        if (FdoExtension->PnpDeviceObject) {
            FdoExtension->AttachedDevice = TRUE;
        } else {
            Status = STATUS_DEVICE_REMOVED;
        }
    }
    if (NT_SUCCESS( Status )) {
        //
        // Obtain counter frequency and compute the maximum timeout.
        //

        KeQueryPerformanceCounter( &FdoExtension->CounterFrequency );

        FdoExtension->MaximumTimeout.QuadPart =
            MAXIMUM_TIMEOUT_IN_SECS * FdoExtension->CounterFrequency.QuadPart;

        //
        // The power code is pagable.
        //
    
        BusDeviceObject->Flags |= DO_POWER_PAGABLE;
    
        Status = ScanBus( BusDeviceObject );
    }
    if (!NT_SUCCESS( Status )) {
    
        //
        // Failure, perform cleanup.
        //
    
        if (FdoExtension->linkName.Buffer) {
        
            //
            // Remove device interface association...
            //
            
            IoSetDeviceInterfaceState( &FdoExtension->linkName, FALSE );
        
            //
            // and free the symbolic link.
            //
            
            ExFreePool( FdoExtension->linkName.Buffer );
        }
        
        //
        // Delete the copy of the registry path.
        // 
        
        ExFreePool( FdoExtension->BaseRegistryPath.Buffer );
        
        //
        // Detach the device if attached.
        //
        
        if (FdoExtension->AttachedDevice) {
            IoDetachDevice( FdoExtension->PnpDeviceObject );
        }
        
        ExFreePool( FdoExtension );
        
        //
        // Clear the reference in the DeviceExtension to the FDO_EXTENSION
        //
        *(PVOID *)BusDeviceObject->DeviceExtension = NULL;
    }
   
    return Status;
}    


VOID
SweeperDeferredRoutine(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:
    Deferred routine for the sweeper.  Simply queues a work item.

Arguments:
    IN PKDPC Dpc -
        pointer to DPC

    IN PVOID DeferredContext -
        pointer to context 

    IN PVOID SystemArgument1 -
        not used

    IN PVOID SystemArgument2 -
        not used

Return:
    No return value.

--*/

{
    _DbgPrintF( DEBUGLVL_BLAB, ("SweeperDeferredRoutine") );
    ExQueueWorkItem( 
        &((PFDO_EXTENSION) DeferredContext)->SweeperWorkItem,
        CriticalWorkQueue );
}


NTSTATUS 
IssueReparseForIrp(
    IN PIRP Irp,
    IN PDEVICE_REFERENCE DeviceReference
    )

/*++

Routine Description:
    Completes the given IRP to reparse to the actual device path as
    describe in the device reference and device association.   

    N.B.: 
        This routine requires that the DeviceListMutex has been acquired.
        
Arguments:
    IN PIRP Irp - 
        I/O request packet

    IN PDEVICE_REFERENCE DeviceReference -
        pointer to the device reference structure

Return:
    Status return value as no return value

--*/

{
    NTSTATUS                Status = STATUS_UNSUCCESSFUL;
    PIO_STACK_LOCATION      irpSp;
    USHORT                  ReparseDataLength;
    
    irpSp = IoGetCurrentIrpStackLocation( Irp );
    
    //
    // Mark this device reference as active.
    //
    
    DeviceReference->SweeperMarker = SweeperDeviceActive;

    //
    // Reset the timeout for this device reference.
    //

    DeviceReference->TimeoutRemaining = DeviceReference->TimeoutPeriod;

    //
    // Reparse to the real PDO.
    //
    
    ReparseDataLength = 
        (wcslen( DeviceReference->DeviceName ) +
         wcslen( DeviceReference->DeviceReferenceString ) + 2) *
               sizeof( WCHAR );

    if (irpSp->FileObject->FileName.MaximumLength < ReparseDataLength) {
        ExFreePool( irpSp->FileObject->FileName.Buffer );
        
        irpSp->FileObject->FileName.Buffer =
            ExAllocatePoolWithTag( 
                PagedPool, 
                ReparseDataLength,
                POOLTAG_DEVICE_REPARSE_STRING );
            
        if (NULL == irpSp->FileObject->FileName.Buffer) {
            _DbgPrintF( 
                DEBUGLVL_VERBOSE, 
                ("failed to reallocate filename buffer for reparse") );
            Status =         
                Irp->IoStatus.Status = 
                    STATUS_INSUFFICIENT_RESOURCES;
             irpSp->FileObject->FileName.Length =
                irpSp->FileObject->FileName.MaximumLength = 0;
             
        } else {
            irpSp->FileObject->FileName.MaximumLength = ReparseDataLength;
        }
    }    

    if (irpSp->FileObject->FileName.Buffer) {

        if (FAILED( StringCbPrintf(
                        irpSp->FileObject->FileName.Buffer,
                        ReparseDataLength,
                        DeviceCreateFileFormat,
                        DeviceReference->DeviceName,
                        DeviceReference->DeviceReferenceString ) )) {

            ExFreePool( irpSp->FileObject->FileName.Buffer );
            irpSp->FileObject->FileName.Buffer = NULL;
            irpSp->FileObject->FileName.Length =
                irpSp->FileObject->FileName.MaximumLength = 0;
            Status =
                Irp->IoStatus.Status = 
                    STATUS_INSUFFICIENT_RESOURCES;
        } else {

            irpSp->FileObject->FileName.Length =
                wcslen( irpSp->FileObject->FileName.Buffer ) *
                    sizeof( WCHAR );

            _DbgPrintF(
                DEBUGLVL_VERBOSE,
                ("reparse to: %S", irpSp->FileObject->FileName.Buffer) );

            Irp->IoStatus.Information = IO_REPARSE;
        
            Status =
                Irp->IoStatus.Status =
                STATUS_REPARSE;
        }
    }

    return Status;
}


VOID
CompletePendingIo(
    IN PDEVICE_REFERENCE DeviceReference,
    IN PFAST_MUTEX DeviceListMutex OPTIONAL,
    IN NTSTATUS Status
    )

/*++

Routine Description:
    Walks the I/O queue, completing pending I/O with the given status
    code.

Arguments:
    IN PDEVICE_REFERENCE DeviceReference -
        pointer to the device reference

    IN PFAST_MUTEX DeviceListMutex OPTIONAL -
        pointer to optional mutex to lock while walking the I/O list
    
    IN NTSTATUS Status -
        status for Irp

Return:
    Nothing.

--*/

{
    PIRP                Irp;
    PLIST_ENTRY         ListEntry;

    if (DeviceListMutex) {
        KeEnterCriticalRegion();
        ExAcquireFastMutexUnsafe( DeviceListMutex );
    }
    
    while (!IsListEmpty( &DeviceReference->IoQueue )) {
        
        ListEntry = RemoveHeadList( &DeviceReference->IoQueue );
        Irp = 
            CONTAINING_RECORD( ListEntry, IRP, Tail.Overlay.ListEntry );
        //
        // Note: If while processing of the IoQueue, a failure is experienced
        // during a reparse, the subsequent IRPs will be failed with the same
        // status code.
        //
        if (Status == STATUS_REPARSE) {
            Status = 
                IssueReparseForIrp( Irp, DeviceReference );
        }
        Irp->IoStatus.Status = Status;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
    }

    if (DeviceListMutex) {
        ExReleaseFastMutexUnsafe( DeviceListMutex );    
        KeLeaveCriticalRegion();
    }
}


VOID
EnableDeviceInterfaces(
    PDEVICE_REFERENCE DeviceReference,
    BOOLEAN EnableState
    )

/*++

Routine Description:
    Walks the device associations and enables or disables 
    the device interfaces.

Arguments:
    PDEVICE_REFERENCE DeviceReference -
        pointer to the device reference

    BOOLEAN EnableState -
        TRUE if enabling, FALSE otherwise

Return:
    Nothing.

--*/

{

    PDEVICE_ASSOCIATION DeviceAssociation;
    
    PAGED_CODE();
    
    //
    // Walk the associated list of device interface aliases
    //
    
    for (DeviceAssociation =
            (PDEVICE_ASSOCIATION) DeviceReference->DeviceAssociations.Flink;
         DeviceAssociation != 
            (PDEVICE_ASSOCIATION) &DeviceReference->DeviceAssociations;
         DeviceAssociation = (PDEVICE_ASSOCIATION) DeviceAssociation->ListEntry.Flink) {

        if (DeviceAssociation->linkName.Buffer) {
        
            //
            // Enable or disable the interface
            //
            
            IoSetDeviceInterfaceState( 
                &DeviceAssociation->linkName, EnableState );    
        }
    }
}


VOID 
SweeperWorker(
    IN PVOID Context
    )

/*++

Routine Description:
    Sweeper work item handler.  This routine actually performs the
    work of sweeping the device reference list and marking devices
    for deletion.

Arguments:
    IN PVOID Context -
        pointer to context

Return:
    No return value.

--*/

{

    BOOLEAN             RescheduleTimer = FALSE;
    PDEVICE_REFERENCE   DeviceReference;
    PFDO_EXTENSION      FdoExtension = (PFDO_EXTENSION) Context;
    LARGE_INTEGER       TimerPeriod;
    
    _DbgPrintF( DEBUGLVL_BLAB, ("SweeperWorker") );
    
    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe( &FdoExtension->DeviceListMutex );    

    //
    // While walking the device reference list, the next timeout period
    // is computed as the minimum of the remaining timeout periods for
    // all device references.
    //
    
    TimerPeriod.QuadPart = MAXLONGLONG;

    for (DeviceReference =
            (PDEVICE_REFERENCE) FdoExtension->DeviceReferenceList.Flink;
         DeviceReference != 
            (PDEVICE_REFERENCE) &FdoExtension->DeviceReferenceList;
         DeviceReference = (PDEVICE_REFERENCE) DeviceReference->ListEntry.Flink) {
         
        if ((DeviceReference->PhysicalDeviceObject) &&
            (DeviceReference->SweeperMarker == SweeperDeviceActive)) {
            
            PPDO_EXTENSION PdoExtension;
            
            PdoExtension = 
                *(PPDO_EXTENSION *)
                    DeviceReference->PhysicalDeviceObject->DeviceExtension;
            if (!PdoExtension->DeviceReferenceCount && 
                (DeviceReference->State != ReferenceFailedStart)) {
                LONGLONG TimeDelta;

                //
                // Compute the remaining timeout using the current time.
                // If the timeout has expired, mark this device for removal.
                //

                TimeDelta = 
                    KeQueryPerformanceCounter( NULL ).QuadPart -
                        DeviceReference->IdleStartTime.QuadPart;

                //
                // Watch for roll-over in the timer.
                //

                if (TimeDelta < 0) {
                    TimeDelta += MAXLONGLONG;
                }

                DeviceReference->TimeoutRemaining.QuadPart =
                    DeviceReference->TimeoutPeriod.QuadPart - TimeDelta;

                if (DeviceReference->TimeoutRemaining.QuadPart <= 0) {

                    DeviceReference->SweeperMarker = SweeperDeviceRemoval;

                    _DbgPrintF( 
                        DEBUGLVL_VERBOSE, 
                        ("DeviceReference: %x, timed out", DeviceReference) );
                
                    if (DeviceReference->State < ReferenceWaitingForStart) {

                        _DbgPrintF( 
                            DEBUGLVL_TERSE, 
                            ("DeviceReference: %x, failed to start", DeviceReference) );

                        //
                        // This device has not responded -- thus, installation
                        // failed or it failed to start. 
                        //
                        
                        //    
                        // Keep this PDO in tact so that Plug-And-Play will 
                        // continue to see the device as installed.  Hopefully, 
                        // it will attempt to complete the installation of this
                        // device.
                        //
                        
                        DeviceReference->State = ReferenceFailedStart;

                        DeviceReference->SweeperMarker = SweeperDeviceActive;
                        
                        _DbgPrintF( 
                            DEBUGLVL_VERBOSE, 
                            ("disabling device interfaces for device reference: %x", DeviceReference) );
                        
                        EnableDeviceInterfaces( DeviceReference, FALSE );

                        // Complete any pending I/O with failure.
                        
                        CompletePendingIo( 
                            DeviceReference, NULL, STATUS_OBJECT_NAME_NOT_FOUND );
                        
                    } else {
                    
                        _DbgPrintF( 
                            DEBUGLVL_BLAB, 
                            ("marked %08x for removal", DeviceReference->PhysicalDeviceObject) );

                        //
                        // This device has been marked for removal, request
                        // a bus reenumeration.
                        //
                        IoInvalidateDeviceRelations( 
                            FdoExtension->PhysicalDeviceObject,
                            BusRelations );
                    }                            
                } else {
                    //
                    // A timer will be rescheduled, compute the minimum timeout
                    // period required.
                    //
                    TimerPeriod.QuadPart =
                        min( 
                            TimerPeriod.QuadPart, 
                            DeviceReference->TimeoutRemaining.QuadPart 
                        );
                    RescheduleTimer = TRUE;
                }
            }
        }
    }    

    ExReleaseFastMutexUnsafe( &FdoExtension->DeviceListMutex );    
    KeLeaveCriticalRegion();

    //
    // Continuing sweeping the device list while we have devices
    // without device object references.
    //
    
    if (RescheduleTimer) {
    
        //
        // Reschedule the timer to attempt a removal later.
        // 

        TimerPeriod.QuadPart =
            -1L *
            (LONGLONG)
                KSCONVERT_PERFORMANCE_TIME(
                    FdoExtension->CounterFrequency.QuadPart, 
                    TimerPeriod );


        if (!TimerPeriod.QuadPart) {
            TimerPeriod.QuadPart = SWEEPER_TIMER_FREQUENCY;
        }

        _DbgPrintF( 
            DEBUGLVL_VERBOSE, 
            ("setting timer for %d ms", 
                ((TimerPeriod.QuadPart * -1L) / _100NS_IN_MS)) );

        KeSetTimer( 
            &FdoExtension->SweeperTimer,
            TimerPeriod,
            &FdoExtension->SweeperDpc );
    }        
    else {
        InterlockedExchange( &FdoExtension->TimerScheduled, FALSE );
    }

    _DbgPrintF( DEBUGLVL_BLAB, ("SweeperWorker, exit") );
}    


VOID 
InterfaceReference(
    IN PPDO_EXTENSION PdoExtension
    )

/*++

Routine Description:
    This is the standard bus interface reference function.

Arguments:
    IN PPDO_EXTENSION PdoExtension -
        pointer to the PDO extension
        
Return:
    Nothing.

--*/

{
    PAGED_CODE();
    ASSERT( PdoExtension->ExtensionType == ExtensionTypePdo );
    
    _DbgPrintF( 
        DEBUGLVL_BLAB,
        ("Referencing interface") );
    InterlockedIncrement( 
        &PdoExtension->BusDeviceExtension->InterfaceReferenceCount );
}


VOID 
InterfaceDereference(
    IN PPDO_EXTENSION PdoExtension
    )

/*++

Routine Description:
    This is the standard bus interface dereference function.

Arguments:
    IN PPDO_EXTENSION PdoExtension -
        pointer to the PDO extension
        
Return:
    Nothing.

--*/

{
    PAGED_CODE();
    ASSERT( PdoExtension->ExtensionType == ExtensionTypePdo );
    _DbgPrintF( 
        DEBUGLVL_BLAB,
        ("Dereferencing interface") );
    InterlockedDecrement( 
        &PdoExtension->BusDeviceExtension->InterfaceReferenceCount );
}


VOID 
ReferenceDeviceObject(
    IN PPDO_EXTENSION PdoExtension
    )

/*++

Routine Description:
    Increments the reference count for the given physical device object.
    This assures that the device object will remain active and enumerated 
    by SWENUM until the reference count returns to 0.

Arguments:
    IN PPDO_EXTENSION PdoExtension -
        pointer to the PDO extension
        
Return:
    Nothing.

--*/

{
    PAGED_CODE();
    ASSERT( PdoExtension->ExtensionType == ExtensionTypePdo );
    InterlockedIncrement( &PdoExtension->DeviceReferenceCount );

    _DbgPrintF( 
        DEBUGLVL_BLAB,
        ("Referenced PDO: %d", PdoExtension->DeviceReferenceCount) );
}


LARGE_INTEGER
ComputeNextSweeperPeriod(
    IN PFDO_EXTENSION FdoExtension
    )

/*++

Routine Description:
    Computes the next sweeper timeout period based on the requirements of
    the device reference list.

Arguments:
    IN PPDO_EXTENSION FdoExtension -
        pointer to the FDO extension
        
Return:
    Nothing.

--*/

{
    LARGE_INTEGER       TimerPeriod;
    PDEVICE_REFERENCE   DeviceReference;

    TimerPeriod.QuadPart = MAXLONGLONG;

    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe( &FdoExtension->DeviceListMutex );    

    for (DeviceReference =
            (PDEVICE_REFERENCE) FdoExtension->DeviceReferenceList.Flink;
         DeviceReference != 
            (PDEVICE_REFERENCE) &FdoExtension->DeviceReferenceList;
         DeviceReference = (PDEVICE_REFERENCE) DeviceReference->ListEntry.Flink) {
         
        if ((DeviceReference->PhysicalDeviceObject) &&
            (DeviceReference->SweeperMarker == SweeperDeviceActive)) {

            PPDO_EXTENSION PdoExtension;

            PdoExtension = 
                *(PPDO_EXTENSION *)
                    DeviceReference->PhysicalDeviceObject->DeviceExtension;
            
            if ((!PdoExtension->DeviceReferenceCount) && 
                (DeviceReference->State != ReferenceFailedStart) &&
                (DeviceReference->TimeoutRemaining.QuadPart)) {

                    //
                    // Compute the minimum timeout period required.
                    //

                    TimerPeriod.QuadPart =
                        min( 
                            TimerPeriod.QuadPart, 
                            DeviceReference->TimeoutRemaining.QuadPart 
                        );
            }
        }
    }    

    ExReleaseFastMutexUnsafe( &FdoExtension->DeviceListMutex );    
    KeLeaveCriticalRegion();

    if (TimerPeriod.QuadPart == MAXLONGLONG) {
        TimerPeriod.QuadPart = SWEEPER_TIMER_FREQUENCY_IN_SECS *
            FdoExtension->CounterFrequency.QuadPart;
    }

    TimerPeriod.QuadPart =
        -1L * 
            (LONGLONG) KSCONVERT_PERFORMANCE_TIME( 
                FdoExtension->CounterFrequency.QuadPart, 
                TimerPeriod );

    return TimerPeriod;
}


VOID 
DereferenceDeviceObject(
    IN PPDO_EXTENSION PdoExtension
    )

/*++

Routine Description:
    Decrements the reference count of the physical device object.  When
    this PDO's reference count is 0 it become eligible for removal.

Arguments:
    IN PPDO_EXTENSION PdoExtension -
        pointer to the PDO extension

Return:
    Nothing.

--*/

{
    PAGED_CODE();
    ASSERT( PdoExtension->ExtensionType == ExtensionTypePdo );
    ASSERT( PdoExtension->DeviceReferenceCount );
    
    if (!InterlockedDecrement( &PdoExtension->DeviceReferenceCount )) {

        PDEVICE_REFERENCE   DeviceReference = PdoExtension->DeviceReference;

        //
        // We have a device that we will attempt to close after sweeping.
        //

        // Reset idle period start.

        DeviceReference->IdleStartTime = KeQueryPerformanceCounter( NULL );

        //
        // Reset the timeout period.  If a timer is not already scheduled,
        // set the timeout based on the requirement for this device.
        //

        DeviceReference->TimeoutRemaining = DeviceReference->TimeoutPeriod;

        if (!InterlockedExchange( 
                &PdoExtension->BusDeviceExtension->TimerScheduled,
                TRUE )) {

            LARGE_INTEGER TimerPeriod;
                
            TimerPeriod = 
                ComputeNextSweeperPeriod( PdoExtension->BusDeviceExtension );

            if (!TimerPeriod.QuadPart) {
                TimerPeriod.QuadPart = SWEEPER_TIMER_FREQUENCY;
            }
            KeSetTimer( 
                &PdoExtension->BusDeviceExtension->SweeperTimer,
                TimerPeriod,
                &PdoExtension->BusDeviceExtension->SweeperDpc );
        }        
    }
    
    _DbgPrintF( 
        DEBUGLVL_BLAB,
        ("Dereferenced PDO: %d", PdoExtension->DeviceReferenceCount) );
}


NTSTATUS 
QueryReferenceString(
    IN PPDO_EXTENSION PdoExtension,
    IN OUT PWCHAR *String
    )

/*++

Routine Description: 
    Creates a buffer from the paged pool and copies the reference string 
    associated with this PDO.  The caller is expected to free this buffer 
    using ExFreePool().

Arguments:
    IN PPDO_EXTENSION PdoExtension -
        pointer to the PDO extension
        
    IN OUT PWCHAR *String -
        pointer to receive an array pointer containing the 
        reference string

Return:
    Nothing.

--*/

{
    ULONG StringLength;

    PAGED_CODE();

    ASSERT( PdoExtension->ExtensionType == ExtensionTypePdo );
    
    StringLength =
        wcslen( PdoExtension->DeviceReference->DeviceReferenceString ) *
            sizeof( WCHAR ) + sizeof( UNICODE_NULL );

    *String =(PWCHAR)
        ExAllocatePoolWithTag( 
            PagedPool,
            StringLength,
            POOLTAG_DEVICE_REFERENCE_STRING );
    
    if (*String == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }        

    if (FAILED( StringCbCopy(
                    *String,
                    StringLength,
                    PdoExtension->DeviceReference->DeviceReferenceString ) )) {
        ExFreePool( *String );
        *String = NULL;
        return STATUS_UNSUCCESSFUL;
    }

    return STATUS_SUCCESS;
}



KSDDKAPI
NTSTATUS
NTAPI
KsServiceBusEnumPnpRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:
    Services the PnP request on behalf of the demand-load bus enumerator
    object as created with KsCreateBusEnumObject().  
    
    N.B. This service does not complete the IRP.

    The following Plug and Play IRPs are handle by this service for the 
    functional device object (FDO) or parent device:

        IRP_MN_START_DEVICE
        IRP_MN_QUERY_BUS_INFORMATION
        IRP_MN_QUERY_DEVICE_RELATIONS
        IRP_MN_QUERY_STOP_DEVICE
        IRP_MN_QUERY_REMOVE_DEVICE
        IRP_MN_CANCEL_STOP_DEVICE
        IRP_MN_CANCEL_REMOVE_DEVICE
        IRP_MN_STOP_DEVICE
        IRP_MN_REMOVE_DEVICE

    The following Plug and Play IRPs are handle by this service for the 
    physical device object (CDO) or child device:
        
        IRP_MN_START_DEVICE
        IRP_MN_QUERY_STOP_DEVICE
        IRP_MN_QUERY_REMOVE_DEVICE
        IRP_MN_STOP_DEVICE
        IRP_MN_REMOVE_DEVICE
        IRP_MN_QUERY_DEVICE_RELATIONS (TargetDeviceRelations)
        IRP_MN_QUERY_PNP_DEVICE_STATE
        IRP_MN_QUERY_ID
        IRP_MN_QUERY_INTERFACE
        IRP_MN_QUERY_RESOURCES
        IRP_MN_QUERY_RESOURCE_REQUIREMENTS
        IRP_MN_READ_CONFIG
        IRP_MN_WRITE_CONFIG
        IRP_MN_QUERY_CAPABILITIES

    
    A caller of this service should first determine if the request is for
    a child or the parent using KsIsBusEnumChildDevice().  If this service
    fails, then complete the IRP with the status code.  Otherwise, call
    this service to perform the initial processing for the bus and if the
    request is for the parent, perform whatever additional processing may
    be necessary for the parent device as demonstrated in the code fragment
    below:

        irpSp = IoGetCurrentIrpStackLocation( Irp );
        
        //
        // Get the PnpDeviceObject and determine FDO/PDO.
        //
        
        Status = KsIsBusEnumChildDevice( DeviceObject, &ChildDevice );

        //
        // If we're unable to obtain any of this information, fail now.
        //    
        
        if (!NT_SUCCESS( Status )) {
            CompleteIrp( Irp, Status, IO_NO_INCREMENT );
            return Status;
        }        

        Status = KsServiceBusEnumPnpRequest( DeviceObject, Irp );    
        
        //
        // FDO processing may return STATUS_NOT_SUPPORTED or may require
        // overrides.  
        //
        
        if (!ChildDevice) {
            NTSTATUS tempStatus;

            //
            // FDO case
            //
            // First retrieve the DO we will forward everything to...
            //
            tempStatus = KsGetBusEnumPnpDeviceObject( DeviceObject, &PnpDeviceObject );

            if (!NT_SUCCESS( tempStatus )) {
                //
                // No DO to forward to. Actually a fatal error, but just complete
                // with an error status.
                //
                return CompleteIrp( Irp, tempStatus, IO_NO_INCREMENT );
            }

            switch (irpSp->MinorFunction) {
        
            case IRP_MN_QUERY_RESOURCES:
            case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
                //
                // This is normally passed on to the PDO, but since this is a 
                // software only device, resources are not required.
                //    
                Irp->IoStatus.Information = (ULONG_PTR)NULL;
                Status = STATUS_SUCCESS;
                break;
            
            case IRP_MN_QUERY_DEVICE_RELATIONS:
               
                //
                // Forward everything...
                //
                break;
                
            case IRP_MN_REMOVE_DEVICE:
                //
                // The KsBusEnum services cleaned up attachments, etc. However, 
                // we must remove our own FDO.
                //
                Status = STATUS_SUCCESS;
                IoDeleteDevice( DeviceObject );
                break;
            }

            if (Status != STATUS_NOT_SUPPORTED) {

                //
                // Set the Irp status only if we have something to add.
                //
                Irp->IoStatus.Status = Status;
            }

                    
            //
            // Forward this IRP down the stack only if we are successful or
            // we don't know how to handle this Irp.
            //
            if (NT_SUCCESS( Status ) || (Status == STATUS_NOT_SUPPORTED)) {                

                IoSkipCurrentIrpStackLocation(Irp);
                return IoCallDriver( PnpDeviceObject, Irp );
            }

            //
            // On error, fall through and complete the IRP with the status.
            //    
        }


        //
        // KsServiceBusEnumPnpRequest() handles all other child PDO requests.
        //    
        
        if (Status != STATUS_NOT_SUPPORTED) {
            Irp->IoStatus.Status = Status;
        } else {
            Status = Irp->IoStatus.Status;
        }
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return Status;


Arguments:
    IN PDEVICE_OBJECT DeviceObject -
        pointer to the device object

    IN PIRP Irp -
        pointer to the associated Irp

Return:
    STATUS_NOT_SUPPORTED if not handled by this service,
    STATUS_INVALID_DEVICE_REQUEST if the device object is neither a parent
    or child of the demand-load bus enumerator object, otherwise the status 
    code for the IRP processing.

--*/
{
    PIO_STACK_LOCATION      irpSp;
    NTSTATUS                Status;
    DEVICE_RELATION_TYPE    relationType;
    BUS_QUERY_ID_TYPE       busQueryId;
    PVOID                   Extension;

    PAGED_CODE();

    //
    // Get a pointer to our stack location and take appropriate action based
    // on the minor function.
    //

    irpSp = IoGetCurrentIrpStackLocation( Irp );
    
    Extension = *(PVOID *) DeviceObject->DeviceExtension;
    if (!Extension) {
        return STATUS_INVALID_PARAMETER;
    }
    
    Status = STATUS_NOT_SUPPORTED;

    switch (((PPDO_EXTENSION) Extension)->ExtensionType) {

    case ExtensionTypeFdo:

        //
        // This IRP is for the Functional Device Object (FDO)
        //

        switch (irpSp->MinorFunction) {

        case IRP_MN_START_DEVICE:
            Status = STATUS_SUCCESS;
            break;

        case IRP_MN_QUERY_DEVICE_RELATIONS:
            relationType = irpSp->Parameters.QueryDeviceRelations.Type;
            if (relationType != TargetDeviceRelation) {
                Status = 
                    QueryDeviceRelations( 
                        (PFDO_EXTENSION) Extension,
                        relationType,
                        (PDEVICE_RELATIONS *) &Irp->IoStatus.Information );
            }        
            break;

        case IRP_MN_QUERY_STOP_DEVICE:
            Status = STATUS_SUCCESS;
            break;

        case IRP_MN_QUERY_REMOVE_DEVICE:
            {
            PFDO_EXTENSION  FdoExtension;
         
            FdoExtension = (PFDO_EXTENSION) Extension;
        
            _DbgPrintF( 
                DEBUGLVL_VERBOSE, ("query remove device, FDO %x", DeviceObject) );
        
            //
            // Block out sweeper...
            //
            
            Status = STATUS_SUCCESS;
            
            if (InterlockedExchange( &FdoExtension->TimerScheduled, TRUE )) {
                if (!KeCancelTimer( &FdoExtension->SweeperTimer )) {
                    Status = STATUS_INVALID_DEVICE_STATE;
                }
            }    
        
            }    
            break;
            
        case IRP_MN_CANCEL_STOP_DEVICE:
            Status = STATUS_SUCCESS;
            break;
            
        case IRP_MN_CANCEL_REMOVE_DEVICE:
            {
            PFDO_EXTENSION  FdoExtension;
            LARGE_INTEGER   TimerPeriod;
         
            //
            // It's OK to let the sweeper run again.
            //
            FdoExtension = (PFDO_EXTENSION) Extension;
            InterlockedExchange( &FdoExtension->TimerScheduled, FALSE );

            TimerPeriod = ComputeNextSweeperPeriod( FdoExtension );

            if (TimerPeriod.QuadPart) {
                InterlockedExchange( &FdoExtension->TimerScheduled, TRUE );

                KeSetTimer( 
                    &FdoExtension->SweeperTimer,
                    TimerPeriod,
                    &FdoExtension->SweeperDpc );

            }

            Status = STATUS_SUCCESS;
            }
            break;    
            
        case IRP_MN_STOP_DEVICE:
            Status = STATUS_SUCCESS;
            break;

        case IRP_MN_SURPRISE_REMOVAL:
            _DbgPrintF( 
                DEBUGLVL_VERBOSE, 
                ("surprise removal, FDO %x", DeviceObject) );
            Status = STATUS_SUCCESS;
            break;

        case IRP_MN_REMOVE_DEVICE:
            {
            
            PFDO_EXTENSION  FdoExtension;
         
            _DbgPrintF( 
                DEBUGLVL_VERBOSE, 
                ("remove device, FDO %x", DeviceObject) );
        
            FdoExtension = (PFDO_EXTENSION) Extension;
            
            if (FdoExtension->linkName.Buffer) {
            
                //
                // Remove device interface association...
                //
                
                IoSetDeviceInterfaceState( &FdoExtension->linkName, FALSE );
            
                //
                // and free the symbolic link.
                //
                
                ExFreePool( FdoExtension->linkName.Buffer );
            }
            
            //
            // Delete the copy of the registry path.
            // 
            
            ExFreePool( FdoExtension->BaseRegistryPath.Buffer );
            
            //
            // Detach the device if attached.
            //
            
            if (FdoExtension->AttachedDevice) {
                IoDetachDevice( FdoExtension->PnpDeviceObject );
            }
            
            ExFreePool( FdoExtension );
            
            //
            // Clear the reference in the DeviceExtension to the FDO_EXTENSION
            //
            *(PVOID *)DeviceObject->DeviceExtension = NULL;
            Status = STATUS_SUCCESS;
            
            }
            break;
        }
        break;    

    case ExtensionTypePdo:
        {
    
        PDEVICE_REFERENCE DeviceReference;
    
        DeviceReference = 
            ((PPDO_EXTENSION) Extension)->DeviceReference;
            
        if (DeviceObject != DeviceReference->PhysicalDeviceObject) {
            _DbgPrintF( 
                DEBUGLVL_VERBOSE, 
                ("specified PDO is not valid (%08x).", DeviceObject) );
            Status = STATUS_NO_SUCH_DEVICE;
            break;
        }
    
        //
        // This IRP is for the Physical Device Object (PDO)
        //

        switch (irpSp->MinorFunction) {

        case IRP_MN_START_DEVICE:
            _DbgPrintF( 
                DEBUGLVL_VERBOSE, 
                ("start device, PDO %x", DeviceObject) );
            Status = StartDevice( DeviceObject );
#if defined( WIN9X_KS )
            if (NT_SUCCESS( Status )) {
                CompletePendingIo( 
                    DeviceReference, 
                    &((PPDO_EXTENSION)Extension)->BusDeviceExtension->DeviceListMutex, 
                    STATUS_REPARSE );
            }
#endif
            break;

        case IRP_MN_CANCEL_STOP_DEVICE:
        case IRP_MN_QUERY_STOP_DEVICE:
            _DbgPrintF( 
                DEBUGLVL_VERBOSE, 
                ("query/cancel stop device, PDO %x", DeviceObject) );
            Status = STATUS_SUCCESS;
            break;
            
        case IRP_MN_QUERY_REMOVE_DEVICE:
            _DbgPrintF( 
                DEBUGLVL_VERBOSE, ("query remove device, PDO %x", DeviceObject) );
        
            if ((((PPDO_EXTENSION) Extension)->DeviceReferenceCount) || 
                (DeviceReference->State == ReferenceFailedStart)) {
                Status = STATUS_INVALID_DEVICE_STATE;
            } else {    
                Status = STATUS_SUCCESS;
            }
            break;

        case IRP_MN_STOP_DEVICE:
            _DbgPrintF( 
                DEBUGLVL_VERBOSE, 
                ("stop device, PDO %x", DeviceObject) );
            DeviceReference->State = ReferenceStopped;
            Status = STATUS_SUCCESS;        
            break;
            
        case IRP_MN_SURPRISE_REMOVAL:
            _DbgPrintF( 
                DEBUGLVL_VERBOSE, 
                ("surprise removal, PDO %x", DeviceObject) );
            Status = STATUS_SUCCESS;
            break;

        case IRP_MN_CANCEL_REMOVE_DEVICE:
            _DbgPrintF( 
                DEBUGLVL_VERBOSE, 
                ("cancel remove device, PDO %x", DeviceObject) );
            Status = STATUS_SUCCESS;
            break;

        case IRP_MN_REMOVE_DEVICE:
            _DbgPrintF( 
                DEBUGLVL_VERBOSE, 
                ("remove device, PDO %x", DeviceObject) );
            Status = RemoveDevice( DeviceObject );
            break;

        case IRP_MN_QUERY_DEVICE_RELATIONS:
            _DbgPrintF( DEBUGLVL_BLAB, ("PDO QueryDeviceRelations") );
            relationType = irpSp->Parameters.QueryDeviceRelations.Type;
            if (relationType == TargetDeviceRelation) {
                Status = 
                    QueryDeviceRelations( 
                        (PFDO_EXTENSION) Extension,
                        relationType,
                        (PDEVICE_RELATIONS *) &Irp->IoStatus.Information );
            } else {                        
                Status = STATUS_NOT_SUPPORTED;
            }
            break;

        case IRP_MN_QUERY_PNP_DEVICE_STATE:
            {
            
            PFDO_EXTENSION BusDeviceExtension;
            PPNP_DEVICE_STATE DeviceState;

            DeviceState = (PPNP_DEVICE_STATE) &Irp->IoStatus.Information;
            
            *DeviceState |= PNP_DEVICE_DONT_DISPLAY_IN_UI | PNP_DEVICE_NOT_DISABLEABLE;

#if !defined( WIN9X_KS )
            //
            // NTOSKRNL fails IRP_MJ_CREATEs that arrive before
            // the device stack is started.  The very first 
            // IRP_MN_QUERY_PNP_DEVICE_STATE received after the IRP_MN_START_DEVICE
            // will be a notification that the stack has started.
            //
            BusDeviceExtension = ((PPDO_EXTENSION)Extension)->BusDeviceExtension;
            KeEnterCriticalRegion();
            ExAcquireFastMutexUnsafe( &BusDeviceExtension->DeviceListMutex );
            if (DeviceReference->State == ReferenceWaitingForStart) {
                DeviceReference->State = ReferenceStarted;
                CompletePendingIo( DeviceReference, NULL, STATUS_REPARSE );
            }
            ExReleaseFastMutexUnsafe( &BusDeviceExtension->DeviceListMutex );
            KeLeaveCriticalRegion();
#endif
            Status = STATUS_SUCCESS;
            
            }
            break;    
            
        case IRP_MN_QUERY_ID:

            //
            // Get a pointer to the query id structure and process.
            //

            busQueryId = irpSp->Parameters.QueryId.IdType;
            Status = 
                QueryId( 
                    (PPDO_EXTENSION) Extension,
                    busQueryId,
                    (PWSTR *)&Irp->IoStatus.Information );
            break;

        case IRP_MN_QUERY_INTERFACE:
            if (IsEqualGUID( 
                    irpSp->Parameters.QueryInterface.InterfaceType,
                    &BUSID_SoftwareDeviceEnumerator) &&
                (irpSp->Parameters.QueryInterface.Size == 
                    sizeof( BUS_INTERFACE_SWENUM )) &&
                (irpSp->Parameters.QueryInterface.Version ==
                    BUS_INTERFACE_SWENUM_VERSION )) {
                    
                PBUS_INTERFACE_SWENUM BusInterface;
                
                BusInterface = 
                    (PBUS_INTERFACE_SWENUM)irpSp->Parameters.QueryInterface.Interface;
                    
                BusInterface->Interface.Size = sizeof( *BusInterface );
                BusInterface->Interface.Version = BUS_INTERFACE_SWENUM_VERSION;
                BusInterface->Interface.Context = Extension;
                BusInterface->Interface.InterfaceReference = InterfaceReference;
                BusInterface->Interface.InterfaceDereference = InterfaceDereference;
                BusInterface->ReferenceDeviceObject = ReferenceDeviceObject;
                BusInterface->DereferenceDeviceObject = DereferenceDeviceObject;
                BusInterface->QueryReferenceString = QueryReferenceString;
                InterfaceReference( BusInterface->Interface.Context );
                Status = STATUS_SUCCESS;
            }
            break;
            
        case IRP_MN_QUERY_RESOURCES:
        case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:

            //
            // No resource requirements nor resource assignment.
            //

            Irp->IoStatus.Information = (ULONG_PTR)NULL;
            Status = STATUS_SUCCESS;
            break;
            
        case IRP_MN_READ_CONFIG:
        case IRP_MN_WRITE_CONFIG:

            //
            // There is no bus specific configuration to be written
            // or read for a device, just return success with no bytes 
            // read/written.
            //

            Status = STATUS_SUCCESS;
            break;

        case IRP_MN_QUERY_CAPABILITIES:
            {

            PDEVICE_CAPABILITIES Caps;
            USHORT size, version;
            ULONG reserved;

            //
            // fill in the capabilities structure
            //

            Caps = irpSp->Parameters.DeviceCapabilities.Capabilities;
            size = Caps->Size;
            version = Caps->Version;
            reserved = Caps->Reserved;
            RtlZeroMemory( Caps, sizeof( DEVICE_CAPABILITIES ) );
            Caps->Size = size;
            Caps->Version = version;
            Caps->Reserved = reserved;
            
            // Cannot wake the system.
            Caps->SystemWake = PowerSystemWorking;
            Caps->DeviceWake = PowerDeviceD0;
            
            Caps->DeviceState[PowerSystemUnspecified] = PowerDeviceUnspecified;
            Caps->DeviceState[PowerSystemWorking] = PowerDeviceD0;
            Caps->DeviceState[PowerSystemSleeping1] = PowerDeviceD1;
            Caps->DeviceState[PowerSystemSleeping2] = PowerDeviceD1;
            Caps->DeviceState[PowerSystemSleeping3] = PowerDeviceD1;
            Caps->DeviceState[PowerSystemHibernate] = PowerDeviceD1;
            Caps->DeviceState[PowerSystemShutdown] =  PowerDeviceD1;
            
            // Have no latencies.
            
            // Do not support locking or ejecting.
            Caps->LockSupported = FALSE;
            Caps->EjectSupported = FALSE;

            // Technically there is no physical device to remove, but this bus
            // driver can yank the PDO from the PlugPlay system, when ever it
            // we hit an access timeout.
            Caps->SurpriseRemovalOK = TRUE;
            Caps->Removable = FALSE;
            Caps->DockDevice = FALSE;
            Caps->UniqueID = TRUE;
            
            Caps->SilentInstall = TRUE;

            //
            // return the number of bytes read
            //

            Irp->IoStatus.Information = sizeof( DEVICE_CAPABILITIES );
            Status = STATUS_SUCCESS;
            }
            break;

        case IRP_MN_QUERY_BUS_INFORMATION:
            {
        
            PPNP_BUS_INFORMATION  BusInformation;
            
            BusInformation = 
                (PPNP_BUS_INFORMATION) 
                    ExAllocatePoolWithTag( 
                        PagedPool, 
                            sizeof( PNP_BUS_INFORMATION ), 
                        POOLTAG_DEVICE_BUSID );
            if (NULL == BusInformation) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            } else {
                RtlZeroMemory( BusInformation, sizeof( PNP_BUS_INFORMATION ) );
                BusInformation->BusTypeGuid = BUSID_SoftwareDeviceEnumerator;
                BusInformation->LegacyBusType = InterfaceTypeUndefined;
                Irp->IoStatus.Information = (ULONG_PTR)BusInformation;
                Status = STATUS_SUCCESS;
            }
            
            }
            break;

        }
        break;
        
        }

    default: 

        //
        // This is neither an FDO or PDO, return invalid device request.
        //

        Status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }


    return Status;
}

KSDDKAPI
NTSTATUS
NTAPI
KsGetBusEnumIdentifier(
    IN PIRP Irp
    )

/*++

Routine Description:
    Returns the software bus enumerator id for the bus device associated with
    this request.

Arguments:
    IN PIRP Irp -
        I/O request packet specifying the address and size of the user output
        buffer to receive the requested bus enumerator id.

Return:
    STATUS_SUCCESS if the bus enumerator id was retrieved succesfully,
    STATUS_INVALID_PARAMETER if the specified device is not valid,
    STATUS_BUFFER_TOO_SMALL is the specified buffer was not large enough,
    STATUS_BUFFER_OVERFLOW (with the required size) if no buffer was specified,
    otherwise the status return from probing the user buffer, or pool allocation
    failure.

--*/

{
    PFDO_EXTENSION      BusExtension;
    PIO_STACK_LOCATION  irpSp;
    ULONG               BufferLength, IdLength;

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    BusExtension = *(PVOID *) irpSp->DeviceObject->DeviceExtension;
    if (!BusExtension) {
        return STATUS_INVALID_PARAMETER;
    }
    if (BusExtension->ExtensionType == ExtensionTypePdo) {
        BusExtension = ((PPDO_EXTENSION) BusExtension)->BusDeviceExtension;
    }

    IdLength =
        (wcslen( BusExtension->BusPrefix ) * sizeof( WCHAR )) +
            sizeof( UNICODE_NULL );

    //
    // The IRP serviced by this routine should specify the I/O buffering method
    // of METHOD_NEITHER.  For this type of (non)-buffering, the I/O manager
    // does not allocate anything for the SystemBuffer.  OutputBufferLength and
    // InputBufferLength are supplied exactly as specified by the caller, with
    // the address of the caller-supplied output buffer specified by UserBuffer,
    // and the address of the caller-supplied input buffer specified by
    // Type3InputBuffer.  The I/O manager has done NO validation whatsoever on
    // these buffers, so they must be probed by the driver for their specified
    // length, for the access desired.
    //
    ASSERT( (irpSp->Parameters.DeviceIoControl.IoControlCode & 3) == METHOD_NEITHER );

    BufferLength = irpSp->Parameters.DeviceIoControl.OutputBufferLength;

    if (BufferLength > 0) {
        //
        // The caller claims they've supplied us with a buffer, first check if
        // it is large enough for the data requested.
        //
        if (BufferLength < IdLength) {
            return STATUS_BUFFER_TOO_SMALL;
        }

        //
        // The caller says their output buffer is large enough for the data
        // requested, so we'll try to pass it back to them.
        //
        // To do this, we:
        //
        //  - Validate the caller-specified output buffer for write access, for
        //    the length specified.
        //
        //  - Allocate a SystemBuffer, with quota charged against
        //    the caller (this can be done since for METHOD_NEITHER IRPs, the
        //    driver can be sent such a request only while it is running in the
        //    context of the thread that originates the I/O control request).
        //
        //  - Modify the IRP to specify buffered I/O, and that upon completion,
        //    the I/O manager should copy what's in the SystemBuffer back to the
        //    user buffer (already probed) and free the SystemBuffer.
        //

        try {
            //
            // Probe the destination buffer where the I/O manager will copy data
            // from the system buffer to for write access, for the length the
            // caller specified.
            //
            ProbeForWrite(Irp->UserBuffer, BufferLength, sizeof(BYTE));

            //
            // Allocate safe and aligned buffer.  Note there's no need to zero
            // the memory to prevent random kernel-memory from being returned to
            // the caller because the I/O manager will only copy the amount we
            // specify in irp->IoStatus.Information to the caller's buffer.
            //
            Irp->AssociatedIrp.SystemBuffer = 
                ExAllocatePoolWithQuotaTag(
                    NonPagedPool,
                    BufferLength,
                    POOLTAG_DEVICE_IO_BUFFER );

            //
            // Modify the IRP for buffered I/O, such that data is copied from
            // the system buffer to the user buffer, and the system buffer is
            // deallocated by the I/O manager on completion.
            //
            Irp->Flags |=
                (IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER | IRP_INPUT_OPERATION);

        } except (EXCEPTION_EXECUTE_HANDLER) {
            //
            // Note that if the exception was raised during the probe, no
            // buffering will be done upon completion of the IRP.  If
            // ExAllocatePoolWithQuotaTag raised the exception, no buffer was
            // allocated, and we have not modified the buffering type for the
            // IRP, so the I/O manager will do nothing on completion.  If both
            // operations were successful, we have a buffer which the I/O
            // manager will copy from and free the upon completion.
            //
            return GetExceptionCode();
        }

        //
        // Copy the BusPrefix string to the SystemBuffer.
        //
        ASSERT( IdLength <= BufferLength );

        if (FAILED( StringCbCopyEx(
                        Irp->AssociatedIrp.SystemBuffer,
                        IdLength,
                        BusExtension->BusPrefix,
                        NULL, NULL,
                        STRSAFE_NULL_ON_FAILURE ) )) {
            Irp->IoStatus.Information = 0;
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        Irp->IoStatus.Information = IdLength;
        return STATUS_SUCCESS;

    } else {
        //
        // No output buffer was specified by the caller.
        // Return the required size.
        //
        Irp->IoStatus.Information = IdLength;
        return STATUS_BUFFER_OVERFLOW;
    }

}

KSDDKAPI
NTSTATUS
NTAPI
KsIsBusEnumChildDevice(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PBOOLEAN ChildDevice
    )

/*++

Routine Description:
    Returns TRUE if the given device object is a child device of the demand-load
    bus enumerator object, FALSE otherwise.

Arguments:
    IN PDEVICE_OBJECT DeviceObject -
        pointer to a device object

    IN PBOOLEAN ChildDevice
        pointer to receive BOOLEAN result

Return:
    STATUS_SUCCESS if DeviceExtension is valid, otherwise an error code.
    If the device object is determined to be a child device, *ChildDevice
    is set to TRUE.

--*/

{
    PVOID Extension;
    
    PAGED_CODE();

    if (DeviceObject->DeviceExtension) {
        Extension = *(PVOID *) DeviceObject->DeviceExtension;
        *ChildDevice = FALSE;
        if (Extension) {
            *ChildDevice = 
                (ExtensionTypePdo == ((PPDO_EXTENSION) Extension)->ExtensionType);
            return STATUS_SUCCESS;
        }
    }
    return STATUS_INVALID_DEVICE_REQUEST;
}

KSDDKAPI
NTSTATUS
NTAPI
KsGetBusEnumPnpDeviceObject(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PDEVICE_OBJECT *PnpDeviceObject
    )

/*++

Routine Description:
    Returns the associated Pnp Device Object stack to which this 
    device object is attached.

Arguments:
    IN PDEVICE_OBJECT DeviceObject -
        device object pointer

    OUT PDEVICE_OBJECT *PnpDeviceObject -
        pointer resultant device object pointer

Return:
    STATUS_SUCCESS or STATUS_INVALID_PARAMETER
    
--*/

{
    PFDO_EXTENSION FdoExtension;

    PAGED_CODE();
    FdoExtension = *(PFDO_EXTENSION *) DeviceObject->DeviceExtension;
    if (!FdoExtension) {
       return STATUS_INVALID_PARAMETER;
    }
    if (ExtensionTypeFdo != FdoExtension->ExtensionType) {
        return STATUS_INVALID_PARAMETER;
    }

    *PnpDeviceObject = FdoExtension->PnpDeviceObject;
    return STATUS_SUCCESS;
}    


NTSTATUS
StartDevice(
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )

/*++

Routine Description:
    Processes the start device request for the given PDO by scanning
    the device associations looking for pending I/O.  If an I/O request
    is found (presumably an IRP_MJ_CREATE), the IRP is completed with
    STATUS_REPARSE via the IssueReparseForIrp() function.

Arguments:
    IN PDEVICE_OBJECT PhysicalDeviceObject -
        pointer to the device object

Return:
    STATUS_SUCCESS if successful, STATUS_INSUFFICIENT_RESOURCES if
    pool allocation failure otherwise an appropriate error return.

--*/

{
    NTSTATUS            Status;
    PDEVICE_REFERENCE   DeviceReference;
    PPDO_EXTENSION      PdoExtension;
    ULONG               ResultLength;
    WCHAR               DeviceName[ 256 ];
                                               

    PdoExtension = *(PPDO_EXTENSION *) PhysicalDeviceObject->DeviceExtension;
    DeviceReference = PdoExtension->DeviceReference;

    if (DeviceReference->State == ReferenceStopped) {
        DeviceReference->State = ReferenceStarted;
        return STATUS_SUCCESS;
    }

    if (PhysicalDeviceObject->AttachedDevice) {

        //
        // Validate that the child is setting DO_POWER_PAGABLE.  
        // Fatal error if not, thus issue the bugcheck.
        //

        if (0 == 
              (PhysicalDeviceObject->AttachedDevice->Flags & DO_POWER_PAGABLE)) {
#if defined( WIN9X_KS )
            DbgPrint(
                "ERROR! the child FDO has not set DO_POWER_PAGABLE, FDO: %08x\n",
                PhysicalDeviceObject->AttachedDevice);

            DbgPrint("**** The owning driver is broken and is not acceptable per ****\n");
            DbgPrint("**** HCT requirements for WDM drivers. This driver will    ****\n");
            DbgPrint("**** bugcheck running under Windows 2000.                  ****\n");

            #ifndef WIN98GOLD_KS
            DbgBreakPoint();
            #endif
#else
            _DbgPrintF( 
                DEBUGLVL_TERSE, 
                ("ERROR! the child FDO has not set DO_POWER_PAGABLE, use \"!devobj %08x\" to report the culprit",
                    PhysicalDeviceObject->AttachedDevice) );
            KeBugCheckEx (
                DRIVER_POWER_STATE_FAILURE,
                0x101,
                (ULONG_PTR) PhysicalDeviceObject->AttachedDevice,
                (ULONG_PTR) PhysicalDeviceObject,
                (ULONG_PTR) PdoExtension->BusDeviceExtension->PhysicalDeviceObject
                );
#endif
        }
    }

    Status = 
        IoGetDeviceProperty( 
            PhysicalDeviceObject,
            DevicePropertyPhysicalDeviceObjectName,
            sizeof( DeviceName ),
            DeviceName,
            &ResultLength );

    if (!NT_SUCCESS( Status )) {
        _DbgPrintF( 
            DEBUGLVL_ERROR, 
            ("failed to retrieve PDO's device name: %x", Status) );
        return Status;
    }

    DeviceReference->DeviceName = 
        ExAllocatePoolWithTag( 
            PagedPool, 
            ResultLength,
            POOLTAG_DEVICE_NAME );

    if (NULL == DeviceReference->DeviceName) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    
    RtlCopyMemory( DeviceReference->DeviceName, DeviceName, ResultLength );

    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe( &PdoExtension->BusDeviceExtension->DeviceListMutex );    
    
    //
    // Scan the device reference for pending I/O, build the new
    // device path and complete the IRPs with STATUS_REPARSE.
    //
    
    //
    // Snap the current time to compute idle time 
    // 

    DeviceReference->IdleStartTime = KeQueryPerformanceCounter( NULL );
#if (DEBUG_LOAD_TIME)
    DeviceReference->LoadTime.QuadPart =
        DeviceReference->IdleStartTime.QuadPart -
            DeviceReference->LoadTime.QuadPart;

    DeviceReference->LoadTime.QuadPart =
                KSCONVERT_PERFORMANCE_TIME(
                    PdoExtension->BusDeviceExtension->CounterFrequency.QuadPart, 
                    DeviceReference->LoadTime );

    _DbgPrintF( 
        DEBUGLVL_TERSE, 
        ("driver load time: %d ms", 
            ((DeviceReference->LoadTime.QuadPart) / _100NS_IN_MS)) );
#endif

    //
    // Adjust the timeout for the default timeout period.
    //
    DeviceReference->TimeoutRemaining = DeviceReference->TimeoutPeriod;

    if (DeviceReference->State == ReferenceFailedStart) {
        //
        // The interfaces were disabled when the device was detected to
        // have failed the Start or AddDevice.  Enable the interfaces to
        // give everyone a chance to try again.
        //
        _DbgPrintF( 
            DEBUGLVL_VERBOSE, 
            ("enabling device interfaces for device reference: %x", DeviceReference) );
        EnableDeviceInterfaces( DeviceReference, TRUE );
    }

    //
    // Note, for the Windows NT case, we have to wait for the device stack
    // to complete startup before dispatching the create IRPs.  Therefore,
    // we have an extra state (ReferenceWaitingForStart) which transitions
    // to ReferenceStarted after we receive the first IRP_MN_QUERY_PNP_DEVICE_STATE 
    // down the stack.  This is guaranteed by the Windows NT implementation.
    //
    
#if !defined( WIN9X_KS )
    DeviceReference->State = ReferenceWaitingForStart;
#else
    DeviceReference->State = ReferenceStarted;
#endif

    ExReleaseFastMutexUnsafe( &PdoExtension->BusDeviceExtension->DeviceListMutex );
    KeLeaveCriticalRegion();
    
    return STATUS_SUCCESS;

}


NTSTATUS
RemoveDevice(
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )

/*++

Routine Description:
    Processes the remove device request for the given PDO by 
    completing any pending I/O with STATUS_OBJECT_NAME_NOT_FOUND and
    deleting the device object.

    NOTE!  IRP_MN_REMOVE_DEVICE is sent to the stack after AddDevice() has
    succeeded.  Thus, if we fail during IRP_MN_START_DEVICE we will receive
    an IRP_MN_REMOVE_DEVICE, thus we can perform appropriate cleanup.

Arguments:
    IN PDEVICE_OBJECT PhysicalDeviceObject -
        pointer to the device object

Return:
    STATUS_SUCCESS if successful, STATUS_INSUFFICIENT_RESOURCES if
    pool allocation failure otherwise an appropriate error return.

--*/

{
    NTSTATUS            Status;
    PDEVICE_REFERENCE   DeviceReference;
    PFDO_EXTENSION      BusDeviceExtension;
    PPDO_EXTENSION      PdoExtension;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("RemoveDevice(), entry.") );
    
    PdoExtension = *(PPDO_EXTENSION *)PhysicalDeviceObject->DeviceExtension;
    
    DeviceReference = PdoExtension->DeviceReference;
    BusDeviceExtension = PdoExtension->BusDeviceExtension;
        
    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe( &BusDeviceExtension->DeviceListMutex );    

    //
    // If the device failed to start or failed during installation, complete any
    // pending create IRPs as STATUS_OBJECT_NAME_NOT_FOUND.  We will mark the
    // device for removal and issue a bus enumeration below.  If additional
    // create requests are made before then, we will create a new PDO and
    // attempt to restart the device on the final removal, below.
    //

    if ((DeviceReference->State < ReferenceStarted) &&
        (DeviceReference->State != ReferenceRemoved)) {
        CompletePendingIo( DeviceReference, NULL, STATUS_OBJECT_NAME_NOT_FOUND );
    }

    //
    // No matter what circumstances we hit below, we must restart the
    // device before we can accept IRP_MJ_CREATE on the associated PDO.
    //    
    
    if (DeviceReference->DeviceName) {
        ExFreePool( DeviceReference->DeviceName );
        DeviceReference->DeviceName = NULL;
    }

    DeviceReference->State = ReferenceRemoved;

    //
    // In the case where the device is forcefully removed by the system,
    // the device reference marker will be "SweeperDeviceActive". 
    // For this case, treat the device as if it just timed out and
    // set the marker as appropriate.  Issue a bus reenumeration and
    // this PDO will be finally removed with another IRP_MN_REMOVE_DEVICE
    // Irp after it is reported as not present in the bus scan to the
    // system.
    //

    if (DeviceReference->SweeperMarker == SweeperDeviceActive) {

        DeviceReference->SweeperMarker = SweeperDeviceRemoval;

        _DbgPrintF( 
            DEBUGLVL_BLAB, 
            ("IRP_MN_REMOVE_DEVICE (exit), marked active device %08x for removal", 
                DeviceReference->PhysicalDeviceObject) );

        //
        // This device has been marked for removal, request a bus reenumeration.
        //

        ExReleaseFastMutexUnsafe( &BusDeviceExtension->DeviceListMutex );
        KeLeaveCriticalRegion();

        IoInvalidateDeviceRelations( 
            BusDeviceExtension->PhysicalDeviceObject,
            BusRelations );

        return STATUS_SUCCESS;
    }

    if ( DeviceReference->SweeperMarker == SweeperDeviceRemoval ) {

        //
        // If an non-active device receives a remove IRP before having been
        // reported as not present in the bus scan to the system, then the
        // device is being forcefully removed by the system after its timeout
        // period.  Leave the device reference marker in its current state, and
        // succeed the remove IRP without deleting the PDO.  We still expect a
        // bus re-enumeration to report the device missing, and will receive
        // another remove IRP to delete the PDO.
        //

        _DbgPrintF(
            DEBUGLVL_BLAB,
            ("IRP_MN_REMOVE_DEVICE (exit), non-active device %08x already marked for removal",
                DeviceReference->PhysicalDeviceObject) );

        //
        // This device has been marked for removal, bus reenumeration is pending.
        //

        ExReleaseFastMutexUnsafe( &BusDeviceExtension->DeviceListMutex );
        KeLeaveCriticalRegion();

        return STATUS_SUCCESS;
    }

    if ( !IsListEmpty( &DeviceReference->IoQueue ) ) {

        //
        // We're about to delete this device, but we've got another pending
        // request.  Create a new PDO for this device and if successful, delete
        // the old PDO and request re-enumeration.  Otherwise, fall through and
        // complete IRPs as STATUS_OBJECT_NAME_NOT_FOUND and then delete the
        // PDO.
        //
    
        Status = 
            CreatePdo( 
                BusDeviceExtension,
                DeviceReference, 
                &DeviceReference->PhysicalDeviceObject );
        
        if (NT_SUCCESS( Status )) {        
        
            _DbgPrintF( 
                DEBUGLVL_VERBOSE, 
                ("RemoveDevice(), created PDO %x.", DeviceReference->PhysicalDeviceObject) );
        
            IoDeleteDevice( PhysicalDeviceObject );
            ExFreePool( PdoExtension );
            *(PVOID *)PhysicalDeviceObject->DeviceExtension = NULL;
            
            //
            // This device has been accessed after issuing the device removal
            // request.  Keep everything associated with this PDO in tact but 
            // reset the SweeperMarker and invalidate the bus relations so that 
            // we'll reenumerate this PDO.
            //
            
            DeviceReference->SweeperMarker = SweeperDeviceActive;
            DeviceReference->TimeoutRemaining = DeviceReference->TimeoutPeriod;
            
            ExReleaseFastMutexUnsafe( &BusDeviceExtension->DeviceListMutex );
            KeLeaveCriticalRegion();

            //
            // Force a re-enumeration of the bus.
            //

            IoInvalidateDeviceRelations(
                BusDeviceExtension->PhysicalDeviceObject,
                BusRelations );
        
            _DbgPrintF( DEBUGLVL_VERBOSE, ("RemoveDevice(), exited w/ reenumeration.") );
                
            return STATUS_SUCCESS;

        } else {
            //
            // Unable to create another PDO, fail any pending I/O and
            // mark this device reference as removed.
            //
            DeviceReference->SweeperMarker = SweeperDeviceRemoved;
        }
    }
    
    //
    // We're really removing this device, set the PhysicalDeviceObject
    // reference to NULL.
    //    
    
    DeviceReference->PhysicalDeviceObject = NULL;
    
    //
    // Since we are really going to remove this device, scan the device 
    // reference for pending I/O and mark them with an error.
    //
    
    CompletePendingIo( DeviceReference, NULL, STATUS_OBJECT_NAME_NOT_FOUND );

    //
    // Free the PDO extension and clear the reference in the 
    // DeviceExtension to it.
    //
    ExFreePool( PdoExtension );
    *(PVOID *)PhysicalDeviceObject->DeviceExtension = NULL;
    IoDeleteDevice( PhysicalDeviceObject );
    
    ExReleaseFastMutexUnsafe( &BusDeviceExtension->DeviceListMutex );
    KeLeaveCriticalRegion();
    
    _DbgPrintF( DEBUGLVL_VERBOSE, ("RemoveDevice(), exit.") );
    
    return STATUS_SUCCESS;
}



KSDDKAPI
NTSTATUS
NTAPI
KsServiceBusEnumCreateRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )

/*++

Routine Description:
    This routine services the IRP_MJ_CREATE request for the registered
    device interface by matching the FileObject->FileName with 
    the registered "bus" reference strings.  If the device reference
    is present, enumerated and created, the IRP is simply re-routed to 
    the actual device via IssueReparseForIrp().
    
    If the reference string is NULL, it is assumed that this is a request
    for the bus interface and the IRP_MJ_CREATE is completed.
    
    If the device reference has not already been enumerated or is not
    active, the IRP is queued and a PDO is created and a bus enumeration is 
    initiated by IoInvalidateDeviceRelations().

Arguments:
    IN PDEVICE_OBJECT DeviceObject -
        pointer to the device object

    IN OUT PIRP Irp -
        pointer to the I/O request packet

Return:
    STATUS_SUCCESS if successful, STATUS_OBJECT_NAME_NOT_FOUND if the 
    FileObject.FileName is NULL or if the reference string can not be
    located. STATUS_REPARSE may be returned via IssueReparseForIrp()
    else an appropriate error return.

--*/

{
    NTSTATUS            Status;
    PIO_STACK_LOCATION  irpSp;
    PDEVICE_REFERENCE   DeviceReference;
    PFDO_EXTENSION      FdoExtension;

    PAGED_CODE();
    
    FdoExtension = *(PFDO_EXTENSION *) DeviceObject->DeviceExtension;
    ASSERT( FdoExtension->ExtensionType == ExtensionTypeFdo );

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    _DbgPrintF( DEBUGLVL_BLAB, ("KsServiceCreateRequest()") );

    //
    // Check if we're handling the request for the child.
    //    

    _DbgPrintF( 
        DEBUGLVL_BLAB, 
        ("KsServiceCreateRequest() scanning for %S", irpSp->FileObject->FileName.Buffer) );

    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe( &FdoExtension->DeviceListMutex );    
        
    //
    // Walk the device reference list looking for the reference string.
    //

    for (DeviceReference =
            (PDEVICE_REFERENCE) FdoExtension->DeviceReferenceList.Flink;
         DeviceReference != 
            (PDEVICE_REFERENCE) &FdoExtension->DeviceReferenceList;
         DeviceReference = (PDEVICE_REFERENCE) DeviceReference->ListEntry.Flink) {

        //
        // Search for bus reference string (skip the initial backslash).
        //
        
        _DbgPrintF( 
            DEBUGLVL_BLAB, 
            ("comparing against %S", DeviceReference->BusReferenceString) );
    
        if ((DeviceReference->BusReferenceString) && 
            (0 == 
                _wcsnicmp( 
                    &irpSp->FileObject->FileName.Buffer[ 1 ], 
                    DeviceReference->BusReferenceString,
                    irpSp->FileObject->FileName.Length ))) {

            //
            // Found the reference.  If the PDO exists, kick off a reparse.
            // Otherwise we need to mark this IRP pending, activate this 
            // device, and invalidate device relations to cause the 
            // actual enumeration of the device.
            //

            _DbgPrintF( DEBUGLVL_BLAB, ("found device reference") );

            //
            // If the device has not been enumerated, then
            // create the PDO and invalidate the device
            // relations.
            //

            if (!DeviceReference->PhysicalDeviceObject) {
                LARGE_INTEGER   TotalIdlePeriod;

                //
                // The device was inactive when it was accessed and will be 
                // reenumerated.
                //
                // In an attempt to increase the hit rate, the device timeout 
                // is recomputed.  
                //
                // To compute the new timeout value, the total idle is determined
                // for this device based on the time the last idle period was
                // started (e.g. the last time the reference count for the device
                // wnt to zero).  If the idle period is greater than the maximum
                // timeout period (e.g. 20 minutes), the device timeout period is
                // reduced by half -- providing a timeout decay when the device
                // is used very infrequently. If the idle period is less than the
                // maximum timeout period but greater than the current timeout
                // value for the device, the new timeout value for the device is
                // set to the idle period.
                //

                //
                // Compute the total idle period for this device.
                //

                TotalIdlePeriod.QuadPart = 
                    KeQueryPerformanceCounter( NULL ).QuadPart - 
                        DeviceReference->IdleStartTime.QuadPart;

                //
                // Watch for roll-over in the timer.
                //

                if (TotalIdlePeriod.QuadPart < 0) {
                    TotalIdlePeriod.QuadPart += MAXLONGLONG;
                }


                if (TotalIdlePeriod.QuadPart < 
                        FdoExtension->MaximumTimeout.QuadPart) {
                    if (TotalIdlePeriod.QuadPart > DeviceReference->TimeoutPeriod.QuadPart) {
                        DeviceReference->TimeoutPeriod.QuadPart = TotalIdlePeriod.QuadPart;
                    }
                } else {
                    //
                    // The device is not being used frequently enough -- reduce
                    // the timeout.  The minimum timeout period is constant.
                    //

                    DeviceReference->TimeoutPeriod.QuadPart /= 2;
                    DeviceReference->TimeoutPeriod.QuadPart = 
                        max( 
                            DeviceReference->TimeoutPeriod.QuadPart,
                            FdoExtension->CounterFrequency.QuadPart *
                            SWEEPER_TIMER_FREQUENCY_IN_SECS
                        );
                }

                _DbgPrintF( 
                    DEBUGLVL_VERBOSE, ("device timeout period is %d ms", 
                        KSCONVERT_PERFORMANCE_TIME( 
                            FdoExtension->CounterFrequency.QuadPart, 
                            DeviceReference->TimeoutPeriod ) / _100NS_IN_MS ) );

                //
                //  The device has not been enumerated
                //
                Status = 
                    CreatePdo( 
                        FdoExtension, 
                        DeviceReference, 
                        &DeviceReference->PhysicalDeviceObject );

                if (!NT_SUCCESS( Status )) {
                
                    _DbgPrintF( 
                        DEBUGLVL_VERBOSE, 
                        ("IRP_MJ_CREATE: unable to create PDO (%8x)", Status) );
                
                    ExReleaseFastMutexUnsafe( &FdoExtension->DeviceListMutex );    
                    KeLeaveCriticalRegion();
                    
                    Irp->IoStatus.Status = Status;
                } else {

                    _DbgPrintF( 
                        DEBUGLVL_BLAB, 
                        ("IRP_MJ_CREATE: created PDO (%8x)", 
                            DeviceReference->PhysicalDeviceObject) );

                    //
                    // This IRP is not cancelable.
                    //
                    
                    IoMarkIrpPending( Irp );
                    InsertTailList( 
                        &DeviceReference->IoQueue,
                        &Irp->Tail.Overlay.ListEntry );

                    ExReleaseFastMutexUnsafe( &FdoExtension->DeviceListMutex );    
                    KeLeaveCriticalRegion();

                    //
                    // Force a re-enumeration of the bus.
                    //
                    IoInvalidateDeviceRelations( 
                        FdoExtension->PhysicalDeviceObject,
                        BusRelations );
                    Status = STATUS_PENDING;
                }
                return Status;    
            }
        
            //
            // We have a PDO.  
            //
            
            //
            // If the device failed to start or failed during installation,
            // complete this IRP as STATUS_OBJECT_NAME_NOT_FOUND.
            //
            
            if (DeviceReference->State == ReferenceFailedStart) {
                Status = STATUS_OBJECT_NAME_NOT_FOUND;
                Irp->IoStatus.Status = Status;
            } else {
            
                //
                // If the device has not been started or has 
                // a pending removal IRP, queue the request, otherwise issue the 
                // reparse.
                //
                
                if ((DeviceReference->State < ReferenceStarted) ||
                    (DeviceReference->SweeperMarker == SweeperDeviceRemoved)) {

                    //
                    // Reset the device reference timeout.
                    //
                    DeviceReference->TimeoutRemaining = 
                        DeviceReference->TimeoutPeriod;

                    //
                    // This IRP is not cancelable.
                    //
                    
                    IoMarkIrpPending( Irp );
                    InsertTailList( 
                        &DeviceReference->IoQueue,
                        &Irp->Tail.Overlay.ListEntry );
                    Status = STATUS_PENDING;
                    
                } else {
                    //
                    // The device has been created and a pending removal IRP is
                    // not emminent. Issue a reparse to the actual device name.
                    //
                    
                    Status =
                        IssueReparseForIrp( 
                                Irp, 
                                DeviceReference );
                                
                }
            }    
            ExReleaseFastMutexUnsafe( &FdoExtension->DeviceListMutex );    
            KeLeaveCriticalRegion();
            return Status;
        }
    }

    //
    // The device reference string was not found, the object name was
    // not valid.
    //    
    
    Status =
        Irp->IoStatus.Status = 
            STATUS_OBJECT_NAME_NOT_FOUND;
    ExReleaseFastMutexUnsafe( &FdoExtension->DeviceListMutex );    
    KeLeaveCriticalRegion();
    return Status;
}


NTSTATUS
OpenDeviceInterfacesKey(
    OUT PHANDLE DeviceInterfacesKey,
    IN PUNICODE_STRING BaseRegistryPath
    )

/*++

Routine Description:
    Opens a handle to the supplied registry key that stores device references
    for devices on the "software bus".

Arguments:
    OUT PHANDLE DeviceInterfacesKey -
        pointer to receive a handle to the registry key where device references
        for the "software bus" are stored


    IN PUNICODE_STRING BaseRegistryPath -
        pointer to registry key path where device references for the "software
        bus" are stored

Return:
    STATUS_SUCCESS or an appropriate error code.

--*/

{   
    NTSTATUS            Status; 
    OBJECT_ATTRIBUTES   ObjectAttributes;
    
    InitializeObjectAttributes( 
        &ObjectAttributes, 
        BaseRegistryPath,
        OBJ_CASE_INSENSITIVE,
        NULL,
        (PSECURITY_DESCRIPTOR) NULL );

    Status = 
        ZwCreateKey( 
            DeviceInterfacesKey,
            KEY_ALL_ACCESS,
            &ObjectAttributes,
            0,          // IN ULONG TitleIndex
            NULL,       // IN PUNICODE_STRING Class
            REG_OPTION_NON_VOLATILE,
            NULL );     // OUT PULONG Disposition
            
    if (!NT_SUCCESS( Status )) {
        _DbgPrintF( 
            DEBUGLVL_BLAB, 
            ("failed in OpenDeviceInterfacesKey(): %08x", Status) );
    }

    return Status; 
}    


NTSTATUS
QueryDeviceRelations(
    IN PFDO_EXTENSION FdoExtension,
    IN DEVICE_RELATION_TYPE RelationType,
    OUT PDEVICE_RELATIONS *DeviceRelations
    )

/*++

Routine Description:
    Processes the PnP IRP_MN_QUERY_DEVICE_RELATIONS request.

Arguments:
    IN PFDO_EXTENSION FdoExtension -
        pointer to the FDO device extension

    IN DEVICE_RELATION_TYPE RelationType -
        relation type, currently only BusRelations are supported

    OUT PDEVICE_RELATIONS *DeviceRelations -
        pointer to receive the child PDO list 

Return:
    STATUS_SUCCESS if successful, STATUS_NOT_SUPPORTED if RelationType !=
    BusRelations else an approprate error return.

--*/

{

    ULONG               pdoCount;
    PDEVICE_RELATIONS   deviceRelations;
    ULONG               deviceRelationsSize;
    PDEVICE_REFERENCE   DeviceReference;

    PAGED_CODE();

    _DbgPrintF( DEBUGLVL_BLAB, ("QueryDeviceRelations") );

    switch (RelationType) {

    case BusRelations:
    
        ASSERT( FdoExtension->ExtensionType == ExtensionTypeFdo );
        
        //
        // First count the child PDOs
        //

        pdoCount = 0;

        KeEnterCriticalRegion();
        ExAcquireFastMutexUnsafe( &FdoExtension->DeviceListMutex );     

        for (DeviceReference =
                (PDEVICE_REFERENCE) FdoExtension->DeviceReferenceList.Flink;
             DeviceReference != 
                (PDEVICE_REFERENCE) &FdoExtension->DeviceReferenceList;
             DeviceReference = (PDEVICE_REFERENCE) DeviceReference->ListEntry.Flink) {
            if ((DeviceReference->PhysicalDeviceObject) && 
                (DeviceReference->SweeperMarker < SweeperDeviceRemoval)) {
                pdoCount++;
            } 
        }   

        _DbgPrintF( 
            DEBUGLVL_BLAB, 
            ("%d active device%s", 
                pdoCount, ((pdoCount == 0) ||  (pdoCount > 1)) ? "s" : "") );
        break;

    case TargetDeviceRelation:
        ASSERT( FdoExtension->ExtensionType == ExtensionTypePdo );
    
        pdoCount = 1;
        break;

    default:
        _DbgPrintF( 
            DEBUGLVL_VERBOSE, 
            ("QueryDeviceRelations: RelationTType %d not handled", RelationType) );
        return STATUS_NOT_SUPPORTED;

    }

    //
    // Now allocate a chunk of memory big enough to hold the DEVICE_RELATIONS
    // structure along with the array
    //
    
    deviceRelationsSize = 
        FIELD_OFFSET( DEVICE_RELATIONS, Objects ) +
            pdoCount * sizeof( PDEVICE_OBJECT );
            
    deviceRelations = 
        ExAllocatePoolWithTag( 
            NonPagedPool, 
            deviceRelationsSize,
            POOLTAG_DEVICE_RELATIONS );
    if (!deviceRelations) {
        if (RelationType == BusRelations) {
            ExReleaseFastMutexUnsafe( &FdoExtension->DeviceListMutex );    
            KeLeaveCriticalRegion();
        }
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    if (RelationType == TargetDeviceRelation) {
        PPDO_EXTENSION PdoExtension = (PPDO_EXTENSION) FdoExtension;
    
        ObReferenceObject( PdoExtension->PhysicalDeviceObject );
        deviceRelations->Objects[ 0 ] = PdoExtension->PhysicalDeviceObject;
    } else {
        //
        // Walk the device references list again and 
        // build the DEVICE_RELATIONS structure.
        //

        for (pdoCount = 0, DeviceReference =
                (PDEVICE_REFERENCE) FdoExtension->DeviceReferenceList.Flink;
             DeviceReference != 
                (PDEVICE_REFERENCE) &FdoExtension->DeviceReferenceList;
             DeviceReference = (PDEVICE_REFERENCE) DeviceReference->ListEntry.Flink) {
            if (DeviceReference->PhysicalDeviceObject) {
                if (DeviceReference->SweeperMarker < SweeperDeviceRemoval) {
                    ObReferenceObject( DeviceReference->PhysicalDeviceObject );
                    deviceRelations->Objects[ pdoCount++ ] = 
                        DeviceReference->PhysicalDeviceObject;
                } else {
                    DeviceReference->SweeperMarker= SweeperDeviceRemoved;
                }
            }
        }
    }

    deviceRelations->Count = pdoCount;
    *DeviceRelations = deviceRelations;

    if (RelationType == BusRelations) {
        ExReleaseFastMutexUnsafe( &FdoExtension->DeviceListMutex );
        KeLeaveCriticalRegion();
    }
    
    _DbgPrintF( DEBUGLVL_BLAB, ("QueryDeviceRelations, exit") );
    
    return STATUS_SUCCESS;
}


NTSTATUS 
EnumerateRegistrySubKeys(
    IN HANDLE ParentKey,
    IN PWCHAR Path OPTIONAL,
    IN PFNREGENUM_CALLBACK EnumCallback,
    IN PVOID EnumContext
    )

/*++

Routine Description:
    Enumerates the registry keys and calls the callback with
    

Arguments:
    IN HANDLE ParentKey -
       handle to the parent registry key
       
    IN PWCHAR Path OPTIONAL -
       path to registry key relative to the parent

    IN PFNREGENUM_CALLBACK EnumCallback -
        enumeration callback function
        
    IN PVOID EnumContext -
        context passed to callback

Return:
    STATUS_SUCCESS if successful, STATUS_INSUFFFICIENT resources if unable
    to allocate pool memory otherwise the status return from the callback
    function.

--*/

{

    HANDLE                  EnumPathKey;
    KEY_FULL_INFORMATION    FullKeyInformation;
    NTSTATUS                Status;
    OBJECT_ATTRIBUTES       ObjectAttributes;
    PKEY_BASIC_INFORMATION  KeyInformation;
    ULONG                   Index, InformationSize, ReturnedSize;
    UNICODE_STRING          KeyName;
    
    PAGED_CODE();
    
    //
    // Enumerate the reference strings associated with this device
    // (the path is relative to the DeviceKey).
    //

    RtlInitUnicodeString( &KeyName, Path );
    InitializeObjectAttributes( 
        &ObjectAttributes, 
        &KeyName, 
        OBJ_CASE_INSENSITIVE,
        ParentKey,
        (PSECURITY_DESCRIPTOR) NULL );

    if (!NT_SUCCESS( Status = 
                        ZwOpenKey( 
                            &EnumPathKey, 
                            KEY_READ,
                            &ObjectAttributes ) )) {
        _DbgPrintF( 
            DEBUGLVL_VERBOSE, 
            ("ZwOpenKey (%s) returned %x", Path, Status) );
        return Status; 
    }

    //
    // Prepare to enumerate the subkeys.
    //

    KeyInformation = NULL;
    if (!NT_SUCCESS( Status = 
                        ZwQueryKey( 
                            EnumPathKey,
                            KeyFullInformation,
                            &FullKeyInformation,
                            sizeof( FullKeyInformation ),
                            &ReturnedSize ) )) {
        _DbgPrintF( DEBUGLVL_VERBOSE, ("ZwQueryKey returned %x", Status) );
    } else { 
        _DbgPrintF( 
            DEBUGLVL_BLAB, 
            ("subkeys: %d", FullKeyInformation.SubKeys) );

        InformationSize = 
            sizeof( KEY_BASIC_INFORMATION ) + 
                FullKeyInformation.MaxNameLen * sizeof( WCHAR ) + 
                    sizeof( UNICODE_NULL );
            
        KeyInformation = 
            (PKEY_BASIC_INFORMATION) 
                ExAllocatePoolWithTag( 
                    PagedPool, 
                    InformationSize,
                    POOLTAG_KEY_INFORMATION );
    }

    if (NULL == KeyInformation) {
        ZwClose( EnumPathKey );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Perform the enumeration.
    //

    for (Index =0; Index < FullKeyInformation.SubKeys; Index++) {
        if (NT_SUCCESS( Status = 
                            ZwEnumerateKey( 
                                EnumPathKey,
                                Index, 
                                KeyBasicInformation,
                                KeyInformation,
                                InformationSize,
                                &ReturnedSize ) )) {

            //
            // NULL terminate the key name.
            //

            KeyInformation->Name[ KeyInformation->NameLength / sizeof( WCHAR ) ] = UNICODE_NULL;
            RtlInitUnicodeString( 
                &KeyName, 
                KeyInformation->Name );
        
            //
            // Call the callback.
            //         
        
            Status = 
                EnumCallback( EnumPathKey, &KeyName, EnumContext );
                
            if (!NT_SUCCESS( Status )) {
                break;
            }
        }
    }

    ExFreePool( KeyInformation );
    ZwClose( EnumPathKey );
    
    return Status ;
}        

VOID 
ClearDeviceReferenceMarks(
    IN PFDO_EXTENSION FdoExtension
)

/*++

Routine Description:
    Walks the device reference list, clearing all reference marks.

Arguments:
    IN PFDO_EXTENSION FdoExtension -

    N.B.: 
        This routine requires that the DeviceListMutex has been acquired.
    
Return:
    Nothing.

--*/

{
    PDEVICE_REFERENCE  DeviceReference;
    
    PAGED_CODE();
    
    DeviceReference = 
        (PDEVICE_REFERENCE) FdoExtension->DeviceReferenceList.Flink;

    for (DeviceReference =
            (PDEVICE_REFERENCE) FdoExtension->DeviceReferenceList.Flink;
         DeviceReference != 
            (PDEVICE_REFERENCE) &FdoExtension->DeviceReferenceList;
         DeviceReference = (PDEVICE_REFERENCE) DeviceReference->ListEntry.Flink) {
         DeviceReference->Referenced = FALSE;
    }
}


VOID 
RemoveDeviceAssociations(
    IN PDEVICE_REFERENCE DeviceReference
    )

/*++

Routine Description:
    Removes the device association structures attached to the device
    reference.
    
    N.B.: 
        This routine requires that the DeviceListMutex has been acquired.

Arguments:
    IN PDEVICE_REFERENCE DeviceReference -
        pointer to the device reference structure

Return:
    Nothing.

--*/

{
    PDEVICE_ASSOCIATION     DeviceAssociation, NextAssociation;
    
    PAGED_CODE();
    
    for (DeviceAssociation =
            (PDEVICE_ASSOCIATION) DeviceReference->DeviceAssociations.Flink;
         DeviceAssociation != 
            (PDEVICE_ASSOCIATION) &DeviceReference->DeviceAssociations;
         DeviceAssociation = NextAssociation) {
         
        NextAssociation = 
            (PDEVICE_ASSOCIATION) DeviceAssociation->ListEntry.Flink;

        if (DeviceAssociation->linkName.Buffer) {
        
            //
            // Remove device interface association...
            //
            
            IoSetDeviceInterfaceState( &DeviceAssociation->linkName, FALSE);    
            
            //
            // and free the symbolic link.
            //
            
            ExFreePool( DeviceAssociation->linkName.Buffer );
            DeviceAssociation->linkName.Buffer = NULL;
        }
    
        //
        // unlink and free the association structure
        //
        
        RemoveEntryList( &DeviceAssociation->ListEntry );
        ExFreePool( DeviceAssociation );
    }
}


VOID
RemoveUnreferencedDevices(
    IN PFDO_EXTENSION FdoExtension
    )

/*++

Routine Description:
    Removes device references from the list which are not marked.

    N.B.: 
        This routine requires that the DeviceListMutex has been acquired.
    
Arguments:
    IN PFDO_EXTENSION FdoExtension -
        pointer to the FDO device extension

Return:
    No return value.

--*/

{
    PDEVICE_REFERENCE   DeviceReference, NextReference;

    PAGED_CODE();
    
    //
    // Scan the device reference list looking for unmarked entries
    //

    for (DeviceReference =
            (PDEVICE_REFERENCE) FdoExtension->DeviceReferenceList.Flink;
         DeviceReference != 
            (PDEVICE_REFERENCE) &FdoExtension->DeviceReferenceList;
            DeviceReference = NextReference) {

        NextReference = (PDEVICE_REFERENCE) DeviceReference->ListEntry.Flink;

        if (!DeviceReference->Referenced) {
            PIRP    Irp;
        
            //
            // Remove the links, this will make the device invisible from
            // user mode.
            //
            RemoveDeviceAssociations( DeviceReference );
            
            //
            // Any IRP (IRP_MJ_CREATE) on the list is completed with 
            // STATUS_OBJECT_NAME_NOT_FOUND as this device referenece is
            // no longer active.
            //
            
            while (!IsListEmpty( &DeviceReference->IoQueue )) {
                PLIST_ENTRY         ListEntry;
                
                ListEntry = RemoveHeadList( &DeviceReference->IoQueue );
                Irp = 
                    CONTAINING_RECORD( ListEntry, IRP, Tail.Overlay.ListEntry );
                Irp->IoStatus.Status = STATUS_OBJECT_NAME_NOT_FOUND;
                IoCompleteRequest( Irp, IO_NO_INCREMENT );
            }
    
            //
            // If there is an associated device object, this
            // reference structure can not be removed until
            // all references to the device object are released.
            //
                
            if (!DeviceReference->PhysicalDeviceObject) {
            
                //
                // If the bus reference string was allocated, clean it up.
                //    
                
                if (DeviceReference->BusReferenceString) {
                    ExFreePool( DeviceReference->BusReferenceString );
                    DeviceReference->BusReferenceString = NULL;
                }
            
                if (DeviceReference->DeviceGuidString) {
                    ExFreePool( DeviceReference->DeviceGuidString );
                    DeviceReference->DeviceGuidString = NULL;
                }
                
                //
                // There is no physical device object, it is safe
                // to remove the device reference.
                //
                RemoveEntryList( &DeviceReference->ListEntry );
                ExFreePool( DeviceReference );
            }
        }
    }
}


NTSTATUS 
RegisterDeviceAssociation(
    IN PFDO_EXTENSION FdoExtension,
    IN PDEVICE_REFERENCE DeviceReference,
    IN PDEVICE_ASSOCIATION DeviceAssociation
    )

/*++

Routine Description:
    Registers the device interface association with Plug-N-Play

Arguments:
    IN PFDO_EXTENSION FdoExtension -
        pointer to the FDO extension

    IN PDEVICE_REFERENCE DeviceReference -
        pointer to the device reference structure

    IN PDEVICE_ASSOCIATION DeviceAssociation -
        pointer to the device association structure

Return:

--*/

{
    NTSTATUS        Status;
    UNICODE_STRING  BusReferenceString;
    
    PAGED_CODE();
    
    //
    // Register the device interface association
    //
    
    RtlInitUnicodeString( 
        &BusReferenceString, 
        DeviceReference->BusReferenceString );

    Status = 
        IoRegisterDeviceInterface(
            FdoExtension->PhysicalDeviceObject,
            &DeviceAssociation->InterfaceId,
            &BusReferenceString,
            &DeviceAssociation->linkName );

    //
    // Set up the device interface association (e.g. symbolic link).
    //

    if (NT_SUCCESS( Status )) {
        _DbgPrintF( 
            DEBUGLVL_BLAB, 
            ("linkName = %S", DeviceAssociation->linkName.Buffer) );

        Status = 
            IoSetDeviceInterfaceState(
                &DeviceAssociation->linkName, 
                TRUE );
        
        if (!NT_SUCCESS( Status )) {
            if (DeviceAssociation->linkName.Buffer) {
                ExFreePool( DeviceAssociation->linkName.Buffer );
                DeviceAssociation->linkName.Buffer = NULL;
            }
        }        
    }

    return Status;    
}


NTSTATUS 
CreateDeviceAssociation(
    IN HANDLE InterfaceKey,
    IN PUNICODE_STRING KeyName,
    IN PVOID EnumContext
    )

/*++

Routine Description:
    Creates a device association structure, this is stored per
    InterfaceKey/Reference String combination -- this function is
    called as a result of enumeration of the interface branch of a 
    device.

Arguments:
    IN HANDLE InterfaceKey -
        Handle to the interface branch in the registry

    IN PUNICODE_STRING KeyName -
        Enumerated key name

    IN PVOID EnumContext -
        Context pointer

Return:
    STATUS_SUCCESS or an appropriate error return

--*/

{
    NTSTATUS                    Status;
    GUID                        InterfaceId;
    PCREATE_ASSOCIATION_CONTEXT CreateAssociationContext = EnumContext;
    PDEVICE_ASSOCIATION         DeviceAssociation;
    
    PAGED_CODE();
    
    _DbgPrintF( DEBUGLVL_BLAB, ("CreateDeviceAssociation") );
    
    //
    // Convert to GUID and scan for this interface ID
    //    

    RtlGUIDFromString( KeyName, &InterfaceId );
    
    for (DeviceAssociation = 
            (PDEVICE_ASSOCIATION) CreateAssociationContext->DeviceReference->DeviceAssociations.Flink;
         DeviceAssociation !=
            (PDEVICE_ASSOCIATION) &CreateAssociationContext->DeviceReference->DeviceAssociations;
         DeviceAssociation =
            (PDEVICE_ASSOCIATION) DeviceAssociation->ListEntry.Flink) {
        if (IsEqualGUIDAligned( &DeviceAssociation->InterfaceId, &InterfaceId )) {
            _DbgPrintF(
                DEBUGLVL_BLAB,
                ("device association exists, return STATUS_SUCCESS") );
            return STATUS_SUCCESS;
        }
    }            
    
    
    DeviceAssociation = 
        (PDEVICE_ASSOCIATION) 
            ExAllocatePoolWithTag( 
                PagedPool,
                sizeof( DEVICE_ASSOCIATION ),
                POOLTAG_DEVICE_ASSOCIATION );

    if (NULL == DeviceAssociation) {
        _DbgPrintF(
            DEBUGLVL_VERBOSE,
            ("out of memory while allocating device association") );

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    
    RtlZeroMemory( DeviceAssociation, sizeof( DEVICE_ASSOCIATION ) );
    DeviceAssociation->InterfaceId = InterfaceId;

    //
    // Register the interface association
    //

    Status = 
        RegisterDeviceAssociation( 
            CreateAssociationContext->FdoExtension,
            CreateAssociationContext->DeviceReference,
            DeviceAssociation );

    if (NT_SUCCESS( Status )) {
        //
        // everything was successful with this association,
        // add to the list.
        //

        InsertTailList( 
            &CreateAssociationContext->DeviceReference->DeviceAssociations,
            &DeviceAssociation->ListEntry );
    } else {
        //
        // A failure occured, remove this association structure.
        //

        ExFreePool( DeviceAssociation );
    }

    return Status;    
}


NTSTATUS 
CreateDeviceReference(
    IN HANDLE DeviceReferenceKey,
    IN PUNICODE_STRING KeyName,
    IN PVOID EnumContext
    )

/*++

Routine Description:
    If the device reference does not already exist on this bus, creates a 
    device reference structure and initializes it with the given device
    GUID and reference string.  If the reference already exists, the reference 
    is marked.
    
    N.B.: 
        This routine requires that the DeviceListMutex has been acquired.

Arguments:
    IN HANDLE DeviceReferenceKey -
        handle to the parent key 
            (HKLM\CCS\Services\swenum\devices\{device-guid})

    IN PUNICODE_STRING KeyName -
        string containing key name (reference string)

    IN PVOID EnumContext -
        enumeration context (PCREATE_DEVICE_ASSOCATION)

Return:
    STATUS_SUCCESS or an appropriate STATUS return.

--*/

{
    BOOLEAN                     Created;
    NTSTATUS                    Status;
    PCREATE_ASSOCIATION_CONTEXT CreateAssociationContext = EnumContext;
    PDEVICE_REFERENCE           DeviceReference;
    PFDO_EXTENSION              FdoExtension;
    PWCHAR                      BusReferenceString;
    ULONG                       BusReferenceStringSize;
    ULONG                       InformationSize;

    PAGED_CODE();
    
    _DbgPrintF( DEBUGLVL_BLAB, ("CreateDeviceReference") );
    
    FdoExtension = CreateAssociationContext->FdoExtension;

    //
    // Scan the device reference list looking for a matching on
    // the device-guid reference-string pair.
    //
    BusReferenceStringSize =
        (2 + wcslen( CreateAssociationContext->DeviceGuidString->Buffer ) +
         wcslen( KeyName->Buffer )) * sizeof( WCHAR );

    BusReferenceString =
        ExAllocatePoolWithTag( 
            PagedPool, 
            BusReferenceStringSize,
            POOLTAG_DEVICE_BUSREFERENCE );
            
    if (NULL == BusReferenceString) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // The bus reference string is in the following format:
    // {device-guid}&{reference-string}
    //

    if (FAILED( StringCbPrintf(
                    BusReferenceString,
                    BusReferenceStringSize,
                    BusReferenceStringFormat,
                    CreateAssociationContext->DeviceGuidString->Buffer,
                    KeyName->Buffer ) )) {
        ExFreePool( BusReferenceString );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    _DbgPrintF( DEBUGLVL_BLAB, ("CreateDeviceReference() scanning for: %S", BusReferenceString) );
    
    for (DeviceReference =
            (PDEVICE_REFERENCE) FdoExtension->DeviceReferenceList.Flink;
         DeviceReference != 
            (PDEVICE_REFERENCE) &FdoExtension->DeviceReferenceList;
         DeviceReference = (PDEVICE_REFERENCE) DeviceReference->ListEntry.Flink) {
         
        if ((DeviceReference->BusReferenceString) && 
            (0 == 
                _wcsicmp( 
                    BusReferenceString,
                    DeviceReference->BusReferenceString ))) {
            //
            // Already referenced this device, just set the flag.
            //

            _DbgPrintF( DEBUGLVL_BLAB, ("marking device reference" ) );
            DeviceReference->Referenced = TRUE;
            Created = FALSE;
            break;
        }
    }

    //
    // If the device reference was not found, create a new one.
    //    
    
    if (DeviceReference == 
            (PDEVICE_REFERENCE) &FdoExtension->DeviceReferenceList) {
    
        Created = TRUE;

        //
        // Allocate the device reference structure.
        //

        InformationSize = 
            FIELD_OFFSET( DEVICE_REFERENCE, DeviceReferenceString ) + 
                KeyName->Length + sizeof( UNICODE_NULL );

        //
        // Allocate the device reference structure, copy the GUID string
        // and initialize other members.
        //

        if (NULL == 
                (DeviceReference = 
                    ExAllocatePoolWithTag( 
                        PagedPool, 
                        InformationSize,
                        POOLTAG_DEVICE_REFERENCE ))) {
            ExFreePool( BusReferenceString );
            return STATUS_INSUFFICIENT_RESOURCES;
        }
                               
        RtlZeroMemory( 
            DeviceReference, 
            FIELD_OFFSET( DEVICE_REFERENCE, DeviceReferenceString ) );
        RtlCopyMemory( 
            DeviceReference->DeviceReferenceString, 
            KeyName->Buffer, 
            KeyName->Length + sizeof( UNICODE_NULL ) );

        //
        // Allocate the storage for the device GUID string (used for the Bus ID)
        //        

        if (NULL == 
                (DeviceReference->DeviceGuidString =
                    ExAllocatePoolWithTag(
                        PagedPool,
                        CreateAssociationContext->DeviceGuidString->Length +
                            sizeof( UNICODE_NULL ),
                        POOLTAG_DEVICE_ID ))) {
            ExFreePool( DeviceReference );                
            ExFreePool( BusReferenceString );
            return STATUS_INSUFFICIENT_RESOURCES;                
        } else {
            RtlCopyMemory( 
                DeviceReference->DeviceGuidString, 
                CreateAssociationContext->DeviceGuidString->Buffer, 
                CreateAssociationContext->DeviceGuidString->Length + 
                    sizeof( UNICODE_NULL ) );
            RtlGUIDFromString( 
                CreateAssociationContext->DeviceGuidString, 
                &DeviceReference->DeviceId );
        }

        InitializeListHead( &DeviceReference->IoQueue );
        DeviceReference->Referenced = TRUE;

        //
        // Initialize the timeout period and set the initial idle start time.
        //

        DeviceReference->TimeoutPeriod.QuadPart = 
            SWEEPER_TIMER_FREQUENCY_IN_SECS * FdoExtension->CounterFrequency.QuadPart;

        DeviceReference->IdleStartTime = KeQueryPerformanceCounter( NULL );

        //
        // Store the pointer to the bus reference string.
        //
        
        DeviceReference->BusReferenceString = BusReferenceString;
        
        //
        // Prepare the list of device associations
        //
        
        InitializeListHead( &DeviceReference->DeviceAssociations );
        
        _DbgPrintF( 
            DEBUGLVL_BLAB, 
            ("created device reference: %S", 
            DeviceReference->BusReferenceString) );
    } else {
        //
        // Free the BusReferenceString, it is no longer needed because
        // we found a match.
        //

        ExFreePool( BusReferenceString );
        BusReferenceString = NULL;
    }
    
    //
    // Enumerate the device interface guids associated with this device.
    //
    
    CreateAssociationContext->DeviceReference = DeviceReference;
    CreateAssociationContext->DeviceReferenceString = KeyName;
    
    Status = 
        EnumerateRegistrySubKeys( 
            DeviceReferenceKey, 
            KeyName->Buffer,
            CreateDeviceAssociation,
            CreateAssociationContext );
    
    //
    // If there are no associations, we have an invalid state.
    // 
    
    if (IsListEmpty( &DeviceReference->DeviceAssociations )) {
    
        _DbgPrintF( 
            DEBUGLVL_VERBOSE, 
            ("no associations, removing the device reference") );
        if (DeviceReference->DeviceGuidString) {
            ExFreePool( DeviceReference->DeviceGuidString );
            DeviceReference->DeviceGuidString = NULL;
        }
        if (DeviceReference->BusReferenceString) {    
            ExFreePool( DeviceReference->BusReferenceString );        
            DeviceReference->BusReferenceString = NULL;
        }
        ExFreePool( DeviceReference );
        Status = STATUS_INVALID_DEVICE_STATE;
        
    } else if (Created) {
    
        if (NT_SUCCESS( Status )) {
                //
                // Add this device reference to the list.
                //

                InsertTailList( 
                    &FdoExtension->DeviceReferenceList,
                    &DeviceReference->ListEntry );

        } else {

            //
            // Walk the list and remove any device association stragglers.
            //
            
            RemoveDeviceAssociations( DeviceReference );
            if (DeviceReference->BusReferenceString) {
                ExFreePool( DeviceReference->BusReferenceString );
                DeviceReference->BusReferenceString = NULL;
            }
        
            if (DeviceReference->DeviceGuidString) {
                ExFreePool( DeviceReference->DeviceGuidString );
                DeviceReference->DeviceGuidString = NULL;
            }
            ExFreePool( DeviceReference );
        }
    }    

    return Status;
}


NTSTATUS 
EnumerateDeviceReferences(
    IN HANDLE DeviceListKey,
    IN PUNICODE_STRING KeyName,
    IN PVOID EnumContext
    )

/*++

Routine Description:
    If the device reference does not already exist on this bus, creates a 
    device reference structure and initializes it with the given device
    GUID.  If the reference already exists, the reference is marked.
    
    N.B.: 
        This routine requires that the DeviceListMutex has been acquired.

Arguments:
    IN HANDLE DeviceListKey -
        handle to the parent key (HKLM\CCS\Services\swenum\devices)

    IN PUNICODE_STRING KeyName -
        string containing key name (device GUID string)

    IN PVOID EnumContext -
        enumeration context (FdoExtension)

Return:
    STATUS_SUCCESS or an appropriate STATUS return.

--*/
{
    CREATE_ASSOCIATION_CONTEXT  CreateAssociationContext;
    
    //
    // The association context is built upon during the traversal
    // of the devices listed in the registry.  The initial state
    // includes this FDO and the device GUID string.
    //
    
    RtlZeroMemory( 
        &CreateAssociationContext, 
        sizeof( CREATE_ASSOCIATION_CONTEXT ) );
    
    CreateAssociationContext.FdoExtension = EnumContext;
    CreateAssociationContext.DeviceGuidString = KeyName;
    
    //
    // Enumerate the device guids from the registry.
    //
    
    return
        EnumerateRegistrySubKeys( 
            DeviceListKey,
            KeyName->Buffer,
            CreateDeviceReference,
            &CreateAssociationContext );
}


NTSTATUS
ScanBus(
    IN PDEVICE_OBJECT FunctionalDeviceObject
    )

/*++

Routine Description:
    Scans the "software bus" looking for new or removed entries in
    the registry.

    NOTE: 
    
        This function is always called in the context of the system
        process so that registry handles are tucked away safely from
        rogue user-mode applications.

        From user-mode, the IOCTL that initiates an installation, removal, or
        scan always results in a worker in the system process to do the actual
        work.

Arguments:
    IN PFDO_EXTENSION FdoExtension -
        pointer to the FDO device extension

Return:
    STATUS_SUCCESS or an appropriate error code

--*/

{
    HANDLE                  DeviceInterfacesKey;
    NTSTATUS                Status;
    PFDO_EXTENSION          FdoExtension;

    PAGED_CODE();

    _DbgPrintF( DEBUGLVL_BLAB, ("ScanBus") );

    FdoExtension = *(PFDO_EXTENSION *) FunctionalDeviceObject->DeviceExtension;
    
    //
    // Open driver registry path
    //
    
    if (!NT_SUCCESS( Status = 
            OpenDeviceInterfacesKey( 
                &DeviceInterfacesKey,
                &FdoExtension->BaseRegistryPath ) )) {
        return Status;
    }

    //
    // Clear reference marks in the reference list.
    //

    ClearDeviceReferenceMarks( FdoExtension );
    
    //
    // Enumerate the device guids from the registry.
    //
    
    Status = 
        EnumerateRegistrySubKeys( 
            DeviceInterfacesKey,
            NULL,
            EnumerateDeviceReferences,
            FdoExtension );
            
    //
    // This removes the device reference structure for each 
    // unreferenced device.
    //
    
    RemoveUnreferencedDevices( FdoExtension );
    
    ZwClose( DeviceInterfacesKey );
    
    return Status;
}


NTSTATUS
CreatePdo(
    IN PFDO_EXTENSION FdoExtension,
    IN PDEVICE_REFERENCE DeviceReference,
    OUT PDEVICE_OBJECT *DeviceObject
)

/*++

Routine Description:
    Creates a PDO for the given device reference.

Arguments:
    IN PFDO_EXTENSION FdoExtension -
        pointer to FDO device extension

    IN PDEVICE_REFERENCE DeviceReference -
        pointer to the device reference structure

    OUT PDEVICE_OBJECT *DeviceObject -
        pointer to receive the device object

Return:
    STATUS_SUCCESS else an appropriate error return

--*/

{
    NTSTATUS Status;
    PDRIVER_OBJECT  DriverObject;
    PDEVICE_OBJECT  FunctionalDeviceObject;
    PDEVICE_OBJECT  PhysicalDeviceObject;
    PPDO_EXTENSION  PdoExtension;
    WCHAR           DeviceName[ 64 ];
    UNICODE_STRING  DeviceNameString;

    PAGED_CODE();

    //
    // We've been asked to create a new PDO a device.  First get
    // a pointer to our driver object.
    //

    FunctionalDeviceObject = FdoExtension->FunctionalDeviceObject;
    DriverObject = FunctionalDeviceObject->DriverObject;
    
    DeviceReference->State = ReferenceAdded;
    
    if (FAILED( StringCbPrintf(
                    DeviceName,
                    sizeof( DeviceName ),
                    DeviceReferencePrefix,
                    InterlockedIncrement( &UniqueId ) ) )) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlInitUnicodeString( &DeviceNameString, DeviceName );

    //
    // Create the physical device object for this device.  
    //

    Status = IoCreateDevice(
                DriverObject,               // our driver object
                sizeof( PPDO_EXTENSION ),   // size of our extension,
                &DeviceNameString,          // the name of our PDO
                FILE_DEVICE_UNKNOWN,        // device type
                0,                          // device characteristics
                FALSE,                      // not exclusive
                &PhysicalDeviceObject       // store new device object here
                );

    if( !NT_SUCCESS( Status )){

        return Status;
    }

    PdoExtension = 
        ExAllocatePoolWithTag( 
            NonPagedPool, 
            sizeof( PDO_EXTENSION ), 
            POOLTAG_DEVICE_PDOEXTENSION );
    
    if (NULL == PdoExtension) {
        IoDeleteDevice( PhysicalDeviceObject );
        return STATUS_INSUFFICIENT_RESOURCES;
    }        
    
    *(PPDO_EXTENSION *) PhysicalDeviceObject->DeviceExtension = PdoExtension;
    RtlZeroMemory( PdoExtension, sizeof( PDO_EXTENSION ) );

    //
    // We have our physical device object, initialize it.
    //

    PdoExtension->ExtensionType = ExtensionTypePdo;
    PdoExtension->PhysicalDeviceObject = PhysicalDeviceObject;
    PdoExtension->DeviceReference = DeviceReference;
    PdoExtension->BusDeviceExtension = FdoExtension;
    
    //
    // This device reference is now active.
    //
    
    DeviceReference->SweeperMarker = SweeperDeviceActive;

    //
    // Short initial timeout period, waiting for device load.
    //
    DeviceReference->IdleStartTime = KeQueryPerformanceCounter( NULL );
#if (DEBUG_LOAD_TIME)
    DeviceReference->LoadTime = DeviceReference->IdleStartTime;
#endif
    DeviceReference->TimeoutRemaining.QuadPart =
        FdoExtension->CounterFrequency.QuadPart *
        SWEEPER_TIMER_FREQUENCY_IN_SECS * 2L; 
    
    //
    // Clear the device initializing flag.
    //
    
    PhysicalDeviceObject->Flags |= DO_POWER_PAGABLE;
    PhysicalDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
    
    //
    // Try to remove this PDO later if there is no response 
    // from the device.
    //
    
    if (!InterlockedExchange( &FdoExtension->TimerScheduled, TRUE )) {
            
        LARGE_INTEGER Freq;
        
        Freq.QuadPart = SWEEPER_TIMER_FREQUENCY;
        KeSetTimer( 
            &FdoExtension->SweeperTimer,
            Freq,
            &FdoExtension->SweeperDpc );
    }        
    
    *DeviceObject = PhysicalDeviceObject;
    
    return STATUS_SUCCESS;
}


NTSTATUS
QueryId(
    IN PPDO_EXTENSION PdoExtension,
    IN BUS_QUERY_ID_TYPE IdType,
    IN OUT PWSTR *BusQueryId
    )

/*++

Routine Description:
    Processes the PnP IRP_MN_QUERY_ID for the PDO.

Arguments:
    IN PPDO_EXTENSION PdoExtension -
        pointer to the PDO device extension

    IN BUS_QUERY_ID_TYPE IdType -
        query ID type

    IN OUT PWSTR *BusQueryId -
        pointer to receive the bus query string

Return:
    STATUS_SUCCESS, STATUS_INSUFFICIENT_RESOURCES if pool allocation failure
    otherwise STATUS_NOT_SUPPORTED if an invalid ID type is provided.

--*/

{
    NTSTATUS Status;
    PWSTR IdString;

    PAGED_CODE();

    switch( IdType ) {

    case BusQueryHardwareIDs:
    case BusQueryDeviceID:

        //
        // Caller wants the bus ID of this device.
        //

        //
        // Note that the returned string is a double NULL-terminated multi-sz.
        // Plug and Play only requires this for BusQueryHardwareIDs (also
        // BusQueryCompatibleIDs, which we do not support) but having an extra
        // NULL-terminating character for BusQueryDeviceID doesn't hurt.
        //

        IdString = BuildBusId( PdoExtension );
        break;

    case BusQueryInstanceID:

        //
        // Caller wants the instance ID of this device.
        //

        IdString = BuildInstanceId( PdoExtension );
        break;

    default:

        return STATUS_NOT_SUPPORTED;

    }

    if (IdString != NULL) {
        _DbgPrintF( DEBUGLVL_BLAB, ("QueryId returns: %S", IdString) );
        *BusQueryId = IdString;
        Status = STATUS_SUCCESS;
    } else {
        _DbgPrintF( DEBUGLVL_VERBOSE, ("QueryId returning failure.") );
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;
}


PWSTR
BuildBusId(
    IN PPDO_EXTENSION PdoExtension
    )

/*++

Routine Description:
    Builds the bus identifier string given the PDO extension.

Arguments:
    IN PPDO_EXTENSION PdoExtension
        pointer to the PDO extension 

Return:
    NULL or a pointer to the bus ID string.

--*/

{
    PWSTR strId;
    ULONG length;

    PAGED_CODE();

    //
    // Allocate the ID string. The initial count of two includes the separator
    // and the trailing UNICODE_NULL. 
    //
    
    length = 
        (2 + wcslen( PdoExtension->DeviceReference->DeviceGuidString  ) + 
         wcslen( PdoExtension->BusDeviceExtension->BusPrefix )) * sizeof( WCHAR ) + 
            sizeof( UNICODE_NULL );
    strId =
        ExAllocatePoolWithTag(
            PagedPool,
            length,
            POOLTAG_DEVICE_BUSID );

    if ( strId != NULL ) {

        //
        // Form the multi-sz string and return it.
        //

        if (FAILED( StringCbPrintf(
                        strId,
                        length,
                        BusIdFormat,
                        PdoExtension->BusDeviceExtension->BusPrefix,
                        PdoExtension->DeviceReference->DeviceGuidString,
                        L'\0' ) )) {
            ExFreePool( strId );
            strId = NULL;
        }
    }

    return strId;
}


PWSTR
BuildInstanceId(
    IN PPDO_EXTENSION PdoExtension
    )

/*++

Routine Description:
    Builds the instance identifier string given the PDO extension.

Arguments:
    IN PPDO_EXTENSION PdoExtension
        pointer to the PDO extension 

Return:
    NULL or a pointer to the instance ID string.

--*/

{
    PWSTR strId;
    ULONG length;

    PAGED_CODE();

    //
    // Allocate the ID string.
    //
    
    length =
        (wcslen( PdoExtension->DeviceReference->DeviceReferenceString ) *
         sizeof( WCHAR )) +
             sizeof( UNICODE_NULL );

    strId =
        ExAllocatePoolWithTag(
            PagedPool,
            length,
            POOLTAG_DEVICE_INSTANCEID );

    if ( strId != NULL ) {

        //
        // Form the string and return it.
        //

        if (FAILED( StringCbCopy(
                        strId,
                        length,
                        PdoExtension->DeviceReference->DeviceReferenceString ) )) {
            ExFreePool( strId );
            strId = NULL;
        }
    }

    return strId;
}


VOID
KspInstallBusEnumInterface(
    IN PWORKER_CONTEXT WorkerContext
    )

/*++

Routine Description:
    This is the internal routine which does the actual work of modifying
    the registry and enumerating the new child interface.

    NOTE: 
    
        This function is always called in the context of the system
        process so that registry handles are tucked away safely from
        rogue user-mode applications.

Arguments:
    IN PWORKER_CONTEXT WorkerContext -
        contains a pointer to the context for the worker

Return:
    STATUS_SUCCESS or an appropriate error code

--*/


{
    PFDO_EXTENSION              FdoExtension;
    PIO_STACK_LOCATION          irpSp;
    PIRP                        Irp;
    PDEVICE_REFERENCE           DeviceReference;
    PSWENUM_INSTALL_INTERFACE   SwEnumInstallInterface;
    NTSTATUS                    Status;
    ULONG                       NullLocation;

    Irp = WorkerContext->Irp;

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    Status = STATUS_SUCCESS;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength < 
            sizeof( SWENUM_INSTALL_INTERFACE )) {
        Status = STATUS_INVALID_PARAMETER;
    } 
    
    if (NT_SUCCESS( Status )) {
        FdoExtension = *(PFDO_EXTENSION *) irpSp->DeviceObject->DeviceExtension;
        SwEnumInstallInterface = 
            (PSWENUM_INSTALL_INTERFACE) Irp->AssociatedIrp.SystemBuffer;
        
        //
        // Make sure that the string is UNICODE_NULL terminated.  Note that the
        // first two members of this structure are GUIDs and therefore WCHAR 
        // aligned.
        //

        //
        // N.B.  
        //
        // The ReferenceString member of SWENUM_INSTALL_INTERFACE is
        // defined as WCHAR[1].  There is always room for the UNICODE_NULL.
        //
        
        NullLocation = 
            irpSp->Parameters.DeviceIoControl.InputBufferLength >> 1;
        ((PWCHAR) Irp->AssociatedIrp.SystemBuffer)[ NullLocation - 1 ] = 
            UNICODE_NULL;
        
        //
        // Take the list mutex
        //    

        KeEnterCriticalRegion();
        ExAcquireFastMutexUnsafe( &FdoExtension->DeviceListMutex );     

        //
        // Install the interface
        //
        Status = 
            InstallInterface( 
                SwEnumInstallInterface,
                &FdoExtension->BaseRegistryPath );
        if (NT_SUCCESS( Status )) {
            //
            // If successful, force the re-enumeration of the bus.
            //    
            ScanBus( irpSp->DeviceObject );
            
            //
            // Walk the device reference scanning for our device.
            //
            
            Status = STATUS_NOT_FOUND;

            for (DeviceReference =
                    (PDEVICE_REFERENCE) FdoExtension->DeviceReferenceList.Flink;
                 DeviceReference != 
                    (PDEVICE_REFERENCE) &FdoExtension->DeviceReferenceList;
                 DeviceReference = (PDEVICE_REFERENCE) DeviceReference->ListEntry.Flink) {

                //
                // Search for the new device reference.
                //
                
                if (IsEqualGUIDAligned( 
                        &DeviceReference->DeviceId, 
                        &SwEnumInstallInterface->DeviceId )) {
                    if (DeviceReference->BusReferenceString &&
                        (0 == 
                            _wcsicmp( 
                                DeviceReference->DeviceReferenceString, 
                                SwEnumInstallInterface->ReferenceString ))) {
                                    
                        //
                        // Found the reference.  
                        //
                        
                        Status = STATUS_SUCCESS;
                        break;
                    }
                }       
            }
        
            if (NT_SUCCESS( Status )) {
                    
                //
                // If the PDO does not already exist, then create it and mark 
                // it as "FailedInstall".  This prevents other creates from 
                // blocking on this device until we actually complete the 
                // installation operation.
                //
                
                if (!DeviceReference->PhysicalDeviceObject) {

                    //
                    //  The device has not been instantiated.
                    //
                    Status = 
                        CreatePdo( 
                            FdoExtension, 
                            DeviceReference, 
                            &DeviceReference->PhysicalDeviceObject );

                    if (!NT_SUCCESS( Status )) {
                    
                        _DbgPrintF( 
                            DEBUGLVL_VERBOSE, 
                            ("KsInstallBusEnumInterface: unable to create PDO (%8x)", Status) );
                    
                    } else {
                        _DbgPrintF( 
                            DEBUGLVL_BLAB, 
                            ("KsInstallBusEnumInterface: created PDO (%8x)", 
                                DeviceReference->PhysicalDeviceObject) );
                    }
                }    
                
            }    
            IoInvalidateDeviceRelations( 
                FdoExtension->PhysicalDeviceObject,
                BusRelations );
        } 
        ExReleaseFastMutexUnsafe( &FdoExtension->DeviceListMutex );    
        KeLeaveCriticalRegion();
    }
    
    WorkerContext->Status = Status;
    KeSetEvent( &WorkerContext->CompletionEvent, IO_NO_INCREMENT, FALSE );
}    


KSDDKAPI
NTSTATUS
NTAPI
KsInstallBusEnumInterface(
    IN PIRP Irp
    )
/*++

Routine Description:
    Services an I/O request for the parent device to install an interface 
    on the bus.  The Irp->AssociatedIrp.SystemBuffer is assumed to have a
    SWENUM_INSTALL_INTERFACE structure:

        typedef struct _SWENUM_INSTALL_INTERFACE {
            GUID   DeviceId;
            GUID   InterfaceId;
            WCHAR  ReferenceString[1];
            
        } SWENUM_INSTALL_INTERFACE, *PSWENUM_INSTALL_INTERFACE;


    where the DeviceId, InterfaceId and ReferenceString specify the specific
    device and interface with which to access this new interface.  When the
    interface as registered with Plug and Play for the interface GUID and 
    associated reference string is accessed the first time via IRP_MJ_CREATE, 
    the device will be enumerated using the format of 
    bus-identifier-prefix\device-id-GUID-string.

Arguments:
    IN PIRP Irp -
        pointer to I/O request containing SWENUM_INSTALL_INTERFACE structure

Return:
    STATUS_SUCCESS or an appropriate error code

--*/

{
    WORK_QUEUE_ITEM InstallWorker;
    WORKER_CONTEXT  WorkerContext;

    //
    // Do the processing of the installation in a worker item so that
    // registry handles are managed in the context of the system process.
    //

#if !defined( WIN9X_KS )
    if (!SeSinglePrivilegeCheck( 
            RtlConvertLongToLuid( SE_LOAD_DRIVER_PRIVILEGE ), 
            ExGetPreviousMode() )) {
        return STATUS_PRIVILEGE_NOT_HELD;
    }
#endif

    KeInitializeEvent( 
        &WorkerContext.CompletionEvent, NotificationEvent, FALSE );
    WorkerContext.Irp = Irp;
    ExInitializeWorkItem(
        &InstallWorker, KspInstallBusEnumInterface, &WorkerContext );
    ExQueueWorkItem( &InstallWorker, DelayedWorkQueue );
    KeWaitForSingleObject( 
        &WorkerContext.CompletionEvent, Executive, KernelMode, FALSE, NULL );

    return WorkerContext.Status;
}


NTSTATUS 
InstallInterface(
    IN PSWENUM_INSTALL_INTERFACE Interface,
    IN PUNICODE_STRING BaseRegistryPath
    )               

/*++

Routine Description:
    Creates the registry key for the interface in the SWENUM\Devices.

    NOTE: 
    
        This function is always called in the context of the system
        process so that registry handles are tucked away safely from
        rogue user-mode applications.

        From user-mode, the IOCTL that initiates an installation, removal, or
        scan always results in a worker in the system process to do the actual
        work.

Arguments:
    IN PSWENUM_INSTALL_INTERFACE Interface -

    IN PUNICODE_STRING BaseRegistryPath -
Return:

--*/

{
    HANDLE              DeviceIdKey, DeviceInterfacesKey, 
                        InterfaceKey, ReferenceStringKey;
    NTSTATUS            Status;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    UNICODE_STRING      DeviceIdString, InterfaceIdString, 
                        ReferenceString;
    PWCHAR              Ptr;

    _DbgPrintF( DEBUGLVL_BLAB, ("InstallInterface") );

    //
    // Validate interface reference string
    //

    if (Ptr = Interface->ReferenceString) {
        for (; *Ptr; *Ptr++) {
            if ((*Ptr <= L' ')  || (*Ptr > (WCHAR)0x7F) || (*Ptr == L',') || (*Ptr == L'\\') || (*Ptr == L'/')) {
                return STATUS_INVALID_PARAMETER;
            }
        }
    }

    //
    // Open driver registry path
    //
    
    if (!NT_SUCCESS( Status = 
            OpenDeviceInterfacesKey( 
                &DeviceInterfacesKey,
                BaseRegistryPath ) )) {
        return Status;
    }

    Status = 
        RtlStringFromGUID( 
            &Interface->DeviceId, 
            &DeviceIdString );
        
    if (!NT_SUCCESS( Status )) {
        _DbgPrintF( 
            DEBUGLVL_VERBOSE, 
            ("failed to create device ID string: %08x", Status) );
        ZwClose( DeviceInterfacesKey );
        return Status;
    }

    Status =
        RtlStringFromGUID( 
            &Interface->InterfaceId, 
            &InterfaceIdString );
    
    if (!NT_SUCCESS( Status )) {
        _DbgPrintF( 
            DEBUGLVL_VERBOSE, 
            ("failed to create interface ID string: %08x", Status) );
        RtlFreeUnicodeString( &DeviceIdString );
        ZwClose( DeviceInterfacesKey );
        return Status;
    }

    DeviceIdKey = 
        ReferenceStringKey = 
        InterfaceKey = 
            INVALID_HANDLE_VALUE;

    InitializeObjectAttributes( 
        &ObjectAttributes, 
        &DeviceIdString,
        OBJ_CASE_INSENSITIVE,
        DeviceInterfacesKey,
        (PSECURITY_DESCRIPTOR) NULL );

    Status = 
        ZwCreateKey( 
            &DeviceIdKey,
            KEY_WRITE,
            &ObjectAttributes,
            0,          // IN ULONG TitleIndex
            NULL,       // IN PUNICODE_STRING Class
            REG_OPTION_NON_VOLATILE,
            NULL );     // OUT PULONG Disposition
            
    if (NT_SUCCESS( Status )) {
        RtlInitUnicodeString( 
            &ReferenceString,
            Interface->ReferenceString );
        
        InitializeObjectAttributes( 
            &ObjectAttributes, 
            &ReferenceString,
            OBJ_CASE_INSENSITIVE,
            DeviceIdKey,
            (PSECURITY_DESCRIPTOR) NULL );
    
        Status = 
            ZwCreateKey( 
                &ReferenceStringKey,
                KEY_WRITE,
                &ObjectAttributes,
                0,          // IN ULONG TitleIndex
                NULL,       // IN PUNICODE_STRING Class
                REG_OPTION_NON_VOLATILE,
                NULL );     // OUT PULONG Disposition
    } 

    if (NT_SUCCESS( Status )) {
        InitializeObjectAttributes( 
            &ObjectAttributes, 
            &InterfaceIdString, 
            OBJ_CASE_INSENSITIVE,
            ReferenceStringKey,
            (PSECURITY_DESCRIPTOR) NULL );
    
        Status = 
            ZwCreateKey( 
                &InterfaceKey,
                KEY_WRITE,
                &ObjectAttributes,
                0,          // IN ULONG TitleIndex
                NULL,       // IN PUNICODE_STRING Class
                REG_OPTION_NON_VOLATILE,
                NULL );     // OUT PULONG Disposition
    } 

    if (InterfaceKey != INVALID_HANDLE_VALUE) {
        ZwClose( InterfaceKey );
    }

    if (ReferenceStringKey != INVALID_HANDLE_VALUE) {    
        ZwClose( ReferenceStringKey );
    }
    
    if (DeviceIdKey != INVALID_HANDLE_VALUE) {    
        ZwClose( DeviceIdKey );
    }    
    
    RtlFreeUnicodeString( &DeviceIdString );
    RtlFreeUnicodeString( &InterfaceIdString );

    ZwClose( DeviceInterfacesKey );
    
    _DbgPrintF( DEBUGLVL_VERBOSE, ("InstallInterface returning %08x", Status) );
    return Status;
}    


KSDDKAPI
NTSTATUS
NTAPI
KsGetBusEnumParentFDOFromChildPDO(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PDEVICE_OBJECT *FunctionalDeviceObject
    )

/*++

Routine Description:
    Retrieves the parent's functional device object (FDO) given a
    child physical device object (PDO).

Arguments:
    IN PDEVICE_OBJECT DeviceObject -
        Child device object

    OUT PDEVICE_OBJECT *FunctionalDeviceObject -
        Pointer to receive parent's FDO

Return:
    STATUS_SUCCESS or STATUS_INVALID_PARAMETER

--*/

{
    PPDO_EXTENSION PdoExtension;

    PAGED_CODE();
    PdoExtension = *(PPDO_EXTENSION *) DeviceObject->DeviceExtension;
    if (!PdoExtension) {
       return STATUS_INVALID_PARAMETER;
    }
    if (ExtensionTypePdo != PdoExtension->ExtensionType) {
        return STATUS_INVALID_PARAMETER;
    }

    *FunctionalDeviceObject =
        PdoExtension->BusDeviceExtension->FunctionalDeviceObject;

    return STATUS_SUCCESS;
}


VOID
KspRemoveBusEnumInterface(
    IN PWORKER_CONTEXT WorkerContext
    )

/*++

Routine Description:
    This is the internal routine which does the actual work of modifying
    the registry.

    NOTE: 
    
        This function is always called in the context of the system
        process so that registry handles are tucked away safely from
        rogue user-mode applications.

Arguments:
    IN PWORKER_CONTEXT WorkerContext -
        contains a pointer to the context for the worker

Return:
    STATUS_SUCCESS or an appropriate error code

--*/


{
    PFDO_EXTENSION              FdoExtension;
    PIO_STACK_LOCATION          irpSp;
    PIRP                        Irp;
    PSWENUM_INSTALL_INTERFACE   SwEnumInstallInterface;
    NTSTATUS                    Status;
    ULONG                       NullLocation;

    Irp = WorkerContext->Irp;

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    Status = STATUS_SUCCESS;

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength < 
            sizeof( SWENUM_INSTALL_INTERFACE )) {
        Status = STATUS_INVALID_PARAMETER;
    } 
    
    if (NT_SUCCESS( Status )) {
        FdoExtension = *(PFDO_EXTENSION *) irpSp->DeviceObject->DeviceExtension;
        SwEnumInstallInterface = 
            (PSWENUM_INSTALL_INTERFACE) Irp->AssociatedIrp.SystemBuffer;
        
        //
        // Make sure that the string is UNICODE_NULL terminated.  Note that the
        // first two members of this structure are GUIDs and therefore WCHAR 
        // aligned.
        //

        //
        // N.B.  
        //
        // The ReferenceString member of SWENUM_INSTALL_INTERFACE is
        // defined as WCHAR[1].  There is always room for the UNICODE_NULL.
        //
        
        NullLocation = 
            irpSp->Parameters.DeviceIoControl.InputBufferLength >> 1;
        ((PWCHAR) Irp->AssociatedIrp.SystemBuffer)[ NullLocation - 1 ] = 
            UNICODE_NULL;
        
        //
        // Take the list mutex
        //    

        KeEnterCriticalRegion();
        ExAcquireFastMutexUnsafe( &FdoExtension->DeviceListMutex );     

        //
        // Remove the interface
        //
        Status = 
            RemoveInterface(
                SwEnumInstallInterface,
                &FdoExtension->BaseRegistryPath );
        if (NT_SUCCESS( Status )) {
            //
            // If successful, force the re-enumeration of the bus.
            //    
            ScanBus( irpSp->DeviceObject );

            IoInvalidateDeviceRelations(
                FdoExtension->PhysicalDeviceObject,
                BusRelations );
        } 
        ExReleaseFastMutexUnsafe( &FdoExtension->DeviceListMutex );    
        KeLeaveCriticalRegion();
    }
    
    WorkerContext->Status = Status;
    KeSetEvent( &WorkerContext->CompletionEvent, IO_NO_INCREMENT, FALSE );
}    


KSDDKAPI
NTSTATUS
NTAPI
KsRemoveBusEnumInterface(
    IN PIRP Irp
    )
/*++

Routine Description:
    Services an I/O request for the parent device to remove an interface
    on the bus.  The Irp->AssociatedIrp.SystemBuffer is assumed to have a
    SWENUM_INSTALL_INTERFACE structure:

        typedef struct _SWENUM_INSTALL_INTERFACE {
            GUID   DeviceId;
            GUID   InterfaceId;
            WCHAR  ReferenceString[1];
            
        } SWENUM_INSTALL_INTERFACE, *PSWENUM_INSTALL_INTERFACE;


    where the DeviceId, InterfaceId and ReferenceString specify the specific
    device and interface to be removed.

Arguments:
    IN PIRP Irp -
        pointer to I/O request containing SWENUM_INSTALL_INTERFACE structure

Return:
    STATUS_SUCCESS or an appropriate error code

--*/

{
    WORK_QUEUE_ITEM InstallWorker;
    WORKER_CONTEXT  WorkerContext;

    //
    // Do the processing of the uninstallation in a worker item so that
    // registry handles are managed in the context of the system process.
    //

#if !defined( WIN9X_KS )
    if (!SeSinglePrivilegeCheck( 
            RtlConvertLongToLuid( SE_LOAD_DRIVER_PRIVILEGE ), 
            ExGetPreviousMode() )) {
        return STATUS_PRIVILEGE_NOT_HELD;
    }
#endif

    KeInitializeEvent( 
        &WorkerContext.CompletionEvent, NotificationEvent, FALSE );
    WorkerContext.Irp = Irp;
    ExInitializeWorkItem(
        &InstallWorker, KspRemoveBusEnumInterface, &WorkerContext );
    ExQueueWorkItem( &InstallWorker, DelayedWorkQueue );
    KeWaitForSingleObject( 
        &WorkerContext.CompletionEvent, Executive, KernelMode, FALSE, NULL );

    return WorkerContext.Status;
}


NTSTATUS 
RemoveInterface(
    IN PSWENUM_INSTALL_INTERFACE Interface,
    IN PUNICODE_STRING BaseRegistryPath
    )               

/*++

Routine Description:
    Removes the registry key for the interface in the SWENUM\Devices.

    NOTE: 
    
        This function is always called in the context of the system
        process so that registry handles are tucked away safely from
        rogue user-mode applications.

        From user-mode, the IOCTL that initiates an installation, removal, or
        scan always results in a worker in the system process to do the actual
        work.

Arguments:
    IN PSWENUM_INSTALL_INTERFACE Interface -

    IN PUNICODE_STRING BaseRegistryPath -
Return:

--*/

{
    HANDLE                DeviceIdKey, DeviceInterfacesKey,
                          InterfaceKey, ReferenceStringKey;
    NTSTATUS              Status;
    OBJECT_ATTRIBUTES     ObjectAttributes;
    UNICODE_STRING        DeviceIdString, InterfaceIdString,
                          ReferenceString;
    PWCHAR                Ptr;
    KEY_FULL_INFORMATION  FullKeyInformation;
    ULONG                 ReturnedSize;

    _DbgPrintF( DEBUGLVL_BLAB, ("RemoveInterface") );

    //
    // Validate interface reference string
    //

    if (Ptr = Interface->ReferenceString) {
        for (; *Ptr; *Ptr++) {
            if ((*Ptr <= L' ')  || (*Ptr > (WCHAR)0x7F) || (*Ptr == L',') || (*Ptr == L'\\') || (*Ptr == L'/')) {
                return STATUS_INVALID_PARAMETER;
            }
        }
    }

    //
    // Open driver registry path
    //
    
    if (!NT_SUCCESS( Status = 
            OpenDeviceInterfacesKey( 
                &DeviceInterfacesKey,
                BaseRegistryPath ) )) {
        return Status;
    }

    Status = 
        RtlStringFromGUID( 
            &Interface->DeviceId, 
            &DeviceIdString );
        
    if (!NT_SUCCESS( Status )) {
        _DbgPrintF( 
            DEBUGLVL_VERBOSE, 
            ("failed to create device ID string: %08x", Status) );
        ZwClose( DeviceInterfacesKey );
        return Status;
    }

    Status =
        RtlStringFromGUID( 
            &Interface->InterfaceId, 
            &InterfaceIdString );
    
    if (!NT_SUCCESS( Status )) {
        _DbgPrintF( 
            DEBUGLVL_VERBOSE, 
            ("failed to create interface ID string: %08x", Status) );
        RtlFreeUnicodeString( &DeviceIdString );
        ZwClose( DeviceInterfacesKey );
        return Status;
    }

    DeviceIdKey = 
        ReferenceStringKey = 
        InterfaceKey = 
            INVALID_HANDLE_VALUE;

    //
    // Open device ID key
    //

    InitializeObjectAttributes(
        &ObjectAttributes, 
        &DeviceIdString,
        OBJ_CASE_INSENSITIVE,
        DeviceInterfacesKey,
        (PSECURITY_DESCRIPTOR) NULL );

    Status = 
        ZwOpenKey(
            &DeviceIdKey,
            KEY_WRITE,
            &ObjectAttributes );

    if (!NT_SUCCESS( Status )) {
        _DbgPrintF( 
            DEBUGLVL_VERBOSE, 
            ("failed to open device key: %08x", Status) );
    } else {

        //
        // Open reference string key
        //

        RtlInitUnicodeString(
            &ReferenceString,
            Interface->ReferenceString );
        
        InitializeObjectAttributes( 
            &ObjectAttributes, 
            &ReferenceString,
            OBJ_CASE_INSENSITIVE,
            DeviceIdKey,
            (PSECURITY_DESCRIPTOR) NULL );
    
        Status = 
            ZwOpenKey(
                &ReferenceStringKey,
                KEY_WRITE,
                &ObjectAttributes );

        if (!NT_SUCCESS( Status )) {
            _DbgPrintF(
                DEBUGLVL_VERBOSE,
                ("failed to open reference string key: %08x", Status) );
        } else {

            //
            // Open interface ID key
            //

            InitializeObjectAttributes(
                &ObjectAttributes,
                &InterfaceIdString,
                OBJ_CASE_INSENSITIVE,
                ReferenceStringKey,
                (PSECURITY_DESCRIPTOR) NULL );

            Status =
                ZwOpenKey(
                    &InterfaceKey,
                    KEY_WRITE,
                    &ObjectAttributes );

            if (!NT_SUCCESS( Status )) {
                _DbgPrintF(
                    DEBUGLVL_VERBOSE,
                    ("failed to open interface ID key: %08x", Status) );
            } else {

                //
                // Remove the interface from the bus
                //

                ZwDeleteKey( InterfaceKey );
                InterfaceKey = INVALID_HANDLE_VALUE;

            }

            Status =
                ZwQueryKey(
                    ReferenceStringKey,
                    KeyFullInformation,
                    &FullKeyInformation,
                    sizeof ( FullKeyInformation ),
                    &ReturnedSize
                    );

            if (NT_SUCCESS( Status )) {

                if (FullKeyInformation.SubKeys == 0) {
                    ZwDeleteKey( ReferenceStringKey );
                    ReferenceStringKey = INVALID_HANDLE_VALUE;
                }

            }

        }

        Status =
            ZwQueryKey(
                DeviceIdKey,
                KeyFullInformation,
                &FullKeyInformation,
                sizeof ( FullKeyInformation ),
                &ReturnedSize
                );

        if (NT_SUCCESS( Status )) {

            if (FullKeyInformation.SubKeys == 0) {
                ZwDeleteKey( DeviceIdKey );
                DeviceIdKey = INVALID_HANDLE_VALUE;
            }

        }

    }


    if (InterfaceKey != INVALID_HANDLE_VALUE) {
        ZwClose( InterfaceKey );
    }

    if (ReferenceStringKey != INVALID_HANDLE_VALUE) {    
        ZwClose( ReferenceStringKey );
    }
    
    if (DeviceIdKey != INVALID_HANDLE_VALUE) {    
        ZwClose( DeviceIdKey );
    }    
    
    RtlFreeUnicodeString( &DeviceIdString );
    RtlFreeUnicodeString( &InterfaceIdString );

    ZwClose( DeviceInterfacesKey );
    
    _DbgPrintF( DEBUGLVL_VERBOSE, ("RemoveInterface returning %08x", Status) );
    return Status;
}    


#if 0

VOID
LogErrorWithStrings(
    IN PFDO_EXTENSION FdoExtenstion,
    IN ULONG ErrorCode,
    IN ULONG UniqueId,
    IN PUNICODE_STRING String1,
    IN PUNICODE_STRING String2
    )

/*++

Routine Description

    This function logs an error and includes the strings provided.

Arguments:

    IN PFDO_EXTENSION FdoExtension -
        pointer to the FDO extension
        
    IN ULONG ErrorCode - 
        error code
        
    IN ULONG UniqueId - 
        unique Id for this error
        
    IN PUNICODE_STRING String1 - 
        The first string to be inserted.
        
    IN PUNICODE_STRING String2 - 
        The second string to be inserted.

Return Value:

    None.

--*/

{
   ULONG                length;
   PCHAR                dumpData;
   PIO_ERROR_LOG_PACKET IoErrorPacket;

   length = String1->Length + sizeof(IO_ERROR_LOG_PACKET) + 4;

   if (String2) {
      length += String2->Length;
   }

   if (length > ERROR_LOG_MAXIMUM_SIZE) {

      //
      // Don't have code to truncate strings so don't log this.
      //

      return;
   }

   IoErrorPacket = (PIO_ERROR_LOG_PACKET) IoAllocateErrorLogEntry(DeviceExtension->DeviceObject,
                                                           (UCHAR) length);
   if (IoErrorPacket) {
      IoErrorPacket->ErrorCode = ErrorCode;
      IoErrorPacket->SequenceNumber = DeviceExtension->SequenceNumber++;
      IoErrorPacket->MajorFunctionCode = 0;
      IoErrorPacket->RetryCount = (UCHAR) 0;
      IoErrorPacket->UniqueErrorValue = UniqueId;
      IoErrorPacket->FinalStatus = STATUS_SUCCESS;
      IoErrorPacket->NumberOfStrings = 1;
      IoErrorPacket->StringOffset = (USHORT) ((PUCHAR)&IoErrorPacket->DumpData[0] - (PUCHAR)IoErrorPacket);
      IoErrorPacket->DumpDataSize = (USHORT) (length - sizeof(IO_ERROR_LOG_PACKET));
      IoErrorPacket->DumpDataSize /= sizeof(ULONG);
      dumpData = (PUCHAR) &IoErrorPacket->DumpData[0];

      RtlCopyMemory(dumpData, String1->Buffer, String1->Length);

      dumpData += String1->Length;
      if (String2) {
         *dumpData++ = '\\';
         *dumpData++ = '\0';

         RtlCopyMemory(dumpData, String2->Buffer, String2->Length);
         dumpData += String2->Length;
      }
      *dumpData++ = '\0';
      *dumpData++ = '\0';

      IoWriteErrorLogEntry(IoErrorPacket);
   }

   return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\ks\connect.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    connect.c

Abstract:

    This module contains the helper functions for pins.

--*/

#include "ksp.h"

#ifdef ALLOC_PRAGMA
BOOL
ValidAttributeList(
    IN PKSMULTIPLE_ITEM AttributeList,
    IN ULONG ValidFlags,
    IN BOOL RequiredAttribute
    );
BOOL
AttributeIntersection(
    IN PKSATTRIBUTE_LIST AttributeList OPTIONAL,
    IN BOOL RequiredRangeAttribute,
    IN PKSMULTIPLE_ITEM CallerAttributeList OPTIONAL,
    OUT ULONG* AttributesFound OPTIONAL
    );
NTSTATUS
CompatibleIntersectHandler(
    IN PVOID Context,
    IN PIRP Irp,
    IN PKSP_PIN Pin,
    IN PKSDATARANGE DataRange,
    IN PKSDATARANGE MatchingDataRange,
    IN ULONG DataBufferSize,
    OUT PVOID Data OPTIONAL,
    OUT PULONG DataSize
    );
#pragma alloc_text(PAGE, ValidAttributeList)
#pragma alloc_text(PAGE, AttributeIntersection)
#pragma alloc_text(PAGE, KsCreatePin)
#pragma alloc_text(PAGE, KspValidateConnectRequest)
#pragma alloc_text(PAGE, KspValidateDataFormat)
#pragma alloc_text(PAGE, KsValidateConnectRequest)
#pragma alloc_text(PAGE, KsHandleSizedListQuery)
#pragma alloc_text(PAGE, KspPinPropertyHandler)
#pragma alloc_text(PAGE, KsPinPropertyHandler)
#pragma alloc_text(PAGE, KsPinDataIntersectionEx)
#pragma alloc_text(PAGE, CompatibleIntersectHandler)
#pragma alloc_text(PAGE, KsPinDataIntersection)
#endif // ALLOC_PRAGMA

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA
static const WCHAR PinString[] = KSSTRING_Pin;
DEFINE_KSPIN_INTERFACE_TABLE(StandardPinInterfaces) {
    {
        STATICGUIDOF(KSINTERFACESETID_Standard),
        KSINTERFACE_STANDARD_STREAMING,
        0
    }
};

DEFINE_KSPIN_MEDIUM_TABLE(StandardPinMediums) {
    {
        STATICGUIDOF(KSMEDIUMSETID_Standard),
        KSMEDIUM_TYPE_ANYINSTANCE,
        0
    }
};
#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif // ALLOC_DATA_PRAGMA

//
// This flag is used to temporarily mark an incoming attribute as being
// found. It is always cleared after enumerating attributes, and is not
// referenced outside of this module.
//
#define KSATTRIBUTE_FOUND 0x80000000


BOOL
ValidAttributeList(
    IN PKSMULTIPLE_ITEM AttributeList,
    IN ULONG ValidFlags,
    IN BOOL RequiredAttribute
    )
/*++

Routine Description:

    Validates the given list of attributes, or attribute ranges. Checks
    that the header contains the correct count of items when compared to
    the size in the header. Also checks each attribute for valid flags
    and size. Ensures that if a required attribute should be present, that
    there is indeed a required attribute present.

Arguments:

    AttributeList -
        Contains a captured buffer with the attribute list to probe. The
        format of the list is a KSMULTIPLE_ITEM, followed by a list of
        aligned KSATTRIBUTE structures, each with trailing data. The
        specified size of the leading KSMULTIPLE_ITEM has been validated
        against the size of the entire buffer, and is at least great
        enough to contain the header.

    ValidFlags -
        Contains the flags which are valid for this list. This changes
        based on whether the attribute list is actually an attribute range
        list, or a set of attributes for a Create request. Only ranges
        may have flags at this time, so KSATTRIBUTE_REQUIRED could be set.

    RequiredAttribute -
        Indicates whether or not the attribute list should contain an
        attribute with the KSATTRIBUTE_REQUIRED flag set. This can only
        be TRUE when the list is actually a list of attribute ranges.

Return Value:

    Returns TRUE if the list is valid, else FALSE if any error is found.

--*/
{
    PKSATTRIBUTE Attribute;
    KSMULTIPLE_ITEM MultipleItem;
    ULONG AttributeSize;
    BOOL FoundRequiredAttribute;

    //
    // Create a local copy of the header which will be modified as the
    // list is enumerated. Since the size is inclusive, remove the header
    // size, and obtain a pointer to the first item. The header itself is
    // an aligned object, so the first element will be aligned already.
    //
    MultipleItem = *AttributeList;
    MultipleItem.Size -= sizeof(MultipleItem);
    Attribute = (PKSATTRIBUTE)(AttributeList + 1);
    FoundRequiredAttribute = FALSE;
    //
    // Enumerate the given list of attributes, presumably until the count
    // in the header runs out. However, an error will prematurely return
    // from the function. At termination it is determined if all the
    // attributes were found that needed to be found, and if there is
    // an invalid (too long) size parameter.
    //
    for (; MultipleItem.Count; MultipleItem.Count--) {
        if ((MultipleItem.Size < sizeof(*Attribute)) ||
            (Attribute->Size < sizeof(*Attribute)) ||
            (Attribute->Size > MultipleItem.Size) ||
            (Attribute->Flags & ~ValidFlags)) {
            return FALSE;
        }
        //
        // If this flag is set on the attribute, determine if either a required
        // attribute is needed, or is not allowed. If the list passed is actually
        // from a Create request, then this flag will never be set, and the
        // check above for ValidFlags will catch it before getting this far.
        //
        if (Attribute->Flags & KSATTRIBUTE_REQUIRED) {
            if (RequiredAttribute) {
                FoundRequiredAttribute = TRUE;
            } else {
                return FALSE;
            }
        }
        AttributeSize = Attribute->Size;
        //
        // Align the next increase on a LONGLONG boundary only if more attributes
        // are to follow. The length in the header is supposed to reflect the
        // exact length, so no alignment should be done on the last item.
        //
        if (MultipleItem.Count > 1) {
            AttributeSize = (AttributeSize + FILE_QUAD_ALIGNMENT) & ~FILE_QUAD_ALIGNMENT;
            //
            // Perform extra size check on aligned size.
            //
            if (AttributeSize > MultipleItem.Size) {
                return FALSE;
            }
        }
        MultipleItem.Size -= AttributeSize;
        (PUCHAR)Attribute += AttributeSize;
    }
    //
    // If one of the attributes did not contain the required bit, yet the
    // data range indicated that there was a required attribute in the
    // list, then the validation fails.
    //
    if (RequiredAttribute && !FoundRequiredAttribute) {
        return FALSE;
    }
    //
    // There should be no size left over.
    //
    return !MultipleItem.Size;
}


BOOL
AttributeIntersection(
    IN PKSATTRIBUTE_LIST RangeAttributeList OPTIONAL,
    IN BOOL RequiredRangeAttribute,
    IN PKSMULTIPLE_ITEM CallerAttributeList OPTIONAL,
    OUT ULONG* AttributesFound OPTIONAL
    )
/*++

Routine Description:

    Determines if the attribute range list produces a valid intersection
    with the caller attribute list (which may be a range, but it does
    not matter). Either or both of these lists may not be present. The
    function ensures that all required attributes in either list are
    present in the opposite list. In the case wherein the caller list
    is not a list of attribute ranges, no required bits will be set, but
    based on the absence of the AttributesFound pointer, all of the
    items in the list must be present for the function to succeed. The
    function also fails if the caller list has duplicates, because a
    second instance of the same attribute will not be marked as found.


Arguments:

    RangeAttributeList -
        Optionally contains a list of attribute ranges which is used
        to locate attributes in the caller list. If an attribute is
        marked as required, it must appear in the caller list for the
        function to succeed.

    RequiredRangeAttribute -
        This is set if the attribute ranges has a required attribute
        in it. If not set, and there is no caller attribute list, then
        the function can return quickly with success.

    CallerAttributeList -
        Optionally contains a list of attributes or attribute ranges.
        If an AttributesFound pointer is passed, not all the attributes
        need to be found in this list, unless the required bit is set
        for a particular attribute. Otherwise, all attributes must be
        found in this list in order to succeed.

    AttributesFound -
        Optionally contains a place in which to return the number of
        attributes in the caller list found. If this is not present,
        all attributes in the caller list must be found in order for
        this function to succeed, else only required attributes need
        to be found in both lists.

Return Value:

    Returns TRUE if there is a valid intersection, else FALSE.

--*/
{
    PKSATTRIBUTE* RangeAttributes;
    PKSATTRIBUTE Attribute;
    ULONG RangeAttributeCount;
    ULONG AttributeCount;
    ULONG LocalAttributesFound;
    BOOL AllRequiredAttributesFound;

    //
    // If there is no caller attribute list, determine if there is a
    // quick way out of the intersection. This is true if no attribute
    // in the range is required.
    //
    if (!CallerAttributeList && !RequiredRangeAttribute) {
        if (AttributesFound) {
            *AttributesFound = 0;
        }
        return TRUE;
    }
    //
    // Enumerate each attribute range in this data range, and look
    // for its presence in the list of attributes passed with the
    // parameters. When all the attribute ranges have been enumerated,
    // all of the attributes in the list should have been found. If
    // there are duplicate attributes in the list, then the second
    // copy will not have been marked as found.
    //
    if (RangeAttributeList) {
        RangeAttributes = RangeAttributeList->Attributes;
        RangeAttributeCount = RangeAttributeList->Count;
    } else {
        RangeAttributeCount = 0;
    }
    for (; RangeAttributeCount; RangeAttributeCount--, RangeAttributes++) {
        //
        // Enumerate each caller attribute attempting to locate the
        // attribute range given. If the attribute is found, then mark
        // the attribute in the list, and continue on to the next range.
        //
        AttributeCount = CallerAttributeList ? CallerAttributeList->Count : 0;
        for (Attribute = (PKSATTRIBUTE)(CallerAttributeList + 1); AttributeCount; AttributeCount--) {
            if (IsEqualGUIDAligned(&RangeAttributes[0]->Attribute, &Attribute->Attribute)) {
                ASSERT(!(Attribute->Flags & KSATTRIBUTE_FOUND) && "AttributeIntersection: Driver has duplicate attribute ranges.");
                //
                // Mark this attribute as being found. These will
                // be reset at the end when determining what items
                // were found.
                // 
                Attribute->Flags |= KSATTRIBUTE_FOUND;
                break;
            }
            Attribute = (PKSATTRIBUTE)(((UINT_PTR)Attribute + Attribute->Size + FILE_QUAD_ALIGNMENT) & ~FILE_QUAD_ALIGNMENT);
        }
        //
        // If the attribute range was not found in the caller list
        // presented, and it is required, then the intersection is invalid.
        //
        if (!AttributeCount && (RangeAttributes[0]->Flags & KSATTRIBUTE_REQUIRED)) {
            ASSERT(RequiredRangeAttribute && "AttributeIntersection: Driver did not set the KSDATARANGE_REQUIRED_ATTRIBUTES bit in a range with required attributes.");
            break;
        }
    }
    //
    // Enumerate all the attributes, ensuring that each was marked as
    // found in the attribute ranges, and resettting the found flag
    // for subsequent calls. This will also locate duplicate caller
    // attributes passed in, since only the first one will have been marked.
    //
    LocalAttributesFound = 0;
    AllRequiredAttributesFound = TRUE;
    AttributeCount = CallerAttributeList ? CallerAttributeList->Count : 0;
    for (Attribute = (PKSATTRIBUTE)(CallerAttributeList + 1); AttributeCount; AttributeCount--) {
        //
        // The attribute was found, so reset the flag and count it.
        // Continue the loop so that all flags are reset.
        //
        if (Attribute->Flags & KSATTRIBUTE_FOUND) {
            Attribute->Flags &= ~KSATTRIBUTE_FOUND;
            LocalAttributesFound++;
        } else if (Attribute->Flags & KSATTRIBUTE_REQUIRED) {
            //
            // The caller's attribute is required, but was not found.
            // This means the function must fail. This will only be set
            // when the caller's list is a range list, but just check
            // in all cases anyway.
            //
            AllRequiredAttributesFound = FALSE;
        }
    }
    //
    // If not all the attributes need to be found, then return the
    // number that were actually found, whether or not all the
    // caller's required attributes were found, and whether or not
    // all the required attributes in the range list were fulfilled.
    //
    if (AttributesFound) {
        *AttributesFound = LocalAttributesFound;
    } else if (CallerAttributeList && (LocalAttributesFound < CallerAttributeList->Count)) {
        AllRequiredAttributesFound = FALSE;
    }
    return !RangeAttributeCount && AllRequiredAttributesFound;
}


KSDDKAPI
NTSTATUS
NTAPI
KsCreatePin(
    IN HANDLE FilterHandle,
    IN PKSPIN_CONNECT Connect,
    IN ACCESS_MASK DesiredAccess,
    OUT PHANDLE ConnectionHandle
    )
/*++

Routine Description:

    Creates a handle to a pin instance.

Arguments:

    FilterHandle -
        Contains the handle to the filter on which to create the pin.

    Connect -
        Contains the connection request information.

    DesiredAccess -
        Specifies the desired access to the object. This is normally GENERIC_READ
        and/or GENERIC_WRITE. For data flow into the pin this should be Write
        access, and for data flow out of the pin this should be Read access. This
        is irregardless of the communications method.

    ConnectionHandle -
        Place in which to put the pin handle.

Return Value:

    Returns any CreateFile error.

--*/
{
    ULONG ConnectSize;
    PKSDATAFORMAT DataFormat;

    PAGED_CODE();

    DataFormat = (PKSDATAFORMAT)(Connect + 1);
    ConnectSize = DataFormat->FormatSize;
    if (DataFormat->Flags & KSDATAFORMAT_ATTRIBUTES) {
        ConnectSize = (ConnectSize + FILE_QUAD_ALIGNMENT) & ~FILE_QUAD_ALIGNMENT;
        ConnectSize += ((PKSMULTIPLE_ITEM)((PUCHAR)DataFormat + ConnectSize))->Size;
    }
    ConnectSize += sizeof(*Connect);
    return KsiCreateObjectType(
        FilterHandle,
        (PWCHAR)PinString,
        Connect,
        ConnectSize,
        DesiredAccess,
        ConnectionHandle);
}


KSDDKAPI
NTSTATUS
NTAPI
KspValidateConnectRequest(
    IN PIRP Irp,
    IN ULONG DescriptorsCount,
    IN const KSPIN_DESCRIPTOR* Descriptor,
    IN ULONG DescriptorSize,
    OUT PKSPIN_CONNECT* Connect,
    OUT PULONG ConnectSize
    )
/*++

Routine Description:

    Validates the connection request and returns the connection structure
    associated with the request.

Arguments:

    Irp -
        Contains the IRP with the connection request being handled.

    DescriptorsCount -
        Indicates the number of descriptor structures being passed.

    Descriptor -
        Contains the pointer to the list of pin information structures.

    DescriptorSize -
        Contains the size in bytes of the descriptor structure.

    Connect -
        Place in which to put the connection structure pointer passed to the
        create request.

    ConnectSize -
        Place in which to put the size of the connection structure captured.
        This includes any data format attributes.

Return Value:

    Returns STATUS_SUCCESS, else an error.

--*/
{
    NTSTATUS Status;
    PKSPIN_CONNECT LocalConnect;
    ULONG IdentifierCount;
    const KSIDENTIFIER* Identifier;
    KSPIN_COMMUNICATION Communication;

    PAGED_CODE();

    //
    // Ensure that the create parameter passed is minimally large
    // enough, containing at least enough size for a connection
    // structure and a data format.
    //
    *ConnectSize = sizeof(**Connect) + sizeof(KSDATAFORMAT);
    Status = KsiCopyCreateParameter(
        Irp,
        ConnectSize,
        Connect);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    //
    // Ensure that the connection point actually exists.
    //
    if ((*Connect)->PinId >= DescriptorsCount) {
        return STATUS_INVALID_PARAMETER_3;
    }
    Descriptor = (const KSPIN_DESCRIPTOR *)(((PUCHAR)Descriptor) + 
        DescriptorSize * (*Connect)->PinId);
    //
    // Ensure that the type of connection requested fits the type of communication
    // which the pin supports. If there is a PinToHandle, then the pin being
    // connected to must be a source. Else it must either be a sink, or a bridge.
    //
    if ((*Connect)->PinToHandle) {
        Communication = KSPIN_COMMUNICATION_SOURCE;
    } else {
        Communication = KSPIN_COMMUNICATION_SINK | KSPIN_COMMUNICATION_BRIDGE;
    }
    //
    // Ensure the type expected is a subset of the type supported. This assumes
    // that the Communication enum is really a set of bit flags.
    //
    if (!(Communication & Descriptor->Communication)) {
        return STATUS_INVALID_PARAMETER_4;
    }
    //
    // Flags are not used on an Interface identifier.
    // Zero is a reserved value for Priority.
    //
    if ((*Connect)->Interface.Flags) {
        return STATUS_INVALID_PARAMETER_1;
    }
    if (!(*Connect)->Priority.PriorityClass ||
        !(*Connect)->Priority.PrioritySubClass) {
        return STATUS_INVALID_PARAMETER_5;
    }
    //
    // Search the list of Interfaces available on this pin in order to find
    // the type requested.
    //
    if (Descriptor->InterfacesCount) {
        IdentifierCount = Descriptor->InterfacesCount;
        Identifier = Descriptor->Interfaces;
    } else {
        IdentifierCount = SIZEOF_ARRAY(StandardPinInterfaces);
        Identifier = StandardPinInterfaces;
    }
    for (;; IdentifierCount--, Identifier++) {
        if (!IdentifierCount) {
            //
            // If there are no more interfaces in the list, then a match
            // was not found.
            //
            return STATUS_NO_MATCH;
        } else if (IsEqualGUIDAligned(&Identifier->Set, &(*Connect)->Interface.Set) && (Identifier->Id == (*Connect)->Interface.Id)) {
            break;
        }
    }
    //
    // Flags are not used on a Medium identifier.
    //
    if ((*Connect)->Medium.Flags) {
        return STATUS_INVALID_PARAMETER_2;
    }
    //
    // Search the list of Mediums available on this pin in order to find
    // the type requested.
    //
    if (Descriptor->MediumsCount) {
        IdentifierCount = Descriptor->MediumsCount;
        Identifier = Descriptor->Mediums;
    } else {
        IdentifierCount = SIZEOF_ARRAY(StandardPinMediums);
        Identifier = StandardPinMediums;
    }
    for (;; IdentifierCount--, Identifier++) { 
        if (!IdentifierCount) {
            //
            // If there are no more mediums in the list, then a match
            // was not found.
            //
            return STATUS_NO_MATCH;
        } else if (IsEqualGUIDAligned(&Identifier->Set, &(*Connect)->Medium.Set) && (Identifier->Id == (*Connect)->Medium.Id)) {
            break;
        }
    }

    return STATUS_SUCCESS;
}


KSDDKAPI
NTSTATUS
NTAPI
KspValidateDataFormat(
    IN const KSPIN_DESCRIPTOR* Descriptor,
    IN PKSDATAFORMAT DataFormat,
    IN ULONG RequestSize,
    IN PFNVALIDATEDATAFORMAT ValidateCallback OPTIONAL,
    IN PVOID Context OPTIONAL
    )
/*++

Routine Description:

    Validates the data format, optionally calling the format handler.

Arguments:

    Descriptor -
        Contains the pointer to the specific pin information structure.

    DataFormat -
        The data format to validate.

    RequestSize -
        The size of the data format, including any attributes.

    ValidateCallback -
        Optionally contains a callback used to validate a data format
        against a data range on the pin. If not present, the first
        matching range is used.

    Context -
        Optionally contains context passed to the validation callback.

Return Value:

    Returns STATUS_SUCCESS, else an error.

--*/
{
    PKSMULTIPLE_ITEM AttributeList;
    ULONG IdentifierCount;
    const PKSDATARANGE* DataRanges;
    NTSTATUS Status;

    //
    // Validate the basic data format structure for size, Major Format, Sub
    // Format, and Specifier. The rest must be validated by the specific
    // format function for this pin.
    //
    if ((RequestSize < sizeof(*DataFormat)) || (DataFormat->FormatSize < sizeof(*DataFormat))) {
        return STATUS_INVALID_BUFFER_SIZE;
    }
    if (DataFormat->Reserved) {
        return STATUS_INVALID_PARAMETER_6;
    }    
    //
    // Passing in a wildcard in the data format is invalid. Additionally, if
    // the specifier is None, then there can be no associated specifier data.
    //
    if (IsEqualGUIDAligned(&DataFormat->MajorFormat, &KSDATAFORMAT_TYPE_WILDCARD) ||
        IsEqualGUIDAligned(&DataFormat->SubFormat, &KSDATAFORMAT_SUBTYPE_WILDCARD) ||
        IsEqualGUIDAligned(&DataFormat->Specifier, &KSDATAFORMAT_SPECIFIER_WILDCARD) ||
        ((DataFormat->FormatSize != sizeof(*DataFormat)) &&
        IsEqualGUIDAligned(&DataFormat->Specifier, &KSDATAFORMAT_SPECIFIER_NONE))) {
        return STATUS_INVALID_PARAMETER_6;
    }
    //
    // If there are attributes, validate that the list is formed correctly.
    //
    if (DataFormat->Flags & KSDATAFORMAT_ATTRIBUTES) {
        ULONG AlignedFormatSize;

        AlignedFormatSize = (DataFormat->FormatSize + FILE_QUAD_ALIGNMENT) & ~FILE_QUAD_ALIGNMENT;
        //
        // Place this extra check here in case of roll over.
        //
        if (DataFormat->FormatSize < AlignedFormatSize + sizeof(*AttributeList)) {
            return STATUS_INVALID_BUFFER_SIZE;
        }
        //
        // Ensure that the size passed in is at least large enough to cover the
        // size of the multiple-item structure.
        //
        if (RequestSize < AlignedFormatSize + sizeof(*AttributeList)) {
            return STATUS_INVALID_PARAMETER;
        }
        AttributeList = (PKSMULTIPLE_ITEM)((PUCHAR)DataFormat + AlignedFormatSize);
        //
        // Ensure the attribute list size is the same size as the remaining
        // buffer passed in.
        //
        if (AttributeList->Size != RequestSize - AlignedFormatSize) {
            return STATUS_INVALID_PARAMETER;
        }
        if (!ValidAttributeList(AttributeList, 0, FALSE)) {
            return STATUS_INVALID_PARAMETER;
        }
    } else {
        //
        // This pointer is used to determine if an attribute list is present, and
        // to access that list when validating it against a data range.
        //
        AttributeList = NULL;
    }
    //
    // Search the list of Data Ranges available on this pin in order to find
    // the type requested.
    //
    if (Descriptor->ConstrainedDataRangesCount) {
        IdentifierCount = Descriptor->ConstrainedDataRangesCount;
        DataRanges = Descriptor->ConstrainedDataRanges;
    } else {
        IdentifierCount = Descriptor->DataRangesCount;
        DataRanges = Descriptor->DataRanges;
    }
    //
    // If no ranges get into the inner portion of the enumeration, then
    // the status return will not get set, so initialize it here for
    // no match.
    //
    Status = STATUS_NO_MATCH;
    for (; IdentifierCount; IdentifierCount--, DataRanges++) {
        //
        // A data format match is found if an element of the DataRanges is a
        // wildcard, or if it matches one of the DataRanges.
        //
        if ((IsEqualGUIDAligned(&DataRanges[0]->MajorFormat, &KSDATAFORMAT_TYPE_WILDCARD) ||
            IsEqualGUIDAligned(&DataRanges[0]->MajorFormat, &DataFormat->MajorFormat)) &&
            (IsEqualGUIDAligned(&DataRanges[0]->SubFormat, &KSDATAFORMAT_SUBTYPE_WILDCARD) ||
            IsEqualGUIDAligned(&DataRanges[0]->SubFormat, &DataFormat->SubFormat)) &&
            (IsEqualGUIDAligned(&DataRanges[0]->Specifier, &DataFormat->Specifier) ||
            IsEqualGUIDAligned(&DataRanges[0]->Specifier, &KSDATAFORMAT_SPECIFIER_WILDCARD))) {
            PKSATTRIBUTE_LIST RangeAttributeList;
            ULONG RequiredRangeAttribute;

            //
            // If there is an attribute list associated with this connection,
            // then ensure that all these attributes are present.
            //
            if (DataRanges[0]->Flags & KSDATARANGE_ATTRIBUTES) {
                RequiredRangeAttribute = DataRanges[0]->Flags & KSDATARANGE_REQUIRED_ATTRIBUTES;
                RangeAttributeList = (PKSATTRIBUTE_LIST)DataRanges[1];
            } else {
                RequiredRangeAttribute = FALSE;
                RangeAttributeList = NULL;
            }
            if (AttributeIntersection(RangeAttributeList, RequiredRangeAttribute, AttributeList, NULL)) {
                //
                // If there is a validation callback, then use it on this
                // data range before deciding to return success.
                //
                if (ValidateCallback) {
                    Status = ValidateCallback(
                        Context,
                        DataFormat,
                        AttributeList,
                        DataRanges[0],
                        RangeAttributeList);
                    //
                    // If the validation succeeded, or there was some unexpected
                    // error, leave the enumeration loop with the status return.
                    //
                    if (Status != STATUS_NO_MATCH) {
                        break;
                    }
                } else {
                    //
                    // No other validation is necessary, as there is no callback,
                    // so return success.
                    //
                    Status = STATUS_SUCCESS;
                    break;
                }
            }
        }
        if (DataRanges[0]->Flags & KSDATARANGE_ATTRIBUTES) {
            //
            // If this data range has an associated attribute list, then
            // skip past it.
            //
            DataRanges++;
            IdentifierCount--;
        }
    }
    return Status;
}


KSDDKAPI
NTSTATUS
NTAPI
KsValidateConnectRequest(
    IN PIRP Irp,
    IN ULONG DescriptorsCount,
    IN const KSPIN_DESCRIPTOR* Descriptor,
    OUT PKSPIN_CONNECT* Connect
    )
/*++

Routine Description:

    Validates the connection request and returns the connection structure
    associated with the request.

Arguments:

    Irp -
        Contains the IRP with the connection request being handled.

    DescriptorsCount -
        Indicates the number of descriptor structures being passed.

    Descriptor -
        Contains the pointer to the list of pin information structures.

    Connect -
        Place in which to put the connection structure pointer passed to the
        create request.

Return Value:

    Returns STATUS_SUCCESS, else an error.

--*/
{
    NTSTATUS Status;
    ULONG RequestSize;

    PAGED_CODE();
    Status = KspValidateConnectRequest(
        Irp,
        DescriptorsCount,
        Descriptor,
        sizeof(*Descriptor),
        Connect,
        &RequestSize);
    if (NT_SUCCESS(Status)) {
        Status = KspValidateDataFormat(
            (const KSPIN_DESCRIPTOR *)(((PUCHAR)Descriptor) + sizeof(*Descriptor) * (*Connect)->PinId),
            (PKSDATAFORMAT)(*Connect + 1),
            RequestSize - sizeof(KSPIN_CONNECT),
            NULL,
            NULL);
    }
    return Status;
}


KSDDKAPI
NTSTATUS
NTAPI
KsHandleSizedListQuery(
    IN PIRP Irp,
    IN ULONG DataItemsCount,
    IN ULONG DataItemSize,
    IN const VOID* DataItems
    )
/*++

Routine Description:

    Depending on the length of the system buffer, either returns the size of
    the buffer needed, size and number of entries in the specified data list,
    or additionally copies the entries themselves.

Arguments:

    Irp -
        The IRP containing the identifier list request.

    DataItemsCount -
        The number of items in the identifier list.

    DataItemSize -
        The size of a data item.

    DataItems -
        The list of data items.

Return Value:

    Returns STATUS_SUCCESS if the number of entries and possibly the data could
    be copied, else STATUS_BUFFER_TOO_SMALL if not enough space for all the
    entries was available, yet the buffer was larger than the size to store
    just the size and the count of entries.

--*/
{
    ULONG OutputBufferLength;
    PKSMULTIPLE_ITEM MultipleItem;
    ULONG Length;

    PAGED_CODE();
    OutputBufferLength = IoGetCurrentIrpStackLocation(Irp)->Parameters.DeviceIoControl.OutputBufferLength;
    Length = DataItemsCount * DataItemSize;
    if (!OutputBufferLength) {
        //
        // Only the size was requested. Return a warning with the size.
        //
        Irp->IoStatus.Information = sizeof(*MultipleItem) + Length;
        return STATUS_BUFFER_OVERFLOW;
#ifdef SIZE_COMPATIBILITY
    } else if (OutputBufferLength == sizeof(OutputBufferLength)) {
        *(PULONG)Irp->AssociatedIrp.SystemBuffer = sizeof(*MultipleItem) + Length;
        Irp->IoStatus.Information = sizeof(OutputBufferLength);
        return STATUS_SUCCESS;
#endif // SIZE_COMPATIBILITY
    } else if (OutputBufferLength >= sizeof(*MultipleItem)) {
        MultipleItem = (PKSMULTIPLE_ITEM)Irp->AssociatedIrp.SystemBuffer;
        //
        // Always return the byte count and count of items.
        //
        MultipleItem->Size = sizeof(*MultipleItem) + Length;
        MultipleItem->Count = DataItemsCount;
        //
        // Additionally see if there is room for the rest of the information.
        //
        if (OutputBufferLength >= MultipleItem->Size) {
            //
            // Long enough for the size/count and the list of items.
            //
            if (DataItemsCount) {
                RtlCopyMemory(MultipleItem + 1, DataItems, Length);
            }
            Irp->IoStatus.Information = sizeof(*MultipleItem) + Length;
            return STATUS_SUCCESS;
        } else if (OutputBufferLength == sizeof(*MultipleItem)) {
            //
            // It is valid just to request the size/count.
            //
            Irp->IoStatus.Information = sizeof(*MultipleItem);
            return STATUS_SUCCESS;
        }
    }
    //
    // Too small of a buffer was passed.
    //
    return STATUS_BUFFER_TOO_SMALL;
}


NTSTATUS
KspPinPropertyHandler(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    IN OUT PVOID Data,
    IN ULONG DescriptorsCount,
    IN const KSPIN_DESCRIPTOR* Descriptor,
    IN ULONG DescriptorSize
    )
/*++

Routine Description:

    Performs standard handling of the static members of the
    KSPROPSETID_Pin property set. This does not include
    KSPROPERTY_PIN_CINSTANCES or KSPROPERTY_PIN_DATAINTERSECTION.

Arguments:

    Irp -
        Contains the IRP with the property request being handled.

    Property -
        Contains the specific property being queried.

    Data -
        Contains the pin property specific data.

    DescriptorsCount -
        Indicates the number of descriptor structures being passed.

    Descriptor -
        Contains the pointer to the list of pin information structures.

    DescriptorSize -
        Size of the descriptor structures in bytes.

Return Value:

    Returns STATUS_SUCCESS, else an error specific to the property being
    handled. Always fills in the IO_STATUS_BLOCK.Information field of the
    PIRP.IoStatus element within the IRP. It does not set the
    IO_STATUS_BLOCK.Status field, nor complete the IRP however.

--*/
{
    PAGED_CODE();
    //
    // All properties in this set use a KSP_PIN structure for the property
    // to specify the pin identifier, except for KSPROPERTY_PIN_CTYPES,
    // which refers to the filter as a whole, not a particular pin.
    //
    if (Property->Id != KSPROPERTY_PIN_CTYPES) {
        PKSP_PIN Pin;

        Pin = (PKSP_PIN)Property;
        //
        // Ensure that the identifier is within the range of pins.
        //
        if ((Pin->PinId >= DescriptorsCount) || Pin->Reserved) {
            return STATUS_INVALID_PARAMETER;
        }
        Descriptor = (const KSPIN_DESCRIPTOR *)(((PUCHAR)Descriptor) + 
            DescriptorSize * Pin->PinId);
    }

    switch (Property->Id) {

    case KSPROPERTY_PIN_CTYPES:

        //
        // Return a total count of pin types.
        //
        *(PULONG)Data = DescriptorsCount;
        //Irp->IoStatus.Information = sizeof(DescriptorsCount);
        break;

    case KSPROPERTY_PIN_DATAFLOW:

        //
        // Return the Data Flow for this pin.
        //
        *(PKSPIN_DATAFLOW)Data = Descriptor->DataFlow;
        //Irp->IoStatus.Information = sizeof(Descriptor->DataFlow);
        break;

    case KSPROPERTY_PIN_DATARANGES:
    case KSPROPERTY_PIN_CONSTRAINEDDATARANGES:
    {
        const PKSDATARANGE* SourceRanges;
        ULONG SourceCount;
        ULONG OutputBufferLength;
        const PKSDATARANGE* DataRanges;
        ULONG DataRangesCount;
        ULONG DataRangesSize;
        PKSMULTIPLE_ITEM MultipleItem;

        //
        // The range set returned is based on whether this is a
        // static range request, or the current constrained set.
        // The constrained set need not currently be present,
        // in which case the static range set is returned.
        //
        if ((Property->Id == KSPROPERTY_PIN_DATARANGES) || !Descriptor->ConstrainedDataRangesCount) {
            SourceRanges = Descriptor->DataRanges;
            SourceCount = Descriptor->DataRangesCount;
        } else {
            SourceRanges = Descriptor->ConstrainedDataRanges;
            SourceCount = Descriptor->ConstrainedDataRangesCount;
        }
        //
        // Return the size needed to contain the list of data ranges.
        // If there is enough room, also return all the data ranges in
        // a serialized format. Each data range begins on a
        // FILE_QUAD_ALIGNMENT boundary. This assumes that the initial
        // buffer is aligned as such.
        //
        OutputBufferLength = IoGetCurrentIrpStackLocation(Irp)->Parameters.DeviceIoControl.OutputBufferLength;
        DataRanges = SourceRanges;
        DataRangesSize = sizeof(*MultipleItem);
        //
        // First count the total size needed, including the header.
        //
        for (DataRangesCount = SourceCount; DataRangesCount; DataRangesCount--, DataRanges++) {
            DataRangesSize += DataRanges[0]->FormatSize;
            //
            // If this data range has associated attributes, advance the pointer
            // and count each of them.
            //
            if (DataRanges[0]->Flags & KSDATARANGE_ATTRIBUTES) {
                PKSATTRIBUTE_LIST AttributeList;
                PKSATTRIBUTE* Attributes;
                ULONG Count;

                //
                // Align the previous entry, since data is now being appended.
                //
                DataRangesSize = (DataRangesSize + FILE_QUAD_ALIGNMENT) & ~FILE_QUAD_ALIGNMENT;
                DataRangesCount--;
                DataRanges++;
                DataRangesSize += sizeof(KSMULTIPLE_ITEM);
                AttributeList = (PKSATTRIBUTE_LIST)DataRanges[0];
                for (Count = AttributeList->Count, Attributes = AttributeList->Attributes; Count; Count--, Attributes++) {
                    DataRangesSize += Attributes[0]->Size;
                    if (Count > 1) {
                        DataRangesSize = (DataRangesSize + FILE_QUAD_ALIGNMENT) & ~FILE_QUAD_ALIGNMENT;
                    }
                }
            }
            //
            // Align this entry, since another range will be appended. This
            // could also be aligning the last attribute.
            //
            if (DataRangesCount > 1) {
                DataRangesSize = (DataRangesSize + FILE_QUAD_ALIGNMENT) & ~FILE_QUAD_ALIGNMENT;
            }
        }

        if (!OutputBufferLength) {
            //
            // Only the size was requested. Return a warning with the size.
            //
            Irp->IoStatus.Information = DataRangesSize;
            return STATUS_BUFFER_OVERFLOW;
#ifdef SIZE_COMPATIBILITY
        } else if (OutputBufferLength == sizeof(OutputBufferLength)) {
            *(PULONG)Data = DataRangesSize;
            Irp->IoStatus.Information = sizeof(OutputBufferLength);
            return STATUS_SUCCESS;
#endif // SIZE_COMPATIBILITY
        } else if (OutputBufferLength >= sizeof(*MultipleItem)) {
            MultipleItem = (PKSMULTIPLE_ITEM)Data;
            //
            // Always return the byte count and count of items.
            //
            MultipleItem->Size = DataRangesSize;
            MultipleItem->Count = SourceCount;
            //
            // Additionally see if there is room for the rest of the information.
            //
            if (OutputBufferLength >= DataRangesSize) {
                //
                // Long enough to serialize all the data ranges too.
                //
                Data = MultipleItem + 1;
                DataRanges = SourceRanges;
                for (DataRangesCount = SourceCount; DataRangesCount; DataRangesCount--, DataRanges++) {
                    RtlCopyMemory(Data, DataRanges[0], DataRanges[0]->FormatSize);
                    (PUCHAR)Data += ((DataRanges[0]->FormatSize + FILE_QUAD_ALIGNMENT) & ~FILE_QUAD_ALIGNMENT);
                    //
                    // If this data range has an associated attributes range list,
                    // then copy those attributes also.
                    //
                    if (DataRanges[0]->Flags & KSDATARANGE_ATTRIBUTES) {
                        PKSATTRIBUTE_LIST AttributeList;
                        PKSATTRIBUTE* Attributes;
                        ULONG Count;

                        DataRangesCount--;
                        DataRanges++;
                        AttributeList = (PKSATTRIBUTE_LIST)DataRanges[0];
                        MultipleItem = (PKSMULTIPLE_ITEM)Data;
                        MultipleItem->Size = sizeof(*MultipleItem);
                        MultipleItem->Count = AttributeList->Count;

                        for (Count = AttributeList->Count, Attributes = AttributeList->Attributes; Count; Count--, Attributes++) {
                            RtlCopyMemory((PUCHAR)Data + MultipleItem->Size, Attributes[0], Attributes[0]->Size);
                            MultipleItem->Size += Attributes[0]->Size;
                            //
                            // Align this entry, since another attribute will be
                            // appended.
                            //
                            if (Count > 1) {
                                MultipleItem->Size = (MultipleItem->Size + FILE_QUAD_ALIGNMENT) & ~FILE_QUAD_ALIGNMENT;
                            }
                        }
                        //
                        // Advance the output pointer to include the attribute
                        // list, plus alignment, which is not included in the
                        // attribute list size.
                        //
                        (PUCHAR)Data += ((MultipleItem->Size + FILE_QUAD_ALIGNMENT) & ~FILE_QUAD_ALIGNMENT);
                    }
                }
                Irp->IoStatus.Information = DataRangesSize;
                break;
            } else if (OutputBufferLength == sizeof(*MultipleItem)) {
                //
                // It is valid just to request the size/count.
                //
                Irp->IoStatus.Information = sizeof(*MultipleItem);
                break;
            }
        }
        //
        // Not long enough for everything.
        //
        return STATUS_BUFFER_TOO_SMALL;
    }

    case KSPROPERTY_PIN_INTERFACES:

        //
        // Return the Interface list for this pin. If none have been
        // indicated, then build a list of one which contains the
        // standard interface type.
        //
        if (Descriptor->InterfacesCount) {
            return KsHandleSizedListQuery(Irp, Descriptor->InterfacesCount, sizeof(*Descriptor->Interfaces), Descriptor->Interfaces);
        } else {
            return KsHandleSizedListQuery(Irp, SIZEOF_ARRAY(StandardPinInterfaces), sizeof(StandardPinInterfaces[0]), &StandardPinInterfaces);
        }

    case KSPROPERTY_PIN_MEDIUMS:

        //
        // Return the Mediums list for this pin. If none have been
        // indicated, then build a list of one which contains the
        // standard medium type.
        //
        if (Descriptor->MediumsCount) {
            return KsHandleSizedListQuery(Irp, Descriptor->MediumsCount, sizeof(*Descriptor->Mediums), Descriptor->Mediums);
        } else {
            return KsHandleSizedListQuery(Irp, SIZEOF_ARRAY(StandardPinMediums), sizeof(StandardPinMediums[0]), &StandardPinMediums);
        }

    case KSPROPERTY_PIN_COMMUNICATION:

        //
        // Return the Communications for this pin.
        //
        *(PKSPIN_COMMUNICATION)Data = Descriptor->Communication;
        //Irp->IoStatus.Information = sizeof(Descriptor->Communication);
        break;

    case KSPROPERTY_PIN_CATEGORY:

        //
        // Return the Category Guid for this pin, if any.
        // If there is no Guid, pretend the property is not supported.
        //
        if (Descriptor->Category) {
            *(GUID*)Data = *Descriptor->Category;
            //Irp->IoStatus.Information = sizeof(*Descriptor->Category);
        } else {
            return STATUS_NOT_FOUND;
        }
        break;

    case KSPROPERTY_PIN_NAME:

        //
        // Return the name for this pin, if any.
        // If there are no Guids, pretend the property is not supported.
        //
        if (Descriptor->Name) {
            //
            // If the name Guid is present, then it must be represented
            // in the registry.
            //
            return ReadNodeNameValue(Irp, Descriptor->Name, Data);
        }
        if (Descriptor->Category) {
            //
            // Else try for the name associated with the Category Guid.
            //
            return ReadNodeNameValue(Irp, Descriptor->Category, Data);
        }
        // No break

    default:

        return STATUS_NOT_FOUND;

    }
    return STATUS_SUCCESS;
}


KSDDKAPI
NTSTATUS
NTAPI
KsPinPropertyHandler(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    IN OUT PVOID Data,
    IN ULONG DescriptorsCount,
    IN const KSPIN_DESCRIPTOR* Descriptor
    )
/*++

Routine Description:

    Performs standard handling of the static members of the
    KSPROPSETID_Pin property set. This does not include
    KSPROPERTY_PIN_CINSTANCES or KSPROPERTY_PIN_DATAINTERSECTION.

Arguments:

    Irp -
        Contains the IRP with the property request being handled.

    Property -
        Contains the specific property being queried.

    Data -
        Contains the pin property specific data.

    DescriptorsCount -
        Indicates the number of descriptor structures being passed.

    Descriptor -
        Contains the pointer to the list of pin information structures.

Return Value:

    Returns STATUS_SUCCESS, else an error specific to the property being
    handled. Always fills in the IO_STATUS_BLOCK.Information field of the
    PIRP.IoStatus element within the IRP. It does not set the
    IO_STATUS_BLOCK.Status field, nor complete the IRP however.

--*/
{
    PAGED_CODE();
    return KspPinPropertyHandler(Irp, Property, Data, DescriptorsCount, Descriptor, sizeof(*Descriptor));
}


KSDDKAPI
NTSTATUS
NTAPI
KsPinDataIntersectionEx(
    IN PIRP Irp,
    IN PKSP_PIN Pin,
    OUT PVOID Data,
    IN ULONG DescriptorsCount,
    IN const KSPIN_DESCRIPTOR* Descriptor,
    IN ULONG DescriptorSize,
    IN PFNKSINTERSECTHANDLEREX IntersectHandler OPTIONAL,
    IN PVOID HandlerContext OPTIONAL
    )
/*++

Routine Description:

    Performs handling of the KSPROPERTY_PIN_DATAINTERSECTION through a
    callback.

Arguments:

    Irp -
        Contains the IRP with the property request being handled.

    Pin -
        Contains the specific property being queried.

    Data -
        Contains the pin property specific data.

    DescriptorsCount -
        Indicates the number of descriptor structures.

    Descriptor -
        Contains the pointer to the list of pin information structures.

    DescriptorSize -
        Size of the descriptor structures in bytes.

    IntersectHandler -
        Contains the optional handler for comparison of a Data Range.

    HandlerContext -
        Optional context supplied to the handler.

Return Value:

    Returns STATUS_SUCCESS, else an error specific to the property being
    handled.

--*/
{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpStack;
    KSMULTIPLE_ITEM MultipleItem;
    PKSDATARANGE DataRange;
    ULONG OutputBufferLength;
    ULONG DataSize;

    PAGED_CODE();
    //
    // All properties in this set use a KSP_PIN structure for the property
    // to specify the pin identifier, except for KSPROPERTY_PIN_CTYPES,
    // which refers to the filter as a whole, not a particular pin.
    //
    // Ensure that the identifier is within the range of pins.
    //
    if ((Pin->PinId >= DescriptorsCount) || Pin->Reserved) {
        return STATUS_INVALID_PARAMETER;
    }
    Descriptor = (const KSPIN_DESCRIPTOR *)(((PUCHAR)Descriptor) + 
        DescriptorSize * Pin->PinId);
    //
    // Return the first valid data format which lies within the list of
    // data ranges passed. Do this by repeatedly calling the Sub Handler
    // with each range in the list, making basic validation while
    // enumerating the items.
    //
    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    OutputBufferLength = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;
    //
    // This parameter is guaranteed to be at least large enough to contain a
    // MultipleItem structure, which then indicates what data ranges may follow.
    //
    MultipleItem = *(PKSMULTIPLE_ITEM)(Pin + 1);
    //
    // Ensure that the size claimed is actually valid.
    //
    if (IrpStack->Parameters.DeviceIoControl.InputBufferLength - sizeof(*Pin) < MultipleItem.Size) {
        return STATUS_INVALID_BUFFER_SIZE;
    }
    MultipleItem.Size -= sizeof(MultipleItem);
    DataRange = (PKSDATARANGE)((PKSMULTIPLE_ITEM)(Pin + 1) + 1);
    //
    // Enumerate the given list of data ranges.
    //
    for (;;) {
        ULONG FormatSize;
        ULONG RangeCount;
        const PKSDATARANGE* DataRanges;
        PKSMULTIPLE_ITEM CallerAttributeRanges;

        if (!MultipleItem.Count) {
            //
            // An acceptable data range was not found.
            //
            return STATUS_NO_MATCH;
        }

        if ((MultipleItem.Size < sizeof(*DataRange)) ||
            (DataRange->FormatSize < sizeof(*DataRange)) ||
            (DataRange->FormatSize > MultipleItem.Size) ||
            ((DataRange->FormatSize != sizeof(*DataRange)) &&
            (IsEqualGUIDAligned(&KSDATAFORMAT_SPECIFIER_WILDCARD, &DataRange->Specifier) ||
            IsEqualGUIDAligned(&KSDATAFORMAT_SPECIFIER_NONE, &DataRange->Specifier)))) {
            //
            // As the ranges are enumerated, validate that the Size is consistent.
            // For simple formats, there cannot be any specifier data associated.
            // If the enumerate completes early, this inconsistency would not be
            // caught.
            //
            return STATUS_INVALID_BUFFER_SIZE;
        }
        //
        // Attribute flags are the only valid items on data ranges. Also,
        // if the Required flag is set, then the Attributes flag must be
        // set. The second part of the conditional assumes that there are
        // only two valid flags.
        //
        if ((DataRange->Flags & ~(KSDATARANGE_ATTRIBUTES | KSDATARANGE_REQUIRED_ATTRIBUTES)) ||
            (DataRange->Flags == KSDATARANGE_REQUIRED_ATTRIBUTES)) {
            return STATUS_INVALID_PARAMETER;
        }
        FormatSize = DataRange->FormatSize;
        //
        // If there are more items left, then align the size increment.
        //
        if (MultipleItem.Count > 1) {
            //
            // Not worried about roll over, since the size has already
            // been compared to the multiple item header size.
            //
            FormatSize = (FormatSize + FILE_QUAD_ALIGNMENT) & ~FILE_QUAD_ALIGNMENT;
            //
            // Perform extra size check on aligned size.
            //
            if (FormatSize > MultipleItem.Size) {
                return STATUS_INVALID_BUFFER_SIZE;
            }
        }
        //
        // Validate the attributes.
        //
        if (DataRange->Flags & KSDATARANGE_ATTRIBUTES) {
            //
            // If there are no more items in the list, no attributes were passed.
            //
            if (MultipleItem.Count == 1) {
                return STATUS_INVALID_BUFFER_SIZE;
            }
            //
            // Adjust count to now include the associated attribute range.
            //
            MultipleItem.Count--;
            CallerAttributeRanges = (PKSMULTIPLE_ITEM)((PUCHAR)DataRange + FormatSize);
            //
            // The attribute list validation code checks to see that the Size
            // element in the attribute list header is correct. Adding the
            // size of the attributes range can't roll over. However, check
            // for roll over on the attribute range Size.
            //
            if ((CallerAttributeRanges->Size < sizeof(*CallerAttributeRanges)) ||
                (MultipleItem.Size < FormatSize + sizeof(*CallerAttributeRanges)) ||
                (FormatSize + CallerAttributeRanges->Size < CallerAttributeRanges->Size) ||
                (MultipleItem.Size < FormatSize + CallerAttributeRanges->Size) ||
                !ValidAttributeList(CallerAttributeRanges, KSATTRIBUTE_REQUIRED, DataRange->Flags & KSDATARANGE_REQUIRED_ATTRIBUTES)) {
                return STATUS_INVALID_BUFFER_SIZE;
            }
            FormatSize += CallerAttributeRanges->Size;
            if (MultipleItem.Count > 1) {
                //
                // Not worried about roll over, since the size has already
                // been compared to the multiple item header size.
                //
                FormatSize = (FormatSize + FILE_QUAD_ALIGNMENT) & ~FILE_QUAD_ALIGNMENT;
                //
                // Perform extra size check on aligned size.
                //
                if (FormatSize > MultipleItem.Size) {
                    return STATUS_INVALID_BUFFER_SIZE;
                }
            }
        } else {
            CallerAttributeRanges = NULL;
        }
        //
        // Enumerate the list of data ranges for this pin to see if a match
        // is even possible.
        //
        for (RangeCount = Descriptor->DataRangesCount, DataRanges = Descriptor->DataRanges; RangeCount; RangeCount--, DataRanges++) {
            ULONG AttributesFound;

            //
            // A data range match is found if an element of the DataRange is a
            // wildcard, or if it matches one of the DataRanges.
            //
            if ((IsEqualGUIDAligned(&DataRanges[0]->MajorFormat, &DataRange->MajorFormat) ||
                IsEqualGUIDAligned(&KSDATAFORMAT_TYPE_WILDCARD, &DataRanges[0]->MajorFormat) ||
                IsEqualGUIDAligned(&KSDATAFORMAT_TYPE_WILDCARD, &DataRange->MajorFormat)) &&
                (IsEqualGUIDAligned(&DataRanges[0]->SubFormat, &DataRange->SubFormat) ||
                IsEqualGUIDAligned(&KSDATAFORMAT_SUBTYPE_WILDCARD, &DataRange->SubFormat) ||
                IsEqualGUIDAligned(&KSDATAFORMAT_SUBTYPE_WILDCARD, &DataRanges[0]->SubFormat)) &&
                (IsEqualGUIDAligned(&DataRanges[0]->Specifier, &DataRange->Specifier) ||
                IsEqualGUIDAligned(&KSDATAFORMAT_SPECIFIER_WILDCARD, &DataRange->Specifier) ||
                IsEqualGUIDAligned(&KSDATAFORMAT_SPECIFIER_WILDCARD, &DataRanges[0]->Specifier)) &&
                AttributeIntersection(
                    (DataRanges[0]->Flags & KSDATARANGE_ATTRIBUTES) ? (PKSATTRIBUTE_LIST)DataRanges[1] : NULL,
                    DataRanges[0]->Flags & KSDATARANGE_REQUIRED_ATTRIBUTES,
                    CallerAttributeRanges,
                    &AttributesFound)) {
                
                //
                // This type of intersection can only take place if there are
                // no required attributes, and no attributes present coincide
                // with attributes on the driver's data range.
                //
                // If there's no specifier and we can get non-wildcards from 
                // one range or the other, we can produce a data format 
                // without bothering the handler.
                //
                if (!(DataRange->Flags & KSDATARANGE_REQUIRED_ATTRIBUTES) &&
                    !(DataRanges[0]->Flags & KSDATARANGE_REQUIRED_ATTRIBUTES) &&
                    !AttributesFound &&
                    (IsEqualGUIDAligned(&KSDATAFORMAT_SPECIFIER_NONE, &DataRanges[0]->Specifier) ||
                    IsEqualGUIDAligned(&KSDATAFORMAT_SPECIFIER_NONE, &DataRange->Specifier)) &&
                    ((!IsEqualGUIDAligned(&KSDATAFORMAT_TYPE_WILDCARD, &DataRanges[0]->MajorFormat)) ||
                    (!IsEqualGUIDAligned(&KSDATAFORMAT_TYPE_WILDCARD, &DataRange->MajorFormat))) &&
                    ((!IsEqualGUIDAligned(&KSDATAFORMAT_SUBTYPE_WILDCARD, &DataRanges[0]->SubFormat)) ||
                    (!IsEqualGUIDAligned(&KSDATAFORMAT_SUBTYPE_WILDCARD, &DataRange->SubFormat)))) {

                    //
                    // If this is a size query or the buffer is too small, we don't have to
                    // create the format.
                    //
                    if (!OutputBufferLength) {
                        Irp->IoStatus.Information = sizeof(KSDATAFORMAT);
                        return STATUS_BUFFER_OVERFLOW;
                    } else if (OutputBufferLength < sizeof(KSDATAFORMAT)) {
                        return STATUS_BUFFER_TOO_SMALL;
                    }

                    //
                    // Copy the whole thing from the pin's datarange.  And replace 
                    // wildcards as needed.
                    //
                    RtlCopyMemory(Data, DataRanges[0], sizeof(KSDATAFORMAT));
                    if (IsEqualGUIDAligned(&KSDATAFORMAT_TYPE_WILDCARD, &DataRanges[0]->MajorFormat)) {
                        RtlCopyMemory(&((PKSDATARANGE)Data)->MajorFormat,&DataRange->MajorFormat,sizeof(DataRange->MajorFormat));
                    }
                    if (IsEqualGUIDAligned(&KSDATAFORMAT_SUBTYPE_WILDCARD, &DataRanges[0]->SubFormat)) {
                        RtlCopyMemory(&((PKSDATARANGE)Data)->SubFormat,&DataRange->SubFormat,sizeof(DataRange->SubFormat));
                    }
                    if (IsEqualGUIDAligned(&KSDATAFORMAT_SPECIFIER_WILDCARD, &DataRanges[0]->Specifier)) {
                        RtlCopyMemory(&((PKSDATARANGE)Data)->Specifier,&DataRange->Specifier,sizeof(DataRange->Specifier));
                    }
                    //
                    // Remove any attribute flags, since none will be used.
                    //
                    ((PKSDATAFORMAT)Data)->Flags &= ~(KSDATARANGE_ATTRIBUTES | KSDATARANGE_REQUIRED_ATTRIBUTES);
                    Irp->IoStatus.Information = sizeof(KSDATAFORMAT);
                    return STATUS_SUCCESS;
                } else if (! IntersectHandler) {
                    //
                    // We need an intersect handler when there is a specifier.
                    //
                    return STATUS_NOT_FOUND;
                }

                //
                // If any attributes were actually found, then set up a pointer
                // to the attribute range list for the handler.
                //
                if (AttributesFound) {
                    KSPROPERTY_ATTRIBUTES_IRP_STORAGE(Irp) = (PKSATTRIBUTE_LIST)DataRanges[1];
                }
                //
                // The only reason to attempt to continue is if the data passed was
                // valid, but a match could not be found. This sub-handler could
                // return STATUS_PENDING. If so, there is no continuation of the
                // matching enumeration.
                //
                Status = IntersectHandler(
                    HandlerContext, 
                    Irp, 
                    Pin, 
                    DataRange, 
                    DataRanges[0], 
                    OutputBufferLength,
                    Data,
                    &DataSize);
                if (Status != STATUS_NO_MATCH) {
                    //
                    // Some other error, or success, happened.
                    //
                    if ((Status != STATUS_PENDING) && !NT_ERROR(Status)) {
                        Irp->IoStatus.Information = DataSize;
                    }
                    if (NT_SUCCESS(Status)) {
                        //
                        // If the filter's data range does not have associated
                        // attributes, then the filter may not know anything
                        // about attributes. It may accidentally copy the input
                        // flags into the output. So for compatibility, remove
                        // the flag if it should not be there.
                        //
                        if (Data && !(DataRanges[0]->Flags & KSDATARANGE_ATTRIBUTES)) {
                            ((PKSDATAFORMAT)Data)->Flags &= ~(KSDATARANGE_ATTRIBUTES | KSDATARANGE_REQUIRED_ATTRIBUTES);
                        }
                    }
                    return Status;
                }
            }
            //
            // If this data range has associated attributes, skip past them
            // to get to the next data range in the list.
            //
            if (DataRanges[0]->Flags & KSDATARANGE_ATTRIBUTES) {
                DataRanges++;
                RangeCount--;
            }
        }
        MultipleItem.Size -= FormatSize;
        (PUCHAR)DataRange += FormatSize;
        MultipleItem.Count--;
    }
}


NTSTATUS
CompatibleIntersectHandler(
    IN PVOID Context,
    IN PIRP Irp,
    IN PKSP_PIN Pin,
    IN PKSDATARANGE DataRange,
    IN PKSDATARANGE MatchingDataRange,
    IN ULONG DataBufferSize,
    OUT PVOID Data OPTIONAL,
    OUT PULONG DataSize
    )
/*++

Routine Description:

    This function performs translation between the old style of intersection
    callback, and the new extended method. It essentially throws away all the
    new parameters.

Arguments:

    Context -
        Contains the actual intersection handler to be called.

    Irp -
        Contains the IRP with the property request being handled.

    Pin -
        Contains the specific property being queried.

    DataRange -
        Contains the data range to be matched.

    MatchingDataRange -
        Contains the possible match from the list of data ranges provided by
        the driver. This is not used.

    DataBufferSize -
        Contains the size of the data buffer. This is not used.

    Data -
        Optionally contains the buffer into which to place the data format.

    DataSize -
        Contains the place in which to put the size of the data format returned.
        This is not used.

Return Value:

    Returns the handler's return code to KsPinDataIntersectionEx.

--*/
{
    NTSTATUS Status;
        
    Status = ((PFNKSINTERSECTHANDLER)Context)(Irp, Pin, DataRange, Data);
    *DataSize = (ULONG)Irp->IoStatus.Information;
    return Status;
}


KSDDKAPI
NTSTATUS
NTAPI
KsPinDataIntersection(
    IN PIRP Irp,
    IN PKSP_PIN Pin,
    OUT PVOID Data OPTIONAL,
    IN ULONG DescriptorsCount,
    IN const KSPIN_DESCRIPTOR* Descriptor,
    IN PFNKSINTERSECTHANDLER IntersectHandler
    )
/*++

Routine Description:

    Performs handling of the KSPROPERTY_PIN_DATAINTERSECTION through a
    callback.

Arguments:

    Irp -
        Contains the IRP with the property request being handled.

    Pin -
        Contains the specific property being queried.

    Data -
        Contains the pin property specific data.

    DescriptorsCount -
        Indicates the number of descriptor structures.

    Descriptor -
        Contains the pointer to the list of pin information structures.

    IntersectHandler -
        Contains the handler for comparison of a Data Range.

Return Value:

    Returns STATUS_SUCCESS, else an error specific to the property being
    handled.

--*/
{
    PAGED_CODE();
    return KsPinDataIntersectionEx(
        Irp,
        Pin,
        Data,
        DescriptorsCount,
        Descriptor,
        sizeof(*Descriptor),
        CompatibleIntersectHandler,
        IntersectHandler);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\ks\image.c ===
/*++

    Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    image.c

Abstract:

    KSDSP related support functions:
        - Binary image processing
        - Resource parsing
        - Module name mapping

Author:

    bryanw 10-Dec-1998 Lifted resource loading ideas from setupdd

--*/

#include "ksp.h"
#include <ntimage.h>
#include <stdlib.h>

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA
static const WCHAR ImageValue[] = L"Image";
static const WCHAR ResourceIdValue[] = L"ResourceId";
static const WCHAR RegistrySubPath[] = L"Modules\\";
static const WCHAR ImagePathPrefix[] = L"\\SystemRoot\\system32\\drivers\\";
#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif // ALLOC_DATA_PRAGMA

NTSTATUS
KspRegQueryValue(
    HANDLE RegKey,
    LPCWSTR ValueName,
    PVOID ValueData,
    PULONG ValueLength,
    PULONG ValueType
);

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, KspRegQueryValue)
#pragma alloc_text(PAGE, KsLoadResource)
#pragma alloc_text(PAGE, KsMapModuleName)
#endif


//
// external function references
//

NTSTATUS
LdrAccessResource(
    IN PVOID DllHandle,
    IN PIMAGE_RESOURCE_DATA_ENTRY ResourceDataEntry,
    OUT PVOID *Address OPTIONAL,
    OUT PULONG Size OPTIONAL
    );

NTSTATUS
LdrFindResource_U(
    IN PVOID DllHandle,
    IN PULONG_PTR ResourceIdPath,
    IN ULONG ResourceIdPathLength,
    OUT PIMAGE_RESOURCE_DATA_ENTRY *ResourceDataEntry
    );


KSDDKAPI
NTSTATUS
NTAPI
KsLoadResource(
    IN PVOID ImageBase,
    IN POOL_TYPE PoolType,
    IN ULONG_PTR ResourceName,
    IN ULONG ResourceType,
    OUT PVOID *Resource,
    OUT PULONG ResourceSize            
    )

/*++

Routine Description:
    Copies (loads) a resource from the given image. 

Arguments:
    IN PVOID ImageBase -
        pointer to the image base

    IN POOL_TYPE PoolType -
        pool type to use when copying resource

    IN PULONG_PTR ResourceName -
        resource name

    IN ULONG ResourceType -
        resource type

    OUT PVOID *Resource -
        pointer to resultant resource memory

    OUT PULONG ResourceSize -
        pointer to ULONG value to receive the size of the resource

Return:
    STATUS_SUCCESS, STATUS_INSUFFICIENT_RESOURCES if memory can not
    be allocated otherwise an appropriate error code

--*/

{
    NTSTATUS                    Status;
    PIMAGE_RESOURCE_DATA_ENTRY  ResourceDataEntry;
    PVOID                       ResourceAddress;
    ULONG                       ActualResourceSize;
    ULONG_PTR                   IdPath[3];

    PAGED_CODE();

    IdPath[0] = (ULONG_PTR) ResourceType;
    IdPath[1] = (ULONG_PTR) ResourceName;
    IdPath[2] = 0;

    ASSERT( Resource );

    //
    // Let the kernel know that this is mapped as image.
    //
    ImageBase = (PVOID)((ULONG_PTR)ImageBase | 1);

    try {
        Status = LdrFindResource_U( ImageBase, IdPath, 3, &ResourceDataEntry );
    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = STATUS_UNSUCCESSFUL;
    }

    if (!NT_SUCCESS( Status )) {
        return Status;
    }

    Status = 
        LdrAccessResource(
            ImageBase,
            ResourceDataEntry,
            &ResourceAddress,
            &ActualResourceSize );

    if (NT_SUCCESS( Status )) {

        ASSERT( Resource );

        if (*Resource = ExAllocatePoolWithTag( PoolType, ActualResourceSize, 'srSK' )) {
            RtlCopyMemory( *Resource, ResourceAddress, ActualResourceSize );
            if (ARGUMENT_PRESENT( ResourceSize )) {
                *ResourceSize = ActualResourceSize;
            }
            Status = STATUS_SUCCESS;
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    return Status;
}


NTSTATUS
KspRegQueryValue(
    IN HANDLE RegKey,
    IN LPCWSTR ValueName,
    OUT PVOID ValueData,
    IN OUT PULONG ValueLength,
    OUT PULONG ValueType
)
{
    KEY_VALUE_PARTIAL_INFORMATION   PartialInfoHeader;
    NTSTATUS                        Status;
    UNICODE_STRING                  ValueNameString;
    ULONG                           BytesReturned;

    PAGED_CODE();

    ASSERT( ValueLength );

    RtlInitUnicodeString( &ValueNameString, ValueName );

    Status = ZwQueryValueKey(
        RegKey,
        &ValueNameString,
        KeyValuePartialInformation,
        &PartialInfoHeader,
        sizeof(PartialInfoHeader),
        &BytesReturned);

    if ((Status == STATUS_BUFFER_OVERFLOW) || NT_SUCCESS(Status)) {

        PKEY_VALUE_PARTIAL_INFORMATION  PartialInfoBuffer;

        if (ARGUMENT_PRESENT( ValueType )) {
            *ValueType = PartialInfoHeader.Type;
        }

        if (!*ValueLength) {
            *ValueLength = 
                BytesReturned - FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data);
            return STATUS_BUFFER_OVERFLOW;
        } else if (*ValueLength < BytesReturned - FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data)) {
            return STATUS_BUFFER_TOO_SMALL;
        }

        //
        // Allocate a buffer for the actual size of data needed.
        //

        PartialInfoBuffer = ExAllocatePoolWithTag(
            PagedPool,
            BytesReturned,
            'vrSK');

        if (PartialInfoBuffer) {
            //
            // Retrieve the value.
            //
            Status = ZwQueryValueKey(
                RegKey,
                &ValueNameString,
                KeyValuePartialInformation,
                PartialInfoBuffer,
                BytesReturned,
                &BytesReturned);

            if (NT_SUCCESS(Status)) {
                ASSERT( ValueData );

                //
                // Make sure that there is always a value.
                //
                if (!PartialInfoBuffer->DataLength) {
                    Status = STATUS_UNSUCCESSFUL;
                } else {
                    RtlCopyMemory(
                        ValueData,
                        PartialInfoBuffer->Data,
                        PartialInfoBuffer->DataLength);
                    *ValueLength = PartialInfoBuffer->DataLength;
                }
            }
            ExFreePool(PartialInfoBuffer);
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    return Status;
}


KSDDKAPI
NTSTATUS
NTAPI
KsGetImageNameAndResourceId(
    IN HANDLE RegKey,
    OUT PUNICODE_STRING ImageName,                
    OUT PULONG_PTR ResourceId,
    OUT PULONG ValueType
)
{
    NTSTATUS  Status;
    ULONG     ValueLength, pValueType;

    RtlZeroMemory( ImageName, sizeof( UNICODE_STRING ) );
    *ResourceId = (ULONG_PTR) NULL;

    //
    // First, look up the image name for the given module.  
    // This is a requirement.
    //

    ValueLength = 0;

    Status =
        KspRegQueryValue( 
            RegKey,
            ImageValue,
            NULL,
            &ValueLength,
            &pValueType );

    if (Status == STATUS_BUFFER_OVERFLOW) {
        if (pValueType == REG_SZ) {
            PWCHAR  String;

            ValueLength += wcslen( ImagePathPrefix ) * sizeof( WCHAR );

            if (String = 
                    ExAllocatePoolWithTag( PagedPool, ValueLength, 'tsSK' )) {

                wcscpy( String, ImagePathPrefix );

                Status = 
                    KspRegQueryValue(
                        RegKey,
                        ImageValue,
                        &String[ wcslen( ImagePathPrefix ) ],
                        &ValueLength,
                        NULL );
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }

            if (NT_SUCCESS( Status )) {
                RtlInitUnicodeString( ImageName, String );
            }
        } else {
            Status = STATUS_INVALID_PARAMETER;
        }
    } 

    //
    // If the image name retrieval is successful, move on to
    // retrieve either a resource ID or a resource name.
    //

    if (NT_SUCCESS( Status )) {
        ValueLength = sizeof( ULONG );
        Status =
            KspRegQueryValue( 
                RegKey,
                ResourceIdValue,
                ResourceId,
                &ValueLength,
                ValueType );

        if (*ValueType != REG_DWORD) {
            Status = STATUS_INVALID_PARAMETER;
        }

        //
        // If the resource ID lookup has failed, the last chance effort
        // is to look up a resource name.  
        //

        if (!NT_SUCCESS( Status )) {

            ValueLength = 0;

            Status =
                KspRegQueryValue( 
                    RegKey,
                    ResourceIdValue,
                    NULL,
                    &ValueLength,
                    ValueType );

            if (Status == STATUS_BUFFER_OVERFLOW) {
                if (*ValueType == REG_SZ) {
                    PWCHAR  String;

                    if (String = 
                            ExAllocatePoolWithTag( PagedPool, ValueLength, 'tsSK' )) {
                        Status = 
                            KspRegQueryValue(
                                RegKey,
                                ResourceIdValue,
                                String,
                                &ValueLength,
                                NULL ); 
                    } else {
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                    }

                    if (NT_SUCCESS( Status )) {
                        *ResourceId = (ULONG_PTR) String;
                    }
                } else {
                    Status = STATUS_INVALID_PARAMETER;
                }
            } 
        }
    }
    
    if (!NT_SUCCESS( Status )) {
        if (ImageName->Buffer) {
            RtlFreeUnicodeString( ImageName );
        }
        if ((*ValueType == REG_SZ) && *ResourceId) {
            ExFreePool( ResourceId );
        }
    }
    return Status;
}


KSDDKAPI
NTSTATUS
NTAPI
KsMapModuleName(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN PUNICODE_STRING ModuleName,
    OUT PUNICODE_STRING ImageName,                
    OUT PULONG_PTR ResourceId,
    OUT PULONG ValueType
    )
{
    HANDLE              DeviceRegKey, ModuleRegKey;
    NTSTATUS            Status;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    UNICODE_STRING      RegistryPathString;

    PAGED_CODE();

    ASSERT( ModuleName );
    ASSERT( ResourceId );

    Status =
        IoOpenDeviceRegistryKey(
            PhysicalDeviceObject,
            PLUGPLAY_REGKEY_DEVICE,
            KEY_READ,
            &DeviceRegKey );
    if (!NT_SUCCESS( Status )) {
        return Status;
    }

    if (!(RegistryPathString.Buffer = 
            ExAllocatePoolWithTag( PagedPool, _MAX_PATH, 'prSK' ))) {
        ZwClose( DeviceRegKey );
        return STATUS_INSUFFICIENT_RESOURCES;
    } 

    RegistryPathString.Length = 0;
    RegistryPathString.MaximumLength = _MAX_PATH;

    Status = 
        RtlAppendUnicodeToString(
            &RegistryPathString, RegistrySubPath );

    if (NT_SUCCESS( Status )) {
        Status = 
            RtlAppendUnicodeStringToString(
                &RegistryPathString, ModuleName );
    }

    if (NT_SUCCESS( Status )) {
        InitializeObjectAttributes(
            &ObjectAttributes, 
            &RegistryPathString, 
            OBJ_CASE_INSENSITIVE, 
            DeviceRegKey, 
            NULL);

        Status = ZwOpenKey( &ModuleRegKey, KEY_READ, &ObjectAttributes );
    }
    RtlFreeUnicodeString( &RegistryPathString );

    ZwClose( DeviceRegKey );

    if (!NT_SUCCESS( Status )) {
        return Status;
    }

    Status = 
        KsGetImageNameAndResourceId( 
            ModuleRegKey,
            ImageName,
            ResourceId,
            ValueType );

    ZwClose( ModuleRegKey );

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\ks\irp.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    irp.c

Abstract:

    This module contains Irp related functions for the most part.
*/

#include "ksp.h"

#ifdef C_ASSERT
//
// The KSIRP_REMOVAL_OPERATION enumeration is assumed to have overlapping
// bits.
//
C_ASSERT(KsAcquireAndRemove & KsAcquireAndRemoveOnlySingleItem);
C_ASSERT(KsAcquireOnlySingleItem & KsAcquireAndRemoveOnlySingleItem);
#endif // C_ASSERT

#define KSSIGNATURE_CREATE_ENTRY 'ecSK'
#define KSSIGNATURE_CREATE_HANDLER 'hcSK'
#define KSSIGNATURE_DEVICE_HEADER 'hdSK'
#define KSSIGNATURE_OBJECT_HEADER 'hoSK'
#define KSSIGNATURE_OBJECT_PARAMETERS 'poSK'
#define KSSIGNATURE_AUX_CREATE_PARAMETERS 'pcSK'
#define KSSIGNATURE_STREAM_HEADERS 'hsSK'
#define KSSIGNATURE_AUX_STREAM_HEADERS 'haSK'
#define KSSIGNATURE_STANDARD_BUS_INTERFACE 'isSK'

#ifdef ALLOC_PRAGMA
VOID
FreeCreateEntries(
    PLIST_ENTRY ChildCreateHandlerList
    );
NTSTATUS
KsiAddObjectCreateItem(
    IN PLIST_ENTRY ChildCreateHandlerList,
    IN PDRIVER_DISPATCH Create,
    IN PVOID Context,
    IN PWCHAR ObjectClass,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor OPTIONAL
    );
NTSTATUS
ValidateCreateAccess(
    IN PIRP Irp,
    IN PKSOBJECT_CREATE_ITEM CreateItem
    );
PKSICREATE_ENTRY
FindAndReferenceCreateItem(
    IN PWCHAR Buffer,
    IN ULONG Length,
    IN PLIST_ENTRY ChildCreateHandlerList
    );
NTSTATUS
DispatchCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
NTSTATUS
DispatchDeviceIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
BOOLEAN
DispatchFastDeviceIoControl(
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );
NTSTATUS
DispatchRead(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
BOOLEAN
DispatchFastRead(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );
NTSTATUS
DispatchWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
BOOLEAN
DispatchFastWrite(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );
NTSTATUS
DispatchFlush(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
NTSTATUS
DispatchClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
NTSTATUS
DispatchQuerySecurity(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
NTSTATUS
DispatchSetSecurity(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

#pragma alloc_text(PAGE, KsAcquireDeviceSecurityLock)
#pragma alloc_text(PAGE, KsReleaseDeviceSecurityLock)
#pragma alloc_text(PAGE, KsReferenceBusObject)
#pragma alloc_text(PAGE, KsiGetBusInterface)
#pragma alloc_text(PAGE, KsDereferenceBusObject)
#pragma alloc_text(PAGE, KsDefaultDispatchPnp)
#pragma alloc_text(PAGE, KsDefaultForwardIrp)
#pragma alloc_text(PAGE, KsSetDevicePnpAndBaseObject)
#pragma alloc_text(PAGE, KsQueryDevicePnpObject)
#pragma alloc_text(PAGE, FreeCreateEntries)
#pragma alloc_text(PAGE, KsAllocateDeviceHeader)
#pragma alloc_text(PAGE, KsFreeDeviceHeader)
#pragma alloc_text(PAGE, KsQueryObjectAccessMask)
#pragma alloc_text(PAGE, KsRecalculateStackDepth)
#pragma alloc_text(PAGE, KsSetTargetState)
#pragma alloc_text(PAGE, KsSetTargetDeviceObject)
#pragma alloc_text(PAGE, KsQueryObjectCreateItem)
#pragma alloc_text(PAGE, KsAllocateObjectHeader)
#pragma alloc_text(PAGE, KsAllocateObjectCreateItem)
#pragma alloc_text(PAGE, KsFreeObjectCreateItem)
#pragma alloc_text(PAGE, KsFreeObjectCreateItemsByContext)
#pragma alloc_text(PAGE, KsiQueryObjectCreateItemsPresent)
#pragma alloc_text(PAGE, KsiAddObjectCreateItem)
#pragma alloc_text(PAGE, KsAddObjectCreateItemToDeviceHeader)
#pragma alloc_text(PAGE, KsAddObjectCreateItemToObjectHeader)
#pragma alloc_text(PAGE, KsiCreateObjectType)
#pragma alloc_text(PAGE, KsiCopyCreateParameter)
#pragma alloc_text(PAGE, ValidateCreateAccess)
#pragma alloc_text(PAGE, FindAndReferenceCreateItem)
#pragma alloc_text(PAGE, DispatchCreate)
#pragma alloc_text(PAGE, DispatchDeviceIoControl)
#pragma alloc_text(PAGE, DispatchFastDeviceIoControl)
#pragma alloc_text(PAGE, DispatchRead)
#pragma alloc_text(PAGE, DispatchFastRead)
#pragma alloc_text(PAGE, DispatchWrite)
#pragma alloc_text(PAGE, DispatchFastWrite)
#pragma alloc_text(PAGE, DispatchFlush)
#pragma alloc_text(PAGE, DispatchClose)
#pragma alloc_text(PAGE, KsDispatchQuerySecurity)
#pragma alloc_text(PAGE, KsDispatchSetSecurity)
#pragma alloc_text(PAGE, DispatchQuerySecurity)
#pragma alloc_text(PAGE, DispatchSetSecurity)
#pragma alloc_text(PAGE, KsDispatchSpecificProperty)
#pragma alloc_text(PAGE, KsDispatchSpecificMethod)
#pragma alloc_text(PAGE, KsDispatchInvalidDeviceRequest)
#pragma alloc_text(PAGE, KsDefaultDeviceIoCompletion)
#pragma alloc_text(PAGE, KsDispatchIrp)
#pragma alloc_text(PAGE, KsDispatchFastIoDeviceControlFailure)
#pragma alloc_text(PAGE, KsDispatchFastReadFailure)
#pragma alloc_text(PAGE, KsNullDriverUnload)
#pragma alloc_text(PAGE, KsSetMajorFunctionHandler)
#pragma alloc_text(PAGE, KsReadFile)
#pragma alloc_text(PAGE, KsWriteFile)
#pragma alloc_text(PAGE, KsQueryInformationFile)
#pragma alloc_text(PAGE, KsSetInformationFile)
#pragma alloc_text(PAGE, KsStreamIo)
#pragma alloc_text(PAGE, KsProbeStreamIrp)
#pragma alloc_text(PAGE, KsAllocateExtraData)

#endif // ALLOC_PRAGMA

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA
static const WCHAR ObjectTypeName[] = L"File";
#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif // ALLOC_DATA_PRAGMA


KSDDKAPI
VOID
NTAPI
KsAcquireDeviceSecurityLock(
    IN KSDEVICE_HEADER Header,
    IN BOOLEAN Exclusive
    )
/*++

Routine Description:

    Acquires the security lock associated with a device object. A shared
    lock is acquired when validating access during a create. An exclusive
    lock is acquired when changing a security descriptor. When manipulating
    the security of any object under a particular device object, this lock
    must be acquired.

Arguments:

    Header -
        Points to a header previously allocated by KsAllocateDeviceHeader
        whose security lock is to be acquired.

    Exclusive -
        Set to TRUE if the lock is to be acquired exclusively.

Return Value:

    Nothing.

--*/
{
    PAGED_CODE();
#ifndef WIN9X_KS
    KeEnterCriticalRegion();
    if (Exclusive) {
        ExAcquireResourceExclusiveLite(&((PKSIDEVICE_HEADER)Header)->SecurityDescriptorResource, TRUE);
    } else {
        ExAcquireResourceSharedLite(&((PKSIDEVICE_HEADER)Header)->SecurityDescriptorResource, TRUE);
    }
#endif // !WIN9X_KS
}


KSDDKAPI
VOID
NTAPI
KsReleaseDeviceSecurityLock(
    IN KSDEVICE_HEADER Header
    )
/*++

Routine Description:

    Releases a previously acquired security lock on the device object header.

Arguments:

    Header -
        Points to a header previously allocated by KsAllocateDeviceHeader
        whose security lock is to be released.

Return Value:

    Nothing.

--*/
{
    PAGED_CODE();
#ifndef WIN9X_KS
    ExReleaseResourceLite(&((PKSIDEVICE_HEADER)Header)->SecurityDescriptorResource);
    KeLeaveCriticalRegion();
#endif // !WIN9X_KS
}


KSDDKAPI
NTSTATUS
NTAPI
KsReferenceBusObject(
    IN KSDEVICE_HEADER Header
    )
/*++

Routine Description:

    References the bus Physical device object. This is used by filters
    which use the device header to keep track of their PnP object stack. This is
    normally called on a successful Open of the filter when the bus for this
    device requires such a reference (such as software devices), and is matched
    by a call to KsDereferenceBusObject on a close of that filter instance.

    The caller must have previously also called KsSetDevicePnpAndBaseObject in order
    to set the PnP device stack object. This would have been done in the PnP Add
    Device function.

    If the object has not been previously referenced, interface space is allocated
    and the function uses the PnP device object to acquire the bus referencing
    interface. It then calls the ReferenceDeviceObject method on that interface.
    The interface itself is released and freed when the device header is freed.

Arguments:

    Header -
        Points to a header previously allocated by KsAllocateDeviceHeader, which
        also contains the PnP device stack object.

Return Value:

    Returns STATUS_SUCCESS if the reference was successful, else an error such as
    STATUS_INSUFFICIENT_RESOURCES.

--*/
{
    PKSIDEVICE_HEADER DeviceHeader;
    NTSTATUS status;

    PAGED_CODE();
    DeviceHeader = (PKSIDEVICE_HEADER)Header;

    status = KsiGetBusInterface(DeviceHeader);

    //
    // Succeed even if the interface is not supported.
    //
    if (status == STATUS_NOT_SUPPORTED) {
        status = STATUS_SUCCESS;
    } else if (NT_SUCCESS(status)) {
        DeviceHeader->BusInterface->ReferenceDeviceObject(DeviceHeader->BusInterface->Interface.Context);
    }

    return status;
}


NTSTATUS
KsiGetBusInterface(
    IN PKSIDEVICE_HEADER DeviceHeader
    )
/*++

Routine Description:

    Gets the cached copy of the bus interface, performing the query if 
    necessary.

    The caller must have previously also called KsSetDevicePnpAndBaseObject in order
    to set the PnP device stack object. This would have been done in the PnP Add
    Device function.

    If the object has not been previously referenced, interface space is allocated
    and the function uses the PnP device object to acquire the bus referencing
    interface.  The interface is released and freed when the device header is freed.

Arguments:

    DeviceHeader -
        Points to a header previously allocated by KsAllocateDeviceHeader, which
        also contains the PnP device stack object.

Return Value:

    Returns STATUS_SUCCESS if the interface was already cached, else the status
    of the completed request.  STATUS_NOT_SUPPORTED indicates the interface is
    not supported, which is normal for all bus drivers except swenum.

--*/
{
    NTSTATUS status;

    PAGED_CODE();
    ASSERT(DeviceHeader->PnpDeviceObject && "KsSetDevicePnpAndBaseObject was not used on this header");

    //
    // watch out for race condition. must take syc obj here if not recheck in CS.
    // we optimize it by recheck in CS, see comments in "else" branch.
    //
    //KeEnterCriticalRegion();
    //ExAcquireFastMutexUnsafe(&DeviceHeader->ObjectListLock);

    if (DeviceHeader->QueriedBusInterface) {
        if (DeviceHeader->BusInterface) {
            status = STATUS_SUCCESS;
        } 

        else {
            status = STATUS_NOT_SUPPORTED;
        }

    } 

    else {

        //
        // Synchronize with multiple instances of an opened device.
        //
        // too late to take the sync obj here
        // but this path is a one time deal per devheader. Optimize it by
        // taking the sync obj here, but check the boolean once more inside
        // CS. More than one thread can reach here. But only one should
        // continue to do the work.
        //

        KeEnterCriticalRegion();
        ExAcquireFastMutexUnsafe(&DeviceHeader->ObjectListLock);

        if ( DeviceHeader->QueriedBusInterface ) {
            //
            // Other thread beat us getting in here. The work
            // should have been done. simply use his work.
            //
            if (DeviceHeader->BusInterface) {
               status = STATUS_SUCCESS;
            }
            else {
                status = STATUS_NOT_SUPPORTED;
            }            
            ExReleaseFastMutexUnsafe(&DeviceHeader->ObjectListLock);
            KeLeaveCriticalRegion();
            return status;
        }

        //
        // This is used to hold the interface returned by the bus.
        //

        DeviceHeader->BusInterface = ExAllocatePoolWithTag(
            PagedPool,
            sizeof(*DeviceHeader->BusInterface),
            KSSIGNATURE_STANDARD_BUS_INTERFACE);
        if (!DeviceHeader->BusInterface) {
            ExReleaseFastMutexUnsafe(&DeviceHeader->ObjectListLock);
            KeLeaveCriticalRegion();
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        //
        // Attempt to acquire a reference count on the interface by calling
        // the underlying PnP object stack.
        //
        status = QueryReferenceBusInterface(
            DeviceHeader->PnpDeviceObject,
            DeviceHeader->BusInterface);
        if (! NT_SUCCESS(status)) {
            ExFreePool(DeviceHeader->BusInterface);
            DeviceHeader->BusInterface = NULL;
            //
            // Check to see whether the bus is returning some bogus status.
            // LonnyM says this should be enforced.
            //
            // HACKHACK: (WRM 8/24/99) See notes below.
            //
            if (/* (status == STATUS_NOT_IMPLEMENTED) ||  */ 
                (status == STATUS_INVALID_PARAMETER_1) || 
                (status == STATUS_INVALID_PARAMETER) || 
                (status == STATUS_INVALID_DEVICE_REQUEST)) {

            _DbgPrintF( 
                DEBUGLVL_TERSE, 
                ("ERROR! The PDO returned an invalid error code (%08x) in response to an interface query.  Use \"!devobj %p\" to report the culprit",
                    status,DeviceHeader->PnpDeviceObject) );
            KeBugCheckEx (
                PNP_DETECTED_FATAL_ERROR,
                0x101,
                (ULONG_PTR) DeviceHeader,
                (ULONG_PTR) DeviceHeader->PnpDeviceObject,
                (ULONG_PTR) NULL
                );
            }

            //
            // HACKHACK: (WRM 8/24/99)
            //
            // All query interface irps will return
            // STATUS_NOT_IMPLEMENTED which screws any number of things
            // up.  If the interface is not supported, STATUS_NOT_SUPPORTED
            // should be returned.  In order to get h/w drivers on the PCI
            // bus to work under Millennium, I have to munge
            // STATUS_NOT_IMPLEMENTED into STATUS_NOT_SUPPORTED. 
            //

            if (status == STATUS_NOT_IMPLEMENTED) {
                status = STATUS_NOT_SUPPORTED;
            }

        }

        //
        // Must set it true before we leave the CS.
        //

        DeviceHeader->QueriedBusInterface = TRUE;
        ExReleaseFastMutexUnsafe(&DeviceHeader->ObjectListLock);
        KeLeaveCriticalRegion();
    }

    return status;
}


KSDDKAPI
VOID
NTAPI
KsDereferenceBusObject(
    IN KSDEVICE_HEADER Header
    )
/*++

Routine Description:

    Dereferences the bus Physical device object. This is used by filters which
    use the device header to keep track of their PnP object stack. This is
    normally called on a Close of the filter when the bus for this device
    requires it (such as software devices), and matches a previous call to
    KsReferenceBusObject on an open of that filter instance.

    The caller must have previously also called KsSetDevicePnpAndBaseObject in order
    to set the PnP device stack object. This would have been done in the PnP Add
    Device function.

    The function calls the DereferenceDeviceObject method on the previously
    retrieved interface. The interface itself is released and freed when the device
    header is freed.

Arguments:

    Header -
        Points to a header previously allocated by KsAllocateDeviceHeader, which
        also contains the PnP device stack object.

Return Value:

    Nothing.

--*/
{
    PKSIDEVICE_HEADER DeviceHeader;

    PAGED_CODE();
    DeviceHeader = (PKSIDEVICE_HEADER)Header;
    ASSERT(DeviceHeader->PnpDeviceObject && "KsSetDevicePnpAndBaseObject was not used on this header");
#ifndef WIN9X_KS	
    ASSERT(DeviceHeader->QueriedBusInterface && "Caller never used KsReferenceBusObject");
#endif
    //
    // The bus may not support the referencing interface.
    //
    if (DeviceHeader->BusInterface) {
        DeviceHeader->BusInterface->DereferenceDeviceObject(DeviceHeader->BusInterface->Interface.Context);
    }
}


KSDDKAPI
NTSTATUS
NTAPI
KsDefaultForwardIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:
    This is a default handler for dispatch routines that simply want to
    forward an I/O request to their Physical Device Object only because 
    the driver is required to have a IRP_MJ_* function handler for a specific
    major function.  For example, this is the case for IRP_MJ_SYSTEM_CONTROL.

Arguments:
    DeviceObject -
        Contains the Functional Device Object.

    Irp -
        Contains the Irp.

Return Values:
    Returns the status of the underlying Physical Device Object Irp processing.

--*/
{
    PKSIDEVICE_HEADER DeviceHeader;
    PIO_STACK_LOCATION IrpStack;
    
    PAGED_CODE();
    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    DeviceHeader = *(PKSIDEVICE_HEADER*)IrpStack->DeviceObject->DeviceExtension;
    ASSERT(DeviceHeader->PnpDeviceObject && "KsSetDevicePnpAndBaseObject was not used on this header");
    
    //
    // Ensure that there is another stack location before copying parameters.
    //
    ASSERT((Irp->CurrentLocation > 1) && "No more stack locations");
    
    if (Irp->CurrentLocation > 1) {
        //
        // Copy everything, then rewrite the file object.
        //
        IoCopyCurrentIrpStackLocationToNext(Irp);
        return IoCallDriver(DeviceHeader->PnpDeviceObject, Irp);
    }
    Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_INVALID_DEVICE_REQUEST;
}


KSDDKAPI
NTSTATUS
NTAPI
KsDefaultDispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:
    This is a default main PnP dispatch handler. Notifications regarding the
    Functional Device Object may be directed here. This function passes all
    notifications to the PnP Device Object previously set with KsSetDevicePnpAndBaseObject,
    and assumes the use of a device header. On an IRP_MN_REMOVE_DEVICE,
    this function deletes the device object.

    The function is useful when there is no extra cleanup which needs to be
    performed on device removal, beyond freeing the device header and deleting
    the actual device object.

Arguments:
    DeviceObject -
        Contains the Functional Device Object.

    Irp -
        Contains the PnP Irp.

Return Values:

    Returns the status of the underlying Physical Device Object Irp processing.

--*/
{
    NTSTATUS Status;
    PKSIDEVICE_HEADER DeviceHeader;
    PIO_STACK_LOCATION IrpStack;
    UCHAR MinorFunction;
    PDEVICE_OBJECT PnpDeviceObject;
    
    PAGED_CODE();
    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    DeviceHeader = *(PKSIDEVICE_HEADER*)IrpStack->DeviceObject->DeviceExtension;
    ASSERT(DeviceHeader->PnpDeviceObject && "KsSetDevicePnpAndBaseObject was not used on this header");
    //
    // Save this now in order to detach in case of a Remove.
    //
    PnpDeviceObject = DeviceHeader->PnpDeviceObject;
    //
    // Store this before passing the Irp along in order to check it later.
    //
    MinorFunction = IrpStack->MinorFunction;

    //
    // Set Irp->IoStatus.Status per PnP specification.
    //

    switch (MinorFunction) {

    case IRP_MN_REMOVE_DEVICE:

        //
        // The device header must be destroyed before passing on the Remove
        // request because the bus interface may have to be released, and
        // cannot be after the information on the PDO has been deleted.
        //
        KsFreeDeviceHeader(DeviceHeader);
        // No break
    case IRP_MN_START_DEVICE:
    case IRP_MN_QUERY_REMOVE_DEVICE:
    case IRP_MN_CANCEL_REMOVE_DEVICE:
    case IRP_MN_STOP_DEVICE:
    case IRP_MN_QUERY_STOP_DEVICE:
    case IRP_MN_CANCEL_STOP_DEVICE:
    case IRP_MN_SURPRISE_REMOVAL:
        Irp->IoStatus.Status = STATUS_SUCCESS;
        break;
    }

    //
    // Just reuse the current stack location when forwarding the call. This
    // is assumed when recalculating the stack size for a Pin.
    //
    IoSkipCurrentIrpStackLocation(Irp);
    Status = IoCallDriver(PnpDeviceObject, Irp);
    //
    // The only Irp that matters is a RemoveDevice, on which the device
    // object is deleted.
    //
    if (MinorFunction == IRP_MN_REMOVE_DEVICE) {
        //
        // Removes any reference on the PDO so that it can be deleted.
        //
        IoDetachDevice(PnpDeviceObject);
        //
        // The device object obviously cannot be touched after this point.
        //
        IoDeleteDevice(DeviceObject);
    }
    return Status;
}


KSDDKAPI
NTSTATUS
NTAPI
KsDefaultDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:
    This is a default main Power dispatch handler. Notifications regarding the
    Functional Device Object may be directed here. This function passes all
    notifications to the Pnp Device Object previously set with KsSetDevicePnpAndBaseObject,
    and assumes the use of a device header.

    The function is useful when there is no extra cleanup which needs to be
    performed on power Irps, or just as a way of completing any power Irp. It
    also allows specific file objects, such as the default clock implementation,
    to attach themselves to the power Irps using KsSetPowerDispatch, and act on
    them before they are completed by this routine. This function calls each
    power dispatch routine before completing the Irp.

Arguments:
    DeviceObject -
        Contains the Functional Device Object.

    Irp -
        Contains the Power Irp.

Return Values:

    Returns the status of the underlying Physical Device Object Irp processing.

--*/
{
    PKSIDEVICE_HEADER DeviceHeader;
    PIO_STACK_LOCATION IrpStack;
    PLIST_ENTRY CurrentItem;
    KIRQL oldIrql;
    PETHREAD PowerEnumThread;

    ASSERT((KeGetCurrentIrql() <= DISPATCH_LEVEL) && "Called at high Irql");
    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    DeviceHeader = *(PKSIDEVICE_HEADER*)IrpStack->DeviceObject->DeviceExtension;
    ASSERT(DeviceHeader->PnpDeviceObject && "KsSetDevicePnpAndBaseObject was not used on this header");
    PowerEnumThread = PsGetCurrentThread();
    //
    // Synchronize with multiple instances of an opened device.
    // Depending on the pagable flag, take a spinlock, or just
    // a mutex.
    //
    if (DeviceHeader->BaseDevice->Flags & DO_POWER_PAGABLE) {
        //
        // Power handlers for POWER_PAGEABLE are always called in 
        // the context of a worker thread.
        //
        KeEnterCriticalRegion();
        ExAcquireFastMutexUnsafe(&DeviceHeader->LoPowerListLock);
    } else {
        KeAcquireSpinLock(&DeviceHeader->HiPowerListLock, &oldIrql);
    }
    //
    // Acquire the current thread so that a recursive call to
    // KsSetPowerDispatch may be made by this thread. This allows
    // the current object header to be removed from the list
    // during the callback. In no other case does the driver
    // get execution control of this thread while the mutex is
    // being held.
    //
    ASSERT(!DeviceHeader->PowerEnumThread && "This device is already processing a Power Irp");
    DeviceHeader->PowerEnumThread = PowerEnumThread;
    //
    // Enumerate the object in the list and dispatch to each power routine.
    //
    for (CurrentItem = &DeviceHeader->PowerList;
        CurrentItem->Flink != &DeviceHeader->PowerList;) {
        PKSIOBJECT_HEADER ObjectHeader;
        NTSTATUS Status;

        ObjectHeader = CONTAINING_RECORD(
            CurrentItem->Flink,
            KSIOBJECT_HEADER,
            PowerList);
        ASSERT(ObjectHeader->PowerDispatch && "The object added to the enum list does not have a PowerDispatch routine");
        //
        // Pre-increment so that this item can be removed from the list
        // if needed.
        //
        CurrentItem = CurrentItem->Flink;
        Status = ObjectHeader->PowerDispatch(ObjectHeader->PowerContext, Irp);
        ASSERT(NT_SUCCESS(Status) && "The PowerDispatch routine which cannot fail did not return STATUS_SUCCESS");
    }
    //
    // Indicate that the callback is no longer occuring.
    //
    DeviceHeader->PowerEnumThread = NULL;
    //
    // Release the lock as it was taken.
    //
    if (DeviceHeader->BaseDevice->Flags & DO_POWER_PAGABLE) {
        ExReleaseFastMutexUnsafe(&DeviceHeader->LoPowerListLock);
        KeLeaveCriticalRegion();
    } else {
        KeReleaseSpinLock(&DeviceHeader->HiPowerListLock, oldIrql);
    }
    //
    // Start the next power Irp and clean up current one.
    //
    PoStartNextPowerIrp(Irp);
    //
    // Just reuse the current stack location when forwarding the call. This
    // is assumed when recalculating the stack size for a Pin.
    //
    IoSkipCurrentIrpStackLocation(Irp);
    return PoCallDriver(DeviceHeader->PnpDeviceObject, Irp);
}


KSDDKAPI
VOID
NTAPI
KsSetDevicePnpAndBaseObject(
    IN KSDEVICE_HEADER Header,
    IN PDEVICE_OBJECT PnpDeviceObject,
    IN PDEVICE_OBJECT BaseDevice
    )
/*++

Routine Description:

    Sets the PnP Device Object in the device header. This is the next device object
    on the PnP stack, and is what PnP requests are forwared to if
    KsDefaultDispatchPnp is used.

Arguments:

    Header -
        Points to a header previously allocated by KsAllocateDeviceHeader
        in which to put the PnP Device Object.

    PnpDeviceObject -
        Contains the PnP Device Object to place in the device header, overwriting
        any previously set device object.

    BaseDevice -
        Contains the base device object to which this device header is attached.
        This must be set if stack recalculation functionality or power dispatch
        will be used.

Return Value:

    Nothing.

--*/
{
    PAGED_CODE();
    ((PKSIDEVICE_HEADER)Header)->PnpDeviceObject = PnpDeviceObject;
    ((PKSIDEVICE_HEADER)Header)->BaseDevice = BaseDevice;
}


KSDDKAPI
PDEVICE_OBJECT
NTAPI
KsQueryDevicePnpObject(
    IN KSDEVICE_HEADER Header
    )
/*++

Routine Description:

    Returns the PnP Device Object which can be stored in the device header. This is
    the next device object on the PnP stack, and is what PnP requests are forwared
    to if KsDefaultDispatchPnp is used.

Arguments:

    Header -
        Points to a header previously allocated by KsAllocateDeviceHeader
        whose PnP Device Object is to be returned.

Return Value:

    The previously set PnP Device Object. If none was previously set, this returns
    NULL

--*/
{
    PAGED_CODE();
    return ((PKSIDEVICE_HEADER)Header)->PnpDeviceObject;
}


VOID
FreeCreateEntries(
    PLIST_ENTRY ChildCreateHandlerList
    )
/*++

Routine Description:

    Frees the contents of the create item list. If the create item was dynamically
    added by copying a provided entry, and if there is a Free callback, then call
    the function before freeing the item.

Arguments:

    ChildCreateHandlerList -
        The create entry list to free.
    
Return Value:

    Nothing.

--*/
{
    while (!IsListEmpty(ChildCreateHandlerList)) {
        PLIST_ENTRY ListEntry;
        PKSICREATE_ENTRY Entry;

        ListEntry = RemoveHeadList(ChildCreateHandlerList);
        Entry = CONTAINING_RECORD(ListEntry, KSICREATE_ENTRY, ListEntry);
        ASSERT((Entry->RefCount < 2) && "There is a thread in the middle of a create using this CreateItem");
        //
        // The entry may point to an item which was copied internally
        // rather than being passed in on a list or pointed to externally.
        //
        if (Entry->Flags & CREATE_ENTRY_FLAG_COPIED) {
            //
            // This item may need a cleanup callback, which can take care
            // of things like security changes.
            //
            if (Entry->ItemFreeCallback) {
                Entry->ItemFreeCallback(Entry->CreateItem);
            }
        }
        //
        // If the create item was allocated and copied, it was allocated in
        // the same block with the entry.
        //
        ExFreePool(Entry);
    }
}


KSDDKAPI
NTSTATUS
NTAPI
KsAllocateDeviceHeader(
    OUT KSDEVICE_HEADER* Header,
    IN ULONG ItemsCount,
    IN PKSOBJECT_CREATE_ITEM ItemsList OPTIONAL
    )
/*++

Routine Description:

    Allocates and initialize the required device extension header.

Arguments:

    Header -
        Points to the place in which to return a pointer to the initialized
        header.

    ItemsCount -
        Number of child create items in the ItemsList. This should be zero
        if an ItemsList is not passed.

    ItemsList -
        List of child create items, or NULL if there are none.

Return Value:

    Returns STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES.

--*/
{
    PKSIDEVICE_HEADER DeviceHeader;

    PAGED_CODE();
    //
    // Allocate NonPagedPool because of the Resource.
    //
    DeviceHeader = ExAllocatePoolWithTag(
        NonPagedPool,
        sizeof(*DeviceHeader),
        KSSIGNATURE_DEVICE_HEADER);
    if (!DeviceHeader) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    InitializeListHead(&DeviceHeader->ChildCreateHandlerList);
    //
    // Keep a list of pointers to the create items so that they can
    // be added to without needing to reserve slots in a fixed list.
    //
    for (; ItemsCount--;) {
        PKSICREATE_ENTRY Entry;

        Entry = ExAllocatePoolWithTag(PagedPool, sizeof(*Entry), KSSIGNATURE_CREATE_ENTRY);
        if (!Entry) {
            FreeCreateEntries(&DeviceHeader->ChildCreateHandlerList);
            ExFreePool(DeviceHeader);
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        Entry->CreateItem = &ItemsList[ItemsCount];
        Entry->ItemFreeCallback = NULL;
        Entry->RefCount = 1;
        Entry->Flags = 0;
        InsertHeadList(&DeviceHeader->ChildCreateHandlerList, &Entry->ListEntry);
    }
#ifndef WIN9X_KS
    ExInitializeResourceLite(&DeviceHeader->SecurityDescriptorResource);
#endif // !WIN9X_KS
    DeviceHeader->PnpDeviceObject = NULL;
    DeviceHeader->BusInterface = NULL;
    InitializeListHead(&DeviceHeader->ObjectList);
    ExInitializeFastMutex(&DeviceHeader->ObjectListLock);
    ExInitializeFastMutex(&DeviceHeader->CreateListLock);
    InitializeListHead(&DeviceHeader->PowerList);
    ExInitializeFastMutex(&DeviceHeader->LoPowerListLock);
    KeInitializeSpinLock(&DeviceHeader->HiPowerListLock);
    DeviceHeader->PowerEnumThread = NULL;
    DeviceHeader->BaseDevice = NULL;
    DeviceHeader->Object = NULL;
    DeviceHeader->QueriedBusInterface = FALSE;
    *Header = DeviceHeader;
    return STATUS_SUCCESS;
}


KSDDKAPI
VOID
NTAPI
KsFreeDeviceHeader(
    IN KSDEVICE_HEADER Header
    )
/*++

Routine Description:

    Cleans up and frees a previously allocated device header.

Arguments:

    Header -
        Points to the device header to free.

Return Value:

    Nothing.

--*/
{
    PKSIDEVICE_HEADER DeviceHeader;

    PAGED_CODE();
    DeviceHeader = (PKSIDEVICE_HEADER)Header;
    ASSERT(IsListEmpty(&DeviceHeader->ObjectList) && "The driver did not remove all the streaming Irp destinations");
    ASSERT(IsListEmpty(&DeviceHeader->PowerList) && "The driver did not remove all the Power Irp destinations");
    //
    // Destroy the list of create item entries.
    //
    FreeCreateEntries(&DeviceHeader->ChildCreateHandlerList);
#ifndef WIN9X_KS
    ExDeleteResourceLite(&DeviceHeader->SecurityDescriptorResource);
#endif // !WIN9X_KS
    //
    // The caller may have been a device which also used the header
    // to set the open reference count on the underlying PDO.
    //
    if (DeviceHeader->BusInterface) {
        //
        // The interface is referenced when it comes back from the query
        // interface call, so it must be dereferenced before discarding.
        //
        DeviceHeader->BusInterface->Interface.InterfaceDereference(DeviceHeader->BusInterface->Interface.Context);
        ExFreePool(DeviceHeader->BusInterface);
    }
    ExFreePool(Header);
}


KSDDKAPI
ACCESS_MASK
NTAPI
KsQueryObjectAccessMask(
    IN KSOBJECT_HEADER Header
    )
/*++

Routine Description:

    Returns the access originally granted to the first client that created
    a handle on the associated object. Access can not be changed by
    duplicating handles.

Arguments:

    Header -
        Points to a header previously allocated by KsAllocateObjectHeader
        whose access granted mask pointer is to be returned.

Return Value:

    Returns an access mask.

--*/
{
    PAGED_CODE();
    return ((PKSIOBJECT_HEADER)Header)->ObjectAccess;
}


KSDDKAPI
VOID
NTAPI
KsRecalculateStackDepth(
    IN KSDEVICE_HEADER Header,
    IN BOOLEAN ReuseStackLocation
    )
/*++

Routine Description:

    Recalculates the maximum stack depth needed by the underlying device object
    based on all of the objects which have set a target device, and thus added
    themselves to the object list, on the underlying device object. If the PnP
    device object has been set on the underlying device header using
    KsSetDevicePnpAndBaseObject, that device is also taken into account when calculating
    the maximum stack depth required.

    Assumes that KsSetDevicePnpAndBaseObject has been called on this device
    header, and assigned a base object whose stack depth is to be recalculated.

    This function allows Irp's to be forwarded through an object by ensuring that
    any Irp allocated on this device will have sufficient stack locations to
    be able to be forwarded. Stack depth must be recalculated on a streaming
    device when the device transitions out of a Stop state. It may also be
    recalculated when an object is freed in order to conserve resources.

    For WDM Streaming devices this is called on a transition from Stop to Acquire
    state. Note that if this function is used, KsSetTargetState must also be used
    when transitioning into and out of a Stop state in order to enable and disable
    the target device for inclusion in the recalculation. KsRecalculateStackDepth
    may also be called when transitioning back to a Stop state in order to reduce
    stack depth, especially for cases wherein one or more instances of a filter
    based on the same device object appears in a single Irp stream.

Arguments:

    Header -
        Points to a header previously allocated by KsAllocateDeviceHeader.

    ReuseStackLocation -
        If this is set to TRUE, the current stack location is reused when any
        Irp is forwarded. This means that this object does not required its
        own stack location when forwarding Irp's, and an extra location is not
        added to the maximum stack size. If set to FALSE, the calculated
        stack size is incremented by one. If the Pnp object stack is set, the
        reuse parameter also applies to that stack. Note that KsDefaultDispatchPnp
        always reuses the current stack location. A minimum stack depth of 1
        is always ensured.

Return Value:

    Nothing.

--*/
{
    PKSIDEVICE_HEADER DeviceHeader;
    ULONG MaximumStackDepth;
    PLIST_ENTRY CurrentItem;

    PAGED_CODE();
    DeviceHeader = (PKSIDEVICE_HEADER)Header;
    ASSERT(DeviceHeader->BaseDevice && "KsSetDevicePnpAndBaseObject was not used on this header");
    //
    // If a PnP object stack has been specified, include that in the calculation.
    //
    if (DeviceHeader->PnpDeviceObject) {
        MaximumStackDepth = DeviceHeader->PnpDeviceObject->StackSize;
    } else {
        MaximumStackDepth = 0;
    }
    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe(&DeviceHeader->ObjectListLock);
    //
    // Enumerate the object in the list and calculate the maximum used depth.
    //
    for (CurrentItem = &DeviceHeader->ObjectList;
        CurrentItem->Flink != &DeviceHeader->ObjectList;
        CurrentItem = CurrentItem->Flink) {
        PKSIOBJECT_HEADER ObjectHeader;

        ObjectHeader = CONTAINING_RECORD(
            CurrentItem->Flink,
            KSIOBJECT_HEADER,
            ObjectList);
        //
        // To guard against ever-growing stack depth in the case of a single
        // device occuring multiple times in a single stream, a target can
        // be disabled when a pin transitions to a Stop state so that its
        // target is not counted in a recalculation. That pin should also
        // recalculate stack depth at that time to remove its extra stack
        // count from the total, although it is not necessary.
        //
        if (ObjectHeader->TargetState == KSTARGET_STATE_ENABLED) {
            if (ObjectHeader->TargetDevice) {
                if ((ULONG)ObjectHeader->TargetDevice->StackSize > MaximumStackDepth) {
                    MaximumStackDepth = ObjectHeader->TargetDevice->StackSize;
                }
            } else {
                if (ObjectHeader->MinimumStackDepth > MaximumStackDepth) {
                    MaximumStackDepth = ObjectHeader->MinimumStackDepth;
                }
            }
        }
    }
    //
    // This object may be reusing the stack locations, and not need it's
    // own extra location. However, if there were no device on the ObjectList,
    // and no PnP stack specified, then the minimum stack depth must be
    // ensured.
    //
    if (!ReuseStackLocation || !MaximumStackDepth) {
        MaximumStackDepth++;
    }
    DeviceHeader->BaseDevice->StackSize = (CCHAR)MaximumStackDepth;
    ExReleaseFastMutexUnsafe(&DeviceHeader->ObjectListLock);
    KeLeaveCriticalRegion();
}


KSDDKAPI
VOID
NTAPI
KsSetTargetState(
    IN KSOBJECT_HEADER Header,
    IN KSTARGET_STATE TargetState
    )
/*++

Routine Description:

    Sets the enabled state of a target device associated with the object header
    passed. Assumes that such a target has been set with KsSetTargetDeviceObject.
    The target is initially disabled, and is ignored when recalculating stack
    depth.

    For WDM Streaming devices this is called on a transition back to a Stop state,
    after having enabled the target and used KsRecalculateStackDepth on a transition
    to Acquire state. This allows the stack depth to be minimized.

Arguments:

    Header -
        Points to a header previously allocated by KsAllocateDeviceHeader.

    TargetState -
        Contains the new state of the target associated with this object header.
        This may be either KSTARGET_STATE_DISABLED or KSTARGET_STATE_ENABLED.

Return Value:

    Nothing.

--*/
{
    PKSIOBJECT_HEADER ObjectHeader;

    PAGED_CODE();
    ObjectHeader = (PKSIOBJECT_HEADER)Header;
    //
    // Not really worried too much about concurrent access.
    //
    ObjectHeader->TargetState = TargetState;
}


KSDDKAPI
VOID
NTAPI
KsSetTargetDeviceObject(
    IN KSOBJECT_HEADER Header,
    IN PDEVICE_OBJECT TargetDevice OPTIONAL
    )
/*++

Routine Description:

    Sets the target device object of an object. This has the effect of adding
    this object header to a list of object headers which have target devices.
    The head of this list is kept by a device header. Assumes that the caller
    has previously allocated a device header on the underlying Device Object
    with KsAllocateDeviceHeader.

    This allows future calls to KsRecalculateStackDepth, and is used when this
    object will be forwarding Irp's through a connection to another device,
    and needs to keep track of the deepest stack depth. Note that KsSetTargetState
    must be called to enable this target for any recalculation, as it is disabled
    by default.

    If KsSetDevicePnpAndBaseObject is also used to assign the PnP Object stack, that
    device object will also be taken into account when recalculating stack
    depth.

    This should only be used if the filter passes Irp's received on a
    Communication Sink pin through to a Communication Source pin without
    generating a new Irp. If the filter generates new Irp's for each Irp
    received, there is no need for it to keep track of stack depth, beyond
    that of the PDO it is attached to.

Arguments:

    Header -
        Points to a header previously allocated by KsAllocateObjectHeader.

    TargetDevice -
        Optionally contains the target device object which will be used when
        recalculating the stack depth for the underlying device object. If
        this is NULL, any current setting is removed. If not, any current
        setting is replaced.

Return Value:

    Nothing.

--*/
{
    PKSIOBJECT_HEADER ObjectHeader;
    PKSIDEVICE_HEADER DeviceHeader;

    PAGED_CODE();
    ObjectHeader = (PKSIOBJECT_HEADER)Header;
    DeviceHeader = *(PKSIDEVICE_HEADER*)ObjectHeader->BaseDevice->DeviceExtension;
    //
    // Lock the common list against manipulation by other object instances.
    //
    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe(&DeviceHeader->ObjectListLock);
    //
    // Remove the entry if it is currently set, and will now be unset. Else
    // just add the entry.
    //
    if (ObjectHeader->TargetDevice) {
        if (!TargetDevice) {
            RemoveEntryList(&ObjectHeader->ObjectList);
        }
    } else if (TargetDevice) {
        InsertTailList(&DeviceHeader->ObjectList, &ObjectHeader->ObjectList);
    }
    ObjectHeader->TargetDevice = TargetDevice;
    ExReleaseFastMutexUnsafe(&DeviceHeader->ObjectListLock);
    KeLeaveCriticalRegion();
}


KSDDKAPI
VOID
NTAPI
KsSetPowerDispatch(
    IN KSOBJECT_HEADER Header,
    IN PFNKSCONTEXT_DISPATCH PowerDispatch OPTIONAL,
    IN PVOID PowerContext OPTIONAL
    )
/*++

Routine Description:

    Sets the power dispatch function to be called when the driver object
    receives an IRP_MJ_POWER Irp. This is only effective if KsDefaultDispatchPower
    is called to dispatch or complete power Irps.

    This has the effect of adding this object header to a list of object headers
    which have power dispatch routines to execute. The head of this list is kept
    by a device header. Assumes that the caller has previously allocated a device
    header on the underlying Device Object with KsAllocateDeviceHeader.

Arguments:

    Header -
        Points to a header previously allocated by KsAllocateObjectHeader.

    PowerDispatch -
        Optionally contains the power dispatch function which will be called,
        or NULL if the function is to be removed from the list of functions
        being called. This function must not complete the power Irp sent. The
        return value of this function must be STATUS_SUCCESS. KsSetPowerDispatch
        may be called while executing this power dispatch routine if the
        purpose is to manipulate this list entry only. Manipulating other list
        entries may confuse the current enumeration.

    PowerContext -
        Optionally contains the context parameter to pass to the power dispatch
        function.

Return Value:

    Nothing.

--*/
{
    PKSIOBJECT_HEADER ObjectHeader;
    PKSIDEVICE_HEADER DeviceHeader;
    PETHREAD CurrentThread;
    KIRQL oldIrql;

    ASSERT((KeGetCurrentIrql() <= DISPATCH_LEVEL) && "Called at high Irql");
    ObjectHeader = (PKSIOBJECT_HEADER)Header;
    DeviceHeader = *(PKSIDEVICE_HEADER*)ObjectHeader->BaseDevice->DeviceExtension;
    ASSERT(DeviceHeader->BaseDevice && "KsSetDevicePnpAndBaseObject was not used on this header");
    CurrentThread = PsGetCurrentThread();
    //
    // If the current thread is enumerating callbacks through
    // KsDefaultDispatchPower, then do not attempt to acquire
    // the list lock, as it has already been acquired by this
    // thread. Instead just allow it to manipulate the list.
    // The assumption is that it is only manipulating the current
    // entry being enumerated, and not some other entry (like
    // the next entry, which would confuse enumeration).
    //
    if (DeviceHeader->PowerEnumThread != CurrentThread) {
        //
        // Lock the common list against manipulation by other object instances.
        // Depending on the pagable flag, take a spinlock, or just
        // a mutex.
        //
        if (DeviceHeader->BaseDevice->Flags & DO_POWER_PAGABLE) {
            ASSERT((KeGetCurrentIrql() == PASSIVE_LEVEL) && "Pagable power called at Dispatch level");
            KeEnterCriticalRegion();
            ExAcquireFastMutexUnsafe(&DeviceHeader->LoPowerListLock);
        } else {
            KeAcquireSpinLock(&DeviceHeader->HiPowerListLock, &oldIrql);
        }
    }
    //
    // Remove the entry if it is currently set, and will now be unset. Else
    // just add the entry.
    //
    if (ObjectHeader->PowerDispatch) {
        if (!PowerDispatch) {
            RemoveEntryList(&ObjectHeader->PowerList);
        }
    } else if (PowerDispatch) {
        InsertTailList(&DeviceHeader->PowerList, &ObjectHeader->PowerList);
    }
    ObjectHeader->PowerDispatch = PowerDispatch;
    ObjectHeader->PowerContext = PowerContext;
    //
    // Only release the lock if it was acquired.
    //
    if (DeviceHeader->PowerEnumThread != CurrentThread) {
        //
        // Release the lock as it was taken.
        //
        if (DeviceHeader->BaseDevice->Flags & DO_POWER_PAGABLE) {
            ExReleaseFastMutexUnsafe(&DeviceHeader->LoPowerListLock);
            KeLeaveCriticalRegion();
        } else {
            KeReleaseSpinLock(&DeviceHeader->HiPowerListLock, oldIrql);
        }
    }
}


KSDDKAPI
PKSOBJECT_CREATE_ITEM
NTAPI
KsQueryObjectCreateItem(
    IN KSOBJECT_HEADER Header
    )
/*++

Routine Description:

    Returns the create item assigned to this object on creation. If the device
    object allows dynamic deletion of create items, then the pointer returned
    may no longer be valid.

Arguments:

    Header -
        Points to a header previously allocated by KsAllocateObjectHeader
        whose create item is returned.

Return Value:

    Returns a pointer to a create item

--*/
{
    PAGED_CODE();
    return ((PKSIOBJECT_HEADER)Header)->CreateItem;
}


KSDDKAPI
NTSTATUS
NTAPI
KsAllocateObjectHeader(
    OUT KSOBJECT_HEADER* Header,
    IN ULONG ItemsCount,
    IN PKSOBJECT_CREATE_ITEM ItemsList OPTIONAL,
    IN PIRP Irp,
    IN const KSDISPATCH_TABLE* Table
    )
/*++

Routine Description:

    Initialize the required file context header.

Arguments:

    Header -
        Points to the place in which to return a pointer to the initialized
        header.

    ItemsCount -
        Number of child create items in the ItemsList. This should be zero
        if an ItemsList is not passed.

    ItemsList -
        List of child create items, or NULL if there are none.

    Irp -
        Contains the Create Irp, from which the create item and object access
        is extracted.

    Table -
        Points to the dispatch table for this object.

Return Value:

    Returns STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES.

--*/

{
    PKSIOBJECT_HEADER ObjectHeader;
    PIO_STACK_LOCATION IrpStack;

    PAGED_CODE();
    ObjectHeader = ExAllocatePoolWithTag(
        NonPagedPool,
        sizeof(*ObjectHeader),
        KSSIGNATURE_OBJECT_HEADER);
    if (!ObjectHeader) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    //
    // The Self pointer is used by the shell so it doesn't need a separate
    // FsContext in addition to the object header.  The shell is responsible
    // for setting this pointer to point to the object header.  We set it to
    // NULL here because that provides an easy way to determine if a filter is
    // shell-based in the debugger.
    //
    ObjectHeader->Self = NULL;
    ObjectHeader->DispatchTable = Table;
    InitializeListHead(&ObjectHeader->ChildCreateHandlerList);
    //
    // Keep a list of pointers to the create items so that they can
    // be added to without needing to reserve slots in a fixed list.
    //
    for (; ItemsCount--;) {
        PKSICREATE_ENTRY Entry;

        Entry = ExAllocatePoolWithTag(PagedPool, sizeof(*Entry), KSSIGNATURE_CREATE_ENTRY);
        if (!Entry) {
            FreeCreateEntries(&ObjectHeader->ChildCreateHandlerList);
            ExFreePool(ObjectHeader);
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        Entry->CreateItem = &ItemsList[ItemsCount];
        Entry->ItemFreeCallback = NULL;
        Entry->RefCount = 1;
        Entry->Flags = 0;
        InsertHeadList(&ObjectHeader->ChildCreateHandlerList, &Entry->ListEntry);
    }
    ObjectHeader->CreateItem = KSCREATE_ITEM_IRP_STORAGE(Irp);
    IrpStack = IoGetCurrentIrpStackLocation(Irp);
#ifdef WIN9X_KS
    ObjectHeader->ObjectAccess = FILE_ALL_ACCESS;
#else // !WIN9X_KS
    ObjectHeader->ObjectAccess = IrpStack->Parameters.Create.SecurityContext->AccessState->PreviouslyGrantedAccess;
#endif // !WIN9X_KS
    ObjectHeader->BaseDevice = IrpStack->DeviceObject;
    ObjectHeader->TargetDevice = NULL;
    ObjectHeader->PowerDispatch = NULL;
    ObjectHeader->TargetState = KSTARGET_STATE_DISABLED;
    ObjectHeader->Object = NULL;
    *Header = ObjectHeader;
    return STATUS_SUCCESS;
}


KSDDKAPI
VOID
NTAPI
KsFreeObjectHeader(
    IN KSOBJECT_HEADER Header
    )
/*++

Routine Description:

    Cleans up and frees a previously allocated object header.

Arguments:

    Header -
        Points to the object header to free.

Return Value:

    Nothing.

--*/
{
    PKSIOBJECT_HEADER ObjectHeader;
    PKSIDEVICE_HEADER DeviceHeader;

    ASSERT((KeGetCurrentIrql() == PASSIVE_LEVEL) && "Driver did not call at Passive level");
    ObjectHeader = (PKSIOBJECT_HEADER)Header;
    //
    // Destroy the list of create item entries.
    //
    FreeCreateEntries(&ObjectHeader->ChildCreateHandlerList);
    DeviceHeader = *(PKSIDEVICE_HEADER*)ObjectHeader->BaseDevice->DeviceExtension;
    //
    // This item may have been added to the object list stack depth calculations,
    // or the power forwarding list. Presumably this element is not concurrently
    // being accessed elsewhere.
    //
    if (ObjectHeader->TargetDevice) {
        KeEnterCriticalRegion();
        ExAcquireFastMutexUnsafe(&DeviceHeader->ObjectListLock);
        RemoveEntryList(&ObjectHeader->ObjectList);
        ExReleaseFastMutexUnsafe(&DeviceHeader->ObjectListLock);
        KeLeaveCriticalRegion();
    }
    if (ObjectHeader->PowerDispatch) {
        if (DeviceHeader->BaseDevice->Flags & DO_POWER_PAGABLE) {
            KeEnterCriticalRegion();
            ExAcquireFastMutexUnsafe(&DeviceHeader->LoPowerListLock);
            RemoveEntryList(&ObjectHeader->PowerList);
            ExReleaseFastMutexUnsafe(&DeviceHeader->LoPowerListLock);
            KeLeaveCriticalRegion();
        } else {
            KIRQL   oldIrql;

            KeAcquireSpinLock(&DeviceHeader->HiPowerListLock, &oldIrql);
            RemoveEntryList(&ObjectHeader->PowerList);
            KeReleaseSpinLock(&DeviceHeader->HiPowerListLock, oldIrql);
        }
    }
    ExFreePool(Header);
}


KSDDKAPI
NTSTATUS
NTAPI
KsAllocateObjectCreateItem(
    IN KSDEVICE_HEADER Header,
    IN PKSOBJECT_CREATE_ITEM CreateItem,
    IN BOOLEAN AllocateEntry,
    IN PFNKSITEMFREECALLBACK ItemFreeCallback OPTIONAL
    )
/*++

Routine Description:

    Allocates a slot for the specified create item, optionally allocating space
    for and copying the create item data as well. This function does not assume
    that the caller is serializing multiple changes to the create entry list.

Arguments:

    Header -
        Points to the device header on which to attach the create item.

    CreateItem -
        Contains the create item to attach.

    AllocateEntry -
        Indicates whether the create item pointer passed should be attached
        directly to the header, or if a copy of it should be made instead.

    ItemFreeCallback -
        Optionally contains a pointer to a callback function which is called
        when the create entry is being destroyed upon freeing the device
        header. This is only valid when AllocateEntry is TRUE.

Return Value:

    Returns STATUS_SUCCESS if a new item was allocated and attached, else
    STATUS_INSUFFICIENT_RESOURCES.

--*/
{
    PKSIDEVICE_HEADER DeviceHeader;
    PKSICREATE_ENTRY Entry;

    DeviceHeader = (PKSIDEVICE_HEADER)Header;
    if (AllocateEntry) {
        Entry = ExAllocatePoolWithTag(PagedPool, sizeof(*Entry) + sizeof(*CreateItem) + CreateItem->ObjectClass.Length, KSSIGNATURE_CREATE_ENTRY);
    } else {
        Entry = ExAllocatePoolWithTag(PagedPool, sizeof(*Entry), KSSIGNATURE_CREATE_ENTRY);
    }
    if (!Entry) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    //
    // If the item should be copied, do so.
    //
    if (AllocateEntry) {
        PKSOBJECT_CREATE_ITEM LocalCreateItem;

        LocalCreateItem = (PKSOBJECT_CREATE_ITEM)(Entry + 1);
        *LocalCreateItem = *CreateItem;
        LocalCreateItem->ObjectClass.Buffer = (PWCHAR)(LocalCreateItem + 1);
        LocalCreateItem->ObjectClass.MaximumLength = CreateItem->ObjectClass.Length;
        RtlCopyUnicodeString(&LocalCreateItem->ObjectClass, &CreateItem->ObjectClass);
        Entry->CreateItem = LocalCreateItem;
        Entry->ItemFreeCallback = ItemFreeCallback;
        //
        // Indicate that the entry was copied.
        //
        Entry->Flags = CREATE_ENTRY_FLAG_COPIED;
    } else {
        ASSERT(!ItemFreeCallback && "The callback parameter should be NULL, since it is not used in this case");
        Entry->CreateItem = CreateItem;
        Entry->ItemFreeCallback = NULL;
        Entry->Flags = 0;
    }
    //
    // Initialize this to one so that it can be decremented to zero if it is
    // ever deleted before the object header is freed.
    //
    Entry->RefCount = 1;
    //
    // This works fine even if Create's are being processed, since
    // the entry is updated before being added, and the Blink is
    // never used. However, it must be synchronized with deletions
    // which may occur on the return from calling a create item entry
    // point.
    //
    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe(&DeviceHeader->CreateListLock);
    InsertTailList(&DeviceHeader->ChildCreateHandlerList, &Entry->ListEntry);
    ExReleaseFastMutexUnsafe(&DeviceHeader->CreateListLock);
    KeLeaveCriticalRegion();
    return STATUS_SUCCESS;
}


NTSTATUS
KsiFreeMatchingObjectCreateItems(
    IN KSDEVICE_HEADER Header,
    IN PKSOBJECT_CREATE_ITEM Match
    )
/*++

Routine Description:

    Frees the slots for the specified create items based on non-zero
    fields in a 'pattern' create item.  This function does not assume
    that the caller is serializing multiple changes to the create entry
    list.

Arguments:

    Header -
        Points to the device header on which the create items are attached.

    Match -
        Contains the create item that is compared to create items in the
        device header's list to determine if they should be freed.  A create
        item is freed if all of the non-NULL pointers in this argument are 
        equal to corresponding pointers in the create item, and if any of the
        flags set in this argument are also set in the create item.

    Flags -
        Contains the flags of the create items to free.  All create items with
        any of these flags will be freed.

Return Value:

    Returns STATUS_SUCCESS if an item was freed, else STATUS_OBJECT_NAME_NOT_FOUND.

--*/
{
    PKSIDEVICE_HEADER DeviceHeader;
    PLIST_ENTRY ListEntry;
    PKSICREATE_ENTRY Entry;
    LIST_ENTRY CreateList;

    //
    // Initialize a list in which to collect create items to be freed.  This
    // list will be passed to FreeCreateEntries for bulk disposal.
    //
    InitializeListHead(&CreateList);

    DeviceHeader = (PKSIDEVICE_HEADER)Header;
    //
    // Synchronize with other accesses to this list. This will stop not only
    // other deletions, but also create item lookups during a create request.
    //
    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe(&DeviceHeader->CreateListLock);
    for (ListEntry = DeviceHeader->ChildCreateHandlerList.Flink; ListEntry != &DeviceHeader->ChildCreateHandlerList;) {
        //
        // Save a pointer to the next entry in order to tolerate removals.
        //
        PLIST_ENTRY NextListEntry = ListEntry->Flink;

        Entry = CONTAINING_RECORD(ListEntry, KSICREATE_ENTRY, ListEntry);
        //
        // If the create item was already deleted, but just not freed yet,
        // then ignore it, allowing for duplicate names from multiple adds
        // and deletes.
        //
        if (((Entry->Flags & CREATE_ENTRY_FLAG_DELETED) == 0) &&
            ((! Match->Create) || (Match->Create == Entry->CreateItem->Create)) &&
            ((! Match->Context) || (Match->Context == Entry->CreateItem->Context)) &&
            ((! Match->ObjectClass.Buffer) || !RtlCompareUnicodeString(&Entry->CreateItem->ObjectClass, &Match->ObjectClass, FALSE)) &&
            ((! Match->SecurityDescriptor) || (Match->Context == Entry->CreateItem->SecurityDescriptor)) &&
            ((! Match->Flags) || (Match->Flags & Entry->CreateItem->Flags))) {
            //
            // Mark the item as deleted so that no future searches will find it.
            // Since the mutex has been acquired, no searches can be occuring.
            // This avoids the possibility of two create requests trying to free
            // the same deleted create item.
            //
            Entry->Flags |= CREATE_ENTRY_FLAG_DELETED;
            //
            // Found the item. Decrement the previously applied reference count,
            // and determine if it is now zero, meaning that it has been deleted.
            //
            if (!InterlockedDecrement(&Entry->RefCount)) {
                //
                // The item has no reference counts, therefore no other create
                // request is being synchronously processed on it (asynchronous
                // create requests must retrieve relevant information before
                // returning from their create handler). Removing it from the
                // list means it is no longer available.
                //
                RemoveEntryList(&Entry->ListEntry);
                //
                // Put the create item on the garbage list so that the common
                // FreeCreateEntries function can be used later.
                //
                InsertHeadList(&CreateList, &Entry->ListEntry);
            }
        }
        ListEntry = NextListEntry;
    }
    ExReleaseFastMutexUnsafe(&DeviceHeader->CreateListLock);
    KeLeaveCriticalRegion();

    //
    // Free any create items we have collected.
    //
    if (! IsListEmpty(&CreateList)) {
        FreeCreateEntries(&CreateList);
        return STATUS_SUCCESS;
    }

    return STATUS_OBJECT_NAME_NOT_FOUND;
}


KSDDKAPI
NTSTATUS
NTAPI
KsFreeObjectCreateItem(
    IN KSDEVICE_HEADER Header,
    IN PUNICODE_STRING CreateItem
    )
/*++

Routine Description:

    Frees the slot for the specified create item. This function does not assume
    that the caller is serializing multiple changes to the create entry list.

Arguments:

    Header -
        Points to the device header on which the create item is attached.

    CreateItem -
        Contains the name of the create item to free.

Return Value:

    Returns STATUS_SUCCESS if the item was freed, else STATUS_OBJECT_NAME_NOT_FOUND.

--*/
{
    KSOBJECT_CREATE_ITEM match;
    RtlZeroMemory(&match,sizeof(match));
    match.ObjectClass = *CreateItem;
    return KsiFreeMatchingObjectCreateItems(Header,&match);
}


KSDDKAPI
NTSTATUS
NTAPI
KsFreeObjectCreateItemsByContext(
    IN KSDEVICE_HEADER Header,
    IN PVOID Context
    )
/*++

Routine Description:

    Frees the slots for the specified create items based on context. This
    function does not assume that the caller is serializing multiple 
    changes to the create entry list.

Arguments:

    Header -
        Points to the device header on which the create items are attached.

    Context -
        Contains the context of the create items to free.  All create items
        with this context value will be freed.

Return Value:

    Returns STATUS_SUCCESS if an item was freed, else STATUS_OBJECT_NAME_NOT_FOUND.

--*/
{
    KSOBJECT_CREATE_ITEM match;
    RtlZeroMemory(&match,sizeof(match));
    match.Context = Context;
    return KsiFreeMatchingObjectCreateItems(Header,&match);
}


KSDDKAPI
BOOLEAN
NTAPI
KsiQueryObjectCreateItemsPresent(
    IN KSDEVICE_HEADER Header
    )
/*++

Routine Description:

    Returns whether or not create items have been attached to this device
    header. This allows KPort to determine whether a Start Device has been
    sent to a particular mini-port in the past, which would have previously
    bound the ports to the mini-port.

Arguments:

    Header -
        Points to the device header on which to search for create items.

Return Value:

    Returns TRUE if any Create Items are attached to this device header, else
    FALSE.

--*/
{
    return !IsListEmpty(&((PKSIDEVICE_HEADER)Header)->ChildCreateHandlerList);
}


NTSTATUS
KsiAddObjectCreateItem(
    IN PLIST_ENTRY ChildCreateHandlerList,
    IN PDRIVER_DISPATCH Create,
    IN PVOID Context,
    IN PWCHAR ObjectClass,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor OPTIONAL
    )
/*++

Routine Description:

    Adds the specified create item to an empty item in the previously allocated
    create entry list. An empty item is signified by a NULL create dispatch
    function in the entry. This function assumes that the caller is serializing
    multiple changes to the create entry list.

Arguments:

    ChildCreateHandlerList -
        Points to the list of create entries.

    Create -
        Contains the create dispatch function to use.

    Context -
        Contains the context parameter to use.

    ObjectClass -
        Contains a pointer to a NULL-terminated character string which will
        be used for comparison on create requests. This pointer must remain
        valid while the object is active.

    SecurityDescriptor -
        Contains the security descriptor to use. This must remain valid while
        the object is active.

Return Value:

    Returns STATUS_SUCCESS if an empty create item slot was found, and the
    item was added, else STATUS_ALLOTTED_SPACE_EXCEEDED.

--*/
{
    PLIST_ENTRY ListEntry;

    //
    // Enumerate the list of create entries attached to this header,
    // looking for an empty entry.
    //
    for (ListEntry = ChildCreateHandlerList->Flink; ListEntry != ChildCreateHandlerList; ListEntry = ListEntry->Flink) {
        PKSICREATE_ENTRY Entry;

        Entry = CONTAINING_RECORD(ListEntry, KSICREATE_ENTRY, ListEntry);
        if (!Entry->CreateItem->Create) {
            Entry->CreateItem->Context = Context;
            Entry->CreateItem->SecurityDescriptor = SecurityDescriptor;
            Entry->CreateItem->Flags = 0;
            Entry->RefCount = 1;
            Entry->Flags = 0;
            RtlInitUnicodeString(&Entry->CreateItem->ObjectClass, ObjectClass);
            //
            // Do this last to make sure the entry is not used prematurely.
            //
            InterlockedExchangePointer((PVOID*)&Entry->CreateItem->Create, (PVOID)Create);
            return STATUS_SUCCESS;
        }
    }
    return STATUS_ALLOTTED_SPACE_EXCEEDED;
}


KSDDKAPI
NTSTATUS
NTAPI
KsAddObjectCreateItemToDeviceHeader(
    IN KSDEVICE_HEADER Header,
    IN PDRIVER_DISPATCH Create,
    IN PVOID Context,
    IN PWCHAR ObjectClass,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor OPTIONAL
    )
/*++

Routine Description:

    Adds the specified create item to an empty item in the previously allocated
    create item list for this device header. An empty item is signified by a
    NULL create dispatch function in the entry. This function assumes that the
    caller is serializing multiple changes to the create items list.

Arguments:

    Header -
        Points to the device header which contains the previously allocated
        child create table.

    Create -
        Contains the create dispatch function to use.

    Context -
        Contains the context parameter to use.

    ObjectClass -
        Contains a pointer to a NULL-terminated character string which will
        be used for comparison on create requests. This pointer must remain
        valid while the device object is active.

    SecurityDescriptor -
        Contains the security descriptor to use. This must remain valid while
        the device object is active.

Return Value:

    Returns STATUS_SUCCESS if an empty create item slot was found, and the
    item was added, else STATUS_ALLOTTED_SPACE_EXCEEDED.

--*/
{
    PAGED_CODE();
    return KsiAddObjectCreateItem(
        &((PKSIDEVICE_HEADER)Header)->ChildCreateHandlerList,
        Create,
        Context,
        ObjectClass,
        SecurityDescriptor);
}


KSDDKAPI
NTSTATUS
NTAPI
KsAddObjectCreateItemToObjectHeader(
    IN KSOBJECT_HEADER Header,
    IN PDRIVER_DISPATCH Create,
    IN PVOID Context,
    IN PWCHAR ObjectClass,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor OPTIONAL
    )
/*++

Routine Description:

    Adds the specified create item to an empty item in the previously allocated
    create item list for this object header. An empty item is signified by a
    NULL create dispatch function in the entry. This function assumes that the
    caller is serializing multiple changes to the create items list.

Arguments:

    Header -
        Points to the object header which contains the previously allocated
        child create table.

    Create -
        Contains the create dispatch function to use.

    Context -
        Contains the context parameter to use.

    ObjectClass -
        Contains a pointer to a NULL-terminated character string which will
        be used for comparison on create requests. This pointer must remain
        valid while the object is active.

    SecurityDescriptor -
        Contains the security descriptor to use. This must remain valid while
        the object is active.

Return Value:

    Returns STATUS_SUCCESS if an empty create item slot was found, and the
    item was added, else STATUS_ALLOTTED_SPACE_EXCEEDED.

--*/
{
    PAGED_CODE();
    return KsiAddObjectCreateItem(
        &((PKSIOBJECT_HEADER)Header)->ChildCreateHandlerList,
        Create,
        Context,
        ObjectClass,
        SecurityDescriptor);
}


NTSTATUS
KsiCreateObjectType(
    IN HANDLE ParentHandle,
    IN PWCHAR RequestType,
    IN PVOID CreateParameter,
    IN ULONG CreateParameterLength,
    IN ACCESS_MASK DesiredAccess,
    OUT PHANDLE ObjectHandle
    )
/*++

Routine Description:

    Uses IoCreateFile to create a handle relative to the ParentHandle specified.
    This is a handle to a sub-object such as a Pin, Clock, or Allocator.
    Passes the parameters as the file system-specific data.

Arguments:

    ParentHandle -
        Contains the handle of the parent used in initializing the object
        attributes passed to IoCreateFile. This is normally a handle to a
        filter or pin.

    RequestType -
        Contains the type of sub-object to create. This is the standard string
        representing the various object types.
    
    CreateParameter -
        Contains the request-specific data to pass to IoCreateFile. This
        must be a system address.

    CreateParameterLength -
        Contains the length of the create parameter passed.

    DesiredAccess -
        Specifies the desired access to the object. This is normally GENERIC_READ
        and/or GENERIC_WRITE.

    ObjectHandle -
        Place in which to put the sub-object handle.

Return Value:

    Returns any IoCreateFile error.

--*/
{
    ULONG NameLength;
    PWCHAR FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING FileNameString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS Status;

    //
    // Build a structure consisting of:
    //     "<request type>\<params>"
    // The <params> is a binary structure which is extracted on the other end.
    //
    NameLength = wcslen(RequestType);
    FileName = ExAllocatePoolWithTag(
        PagedPool,
        NameLength * sizeof(*FileName) + sizeof(OBJ_NAME_PATH_SEPARATOR) + CreateParameterLength,
        KSSIGNATURE_OBJECT_PARAMETERS);
    if (!FileName) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    wcscpy(FileName, RequestType);
    FileName[NameLength] = OBJ_NAME_PATH_SEPARATOR;
    RtlCopyMemory(&FileName[NameLength + 1], CreateParameter, CreateParameterLength);
    FileNameString.Buffer = FileName;
    FileNameString.Length = (USHORT)(NameLength * sizeof(*FileName) + sizeof(OBJ_NAME_PATH_SEPARATOR) + CreateParameterLength);
    FileNameString.MaximumLength = FileNameString.Length;
    //
    // MANBUGS 38462:
    //
    // WinME SysAudio uses global handles...  downlevel distribution onto
    // WinME requires this support.  Win2K will also be kept consistent
    // with Whistler.
    //
    #if defined(WIN9X_KS) && !defined(WINME)
        InitializeObjectAttributes(
            &ObjectAttributes,
            &FileNameString,
            OBJ_CASE_INSENSITIVE,
            ParentHandle,
            NULL);
        Status = IoCreateFile(
            ObjectHandle,
            DesiredAccess,
            &ObjectAttributes,
            &IoStatusBlock,
            NULL,
            0,
            0,
            FILE_OPEN,
            0,
            NULL,
            0,
            CreateFileTypeNone,
            NULL,
            IO_FORCE_ACCESS_CHECK | IO_NO_PARAMETER_CHECKING);
    #else // WIN9X_KS && !WINME
        InitializeObjectAttributes(
            &ObjectAttributes,
            &FileNameString,
            OBJ_CASE_INSENSITIVE | (DesiredAccess & OBJ_KERNEL_HANDLE),
            ParentHandle,
            NULL);
        Status = IoCreateFile(
            ObjectHandle,
            (DesiredAccess & ~OBJ_KERNEL_HANDLE),
            &ObjectAttributes,
            &IoStatusBlock,
            NULL,
            0,
            0,
            FILE_OPEN,
            0,
            NULL,
            0,
            CreateFileTypeNone,
            NULL,
            IO_FORCE_ACCESS_CHECK | IO_NO_PARAMETER_CHECKING);
    #endif // WIN9XKS && !WINME

    ExFreePool(FileName);
    return Status;
}


NTSTATUS
KsiCopyCreateParameter(
    IN PIRP Irp,
    IN OUT PULONG CapturedSize,
    OUT PVOID* CapturedParameter
    )
/*++

Routine Description:

    Copies the specified create parameter to the Irp->AssociatedIrp.SystemBuffer
    buffer so that it will be LONGLONG aligned. Determine if the parameter has
    already been captured before capturing again.

Arguments:

    Irp -
        Contains create Irp.

    CapturedSize -
        On entry specifies the minimum size of the create parameter to copy.
        Returns the actual number of bytes copied.

    CapturedParameter -
        The place in which to put a pointer to the captured create parameter.
        This is automatically freed when the Irp is completed.

Return Value:

    Returns any allocation or access error.

--*/
{
    PIO_STACK_LOCATION IrpStack;
    PKSOBJECT_CREATE_ITEM CreateItem;
    PWCHAR FileNameBuffer;
    ULONG FileNameLength;

    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    //
    // There may be an initial path separator if this was not a child object,
    // so skip by any separator. The separator could not be there if it was
    // a child object.
    //
    // Since a child object can not both have a null name and pass parameters,
    // then this function could not be used to copy parameters.
    //
    FileNameBuffer = IrpStack->FileObject->FileName.Buffer;
    FileNameLength = IrpStack->FileObject->FileName.Length;
    if ((FileNameLength >= sizeof(OBJ_NAME_PATH_SEPARATOR)) &&
        (FileNameBuffer[0] == OBJ_NAME_PATH_SEPARATOR)) {
        FileNameBuffer++;
        FileNameLength -= sizeof(OBJ_NAME_PATH_SEPARATOR);
    }
    CreateItem = KSCREATE_ITEM_IRP_STORAGE(Irp);
    //
    // Ensure that the length is at least large enough for what the caller
    // requested. This is checked even if the parameter had already been
    // copied in case a second caller indicates a different size.
    //
    if (FileNameLength < CreateItem->ObjectClass.Length + sizeof(OBJ_NAME_PATH_SEPARATOR) + *CapturedSize) {
        return STATUS_INVALID_BUFFER_SIZE;
    }
    *CapturedSize = FileNameLength - (CreateItem->ObjectClass.Length + sizeof(OBJ_NAME_PATH_SEPARATOR));
    ASSERT(*CapturedSize && "Invalid use of KsiCopyCreateParameter");
    //
    // The IRP_BUFFERED_IO flag is set after the parameter has been copied
    // the first time KsiCopyCreateParameter is called. So if it is set, then
    // no more work needs to be done.
    //
    if (!(Irp->Flags & IRP_BUFFERED_IO)) {
        if (IrpStack->Parameters.Create.EaLength) {
            //
            // Since the SystemBuffer is used to store create parameters, then
            // it better not already be used for extended attributes.
            //
            return STATUS_EAS_NOT_SUPPORTED;
        }
        ASSERT(!Irp->AssociatedIrp.SystemBuffer && "Something is using the SystemBuffer in IRP_MJ_CREATE.");
        //
        // Move to the actual parameter at the end of the name.
        //
        (PUCHAR)FileNameBuffer += (CreateItem->ObjectClass.Length + sizeof(OBJ_NAME_PATH_SEPARATOR));
        //
        // This buffered copy is automatically freed on Irp completion.
        //
        Irp->AssociatedIrp.SystemBuffer = ExAllocatePoolWithTag(
            NonPagedPool,
            *CapturedSize,
            KSSIGNATURE_AUX_CREATE_PARAMETERS);
        if (!Irp->AssociatedIrp.SystemBuffer) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        //
        // Setting the IRP_BUFFERED_IO flag also indicates to this function
        // that the create parameter has already been buffered.
        //
        Irp->Flags |= (IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER);
        RtlCopyMemory(Irp->AssociatedIrp.SystemBuffer, FileNameBuffer, *CapturedSize);
    }
    //
    // Return a pointer to the buffered parameter.
    //
    *CapturedParameter = Irp->AssociatedIrp.SystemBuffer;
    return STATUS_SUCCESS;
}


NTSTATUS
ValidateCreateAccess(
    IN PIRP Irp,
    IN PKSOBJECT_CREATE_ITEM CreateItem
    )
/*++

Routine Description:

    Validates the access to the object described by the CreateItem. If there is
    no security, or the caller is trusted, or the sub-object name is null and
    therefore security was checked in the I/O system, the check is bypassed.

Arguments:

    Irp -
        Contains create Irp. This is used to access the underlying device object
        and possibly the security descriptor associated with that device object.

    CreateItem -
        Contains the create item with the optional security descriptor.
    
Return Value:

    Returns the access check status.

--*/
{
#ifndef WIN9X_KS
    PIO_STACK_LOCATION IrpStack;
    PKSIDEVICE_HEADER DeviceHeader;
    NTSTATUS Status;

    //
    // Only perform an access check if this client is not trusted. Since the
    // client is trusted, the granted access will not be used later.
    //
    if (ExGetPreviousMode() == KernelMode) {
        return STATUS_SUCCESS;
    }
    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    //
    // Acquire the security descriptor resource to stop any changes. In order
    // to use the create dispatch methods, the first element in the Device
    // Extension must be a pointer to a KSIDEVICE_HEADER allocated and initialized
    // with KsAllocateDeviceHeader.
    //
    DeviceHeader = *(PKSIDEVICE_HEADER*)IrpStack->DeviceObject->DeviceExtension;
    KeEnterCriticalRegion();
    ExAcquireResourceSharedLite(&DeviceHeader->SecurityDescriptorResource, TRUE);
    //
    // Only check security if the object actually uses security, and security
    // has not already been checked by the I/O system because of a null class
    // name being passed.
    //
    if (CreateItem->SecurityDescriptor && CreateItem->ObjectClass.Length) {
        PIO_SECURITY_CONTEXT SecurityContext;
        BOOLEAN accessGranted;
        ACCESS_MASK grantedAccess;
        PPRIVILEGE_SET privileges;
        UNICODE_STRING nameString;

        SecurityContext = IrpStack->Parameters.Create.SecurityContext;
        privileges = NULL;
        //
        // Lock the subject context once here.
        //
        SeLockSubjectContext(&SecurityContext->AccessState->SubjectSecurityContext);
        accessGranted = SeAccessCheck(CreateItem->SecurityDescriptor,
            &SecurityContext->AccessState->SubjectSecurityContext,
            TRUE,
            SecurityContext->DesiredAccess,
            0,
            &privileges,
            IoGetFileObjectGenericMapping(),
            UserMode,
            &grantedAccess,
            &Status);
        if (privileges) {
            SeAppendPrivileges(SecurityContext->AccessState, privileges);
            SeFreePrivileges(privileges);
        }
        if (accessGranted) {
            SecurityContext->AccessState->PreviouslyGrantedAccess |= grantedAccess;
            SecurityContext->AccessState->RemainingDesiredAccess &= ~(grantedAccess | MAXIMUM_ALLOWED);
        }
        //
        // Use a hardcoded constant "File" for the object type name. If
        // the object has no name, just use the same constant.
        //
        RtlInitUnicodeString(&nameString, ObjectTypeName);
        SeOpenObjectAuditAlarm(&nameString,
            IrpStack->DeviceObject,
            CreateItem->ObjectClass.Length ? &CreateItem->ObjectClass : &nameString,
            CreateItem->SecurityDescriptor,
            SecurityContext->AccessState,
            FALSE,
            accessGranted,
            UserMode,
            &SecurityContext->AccessState->GenerateOnClose);
        //
        // Unlock the previously locked subject context.
        //
        SeUnlockSubjectContext(&SecurityContext->AccessState->SubjectSecurityContext);
    } else {
        PIO_SECURITY_CONTEXT    SecurityContext;

        //
        // This object does not have any security, or it has already been
        // check by the I/O system for a null named sub-device, so succeed.
        // The granted access may be retrieved later, so it must be
        // updated with the desired access.
        //
        SecurityContext = IrpStack->Parameters.Create.SecurityContext;
        RtlMapGenericMask(&SecurityContext->DesiredAccess, IoGetFileObjectGenericMapping());
        SecurityContext->AccessState->PreviouslyGrantedAccess |= SecurityContext->DesiredAccess;
        SecurityContext->AccessState->RemainingDesiredAccess &= ~(SecurityContext->DesiredAccess | MAXIMUM_ALLOWED);
        Status = STATUS_SUCCESS;
    }
    //
    // Allow change access to the security descriptor.
    //
    ExReleaseResourceLite(&DeviceHeader->SecurityDescriptorResource);
    KeLeaveCriticalRegion();
    return Status;
#else // WIN9X_KS
    return STATUS_SUCCESS;
#endif // WIN9X_KS
}


PKSICREATE_ENTRY
FindAndReferenceCreateItem(
    IN PWCHAR Buffer,
    IN ULONG Length,
    IN PLIST_ENTRY ChildCreateHandlerList
    )
/*++

Routine Description:

    Given a file name, and a list of create items, returns the matching create item.
    It also increments the reference count on any create item returned. It is assumed
    that the CreateListLock has been acquired before calling this function.

Arguments:

    Buffer -
        The file name to match against the object item list.

    Length -
        The length of the file name. This may be zero, in which case
        the Buffer parameter is invalid.

    ChildCreateHandlerList -
        The create entry list to search.
    
Return Value:

    Returns the create entry found containing the create item, or NULL if no match
    was found.

--*/
{
    PLIST_ENTRY ListEntry;
    PKSICREATE_ENTRY WildCardItem;

    WildCardItem = NULL;
    //
    // Enumerate the list to try and match a string with the request.
    //
    for (ListEntry = ChildCreateHandlerList->Flink; ListEntry != ChildCreateHandlerList; ListEntry = ListEntry->Flink) {
        PKSICREATE_ENTRY    Entry;

        Entry = CONTAINING_RECORD(ListEntry, KSICREATE_ENTRY, ListEntry);
        //
        // In order to allow lists with empty slots, the Create function callback
        // is used to determine if the entry is currently valid. An item which is
        // being disabled must first NULL out this entry before removing any other
        // assumptions about the object. It is assumed that reading a PVOID value
        // can be done without interlocking.
        //
        if (Entry->CreateItem->Create) {
            //
            // A wildcard entry will always match. Save this in case a match is
            // not found. The wildcard item may have a name for purposes of
            // dynamic removal.
            //
            if (Entry->CreateItem->Flags & KSCREATE_ITEM_WILDCARD) {
                WildCardItem = Entry;
            } else {
                PWCHAR ItemBuffer;
                ULONG ItemLength;

                ItemBuffer = Entry->CreateItem->ObjectClass.Buffer;
                ItemLength = Entry->CreateItem->ObjectClass.Length;
                //
                // Try to match the sub-object name with the current entry being
                // enumerated. An entry in the create item list may be NULL, in
                // which case parameter passing would not work for sub-objects,
                // since the first character of the sub-path would be an object
                // name path separator, which is rejected by the I/O subsystem.
                // A terminating object name path separator must be present on the
                // file name when parameters are passed, such as"name\parameters".
                // It is assumes that any initial object name path separator the
                // I/O system leaves on has been skipped past.
                //
                // Ensure that the length is at least as long as this entry.
                // Compare the strings, but don't call the compare for a zero
                // length item because the Buffer can be NULL.
                // Ensure that the lengths are either equal, meaning that the
                // compare looked at all the characters, or that the character
                // after the comparison is a path separator, and thus parameters
                // to the create.
                //
                if ((Length >= ItemLength) &&
                    (!ItemLength ||
                    !_wcsnicmp(Buffer, ItemBuffer, ItemLength / sizeof(*ItemBuffer))) &&
                    ((Length == ItemLength) ||
                    (Buffer[ItemLength / sizeof(*ItemBuffer)] == OBJ_NAME_PATH_SEPARATOR))) {
                    //
                    // The Create Item may specify that no parameters should be present.
                    // If so, then none should be present, else anything is allowed.
                    // Allow a trailing path separator in any case. If the length of the
                    // string is ItemLength + 1, then the only character could be a
                    // path separator, as tested for above. Else it must be equivalent.
                    //
                    // If this fails, continue through the list in case a wild card is
                    // yet to be found.
                    //
                    if (!(Entry->CreateItem->Flags & KSCREATE_ITEM_NOPARAMETERS) ||
                        (Length <= ItemLength + 1)) {
                        //
                        // Ensure the item is not deleted while processing the create.
                        //
                        InterlockedIncrement(&Entry->RefCount);
                        return Entry;
                    }
                }
            }
        }
    }
    if (WildCardItem) {
        //
        // Ensure the item is not deleted while processing the create.
        //
        InterlockedIncrement(&WildCardItem->RefCount);
    }
    //
    // If a wildcard item was found, return it, else return NULL.
    //
    return WildCardItem;
}


NTSTATUS
DispatchCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This function is used to multiplex a Create to a specific dispatch function.
    It assumes the client is using the KSOBJECT_CREATE method of dispatching
    create request IRP's. This function is assigned when a filter uses
    KsSetMajorFunctionHandler to set the IRP_MJ_CREATE class.

    The file name string up to the first path name separator is compared to
    entries in the object create table to determine if a match is found.
    The dispatch function which first matches is called. If no match is
    found STATUS_INVALID_DEVICE_REQUEST is returned.

    If the create request contains a root file object, then the
    KSIOBJECT_HEADER.CreateItem.ChildCreateHandlerList on that parent file
    object is used rather than the table on the device object. This assumes
    that the KSDISPATCH_TABLE method of dispatching IRP's is being used for
    dealing with create requests for child objects.

    Passes a pointer to the matching create item in the
    KSCREATE_ITEM_IRP_STORAGE(Irp) element. This should be assigned to a
    structure pointed to by FsContext as the second element, after a pointer
    to the dispatch structure. This is used by the security descriptor handlers.

Arguments:

    DeviceObject -
        Contains the device object to which the specific file object belongs.

    Irp -
        Contains the Create Irp to pass on to the specific file context.

Return Value:

    Returns the value of the Create call.

--*/
{
    PIO_STACK_LOCATION IrpStack;
    NTSTATUS Status=0;
    PKSICREATE_ENTRY CreateEntry;
    PKSIDEVICE_HEADER DeviceHeader;

    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    if (IrpStack->FileObject->RelatedFileObject) {
        //
        // If the parent file object was actually a direct open on the
        // device, it may not have actually been handled by the driver
        // through the create dispatch. Therefore any requests to create
        // children against such a parent must be rejected.
        //
        if (IrpStack->FileObject->RelatedFileObject->Flags & FO_DIRECT_DEVICE_OPEN) {
            CreateEntry = NULL;
        } else {
            PKSIOBJECT_HEADER ObjectHeader;

            //
            // This is a request to create a child object on a parent file object.
            // It must have a sub-string in order to be able to pass parameters,
            // and to enable separate persistant security on the object.
            //
            ObjectHeader = *(PKSIOBJECT_HEADER*)IrpStack->FileObject->RelatedFileObject->FsContext;
            CreateEntry = FindAndReferenceCreateItem(
                IrpStack->FileObject->FileName.Buffer,
                IrpStack->FileObject->FileName.Length,
                &ObjectHeader->ChildCreateHandlerList);
        }
    } else {
        //
        // This is a request to create a base object from the list on the device
        // object.
        //
        DeviceHeader = *(PKSIDEVICE_HEADER*)IrpStack->DeviceObject->DeviceExtension;
        //
        // Synchronize with threads removing create items. Only device objects
        // can remove create items, so the lock is not necessary on sub-objects.
        //
        KeEnterCriticalRegion();
        ExAcquireFastMutexUnsafe(&DeviceHeader->CreateListLock);
        //
        // When searching for the entry, if there is a file name attached,
        // skip the initial path name separator passed in by the I/O manager.
        //
        if (IrpStack->FileObject->FileName.Length) {
            //
            // The file name length is known to be non-zero at this point. In
            // this case parameters could be passed even if the name string contains
            // nothing, since an initial object name path separator is valid (and
            // neccessary) as the first character of the string.
            //
            ASSERT((IrpStack->FileObject->FileName.Buffer[0] == OBJ_NAME_PATH_SEPARATOR) && "The I/O manager passed an invalid path");
            CreateEntry = FindAndReferenceCreateItem(
                IrpStack->FileObject->FileName.Buffer + 1,
                IrpStack->FileObject->FileName.Length - sizeof(OBJ_NAME_PATH_SEPARATOR),
                &DeviceHeader->ChildCreateHandlerList);
        } else {
            //
            // This is a zero length file name search. No parameters can be
            // passed with this request, and no persistant security is available.
            //
            CreateEntry = FindAndReferenceCreateItem(NULL, 0, &DeviceHeader->ChildCreateHandlerList);
        }
        //
        // This can be acquired again if the reference count is zero.
        //
        ExReleaseFastMutexUnsafe(&DeviceHeader->CreateListLock);
        KeLeaveCriticalRegion();
    }
    if (!CreateEntry) {
        //
        // Unable to find matching item.
        //
        Status = STATUS_OBJECT_NAME_NOT_FOUND;
    } else {
        if (NT_SUCCESS(Status = ValidateCreateAccess(Irp, CreateEntry->CreateItem))) {
            //
            // Pass along the create item in the entry so that it can be placed in
            // the common buffer area pointed to by FsContext.
            //
            KSCREATE_ITEM_IRP_STORAGE(Irp) = CreateEntry->CreateItem;
#if (DBG)
            {
                PFILE_OBJECT FileObject;

                FileObject = IrpStack->FileObject;
                if (NT_SUCCESS(Status = CreateEntry->CreateItem->Create(DeviceObject, Irp)) &&
                    (Status != STATUS_PENDING)) {
                    if (NULL ==FileObject->FsContext) {
                    	DbgPrint( "KS Warning: The driver's create returned successfully"
                    			  ", but did not make an FsContext");
	            }    
                }
            }
#else
            Status = CreateEntry->CreateItem->Create(DeviceObject, Irp);
#endif
        } else {
            //
            // No handler has been called, so the Irp has not been completed.
            //
            Irp->IoStatus.Status = Status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
        }
        //
        // The assumption from here on is that the I/O system has a reference count
        // on the device object because of the file object it has allocated for the
        // create request. This reference count does not go away until this function
        // returns, whether or not the Irp has already been completed. Therefore the
        // device header still exists.
        //
        // Decrement the previously applied reference count, and determine if it
        // is now zero, meaning that it has been deleted. There will only be a single
        // request which succeeds this conditional because when an item is deleted,
        // a flag marks it as such, so a second request would not be allowed to find
        // the deleted item. Otherwise a first request could decrement the reference
        // count, and a second request could find the deleted item, and also succeed
        // at this conditional, and the create item would be freed twice.
        //
        // Other accesses to the RefCount are interlocked because of this access,
        // which can be performed without acquiring the list lock.
        //
        if (!InterlockedDecrement(&CreateEntry->RefCount)) {
            LIST_ENTRY  CreateList;

            //
            // Acquire the create list lock again, so that the item can be actually
            // removed from the list. Sub-objects should never get to this point,
            // since there is no way to decrement their reference count to zero.
            //
            KeEnterCriticalRegion();
            ExAcquireFastMutexUnsafe(&DeviceHeader->CreateListLock);
            RemoveEntryList(&CreateEntry->ListEntry);
            ExReleaseFastMutexUnsafe(&DeviceHeader->CreateListLock);
            KeLeaveCriticalRegion();
            //
            // Put the create item on its own list so that the common
            // FreeCreateEntries function can be used.
            //
            InitializeListHead(&CreateList);
            InsertHeadList(&CreateList, &CreateEntry->ListEntry);
            FreeCreateEntries(&CreateList);
        }
        //
        // The Irp has already been completed by the create handler.
        //
        return Status;
    }
    //
    // Since no create handler was found, the Irp has not been completed yet.
    //
    Irp->IoStatus.Status = Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return Status;
}


NTSTATUS
DispatchDeviceIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This function is used to multiplex a Device Control to a specific file
    context. It assumes the client is using the KSDISPATCH_TABLE method of
    dispatching IRP's. This function is assigned when a filter uses
    KsSetMajorFunctionHandler to set the IRP_MJ_DEVICE_CONTROL class.

Arguments:

    DeviceObject -
        Contains the device object to which the specific file object belongs.

    Irp -
        Contains the Device Control Irp to pass on to the specific file context.

Return Value:

    Returns the value of the Device Control call.

--*/
{
    PIO_STACK_LOCATION IrpStack;
    PKSIOBJECT_HEADER ObjectHeader;

    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    //
    // If the device was directly opened, then no IRP_MJ_CREATE was ever
    // received, and therefore no initialization happened. Since some Ioctl's
    // can be FILE_ANY_ACCESS, some may be dispatched. Fail this request.
    //
    if (IrpStack->FileObject->Flags & FO_DIRECT_DEVICE_OPEN) {
        return KsDefaultDeviceIoCompletion(DeviceObject, Irp);
    }

    //
    // log perf johnlee
    //

    KSPERFLOGS (
       	PKSSTREAM_HEADER pKsStreamHeader;
       	ULONG	TimeStampMs;
       	ULONG	TotalSize;
       	ULONG	HeaderSize;
       	ULONG 	BufferSize;

       	//pKsStreamHeader = (PKSSTREAM_HEADER)Irp->AssociatedIrp.SystemBuffer;
       	pKsStreamHeader = (PKSSTREAM_HEADER)Irp->UserBuffer;
        switch (IrpStack->Parameters.DeviceIoControl.IoControlCode)
        {            
            case IOCTL_KS_READ_STREAM: {
				//
				// compute total size
				//
            	TotalSize = 0;
            	try {
	            	if ( pKsStreamHeader ) {
    	        		BufferSize = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;
	    	       		while ( BufferSize >= pKsStreamHeader->Size ) {
	        	   			BufferSize -= pKsStreamHeader->Size;
	           				TotalSize += pKsStreamHeader->FrameExtent;
	           			}
	           		}
            	}
            	except ( EXCEPTION_EXECUTE_HANDLER ) {
            		DbgPrint( "Execption=%x\n", GetExceptionCode());
            	}
            	
                //KdPrint(("PerfIsAnyGroupOn=%x\n", PerfIsAnyGroupOn()));
                KSPERFLOG_RECEIVE_READ( DeviceObject, Irp, TotalSize );
            } break;

            case IOCTL_KS_WRITE_STREAM: {
        		TimeStampMs = 0;
            	TotalSize = 0;
            	try {
	            	if ( pKsStreamHeader && 
    	        		 (pKsStreamHeader->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_TIMEVALID)){
        	    		TimeStampMs =(ULONG)
            				(pKsStreamHeader->PresentationTime.Time / (__int64)10000);
            		}

					//
					// compute total size
					//
            		if ( pKsStreamHeader ) {
            			BufferSize = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;
	           			while ( BufferSize >= pKsStreamHeader->Size ) {
	           				BufferSize -= pKsStreamHeader->Size;
		           			TotalSize += pKsStreamHeader->DataUsed;
		           		}
	            	}
	            }
	            except ( EXCEPTION_EXECUTE_HANDLER ) {
            		DbgPrint( "Execption=%x\n", GetExceptionCode());
	            }

                //KdPrint(("PerfIsAnyGroupOn=%x\n", PerfIsAnyGroupOn()));
                KSPERFLOG_RECEIVE_WRITE( DeviceObject, Irp, TimeStampMs, TotalSize );
            } break;
        }
    ) // KSPERFLOGS

    
    //
    // If there is an entry in the DriverObject for this major Irp class, then
    // there must be an entry in the dispatch table which either points to
    // KsDispatchInvalidDeviceRequest, or points to a real dispatch function.
    //
    ObjectHeader = *(PKSIOBJECT_HEADER*)IrpStack->FileObject->FsContext;
    return ObjectHeader->DispatchTable->DeviceIoControl(DeviceObject, Irp);
}


BOOLEAN
DispatchFastDeviceIoControl(
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This function is used to multiplex a Device Control to a specific file
    context. It assumes the client is using the KSDISPATCH_TABLE method of
    dispatching I/O. This function is assigned when a filter uses
    KsSetMajorFunctionHandler to set the IRP_MJ_DEVICE_CONTROL class with the
    KSDISPATCH_FASTIO flag.

Arguments:

    FileObject -
        The file object whose dispatch table is being multi-plexed to.

    Wait -
        Not used.

    InputBuffer -
        Not used.

    InputBufferLength -
        Not used.

    OutputBuffer -
        Not used.

    OutputBufferLength -
        Not used.

    IoControlCode -
        Not used.

    IoStatus -
        Not used.

    DeviceObject -
        Not used.

Return Value:

    Returns the value of the fast Device Control call.

--*/
{
    PKSIOBJECT_HEADER ObjectHeader;

    //
    // If the device was directly opened, then no IRP_MJ_CREATE was ever
    // received, and therefore no initialization happened. Since some Ioctl's
    // can be FILE_ANY_ACCESS, some may be dispatched. Fail this request.
    //
    if (FileObject->Flags & FO_DIRECT_DEVICE_OPEN) {
        return FALSE;
    }
    //
    // If there is a fast I/O entry in the DriverObject for this major IRP
    // class, then there must be an entry in the dispatch table which either
    // points to KsDispatchFastIoDeviceControlFailure, or points to a real
    // dispatch function.
    //
    ObjectHeader = *(PKSIOBJECT_HEADER*)FileObject->FsContext;
    return ObjectHeader->DispatchTable->FastDeviceIoControl(FileObject, Wait, InputBuffer, InputBufferLength, OutputBuffer, OutputBufferLength, IoControlCode, IoStatus, DeviceObject);
}


NTSTATUS
DispatchRead(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This function is used to multiplex a Read to a specific file context. It
    assumes the client is using the KSDISPATCH_TABLE method of dispatching
    IRP's. This function is assigned when a filter uses
    KsSetMajorFunctionHandler to set the IRP_MJ_READ class.

Arguments:

    DeviceObject -
        Contains the device object to which the specific file object belongs.

    Irp -
        Contains the Read Irp to pass on to the specific file context.

Return Value:

    Returns the value of the Read call.

--*/
{
    PKSIOBJECT_HEADER ObjectHeader;

    //
    // If there is an entry in the DriverObject for this major Irp class, then
    // there must be an entry in the dispatch table which either points to
    // KsDispatchInvalidDeviceRequest, or points to a real dispatch function.
    //
    ObjectHeader = *(PKSIOBJECT_HEADER*)IoGetCurrentIrpStackLocation(Irp)->FileObject->FsContext;
    return ObjectHeader->DispatchTable->Read(DeviceObject, Irp);
}


BOOLEAN
DispatchFastRead(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This function is used to multiplex a Read to a specific file context. It
    assumes the client is using the KSDISPATCH_TABLE method of dispatching
    I/O. This function is assigned when a filter uses
    KsSetMajorFunctionHandler to set the IRP_MJ_READ class with the
    KSDISPATCH_FASTIO flag.

Arguments:

    FileObject -
        The file object whose dispatch table is being multi-plexed to.

    FileOffset -
        Not used.

    Length -
        Not used.

    Wait -
        Not used.

    LockKey -
        Not used.

    Buffer -
        Not used.

    IoStatus -
        Not used.

    DeviceObject -
        Not used.

Return Value:

    Returns the value of the fast Read call.

--*/
{
    PKSIOBJECT_HEADER ObjectHeader;

    //
    // If there is a fast I/O entry in the DriverObject for this major IRP
    // class, then there must be an entry in the dispatch table which either
    // points to KsDispatchFastReadFailure, or points to a real dispatch function.
    //
    ObjectHeader = *(PKSIOBJECT_HEADER*)FileObject->FsContext;
    return ObjectHeader->DispatchTable->FastRead(FileObject, FileOffset, Length, Wait, LockKey, Buffer, IoStatus, DeviceObject);
}


NTSTATUS
DispatchWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This function is used to multiplex a Write to a specific file context. It
    assumes the client is using the KSDISPATCH_TABLE method of dispatching
    IRP's. This function is assigned when a filter uses
    KsSetMajorFunctionHandler to set the IRP_MJ_WRITE class.

Arguments:

    DeviceObject -
        Contains the device object to which the specific file object belongs.

    Irp -
        Contains the Write Irp to pass on to the specific file context.

Return Value:

    Returns the value of the Write call.

--*/
{
    PKSIOBJECT_HEADER   ObjectHeader;

    //
    // If there is an entry in the DriverObject for this major Irp class, then
    // there must be an entry in the dispatch table which either points to
    // KsDispatchInvalidDeviceRequest, or points to a real dispatch function.
    //
    ObjectHeader = *(PKSIOBJECT_HEADER*)IoGetCurrentIrpStackLocation(Irp)->FileObject->FsContext;
    return ObjectHeader->DispatchTable->Write(DeviceObject, Irp);
}


BOOLEAN
DispatchFastWrite(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This function is used to multiplex a Write to a specific file context. It
    assumes the client is using the KSDISPATCH_TABLE method of dispatching
    I/O. This function is assigned when a filter uses
    KsSetMajorFunctionHandler to set the IRP_MJ_WRITE class with the
    KSDISPATCH_FASTIO flag.

Arguments:

    FileObject -
        The file object whose dispatch table is being multi-plexed to.

    FileOffset -
        Not used.

    Length -
        Not used.

    Wait -
        Not used.

    LockKey -
        Not used.

    Buffer -
        Not used.

    IoStatus -
        Not used.

    DeviceObject -
        Not used.

Return Value:

    Returns the value of the fast Write call.

--*/
{
    PKSIOBJECT_HEADER ObjectHeader;

    //
    // If there is a fast I/O entry in the DriverObject for this major IRP
    // class, then there must be an entry in the dispatch table which either
    // points to KsDispatchFastWriteFailure, or points to a real dispatch function.
    //
    ObjectHeader = *(PKSIOBJECT_HEADER*)FileObject->FsContext;
    return ObjectHeader->DispatchTable->FastWrite(FileObject, FileOffset, Length, Wait, LockKey, Buffer, IoStatus, DeviceObject);
}


NTSTATUS
DispatchFlush(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This function is used to multiplex a Flush to a specific file context. It
    assumes the client is using the KSDISPATCH_TABLE method of dispatching
    IRP's. This function is assigned when a filter uses
    KsSetMajorFunctionHandler to set the IRP_MJ_FLUSH_BUFFERS class.

Arguments:

    DeviceObject -
        Contains the device object to which the specific file object belongs.

    Irp -
        Contains the Flush Irp to pass on to the specific file context.

Return Value:

    Returns the value of the Flush call.

--*/
{
    PKSIOBJECT_HEADER ObjectHeader;

    //
    // If there is an entry in the DriverObject for this major Irp class, then
    // there must be an entry in the dispatch table which either points to
    // KsDispatchInvalidDeviceRequest, or points to a real dispatch function.
    //
    ObjectHeader = *(PKSIOBJECT_HEADER*)IoGetCurrentIrpStackLocation(Irp)->FileObject->FsContext;
    return ObjectHeader->DispatchTable->Flush(DeviceObject, Irp);
}


NTSTATUS
DispatchClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This function is used to multiplex a Close to a specific file context. It
    assumes the client is using the KSDISPATCH_TABLE method of dispatching
    IRP's. This function is assigned when a filter uses
    KsSetMajorFunctionHandler to set the IRP_MJ_CLOSE class.

Arguments:

    DeviceObject -
        Contains the device object to which the specific file object belongs.

    Irp -
        Contains the Close Irp to pass on to the specific file context.

Return Value:

    Returns the value of the Close call.

--*/
{
    PIO_STACK_LOCATION IrpStack;
    PKSIOBJECT_HEADER ObjectHeader;

    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    //
    // If the device was directly opened, then no IRP_MJ_CREATE was ever
    // received, and therefore no initialization happened. Just succeed
    // the close.
    //
    if (IrpStack->FileObject->Flags & FO_DIRECT_DEVICE_OPEN) {
        Irp->IoStatus.Status = STATUS_SUCCESS;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_SUCCESS;
    }
    //
    // This entry needs to point to something, since a close must succeed.
    //
    ObjectHeader = *(PKSIOBJECT_HEADER*)IrpStack->FileObject->FsContext;
    return ObjectHeader->DispatchTable->Close(DeviceObject, Irp);
}


KSDDKAPI
NTSTATUS
NTAPI
KsDispatchQuerySecurity(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This is used in the KSDISPATCH_TABLE.QuerySecurity entry to handle querying
    about the current security descriptor. This assumes that the KSIOBJECT_HEADER
    structure is being used in the FsContext data structure, and that the
    CreateItem points to a valid item which optionally contains a security
    descriptor. If no security descriptor is present returns
    STATUS_NO_SECURITY_ON_OBJECT.

Arguments:

    DeviceObject -
        Contains the Device Object associated with the current Irp stack location.

    Irp -
        Contains the Irp being handled.

Return Value:

    Returns the security query status, and completes the Irp.

--*/
{
    NTSTATUS Status;
#ifndef WIN9X_KS
    PIO_STACK_LOCATION IrpStack;
    PKSIOBJECT_HEADER ObjectHeader;
    PKSIDEVICE_HEADER DeviceHeader;

    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    ObjectHeader = *(PKSIOBJECT_HEADER*)IrpStack->FileObject->FsContext;
    //
    // Acquire the lock for all security descriptors on this device object.
    //
    DeviceHeader = *(PKSIDEVICE_HEADER*)IrpStack->DeviceObject->DeviceExtension;
    KeEnterCriticalRegion();
    ExAcquireResourceSharedLite(&DeviceHeader->SecurityDescriptorResource, TRUE);
    //
    // Only return something valid if a security descriptor exists.
    //
    if (ObjectHeader->CreateItem->SecurityDescriptor) {
        ULONG   Length;

        Length = IrpStack->Parameters.QuerySecurity.Length;
        Status = SeQuerySecurityDescriptorInfo(
            &IrpStack->Parameters.QuerySecurity.SecurityInformation,
            Irp->UserBuffer,
            &Length,
            &ObjectHeader->CreateItem->SecurityDescriptor);
        if (Status == STATUS_BUFFER_TOO_SMALL) {
            Irp->IoStatus.Information = Length;
            Status = STATUS_BUFFER_OVERFLOW;
        } else if (NT_SUCCESS(Status)) {
            Irp->IoStatus.Information = Length;
        }
    } else {
        Status = STATUS_NO_SECURITY_ON_OBJECT;
    }
    //
    // Release the security descriptor lock for this device object.
    //
    ExReleaseResourceLite(&DeviceHeader->SecurityDescriptorResource);
    KeLeaveCriticalRegion();
#else // WIN9X_KS
    Status = STATUS_NO_SECURITY_ON_OBJECT;
#endif // WIN9X_KS
    Irp->IoStatus.Status = Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return Status;
}


KSDDKAPI
NTSTATUS
NTAPI
KsDispatchSetSecurity(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This is used in the KSDISPATCH_TABLE.SetSecurity entry to handle setting
    the current security descriptor. This assumes that the KSIOBJECT_HEADER
    structure is being used in the FsContext data structure, and that the
    CreateItem points to a valid item which optionally contains a security
    descriptor.

Arguments:

    DeviceObject -
        Contains the Device Object associated with the current Irp stack location.

    Irp -
        Contains the Irp being handled.

Return Value:

    Returns the security set status, and completes the Irp.

--*/
{
    NTSTATUS Status;
#ifndef WIN9X_KS
    PIO_STACK_LOCATION IrpStack;
    PKSIOBJECT_HEADER ObjectHeader;
    PKSIDEVICE_HEADER DeviceHeader;
    PSECURITY_DESCRIPTOR OldSecurityDescriptor;

    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    ObjectHeader = *(PKSIOBJECT_HEADER*)IrpStack->FileObject->FsContext;
    //
    // Acquire the lock for all security descriptors on this device object.
    //
    DeviceHeader = *(PKSIDEVICE_HEADER*)IrpStack->DeviceObject->DeviceExtension;
    KeEnterCriticalRegion();
    ExAcquireResourceExclusiveLite(&DeviceHeader->SecurityDescriptorResource, TRUE);
    //
    // Only allow a change if a security descriptor exists.
    //
    if (ObjectHeader->CreateItem->SecurityDescriptor) {
        //
        // Replace the old security descriptor with the new one.
        //
        OldSecurityDescriptor = ObjectHeader->CreateItem->SecurityDescriptor;
        Status = SeSetSecurityDescriptorInfo(IrpStack->FileObject,
            &IrpStack->Parameters.SetSecurity.SecurityInformation,
            IrpStack->Parameters.SetSecurity.SecurityDescriptor,
            &ObjectHeader->CreateItem->SecurityDescriptor,
            NonPagedPool,
            IoGetFileObjectGenericMapping());
        if (NT_SUCCESS(Status)) {
            ExFreePool(OldSecurityDescriptor);
            //
            // Indicate that this security descriptor should be flushed
            // before disposing the create item for this type of object.
            //
            ObjectHeader->CreateItem->Flags |= KSCREATE_ITEM_SECURITYCHANGED;
        }
    } else {
        Status = STATUS_NO_SECURITY_ON_OBJECT;
    }
    //
    // Release the security descriptor lock for this device object.
    //
    ExReleaseResourceLite(&DeviceHeader->SecurityDescriptorResource);
    KeLeaveCriticalRegion();
#else // WIN9X_KS
    Status = STATUS_NO_SECURITY_ON_OBJECT;
#endif // WIN9X_KS
    Irp->IoStatus.Status = Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return Status;
}


NTSTATUS
DispatchQuerySecurity(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This function is used to multiplex a Query Security to a specific file context.
    It assumes the client is using the KSDISPATCH_TABLE method of dispatching
    IRP's. This function is assigned when a filter uses
    KsSetMajorFunctionHandler to set the IRP_MJ_QUERY_SECURITY class.

Arguments:

    DeviceObject -
        Contains the device object to which the specific file object belongs.

    Irp -
        Contains the Query Security Irp to pass on to the specific file context.

Return Value:

    Returns the value of the Query Security call.

--*/
{
    PIO_STACK_LOCATION IrpStack;
    PKSIOBJECT_HEADER ObjectHeader;

    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    //
    // If the device was directly opened, then no IRP_MJ_CREATE was ever
    // received, and therefore no initialization happened. ACCESS_SYSTEM_SECURITY
    // is allowed, so this type of request will be dispatched. Fail this request.
    //
    if (IrpStack->FileObject->Flags & FO_DIRECT_DEVICE_OPEN) {
        return KsDefaultDeviceIoCompletion(DeviceObject, Irp);
    }
    //
    // If there is an entry in the DriverObject for this major Irp class, then
    // there must be an entry in the dispatch table which either points to
    // KsDispatchInvalidDeviceRequest, or points to a real dispatch function.
    //
    ObjectHeader = *(PKSIOBJECT_HEADER*)IrpStack->FileObject->FsContext;
    return ObjectHeader->DispatchTable->QuerySecurity(DeviceObject, Irp);
}


NTSTATUS
DispatchSetSecurity(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This function is used to multiplex a Set Security to a specific file context.
    It assumes the client is using the KSDISPATCH_TABLE method of dispatching
    IRP's. This function is assigned when a filter uses
    KsSetMajorFunctionHandler to set the IRP_MJ_SET_SECURITY class.

Arguments:

    DeviceObject -
        Contains the device object to which the specific file object belongs.

    Irp -
        Contains the Set Security Irp to pass on to the specific file context.

Return Value:

    Returns the value of the Set Security call.

--*/
{
    PIO_STACK_LOCATION IrpStack;
    PKSIOBJECT_HEADER ObjectHeader;

    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    //
    // If the device was directly opened, then no IRP_MJ_CREATE was ever
    // received, and therefore no initialization happened. ACCESS_SYSTEM_SECURITY
    // is allowed, so this type of request will be dispatched. Fail this request.
    //
    if (IrpStack->FileObject->Flags & FO_DIRECT_DEVICE_OPEN) {
        return KsDefaultDeviceIoCompletion(DeviceObject, Irp);
    }
    //
    // If there is an entry in the DriverObject for this major Irp class, then
    // there must be an entry in the dispatch table which either points to
    // KsDispatchInvalidDeviceRequest, or points to a real dispatch function.
    //
    ObjectHeader = *(PKSIOBJECT_HEADER*)IrpStack->FileObject->FsContext;
    return ObjectHeader->DispatchTable->SetSecurity(DeviceObject, Irp);
}


KSDDKAPI
NTSTATUS
NTAPI
KsDispatchSpecificProperty(
    IN PIRP Irp,
    IN PFNKSHANDLER Handler
    )
/*++

Routine Description:

    Dispatches the property to a specific handler. This function assumes that
    the caller has previous dispatched this Irp to a handler via the
    KsPropertyHandler function. This function is intended for additional
    processing of the property such as completing a pending operation.

    This function may only be called at PASSIVE_LEVEL.

Arguments:

    Irp -
        Contains the Irp with the property request being dispatched.

    Handler -
        Contains the pointer to the specific property handler.

Return Value:

    Returns STATUS_SUCCESS, else an error.

--*/
{
    PIO_STACK_LOCATION IrpStack;
    PKSIDENTIFIER Request;
    PVOID UserBuffer;
    ULONG AlignedBufferLength;

    PAGED_CODE();
    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    //
    // In the normal case, the UserBuffer is first, followed by the request,
    // which is on FILE_QUAD_ALIGNMENT. So determine how much to skip by.
    //
    AlignedBufferLength = (IrpStack->Parameters.DeviceIoControl.OutputBufferLength + FILE_QUAD_ALIGNMENT) & ~FILE_QUAD_ALIGNMENT;
    if (AlignedBufferLength) {
        UserBuffer = Irp->AssociatedIrp.SystemBuffer;
    } else {
        UserBuffer = NULL;
    }
    Request = (PKSIDENTIFIER)((PUCHAR)Irp->AssociatedIrp.SystemBuffer + AlignedBufferLength);
    return Handler(Irp, Request, UserBuffer);
}


KSDDKAPI
NTSTATUS
NTAPI
KsDispatchSpecificMethod(
    IN PIRP Irp,
    IN PFNKSHANDLER Handler
    )
/*++

Routine Description:

    Dispatches the method to a specific handler. This function assumes that
    the caller has previous dispatched this Irp to a handler via the
    KsMethodHandler function. This function is intended for additional
    processing of the method such as completing a pending operation.

    This function may only be called at PASSIVE_LEVEL.

Arguments:

    Irp -
        Contains the Irp with the method request being dispatched.

    Handler -
        Contains the pointer to the specific method handler.

Return Value:

    Returns STATUS_SUCCESS, else an error.

--*/
{
    PIO_STACK_LOCATION IrpStack;
    PKSIDENTIFIER Request;
    PVOID UserBuffer;

    PAGED_CODE();
    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    //
    // The type has been put into the KSMETHOD_TYPE_IRP_STORAGE(Irp) in
    // KsMethodHandler. This needs to be done since there is no way to
    // determine in a generic manner where the Method is in the SystemBuffer
    // without this clue.
    //
    if (KSMETHOD_TYPE_IRP_STORAGE(Irp) & KSMETHOD_TYPE_SOURCE) {
        if (IrpStack->Parameters.DeviceIoControl.OutputBufferLength) {
            //
            // Either the original caller's buffer is to be used, or one of the
            // other method type flags have been set, and a system address for
            // that buffer is to be used.
            //
            if (IrpStack->MinorFunction & ~KSMETHOD_TYPE_SOURCE) {
                UserBuffer = MmGetSystemAddressForMdl(Irp->MdlAddress);
            } else {
                UserBuffer = Irp->UserBuffer;
            }
        } else {
            UserBuffer = NULL;
        }
        //
        // In this special case, the UserBuffer does not preceed the request
        //
        Request = (PKSIDENTIFIER)Irp->AssociatedIrp.SystemBuffer;
    } else {
        ULONG AlignedBufferLength;

        //
        // In the normal case, the UserBuffer is first, followed by the request,
        // which is on FILE_QUAD_ALIGNMENT. So determine how much to skip by.
        //
        AlignedBufferLength = (IrpStack->Parameters.DeviceIoControl.OutputBufferLength + FILE_QUAD_ALIGNMENT) & ~FILE_QUAD_ALIGNMENT;
        if (AlignedBufferLength) {
            UserBuffer = Irp->AssociatedIrp.SystemBuffer;
        } else {
            UserBuffer = NULL;
        }
        Request = (PKSIDENTIFIER)((PUCHAR)Irp->AssociatedIrp.SystemBuffer + AlignedBufferLength);
    }
    return Handler(Irp, Request, UserBuffer);
}


KSDDKAPI
NTSTATUS
NTAPI
KsDispatchInvalidDeviceRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This is used in KSDISPATCH_TABLE entries which are not handled, and
    should return STATUS_INVALID_DEVICE_REQUEST. This is needed since the
    dispatch table for a particular opened instance of a device may not
    handle a specific major function that another opened instance needs to
    handle. Therefore the function pointer in the Driver Object always must
    point to a function which calls a dispatch table entry.

Arguments:

    DeviceObject -
        Not used.

    Irp -
        Contains the Irp which is not being handled.

Return Value:

    Returns STATUS_INVALID_DEVICE_REQUEST, and completes the Irp.

--*/
{
    PAGED_CODE();
    Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_INVALID_DEVICE_REQUEST;
}


KSDDKAPI
NTSTATUS
NTAPI
KsDefaultDeviceIoCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This function is used to return a default response to any device I/O
    control. It can be used in the KSDISPATCH_TABLE, and as the default
    response to unknown Ioctl's.

Arguments:

    DeviceObject -
        Contains the device object dispatched to.

    Irp -
        Contains the Irp to return a default response to.

Return Value:

    Returns the default response to the possible Ioctl's.

--*/
{
    NTSTATUS Status;

    PAGED_CODE();
    switch (IoGetCurrentIrpStackLocation(Irp)->Parameters.DeviceIoControl.IoControlCode) {
    case IOCTL_KS_PROPERTY:
    case IOCTL_KS_ENABLE_EVENT:
    case IOCTL_KS_METHOD:
        Status = STATUS_PROPSET_NOT_FOUND;
        break;
    case IOCTL_KS_RESET_STATE:
        Status = STATUS_SUCCESS;
        break;
    default:
        Status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }
    Irp->IoStatus.Status = Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return Status;
}


KSDDKAPI
BOOLEAN
NTAPI
KsDispatchFastIoDeviceControlFailure(
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This is used in KSDISPATCH_TABLE fast device control entry when not handled,
    and should return FALSE. This is needed since the dispatch table for a
    particular opened instance of a device may not handle a specific major
    function that another opened instance needs to handle. Therefore the
    function pointer in the Driver Object always must point to a function
    which calls a dispatch table entry.

Arguments:

    FileObject -
        Not used.

    Wait -
        Not used.

    InputBuffer -
        Not used.

    InputBufferLength -
        Not used.

    OutputBuffer -
        Not used.

    OutputBufferLength -
        Not used.

    IoControlCode -
        Not used.

    IoStatus -
        Not used.

    DeviceObject -
        Not used.

Return Value:

    Returns FALSE.

--*/
{
    return FALSE;
}


KSDDKAPI
BOOLEAN
NTAPI
KsDispatchFastReadFailure(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This is used in KSDISPATCH_TABLE fast read entry when not handled, and
    should return FALSE. This is needed since the dispatch table for a
    particular opened instance of a device may not handle a specific major
    function that another opened instance needs to handle. Therefore the
    function pointer in the Driver Object always must point to a function
    which calls a dispatch table entry.

    This function is also used as KsDispatchFastWriteFailure.

Arguments:

    FileObject -
        Not used.

    FileOffset -
        Not used.

    Length -
        Not used.

    Wait -
        Not used.

    LockKey -
        Not used.

    Buffer -
        Not used.

    IoStatus -
        Not used.

    DeviceObject -
        Not used.

Return Value:

    Returns FALSE.

--*/
{
    return FALSE;
}


KSDDKAPI
VOID
NTAPI
KsNullDriverUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    Default function which drivers can use when they do not have anything to do
    in their unload function, but must still allow the device to be unloaded by
    its presence.

Arguments:

    DriverObject -
        Contains the driver object for this device.

Return Values:

    Nothing.

--*/
{
}


KSDDKAPI
NTSTATUS
NTAPI
KsSetMajorFunctionHandler(
    IN PDRIVER_OBJECT DriverObject,
    IN ULONG MajorFunction
    )
/*++

Routine Description:

    This function sets the handler for a specified major function to use
    the internal dispatching, which routes through a KSDISPATCH_TABLE
    assumed to be the first element within a structure pointed to by an
    FsContext within a File Object. The dispatching assumes the table and
    FsContext structure are initialized by the device. For the create function
    assumes that the first element of the device object extent contains a
    KSOBJECT_CREATE structure.

    Note that if a major function handler is set for a driver object, all
    file objects must handle that major function, even if the entry just
    points to KsDispatchInvalidDeviceRequest.

Arguments:

    DriverObject -
    Contains the Driver Object whose major function is to be handled.

    MajorFunction -
    Contains the major function identifier to be handled. This sets the
    major function pointer in the Driver Object to an internal function
    which then dispatches to the KSDISPATCH_TABLE function. The pointer
    to this table is assumed to be the first element in a structure pointed
    to by FsContext in the File Object of the specific Irp being dispatched.
    The valid Major Function identifiers are as listed:

    IRP_MJ_CREATE -
        Create Irp. In this instance, a create request could be use for
        either creating a new instance of a filter, or for creating some
        object such as a pin under a filter, or a clock under a pin. This
        assumes that the first element in the driver object's extent
        contains a KSOBJECT_CREATE structure, which is used to find the type
        of object to create, based on the name passed. One of the types may
        be a sub-object, such as a pin, allocator, or clock. In this case
        the dispatcher routing uses an internal dispatch function in
        creating the sub-objects, which looks at the
        KSIOBJECT_HEADER.CreateItem.ChildCreateHandlerList in the parent's
        file object FsContext to determine which handler to use for the create.

    IRP_MJ_CLOSE -
        Close Irp.

    IRP_MJ_DEVICE_CONTROL -
        Device Control Irp.

    IRP_MJ_READ -
        Read Irp.

    IRP_MJ_WRITE -
        Write Irp.

    IRP_MJ_FLUSH_BUFFERS -
        Flush Irp.

    IRP_MJ_QUERY_SECURITY -
        Query security information

    IRP_MJ_SET_SECURITY -
        Set security information

    KSDISPATCH_FASTIO -
        This flag may be added to the MajorFunction identifier in order to
        specify that the entry refers to the fast I/O dispatch table, rather
        than the normal major function entry. This is only valid with
        IRP_MJ_READ, IRP_MJ_WRITE, or IRP_MJ_DEVICE_CONTROL. The driver is
        responsible for creating the DriverObject->FastIoDispatch table.
        As with normal dispatching, if a handler is set for the driver
        object, all file objects must handle that fast I/O, even if the
        entry just points to KsDispatchFastIoDeviceControlFailure or
        similar function.

Return Value:

    Returns STATUS_SUCCESS if the MajorFunction identifier is valid.

--*/
{
    PAGED_CODE();
    if (MajorFunction & KSDISPATCH_FASTIO) {
        //
        // Modify the Fast I/O table instead.
        //
        switch (MajorFunction & ~KSDISPATCH_FASTIO) {

        case IRP_MJ_DEVICE_CONTROL:
            DriverObject->FastIoDispatch->FastIoDeviceControl = DispatchFastDeviceIoControl;
            break;

        case IRP_MJ_READ:
            DriverObject->FastIoDispatch->FastIoRead = DispatchFastRead;
            break;

        case IRP_MJ_WRITE:
            DriverObject->FastIoDispatch->FastIoWrite = DispatchFastWrite;
            break;

        default:
            return STATUS_INVALID_PARAMETER;

        }
    } else {
        PDRIVER_DISPATCH    Dispatch;

        switch (MajorFunction) {

        case IRP_MJ_CREATE:
            Dispatch = DispatchCreate;
            break;

        case IRP_MJ_CLOSE:
            Dispatch = DispatchClose;
            break;

        case IRP_MJ_FLUSH_BUFFERS:
            Dispatch = DispatchFlush;
            break;

        case IRP_MJ_DEVICE_CONTROL:
            Dispatch = DispatchDeviceIoControl;
            break;

        case IRP_MJ_READ:
            Dispatch = DispatchRead;
            break;

        case IRP_MJ_WRITE:
            Dispatch = DispatchWrite;
            break;

        case IRP_MJ_QUERY_SECURITY:
            Dispatch = DispatchQuerySecurity;
            break;

        case IRP_MJ_SET_SECURITY:
            Dispatch = DispatchSetSecurity;
            break;

        default:
            return STATUS_INVALID_PARAMETER;

        }
        DriverObject->MajorFunction[MajorFunction] = Dispatch;
    }
    return STATUS_SUCCESS;
}


KSDDKAPI
NTSTATUS
NTAPI
KsReadFile(
    IN PFILE_OBJECT FileObject,
    IN PKEVENT Event OPTIONAL,
    IN PVOID PortContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN ULONG Key OPTIONAL,
    IN KPROCESSOR_MODE RequestorMode
    )
/*++

Routine Description:

    Peforms a read against the specified file object. Assumes the caller is
    serializing access to the file for operations against a FO_SYNCHRONOUS_IO
    file object.

    The function attempts to use FastIoDispatch if possible, else generates a
    read request against the device object.

Arguments:

    FileObject -
        Contains the file object to perform the read against.

    Event -
        Optionally contains the event to use in the read. If none is passed, the
        call is assumed to be on a synchronous file object or the caller will wait
        on the file object's event, else it may be asynchronously completed. If
        the file has been opened for synchronous I/O, this must be NULL. If used,
        this must be an event allocated by the object manager.

    PortContext -
        Optionally contains context information for a completion port.

    IoStatusBlock -
        The place in which to return the status information. This is always
        assumed to be a valid address, regardless of the requestor mode.

    Buffer -
        Contains the buffer in which to place the data read. If the buffer needs
        to be probed and locked, an exception handler is used, along with
        RequestorMode.

    Length -
        Specifies the size of the Buffer passed.

    Key -
        Optionally contains a key, or zero if none.

    RequestorMode -
        Indicates the processor mode to place in the read Irp if one is needs to
        be generated. Additionally is used if Buffer needs to be probed and
        locked. This also determines if a fast I/O call can be performed. If the
        requestor mode is not KernelMode, but the previous mode is, then fast I/O
        cannot be used.

Return Value:

    Returns STATUS_SUCCESS, STATUS_PENDING, else a read error.

--*/
{
    NTSTATUS Status;
    PDEVICE_OBJECT DeviceObject;
    PIRP Irp;
    PIO_STACK_LOCATION IrpStackNext;

    PAGED_CODE();
    //
    // If there is an Event being passed, then the call should be asynchronous.
    //
    if (Event) {
        ASSERT(!(FileObject->Flags & FO_SYNCHRONOUS_IO) && "The driver opened a file for synchronous I/O, and is now passing an event for asynchronous I/O");
        KeClearEvent(Event);
    }
    if (Length && (RequestorMode != KernelMode)) {
        try {
            ProbeForWrite(Buffer, Length, sizeof(BYTE));
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }
    }
    //
    // First determine if the Fast I/O entry point can be used. This does not hinge
    // on the I/O being synchronous, since the caller is supposed to serialize access
    // for synchronous file objects. It does however need to check that the Previous
    // mode is the same as the Requestor mode, since a Fast I/O entry point has no
    // way of determining a Requestor mode.
    //
    DeviceObject = IoGetRelatedDeviceObject(FileObject);
    if (FileObject->PrivateCacheMap && ((RequestorMode != KernelMode) || (ExGetPreviousMode() == KernelMode))) {
        ASSERT(DeviceObject->DriverObject->FastIoDispatch && DeviceObject->DriverObject->FastIoDispatch->FastIoRead && "This file has a PrivateCacheMap, but no fast I/O function");
        if (DeviceObject->DriverObject->FastIoDispatch->FastIoRead(FileObject, 
            &FileObject->CurrentByteOffset, 
            Length, 
            TRUE, 
            Key, 
            Buffer, 
            IoStatusBlock, 
            DeviceObject) &&
            ((IoStatusBlock->Status == STATUS_SUCCESS) ||
            (IoStatusBlock->Status == STATUS_BUFFER_OVERFLOW) ||
            (IoStatusBlock->Status == STATUS_END_OF_FILE))) {
            return IoStatusBlock->Status;
        }
    }
    //
    // Fast I/O did not work, so an Irp must be allocated.
    //
    KeClearEvent(&FileObject->Event);
    Irp = IoBuildSynchronousFsdRequest(
        IRP_MJ_READ,
        DeviceObject,
        Buffer,
        Length,
        &FileObject->CurrentByteOffset,
        Event,
        IoStatusBlock);
    if (!Irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    Irp->RequestorMode = RequestorMode;
    Irp->Tail.Overlay.OriginalFileObject = FileObject;
    Irp->Overlay.AsynchronousParameters.UserApcContext = PortContext;
    IrpStackNext = IoGetNextIrpStackLocation(Irp);
    IrpStackNext->Parameters.Read.Key = Key;
    IrpStackNext->FileObject = FileObject;
    //
    // These are dereferenced by the completion routine.
    //
    if (Event) {
        ObReferenceObject(Event);
    }
    ObReferenceObject(FileObject);
    Status = IoCallDriver(DeviceObject, Irp);
    if (Status == STATUS_PENDING) {
        //
        // This is a synchronous file object, so wait for the file object to
        // be signalled, and retrieve the status from the file object itself.
        // Since the file I/O cannot really be canceled, just wait forever.
        //
        if (FileObject->Flags & FO_SYNCHRONOUS_IO) {
            KeWaitForSingleObject(
                &FileObject->Event,
                Executive,
                RequestorMode,
                FALSE,
                NULL);
            Status = FileObject->FinalStatus;
        }
    }
    return Status;
}


KSDDKAPI
NTSTATUS
NTAPI
KsWriteFile(
    IN PFILE_OBJECT FileObject,
    IN PKEVENT Event OPTIONAL,
    IN PVOID PortContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID Buffer,
    IN ULONG Length,
    IN ULONG Key OPTIONAL,
    IN KPROCESSOR_MODE RequestorMode
    )
/*++

Routine Description:

    Peforms a write against the specified file object. Assumes the caller is
    serializing access to the file for operations against a FO_SYNCHRONOUS_IO
    file object.

    The function attempts to use FastIoDispatch if possible, else generates a
    write request against the device object.

Arguments:

    FileObject -
        Contains the file object to perform the write against.

    Event -
        Optionally contains the event to use in the write. If none is passed, the
        call is assumed to be on a synchronous file object or the caller will wait
        on the file object's event, else it may be asynchronously completed. If
        the file has been opened for synchronous I/O, this must be NULL. If used,
        this must be an event allocated by the object manager.

    PortContext -
        Optionally contains context information for a completion port.

    IoStatusBlock -
        The place in which to return the status information. This is always
        assumed to be a valid address, regardless of the requestor mode.

    Buffer -
        Contains the buffer from which to write the data. If the buffer needs
        to be probed and locked, an exception handler is used, along with
        RequestorMode.

    Length -
        Specifies the size of the Buffer passed.

    Key -
        Optionally contains a key, or zero if none.

    RequestorMode -
        Indicates the processor mode to place in the write Irp if one is needs to
        be generated. Additionally is used if Buffer needs to be probed and
        locked. This also determines if a fast I/O call can be performed. If the
        requestor mode is not KernelMode, but the previous mode is, then fast I/O
        cannot be used.

Return Value:

    Returns STATUS_SUCCESS, STATUS_PENDING, else a write error.

--*/
{
    NTSTATUS Status;
    PDEVICE_OBJECT DeviceObject;
    PIRP Irp;
    PIO_STACK_LOCATION IrpStackNext;

    PAGED_CODE();
    //
    // If there is an Event being passed, then the call should be synchronous.
    //
    if (Event) {
        ASSERT(!(FileObject->Flags & FO_SYNCHRONOUS_IO) && "The driver opened a file for synchronous I/O, and is now passing an event for asynchronous I/O");
        KeClearEvent(Event);
    }
    if (Length && (RequestorMode != KernelMode)) {
        try {
            ProbeForRead(Buffer, Length, sizeof(BYTE));
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }
    }
    //
    // First determine if the Fast I/O entry point can be used. This does not hinge
    // on the I/O being synchronous, since the caller is supposed to serialize access
    // for synchronous file objects. It does however need to check that the Previous
    // mode is the same as the Requestor mode, since a Fast I/O entry point has no
    // way of determining a Requestor mode.
    //
    DeviceObject = IoGetRelatedDeviceObject(FileObject);
    if (FileObject->PrivateCacheMap && ((RequestorMode != KernelMode) || (ExGetPreviousMode() == KernelMode))) {
        ASSERT(DeviceObject->DriverObject->FastIoDispatch && DeviceObject->DriverObject->FastIoDispatch->FastIoWrite && "This file has a PrivateCacheMap, but no fast I/O function");
        if (DeviceObject->DriverObject->FastIoDispatch->FastIoWrite(FileObject, 
            &FileObject->CurrentByteOffset, 
            Length, 
            TRUE, 
            Key, 
            Buffer, 
            IoStatusBlock, 
            DeviceObject) &&
            (IoStatusBlock->Status == STATUS_SUCCESS)) {
            return IoStatusBlock->Status;
        }
    }
    //
    // Fast I/O did not work, so an Irp must be allocated.
    //
    KeClearEvent(&FileObject->Event);
    Irp = IoBuildSynchronousFsdRequest(
        IRP_MJ_WRITE,
        DeviceObject,
        Buffer,
        Length,
        &FileObject->CurrentByteOffset,
        Event,
        IoStatusBlock);
    if (!Irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    Irp->RequestorMode = RequestorMode;
    Irp->Tail.Overlay.OriginalFileObject = FileObject;
    Irp->Overlay.AsynchronousParameters.UserApcContext = PortContext;
    IrpStackNext = IoGetNextIrpStackLocation(Irp);
    IrpStackNext->Parameters.Write.Key = Key;
    IrpStackNext->FileObject = FileObject;
    //
    // These are dereferenced by the completion routine.
    //
    if (Event) {
        ObReferenceObject(Event);
    }
    ObReferenceObject(FileObject);
    Status = IoCallDriver(DeviceObject, Irp);
    if (Status == STATUS_PENDING) {
        //
        // This is a synchronous file object, so wait for the file object to
        // be signalled, and retrieve the status from the file object itself.
        // Since the file I/O cannot really be canceled, just wait forever.
        //
        if (FileObject->Flags & FO_SYNCHRONOUS_IO) {
            KeWaitForSingleObject(
                &FileObject->Event,
                Executive,
                RequestorMode,
                FALSE,
                NULL);
            Status = FileObject->FinalStatus;
        }
    }
    return Status;
}


KSDDKAPI
NTSTATUS
NTAPI
KsQueryInformationFile(
    IN PFILE_OBJECT FileObject,
    OUT PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass
    )
/*++

Routine Description:

    Peforms an information query against the specified file object. This should only
    be used in cases where the query would result in an actual request to the
    underlying driver. For instance, FilePositionInformation would not generate such
    a request, and should not be used. Assumes the caller is serializing access to
    the file for operations against a FO_SYNCHRONOUS_IO file object.

    The function attempts to use FastIoDispatch if possible, else generates an
    information request against the device object.

Arguments:

    FileObject -
        Contains the file object to query the standard information from.

    FileInformation -
        The place in which to put the file information. This is assumed to be a
        valid or probed address.

    Length -
        The correct length of the FileInformation buffer.

    FileInformationClass -
        The class of information being requested.

Return Value:

    Returns STATUS_SUCCESS, else a query error.

--*/
{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    PDEVICE_OBJECT DeviceObject;
    PIRP Irp;
    KEVENT Event;
    PIO_STACK_LOCATION IrpStackNext;
    PVOID SystemBuffer;

    PAGED_CODE();
    //
    // First determine if the Fast I/O entry point can be used. This does not hinge
    // on the I/O being synchronous, since the caller is supposed to serialize access
    // for synchronous file objects.
    //
    DeviceObject = IoGetRelatedDeviceObject(FileObject);
    if (DeviceObject->DriverObject->FastIoDispatch) {
        if ((FileInformationClass == FileBasicInformation) &&
            DeviceObject->DriverObject->FastIoDispatch->FastIoQueryBasicInfo) {
            if (DeviceObject->DriverObject->FastIoDispatch->FastIoQueryBasicInfo(
                FileObject, 
                TRUE, 
                FileInformation,
                &IoStatusBlock, 
                DeviceObject)) {
                return IoStatusBlock.Status;
            }
        } else if ((FileInformationClass == FileStandardInformation) &&
            DeviceObject->DriverObject->FastIoDispatch->FastIoQueryStandardInfo) {
            if (DeviceObject->DriverObject->FastIoDispatch->FastIoQueryStandardInfo(
                FileObject, 
                TRUE, 
                FileInformation,
                &IoStatusBlock, 
                DeviceObject)) {
                return IoStatusBlock.Status;
            }
        }
    }
    //
    // Fast I/O did not work, so an Irp must be allocated. First allocate the buffer
    // which the driver will use to write the file information. This is cleaned up
    // either by a failure to create an Irp, or during Irp completion.
    //
    SystemBuffer = ExAllocatePoolWithTag(NonPagedPool, Length, 'fqSK');
    if (!SystemBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    KeClearEvent(&FileObject->Event);
    //
    // This is on the stack, but any wait for a pending return will be done using
    // KernelMode so the stack will be locked.
    //
    KeInitializeEvent(&Event, SynchronizationEvent, FALSE);
    //
    // Just build a random Irp so that it gets queued up properly.
    //
    Irp = IoBuildSynchronousFsdRequest(
        IRP_MJ_FLUSH_BUFFERS,
        DeviceObject,
        NULL,
        0,
        NULL,
        &Event,
        &IoStatusBlock);
    if (!Irp) {
        ExFreePool(SystemBuffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    //
    // The parameters are always valid, so the Requestor is alway KernelMode.
    //
    Irp->RequestorMode = KernelMode;
    Irp->Tail.Overlay.OriginalFileObject = FileObject;
    Irp->Overlay.AsynchronousParameters.UserApcContext = NULL;
    Irp->UserBuffer = FileInformation;
    Irp->AssociatedIrp.SystemBuffer = SystemBuffer;
    //
    // Set this Irp to be a Synchronous API so that the Event passed is not
    // dereferenced during Irp completion, but merely signalled.
    //
    Irp->Flags |= IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER | IRP_INPUT_OPERATION | IRP_SYNCHRONOUS_API;
    IrpStackNext = IoGetNextIrpStackLocation(Irp);
    IrpStackNext->MajorFunction = IRP_MJ_QUERY_INFORMATION;
    IrpStackNext->Parameters.QueryFile.Length = Length;
    IrpStackNext->Parameters.QueryFile.FileInformationClass = FileInformationClass;
    IrpStackNext->FileObject = FileObject;
    //
    // This is dereferenced by the completion routine.
    //
    ObReferenceObject(FileObject);
    Status = IoCallDriver(DeviceObject, Irp);
    if (Status == STATUS_PENDING) {
        //
        // An event was passed, so it will always be signalled. Either
        // retrieve the status from the file object itself, or from the
        // status block, depending on where it ends up. Since the file
        // I/O cannot really be canceled, just wait forever. Note that
        // this is a KernelMode wait so that the Event which is on the
        // stack becomes NonPaged.
        //
        KeWaitForSingleObject(
            &Event,
            Executive,
            KernelMode,
            FALSE,
            NULL);
        if (FileObject->Flags & FO_SYNCHRONOUS_IO) {
            Status = FileObject->FinalStatus;
        } else {
            Status = IoStatusBlock.Status;
        }
    }
    return Status;
}


KSDDKAPI
NTSTATUS
NTAPI
KsSetInformationFile(
    IN PFILE_OBJECT FileObject,
    IN PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass
    )
/*++

Routine Description:

    Peforms an information set against the specified file object. This should only
    be used in cases where the set would result in an actual request to the
    underlying driver, not including complex operations which require additional
    parameters to be sent to the driver (such as rename, deletion, completion).
    For instance, FilePositionInformation would not generate such a request, and
    should not be used. Assumes the caller is serializing access to the file for
    operations against a FO_SYNCHRONOUS_IO file object.

    The function attempts to use FastIoDispatch if possible, else generates an
    information set against the device object.

Arguments:

    FileObject -
        Contains the file object to set the standard information on.

    FileInformation -
        Contains the file information. This is assumed to be a valid or probed
        address.

    Length -
        The correct length of the FileInformation buffer.

    FileInformationClass -
        The class of information being set.

Return Value:

    Returns STATUS_SUCCESS, else a set error.

--*/
{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    PDEVICE_OBJECT DeviceObject;
    PIRP Irp;
    KEVENT Event;
    PIO_STACK_LOCATION IrpStackNext;
    PVOID SystemBuffer;

    PAGED_CODE();
    DeviceObject = IoGetRelatedDeviceObject(FileObject);
    //
    // First allocate the buffer which the driver will use to read the file
    // information. This is cleaned up either by a failure to create an Irp,
    // or during Irp completion.
    //
    SystemBuffer = ExAllocatePoolWithTag(NonPagedPool, Length, 'fsSK');
    if (!SystemBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    try {
        RtlCopyMemory(SystemBuffer, FileInformation, Length);
    } except (EXCEPTION_EXECUTE_HANDLER) {
        ExFreePool(SystemBuffer);
        return GetExceptionCode();
    }
    KeClearEvent(&FileObject->Event);
    //
    // This is on the stack, but any wait for a pending return will be done using
    // KernelMode so the stack will be locked.
    //
    KeInitializeEvent(&Event, SynchronizationEvent, FALSE);
    //
    // Just build a random Irp so that it gets queued up properly.
    //
    Irp = IoBuildSynchronousFsdRequest(
        IRP_MJ_FLUSH_BUFFERS,
        DeviceObject,
        NULL,
        0,
        NULL,
        &Event,
        &IoStatusBlock);
    if (!Irp) {
        ExFreePool(SystemBuffer);
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    //
    // The parameters are always valid, so the Requestor is alway KernelMode.
    //
    Irp->RequestorMode = KernelMode;
    Irp->Tail.Overlay.OriginalFileObject = FileObject;
    Irp->Overlay.AsynchronousParameters.UserApcContext = NULL;
    Irp->UserBuffer = FileInformation;
    Irp->AssociatedIrp.SystemBuffer = SystemBuffer;
    //
    // Set this Irp to be a Synchronous API so that the Event passed is not
    // dereferenced during Irp completion, but merely signalled.
    //
    Irp->Flags |= IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER | IRP_SYNCHRONOUS_API;
    IrpStackNext = IoGetNextIrpStackLocation(Irp);
    IrpStackNext->MajorFunction = IRP_MJ_SET_INFORMATION;
    IrpStackNext->Parameters.SetFile.Length = Length;
    IrpStackNext->Parameters.SetFile.FileInformationClass = FileInformationClass;
    IrpStackNext->FileObject = FileObject;
    //
    // This is dereferenced by the completion routine.
    //
    ObReferenceObject(FileObject);
    Status = IoCallDriver(DeviceObject, Irp);
    if (Status == STATUS_PENDING) {
        //
        // An event was passed, so it will always be signalled. Either
        // retrieve the status from the file object itself, or from the
        // status block, depending on where it ends up. Since the file
        // I/O cannot really be canceled, just wait forever. Note that
        // this is a KernelMode wait so that the Event which is on the
        // stack becomes NonPaged.
        //
        KeWaitForSingleObject(
            &Event,
            Executive,
            KernelMode,
            FALSE,
            NULL);
        if (FileObject->Flags & FO_SYNCHRONOUS_IO) {
            Status = FileObject->FinalStatus;
        } else {
            Status = IoStatusBlock.Status;
        }
    }
    return Status;
}


KSDDKAPI
NTSTATUS
NTAPI
KsStreamIo(
    IN PFILE_OBJECT FileObject,
    IN PKEVENT Event OPTIONAL,
    IN PVOID PortContext OPTIONAL,
    IN PIO_COMPLETION_ROUTINE CompletionRoutine OPTIONAL,
    IN PVOID CompletionContext OPTIONAL,
    IN KSCOMPLETION_INVOCATION CompletionInvocationFlags OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN OUT PVOID StreamHeaders,
    IN ULONG Length,
    IN ULONG Flags,
    IN KPROCESSOR_MODE RequestorMode
    )
/*++

Routine Description:

    Peforms a stream read or write against the specified file object. The function
    attempts to use FastIoDispatch if possible, else generates a read or write
    request against the device object.

Arguments:

    FileObject -
        Contains the file object to perform the I/O against.

    Event -
        Optionally contains the event to use in the I/O. If none is passed, the
        call is assumed to be on a synchronous file object or the caller will wait
        on the file object's event, else it may be asynchronously completed. If used,
        and the KSSTREAM_SYNCHRONOUS flag is not set, this must be an event allocated
        by the object manager.

    PortContext -
        Optionally contains context information for a completion port.
        
    CompletionRoutine -
        Optionally points to a completion routine for this Irp.
        
    CompletionContext -
        If CompletionRoutine is specified, this provides a context pointer
        in the completion routine callback.
    
    CompletionInvocationFlags -
        Contains invocation flags specifying when the completion routine
        will be invoked (this value may be a combination of the following):

        KsInvokeOnSuccess - invokes the completion routine on success
        
        KsInvokeOnError - invokes the completion routine on error
        
        KsInvokeOnCancel - invokes the completion routine on cancellation

    IoStatusBlock -
        The place in which to return the status information. This is always
        assumed to be a valid address, regardless of the requestor mode.

    StreamHeaders -
        Contains the list of stream headers. This address, as well as the 
        addresses of the data buffers, are assumed to have been probed for 
        appropriate access if needed.  KernelMode clients submitting 
        streaming headers must allocate the headers from NonPagedPool memory.

    Length -
        Specifies the size of the StreamHeaders passed.

    Flags -
        Contains various flags for the I/O.

        KSSTREAM_READ - Specifies that an IOCTL_KS_STREAMREAD Irp is to be
        built. This is the default.

        KSSTREAM_WRITE - Specifies that an IOCTL_KS_STREAMWRITE Irp is to
        be built.

        KSSTREAM_PAGED_DATA - Specifies that the data is pageable. This is
        the default, and may be used at all times.

        KSSTREAM_NONPAGED_DATA - Specifies that the data is nonpaged, and
        can be used as a performance enhancement.

        KSSTREAM_SYNCHRONOUS - Specifies that the Irp is synchornous. This
        means that if the Event parameter is passed, it is not treated as an
        Object Manager event, and not referenced or dereferenced.

        KSSTREAM_FAILUREEXCEPTION - Specifies that failure within this
        function should produce an exception. A failure would generally be
        caused by a lack of pool to allocate an Irp. If this is not used,
        such a failure is indicated by setting the IoStatusBlock.Information
        field to -1, and returning the failure code.

    RequestorMode -
        Indicates the processor mode to place in the Irp if one is needs to be
        generated. This also determines if a fast I/O call can be performed. If the
        requestor mode is not KernelMode, but the previous mode is, then fast I/O
        cannot be used.

Return Value:

    Returns STATUS_SUCCESS, STATUS_PENDING, else an I/O error.

--*/
{
    PDEVICE_OBJECT DeviceObject;
    PIRP Irp;
    PIO_STACK_LOCATION IrpStackNext;

    PAGED_CODE();
    ASSERT(Length && "A non-zero I/O length must be passed by the driver");
    if (Event) {
        KeClearEvent(Event);
    }
    DeviceObject = IoGetRelatedDeviceObject(FileObject);
    //
    // Since there is no way for the recipient to determine the requestor mode other
    // than looking at PreviousMode, then if the requestor mode is not KernelMode,
    // and it does not match PreviousMode, Fast I/O cannot be used.
    //
    if ((RequestorMode != KernelMode) || (ExGetPreviousMode() == KernelMode)) {
        //
        // Check to see if there is even a Fast I/O dispatch table, and a Device
        // Control entry in it.
        //
        if (DeviceObject->DriverObject->FastIoDispatch && 
            DeviceObject->DriverObject->FastIoDispatch->FastIoDeviceControl) {
            //
            // Either the request was handled (by succeeding or failing), or it
            // could not be done synchronously, or by the Fast I/O handler.
            //
            if (DeviceObject->DriverObject->FastIoDispatch->FastIoDeviceControl(
                FileObject,
                TRUE,
                NULL,
                0,
                StreamHeaders,
                Length,
                (Flags & KSSTREAM_WRITE) ? IOCTL_KS_WRITE_STREAM : IOCTL_KS_READ_STREAM,
                IoStatusBlock,
                DeviceObject)) {
                return IoStatusBlock->Status;
            }
        }
    }
    //
    // Fast I/O did not work, so an Irp must be allocated.
    //
    KeClearEvent(&FileObject->Event);
    //
    // Just build a random Irp so that it gets queued up properly.
    //
    Irp = IoBuildSynchronousFsdRequest(
        IRP_MJ_FLUSH_BUFFERS,
        DeviceObject,
        NULL,
        0,
        NULL,
        Event,
        IoStatusBlock);
    if (!Irp) {
        //
        // Allocation of an Irp is allowed to fail if PreviousMode != KernelMode,
        // which of course is irrelevant to this function. In order to distinguish
        // between a failed Irp allocation, and an NT_ERROR() I/O call, both of
        // which do not update the IoStatusBlock.Status field, either the
        // Information field is set to a known value, or an exception is
        // generated. Of course this will be done immediately prior to the
        // machine failing because there is no more pool.
        //
        if (Flags & KSSTREAM_FAILUREEXCEPTION) {
            ExRaiseStatus(STATUS_INSUFFICIENT_RESOURCES);
        }
        //
        // Generation of an exception was not desired, so instead inform
        // the caller via the status block.
        //
        IoStatusBlock->Information = (ULONG_PTR)-1;
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    Irp->RequestorMode = RequestorMode;
    Irp->Tail.Overlay.OriginalFileObject = FileObject;
    Irp->Overlay.AsynchronousParameters.UserApcContext = PortContext;
    Irp->UserBuffer = StreamHeaders;
    IrpStackNext = IoGetNextIrpStackLocation(Irp);
    IrpStackNext->MajorFunction = IRP_MJ_DEVICE_CONTROL;
    IrpStackNext->Parameters.DeviceIoControl.OutputBufferLength = Length;
    if (Flags & KSSTREAM_WRITE) {
        IrpStackNext->Parameters.DeviceIoControl.IoControlCode = IOCTL_KS_WRITE_STREAM;
    } else {
        IrpStackNext->Parameters.DeviceIoControl.IoControlCode = IOCTL_KS_READ_STREAM;
    }
    IrpStackNext->FileObject = FileObject;
    if (Flags & KSSTREAM_SYNCHRONOUS) {
        //
        // Set this Irp to be a Synchronous API so that the Event passed is not
        // dereferenced during Irp completion, but merely signalled.
        //
        Irp->Flags |= IRP_SYNCHRONOUS_API;
    } else if (Event) {
        //
        // Since there is always a FileObject for this request, and the
        // Synchonous API flag was not set, so this event will be dereferenced
        // on completion.
        //
        ObReferenceObject(Event);
    }
    //
    // This is dereferenced by the completion routine.
    //
    ObReferenceObject(FileObject);
    
    //
    // If the completion routine has been specified, then set it up.
    //
    
    if (ARGUMENT_PRESENT( CompletionRoutine )) {
        IoSetCompletionRoutine( 
            Irp,
            CompletionRoutine,
            CompletionContext,
            CompletionInvocationFlags & KsInvokeOnSuccess,
            CompletionInvocationFlags & KsInvokeOnError,
            CompletionInvocationFlags & KsInvokeOnCancel );
    }
    
    //
    // Need to build Mdl's for nonpaged data.
    //
    //KSSTREAM_NONPAGED_DATA
    //
    return IoCallDriver(DeviceObject, Irp);
}


KSDDKAPI
NTSTATUS
NTAPI
KsProbeStreamIrp(
    IN OUT PIRP Irp,
    IN ULONG ProbeFlags,
    IN ULONG HeaderSize OPTIONAL
    )
/*++

Routine Description:

    Makes the specified modifications to the given IRP's input and output
    buffers based on the specific streaming IOCTL in the current stack
    location, and validates the stream header. This is useful when
    localizing exception handling, or performing asynchronous work on the
    Irp. The Irp end up in essentially the METHOD_OUT_DIRECT or
    METHOD_IN_DIRECT format, with the exception that the access to the data
    buffer may be IoModifyAccess depending on the flags passed to this
    function or in the stream header. If the header appears to have already
    been copied to a system buffer it is not validated again. In general
    calling this function multiple times with an Irp will not cause harm.
    After calling this function, the stream headers are available in
    PIRP->AssociatedIrp.SystemBuffer. If the stream buffers MDL's have been
    allocated, they are available through the PIRP->MdlAddress. Note that
    for kernelmode IRP sources, the header is not copied nor validated. This
    means that if an in-place data transform has been negotiated, not only
    will the data buffers be modified, but so will the headers.

Arguments:

    Irp -
        Contains the Irp whose input and output buffers are to be mapped. The
        requestor mode of the Irp will be used in probing the buffers.

    ProbeFlags -
        Contains flags specifying how to probe the streaming Irp.

        KSPROBE_STREAMREAD -
            Indicates that the operation is a stream read on the device. This
            is the default.

        KSPROBE_STREAMWRITE -
            Indicates that the operation is a stream write on the device.

        KSPROBE_STREAMWRITEMODIFY -
            Indicates that the operation is a stream write on the device, which
            is modifying the data for passthu.

        KSPROBE_ALLOCATEMDL -
            Indicates that MDL's should be allocated for the stream buffers if
            they have not already allocated. If no stream buffers are present,
            the flag is ignored. If KSPROBE_PROBEANDLOCK is not specified at
            the same time as this flag, the caller must have a completion routine
            in order to clean up any MDL's if not all the MDL's were successfully
            probed and locked.

        KSPROBE_PROBEANDLOCK -
            If the KSPROBE_ALLOCATEMDL is set, indicates that the memory
            referenced by the MDL's for the stream buffers should be probed and
            locked. If the Mdl allocation flag is not set, this flag is ignored,
            even if the Mdl allocation has previously taken place. The method of
            probing is determined by what type of Irp is being passed. For a
            write operation IoReadAccess is used. For a read operation is
            IoWriteAccess is used. If the client which sent the data is using the
            NonPagedPool, appropriate Mdl's are initialized rather than probing
            and locking.

        KSPROBE_SYSTEMADDRESS -
            Retrieve a system address for each Mdl in the chain so that the
            caller need not do this in a separate step. This is ignored if the
            Probe and Lock flag is not set, even if the Mdl's have previously
            been probed.

        KSPROBE_ALLOWFORMATCHANGE -
            For a Stream Write, allows the KSSTREAM_HEADER_OPTIONSF_TYPECHANGED
            flag to be set in the stream header. This implies that the stream
            header is not of extended length, even if an extended header size
            was indicated. Also, there may only be one stream header contained
            in the Irp in this case.

    HeaderSize -
        The size to validate each header header against passed to this client,
        or zero if no validation is to be done. If used, it is assumed that
        the entire buffer passed is a multiple of this header size, unless
        the buffer instead contains a single format change header.

Return Value:

    Returns STATUS_SUCCESS, else some resource or access error.

--*/
{
    PIO_STACK_LOCATION IrpStack;

    ASSERT((KeGetCurrentIrql() == PASSIVE_LEVEL) && "Driver did not call at Passive level");
    ASSERT((!HeaderSize || (HeaderSize >= sizeof(KSSTREAM_HEADER))) && "Invalid header size passed");
    ASSERT(!(HeaderSize & FILE_QUAD_ALIGNMENT) && "Odd aligned header size passed");
    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    //
    // Determine if the stream header has already been dealt with by a previous
    // call to this function.
    //
    if (!Irp->AssociatedIrp.SystemBuffer) {
        if (Irp->RequestorMode == KernelMode) {
            //
            // The caller is trusted, so assume that the size of the
            // buffer is correct and aligned properly. This means that a
            // copy of the headers is not needed, so the SystemBuffer
            // just points directly at the UserBuffer.
            //
            Irp->AssociatedIrp.SystemBuffer = Irp->UserBuffer;
        } else {
            ULONG BufferLength;

            //
            // The caller is not trusted, so verify the size, and make
            // a copy to guard against access and alignment problems.
            //
            BufferLength = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;
            if (!BufferLength) {
                return STATUS_INVALID_BUFFER_SIZE;
            }
            if (HeaderSize && (BufferLength % HeaderSize)) {
                //
                // This could be a data format change. Determine if such a
                // change is even allowed, and if it is, that there is only
                // a single header present. This should only be occuring on
                // a write operation.
                //
                if (!(ProbeFlags & KSPROBE_ALLOWFORMATCHANGE) || (BufferLength != sizeof(KSSTREAM_HEADER))) {
                    //
                    // Obviously not the correct size since the buffer size is not
                    // evenly divisible by the header size, and it is not a format
                    // change.
                    //
                    // Header sizes have been causing problems, so assert this
                    // here so that they can be fixed.
                    //
                    ASSERT(FALSE && "Format changes are not allowed, but the client of the driver might be trying to do so");
                    return STATUS_INVALID_BUFFER_SIZE;
                }
            }
            try {
                //
                // Allocate the safe and aligned buffer, then probe the UserBuffer
                // for access depending on the operation being done. Set the flags
                // to ensure the buffer is cleaned up on completion of the Irp.
                //
                Irp->AssociatedIrp.SystemBuffer = ExAllocatePoolWithQuotaTag(
                    NonPagedPool,
                    BufferLength,
                    KSSIGNATURE_STREAM_HEADERS);
                Irp->Flags |= (IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER);
                if (ProbeFlags & KSPROBE_STREAMWRITE) {
                    //
                    // A transform may need to perform in-place modification of
                    // the data, and pass it on.
                    //
                    if (ProbeFlags & KSPROBE_MODIFY) {
                        ProbeForWrite(Irp->UserBuffer, BufferLength, sizeof(BYTE));
                    } else {
                        ProbeForRead(Irp->UserBuffer, BufferLength, sizeof(BYTE));
                    }
                } else {
                    ASSERT(!(ProbeFlags & KSPROBE_MODIFY) && "Random flag has been set");
                    ASSERT(!(ProbeFlags & KSPROBE_ALLOWFORMATCHANGE) && "Cannot do a format change on a read");
                    ProbeForWrite(Irp->UserBuffer, BufferLength, sizeof(BYTE));
                    //
                    // Ensure that the headers are copied back to the UserBuffer
                    // on completion of the Irp.
                    //
                    Irp->Flags |= IRP_INPUT_OPERATION;
                }
                //
                // Always copy the original header information, since the buffer
                // pointer, length, and flags are needed, and possibly media-
                // specific data at the end of the standard header.
                //
                RtlCopyMemory(
                    Irp->AssociatedIrp.SystemBuffer, 
                    Irp->UserBuffer, 
                    BufferLength);
                //
                // If the buffers will not be validated later, do it now.
                //
                if (!(ProbeFlags & KSPROBE_ALLOCATEMDL)) {
                    PUCHAR SystemBuffer;

                    //
                    // Walk through the list of headers and validate the
                    // buffer size specified.
                    //
                    SystemBuffer = 
                        Irp->AssociatedIrp.SystemBuffer;
                    for (; BufferLength;) {
                        PKSSTREAM_HEADER StreamHdr;

                        StreamHdr = (PKSSTREAM_HEADER)SystemBuffer;
                        //
                        // Ensure for read or write that the specified header
                        // size matches that given, if any, or is at least
                        // large enough for a header and aligned.
                        //
                        if (HeaderSize) {
                            if ((StreamHdr->Size != HeaderSize) && !(StreamHdr->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_TYPECHANGED)) {
                                ASSERT(FALSE && "The client of the driver passed invalid header sizes");
                                ExRaiseStatus(STATUS_INVALID_BUFFER_SIZE);
                            }
                        } else if ((StreamHdr->Size < sizeof(*StreamHdr)) ||
                            (StreamHdr->Size & FILE_QUAD_ALIGNMENT)) {
                            ExRaiseStatus(STATUS_INVALID_BUFFER_SIZE);
                        }
                        if (BufferLength < StreamHdr->Size) {
                            ExRaiseStatus(STATUS_INVALID_BUFFER_SIZE);
                        }
                        if (ProbeFlags & KSPROBE_STREAMWRITE) {
                            //
                            // Check DataUsed vs. the DataExtent
                            //
                            if (StreamHdr->DataUsed > StreamHdr->FrameExtent) {
                                ExRaiseStatus(STATUS_INVALID_BUFFER_SIZE);
                            }
                            if (StreamHdr->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_TYPECHANGED) {
                                //
                                // The format change flag is set. This means that
                                // there can only be a single header of standard
                                // length, and the change must be allowed.
                                //
                                if ((BufferLength != sizeof(*StreamHdr)) || (SystemBuffer != Irp->AssociatedIrp.SystemBuffer)) {
                                    ExRaiseStatus(STATUS_INVALID_BUFFER_SIZE);
                                }
                                if (!(ProbeFlags & KSPROBE_ALLOWFORMATCHANGE)) {
                                    ExRaiseStatus(STATUS_INVALID_PARAMETER);
                                }
                                //
                                // There are no other headers, so exit this loop.
                                //
                                break;
                            }
                        } else if (StreamHdr->DataUsed) {
                            //
                            // Else this is a read operation. DataUsed should
                            // initially be zero.
                            //
                            ExRaiseStatus(STATUS_INVALID_BUFFER_SIZE);
                        } else if (StreamHdr->OptionsFlags) {
                            //
                            // No flags should be set on a Read.
                            //
                            ExRaiseStatus(STATUS_INVALID_PARAMETER);
                        }
                        //
                        // Advance to the next header.
                        //
                        SystemBuffer += StreamHdr->Size;
                        BufferLength -= StreamHdr->Size;
                    }
                }
                
            } except (EXCEPTION_EXECUTE_HANDLER) {
                return GetExceptionCode();
            }
        }
    }
    //
    // Each buffer in the header list may need to have an MDL allocated,
    // and possibly locked.
    //
    if (ProbeFlags & KSPROBE_ALLOCATEMDL) {
        BOOL AllocatedMdl;

        try {
            //
            // Only allocate MDL's if they have not already been allocated.
            //
            if (!Irp->MdlAddress) {
                ULONG BufferLength;
                PUCHAR SystemBuffer;

                //
                // Note that there previously was no Mdl list attached to
                // this Irp. This is used in case cleanup is needed, and
                // it is necessary to know whether or not to free the MDL's.
                //
                AllocatedMdl = TRUE;
                //
                // Walk through the list of headers and allocate an MDL
                // if there is a buffer present. If none present, just
                // continue to the next item.
                //
                SystemBuffer = Irp->AssociatedIrp.SystemBuffer;
                BufferLength = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;
                for (; BufferLength;) {
                    PVOID Data;
                    PKSSTREAM_HEADER StreamHdr;

                    StreamHdr = (PKSSTREAM_HEADER)SystemBuffer;
                    //
                    // Ensure for read or write that the specified header
                    // size matches that given, if any, or is at least
                    // large enough for a header and aligned.
                    //
                    if (HeaderSize) {
                        if ((StreamHdr->Size != HeaderSize) && !(StreamHdr->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_TYPECHANGED)) {
                            ASSERT(FALSE && "The client of the driver passed invalid header sizes");
                            ExRaiseStatus(STATUS_INVALID_BUFFER_SIZE);
                        }
                    } else if ((StreamHdr->Size < sizeof(*StreamHdr)) ||
                        (StreamHdr->Size & FILE_QUAD_ALIGNMENT)) {
                        ExRaiseStatus(STATUS_INVALID_BUFFER_SIZE);
                    }
                    if (BufferLength < StreamHdr->Size) {
                        ExRaiseStatus(STATUS_INVALID_BUFFER_SIZE);
                    }
                    if (ProbeFlags & KSPROBE_STREAMWRITE) {
                        //
                        // Check DataUsed vs. the FrameExtent
                        //
                        
                        if (((PKSSTREAM_HEADER)SystemBuffer)->DataUsed >
                                StreamHdr->FrameExtent) {
                            ExRaiseStatus(STATUS_INVALID_BUFFER_SIZE);
                        }
                        if (StreamHdr->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_TYPECHANGED) {
                            //
                            // The format change flag is set. This means that
                            // there can only be a single header of standard
                            // length, and the change must be allowed.
                            //
                            if ((BufferLength != sizeof(*StreamHdr)) || (SystemBuffer != Irp->AssociatedIrp.SystemBuffer)) {
                                ExRaiseStatus(STATUS_INVALID_BUFFER_SIZE);
                            }
                            if (!(ProbeFlags & KSPROBE_ALLOWFORMATCHANGE)) {
                                ExRaiseStatus(STATUS_INVALID_PARAMETER);
                            }
                            if (StreamHdr->FrameExtent) {
                                Data = ((PKSSTREAM_HEADER)SystemBuffer)->Data;
                                //
                                // Allocate the MDL. This should be the only MDL,
                                // so no need to check for any current ones.
                                //
                                if (!IoAllocateMdl(Data, StreamHdr->FrameExtent, FALSE, TRUE, Irp)) {
                                    ExRaiseStatus(STATUS_INSUFFICIENT_RESOURCES);
                                }
                            }
                            //
                            // There are no other headers, so exit this loop.
                            //
                            break;
                        }
                    } else if (StreamHdr->DataUsed) {
                        //
                        // Else this is a read operation. DataUsed should
                        // initially be zero.
                        //
                        ExRaiseStatus(STATUS_INVALID_BUFFER_SIZE);
                    } else if (StreamHdr->OptionsFlags) {
                        //
                        // No flags should be set on a Read.
                        //
                        ExRaiseStatus(STATUS_INVALID_PARAMETER);
                    }
                    if (StreamHdr->FrameExtent) {
                        Data = ((PKSSTREAM_HEADER)SystemBuffer)->Data;
                        //
                        // Allocate the MDL and put it on the end of the list,
                        // or as the start of the MDL list if this is the first
                        // one.
                        //
                        if (!IoAllocateMdl(Data, StreamHdr->FrameExtent, (BOOLEAN)(Irp->MdlAddress ? TRUE : FALSE), TRUE, Irp)) {
                            ExRaiseStatus(STATUS_INSUFFICIENT_RESOURCES);
                        }
                    }
                    //
                    // Advance to the next header.
                    //
                    SystemBuffer += StreamHdr->Size;
                    BufferLength -= StreamHdr->Size;
                }
            } else {
                //
                // No cleanup of MDL's is needed on failure.
                //
                AllocatedMdl = FALSE;
            }
            //
            // If the pages are to be locked, determine if they have not
            // already been locked, and that there actually are some to lock.
            // If the data is from another KernelMode client which deals
            // with Mdl's, then it must already ensure that locking and
            // unlocking will not be affected by this operation (i.e., it
            // needs to have a completion routine to clean up).
            //
            if ((ProbeFlags & KSPROBE_PROBEANDLOCK) && Irp->MdlAddress) {
                //
                // The pages may already have been locked, or they may be
                // non-paged.
                //
                if (!(Irp->MdlAddress->MdlFlags & (MDL_PAGES_LOCKED | MDL_SOURCE_IS_NONPAGED_POOL))) {
                    LOCK_OPERATION LockOperation;
                    PMDL Mdl;

                    //
                    // A write operation needs Read access, and a read operation
                    // needs Write access, excepting when in-place modification
                    // also is needed.
                    //
                    if ((ProbeFlags & KSPROBE_STREAMWRITE) && !(ProbeFlags & KSPROBE_MODIFY)) {
                        LockOperation = IoReadAccess;
                    } else {
                        LockOperation = IoWriteAccess;
                    }
                    //
                    // Run through the list of Mdl's, locking and probing each one.
                    //
                    for (Mdl = Irp->MdlAddress; Mdl; Mdl = Mdl->Next) {
                        MmProbeAndLockPages(Mdl, Irp->RequestorMode, LockOperation);
                        //
                        // Get the system VA at the same time if needed.
                        // Only bother testing this for pageable memory.
                        //
                        if (ProbeFlags & KSPROBE_SYSTEMADDRESS) {
                            Mdl->MdlFlags |= MDL_MAPPING_CAN_FAIL;
                            if (!MmGetSystemAddressForMdl(Mdl)) {
                                ExRaiseStatus(STATUS_INSUFFICIENT_RESOURCES);
                            }
                        }
                    }
                } else if (ProbeFlags & KSPROBE_SYSTEMADDRESS) {
                    PMDL Mdl;

                    //
                    // Run through the list of Mdl's, getting the system VA
                    // when necessary. The macro checks to make sure this is
                    // not non-paged memory.
                    //
                    for (Mdl = Irp->MdlAddress; Mdl; Mdl = Mdl->Next) {
                        Mdl->MdlFlags |= MDL_MAPPING_CAN_FAIL;
                        if (!MmGetSystemAddressForMdl(Mdl)) {
                            ExRaiseStatus(STATUS_INSUFFICIENT_RESOURCES);
                        }
                    }
                }
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            //
            // If no MDL list was previously associated with this Irp, then
            // remove any MDL's actually allocated. If they had been previously
            // allocated, then the assumption is that a completion routine
            // must perform the cleanup.
            //
            if (AllocatedMdl) {
                PMDL Mdl;

                for (; Mdl = Irp->MdlAddress;) {
                    if (Mdl->MdlFlags & MDL_PAGES_LOCKED) {
                        MmUnlockPages(Mdl);
                    }
                    Irp->MdlAddress = Mdl->Next;
                    IoFreeMdl(Mdl);
                }
            }
            return GetExceptionCode();
        }
    }
    return STATUS_SUCCESS;
}


KSDDKAPI
NTSTATUS
NTAPI
KsAllocateExtraData(
    IN OUT PIRP Irp,
    IN ULONG ExtraSize,
    OUT PVOID* ExtraBuffer
    )
/*++

Routine Description:

    Used with streaming Irp's to allocate extra data containing each
    header separated by the specified extra size. A pointer to the resultant
    buffer is returned, and must be freed by the caller.

Arguments:

    Irp -
        Contains the Irp containing the stream headers. This must have been
        previously passed to KsProbeStreamIrp to buffer the headers.

    ExtraSize -
        The size of any extra data. A copy of the headers is placed in the
        returned buffer, with the extra data size inserted between each header.
        This must be freed by the caller.

    ExtraBuffer -
        The place in which to put the pointer to the buffer returned. This
        must be freed by the caller.

Return Value:

    Returns STATUS_SUCCESS, else some resource error.

--*/
{
    PIO_STACK_LOCATION IrpStack;
    ULONG AllocationSize;
    ULONG HeaderCount;
    ULONG BufferLength;
    PUCHAR LocalExtraBuffer;
    PUCHAR SystemBuffer;

    PAGED_CODE();
    ASSERT(!(ExtraSize & FILE_QUAD_ALIGNMENT) && "The extra data allocation must be quad aligned");
    ASSERT(Irp->AssociatedIrp.SystemBuffer && "The Irp has not been probed yet");
    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    BufferLength = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;
    SystemBuffer = Irp->AssociatedIrp.SystemBuffer;
    AllocationSize = 0;
    HeaderCount = 0;
    //
    // Add up the number of headers and the size of each header.
    //
    for (; BufferLength;) {
        PKSSTREAM_HEADER StreamHdr;

        StreamHdr = (PKSSTREAM_HEADER)SystemBuffer;
        AllocationSize += StreamHdr->Size;
        SystemBuffer += StreamHdr->Size;
        BufferLength -= StreamHdr->Size;
        HeaderCount++;
    }
    if (Irp->RequestorMode == KernelMode) {
        //
        // This is a trusted client, so just allocate with no quota.
        //
        LocalExtraBuffer = ExAllocatePoolWithTag(
            NonPagedPool,
            AllocationSize + HeaderCount * ExtraSize,
            KSSIGNATURE_AUX_STREAM_HEADERS);
        if (!LocalExtraBuffer) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    } else {
        //
        // Else this is part of quota just like an Irp.
        //
        try {
            LocalExtraBuffer = ExAllocatePoolWithQuotaTag(
                NonPagedPool,
                AllocationSize + HeaderCount * ExtraSize,
                KSSIGNATURE_AUX_STREAM_HEADERS);
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }
    }
    *ExtraBuffer = LocalExtraBuffer;
    SystemBuffer = Irp->AssociatedIrp.SystemBuffer;
    BufferLength = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;
    //
    // Copy the each header, then skip past the extra space
    // being inserted between the headers.
    //
    for (; BufferLength;) {
        PKSSTREAM_HEADER StreamHdr;

        StreamHdr = (PKSSTREAM_HEADER)SystemBuffer;
        RtlCopyMemory(LocalExtraBuffer, SystemBuffer, StreamHdr->Size);
        SystemBuffer += StreamHdr->Size;
        BufferLength -= StreamHdr->Size;
        LocalExtraBuffer += StreamHdr->Size + ExtraSize;
    }
    return STATUS_SUCCESS;
}


KSDDKAPI
PIRP
NTAPI
KsRemoveIrpFromCancelableQueue(
    IN OUT PLIST_ENTRY QueueHead,
    IN PKSPIN_LOCK SpinLock,
    IN KSLIST_ENTRY_LOCATION ListLocation,
    IN KSIRP_REMOVAL_OPERATION RemovalOperation
    )
/*++

Routine Description:

    Pops the next non-canceled Irp from the specified cancelable 
    queue, and removes its cancelable status. Continues through the list until
    an Irp is found which has a cancel routine, or the end of the list is
    reached. This function minimizes the use of the Cancel Spinlock by using the
    provided spinlock to synchronize access in most cases. This function may be
    called at <= DISPATCH_LEVEL.

Arguments:

    QueueHead -
        Contains the head of the queue from which to remove the Irp.

    SpinLock -
        Pointer to driver's spin lock for queue access.

    ListLocation -
        Indicates whether this Irp should come from the head or the tail of
        the queue.

    RemovalOperation -
        Specifies whether or not the Irp is removed from the list, or just
        acquired by setting the cancel function to NULL. If it is only acquired,
        it must be later released with KsReleaseIrpOnCancelableQueue, or
        completely remove with KsRemoveSpecificIrpFromCancelableQueue. Also
        specifies whether only a single item can be acquired from the list at
        one time.

Return Value:

    Returns the next available Irp on the list, or NULL if the list is empty
    or an Irp which has not already been acquired cannot be found. If the
    KsAcquireOnlySingleItem or KsAcquireAndRemoveOnlySingleItem flag is being
    used, only one item is allowed to be acquired from the list at a time. This
    allows for re-entrancy checking.

--*/
{
    KIRQL oldIrql;
    PIRP IrpReturned;
    PLIST_ENTRY ListEntry;

    //
    // Indicate that an Irp has not been found yet.
    //
    IrpReturned = NULL;
    ListEntry = QueueHead;
    //
    // Acquire the lock for the queue so that it can be enumerated
    // to find an Irp which has not been acquired.
    //
    KeAcquireSpinLock(SpinLock, &oldIrql);
    //
    // Enumerate the list for the first entry which has not already been
    // acquired. Move either from the front of the list down, or the tail
    // of the list up.
    //
    for (; (ListEntry = ((ListLocation == KsListEntryHead) ? ListEntry->Flink : ListEntry->Blink)) != QueueHead;) {
        PIRP Irp;

        Irp = CONTAINING_RECORD(ListEntry, IRP, Tail.Overlay.ListEntry);
        //
        // An entry on the list has been acquired if it does not have a
        // cancel routine set. So if the entry is still set, then it has
        // now been acquired and can be returned by this function. Else
        // skip to the next entry. This is an interlocked operation.
        //
        if (IoSetCancelRoutine(Irp, NULL)) {
            //
            // The request may be to entirely remove the entry from the list.
            // Otherwise the request is just to acquire the entry, while
            // leaving it on the list in case it needs to maintain its position
            // while work is being done on it.
            //
            // Note that this and the below comparison make assumptions on the
            // bit pattern of KSIRP_REMOVAL_OPERATION.
            //
            if (RemovalOperation & KsAcquireAndRemove) {
                RemoveEntryList(ListEntry);
            }
            IrpReturned = Irp;
            break;
        } else if (RemovalOperation & KsAcquireOnlySingleItem) {
            //
            // Only a single item from this list is supposed to be acquired at one
            // time. Since the Cancel routine was reset, this could mean that
            // either an Irp is being canceled at this time, but held up because
            // this function has the list lock, or the Irp was previously acquired.
            // In the first case there may or may not be an Irp in use. In the
            // second, the Cancel flag can be checked.
            //
            if (!Irp->Cancel) {
                //
                // Obviously this Irp is in use, since it is still present on the
                // queue, even though the cancel flag has been set. Therefore
                // no Irp can be returned.
                //
                break;
            }
            //
            // Acquiring the Cancel Spinlock can no longer be avoided.
            //
            // To see if an Irp has actually been acquired on the list, the Cancel
            // Spinlock must be acquired in order to synchronize with any
            // cancelation that might be occuring. Then the list lock is acquired
            // to stop list changes. Note that it must be done in this order so
            // that a deadlock does not occur with a cancel routine, which also
            // acquires the locks in this order.
            //
            KeReleaseSpinLock(SpinLock, oldIrql);
            //
            // Now synchronize with any cancelation, and with list changes.
            //
            IoAcquireCancelSpinLock(&oldIrql);
            KeAcquireSpinLockAtDpcLevel(SpinLock);
            //
            // Retrieve the first item. Either it will be free, or in use, but it
            // won't be in the middle of being canceled.
            //
            ListEntry = (ListLocation == KsListEntryHead) ? QueueHead->Flink : QueueHead->Blink;
            //
            // There might however not be any entries on the list anymore.
            //
            if (ListEntry != QueueHead) {
                Irp = CONTAINING_RECORD(ListEntry, IRP, Tail.Overlay.ListEntry);
                //
                // Attempt to acquire the list entry. If this fails the Irp is
                // definitely in use, and therefore this function should return NULL.
                //
                if (IoSetCancelRoutine(Irp, NULL)) {
                    //
                    // Again assuming the bit pattern of KSIRP_REMOVAL_OPERATION.
                    //
                    if (RemovalOperation & KsAcquireAndRemove) {
                        RemoveEntryList(ListEntry);
                    }
                    IrpReturned = Irp;
                }
            }
            KeReleaseSpinLockFromDpcLevel(SpinLock);
            IoReleaseCancelSpinLock(oldIrql);
            return IrpReturned;
        }
    }
    KeReleaseSpinLock(SpinLock, oldIrql);
    return IrpReturned;
}


KSDDKAPI
NTSTATUS
NTAPI
KsMoveIrpsOnCancelableQueue(
    IN OUT PLIST_ENTRY SourceList,
    IN PKSPIN_LOCK SourceLock,
    IN OUT PLIST_ENTRY DestinationList,
    IN PKSPIN_LOCK DestinationLock OPTIONAL,
    IN KSLIST_ENTRY_LOCATION ListLocation,
    IN PFNKSIRPLISTCALLBACK ListCallback,
    IN PVOID Context
    )
/*++

Routine Description:

    Moves the specified Irp's from the SourceList to the DestinationList. An
    Irp is moved if the ListCallback function indicates that it should be moved,
    whether or not it is currently acquired. Continues through the list until
    the callback indicates that the search should be terminated, or the end of
    the list is reached. This function minimizes the use of the Cancel
    Spinlock by using the provided spinlocks to synchronize access when
    possible. The function does not allow the cancel routine to be modified
    while moving Irp's. This function may be called at <= DISPATCH_LEVEL.

Arguments:

    SourceList -
        Contains the head of the queue from which to remove the Irp's.

    SourceLock -
        Pointer to driver's spin lock for source queue access.

    DestinationList -
        Contains the head of the queue on which to add the Irp's.

    DestinationLock -
        Optionally contains a pointer to driver's spin lock for destination
        queue access. If this is not provided, the SourceLock is assumed to
        control both queues. If provided, this lock is always acquired after
        the SourceLock. If the destination list has a separate spinlock, the
        Cancel Spinlock is first acquired in order to move Irp's and allow
        the KSQUEUE_SPINLOCK_IRP_STORAGE() spinlock to be updated.

    ListLocation -
        Indicates whether the Irp's should be enumerated from the head or the
        tail of the source queue. Any Irp's which are moved are placed on the
        destination queue's opposite end so that ordering is maintained.

    ListCallback -
        Callback used to indicate whether or not a specific Irp should be
        moved from SourceList to DestinationList, or if enumeration should
        be terminated. If the function returns STATUS_SUCCESS, the Irp is
        moved. If the function returns STATUS_NO_MATCH, the Irp is not
        moved. Any other return warning or error value will terminate
        enumeration and be returned by the function. The STATUS_NO_MATCH
        value will not be returned as an error by the function. This function
        is called at DISPATCH_LEVEL. It is always called at least once at the
        end with a NULL Irp value in order to complete list processing.

    Context -
        Context passed to ListCallback.

Return Value:

    Returns STATUS_SUCCESS if the list was completely enumerated, else
    returns any warning or error returned by ListCallback which interrupted
    enumeration.

--*/
{
    KIRQL oldIrql;
    NTSTATUS Status;
    PLIST_ENTRY ListEntry;

    //
    // Initialize the return status to Success in case there are no Irp's
    // in the source list.
    //
    Status = STATUS_SUCCESS;
    ListEntry = SourceList;
    if (DestinationLock) {
        //
        // The Cancel Spinlock must be acquired in order to stop Irp's from
        // being canceled while being tested for moving from the source list
        // to the destination list. If this lock is not acquired, then each
        // Irp would have to be acquired before determining if it should be
        // moved from one list to another, since the spinlock in the Irp must
        // be changed if a separate spinlock is used for the destination list.
        // If the move test failed, then the Irp would have to be released,
        // which means it could have been canceled in that period, and would
        // have to be completed, which implies calling the cancel routine,
        // which means releasing the list lock.
        //
        IoAcquireCancelSpinLock(&oldIrql);
        //
        // Acquire the lock for the source queue so that it can be enumerated
        // to find Irp's which have not been acquired.
        //
        KeAcquireSpinLockAtDpcLevel(SourceLock);
        KeAcquireSpinLockAtDpcLevel(DestinationLock);
    } else {
        KeAcquireSpinLock(SourceLock, &oldIrql);
    }
    //
    // Enumerate all entries in the list, whether or not they have been
    // acquired. Move either from the front of the list down, or the tail
    // of the list up.
    //
    for (; (ListEntry = ((ListLocation == KsListEntryHead) ? ListEntry->Flink : ListEntry->Blink)) != SourceList;) {
        PIRP Irp;

        Irp = CONTAINING_RECORD(ListEntry, IRP, Tail.Overlay.ListEntry);
        //
        // Determine if this Irp should be moved. A successful return indicates
        // that it should be. A status of STATUS_NO_MATCH indicates that this
        // Irp should be skipped. Any other warning or error return indicates
        // that the enumeration should be aborted and the status returned.
        //
        Status = ListCallback(Irp, Context);
        if (NT_SUCCESS(Status)) {
            //
            // Move the current list entry back to the previous entry.
            //
            ListEntry = (ListLocation == KsListEntryHead) ? ListEntry->Blink : ListEntry->Flink;
            //
            // Update the cancel spinlock to be used for this Irp. This is
            // needed later in canceling the Irp. If this is being updated,
            // the Cancel Spinlock has already been acquired, so it is not
            // possible that a cancel function is currently attempting to
            // acquire this spinlock that is about to be changed.
            //
            if (DestinationLock) {
                KSQUEUE_SPINLOCK_IRP_STORAGE(Irp) = DestinationLock;
            }
            //
            // Actually move the Irp to the DestinationList.
            //
            RemoveEntryList(&Irp->Tail.Overlay.ListEntry);
            //
            // Do this opposite of the removal so that order of items is
            // maintained.
            //
            if (ListLocation != KsListEntryHead) {
                InsertHeadList(DestinationList, &Irp->Tail.Overlay.ListEntry);
            } else {
                InsertTailList(DestinationList, &Irp->Tail.Overlay.ListEntry);
            }
        } else if (Status == STATUS_NO_MATCH) {
            //
            // Set the status back to Success, since this get returned when
            // the enumeration is completed.
            //
            Status = STATUS_SUCCESS;
        } else {
            //
            // Some type of failure occurred in the comparison, so abort the
            // enumeration and return the status.
            //
            break;
        }
    }
    //
    // Notify the callback that the end of the list has been reached. This
    // must always be called, and the return value is ignored.
    //
    ListCallback(NULL, Context);
    //
    // Release locks depending on how they were acquired above.
    //
    if (DestinationLock) {
        KeReleaseSpinLockFromDpcLevel(DestinationLock);
        KeReleaseSpinLockFromDpcLevel(SourceLock);
        IoReleaseCancelSpinLock(oldIrql);
    } else {
        KeReleaseSpinLock(SourceLock, oldIrql);
    }
    return Status;
}


KSDDKAPI
VOID
NTAPI
KsRemoveSpecificIrpFromCancelableQueue(
    IN PIRP Irp
    )
/*++

Routine Description:

    Removes the specified Irp from the specified queue. This is performed on
    an Irp which was previously acquired using KsRemoveIrpFromCancelableQueue,
    but which was not actually removed from the queue. This function may be
    called at <= DISPATCH_LEVEL.

Arguments:

    Irp -
        Pointer to I/O request packet.

Return Value:

    Nothing.

--*/
{
    KIRQL oldIrql;

    KeAcquireSpinLock(KSQUEUE_SPINLOCK_IRP_STORAGE(Irp), &oldIrql);
    //
    // The assumption is that this Irp has already been acquired by a previous
    // call to KsRemoveIrpFromCancelableQueue, which would have set the cancel
    // routine to NULL, but not removed it from the queue. The Irp may have
    // been canceled, but that is of no concern at this point.
    //
    ASSERT((NULL == IoSetCancelRoutine(Irp, NULL)) && "The Irp being removed was never acquired");
    RemoveEntryList(&Irp->Tail.Overlay.ListEntry);
    KeReleaseSpinLock(KSQUEUE_SPINLOCK_IRP_STORAGE(Irp), oldIrql);
}


KSDDKAPI
VOID
NTAPI
KsCancelRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Performs standard Irp cancel functionality, and is defined as a
    PDRIVER_CANCEL routine. This is the default function used for
    KsAddIrpToCancelableQueue if none is provided. It removes the
    entry, cancels and completes the request. This would normally be
    called by the I/O subsystem on canceling an Irp. As any normal
    cancel routine, this function expects the cancel spin lock to have
    been acquired upon entering the function.

    Note that this routine expects that the KSQUEUE_SPINLOCK_IRP_STORAGE(Irp)
    point to the list access spinlock as provided in KsAddIrpToCancelableQueue.

    Note that this routine can be used to do the preliminary list removal
    processing, without actually completing the Irp. If the
    Irp->IoStatus.Status is set to STATUS_CANCELLED on entering this function,
    then the Irp will not be completed. Else the status will be set to
    STATUS_CANCELLED and the Irp will be completed. This means that this
    routine can be used within a cancel routine to do the initial list and
    spinlock manipulation, and return to the driver's completion routine to
    do specific processing, and final Irp completion.

Arguments:

    DeviceObject -
        Contains the device object which owns the Irp.

    Irp -
        Contains the Irp being canceled.

Return Value:

    Nothing.

--*/
{
    PKSPIN_LOCK SpinLock;

    //
    // The list lock was previously placed here by KsAddIrpToCancelableQueue.
    // By acquiring this lock first, then releasing the Cancel Spinlock, there
    // is no window of opportunity for the Irp to have been canceled by any
    // other thread of execution. Any other cancel request, or list modification
    // must acquire the list lock before doing such. But by releasing the Cancel
    // Spinlock, the system is not held up as much, plus it is not needed for
    // normal non-canceling operations. This is the place then that everything
    // is synchronized with the Cancel Spinlock.
    //
    SpinLock = KSQUEUE_SPINLOCK_IRP_STORAGE(Irp);
    //
    // This function by definition is called at DISPATCH_LEVEL.
    //
    KeAcquireSpinLockAtDpcLevel(SpinLock);
    IoReleaseCancelSpinLock(DISPATCH_LEVEL);
    RemoveEntryList(&Irp->Tail.Overlay.ListEntry);
    //
    // Use the Irp->CancelIrql, since that is the Irql used when acquiring
    // the Cancel Spinlock.
    //
    KeReleaseSpinLock(SpinLock, Irp->CancelIrql);
    //
    // Only complete the Irp if the status is not already set to
    // STATUS_CANCELLED. This is so that this function can be used within a
    // cancel routine to do the above list removal processing, without
    // duplicating code.
    //
    if (Irp->IoStatus.Status != STATUS_CANCELLED) {
        Irp->IoStatus.Status = STATUS_CANCELLED;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }
}


KSDDKAPI
VOID
NTAPI
KsAddIrpToCancelableQueue(
    IN OUT PLIST_ENTRY QueueHead,
    IN PKSPIN_LOCK SpinLock,
    IN PIRP Irp,
    IN KSLIST_ENTRY_LOCATION ListLocation,
    IN PDRIVER_CANCEL DriverCancel OPTIONAL
    )
/*++

Routine Description:

    Add an Irp to a cancelable queue. This allows the Irp to be canceled. This
    routine does not use the cancel spinlock to add items to the list, rather,
    access to the list is synchronized using the provided spinlock and relying
    on atomic operations on Irp->CancelRoutine. If the Irp had been previously
    set to a canceled state, this function will complete the canceling of that
    Irp. This allows Irp's to be canceled even before being placed on a cancel
    list, or when being moved from one list to another. This function may be
    called at <= DISPATCH_LEVEL.

Arguments:

    QueueHead -
        Contains the head of the queue on which to add the Irp.

    SpinLock -
        Pointer to driver's spin lock for queue access.  A copy of this 
        pointer is kept in the Irp's KSQUEUE_SPINLOCK_IRP_STORAGE(Irp)
        for use by the cancel routine if necessary.

    Irp -
        Contains the Irp to add to the queue.

    ListLocation -
        Indicates whether this Irp should be placed at the head or the tail of
        the queue.

    DriverCancel -
        Optional parameter which specifies the cancel routine to use. If this
        is NULL, the standard KsCancelRoutine is used.

Return Value:

    Nothing.

--*/
{
    KIRQL oldIrql;

    //
    // Set the up internal cancel routine if needed. This is done here
    // because it may be used multiple times below, and the conditional
    // should be done outside of the spinlock.
    //
    if (!DriverCancel) {
        DriverCancel = KsCancelRoutine;
    }
    //
    // Marking this stack location can be done outside of the spinlock,
    // since nothing but completion would be looking at it anyway.
    //
    IoMarkIrpPending(Irp);
    //
    // Synchronize with access to this cancelable queue.
    //
    KeAcquireSpinLock(SpinLock, &oldIrql);
    //
    // This is needed later in canceling the Irp.
    //
    KSQUEUE_SPINLOCK_IRP_STORAGE(Irp) = SpinLock;
    //
    // This sets either the builtin cancel routine, or a specified one.
    // Up to this point, the caller owns the Irp. After setting the
    // cancel routine, it may be acquired by another thread of execution
    // canceling Irps. However, it will get stalled in the cancel routine
    // when attempting to acquire the list lock until this routine releases
    // that lock.
    //
    if (ListLocation == KsListEntryHead) {
        InsertHeadList(QueueHead, &Irp->Tail.Overlay.ListEntry);
    } else {
        InsertTailList(QueueHead, &Irp->Tail.Overlay.ListEntry);
    }
    //
    // Release ownership of the Irp.
    //
    IoSetCancelRoutine(Irp, DriverCancel);
    //
    // Determine if the Irp has already been set to a canceled state,
    // and if so, if it is currently being canceled. If it is in the
    // cancel state, then attempt to immediately acquire the Irp.
    //
    // When checking for a cancel routine, there is no need to actually
    // retrieve the value, since the routine cannot have change, as the
    // list lock is still acquired at this point.
    //
    if (Irp->Cancel && IoSetCancelRoutine(Irp, NULL)) {
        //
        // The Irp was already in a canceled state, but had not been
        // acquired. Release the list lock, as the Irp has now been
        // acquired by setting the Cancel Routine.
        //
        KeReleaseSpinLock(SpinLock, oldIrql);
        //
        // This needs to be acquired since cancel routines expect it, and
        // to synchronize with NTOS trying to cancel IRP's.
        //
        IoAcquireCancelSpinLock(&Irp->CancelIrql);
        DriverCancel(IoGetCurrentIrpStackLocation(Irp)->DeviceObject, Irp);
    } else {
        //
        // Else just release the list lock, as the Irp either was not canceled
        // during the acquired time, or some other thread of execution is
        // canceling it.
        //
        KeReleaseSpinLock(SpinLock, oldIrql);
    }
}


KSDDKAPI
VOID
NTAPI
KsCancelIo(
    IN OUT PLIST_ENTRY QueueHead,
    IN PKSPIN_LOCK SpinLock
    )
/*++

Routine Description:

    Cancels all IRP's on the specified list. If an Irp on the list does
    not have a cancel routine only the cancel bit is set in the Irp.
    This function may be called at <= DISPATCH_LEVEL.

Arguments:

    QueueHead -
        Contains the head of the Irp list whose members are to be canceled.

    SpinLock -
        Pointer to driver's spin lock for queue access.  A copy of this 
        pointer is kept in the Irp's KSQUEUE_SPINLOCK_IRP_STORAGE(Irp)
        for use by the cancel routine if necessary.

Return Value:

    Nothing.

--*/
{
    //
    // Start at the top of the list of Irp's each time one is cancelled.
    // This is because the list lock needs to be released to cancel the
    // Irp, and so the entire list may have been changed.
    //
    for (;;) {
        PLIST_ENTRY CurrentItem;
        KIRQL oldIrql;

        //
        // On each loop, acquire the list lock again, since it needs to be
        // released to actually cancel the Irp.
        //
        KeAcquireSpinLock(SpinLock, &oldIrql);
        for (CurrentItem = QueueHead;; CurrentItem = CurrentItem->Flink) {
            PIRP Irp;
            PDRIVER_CANCEL DriverCancel;

            //
            // If all the list elements have been enumerated, then exit.
            // Acquired elements will still be on the list, but they will
            // be cancelled when they are released.
            //
            if (CurrentItem->Flink == QueueHead) {
                KeReleaseSpinLock(SpinLock, oldIrql);
                return;
            }
            //
            // Since the list lock is held, any Irp on this list cannot be
            // canceled completely, so it is safe to access the Irp.
            //
            Irp = CONTAINING_RECORD(CurrentItem->Flink, IRP, Tail.Overlay.ListEntry);
            Irp->Cancel = TRUE;
            //
            // If the cancel routine has already been removed, then this IRP
            // can only be marked as canceled, and not actually canceled, as
            // another execution thread has acquired it. The assumption is that
            // the processing will be completed, and the Irp removed from the list
            // some time in the near future.
            //
            // If the element has not been acquired, then acquire it and cancel it.
            // Else continue on to the next element in the list.
            //
            if (DriverCancel = IoSetCancelRoutine(Irp, NULL)) {
                //
                // Since the Irp has been acquired by removing the cancel
                // routine, it is safe to release the list lock. No other thread
                // of execution can not acquire this Irp, including any other
                // call to this function.
                //
                KeReleaseSpinLock(SpinLock, oldIrql);
                //
                // This needs to be acquired since cancel routines expect it, and
                // in order to synchronize with NTOS trying to cancel Irp's.
                //
                IoAcquireCancelSpinLock(&Irp->CancelIrql);
                DriverCancel(IoGetCurrentIrpStackLocation(Irp)->DeviceObject, Irp);
                //
                // Leave the inner loop and start at the top of the list again.
                //
                break;
            }
        }
    }
}


KSDDKAPI
VOID
NTAPI
KsReleaseIrpOnCancelableQueue(
    IN PIRP Irp,
    IN PDRIVER_CANCEL DriverCancel OPTIONAL
    )
/*++

Routine Description:

    Release an acquired Irp which is already on a cancelable queue. This
    sets the cancel function, and completes the canceling of the Irp if
    necessary. This function may be called at <= DISPATCH_LEVEL.

Arguments:

    Irp -
        Contains the Irp to release.

    DriverCancel -
        Optional parameter which specifies the cancel routine to use. If this
        is NULL, the standard KsCancelRoutine is used.

Return Value:

    Nothing.

--*/
{
    PKSPIN_LOCK SpinLock;
    KIRQL oldIrql;

    //
    // Set the up internal cancel routine if needed. This is done here
    // because it may be used multiple times below, and the conditional
    // should be done outside of the spinlock.
    //
    if (!DriverCancel) {
        DriverCancel = KsCancelRoutine;
    }
    //
    // This was stored in the Irp on initial adding to the list.
    //
    SpinLock = KSQUEUE_SPINLOCK_IRP_STORAGE(Irp);
    //
    // Block any other thread of execution from completing this Irp.
    //
    KeAcquireSpinLock(SpinLock, &oldIrql);
    //
    // Release ownership of the Irp.
    //
    IoSetCancelRoutine(Irp, DriverCancel);
    //
    // The Irp may have been canceled while it was being processed and
    // before it was released. If so, then try and finish the canceling of
    // the Irp. At the same time, some other thread of execution may try
    // to cancel the same Irp, so acquire the Irp again. If this fails,
    // some other thread of execution has canceled it.
    //
    // When checking for a cancel routine, there is no need to actually
    // retrieve the value, since the routine cannot have change, as the
    // list lock is still acquired at this point.
    // 
    if (Irp->Cancel && IoSetCancelRoutine(Irp, NULL)) {
        //
        // Since the Irp has been acquired again, the list lock can be released.
        //
        KeReleaseSpinLock(SpinLock, oldIrql);
        //
        // This needs to be acquired since cancel routines expect it, and
        // to synchronize with NTOS trying to cancel IRP's.
        //
        IoAcquireCancelSpinLock(&Irp->CancelIrql);
        DriverCancel(IoGetCurrentIrpStackLocation(Irp)->DeviceObject, Irp);
    } else {
        //
        // Else just release the list lock, as the Irp either was not canceled
        // during the acquired time, or some other thread of execution is
        // canceling it.
        //
        KeReleaseSpinLock(SpinLock, oldIrql);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\ks\event.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    event.c

Abstract:

    This module contains the helper functions for event sets, and event
    generating code. These allow a device object to present an event set
    to a client, and allow the helper function to perform some of the basic
    parameter validation and routing based on an event set table.

--*/

#include "ksp.h"

#define KSSIGNATURE_EVENT_DPCITEM 'deSK'
#define KSSIGNATURE_EVENT_ENTRY 'eeSK'
#define KSSIGNATURE_ONESHOT_WORK 'weSK'
#define KSSIGNATURE_ONESHOT_DPC 'deSK'
#define KSSIGNATURE_BUFFERITEM 'ibSK'

/*++

Routine Description:

    This macro removes the specified event item from the event list. If
    a remove handler was specified for this event type then call it, else
    do the default removal process.

Arguments:

    EventEntry -
        Contains the event list entry to remove.

Return Value:
    Nothing.

--*/
#define REMOVE_ENTRY(EventEntryEx)\
    if ((EventEntryEx)->RemoveHandler) {\
        (EventEntryEx)->RemoveHandler((EventEntryEx)->EventEntry.FileObject, &EventEntryEx->EventEntry);\
    } else {\
        RemoveEntryList(&(EventEntryEx)->EventEntry.ListEntry);\
    }

typedef struct {
    LIST_ENTRY ListEntry;
    ULONG Reserved;
    ULONG Length;
} KSBUFFER_ENTRY, *PKSBUFFER_ENTRY;

typedef struct {
    WORK_QUEUE_ITEM WorkQueueItem;
    PKSEVENT_ENTRY EventEntry;
} KSONESHOT_WORKITEM, *PKSONESHOT_WORKITEM;

typedef struct {
    PLIST_ENTRY EventsList;
    GUID* Set;
    ULONG EventId;
} KSGENERATESYNC, *PKSGENERATESYNC;

typedef struct {
    PLIST_ENTRY EventsList;
    PKSEVENT_ENTRY EventEntry;
} KSENABLESYNC, *PKSENABLESYNC;

typedef struct {
    PLIST_ENTRY EventsList;
    PFILE_OBJECT FileObject;
    PIRP Irp;
    PKSEVENT_ENTRY EventEntry;
} KSDISABLESYNC, *PKSDISABLESYNC;

typedef struct {
    PLIST_ENTRY EventsList;
    PFILE_OBJECT FileObject;
    PIRP Irp;
    PKSEVENTDATA EventData;
    PKSBUFFER_ENTRY BufferEntry;
    ULONG BufferLength;
    NTSTATUS Status;
} KSQUERYSYNC, *PKSQUERYSYNC;

#ifdef ALLOC_PRAGMA
VOID
OneShotWorkItem(
    IN PKSONESHOT_WORKITEM WorkItem
    );
const KSEVENT_ITEM*
FASTCALL
FindEventItem(
    IN const KSEVENT_SET* EventSet,
    IN ULONG EventItemSize,
    IN ULONG EventId
    );
NTSTATUS
FASTCALL
CreateDpc(
    IN PKSEVENT_ENTRY EventEntry,
    IN PKDEFERRED_ROUTINE DpcRoutine,
    IN KDPC_IMPORTANCE Importance
    );

#pragma alloc_text(PAGE, OneShotWorkItem)
#pragma alloc_text(PAGE, FindEventItem)
#pragma alloc_text(PAGE, CreateDpc)
#pragma alloc_text(PAGE, KsEnableEvent)
#pragma alloc_text(PAGE, KsEnableEventWithAllocator)
#pragma alloc_text(PAGE, KspEnableEvent)
#pragma alloc_text(PAGE, KsDisableEvent)
#pragma alloc_text(PAGE, KsFreeEventList)
#endif


VOID
OneShotWorkItem(
    IN PKSONESHOT_WORKITEM WorkItem
    )
/*++

Routine Description:

    This is the work item which deletes a oneshot event which has fired.

Arguments:

    WorkItem -
        Contains the event list entry to delete. This structure has been
        allocated by the caller, and needs to be freed.

Return Value:
    Nothing.

--*/
{
    //
    // The event has previously been removed from the event list.
    //
    KsDiscardEvent(WorkItem->EventEntry);
    //
    // This was allocated by the caller.
    //
    ExFreePool(WorkItem);
}


VOID
QueueOneShotWorkItem(
    PKSEVENT_ENTRY EventEntry
    )
/*++

Routine Description:

    Allocates and queues a work item to delete the event entry.

Arguments:

    EventEntry -
        Contains the event list entry to delete.

Return Value:
    Nothing.

--*/
{
    PKSONESHOT_WORKITEM WorkItem;

    //
    // The work item will delete this memory. Allocation failures
    // cannot be dealt with. This means on deadly low memory, the
    // event entry will not be freed, since the work item will not
    // be run. Note that this is allocating from the NonPagedPool
    // which is accessible at Dispatch Level.
    //
    WorkItem = ExAllocatePoolWithTag(
        NonPagedPool,
        sizeof(*WorkItem),
        KSSIGNATURE_ONESHOT_WORK);
    ASSERT(WorkItem);
    if (WorkItem) {
        WorkItem->EventEntry = EventEntry;
        ExInitializeWorkItem(
            &WorkItem->WorkQueueItem,
            OneShotWorkItem,
            WorkItem);
        ExQueueWorkItem(&WorkItem->WorkQueueItem, DelayedWorkQueue);
    }
}


VOID
OneShotDpc(
    IN PKDPC Dpc,
    IN PKSEVENT_ENTRY EventEntry,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++

Routine Description:

    This is the DPC which queues a worker item to delete a oneshot event.

Arguments:

    Dpc -
        The allocated Dpc entry, plus space for the work item. This was
        allocated by the caller, and will be deleted by the work item.

    EventEntry -
        Contains the event list entry with the worker item to queue.

    SystemArgument1 -
        Not used.

    SystemArgument2 -
        Not used.

Return Value:
    Nothing.

--*/
{
    //
    // Indicate that the Dpc is done accessing the event data. There
    // is no need to synchronize with the DpcItem->AccessLock, as this
    // item has already been remove from the list.
    //
    InterlockedDecrement((PLONG)&EventEntry->DpcItem->ReferenceCount);
    //
    // This is a oneshot, it has already been removed from the
    // list, and just needs to be deleted through a work item.
    //
    QueueOneShotWorkItem(EventEntry);
}


VOID
WorkerDpc(
    IN PKDPC Dpc,
    IN PKSEVENT_ENTRY EventEntry,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++

Routine Description:

    This is the DPC which queues a worker item in case the type of notification
    for an event is to queue a worker item, and the event is generated at
    greater than DPC level.

Arguments:

    Dpc -
        Not used.

    EventEntry -
        Contains the event list entry with the worker item to queue.

    SystemArgument1 -
        Not used.

    SystemArgument2 -
        Not used.

Return Value:
    Nothing.

--*/
{
    //
    // Synchronize access to the event structure with any delete which might be
    // occurring.
    //
    KeAcquireSpinLockAtDpcLevel(&EventEntry->DpcItem->AccessLock);
    //
    // The element may already have been deleted, and is merely present for all
    // outstanding Dpc's to be completed.
    //
    if (!(EventEntry->Flags & KSEVENT_ENTRY_DELETED)) {
        //
        // The caller must have the list lock to call this function, so the
        // entry must still be valid.
        //
        // First check that the WorkQueueItem is not NULL. For a KS worker,
        // this could be NULL, indicating that a counted worker is being
        // used. There is an ASSERT in the enable code to check for a non-KS
        // worker event trying to pass a NULL WorkQueueItem.
        //
        // Note that this check assumes that the WorkItem and Worker
        // structures both contain a WorkQueueItem as the first member.
        //
        if (EventEntry->EventData->KsWorkItem.WorkQueueItem) {
            //
            // Only schedule the work item if it is not already running. This
            // is done by checking the value of the List.Blink. This is
            // initially NULL, and the work item is supposed to set this to
            // NULL again when a new item can be queued. The exchange below
            // ensures that only one caller will actually queue the item,
            // though multiple work items could be running.
            //
            // Note that this exchange assumes that the WorkItem and Worker
            // structures both contain a WorkQueueItem as the first member.
            //
            if (!InterlockedCompareExchangePointer(
                (PVOID)&EventEntry->EventData->WorkItem.WorkQueueItem->List.Blink,
                (PVOID)-1,
                (PVOID)0)) {
                if (EventEntry->NotificationType == KSEVENTF_WORKITEM) {
                    ExQueueWorkItem(EventEntry->EventData->WorkItem.WorkQueueItem, EventEntry->EventData->WorkItem.WorkQueueType);
                } else {
                    KsQueueWorkItem(EventEntry->EventData->KsWorkItem.KsWorkerObject, EventEntry->EventData->KsWorkItem.WorkQueueItem);
                }
            }
        } else {
            //
            // In this case the counting is all internal, and more efficient
            // in terms of scheduling work items.
            //
            KsIncrementCountedWorker(EventEntry->EventData->KsWorkItem.KsWorkerObject);
        }
    }
    //
    // Indicate that the Dpc is done accessing the event data.
    //
    if (InterlockedDecrement((PLONG)&EventEntry->DpcItem->ReferenceCount)) {
        ULONG OneShot;

        //
        // Acquire the flag setting before releasing the spinlock.
        //
        OneShot = EventEntry->Flags & KSEVENT_ENTRY_ONESHOT;
        //
        // The structure is still valid, so just release the access lock.
        //
        KeReleaseSpinLockFromDpcLevel(&EventEntry->DpcItem->AccessLock);
        if (OneShot) {
            //
            // If this is a oneshot, it has already been removed from the
            // list, and just needs to be deleted through a work item.
            //
            QueueOneShotWorkItem(EventEntry);
        }
    } else {
        //
        // This is the last Dpc to be accessing this structure, so delete it.
        // No need to release a spin lock which is no longer valid.
        //
//      KeReleaseSpinLockFromDpcLevel(&EventEntry->DpcItem->AccessLock);
        ExFreePool(EventEntry->DpcItem);
        ExFreePool(EventEntry);
    }
}


VOID
EventDpc(
    IN PKDPC Dpc,
    IN PKSEVENT_ENTRY EventEntry,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++

Routine Description:

    This is the DPC which sets an event object in case the type of notification
    for an event is to set such an event object, and the event is generated at
    greater than DPC level. This function is also called directly by the
    event generation function when KIRQL is <= DISPATCH_LEVEL.

Arguments:

    Dpc -
        Not used.

    EventEntry -
        Contains the event list entry with the event to signal.

    SystemArgument1 -
        Not used.

    SystemArgument2 -
        Not used.

Return Value:
    Nothing.

--*/
{
    //
    // Synchronize access to the event structure with any delete which might be
    // occurring.
    //
    KeAcquireSpinLockAtDpcLevel(&EventEntry->DpcItem->AccessLock);
    //
    // The element may already have been deleted, and is merely present for all
    // outstanding Dpc's to be completed.
    //
    if (!(EventEntry->Flags & KSEVENT_ENTRY_DELETED)) {
        switch (EventEntry->NotificationType) {

        case KSEVENTF_EVENT_HANDLE:
            KeSetEvent(EventEntry->Object, IO_NO_INCREMENT, FALSE);
            break;

        case KSEVENTF_EVENT_OBJECT:
            KeSetEvent(
                EventEntry->EventData->EventObject.Event,
                EventEntry->EventData->EventObject.Increment,
                FALSE);
            break;

        case KSEVENTF_SEMAPHORE_HANDLE:
            try {
                KeReleaseSemaphore(
                    EventEntry->Object,
                    IO_NO_INCREMENT,
                    EventEntry->SemaphoreAdjustment,
                    FALSE);
            } except (GetExceptionCode() == STATUS_SEMAPHORE_LIMIT_EXCEEDED) {
                //
                // Nothing can really be done if an incorrect Adjustment
                // has been provided.
                //
                ASSERT(FALSE);
            }
            break;

        case KSEVENTF_SEMAPHORE_OBJECT:
            try {
                KeReleaseSemaphore(
                    EventEntry->EventData->SemaphoreObject.Semaphore,
                    EventEntry->EventData->SemaphoreObject.Increment,
                    EventEntry->EventData->SemaphoreObject.Adjustment,
                    FALSE);
            } except (GetExceptionCode() == STATUS_SEMAPHORE_LIMIT_EXCEEDED) {
                //
                // Nothing can really be done if an incorrect Adjustment
                // has been provided.
                //
                ASSERT(FALSE);
            }
            break;

        }
    }
    //
    // Indicate that the Dpc is done accessing the event data.
    //
    if (InterlockedDecrement((PLONG)&EventEntry->DpcItem->ReferenceCount)) {
        ULONG OneShot;

        //
        // Acquire the flag setting before releasing the spinlock.
        //
        OneShot = EventEntry->Flags & KSEVENT_ENTRY_ONESHOT;
        //
        // The structure is still valid, so just release the access lock.
        //
        KeReleaseSpinLockFromDpcLevel(&EventEntry->DpcItem->AccessLock);
        if (OneShot) {
            //
            // If this is a oneshot, it has already been removed from the
            // list, and just needs to be deleted through a work item.
            //
            QueueOneShotWorkItem(EventEntry);
        }
    } else {
        //
        // This is the last Dpc to be accessing this structure, so delete it.
        // No need to release a spin lock which is no longer valid.
        //
//      KeReleaseSpinLockFromDpcLevel(&EventEntry->DpcItem->AccessLock);
        ExFreePool(EventEntry->DpcItem);
        ExFreePool(EventEntry);
    }
}


KSDDKAPI
NTSTATUS
NTAPI
KsGenerateEvent(
    IN PKSEVENT_ENTRY EventEntry
    )
/*++

Routine Description:

    Generates one of the standard event notifications given an event entry
    structure. This allows a device to handle determining when event
    notifications should be generated, but use this helper function to
    perform the actual notification. This function may be called at IRQL
    level.

    It is assumed that the event list lock has been acquired before calling
    this function. This function may result in a call to the RemoveHandler
    for the event entry. Therefore the function must not be called at higher
    than the Irql of the lock, or the Remove function must be able to handle
    being called at such an Irql.

Arguments:

    EventEntry -
        Contains the event entry structure which references the event data.
        This is used to determine what type of notification to perform. If the
        notification type is not one of the pre-defined standards, an error is
        returned.

Return Value:

    Returns STATUS_SUCCESS, else an invalid parameter error.

--*/
{
    KIRQL Irql;
    BOOLEAN SignalledEvent;

    Irql = KeGetCurrentIrql();
    SignalledEvent = FALSE;
    switch (EventEntry->NotificationType) {

    case KSEVENTF_EVENT_HANDLE:

        //
        // Only try to set the event if it is currently possible, else schedule
        // a Dpc to do it.
        //
        if (Irql <= DISPATCH_LEVEL) {
            //
            // The caller must have the list lock to call this function, so the
            // entry must still be valid.
            //
            KeSetEvent(EventEntry->Object, IO_NO_INCREMENT, FALSE);
            SignalledEvent = TRUE;
        }
        break;

    case KSEVENTF_EVENT_OBJECT:

        //
        // Only try to set the event if it is currently possible, else schedule
        // a Dpc to do it.
        //
        if (Irql <= DISPATCH_LEVEL) {
            //
            // The caller must have the list lock to call this function, so the
            // entry must still be valid.
            //
            KeSetEvent(EventEntry->EventData->EventObject.Event, EventEntry->EventData->EventObject.Increment, FALSE);
            SignalledEvent = TRUE;
        }
        break;

    case KSEVENTF_SEMAPHORE_HANDLE:

        //
        // Only try to release the semaphore if it is currently possible, else
        // schedule a Dpc to do it.
        //
        if (Irql <= DISPATCH_LEVEL) {
            //
            // The caller must have the list lock to call this function, so the
            // entry must still be valid.
            //
            try {
                KeReleaseSemaphore(
                    EventEntry->Object,
                    IO_NO_INCREMENT,
                    EventEntry->SemaphoreAdjustment,
                    FALSE);
            } except (EXCEPTION_EXECUTE_HANDLER) {
                //
                // Nothing can really be done if an incorrect Adjustment
                // has been provided.
                //
                ASSERT(FALSE);
            }
            SignalledEvent = TRUE;
        }
        break;

    case KSEVENTF_SEMAPHORE_OBJECT:

        //
        // Only try to release the semaphore if it is currently possible, else
        // schedule a Dpc to do it.
        //
        if (Irql <= DISPATCH_LEVEL) {
            //
            // The caller must have the list lock to call this function, so the
            // entry must still be valid.
            //
            try {
                KeReleaseSemaphore(
                    EventEntry->EventData->SemaphoreObject.Semaphore,
                    EventEntry->EventData->SemaphoreObject.Increment,
                    EventEntry->EventData->SemaphoreObject.Adjustment,
                    FALSE);
            } except (EXCEPTION_EXECUTE_HANDLER) {
                //
                // Nothing can really be done if an incorrect Adjustment
                // has been provided.
                //
                ASSERT(FALSE);
            }
            SignalledEvent = TRUE;
        }
        break;

    case KSEVENTF_DPC:

        //
        // Try to schedule the requested Dpc, incrementing the ReferenceCount
        // for the client. If the request fails, ensure the count is decremented.
        //
        // The caller must have the list lock to call this function, so the
        // entry must still be valid.
        //
        InterlockedIncrement((PLONG)&EventEntry->EventData->Dpc.ReferenceCount);
        if (!KeInsertQueueDpc(EventEntry->EventData->Dpc.Dpc, EventEntry->EventData, NULL)) {
            InterlockedDecrement((PLONG)&EventEntry->EventData->Dpc.ReferenceCount);
        }
        SignalledEvent = TRUE;
        break;

    case KSEVENTF_WORKITEM:
    case KSEVENTF_KSWORKITEM:

        //
        // Only try to schedule a work item if it is currently possible, else schedule
        // a Dpc to do it.
        //
        if (Irql <= DISPATCH_LEVEL) {
            //
            // The caller must have the list lock to call this function, so the
            // entry must still be valid.
            //
            // First check that the WorkQueueItem is not NULL. For a KS worker,
            // this could be NULL, indicating that a counted worker is being
            // used. There is an ASSERT in the enable code to check for a non-KS
            // worker event trying to pass a NULL WorkQueueItem.
            //
            // Note that this check assumes that the WorkItem and Worker
            // structures both contain a WorkQueueItem as the first member.
            //
            if (EventEntry->EventData->KsWorkItem.WorkQueueItem) {
                //
                // Only schedule the work item if it is not already running. This
                // is done by checking the value of the List.Blink. This is
                // initially NULL, and the work item is supposed to set this to
                // NULL again when a new item can be queued. The exchange below
                // ensures that only one caller will actually queue the item,
                // though multiple work items could be running.
                //
                // Note that this exchange assumes that the WorkItem and Worker
                // structures both contain a WorkQueueItem as the first member.
                //
                if (!InterlockedCompareExchangePointer(
                    (PVOID)&EventEntry->EventData->WorkItem.WorkQueueItem->List.Blink,
                    (PVOID)-1,
                    (PVOID)0)) {
                    if (EventEntry->NotificationType == KSEVENTF_WORKITEM) {
                        ExQueueWorkItem(EventEntry->EventData->WorkItem.WorkQueueItem, EventEntry->EventData->WorkItem.WorkQueueType);
                    } else {
                        KsQueueWorkItem(EventEntry->EventData->KsWorkItem.KsWorkerObject, EventEntry->EventData->KsWorkItem.WorkQueueItem);
                    }
                }
            } else {
                //
                // In this case the counting is all internal, and more efficient
                // in terms of scheduling work items.
                //
                KsIncrementCountedWorker(EventEntry->EventData->KsWorkItem.KsWorkerObject);
            }
            SignalledEvent = TRUE;
        }
        break;

    default:

        return STATUS_INVALID_PARAMETER;

    }
    if (SignalledEvent) {
        //
        // A oneshot must be removed immediately.
        //
        if (EventEntry->Flags & KSEVENT_ENTRY_ONESHOT) {
            PKSIEVENT_ENTRY EventEntryEx;

            EventEntryEx = CONTAINING_RECORD(EventEntry, KSIEVENT_ENTRY, EventEntry);
            REMOVE_ENTRY(EventEntryEx);
            //
            // The discarding of the event normally must be done outside of
            // acquiring the list lock, but in this case it is a oneshot, so
            // there will be no problems of synchronizing with outstanding
            // signalling.
            //
            // The only time this will actually be executed is if the locking
            // mechanism used is FastMutexUnsafe or the like.
            //
            if (Irql == PASSIVE_LEVEL) {
                KsDiscardEvent(EventEntry);
            } else if (Irql <= DISPATCH_LEVEL) {
                QueueOneShotWorkItem(EventEntry);
            } else {
                //
                // This will only occur in the case of KSEVENTF_DPC. The
                // element must be deleted by a WorkItem, which needs to
                // be queued by a Dpc.
                //
                InterlockedIncrement((PLONG)&EventEntry->DpcItem->ReferenceCount);
                if (!KeInsertQueueDpc(&EventEntry->DpcItem->Dpc, NULL, NULL)) {
                    //
                    // On failure, the event structure will just never be
                    // deleted.
                    //
                    ASSERT(FALSE);
                    InterlockedDecrement((PLONG)&EventEntry->DpcItem->ReferenceCount);
                }
            }
        }
    } else {
        //
        // The event will be signalled asynchronously.
        //
        // A oneshot needs to be removed now before the asynchronous signalling
        // of the event, since otherwise the list lock would have to be acquired,
        // which is not available, and may cause synchronization problems anyway.
        //
        if (EventEntry->Flags & KSEVENT_ENTRY_ONESHOT) {
            PKSIEVENT_ENTRY EventEntryEx;

            EventEntryEx = CONTAINING_RECORD(EventEntry, KSIEVENT_ENTRY, EventEntry);
            REMOVE_ENTRY(EventEntryEx);
        }
        //
        // In the case that this function is being called at high IRQL, schedule
        // a Dpc to perform the real work. Increment the internal ReferenceCount
        // to indicate an outstanding Dpc is queued and may be accessing event
        // data.
        //
        InterlockedIncrement((PLONG)&EventEntry->DpcItem->ReferenceCount);
        if (!KeInsertQueueDpc(&EventEntry->DpcItem->Dpc, NULL, NULL)) {
            //
            // There is no need to check for deletion of the structure on decrement,
            // since the caller must have the list lock to call this function in the
            // first place, which means the item still has to be on the event list,
            // and could not be in the middle of being deleted.
            //
            InterlockedDecrement((PLONG)&EventEntry->DpcItem->ReferenceCount);
        }
    }
    return STATUS_SUCCESS;
}


KSDDKAPI
NTSTATUS
NTAPI
KsGenerateDataEvent(
    IN PKSEVENT_ENTRY EventEntry,
    IN ULONG DataSize,
    IN PVOID Data OPTIONAL
    )
/*++

Routine Description:

    Generates one of the standard event notifications given an event entry
    structure and callback data. This allows a device to handle determining
    when event notifications should be generated, but use this helper function
    to perform the actual notification. This function may only be called at
    <= DISPATCH_LEVEL, as opposed to KsGenerateEvent. This implies that
    the list lock does not raise to Irql, which is a restriction with data
    events.

    It is assumed that the event list lock has been acquired before calling
    this function. This function may result in a call to the RemoveHandler
    for the event entry. Therefore the function must not be called at higher
    than the Irql of the lock, or the Remove function must be able to handle
    being called at such an Irql.

    This function is specifically for events which pass data back to a client
    when buffering is enabled.

Arguments:

    EventEntry -
        Contains the event entry structure which references the event data.
        This is used to determine what type of notification to perform. If the
        notification type is not one of the pre-defined standards, an error is
        returned.

    DataSize -
        The size in bytes of the Data parameter passed.

    Data -
        A pointer to data which to buffer. This may be NULL if DataSize is zero.

Return Value:

    Returns STATUS_SUCCESS, else an invalid parameter error.

--*/
{
    NTSTATUS Status;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    Status = KsGenerateEvent(EventEntry);
    //
    // Optionally buffer the data if buffering is enabled. The event
    // list is locked, so this event can be manipulated by adding to
    // the list of buffered data.
    //
    if (NT_SUCCESS(Status) && DataSize && (EventEntry->Flags & KSEVENT_ENTRY_BUFFERED)) {
        PKSBUFFER_ENTRY BufferEntry;

        BufferEntry = (PKSBUFFER_ENTRY)ExAllocatePoolWithTag(
            NonPagedPool,
            sizeof(*BufferEntry) + DataSize,
            KSSIGNATURE_BUFFERITEM);
        //
        // This really needs to succeed, since the notification happened
        // already.
        //
        ASSERT(BufferEntry);
        if (BufferEntry) {
            BufferEntry->Reserved = 0;
            BufferEntry->Length = DataSize;
            RtlCopyMemory(BufferEntry + 1, Data, DataSize);
            InsertTailList(&EventEntry->BufferItem->BufferList, &BufferEntry->ListEntry);
        }
    }
    return Status;
}


BOOLEAN
PerformLockedOperation(
    IN KSEVENTS_LOCKTYPE EventsFlags,
    IN PVOID EventsLock OPTIONAL,
    IN PKSYNCHRONIZE_ROUTINE SynchronizeRoutine,
    IN PVOID SynchronizeContext
    )
/*++

Routine Description:

    Acquires the list lock and calls the specified routine, then releases the lock.

Arguments:

    EventsFlags -
        Contains flags specifying the type of exclusion lock to be used. If no
        flag is set, then no lock is taken.

        KSEVENT_NONE -
            No lock.

        KSEVENTS_SPINLOCK -
            The lock is assumed to be a KSPIN_LOCK.

        KSEVENTS_MUTEX -
            The lock is assumed to be a KMUTEX.

        KSEVENTS_FMUTEX -
            The lock is assumed to be a FAST_MUTEX, and is acquired by raising
            IRQL to APC_LEVEL.

        KSEVENTS_FMUTEXUNSAFE -
            The lock is assumed to be a FAST_MUTEX, and is acquired without
            raising IRQL to APC_LEVEL.

        KSEVENTS_INTERRUPT -
            The lock is assumed to be an interrupt synchronization spin lock.

        KSEVENTS_ERESOURCE -
            The lock is assumed to be an ERESOURCE.

    EventsLock -
        Optionally contains the list lock mechanism, or NULL if no lock is
        taken.

    SynchronizeRoutine -
        Contains the routine to call with the list lock taken.

    SynchronizeContext -
        Contains the context to pass to the routine.

Return Value:

    Returns the value returned by SynchronizeRoutine.

--*/
{
    KIRQL IrqlOld;
    BOOLEAN SyncReturn = FALSE;

    switch (EventsFlags) {

    case KSEVENTS_NONE:
        SyncReturn = SynchronizeRoutine(SynchronizeContext);
        break;

    case KSEVENTS_SPINLOCK:

        KeAcquireSpinLock((PKSPIN_LOCK)EventsLock, &IrqlOld);
        SyncReturn = SynchronizeRoutine(SynchronizeContext);
        KeReleaseSpinLock((PKSPIN_LOCK)EventsLock, IrqlOld);
        break;

    case KSEVENTS_MUTEX:

        KeWaitForMutexObject(EventsLock, Executive, KernelMode, FALSE, NULL);
        SyncReturn = SynchronizeRoutine(SynchronizeContext);
        KeReleaseMutex((PRKMUTEX)EventsLock, FALSE);
        break;

    case KSEVENTS_FMUTEX:

        ExAcquireFastMutex((PFAST_MUTEX)EventsLock);
        SyncReturn = SynchronizeRoutine(SynchronizeContext);
        ExReleaseFastMutex((PFAST_MUTEX)EventsLock);
        break;

    case KSEVENTS_FMUTEXUNSAFE:

        KeEnterCriticalRegion();
        ExAcquireFastMutexUnsafe((PFAST_MUTEX)EventsLock);
        SyncReturn = SynchronizeRoutine(SynchronizeContext);
        ExReleaseFastMutexUnsafe((PFAST_MUTEX)EventsLock);
        KeLeaveCriticalRegion();
        break;

    case KSEVENTS_INTERRUPT:

        SyncReturn = KeSynchronizeExecution((PKINTERRUPT)EventsLock, SynchronizeRoutine, SynchronizeContext);
        break;

    case KSEVENTS_ERESOURCE:

#ifndef WIN9X_KS
        KeEnterCriticalRegion();
        ExAcquireResourceExclusiveLite((PERESOURCE)EventsLock, TRUE);
#endif
        SyncReturn = SynchronizeRoutine(SynchronizeContext);
#ifndef WIN9X_KS
        ExReleaseResourceLite((PERESOURCE)EventsLock);
        KeLeaveCriticalRegion();
#endif
        break;

    }

    return SyncReturn;
}


const KSEVENT_ITEM*
FASTCALL
FindEventItem(
    IN const KSEVENT_SET* EventSet,
    IN ULONG EventItemSize,
    IN ULONG EventId
    )
/*++

Routine Description:

    Given an event set structure, locates the specified event item. This is used
    when locating an event item in an event list after having located the correct
    event list.

Arguments:

    EventSet -
        Points to the event set to search.

    EventItemSize -
        Contains the size of each Event item. This may be different
        than the standard event item size, since the items could be
        allocated on the fly, and contain context information.

    EventId -
        Contains the event identifier to look for.

Return Value:

    Returns a pointer to the event identifier structure, or NULL if it could
    not be found.

--*/
{
    const KSEVENT_ITEM* EventItem;
    ULONG EventsCount;

    EventItem = EventSet->EventItem;
    for (EventsCount = EventSet->EventsCount;
        EventsCount;
        EventsCount--, EventItem = (const KSEVENT_ITEM*)((PUCHAR)EventItem + EventItemSize)) {
        if (EventId == EventItem->EventId) {
            return EventItem;
        }
    }
    return NULL;
}


NTSTATUS
FASTCALL
CreateDpc(
    IN PKSEVENT_ENTRY EventEntry,
    IN PKDEFERRED_ROUTINE DpcRoutine,
    IN KDPC_IMPORTANCE Importance
    )
/*++

Routine Description:

    Allocates memory for a DPC structure which is used for generating events.
    Initializes the structure with the specified deferred routine and
    importance. If the KSEVENT_ENTRY_BUFFERED flag is set, the structure
    allocated must be for a KSBUFFER_ITEM instead in order to keep the
    buffer list.

Arguments:

    EventEntry -
        Contains the event list entry to hang the allocation off of.

    DpcRoutine -
        Points to the deferred routine to initialize the DPC with.

    Importance -
        Specifies the importance level to set the DPC to.

Return Value:

    Returns STATUS_SUCCESS, else STATUS_INSUFFICIENT_RESOURCES on an
    allocation failure.

--*/
{
    //
    // The two structure elements are part of a union, and assumed to
    // be located at the same offset in the structure.
    //
    if (EventEntry->Flags & KSEVENT_ENTRY_BUFFERED) {
        EventEntry->BufferItem = ExAllocatePoolWithTag(
            NonPagedPool,
            sizeof(*EventEntry->BufferItem),
            KSSIGNATURE_EVENT_DPCITEM);
        if (EventEntry->BufferItem) {
            InitializeListHead(&EventEntry->BufferItem->BufferList);
        }
    } else {
        EventEntry->DpcItem = ExAllocatePoolWithTag(
            NonPagedPool,
            sizeof(*EventEntry->DpcItem),
            KSSIGNATURE_EVENT_DPCITEM);
    }
    if (EventEntry->DpcItem) {
        KeInitializeDpc(&EventEntry->DpcItem->Dpc, DpcRoutine, EventEntry);
#ifndef WIN9X_KS
        KeSetImportanceDpc(&EventEntry->DpcItem->Dpc, Importance);
#endif // WIN9X_KS
        //
        // The reference count begins at 1, since the caller automatically
        // references it by creating it. The deallocation code dereferences
        // by 1, then checks to determine if an outstanding Dpc is referencing
        // the structure.
        //
        EventEntry->DpcItem->ReferenceCount = 1;
        //
        // This will be used to synchronize deletion of the structure with
        // access by a Dpc.
        //
        KeInitializeSpinLock(&EventEntry->DpcItem->AccessLock);
        return STATUS_SUCCESS;
    }
    return STATUS_INSUFFICIENT_RESOURCES;
}


BOOLEAN
AddEventSynchronize(
    IN PKSENABLESYNC Synchronize
    )
/*++

Routine Description:

    Adds the new event to the list while being synchronized with the list lock.

Arguments:

    Synchronize -
        Contains the event list and event to add.

Return Value:
    Returns TRUE.

--*/
{
    InsertTailList(Synchronize->EventsList, &Synchronize->EventEntry->ListEntry);
    return TRUE;
}


BOOLEAN
QueryBufferSynchronize(
    IN PKSQUERYSYNC Synchronize
    )
/*++

Routine Description:

    Looks up the requested enabled event on the event list, and retrieves
    any outstanding buffered data.

Arguments:

    Synchronize -
        Contains the event list, and item to search for, along with the
        buffer to return the data in.

Return Value:
    Returns TRUE.

--*/
{
    PLIST_ENTRY ListEntry;

    for (ListEntry = Synchronize->EventsList->Flink;
        ListEntry != Synchronize->EventsList;
        ListEntry = ListEntry->Flink) {
        PKSEVENT_ENTRY  EventEntry;

        EventEntry = CONTAINING_RECORD(
            ListEntry,
            KSEVENT_ENTRY,
            ListEntry);
        //
        // The comparison is performed based on the original event data
        // pointer.
        //
        if (EventEntry->EventData == Synchronize->EventData) {
            //
            // This must be the same client, as this list might be servicing
            // multiple clients.
            //
            if (EventEntry->FileObject == Synchronize->FileObject) {
                //
                // Make sure this event has buffering turned.
                //
                if (EventEntry->Flags & KSEVENT_ENTRY_BUFFERED) {
                    //
                    // Determine if any data is available.
                    //
                    if (!IsListEmpty(&EventEntry->BufferItem->BufferList)) {
                        PKSBUFFER_ENTRY BufferEntry;

                        BufferEntry = CONTAINING_RECORD(
                            EventEntry->BufferItem->BufferList.Flink,
                            KSBUFFER_ENTRY,
                            ListEntry);
                        if (!Synchronize->BufferLength) {
                            //
                            // The client may be just querying for how large of
                            // a buffer is needed. Zero length data buffers
                            // cannot be queued by the driver, so there is no
                            // possibility of a conflict here.
                            //
                            Synchronize->Irp->IoStatus.Information = BufferEntry->Length;
                            Synchronize->Status = STATUS_BUFFER_OVERFLOW;
                        } else if (Synchronize->BufferLength < BufferEntry->Length) {
                            //
                            // Or the buffer may be too small.
                            //
                            Synchronize->Status = STATUS_BUFFER_TOO_SMALL;
                        } else {
                            //
                            // Or the buffer is large enough. Remove it from the
                            // list.
                            //
                            RemoveHeadList(&EventEntry->BufferItem->BufferList);
                            Synchronize->BufferEntry = BufferEntry;
                            //
                            // Do the copy outside of being synchronized with the list.
                            //
                            Synchronize->Status = STATUS_SUCCESS;
                        }    
                    } else {
                        Synchronize->Status = STATUS_NO_MORE_ENTRIES;
                    }
                } else {
                    Synchronize->Status = STATUS_INVALID_PARAMETER;
                }
                //
                // Some type of error has already been set, so exit before
                // the end of the loop resets the error status.
                //
                return TRUE;
            }
        }
    }
    Synchronize->Status = STATUS_NOT_FOUND;
    return TRUE;
}



KSDDKAPI
NTSTATUS
NTAPI
KsEnableEvent(
    IN PIRP Irp,
    IN ULONG EventSetsCount,
    IN const KSEVENT_SET* EventSet,
    IN OUT PLIST_ENTRY EventsList OPTIONAL,
    IN KSEVENTS_LOCKTYPE EventsFlags OPTIONAL,
    IN PVOID EventsLock OPTIONAL
    )
/*++

Routine Description:

    Handles event enabling requests. Responds to all event identifiers
    defined by the sets. This function may only be called at PASSIVE_LEVEL.

Arguments:

    Irp -
        Contains the IRP with the enable request being handled. The file object
        associated with the IRP is stored with the event for later comparison
        when disabling the event.

    EventSetsCount -
        Indicates the number of event set structures being passed.

    EventSet -
        Contains the pointer to the list of event set information.

    EventsList -
        If the KSEVENT_ITEM.AddHandler for the event being enabled is
        NULL, then this must point to the head of the list of KSEVENT_ENTRY
        items on which the event is to be added. This method assumes a single
        list for at least a subset of events.

    EventsFlags -
        Contains flags specifying the type of exclusion lock to be used in
        accessing the event list, if any. If no flag is set, then no lock is
        taken. If a KSEVENT_ITEM.AddHandler for the event is specified,
        this parameter is ignored.

        KSEVENT_NONE -
            No lock.

        KSEVENTS_SPINLOCK -
            The lock is assumed to be a KSPIN_LOCK.

        KSEVENTS_MUTEX -
            The lock is assumed to be a KMUTEX.

        KSEVENTS_FMUTEX -
            The lock is assumed to be a FAST_MUTEX, and is acquired by raising
            IRQL to APC_LEVEL.

        KSEVENTS_FMUTEXUNSAFE -
            The lock is assumed to be a FAST_MUTEX, and is acquired without
            raising IRQL to APC_LEVEL.

        KSEVENTS_INTERRUPT -
            The lock is assumed to be an interrupt synchronization spin lock.

        KSEVENTS_ERESOURCE -
            The lock is assumed to be an ERESOURCE.

    EventsLock -
        If the KSEVENT_ITEM.AddHandler for the event being enabled is
        NULL, then this is used to synchronize access to the list. This may be
        NULL if no flag is set in EventsFlags.

Return Value:

    Returns STATUS_SUCCESS, else an error specific to the event being
    enabled. Always sets the IO_STATUS_BLOCK.Information field of the
    PIRP.IoStatus element within the IRP to zero. It does not set the
    IO_STATUS_BLOCK.Status field, nor complete the IRP however.

--*/
{
    PAGED_CODE();
    return KspEnableEvent(
        Irp,
        EventSetsCount,
        EventSet,
        EventsList,
        EventsFlags,
        EventsLock,
        NULL,
        0,
        NULL,
        0,
        FALSE
        );
}


KSDDKAPI
NTSTATUS
NTAPI
KsEnableEventWithAllocator(
    IN PIRP Irp,
    IN ULONG EventSetsCount,
    IN const KSEVENT_SET* EventSet,
    IN OUT PLIST_ENTRY EventsList OPTIONAL,
    IN KSEVENTS_LOCKTYPE EventsFlags OPTIONAL,
    IN PVOID EventsLock OPTIONAL,
    IN PFNKSALLOCATOR Allocator OPTIONAL,
    IN ULONG EventItemSize OPTIONAL
    )
/*++

Routine Description:

    Handles event enabling requests. Responds to all event identifiers
    defined by the sets. This function may only be called at PASSIVE_LEVEL.

Arguments:

    Irp -
        Contains the IRP with the enable request being handled. The file object
        associated with the IRP is stored with the event for later comparison
        when disabling the event.

    EventSetsCount -
        Indicates the number of event set structures being passed.

    EventSet -
        Contains the pointer to the list of event set information.

    EventsList -
        If the KSEVENT_ITEM.AddHandler for the event being enabled is
        NULL, then this must point to the head of the list of KSEVENT_ENTRY
        items on which the event is to be added. This method assumes a single
        list for at least a subset of events.

    EventsFlags -
        Contains flags specifying the type of exclusion lock to be used in
        accessing the event list, if any. If no flag is set, then no lock is
        taken. If a KSEVENT_ITEM.AddHandler for the event is specified,
        this parameter is ignored.

        KSEVENT_NONE -
            No lock.

        KSEVENTS_SPINLOCK -
            The lock is assumed to be a KSPIN_LOCK.

        KSEVENTS_MUTEX -
            The lock is assumed to be a KMUTEX.

        KSEVENTS_FMUTEX -
            The lock is assumed to be a FAST_MUTEX, and is acquired by raising
            IRQL to APC_LEVEL.

        KSEVENTS_FMUTEXUNSAFE -
            The lock is assumed to be a FAST_MUTEX, and is acquired without
            raising IRQL to APC_LEVEL.

        KSEVENTS_INTERRUPT -
            The lock is assumed to be an interrupt synchronization spin lock.

        KSEVENTS_ERESOURCE -
            The lock is assumed to be an ERESOURCE.

    EventsLock -
        If the KSEVENT_ITEM.AddHandler for the event being enabled is
        NULL, then this is used to synchronize access to the list. This may be
        NULL if no flag is set in EventsFlags.

    Allocator -
        Optionally contains the callback with which a mapped buffer
        request will be made. If this is not provided, pool memory
        will be used. If specified, this allocates memory for the event
        IRP using a callback. This can be used to allocate specific
        memory for event request, such as mapped memory. Note that this
        assumes that event Irp's passed to a filter have not been
        manipulated before being sent. It is invalid to directly forward
        an event Irp.

    EventItemSize -
        Optionally contains an alternate event item size to use when
        incrementing the current event item counter. If this is a
        non-zero value, it is assumed to contain the size of the increment,
        and directs the function to pass a pointer to the event item
        located in the DriverContext field accessed through the
        KSEVENT_ITEM_IRP_STORAGE macro.

Return Value:

    Returns STATUS_SUCCESS, else an error specific to the event being
    enabled. Always sets the IO_STATUS_BLOCK.Information field of the
    PIRP.IoStatus element within the IRP to zero. It does not set the
    IO_STATUS_BLOCK.Status field, nor complete the IRP however.

--*/
{
    PAGED_CODE();
    return KspEnableEvent(
        Irp,
        EventSetsCount,
        EventSet,
        EventsList,
        EventsFlags,
        EventsLock,
        Allocator,
        EventItemSize,
        NULL,
        0,
        FALSE
        );
}


NTSTATUS
KspEnableEvent(
    IN PIRP Irp,
    IN ULONG EventSetsCount,
    IN const KSEVENT_SET* EventSet,
    IN OUT PLIST_ENTRY EventsList OPTIONAL,
    IN KSEVENTS_LOCKTYPE EventsFlags OPTIONAL,
    IN PVOID EventsLock OPTIONAL,
    IN PFNKSALLOCATOR Allocator OPTIONAL,
    IN ULONG EventItemSize OPTIONAL,
    IN const KSAUTOMATION_TABLE*const* NodeAutomationTables OPTIONAL,
    IN ULONG NodesCount,
    IN BOOLEAN CopyItemAndSet
    )
/*++

Routine Description:

    Handles event enabling requests. Responds to all event identifiers
    defined by the sets. This function may only be called at PASSIVE_LEVEL.

Arguments:

    Irp -
        Contains the IRP with the enable request being handled. The file object
        associated with the IRP is stored with the event for later comparison
        when disabling the event.

    EventSetsCount -
        Indicates the number of event set structures being passed.

    EventSet -
        Contains the pointer to the list of event set information.

    EventsList -
        If the KSEVENT_ITEM.AddHandler for the event being enabled is
        NULL, then this must point to the head of the list of KSEVENT_ENTRY
        items on which the event is to be added. This method assumes a single
        list for at least a subset of events.

    EventsFlags -
        Contains flags specifying the type of exclusion lock to be used in
        accessing the event list, if any. If no flag is set, then no lock is
        taken. If a KSEVENT_ITEM.AddHandler for the event is specified,
        this parameter is ignored.

        KSEVENT_NONE -
            No lock.

        KSEVENTS_SPINLOCK -
            The lock is assumed to be a KSPIN_LOCK.

        KSEVENTS_MUTEX -
            The lock is assumed to be a KMUTEX.

        KSEVENTS_FMUTEX -
            The lock is assumed to be a FAST_MUTEX, and is acquired by raising
            IRQL to APC_LEVEL.

        KSEVENTS_FMUTEXUNSAFE -
            The lock is assumed to be a FAST_MUTEX, and is acquired without
            raising IRQL to APC_LEVEL.

        KSEVENTS_INTERRUPT -
            The lock is assumed to be an interrupt synchronization spin lock.

        KSEVENTS_ERESOURCE -
            The lock is assumed to be an ERESOURCE.

    EventsLock -
        If the KSEVENT_ITEM.AddHandler for the event being enabled is
        NULL, then this is used to synchronize access to the list. This may be
        NULL if no flag is set in EventsFlags.

    Allocator -
        Optionally contains the callback with which a mapped buffer
        request will be made. If this is not provided, pool memory
        will be used. If specified, this allocates memory for the event
        IRP using a callback. This can be used to allocate specific
        memory for event request, such as mapped memory. Note that this
        assumes that event Irp's passed to a filter have not been
        manipulated before being sent. It is invalid to directly forward
        an event Irp.

    EventItemSize -
        Optionally contains an alternate event item size to use when
        incrementing the current event item counter. If this is a
        non-zero value, it is assumed to contain the size of the increment,
        and directs the function to pass a pointer to the event item
        located in the DriverContext field accessed through the
        KSEVENT_ITEM_IRP_STORAGE macro.

    NodeAutomationTables -
        Optional table of automation tables for nodes.

    NodesCount -
        Count of nodes.

    CopyItemAndSet -
        Indicates whether or not the event item and event set are copied
        into overallocated space in the extended event entry (non-paged).

Return Value:

    Returns STATUS_SUCCESS, else an error specific to the event being
    enabled. Always sets the IO_STATUS_BLOCK.Information field of the
    PIRP.IoStatus element within the IRP to zero. It does not set the
    IO_STATUS_BLOCK.Status field, nor complete the IRP however.

--*/
{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpStack;
    ULONG InputBufferLength;
    ULONG OutputBufferLength;
    ULONG AlignedBufferLength;
    PKSEVENTDATA EventData;
    PKSEVENT Event;
    ULONG LocalEventItemSize;
    ULONG RemainingSetsCount;
    ULONG Flags;

    PAGED_CODE();
    //
    // Determine the offsets to both the Event and EventData parameters based
    // on the lengths of the DeviceIoControl parameters. A single allocation is
    // used to buffer both parameters. The EventData (or results on a support
    // query) is stored first, and the Event is stored second, on
    // FILE_QUAD_ALIGNMENT.
    //
    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    InputBufferLength = IrpStack->Parameters.DeviceIoControl.InputBufferLength;
    OutputBufferLength = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;
    AlignedBufferLength = (OutputBufferLength + FILE_QUAD_ALIGNMENT) & ~FILE_QUAD_ALIGNMENT;
    //
    // Determine if the parameters have already been buffered by a previous
    // call to this function.
    //
    if (!Irp->AssociatedIrp.SystemBuffer) {
        //
        // Initially just check for the minimal event parameter length. The
        // actual minimal length will be validated when the event item is found.
        // Also ensure that the output and input buffer lengths are not set so
        // large as to overflow when aligned or added.
        //
        if ((InputBufferLength < sizeof(*Event)) || (AlignedBufferLength < OutputBufferLength) || (AlignedBufferLength + InputBufferLength < AlignedBufferLength)) {
            return STATUS_INVALID_BUFFER_SIZE;
        }
        try {
            //
            // Validate the pointers if the client is not trusted.
            //
            if (Irp->RequestorMode != KernelMode) {
                ProbeForRead(IrpStack->Parameters.DeviceIoControl.Type3InputBuffer, InputBufferLength, sizeof(BYTE));
            }
            //
            // Capture flags first so that they can be used to determine allocation.
            //
            Flags = ((PKSEVENT)IrpStack->Parameters.DeviceIoControl.Type3InputBuffer)->Flags;
            //
            // Allocate space for both parameters, and set the cleanup flags
            // so that normal Irp completion will take care of the buffer.
            //
            if (Allocator && !(Flags & KSIDENTIFIER_SUPPORTMASK)) {
                //
                // The allocator callback places the buffer into SystemBuffer.
                // The flags must be updated by the allocation function if they
                // apply.
                //
                Status = Allocator(Irp, AlignedBufferLength + InputBufferLength, FALSE);
                if (!NT_SUCCESS(Status)) {
                    return Status;
                }
            } else {
                //
                // No allocator was specified, so just use pool memory.
                //
                Irp->AssociatedIrp.SystemBuffer = ExAllocatePoolWithQuotaTag(NonPagedPool, AlignedBufferLength + InputBufferLength, 'ppSK');
                Irp->Flags |= (IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER);
            }
            //
            // Copy the Event parameter.
            //
            RtlCopyMemory((PUCHAR)Irp->AssociatedIrp.SystemBuffer + AlignedBufferLength, IrpStack->Parameters.DeviceIoControl.Type3InputBuffer, InputBufferLength);
            //
            // Rewrite the previously captured flags.
            //
            ((PKSEVENT)((PUCHAR)Irp->AssociatedIrp.SystemBuffer + AlignedBufferLength))->Flags = Flags;
            //
            // Validate the request flags. At the same time set up the IRP flags
            // for an input operation if there is an input buffer available so
            // that Irp completion will copy the data to the client's original
            // buffer.
            //
            Flags &= ~KSEVENT_TYPE_TOPOLOGY;
            switch (Flags) {
            case KSEVENT_TYPE_ENABLE:
            case KSEVENT_TYPE_ONESHOT:
            case KSEVENT_TYPE_ENABLEBUFFERED:
                if (OutputBufferLength) {
                    if (Irp->RequestorMode != KernelMode) {
                        ProbeForRead(Irp->UserBuffer, OutputBufferLength, sizeof(BYTE));
                    }
                    RtlCopyMemory(Irp->AssociatedIrp.SystemBuffer, Irp->UserBuffer, OutputBufferLength);
                }
                break;
            case KSEVENT_TYPE_SETSUPPORT:
            case KSEVENT_TYPE_BASICSUPPORT:
            case KSEVENT_TYPE_QUERYBUFFER:
                if (OutputBufferLength) {
                    if (Irp->RequestorMode != KernelMode) {
                        ProbeForWrite(Irp->UserBuffer, OutputBufferLength, sizeof(BYTE));
                    }
                    Irp->Flags |= IRP_INPUT_OPERATION;
                }
                if (Flags == KSEVENT_TYPE_QUERYBUFFER) {
                    KSQUERYSYNC Synchronize;
                    PKSQUERYBUFFER QueryBuffer;

                    //
                    // The Event parameter must contain the pointer to the
                    // original EventData.
                    //
                    if (InputBufferLength < sizeof(KSQUERYBUFFER)) {
                        return STATUS_INVALID_BUFFER_SIZE;
                    }
                    QueryBuffer = (PKSQUERYBUFFER)((PUCHAR)Irp->AssociatedIrp.SystemBuffer + AlignedBufferLength);
                    if (QueryBuffer->Reserved) {
                        return STATUS_INVALID_PARAMETER;
                    }
                    //
                    // Synchronize with the event list while locating the
                    // specified entry before extracting the specified buffer.
                    //
                    Synchronize.EventsList = EventsList;
                    Synchronize.FileObject = IrpStack->FileObject;
                    Synchronize.Irp = Irp;
                    Synchronize.EventData = QueryBuffer->EventData;
                    Synchronize.BufferLength = OutputBufferLength;
                    Synchronize.Status = STATUS_SUCCESS;
                    PerformLockedOperation(EventsFlags, EventsLock, QueryBufferSynchronize, &Synchronize);
                    if (NT_SUCCESS(Synchronize.Status)) {
                        //
                        // This has not been copied back yet.
                        //
                        RtlCopyMemory((PUCHAR)Irp->AssociatedIrp.SystemBuffer, Synchronize.BufferEntry + 1, Synchronize.BufferEntry->Length);
                        Irp->IoStatus.Information = Synchronize.BufferEntry->Length;
                        //
                        // This buffer was passed by the driver during event
                        // notification.
                        //
                        ExFreePool(Synchronize.BufferEntry);
                    }
                    return Synchronize.Status;
                }
                break;
            default:
                return STATUS_INVALID_PARAMETER;
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }
    }
    //
    // If there is EventData, retrieve a pointer to the buffered copy of it.
    // This is the first portion of the SystemBuffer.
    //
    if (OutputBufferLength) {
        EventData = Irp->AssociatedIrp.SystemBuffer;
    } else {
        EventData = NULL;
    }
    //
    // Retrieve a pointer to the Event, which is on FILE_LONG_ALIGNMENT within
    // the SystemBuffer, after any EventData.
    //
    Event = (PKSEVENT)((PUCHAR)Irp->AssociatedIrp.SystemBuffer + AlignedBufferLength);
    //
    // Optionally call back if this is a node request.
    //
    Flags = Event->Flags;
    if (Event->Flags & KSEVENT_TYPE_TOPOLOGY) {
        //
        // Input buffer must include the node ID.
        //
        PKSE_NODE nodeEvent = (PKSE_NODE) Event;
        if (InputBufferLength < sizeof(*nodeEvent)) {
            return STATUS_INVALID_BUFFER_SIZE;
        }
        if (NodeAutomationTables) {
            const KSAUTOMATION_TABLE* automationTable;
            if (nodeEvent->NodeId >= NodesCount) {
                return STATUS_INVALID_DEVICE_REQUEST;
            }
            automationTable = NodeAutomationTables[nodeEvent->NodeId];
            if ((! automationTable) || (automationTable->EventSetsCount == 0)) {
                return STATUS_NOT_FOUND;
            }
            EventSetsCount = automationTable->EventSetsCount;
            EventSet = automationTable->EventSets;
            EventItemSize = automationTable->EventItemSize;
        }
        Flags &= ~KSEVENT_TYPE_TOPOLOGY;
    }
    //
    // Allow the caller to indicate a size for each event item.
    //
    if (EventItemSize) {
        ASSERT(EventItemSize >= sizeof(KSEVENT_ITEM));
        LocalEventItemSize = EventItemSize;
    } else {
        LocalEventItemSize = sizeof(KSEVENT_ITEM);
    }
    //
    // Search for the specified Event set within the list of sets given. Don't modify
    // the EventSetsCount so that it can be used later in case this is a query for
    // the list of sets supported. Don't do that comparison first (GUID_NULL),
    // because it is rare.
    //
    for (RemainingSetsCount = EventSetsCount; RemainingSetsCount; EventSet++, RemainingSetsCount--) {
        if (IsEqualGUIDAligned(&Event->Set, EventSet->Set)) {
            const KSEVENT_ITEM* EventItem;
            PKSIEVENT_ENTRY EventEntryEx;

            if (Flags & KSIDENTIFIER_SUPPORTMASK) {
                //
                // Querying basic support of a particular event in the set.
                // The only other support item is KSEVENT_TYPE_SETSUPPORT,
                // which is querying support of the set in general. That
                // just returns STATUS_SUCCESS, so it is a fall-through
                // case.
                //
                if (Flags == KSEVENT_TYPE_BASICSUPPORT) {
                    //
                    // Attempt to locate the event item within the set already found.
                    //
                    if (!(EventItem = FindEventItem(EventSet, LocalEventItemSize, Event->Id))) {
                        return STATUS_NOT_FOUND;
                    }
                    //
                    // Some filters want to do their own processing, so a pointer to
                    // the set is placed in any IRP forwarded.
                    //
                    KSEVENT_SET_IRP_STORAGE(Irp) = EventSet;
                    //
                    // Optionally provide event item context.
                    //
                    if (EventItemSize) {
                        KSEVENT_ITEM_IRP_STORAGE(Irp) = EventItem;
                    }
                    //
                    // If the item contains an entry for a query support handler of its
                    // own, then call that handler. The return from that handler
                    // indicates that:
                    //
                    // 1. The item is supported, and the handler filled in the request.
                    // 2. The item is supported, but the handler did not fill anything in.
                    // 3. The item is supported, but the handler is waiting to modify
                    //    what is filled in.
                    // 4. The item is not supported, and an error it to be returned.
                    // 5. A pending return.
                    //
                    if (EventItem->SupportHandler &&
                        (!NT_SUCCESS(Status = EventItem->SupportHandler(Irp, Event, EventData)) ||
                        (Status != STATUS_SOME_NOT_MAPPED)) &&
                        (Status != STATUS_MORE_PROCESSING_REQUIRED)) {
                        //
                        // If 1) the item is not supported, 2) it is supported and the
                        // handler filled in the request, or 3) a pending return, then
                        // return the status. For the case of the item being
                        // supported, and the handler not filling in the requested
                        // information, STATUS_SOME_NOT_MAPPED or
                        // STATUS_MORE_PROCESSING_REQUIRED will continue on with
                        // default processing.
                        //
                        return Status;
                    }
                }
                //
                // Either this is a query for support of the set as a whole, or a query
                // in which the item handler indicated support, but did not fill in the
                // requested information. In either case it is a success.
                //
                return STATUS_SUCCESS;
            }
            //
            // Attempt to locate the event item within the set already found.
            //
            if (!(EventItem = FindEventItem(EventSet, LocalEventItemSize, Event->Id))) {
                return STATUS_NOT_FOUND;
            }
            if (OutputBufferLength < EventItem->DataInput) {
                return STATUS_BUFFER_TOO_SMALL;
            }
            //
            // Allocate room for not only the basic entry, but also room for any extra
            // data that this particular event may need.
            //
            EventEntryEx = ExAllocatePoolWithTag(
                NonPagedPool,
                sizeof(*EventEntryEx) + EventItem->ExtraEntryData +
                    (CopyItemAndSet ? 
                        (sizeof (KSEVENT_SET) + EventItemSize +
                        FILE_QUAD_ALIGNMENT) : 
                        0),
                KSSIGNATURE_EVENT_ENTRY);
            if (EventEntryEx) {
                //
                // Capture the pointer to the EventData and requested notification
                // type.
                //
                EventEntryEx->RemoveHandler = EventItem->RemoveHandler;
                INIT_POINTERALIGNMENT(EventEntryEx->Alignment);
                EventEntryEx->Event = *Event;
                EventEntryEx->EventEntry.Object = NULL;
                EventEntryEx->EventEntry.DpcItem = NULL;
                EventEntryEx->EventEntry.EventData = Irp->UserBuffer;
                EventEntryEx->EventEntry.NotificationType = EventData->NotificationType;
                EventEntryEx->EventEntry.EventSet = EventSet;
                EventEntryEx->EventEntry.EventItem = EventItem;
                EventEntryEx->EventEntry.FileObject = IrpStack->FileObject;
                EventEntryEx->EventEntry.Reserved = 0;
                if (Flags == KSEVENT_TYPE_ONESHOT) {
                    //
                    // This may be a oneshot event. This flag is checked during
                    // event generation in order to determine if the entry
                    // should automatically be deleted after the first signal.
                    //
                    EventEntryEx->EventEntry.Flags = KSEVENT_ENTRY_ONESHOT;
                } else if (Flags == KSEVENT_TYPE_ENABLEBUFFERED) {
                    //
                    // This may have buffering turned on, which means that
                    // the buffered list must be cleaned up when deleted. It
                    // also ensures that a call to KsGenerateDataEvent will
                    // buffer data.
                    //
                    EventEntryEx->EventEntry.Flags = KSEVENT_ENTRY_BUFFERED;
                } else {
                    EventEntryEx->EventEntry.Flags = 0;
                }
                //
                // If the event entry was overallocated, copy the set and item
                // info ensuring that the allocation is aligned to the correct
                // alignment.
                //
                if (CopyItemAndSet) {
                    PUCHAR CopiedSet = 
                        (PUCHAR)EventEntryEx + 
                            ((sizeof (*EventEntryEx) + 
                            EventItem->ExtraEntryData + FILE_QUAD_ALIGNMENT)
                            & ~FILE_QUAD_ALIGNMENT);

                    RtlCopyMemory (
                        CopiedSet,
                        EventSet,
                        sizeof (KSEVENT_SET)
                        );

                    RtlCopyMemory (
                        CopiedSet + sizeof (KSEVENT_SET),
                        EventItem,
                        LocalEventItemSize
                        );


                    EventEntryEx->EventEntry.EventSet = 
                        (PKSEVENT_SET)CopiedSet;
                    EventEntryEx->EventEntry.EventItem =
                        (PKSEVENT_ITEM)(CopiedSet + sizeof (KSEVENT_SET));
                }

                switch (EventEntryEx->EventEntry.NotificationType) {

                case KSEVENTF_EVENT_HANDLE:
                    //
                    // Determine if this is a handle of any sort that can be signalled.
                    //
                    if (!EventData->EventHandle.Reserved[0] && !EventData->EventHandle.Reserved[1]) {
                        Status = ObReferenceObjectByHandle(
                            EventData->EventHandle.Event,
                            EVENT_MODIFY_STATE,
                            *ExEventObjectType,
                            Irp->RequestorMode,
                            &EventEntryEx->EventEntry.Object,
                            NULL);
                    } else {
                        Status = STATUS_INVALID_PARAMETER;
                    }
                    break;

                case KSEVENTF_SEMAPHORE_HANDLE:
                    //
                    // Determine if this is a handle of any sort
                    // that can be signalled.
                    //
                    if (!EventData->SemaphoreHandle.Reserved) {
                        Status = ObReferenceObjectByHandle(
                            EventData->SemaphoreHandle.Semaphore,
                            SEMAPHORE_MODIFY_STATE,
                            *ExSemaphoreObjectType,
                            Irp->RequestorMode,
                            &EventEntryEx->EventEntry.Object,
                            NULL);
                        if (NT_SUCCESS(Status)) {
                            //
                            // Capture the semaphore adjustment
                            //
                            EventEntryEx->EventEntry.SemaphoreAdjustment = EventData->SemaphoreHandle.Adjustment;
                        }
                    } else {
                        Status = STATUS_INVALID_PARAMETER;
                    }
                    break;

                case KSEVENTF_EVENT_OBJECT:
                case KSEVENTF_DPC:
                case KSEVENTF_WORKITEM:
                case KSEVENTF_KSWORKITEM:
                    //
                    // These types of notifications are only available to Kernel
                    // Mode clients. Note that the placement of the Reserved
                    // field is assumed to be the same for these structures.
                    //
                    if ((Irp->RequestorMode == KernelMode) && !EventData->EventObject.Reserved) {
                        Status = STATUS_SUCCESS;
                    } else {
                        Status = STATUS_INVALID_PARAMETER;
                    }
                    break;

                case KSEVENTF_SEMAPHORE_OBJECT:
                    //
                    // This type of notification is only available to Kernel
                    // Mode clients.
                    //
                    if (Irp->RequestorMode == KernelMode) {
                        Status = STATUS_SUCCESS;
                        break;
                    }
                    // No break

                default:

                    Status = STATUS_INVALID_PARAMETER;
                    break;

                }

                if (NT_SUCCESS(Status)) {
                    WORK_QUEUE_TYPE WorkQueueType;

                    //
                    // Set up the event entry based on the notification type.
                    // This may involve creating space for an internal Dpc
                    // structure to handle notification requests performed at
                    // raised IRQL, which need to be deferred to a Dpc.
                    //
                    switch (EventEntryEx->EventEntry.NotificationType) {

                        KDPC_IMPORTANCE Importance;

                    case KSEVENTF_EVENT_HANDLE:
                    case KSEVENTF_SEMAPHORE_HANDLE:

                        //
                        // If the event it triggered at high IRQL, it will
                        // need a Dpc to signal the event object.
                        //
                        Status = CreateDpc(&EventEntryEx->EventEntry, EventDpc, LowImportance);
                        break;

                    case KSEVENTF_EVENT_OBJECT:
                    case KSEVENTF_SEMAPHORE_OBJECT:

                        //
                        // A kernel mode client can select the boost the
                        // waiting thread will receive on being signaled.
                        // This internally corresponds to a higher importance
                        // Dpc. This is only specified internally, and can
                        // be removed if abused. This assumes identical
                        // structures between event and semaphore.
                        //
                        switch (EventData->EventObject.Increment) {

                        case IO_NO_INCREMENT:

                            Importance = LowImportance;
                            break;

                        case EVENT_INCREMENT:

                            Importance = MediumImportance;
                            break;

                        default:

                            Importance = HighImportance;
                            break;

                        }
                        //
                        // If the event it triggered at high IRQL, it will
                        // need a Dpc to signal the event object.
                        //
                        Status = CreateDpc(&EventEntryEx->EventEntry, EventDpc, Importance);
                        break;

                    case KSEVENTF_DPC:

                        //
                        // Since the event generation may be called at high
                        // Irql, the cleanup of the one shot item must be
                        // delayed. So a Dpc structure needs to be allocated
                        // in order to queue a work item to do the cleanup.
                        //
                        if (EventEntryEx->EventEntry.Flags & KSEVENT_ENTRY_ONESHOT) {
                            Status = CreateDpc(&EventEntryEx->EventEntry, OneShotDpc, MediumImportance);
                        }
                        break;

                    case KSEVENTF_WORKITEM:
                        //
                        // The WorkQueueItem should not be NULL in any case, but
                        // since this is valid in a KSEVENTF_KSWORKITEM, and used
                        // to check for counted workers, then this condition
                        // should especially be looked for.
                        //
                        ASSERT(EventData->WorkItem.WorkQueueItem);
                        /* no break */
                    case KSEVENTF_KSWORKITEM:
                        if (EventEntryEx->EventEntry.NotificationType == KSEVENTF_WORKITEM) {
                            WorkQueueType = EventData->WorkItem.WorkQueueType;
                        } else {
                            WorkQueueType = KsiQueryWorkQueueType(EventData->KsWorkItem.KsWorkerObject);
                        }
                        //
                        // A kernel mode client can specify which type of
                        // work queue on which the work item will be
                        // placed when the event is triggered.
                        // This internally corresponds to a higher importance
                        // Dpc. This is only specified internally, and can
                        // be removed if abused.
                        //
                        switch (WorkQueueType) {

                        case CriticalWorkQueue:

                            Importance = MediumImportance;
                            break;

                        case DelayedWorkQueue:

                            Importance = LowImportance;
                            break;

                        case HyperCriticalWorkQueue:

                            Importance = HighImportance;
                            break;

                        }
                        Status = CreateDpc(&EventEntryEx->EventEntry, WorkerDpc, Importance);
                        break;

                    }
                }
                //
                // If the event data is being buffered, and a place to put
                // the buffering has not yet been created, do so now.
                //
                if (NT_SUCCESS(Status) &&
                    (EventEntryEx->EventEntry.Flags & KSEVENT_ENTRY_BUFFERED) &&
                    !EventEntryEx->EventEntry.BufferItem) {
                    //
                    // Just use a random entry point for the DPC, since it will
                    // never be queued.
                    //
                    Status = CreateDpc(&EventEntryEx->EventEntry, WorkerDpc, LowImportance);
                }
                if (NT_SUCCESS(Status)) {
                    if (EventItem->AddHandler) {
                        //
                        // If the enable is to be worked on asynchronously, then
                        // the entry item needs to be saved. This already contains
                        // a pointer to the EventSet.
                        //
                        KSEVENT_ENTRY_IRP_STORAGE(Irp) = &EventEntryEx->EventEntry;
                        //
                        // Optionally provide event item context.
                        //
                        if (EventItemSize) {
                            KSEVENT_ITEM_IRP_STORAGE(Irp) = EventItem;
                        }
                        //
                        // If the item specifies a handler, then just call it to
                        // add the new event. The function is expected to do all
                        // synchronization when adding the event.
                        //
                        if (NT_SUCCESS(Status =
                                EventItem->AddHandler(Irp, EventData, &EventEntryEx->EventEntry)) ||
                                (Status == STATUS_PENDING)) {
                            return Status;
                        }
                    } else {
                        KSENABLESYNC    Synchronize;
                        //
                        // There is no item add handler, so use the default
                        // method of adding an event to the list, which includes
                        // acquiring any specified lock.
                        //
                        Synchronize.EventsList = EventsList;
                        Synchronize.EventEntry = &EventEntryEx->EventEntry;
                        PerformLockedOperation(EventsFlags, EventsLock, AddEventSynchronize, &Synchronize);
                        return STATUS_SUCCESS;
                    }
                }
                //
                // Somewhere the addition failed, or the parameters were invalid,
                // so discard the event.
                //
                KsDiscardEvent(&EventEntryEx->EventEntry);
                return Status;
            } else {
                return STATUS_INSUFFICIENT_RESOURCES;
            }
        }
    }
    //
    // The outer loop looking for event sets fell through with no match. This may
    // indicate that this is a support query for the list of all event sets
    // supported. There is no other way out of the outer loop without returning.
    //
    // Specifying a GUID_NULL as the set means that this is a support query
    // for all sets.
    //
    if (!IsEqualGUIDAligned(&Event->Set, &GUID_NULL)) {
        return STATUS_PROPSET_NOT_FOUND;
    }
    //
    // The support flag must have been used so that the IRP_INPUT_OPERATION
    // is set. For future expansion, the identifier within the set is forced
    // to be zero.
    //
    if (Event->Id || (Flags != KSEVENT_TYPE_SETSUPPORT)) {
        return STATUS_INVALID_PARAMETER;
    }
    //
    // The query can request the length of the needed buffer, or can
    // specify a buffer which is at least long enough to contain the
    // complete list of GUID's.
    //
    if (!OutputBufferLength) {
        //
        // Return the size of the buffer needed for all the GUID's.
        //
        Irp->IoStatus.Information = EventSetsCount * sizeof(GUID);
        return STATUS_BUFFER_OVERFLOW;
#ifdef SIZE_COMPATIBILITY
    } else if (OutputBufferLength == sizeof(OutputBufferLength)) {
        *(PULONG)Irp->AssociatedIrp.SystemBuffer = EventSetsCount * sizeof(GUID);
        Irp->IoStatus.Information = sizeof(OutputBufferLength);
        return STATUS_SUCCESS;
#endif // SIZE_COMPATIBILITY
    } else if (OutputBufferLength < EventSetsCount * sizeof(GUID)) {
        //
        // The buffer was too short for all the GUID's.
        //
        return STATUS_BUFFER_TOO_SMALL;
    } else {
        GUID* Guid;

        Irp->IoStatus.Information = EventSetsCount * sizeof(*Guid);
        EventSet -= EventSetsCount;
        for (Guid = (GUID*)EventData; EventSetsCount; Guid++, EventSet++, EventSetsCount--) {
            *Guid = *EventSet->Set;
        }
    }
    return STATUS_SUCCESS;
}


KSDDKAPI
VOID
NTAPI
KsDiscardEvent(
    IN PKSEVENT_ENTRY EventEntry
    )
/*++

Routine Description:

    Discards the memory used by an event entry, after dereferening any
    referenced objects. This would normally be called when manually
    disabling events which had not been disabled by the event owner if
    for some reason KsFreeEventList could not be used. For instance, when
    an asynchronous enable of an event fails, and the event entry needs to
    be discarded.

    Normally this would automatically be called within KsDisableEvent
    when a request to disable an event occurred or within
    KsFreeEventList when freeing a list of events. This function may
    only be called at PASSIVE_LEVEL.

Arguments:

    EventEntry -
        Contains the pointer to the entry to discard. This pointer is no longer
        valid after a successful call to this function.

Return Value:

    Nothing.

--*/
{
    PAGED_CODE();
    //
    // If DpcItem has been allocated (for KSEVENTF_HANDLE, KSEVENTF_OBJECT,
    // KSEVENTF_WORKITEM and KSEVENTF_KSWORKITEM) to perform work at a lower
    // IRQ level, or for the BufferList, free it.
    //
    if (EventEntry->DpcItem) {
        KIRQL oldIrql;

        //
        // First remove any Dpc which is currently queued to reduce wait time.
        //
        if (KeRemoveQueueDpc(&EventEntry->DpcItem->Dpc)) {
            InterlockedDecrement((PLONG)&EventEntry->DpcItem->ReferenceCount);
        }
        //
        // Synchronize with any Dpc's accessing data structures, then determine
        // if there is any such Dpc code actually running still. If there is,
        // then just exit. The last Dpc running will delete the entry. The Dpc's
        // do not release the spinlock until after accessing the structures.
        //
        // Set the Deleted flag so that any Dpc about to run will not access the
        // user's event data. This flag is checked in any Dpc after acquiring
        // the spin lock, but before referencing any client data pointed to by
        // the event structure. Aquiring the spin lock will synchronize any
        // outstanding Dpc with this function. Nothing will be deleted, since
        // there is still an outstanding reference count on the structure that
        // will be decremented below.
        //
        EventEntry->Flags |= KSEVENT_ENTRY_DELETED;
        //
        // If this is a oneshot, then it can only be deleted by the client
        // before the event has fired, or after the single generated Dpc
        // has finished its work, so there is no need to synchronize with it.
        //
        if (!(EventEntry->Flags & KSEVENT_ENTRY_ONESHOT)) {
            KeAcquireSpinLock(&EventEntry->DpcItem->AccessLock, &oldIrql);
            KeReleaseSpinLock(&EventEntry->DpcItem->AccessLock, oldIrql);
        }
        //
        // Possibly referenced an event object if using KSEVENTF_HANDLE. Since
        // the Deleted flag is set, this may be dereferenced now.
        //
        if (EventEntry->Object) {
            ObDereferenceObject(EventEntry->Object);
        }
        //
        // The reference count which was initially incremented when the event was
        // enabled can be removed. If the result indicates that any Dpc was about
        // to execute, then just exit here rather than delete the structures, as
        // the last Dpc will delete any structures.
        //
        if (InterlockedDecrement((PLONG)&EventEntry->DpcItem->ReferenceCount)) {
            return;
        }
        if (EventEntry->Flags & KSEVENT_ENTRY_BUFFERED) {
            //
            // Any entries left on the list need to be discarded.
            //
            while (!IsListEmpty(&EventEntry->BufferItem->BufferList)) {
                PLIST_ENTRY     ListEntry;
                PKSBUFFER_ENTRY BufferEntry;

                ListEntry = RemoveHeadList(&EventEntry->BufferItem->BufferList);
                BufferEntry = CONTAINING_RECORD(
                    ListEntry,
                    KSBUFFER_ENTRY,
                    ListEntry);
                ExFreePool(BufferEntry);
            }
        }
        ExFreePool(EventEntry->DpcItem);
    } else if (EventEntry->Object) {
        //
        // Possibly referenced an event object if using KSEVENTF_HANDLE.
        //
        ObDereferenceObject(EventEntry->Object);
    }
    //
    // Free the outer structure, which includes the hidden header on the
    // entry.
    //
    ExFreePool(CONTAINING_RECORD(EventEntry, KSIEVENT_ENTRY, EventEntry));
}


BOOLEAN
GenerateEventListSynchronize(
    IN PKSGENERATESYNC Synchronize
    )
/*++

Routine Description:

    Generates events while being synchronize with the list lock.

Arguments:

    Synchronize -
        Contains the event list and specified event within that list to generate.

Return Value:
    Returns TRUE.

--*/
{
    PLIST_ENTRY ListEntry;

    for (ListEntry = Synchronize->EventsList->Flink;
        ListEntry != Synchronize->EventsList;) {
        PKSIEVENT_ENTRY EventEntryEx;

        EventEntryEx = CONTAINING_RECORD(
            ListEntry,
            KSIEVENT_ENTRY,
            EventEntry.ListEntry);
        //
        // When enumerating the elements on the list, the next element
        // must be retrieved before calling the generate function, since
        // such a call may end up removing the event from the list, as
        // is the case for a oneshot.
        //
        ListEntry = ListEntry->Flink;
        //
        // If the identifier matches, then check to see if a set was
        // actually passed. All the entries may be known to be on a single
        // set, so there may be no need to compare the GUID's.
        //
        if ((Synchronize->EventId == EventEntryEx->Event.Id) &&
            (!Synchronize->Set || IsEqualGUIDAligned(Synchronize->Set, &EventEntryEx->Event.Set))) {
            KsGenerateEvent(&EventEntryEx->EventEntry);
        }
    }
    return TRUE;
}


KSDDKAPI
VOID
NTAPI
KsGenerateEventList(
    IN GUID* Set OPTIONAL,
    IN ULONG EventId,
    IN PLIST_ENTRY EventsList,
    IN KSEVENTS_LOCKTYPE EventsFlags,
    IN PVOID EventsLock
    )
/*++

Routine Description:

    Enumerates the list looking for the specified event to generate. This
    function may be called at Irql level if the locking mechanism permits
    it. It may not be called at an Irql that would prevent the list lock
    from being acquired. This function may also result in one or more calls
    to the RemoveHandler for event entries.

Arguments:

    Set -
        Optionally contains the set to which the event to be generated belongs.
        If present, this value is compared against the set identifier for each
        event in the list. If not present, the set identifiers are ignored,
        and just the specific event identifier is used in the comparison for
        matching events on the list. This saves some comparison time when all
        events are known to be contained in a single set.

    EventId -
        Contains the specific event identifier to look for on the list.

    EventsList -
        Points to the head of the list of KSEVENT_ENTRY items on which the
        event may be found.

    EventsFlags -
        Contains flags specifying the type of exclusion lock to be used in
        accessing the event list, if any. If no flag is set, then no lock is
        taken.

        KSEVENT_NONE -
            No lock.

        KSEVENTS_SPINLOCK -
            The lock is assumed to be a KSPIN_LOCK.

        KSEVENTS_MUTEX -
            The lock is assumed to be a KMUTEX.

        KSEVENTS_FMUTEX -
            The lock is assumed to be a FAST_MUTEX, and is acquired by raising
            IRQL to APC_LEVEL.

        KSEVENTS_FMUTEXUNSAFE -
            The lock is assumed to be a FAST_MUTEX, and is acquired without
            raising IRQL to APC_LEVEL.

        KSEVENTS_INTERRUPT -
            The lock is assumed to be an interrupt synchronization spin lock.

        KSEVENTS_ERESOURCE -
            The lock is assumed to be an ERESOURCE.

    EventsLock -
        This is used to synchronize access to an element on the list. The lock
        taken before enumerating the list, and released after enumeration.

Return Value:

    Nothing.

--*/
{
    KSGENERATESYNC Synchronize;

    //
    // Do not allow list manipulation while enumerating the list items.
    //
    Synchronize.EventsList = EventsList;
    Synchronize.Set = Set;
    Synchronize.EventId = EventId;
    PerformLockedOperation(EventsFlags, EventsLock, GenerateEventListSynchronize, &Synchronize);
}


BOOLEAN
DisableEventSynchronize(
    IN PKSDISABLESYNC Synchronize
    )
/*++

Routine Description:

    Disables a specific event while being synchronize with the list lock.

Arguments:

    Synchronize -
        Contains the event list specific event to disable.

Return Value:
    Returns TRUE if either the event was found, or the complete list was searched. If the
    event was found, it is placed in the Synchronize structure. Else returns FALSE to
    indicate a parameter validation error.

--*/
{
    PIO_STACK_LOCATION IrpStack;
    PLIST_ENTRY ListEntry;
    PKSEVENTDATA EventData;

    IrpStack = IoGetCurrentIrpStackLocation(Synchronize->Irp);
    EventData = (PKSEVENTDATA)IrpStack->Parameters.DeviceIoControl.Type3InputBuffer;
    for (ListEntry = Synchronize->EventsList->Flink;
        ListEntry != Synchronize->EventsList;
        ListEntry = ListEntry->Flink) {

        Synchronize->EventEntry = CONTAINING_RECORD(
            ListEntry,
            KSEVENT_ENTRY,
            ListEntry);
        //
        // The comparison is performed based on the original event data
        // pointer.
        //
        if (Synchronize->EventEntry->EventData == EventData) {
            //
            // This must be the same client, as this list might be servicing
            // multiple clients.
            //
            if (Synchronize->EventEntry->FileObject == IrpStack->FileObject) {
                PKSIEVENT_ENTRY EventEntryEx;

                EventEntryEx = CONTAINING_RECORD(Synchronize->EventEntry, KSIEVENT_ENTRY, EventEntry);
                //
                // Note that the list lock is already taken, and cannot
                // be released until the element is removed from the list.
                //
                REMOVE_ENTRY(EventEntryEx);
                return TRUE;
            } else {
                break;
            }
        }
    }
    //
    // Either the entry was not found on the list, or it was found but the
    // item did not belong to the client.
    //
    if (ListEntry == Synchronize->EventsList) {
        //
        // Wipe the entry so that the calling function knows there is nothing
        // to disable.
        //
        Synchronize->EventEntry = NULL;
        return TRUE;
    }
    return FALSE;
}


KSDDKAPI
NTSTATUS
NTAPI
KsDisableEvent(
    IN PIRP Irp,
    IN OUT PLIST_ENTRY EventsList,
    IN KSEVENTS_LOCKTYPE EventsFlags,
    IN PVOID EventsLock
    )
/*++

Routine Description:

    Handles event disable requests. Responds to all event previously enabled
    through KsEnableEvent. If the input buffer length is zero, it is assumed
    that all events on the list are to be disabled. Disabling all events on
    the list will also return STATUS_SUCCESS, so a caller which handles
    multiple lists may need to call this function multiple times if it's
    client was actually attempting to remove all events from all lists.

    It is important that the remove handler synchronize with event
    generation to ensure that when the event is removed from the list it is
    not currently being serviced. Access to this list is assumed to be
    controlled with the lock passed. This function may only be called at
    PASSIVE_LEVEL.

Arguments:

    Irp -
        This is passed to the removal function for context information. The
        file object associated with the IRP is used to compare against the
        file object originally specified when enabling the event. This allows
        a single event list to be used for multiple clients differentiated by
        file objects.

    EventsList -
        Points to the head of the list of KSEVENT_ENTRY items on which the
        event may be found. If the client uses multiple event lists, and does
        not know which list this event may be on, they may call this function
        multiple times. An event not found will return STATUS_UNSUCCESSFUL.

    EventsFlags -
        Contains flags specifying the type of exclusion lock to be used in
        accessing the event list, if any. If no flag is set, then no lock is
        taken.

        KSEVENT_NONE -
            No lock.

        KSEVENTS_SPINLOCK -
            The lock is assumed to be a KSPIN_LOCK.

        KSEVENTS_MUTEX -
            The lock is assumed to be a KMUTEX.

        KSEVENTS_FMUTEX -
            The lock is assumed to be a FAST_MUTEX, and is acquired by raising
            IRQL to APC_LEVEL.

        KSEVENTS_FMUTEXUNSAFE -
            The lock is assumed to be a FAST_MUTEX, and is acquired without
            raising IRQL to APC_LEVEL.

        KSEVENTS_INTERRUPT -
            The lock is assumed to be an interrupt synchronization spin lock.

        KSEVENTS_ERESOURCE -
            The lock is assumed to be an ERESOURCE.

    EventsLock -
        This is used to synchronize access to an element on the list. The lock
        is released after calling the removal function if any. The removal
        function must synchronize with event generation before actually
        removing the element from the list.

Return Value:

    Returns STATUS_SUCCESS, else an error specific to the event being
    enabled. Always sets the IO_STATUS_BLOCK.Information field of the
    PIRP.IoStatus element within the IRP to zero. It does not set the
    IO_STATUS_BLOCK.Status field, nor complete the IRP however. If the event
    was not found on the specified list, a status of STATUS_UNSUCCESSFUL is
    returned.

--*/
{
    PIO_STACK_LOCATION IrpStack;
    KSDISABLESYNC Synchronize;

    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);
    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    if (IrpStack->Parameters.DeviceIoControl.InputBufferLength < sizeof(KSEVENTDATA)) {
        //
        // The specified event data structure is not correct. This may mean that
        // either it is an invalid call, or that all events are to be disabled.
        //
        if (!IrpStack->Parameters.DeviceIoControl.InputBufferLength) {
            //
            // The client may wish to disable all outstanding events at once.
            // This allows all events on the list passed to be disabled. Since
            // the call returns success, a filter which handles multiple lists
            // must check the InputBufferLength to determine if each list should
            // be called for the client.
            //
            KsFreeEventList(IrpStack->FileObject, EventsList, EventsFlags, EventsLock);
            return STATUS_SUCCESS;
        }
        return STATUS_INVALID_BUFFER_SIZE;
    }
    //
    // Do not allow list manipulation while searching for the element to
    // disable.
    //
    Synchronize.EventsList = EventsList;
    Synchronize.Irp = Irp;
    if (PerformLockedOperation(EventsFlags, EventsLock, DisableEventSynchronize, &Synchronize)) {
        //
        // The event to discard is returned in the same structure passed.
        //
        if (Synchronize.EventEntry) {
            KsDiscardEvent(Synchronize.EventEntry);
            return STATUS_SUCCESS;
        }
        //
        // The parameters were OK, it was just not found on this list.
        //
        return STATUS_UNSUCCESSFUL;
    }
    return STATUS_INVALID_PARAMETER;
}


BOOLEAN
FreeEventListSynchronize(
    IN PKSDISABLESYNC Synchronize
    )
/*++

Routine Description:

    Disables a all events owned by a specific file object while being synchronize
    with the list lock.

Arguments:

    Synchronize -
        Contains the event list whose elements are to be disabled.

Return Value:
    Returns TRUE if an event to disable was found, and the list is to be enumerated
    again. Else returns FALSE to indicate that enumeration is complete, and no new
    item was found.

--*/
{
    PLIST_ENTRY ListEntry;

    for (; (ListEntry = Synchronize->EventsList->Flink) != Synchronize->EventsList;) {
        for (;;) {
            Synchronize->EventEntry = CONTAINING_RECORD(ListEntry, KSEVENT_ENTRY, ListEntry);
            //
            // Only check to see if this list element belongs to the client.
            //
            if (Synchronize->EventEntry->FileObject == Synchronize->FileObject) {
                PKSIEVENT_ENTRY EventEntryEx;

                EventEntryEx = CONTAINING_RECORD(Synchronize->EventEntry, KSIEVENT_ENTRY, EventEntry);
                //
                // Note that the list lock is already taken, and cannot
                // be released until the element is removed from the list.
                //
                REMOVE_ENTRY(EventEntryEx);
                //
                // Discard the current item and start over again at the top of the list.
                //
                return TRUE;
            }
            //
            // Check for end of list, which does not mean that the list is
            // empty, just that this enumeration has reached the end without
            // finding any matching entries.
            //
            if ((ListEntry = ListEntry->Flink) == Synchronize->EventsList) {
                //
                // Nothing to discard, and the loop is exited.
                //
                return FALSE;
            }
        }
    }
    return FALSE;
}


KSDDKAPI
VOID
NTAPI
KsFreeEventList(
    IN PFILE_OBJECT FileObject,
    IN OUT PLIST_ENTRY EventsList,
    IN KSEVENTS_LOCKTYPE EventsFlags,
    IN PVOID EventsLock
    )
/*++

Routine Description:

    Handles freeing all events from a specified list with the assumption
    that these events are composed of the standard KSEVENT_ENTRY
    structures. The function calls the remove handler, then
    KsDiscardEvent for each event. It does not assume that the caller
    is in the context of the event owner. This function may only be called
    at PASSIVE_LEVEL.

Arguments:

    FileObject -
        This is passed to the removal function for context information. The
        file object is used to compare against the file object originally
        specified when enabling the event. This allows a single event list
        to be used for multiple clients differentiated by file objects.

    EventsList -
        Points to the head of the list of KSEVENT_ENTRY items to be freed.
        If any events on the list are currently being disabled, they are
        passed over. If any new elements are added to the list while it is
        being processed they may not be freed.

    EventsFlags -
        Contains flags specifying the type of exclusion lock to be used in
        accessing the event list, if any. If no flag is set, then no lock is
        taken.

        KSEVENT_NONE -
            No lock.

        KSEVENTS_SPINLOCK -
            The lock is assumed to be a KSPIN_LOCK.

        KSEVENTS_MUTEX -
            The lock is assumed to be a KMUTEX.

        KSEVENTS_FMUTEX -
            The lock is assumed to be a FAST_MUTEX, and is acquired by raising
            IRQL to APC_LEVEL.

        KSEVENTS_FMUTEXUNSAFE -
            The lock is assumed to be a FAST_MUTEX, and is acquired without
            raising IRQL to APC_LEVEL.

        KSEVENTS_INTERRUPT -
            The lock is assumed to be an interrupt synchronization spin lock.

        KSEVENTS_ERESOURCE -
            The lock is assumed to be an ERESOURCE.

    EventsLock -
        This is used to synchronize access to an element on the list. The lock
        is released after calling the removal function if any. The removal
        function must synchronize with event generation before actually
        removing the element from the list.

Return Value:

    Nothing.

--*/
{
    KSDISABLESYNC Synchronize;

    //
    // Do not allow list manipulation while deleting the list items.
    //
    Synchronize.EventsList = EventsList;
    Synchronize.FileObject = FileObject;
    while (PerformLockedOperation(EventsFlags, EventsLock, FreeEventListSynchronize, &Synchronize)) {
        //
        // The event to discard is returned in the same structure passed.
        //
        if (Synchronize.EventEntry)
            KsDiscardEvent(Synchronize.EventEntry);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\ks\kcom.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    kcom.cpp

Abstract:

    Kernel COM

--*/

//
// Export the class methods without using the DEF files, since decorated
// names differ on various platforms.
//
#define COMDDKMETHOD __declspec(dllexport)

#include "ksp.h"
#include <kcom.h>

typedef struct {
    CLSID ClassId;
    LIST_ENTRY FactoryListEntry;
    LONG ObjectCount;
    KoCreateObjectHandler CreateObject;
    PFILE_OBJECT FileObject;
    NTSTATUS LoadStatus;
    KMUTEX InitializeLock;
} FACTORY_ENTRY, *PFACTORY_ENTRY;

typedef struct {
    KSOBJECT_HEADER Header;
    KoCreateObjectHandler CreateObjectHandler;
} SERVER_INSTANCE, *PSERVER_INSTANCE;

#ifdef ALLOC_PRAGMA
extern "C" {
NTSTATUS
DllInitialize(
    IN PUNICODE_STRING RegistryPath
    );
VOID
RemoveFactoryEntries(
    );
NTSTATUS
LoadService(
    IN REFCLSID ClassId,
    OUT PFILE_OBJECT* FileObject
    );
NTSTATUS
PnpAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );
VOID
DecrementObjectCount(
    IN REFCLSID ClassId
    );
NTSTATUS
CreateObject(
    IN PFACTORY_ENTRY FactoryEntry,
    IN IUnknown* UnkOuter OPTIONAL,
    IN REFIID InterfaceId,
    OUT PVOID* Interface
    );
NTSTATUS
KoDispatchCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
NTSTATUS
KoDispatchClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
COMDDKAPI
void
NTAPI
KoRelease(
    IN REFCLSID ClassId
    );
}
#pragma alloc_text(INIT, DllInitialize)
#pragma alloc_text(PAGE, RemoveFactoryEntries)
#pragma alloc_text(PAGE, LoadService)
#pragma alloc_text(PAGE, DecrementObjectCount)
#pragma alloc_text(PAGE, CreateObject)
#pragma alloc_text(PAGE, KoCreateInstance)
#pragma alloc_text(PAGE, KoDriverInitialize)
#pragma alloc_text(PAGE, KoDeviceInitialize)
#pragma alloc_text(PAGE, PnpAddDevice)
#pragma alloc_text(PAGE, KoDispatchCreate)
#pragma alloc_text(PAGE, KoDispatchClose)
#pragma alloc_text(PAGE, KoRelease)
#endif // ALLOC_PRAGMA

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA

static const WCHAR DeviceTypeCOMService[] = KOSTRING_CreateObject;

static const DEFINE_KSCREATE_DISPATCH_TABLE(DeviceCreateItems)
{
    DEFINE_KSCREATE_ITEM(KoDispatchCreate, DeviceTypeCOMService, 0)
};

static DEFINE_KSDISPATCH_TABLE(
    ServerDispatchTable,
    KsDispatchInvalidDeviceRequest,
    KsDispatchInvalidDeviceRequest,
    KsDispatchInvalidDeviceRequest,
    KsDispatchInvalidDeviceRequest,
    KoDispatchClose,
    KsDispatchQuerySecurity,
    KsDispatchSetSecurity,
    KsDispatchFastIoDeviceControlFailure,
    KsDispatchFastReadFailure,
    KsDispatchFastWriteFailure);

static KMUTEX ListLock;           // Lock for global factory list.
static LIST_ENTRY FactoryList;    // Global factory list.

//++++++++
#if (ENABLE_KSWMI)

LONG KsWmiEnable=0;
LONG KsWmiLogEnable=0;
TRACEHANDLE LoggerHandle;

// Allocate a lock buffer if we are to start to log wmi early
// we write wmi event into the buffer so we can write them later
// when we are really enabled. We know that we are enabled early
// by registry if KsWmiLogBufferSize !=0
KSPIN_LOCK KsWmiSpinLock;
PBYTE   KsWmiLogBuffer;
ULONG	KsWmiLogBufferSize;
ULONG	KsWmiLogOffset;
ULONG	KsWmiLogWriteOffset;
ULONG	KsWmiLogLost;

/* 0300b65f-48aa-4784-a0ac-849c92c67652 */
GUID controlGUID = {
    0x0300b65f,
    0x48aa,
    0x4784,
    0xa0, 0xac, 0x84, 0x9c, 0x92, 0xc6, 0x76, 0x52};

/* f5330bcd-0344-48b0-be72-7a5de1a8c9d9 */
GUID traceGUID = {
    0xf5330bcd,
    0x0344,
    0x48b0,
    0xbe, 0x72, 0x7a, 0x5d, 0xe1, 0xa8, 0xc9, 0xd9};

/* bed3ed21-ff01-4ee7-b045-a85b4dc2084d */
GUID trackGUID = {
    0xbed3ed21,
    0xff01,
    0x4ee7,
    0xb0, 0x45, 0xa8, 0x5b, 0x4d, 0xc2, 0x08, 0x4d};

#define KSWMI_DEVICENAME TEXT("\\Device\\KsWmi")
#define KSWMI_LINKNAME TEXT("\\DosDevices\\KsWmi")

NTSTATUS
KsWmiWriteEvent( PWNODE_HEADER pWnode )
{
	NTSTATUS Status;
	KIRQL Irql;

	if ( 0 == KsWmiEnable && 0 == KsWmiLogEnable ) {
		return STATUS_INVALID_HANDLE;
	}

	//
	// only irql <= DPC
	//
	if ( KeGetCurrentIrql() > DISPATCH_LEVEL ) {
		return STATUS_UNSUCCESSFUL;
	}

	if ( KsWmiEnable ) {
		//
		// write it directly.
		//
		return IoWMIWriteEvent( pWnode );
	}

	ASSERT( KsWmiLogEnable );
	ASSERT( KsWmiLogBufferSize );
	KeAcquireSpinLock( &KsWmiSpinLock, &Irql );
		
	//
	// log to the buffer
	//
	if ( pWnode->BufferSize + KsWmiLogOffset > KsWmiLogBufferSize ) {
		//
		// overrun
		//
		KsWmiLogLost++;
		return STATUS_UNSUCCESSFUL;
	}
	
	RtlCopyMemory( KsWmiLogBuffer+KsWmiLogOffset,
				   pWnode, 
				   pWnode->BufferSize );
				   
	KsWmiLogOffset += pWnode->BufferSize;
	
	KeReleaseSpinLock( &KsWmiSpinLock, Irql );
	return STATUS_SUCCESS;
}

NTSTATUS
KsWmiDispatchCreate( 
	IN PDEVICE_OBJECT pDeviceObject,
	IN PIRP pIrp)
{
	PAGED_CODE();

    ASSERT(pDeviceObject);
    ASSERT(pIrp);

    PIO_STACK_LOCATION pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    pIrpSp->FileObject->FsContext = NULL;

    pIrp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(pIrp,IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}


NTSTATUS
KsWmiDispatchClose(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp)
{
    pIrp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(pIrp,IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}

#define PROC_REG_PATH   L"Software\\Debug\\ks.sys"

NTSTATUS
KsWmiRegisterGuids(
    IN  PWMIREGINFO             WmiRegInfo,
    IN  ULONG                   wmiRegInfoSize,
    IN  PULONG                  pReturnSize
    )
{
    //
    // Register a Control Guid as a Trace Guid. 
    //

    ULONG SizeNeeded;
    PWMIREGGUIDW WmiRegGuidPtr;
    ULONG Status;
    ULONG GuidCount;
    ULONG RegistryPathSize;
    PUCHAR ptmp;

    *pReturnSize = 0;
    GuidCount = 1;

    //
    // Allocate WMIREGINFO for controlGuid + GuidCount.
    //
    RegistryPathSize = sizeof(PROC_REG_PATH) - sizeof(WCHAR) + sizeof(USHORT);
    SizeNeeded = sizeof(WMIREGINFOW) + GuidCount * sizeof(WMIREGGUIDW) +
                 RegistryPathSize;


    if (SizeNeeded  > wmiRegInfoSize) {
        *((PULONG)WmiRegInfo) = SizeNeeded;
        *pReturnSize = sizeof(ULONG);
        return STATUS_SUCCESS;
    }


    RtlZeroMemory(WmiRegInfo, SizeNeeded);
    WmiRegInfo->BufferSize = SizeNeeded;
    WmiRegInfo->GuidCount = GuidCount;
    WmiRegInfo->NextWmiRegInfo = 
    WmiRegInfo->RegistryPath = 
    WmiRegInfo->MofResourceName = 0;

    WmiRegGuidPtr = &WmiRegInfo->WmiRegGuid[0];
    WmiRegGuidPtr->Guid = controlGUID;
    WmiRegGuidPtr->Flags |= WMIREG_FLAG_TRACED_GUID;
    WmiRegGuidPtr->Flags |= WMIREG_FLAG_TRACE_CONTROL_GUID;
    WmiRegGuidPtr->InstanceCount = 0;
    WmiRegGuidPtr->InstanceInfo = 0;

    ptmp = (PUCHAR)&WmiRegInfo->WmiRegGuid[1];
    WmiRegInfo->RegistryPath = (ULONG)ptmp - (ULONG)WmiRegInfo;
    *((PUSHORT)ptmp) = sizeof(PROC_REG_PATH) - sizeof(WCHAR);

    ptmp += sizeof(USHORT);
    RtlCopyMemory(ptmp, PROC_REG_PATH, sizeof(PROC_REG_PATH) - sizeof(WCHAR));

    *pReturnSize =  SizeNeeded;
    return(STATUS_SUCCESS);
}

NTSTATUS
KsWmiDispatchSystem(
	IN PDEVICE_OBJECT pDeviceObject,
	IN PIRP pIrp)
/*
    struct {
        ULONG_PTR ProviderId;
        PVOID DataPath;
        ULONG BufferSize;
        PVOID Buffer;
    } WMI;
    
	typedef struct {
    	ULONG BufferSize;
    	ULONG NextWmiRegInfo;
    	ULONG RegistryPath; 
    	ULONG MofResourceName;
    	ULONG GuidCount;
    	WMIREGGUIDW WmiRegGuid[];  
	} WMIREGINFO, *PWMIREGINFO;

{
    GUID Guid;             // Guid of data block being registered or updated
    ULONG Flags;         // Flags

    ULONG InstanceCount; // Count of static instances names for the guid

    union
    {
                     // If WMIREG_FLAG_INSTANCE_LIST then this has the offset
                     // to a list of InstanceCount counted UNICODE
                     // strings placed end to end.
        ULONG InstanceNameList;
			
                     // If WMIREG_FLAG_INSTANCE_BASENAME then this has the
                     // offset to a single counted UNICODE string that
                     // has the basename for the instance names.
			
        ULONG BaseNameOffset;
			
                     // If WMIREG_FLAG_INSTANCE_PDO is set then InstanceInfo
                     // has the PDO whose device instance path will
                     // become the instance name
        ULONG_PTR Pdo;
			
                     // If WMIREG_FLAG_INSTANCE_REFERENCE then this points to
                     // a WMIREGINSTANCEREF structure.
			
        ULONG_PTR InstanceInfo;// Offset from beginning of the WMIREGINFO structure to
    };

} WMIREGGUIDW, *PWMIREGGUIDW;
*/
{        
    PIO_STACK_LOCATION pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    ULONG BufferSize = pIrpSp->Parameters.WMI.BufferSize;
    PVOID Buffer = pIrpSp->Parameters.WMI.Buffer;
    ULONG ReturnSize = 0;
    NTSTATUS Status;
    PWNODE_HEADER Wnode=NULL;
    HANDLE ThreadHandle;

    switch (pIrpSp->MinorFunction) {

    case IRP_MN_REGINFO:    
        DbgPrint("IRP_MN_REG_INFO\n");
        Status = KsWmiRegisterGuids((PWMIREGINFO)Buffer,
        	           		        BufferSize,
                              		&ReturnSize);
                                   	ULONG SizeNeeded;

        break;

    case IRP_MN_ENABLE_EVENTS:

        //InterlockedExchange(&KsWmiEnable, 1);

        Wnode = (PWNODE_HEADER)Buffer;
        if (BufferSize >= sizeof(WNODE_HEADER)) {
            LoggerHandle = Wnode->HistoricalContext;

            DbgPrint("LoggerContext %I64u\n", Wnode->HistoricalContext);
            DbgPrint("BufferSize %d\n", Wnode->BufferSize);
            DbgPrint("Flags %x\n", Wnode->Flags);
            DbgPrint("Version %x\n", Wnode->Version);
        }


        DbgPrint("IRP_MN_ENABLE_EVENTS\n");
        break;

    case IRP_MN_DISABLE_EVENTS:
        InterlockedExchange(&KsWmiEnable, 0);
        DbgPrint(" IRP_MN_DISABLE_EVENTS\n");
        break;

    case IRP_MN_ENABLE_COLLECTION:

        DbgPrint("IRP_MN_ENABLE_COLLECTION\n");
        break;

    case IRP_MN_DISABLE_COLLECTION:
        DbgPrint("IRP_MN_DISABLE_COLLECTION\n");
        break;
    default:
        DbgPrint("DEFAULT\n");
        break;
    }

    pIrp->IoStatus.Status = STATUS_SUCCESS;
    pIrp->IoStatus.Information = ReturnSize;
    IoCompleteRequest( pIrp, IO_NO_INCREMENT );
    return STATUS_SUCCESS;
}


NTSTATUS
KsWmiDriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    ASSERT(DriverObject);

    DriverObject->DriverUnload = KsNullDriverUnload;

    DriverObject->MajorFunction[IRP_MJ_CREATE] = KsWmiDispatchCreate;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = KsWmiDispatchClose;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = KsWmiDispatchSystem;
    //DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = 
    	//KsWmiDispatchDeviceControl;

    UNICODE_STRING deviceName;
    RtlInitUnicodeString(&deviceName,KSWMI_DEVICENAME);
    PDEVICE_OBJECT deviceObject;
    NTSTATUS Status =
        IoCreateDevice(
            DriverObject,
            0,
            &deviceName,
            FILE_DEVICE_KS,
            FILE_DEVICE_SECURE_OPEN,
            FALSE,
            &deviceObject);

    if (! NT_SUCCESS(Status)) {
        KdPrint(("Failed to create KS Wmi device (%p)\n",Status));
        return Status;
    }

    UNICODE_STRING linkName;
    RtlInitUnicodeString(&linkName,KSWMI_LINKNAME);
    Status = IoCreateSymbolicLink(&linkName,&deviceName);

    if (NT_SUCCESS(Status)) {
        deviceObject->Flags |= DO_BUFFERED_IO;
        deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
    } 

    else {
        KdPrint(("Failed to create KS WMI symbolic link (%p)\n",Status));
        return Status;
    }

    Status = IoWMIRegistrationControl( deviceObject,
    			WMIREG_ACTION_REGISTER 
    			/*WMIREG_FLAG_TRACED_GUID |*/
    			/*WMIREG_ACTION_UPDATE_GUIDS |*/
    			/*WMIREG_FLAG_TRACE_PROVIDER*/);    

	if ( !NT_SUCCESS( Status ) ) {
		KdPrint(("Failed to Register WMI control (%p)\n",Status));		
	}

	WNODE_HEADER WnodEventItem;
	NTSTATUS StatusWmiWrite;

	RtlZeroMemory( (PVOID)&WnodEventItem, sizeof(WnodEventItem ));
	// TRACE_HEADER_ULONG32_TIME = 0xb0000000
	WnodEventItem.BufferSize = (sizeof(WnodEventItem) | TRACE_HEADER_ULONG32_TIME);
	WnodEventItem.HistoricalContext = WMI_GLOBAL_LOGGER_ID;
	WnodEventItem.Guid = traceGUID;

	//_asm int 3;
	StatusWmiWrite = KSWMIWriteEvent( (PWNODE_HEADER) &WnodEventItem );
	KdPrint(("KS: IoWMIWriteEvent Status (%p)\n",StatusWmiWrite));
	
    return Status;
}

extern "C"
NTKERNELAPI
NTSTATUS
IoCreateDriver (
    IN PUNICODE_STRING DriverName OPTIONAL,
    IN PDRIVER_INITIALIZE InitializationFunction
    );
    
#define MAX_REGKEYS         			4
#define TRACE_VERSION_MAJOR             1
#define TRACE_VERSION_MINOR             0
#define DEFAULT_GLOBAL_DIRECTORY        L"\\System32\\LogFiles\\WMI"
#define DEFAULT_GLOBAL_LOGFILE          L"kswmi.log"

NTSTATUS
KsWmiQueryRegistryRoutine(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )
/*++

Routine Description:

    Registry query values callback routine for reading SDs for guids

Arguments:

    ValueName - the name of the value

    ValueType - the type of the value

    ValueData - the data in the value (unicode string data)

    ValueLength - the number of bytes in the value data

    Context - Not used

    EntryContext - Pointer to PSECURITTY_DESCRIPTOR to store a pointer to
        store the security descriptor read from the registry value

Return Value:

    NT Status code

--*/
{
    NTSTATUS status = STATUS_SUCCESS;

    if ( (ValueData != NULL) && (ValueLength > 0) && (EntryContext != NULL) ){
        if (ValueType == REG_DWORD) {
            if ((ValueLength >= sizeof(ULONG)) && (ValueData != NULL)) {
                *((PULONG)EntryContext) = *((PULONG)ValueData);
            }
        }
        else if (ValueType == REG_SZ) {
            if (ValueLength > sizeof(UNICODE_NULL)) {
                RtlInitUnicodeString(
                            (PUNICODE_STRING) EntryContext,
                            (PCWSTR) ValueData);
            }
        }
    }
    return status;
}

NTSTATUS
KsWmiInit( void )
{
	NTSTATUS Status, RegStatus;
	UNICODE_STRING uiDriverName;

    RtlInitUnicodeString(&uiDriverName, L"\\Driver\\KsWmi");

    Status = IoCreateDriver(&uiDriverName, KsWmiDriverEntry);
    if (! NT_SUCCESS(Status)) {
        KdPrint(("Failed to create KS Wmi driver (%p)\n",Status));
    }
    
    WMI_LOGGER_INFORMATION LoggerInfo;
    RTL_QUERY_REGISTRY_TABLE QueryRegistryTable[MAX_REGKEYS];
    ULONG StartRequested = 0;
    ULONG BufferSize=4096*4;

    RtlZeroMemory(QueryRegistryTable,
                  sizeof(RTL_QUERY_REGISTRY_TABLE) * MAX_REGKEYS);

    QueryRegistryTable[0].QueryRoutine = KsWmiQueryRegistryRoutine;
    QueryRegistryTable[0].EntryContext = (PVOID) &StartRequested;
    QueryRegistryTable[0].Name = L"Start";
    QueryRegistryTable[0].DefaultType = REG_DWORD;

    QueryRegistryTable[1].QueryRoutine = KsWmiQueryRegistryRoutine;
    QueryRegistryTable[1].EntryContext = (PVOID) &BufferSize;
    QueryRegistryTable[1].Name = L"BufferSize";
    QueryRegistryTable[1].DefaultType = REG_DWORD;

    RegStatus = RtlQueryRegistryValues(
                RTL_REGISTRY_ABSOLUTE,
                L"\\Registry\\Machine\\Software\\DEBUG\\KSWMI",
                QueryRegistryTable,
                NULL,
                NULL);
                
    if (NT_SUCCESS(RegStatus) && StartRequested) {
    	if ( BufferSize <= 4096 ) BufferSize = 4096;
		KsWmiLogBuffer = (PBYTE)ExAllocatePoolWithTag( NonPagedPool, BufferSize, 'wmSK' );
		if ( NULL != KsWmiLogBuffer ) {
			KeInitializeSpinLock( &KsWmiSpinLock );
			KsWmiLogBufferSize = BufferSize;
			KsWmiEnable = 1;
			KdPrint(("KsWmi Enabled, LogBufferSize=%d\n", KsWmiLogBufferSize));
		}
		//else { // should be 0 by default as global static var
		//	KsWmiLogBufferSize = 0;
		//}
    }    
    return Status;
}
	
#endif
//-----------


#ifdef WIN98GOLD_KS
#pragma optimize("", off)
#endif

extern "C"
NTSTATUS
DllInitialize(
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    Initializes the COM module.

Arguments:

    RegistryPath -
        Not used.

Return Values:

    Returns STATUS_SUCCESS.

--*/
{
	#ifdef WIN98GOLD_KS
	//
	// To distribute ks.sys on down level OS such as win98 gold,
	// we need to work around an NTKern loader nasty bug that 
	// overwrites a loading result by the return value of a dllinitialize
	// return value. It will fail loading drivers. For example,
	// usbintel need usbcamd which need stream.sys which need ks.sys.
	// But at the return of ks.sys dllinitialize, nt loader overwrites
	// the loading result of stream.sys with the ks dllinitialize so
	// that loading stream.sys is not retried. Hence, stream.sys
	// was not loaded and the rests, usbintel and usbcamd, fail to load.
	//
	// We try to patch ntkern loader code so that it does not overwrite
	// the loading result with the return value of dllinitialize.
	// cases {retail,debug}x{ks.sys,ntkern.vxd}x{win98gold,win98se,Millen}
	// Only win98gold Ntkern has the bug.
	//

	PULONG ReturnAddress;

	//
	// this can only be done by assmbly code.
	// Since we turn off optimization, ebp is always used to preserve
	// call frame. The return address will be at ebp+4
	//
	_asm {
			//int 	3;	// check the stack config here
			mov     eax, DWORD PTR [ebp + 4]
			mov     DWORD PTR [ReturnAddress], eax
	}

	//
	// begin the ugly patch, 1st check retail win98gold ntkern
	// 
	// 	ra-4 6a00 push 0
	//  ra-2 ffd0 call eax
	//  ra   8bd8 mov  ebx, eax --> 9090 nop, nop  Not to overwrite the result
	//  ra+2 85db test ebx, ebx --> 85c0 test eax,eax Test the return value
	//  ra+4 7c46 jl   $+46
	//  ra+6 83fbf4 cmp ebx, -c
	//
	//  debug win98gold ntkern
	//
	//  ra-4 6a00 push 0
	//  ra-2 ffd0 call eax
	//  ra   85c0 test eax, eax
	//  ra+2 8945f8 mov [ebp-8], eax --> 909090 nop,nop,nop
	//	ra+5 7c0b jl   $+b			 --> not to overwrite [ebp-8] result
	//  ra+7 837df8f4
	//

	if ( ReturnAddress[-1] == 0xd0ff006a ) {

		//
		// sanity check, the caller should be NTKern loader
		// same for free and debug Ntkern
		//
	
		if ( ReturnAddress[0] == 0xdb85d88b &&
		     ReturnAddress[1] == 0xfb83467c ) {

			//
			// We have the free build win98gold NTKern
			//

			*ReturnAddress = 0xc0859090;
		}

		else if ( ReturnAddress[0] == 0x4589c085 &&
		          ReturnAddress[1] == 0x830b7cf8 ) {

			//
			// We have the win98gold debug ntkern
			//
			
			ReturnAddress = (PULONG) ((PBYTE)ReturnAddress+1);
			*ReturnAddress = 0x909090c0;
		}
	}
	#endif // WIN98GOLD_KS
	
	KSWMI( KsWmiInit() );

    KeInitializeMutex(&ListLock, 0);
    InitializeListHead(&FactoryList);
    KsLogInit();
    KsLog(NULL,KSLOGCODE_KSSTART,NULL,NULL);

	KSPERFLOGS(
		PerfGroupMask_t PerfGroupMask;
		int i;
    	KdPrint(("PerfGlobalGroupMask=\n"));
    	PerfGroupMask = PerfQueryGlobalGroupMask();
    	for ( i=0; i < PERF_NUM_MASKS ;i++ ) {
    		DbgPrint("\t%x\n", PerfGroupMask.masks[i]);
    	}
		
	    KdPrint(("PerfIsAnyGroupOn=%x\n", PerfIsAnyGroupOn()));
	)

    return STATUS_SUCCESS;
}

#ifdef WIN98GOLD_KS
#pragma optimize("", on)
#endif


#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA


extern "C"
VOID
RemoveFactoryEntries(
    )
/*++

Routine Description:

    Remove any unreference class factories.

Arguments:

    None.

Return Values:

    Nothing.

--*/
{
    //
    // Lock the factory list before modifying it.
    //
    KeWaitForMutexObject(&ListLock, Executive, KernelMode, FALSE, NULL);
    for (PLIST_ENTRY FactoryListEntry = FactoryList.Flink; FactoryListEntry != &FactoryList;) {
        PFACTORY_ENTRY FactoryEntry = CONTAINING_RECORD(
            FactoryListEntry,
            FACTORY_ENTRY,
            FactoryListEntry);
        //
        // Increment the current pointer first, in case the
        // entry is removed.
        //
        FactoryListEntry = FactoryListEntry->Flink;
        //
        // If a module is currently being loaded, it's count will
        // be non-zero.
        //
        if (!FactoryEntry->ObjectCount) {
            //
            // The module may have failed to load in the first place, so
            // only unload it if it actually was loaded.
            //
            if (NT_SUCCESS(FactoryEntry->LoadStatus)) {
                //
                // This will allow the file to be closed, and possibly
                // the module to be unloaded.
                //
                ObDereferenceObject(FactoryEntry->FileObject);
            }
            RemoveEntryList(&FactoryEntry->FactoryListEntry);
            ExFreePool(FactoryEntry);
        }
    }
    KeReleaseMutex(&ListLock, FALSE);
}


extern "C"
NTSTATUS
LoadService(
    IN REFCLSID ClassId,
    OUT PFILE_OBJECT* FileObject
    )
/*++

Routine Description:

    Load the specified service and return a file object on the service. A service
    is just a PnP interface Guid, presumably unique.

Arguments:

    ClassId -
        The class of service to load, which is actually the PnP interface Guid.
        The first symbolic link providing this interface is loaded.

    FileObject -
        The place in which to put the file object opened on the service.

Return Value:

    Returns STATUS_SUCCESS if the service was opened, else an open or PnP error.

--*/
{
    PWSTR SymbolicLinkList;

    //
    // Retrieve the set of items. This may contain multiple items, but
    // only the first (default) item is used.
    //
    NTSTATUS Status = IoGetDeviceInterfaces(&ClassId, NULL, 0, &SymbolicLinkList);
    if (NT_SUCCESS(Status)) {
        UNICODE_STRING SymbolicLink;
        OBJECT_ATTRIBUTES ObjectAttributes;
        IO_STATUS_BLOCK IoStatusBlock;
        HANDLE ServiceHandle;

        RtlInitUnicodeString(&SymbolicLink, SymbolicLinkList);
        InitializeObjectAttributes(
            &ObjectAttributes,
            &SymbolicLink,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL);
        //
        // Note that incompatible CreateOptions are passed
        // (FILE_COMPLETE_IF_OPLOCKED | FILE_RESERVE_OPFILTER) in order to
        // ensure access is only be available through KoCreateInstance. In
        // addition, this must be a kernel-mode client caller. This allows
        // the KoDispatchCreate handler to reject any user-mode caller
        // which tries to load the module directly, and to verify that any
        // kernel-mode caller is also calling through KoCreateInstance.
        //
        Status = IoCreateFile(
            &ServiceHandle,
            0,
            &ObjectAttributes,
            &IoStatusBlock,
            NULL,
            0,
            0,
            FILE_OPEN,
            //
            // These are incompatible flags, which are verified on
            // the receiving end in IrpStack->Parameters.Create.Options.
            //
            FILE_COMPLETE_IF_OPLOCKED | FILE_RESERVE_OPFILTER,
            NULL,
            0,
            CreateFileTypeNone,
            NULL,
            IO_FORCE_ACCESS_CHECK | IO_NO_PARAMETER_CHECKING);
        ExFreePool(SymbolicLinkList);
        if (NT_SUCCESS(Status)) {
            Status = ObReferenceObjectByHandle(
                ServiceHandle,
                FILE_GENERIC_READ,
                *IoFileObjectType,
                KernelMode,
                reinterpret_cast<PVOID*>(FileObject),
                NULL);
            //
            // The handle is not needed once the object has been referenced.
            //
            ZwClose(ServiceHandle);
        }        
    }
    return Status;
}


extern "C"
VOID
DecrementObjectCount(
    IN REFCLSID ClassId
    )
/*++

Routine Description:

    Decrements the usage count on a service previously loaded. This is used by a
    service when an object created by KoCreateInstance is deleted. There is no
    corresponding increment function, since the reference count is automatically
    incremented on creation of a new object.

Arguments:

    ClassId -
        The class of the object whose usage count is to be decremented.

Return Value:

    Returns STATUS_SUCCESS if the class was found, else STATUS_NOT_FOUND.

--*/
{
    //
    // Make sure nothing is modifying the factory list,
    // then look for the entry.
    //
    KeWaitForMutexObject(&ListLock, Executive, KernelMode, FALSE, NULL);
    for (PLIST_ENTRY FactoryListEntry = FactoryList.Flink; FactoryListEntry != &FactoryList; FactoryListEntry = FactoryListEntry->Flink) {
        PFACTORY_ENTRY FactoryEntry;

        FactoryEntry = CONTAINING_RECORD(FactoryListEntry, FACTORY_ENTRY, FactoryListEntry);
        if (FactoryEntry->ClassId == ClassId) {
            //
            // Once the entry is found, presumably the reference count
            // is non-zero, and therefore it will not go away until
            // dereferenced. Therefore the list lock can be released.
            //
            ASSERT(FactoryEntry->ObjectCount > 0);
            KeReleaseMutex(&ListLock, FALSE);
            if (!InterlockedDecrement(&FactoryEntry->ObjectCount)) {
                RemoveFactoryEntries();
            }
            return;
        }
    }
    //
    // The entry was not found.
    //
    ASSERT(FactoryListEntry != &FactoryList);
    KeReleaseMutex(&ListLock, FALSE);
}


extern "C"
NTSTATUS
CreateObject(
    IN PFACTORY_ENTRY FactoryEntry,
    IN IUnknown* UnkOuter OPTIONAL,
    IN REFIID InterfaceId,
    OUT PVOID* Interface
    )
/*++

Routine Description:

    Returns an interface on an instance of the specified class.

Arguments:

    FactoryEntry -
        The class factory which to use to create the object.

    UnkOuter -
        The outer unknown to pass to the new instance.

    InterfaceId -
        The interface to return on the instance.

    Interface -
        The place in which to return the interface pointer on the new instance.

Return Value:

    Returns STATUS_SUCCESS if the instance was created, else and error.

--*/
{
    NTSTATUS Status = FactoryEntry->CreateObject(FactoryEntry->ClassId, UnkOuter, InterfaceId, Interface);
    if (NT_SUCCESS(Status)) {
        IKoInitializeParentDeviceObject* InitializeParent;

        if (NT_SUCCESS(reinterpret_cast<IUnknown*>(*Interface)->QueryInterface(
            __uuidof(IKoInitializeParentDeviceObject),
            reinterpret_cast<PVOID*>(&InitializeParent)))) {
            //
            // This object wishes to have the parent device object
            // set on it.
            //
            Status = InitializeParent->SetParentDeviceObject(FactoryEntry->FileObject->DeviceObject);
            InitializeParent->Release();
            if (!NT_SUCCESS(Status)) {
                //
                // There is no need to decrement the object count
                // in this failure path, since the object had been
                // created successfully. The Release method will do
                // the decrement.
                //
                reinterpret_cast<IUnknown*>(*Interface)->Release();
            }
        }
    } else if (!InterlockedDecrement(&FactoryEntry->ObjectCount)) {
        //
        // Creation failed, so remove the count previously added
        // to the entry. Do not touch the entry after this point.
        // If the entry count had reached zero, do a search of the
        // class list to remove any old entries.
        //
        RemoveFactoryEntries();
    }
    return Status;
}


extern "C"
COMDDKAPI
NTSTATUS
NTAPI
KoCreateInstance(
    IN REFCLSID ClassId,
    IN IUnknown* UnkOuter OPTIONAL,
    IN ULONG ClsContext,
    IN REFIID InterfaceId,
    OUT PVOID* Interface
    )
/*++

Routine Description:

    Returns an interface on an instance of the specified class.

Arguments:

    ClassId -
        The class of the object whose usage count is to be decremented.

    UnkOuter -
        The outer unknown to pass to the new instance.

    ClsContext -
        The context in which to create the instance. This must be CLSCTX_KERNEL_SERVER.

    InterfaceId -
        The interface to return on the instance.

    Interface -
        The place in which to return the interface pointer on the new instance.

Return Value:

    Returns STATUS_SUCCESS if the instance was created, else and error.

--*/
{
    PAGED_CODE();
    //
    // Kernel servers are the only type of COM object supported.
    //
    if (ClsContext != CLSCTX_KERNEL_SERVER) {
        return STATUS_INVALID_PARAMETER_3;
    }
    //
    // The COM rules specify that a client must retrieve the IUnknown
    // interface of an object if aggregation is occuring. This is
    // because creation time is the only chance for the client to
    // retrieve the true inner IUnknown of the object.
    //
    if (UnkOuter && (InterfaceId != __uuidof(IUnknown))) {
        return STATUS_INVALID_PARAMETER_4;
    }

    NTSTATUS Status;
    PFACTORY_ENTRY FactoryEntry;

    //
    // Lock out changes to the class list, then search the list for the
    // desired class.
    //
    KeWaitForMutexObject(&ListLock, Executive, KernelMode, FALSE, NULL);
    for (PLIST_ENTRY FactoryListEntry = FactoryList.Flink; FactoryListEntry != &FactoryList; FactoryListEntry = FactoryListEntry->Flink) {
        FactoryEntry = CONTAINING_RECORD(
            FactoryListEntry,
            FACTORY_ENTRY,
            FactoryListEntry);
        //
        // If the desired class is found, then increment the reference count,
        // since a new object is about to be created on it. This stops the
        // entry from being unloaded by RemoveFactoryEntries, while also
        // allowing the list lock to be released immediately.
        //
        if (FactoryEntry->ClassId == ClassId) {
            InterlockedIncrement(&FactoryEntry->ObjectCount);
            KeReleaseMutex(&ListLock, FALSE);
            //
            // Check to see if this entry has even been initialized yet. If
            // the load status is not pending, then it has been initialized,
            // and the mutex will have been, or soon be, set. Initializing
            // this entry mutex is done while holding the list lock, so that
            // it must be initialized when a second client is searching the
            // list.
            //
            if (FactoryEntry->LoadStatus == STATUS_PENDING) {
                //
                // If the mutex was not set, then either the entry was not
                // initialized yet, or a previous client had to wait for the
                // entry to be initialized, and has not released the entry
                // mutex yet. This waiter will also release the mutex once
                // it is acquired.
                //
                KeWaitForMutexObject(
                    &FactoryEntry->InitializeLock,
                    Executive,
                    KernelMode,
                    FALSE,
                    NULL);
                KeReleaseMutex(&FactoryEntry->InitializeLock, FALSE);
                //
                // When the entry is finally loaded, the status returned
                // from loading is stored in the entry for retrieval by
                // all callers, since the entry can't be freed until all
                // callers have been synchronized with the entry initialization.
                //
            }
            Status = FactoryEntry->LoadStatus;
            //
            // So if loading the entry did not fail, then create an
            // instance.
            //
            if (NT_SUCCESS(Status)) {
                Status = CreateObject(FactoryEntry, UnkOuter, InterfaceId, Interface);
            } else if (!InterlockedDecrement(&FactoryEntry->ObjectCount)) {
                //
                // Something failed, so remove the count previously added
                // to the entry. Do not touch the entry after this point.
                // If the entry count had reached zero, do a search of the
                // class list to remove any old entries. The CreateObject call
                // will do the same if necessary.
                //
                RemoveFactoryEntries();
            }
            return Status;
        }
    }
    //
    // The class was not found in the list, so create a new one.
    //
    FactoryEntry = reinterpret_cast<PFACTORY_ENTRY>(ExAllocatePoolWithTag(PagedPool, sizeof(*FactoryEntry), 'efSK'));
    if (!FactoryEntry) {
        KeReleaseMutex(&ListLock, FALSE);
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    FactoryEntry->ClassId = ClassId;
    InsertHeadList(&FactoryList, &FactoryEntry->FactoryListEntry);
    //
    // Initialize this to non-zero so that an unload does not get started
    // on this entry.
    //
    FactoryEntry->ObjectCount = 1;
    FactoryEntry->CreateObject = NULL;
    FactoryEntry->FileObject = NULL;
    KeInitializeMutex(&FactoryEntry->InitializeLock, 0);
    //
    // This value indicates that the entry has not been initialized yet.
    //
    FactoryEntry->LoadStatus = STATUS_PENDING;
    //
    // Acquire the mutex so that any new clients can wait until this entry is
    // initialized. Then the list lock can be released.
    //
    KeWaitForMutexObject(&FactoryEntry->InitializeLock, Executive, KernelMode, FALSE, NULL);
    //
    // The new factory entry is in the list, so the global lock can be
    // release. If the subsequent load fails, then any current queries
    // will also fail after waiting by checking the LoadStatus.
    //
    KeReleaseMutex(&ListLock, FALSE);
    //
    // Try to load the class as a PnP interface.
    //
    Status = LoadService(ClassId, &FactoryEntry->FileObject);
    if (NT_SUCCESS(Status)) {
        FactoryEntry->CreateObject = reinterpret_cast<PSERVER_INSTANCE>(FactoryEntry->FileObject->FsContext)->CreateObjectHandler;
    }
    //
    // When the entry has been loaded, or it fails, set the status return
    // from the load, and release the mutex.
    //
    FactoryEntry->LoadStatus = Status;
    KeReleaseMutex(&FactoryEntry->InitializeLock, FALSE);
    //
    // If the service was loaded, attempt to create an instance.
    //
    if (NT_SUCCESS(Status)) {
        Status = CreateObject(FactoryEntry, UnkOuter, InterfaceId, Interface);
    } else if (!InterlockedDecrement(&FactoryEntry->ObjectCount)) {
        //
        // Something failed, then remove the count that the entry was
        // initialized with. Do not touch the entry after this point.
        // If the entry count had reached zero, do a search of the
        // class list to remove any old entries. The CreateObject call
        // will do the same if necessary.
        //
        RemoveFactoryEntries();
    }
    return Status;
}


extern "C"
COMDDKAPI
NTSTATUS
NTAPI
KoDriverInitialize(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPathName,
    IN KoCreateObjectHandler CreateObjectHandler
    )
/*++

Routine Description:

    Sets up the driver object to handle the KS interface and PnP Add Device
    request. Does not set up a handler for PnP Irp's, as they are all dealt
    with directly by the PDO. This should be called by the DriverEntry of a
    kernel COM server to set up the default driver and entry points for the
    server. This means all the handling will be performed by the default code,
    and the service need only provide an object handler entry point. A more
    complex driver can override these defaults after calling this function.
    If the defaults are not overridden, this only allows for a single object
    creation entry point to be registered for a particular driver. When
    overriding, the DriverObject->DriverExtension->AddDevice function may be
    saved by allocating driver object extension storage, and then called by
    the driver in its own AddDevice function when appropriate. Otherwise, if
    the driver is creating its own device objects, it can use the
    KoDeviceInitialize function to add a new CreateItem to the object, which
    can then be used to support multiple sub-devices.

Arguments:

    DriverObject -
        Driver object for this instance.

    RegistryPathName -
        Contains the registry path which was used to load this instance.

    CreateObjectHandler -
        Contains the entry point used to create new objects.

Return Values:

    Returns STATUS_SUCCESS or a memory allocation failure.

--*/
{
    KoCreateObjectHandler* CreateObjectHandlerStorage;

    PAGED_CODE();
    ASSERT(CreateObjectHandler);
    //
    // Store the entry point for use in KoCreateInstance.
    //
    NTSTATUS Status = IoAllocateDriverObjectExtension(
        DriverObject,
        reinterpret_cast<PVOID>(KoDriverInitialize),
        sizeof(*CreateObjectHandlerStorage),
        reinterpret_cast<PVOID*>(&CreateObjectHandlerStorage));
    if (NT_SUCCESS(Status)) {
        *CreateObjectHandlerStorage = CreateObjectHandler;
        DriverObject->MajorFunction[IRP_MJ_PNP] = KsDefaultDispatchPnp;
        DriverObject->MajorFunction[IRP_MJ_POWER] = KsDefaultDispatchPower;
        DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = KsDefaultForwardIrp;
        DriverObject->DriverExtension->AddDevice = PnpAddDevice;
        DriverObject->DriverUnload = KsNullDriverUnload;
        KsSetMajorFunctionHandler(DriverObject, IRP_MJ_CREATE);
        KsSetMajorFunctionHandler(DriverObject, IRP_MJ_CLOSE);
        KsSetMajorFunctionHandler(DriverObject, IRP_MJ_DEVICE_CONTROL);
    }
    return Status;
}


extern "C"
COMDDKAPI
NTSTATUS
NTAPI
KoDeviceInitialize(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Adds a KCOM CreateItem entry to the object provided (with the
    expectation that a free slot is available). This should be called
    by the PnpAddDevice handler when the FDO is being created. For
    simple drivers which do not share device objects, or create multiple
    devices object, KoDriverInitialize can be used without overriding the
    AddDevice function.

Arguments:

    DeviceObject -
        Device object for this instance. This is assumed to contain a
        KSOBJECT_HEADER in the device extension.

Return Values:

    Returns STATUS_SUCCESS, or a memory allocation error.

--*/
{
    PAGED_CODE();
    //
    // The expectation is that a free slot is available for this
    // new create item.
    //
    return KsAddObjectCreateItemToDeviceHeader(
        *reinterpret_cast<KSDEVICE_HEADER*>(DeviceObject->DeviceExtension),
        DeviceCreateItems[0].Create,
        DeviceCreateItems[0].Context,
        DeviceCreateItems[0].ObjectClass.Buffer,
        DeviceCreateItems[0].SecurityDescriptor);
}


extern "C"
NTSTATUS
PnpAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )
/*++

Routine Description:

    When a new device is detected, PnP calls this entry point with the
    new PhysicalDeviceObject (PDO). The driver creates an associated 
    FunctionalDeviceObject (FDO). This dispatch function is assigned
    when using KoDriverInitialize to default Irp handling.


Arguments:

    DriverObject -
        Pointer to the driver object.

    PhysicalDeviceObject -
        Pointer to the new physical device object.

Return Values:

    STATUS_SUCCESS or an appropriate error condition.

--*/
{
    PDEVICE_OBJECT FunctionalDeviceObject;

    NTSTATUS Status = IoCreateDevice(
        DriverObject,
        sizeof(KSDEVICE_HEADER),
        NULL,
        FILE_DEVICE_KS,
        0,
        FALSE,
        &FunctionalDeviceObject);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    //
    // This object uses KS to perform access through the DeviceCreateItems.
    //
    Status = KsAllocateDeviceHeader(
        reinterpret_cast<KSDEVICE_HEADER*>(FunctionalDeviceObject->DeviceExtension),
        SIZEOF_ARRAY(DeviceCreateItems),
        const_cast<PKSOBJECT_CREATE_ITEM>(DeviceCreateItems));
    if (NT_SUCCESS(Status)) {
        PDEVICE_OBJECT TopDeviceObject = IoAttachDeviceToDeviceStack(
            FunctionalDeviceObject,
            PhysicalDeviceObject);
        if (TopDeviceObject) {
            KsSetDevicePnpAndBaseObject(
                *reinterpret_cast<KSDEVICE_HEADER*>(FunctionalDeviceObject->DeviceExtension),
                TopDeviceObject,
                FunctionalDeviceObject);
            //
            // By default COM services are pagable.
            //
            FunctionalDeviceObject->Flags |= DO_POWER_PAGABLE;
            FunctionalDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
            return STATUS_SUCCESS;
        } else {
            Status = STATUS_DEVICE_REMOVED;
            ASSERT(FALSE && "IoAttachDeviceToDeviceStack() failed on the PDO!");
        }
    }
    IoDeleteDevice(FunctionalDeviceObject);
    return Status;
}


extern "C"
NTSTATUS
KoDispatchCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Dispatches the creation of a server instance. Allocates the object header and initializes
    the data for this server instance. This dispatch function is assigned when using
    KoDriverInitialize to default Irp handling.

Arguments:

    DeviceObject -
        Device object on which the creation is occuring.

    Irp -
        Creation Irp.

Return Values:

    Returns STATUS_SUCCESS on success, STATUS_INSUFFICIENT_RESOURCES or some related error
    on failure.

--*/
{
    NTSTATUS Status;

    PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);
    //
    // Ensure that this was called through KoCreateInstance, else reference
    // counting on objects will be messed up. Do this by ensuring that a
    // kernel client made the create call, and passed an invalid set of
    // option flags (FILE_COMPLETE_IF_OPLOCKED | FILE_RESERVE_OPFILTER).
    //
    if ((Irp->RequestorMode == KernelMode) &&
        ((IrpStack->Parameters.Create.Options & (FILE_COMPLETE_IF_OPLOCKED | FILE_RESERVE_OPFILTER)) == (FILE_COMPLETE_IF_OPLOCKED | FILE_RESERVE_OPFILTER))) {
        //
        // Notify the bus that this device is in use.
        //
        Status = KsReferenceBusObject(
            *reinterpret_cast<KSDEVICE_HEADER*>(DeviceObject->DeviceExtension));
        if (NT_SUCCESS(Status)) {
            PSERVER_INSTANCE ServerInstance;

            //
            // Create the instance information. This contains just the object header.
            //
            if (ServerInstance = reinterpret_cast<PSERVER_INSTANCE>(ExAllocatePoolWithTag(NonPagedPool, sizeof(SERVER_INSTANCE), 'IFsK'))) {
                //
                // This object uses KS to perform access through the DeviceCreateItems and
                // ServerDispatchTable.
                //
                Status = KsAllocateObjectHeader(
                    &ServerInstance->Header,
                    SIZEOF_ARRAY(DeviceCreateItems),
                    const_cast<PKSOBJECT_CREATE_ITEM>(DeviceCreateItems),
                    Irp,
                    &ServerDispatchTable);
                if (NT_SUCCESS(Status)) {
                    KoCreateObjectHandler* CreateObjectHandlerStorage;

                    //
                    // This was created in KoDriverInitialize or KoDeviceInitialize
                    // with the entry point passed.
                    //
                    CreateObjectHandlerStorage = reinterpret_cast<KoCreateObjectHandler*>(
                        IoGetDriverObjectExtension(
                            DeviceObject->DriverObject,
                            reinterpret_cast<PVOID>(KoDriverInitialize)));
                    ASSERT(CreateObjectHandlerStorage);
                    ServerInstance->CreateObjectHandler = *CreateObjectHandlerStorage;
                    //
                    // KS expects that the object data is in FsContext.
                    //
                    IoGetCurrentIrpStackLocation(Irp)->FileObject->FsContext = ServerInstance;
                } else {
                    ExFreePool(ServerInstance);
                    KsDereferenceBusObject(
                        *reinterpret_cast<KSDEVICE_HEADER*>(DeviceObject->DeviceExtension));
                }
            } else {
                KsDereferenceBusObject(
                    *reinterpret_cast<KSDEVICE_HEADER*>(DeviceObject->DeviceExtension));
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
    } else {
        Status = STATUS_ACCESS_DENIED;
    }
    Irp->IoStatus.Status = Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return Status;
}


extern "C"
NTSTATUS
KoDispatchClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Closes a previously opened server instance. This can only occur after all references
    have been released. This dispatch function is assigned when using KoDriverInitialize
    to default Irp handling.

Arguments:

    DeviceObject -
        Device object on which the close is occuring.

    Irp -
        Close Irp.

Return Values:

    Returns STATUS_SUCCESS.

--*/
{
    PSERVER_INSTANCE ServerInstance = reinterpret_cast<PSERVER_INSTANCE>
        (IoGetCurrentIrpStackLocation(Irp)->FileObject->FsContext);
    //
    // These were allocated during the creation of the server instance.
    //
    KsFreeObjectHeader(ServerInstance->Header);
    ExFreePool(ServerInstance);
    //
    // Notify the bus that the device has been closed.
    //
    KsDereferenceBusObject(*reinterpret_cast<KSDEVICE_HEADER*>(DeviceObject->DeviceExtension));

    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}


COMDDKMETHOD
CBaseUnknown::CBaseUnknown(
    IN REFCLSID ClassId,
    IN IUnknown* UnknownOuter OPTIONAL
    ) :
    m_RefCount(0)
/*++

Routine Description:

    Constructor for CBaseUnknown. Initializes the instance, saving the
    parameters to locals, and setting the reference count to zero.

Arguments:

    ClassId -
        Contains the class identifier for the object which inherits
        from this class. This is used when destroying this instance
        in order to decrement the reference count on the module.

    UnknownOuter -
        Optionally contains an outer IUnknown. If this is not set, the
        INonDelegatedUnknown is just used. This allows the object
        which inherits from this class to be aggregated.

Return Values:

    Nothing.

--*/
{
    PAGED_CODE();
    //
    // Either indirect calls to the outer IUnknown, or use the nondelegated
    // IUnknown on this object. The QueryInterface method can then be
    // overridden so that the parent object can add interfaces.
    //
    if (UnknownOuter) {
        m_UnknownOuter = UnknownOuter;
    } else {
        m_UnknownOuter = reinterpret_cast<IUnknown*>(dynamic_cast<INonDelegatedUnknown*>(this));
    }
    //
    // Use this when destroying the object to notify the KCOM services.
    //
    m_UsingClassId = TRUE;
    m_ClassId = ClassId;
}


COMDDKMETHOD
CBaseUnknown::CBaseUnknown(
    IN IUnknown* UnknownOuter OPTIONAL
    ) :
    m_RefCount(0)
/*++

Routine Description:

    Constructor for CBaseUnknown. Initializes the instance, saving the
    parameters to locals, and setting the reference count to zero.

Arguments:

    UnknownOuter -
        Optionally contains an outer IUnknown. If this is not set, the
        INonDelegatedUnknown is just used. This allows the object
        which inherits from this class to be aggregated.

Return Values:

    Nothing.

--*/
{
    PAGED_CODE();
    //
    // Either indirect calls to the outer IUnknown, or use the nondelegated
    // IUnknown on this object. The QueryInterface method can then be
    // overridden so that the parent object can add interfaces.
    //
    if (UnknownOuter) {
        m_UnknownOuter = UnknownOuter;
    } else {
        m_UnknownOuter = reinterpret_cast<IUnknown*>(dynamic_cast<INonDelegatedUnknown*>(this));
    }
    //
    // Use this when destroying the object no notification is performed.
    //
    m_UsingClassId = FALSE;
}


COMDDKMETHOD
CBaseUnknown::~CBaseUnknown(
    )
/*++

Routine Description:

    Destructor for CBaseUnknown. Currently does nothing.

Arguments:

    None.

Return Values:

    Nothing.

--*/
{
    PAGED_CODE();
}


COMDDKMETHOD
STDMETHODIMP_(ULONG)
CBaseUnknown::NonDelegatedAddRef(
    )
/*++

Routine Description:

    Implements INonDelegatedUnknown::NonDelegatedAddRef. Increments
    the reference count on this object.

Arguments:

    None.

Return Values:

    Returns the current reference count value.

--*/
{
    PAGED_CODE();
    return InterlockedIncrement(&m_RefCount);
}


COMDDKMETHOD
STDMETHODIMP_(ULONG)
CBaseUnknown::NonDelegatedRelease(
    )
/*++

Routine Description:

    Implements INonDelegatedUnknown::NonDelegatedRelease. Decrements
    the reference count on this object. If the reference count reaches
    zero, the object is deleted and if the ClassId was specified on the
    constructor, the reference count on the module which supports the
    class passed in on the constructor is decremented.

    This function must be called directly from the IUnknown::Release()
    method of the object.

Arguments:

    None.

Return Values:

    Returns the current reference count value.

--*/
{
    PAGED_CODE();
    LONG RefCount;

    //
    // This code is expecting to be called from IUnknown->Release, and will
    // eventually use the new primitives to rearrange the stack so that it
    // is actually run after the calling function has returned.
    //
    if (!(RefCount = InterlockedDecrement(&m_RefCount))) {
        ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);
        //
        // Protect against reentering the deletion code.
        //
        m_RefCount++;
        BOOLEAN UsingClassId = m_UsingClassId;
        CLSID ClassId = m_ClassId;
        //
        // Call any destructor on the parent object.
        //
        delete this;
        if (UsingClassId) {
            //
            // Release a reference count on the module which
            // supports the parent's class. On zero, the module is
            // marked for delayed removal.
            //
            DecrementObjectCount(ClassId);
        }
    }
    return RefCount;
}


COMDDKMETHOD
STDMETHODIMP_(NTSTATUS)
CBaseUnknown::NonDelegatedQueryInterface(
    IN REFIID InterfaceId,
    OUT PVOID* Interface
    )
/*++

Routine Description:

    Implements INonDelegatedUnknown::NonDelegatedQueryInterface. This
    is just the default implementation, and should be overridden by the
    parent object. This only supports IUnknown.

Arguments:

    InterfaceId -
        Contains the identifier of the interface to return.

    Interface -
        The place in which to put the pointer to the interface returned.

Return Values:

    Returns STATUS_SUCCESS if the interface was returned, else
    STATUS_NOINTERFACE.

--*/
{
    PAGED_CODE();
    if (InterfaceId == __uuidof(IUnknown)) {
        //
        // This is the inner IUnknown which is returned.
        //
        *Interface = reinterpret_cast<PVOID>(static_cast<IIndirectedUnknown*>(this));
        NonDelegatedAddRef();
        return STATUS_SUCCESS;
    }
    *Interface = NULL;
    return STATUS_NOINTERFACE;
}


COMDDKMETHOD
STDMETHODIMP_(ULONG)
CBaseUnknown::IndirectedAddRef(
    )
/*++

Routine Description:

    Implements IIndirectedUnknown::IndirectedAddRef. Increments
    the reference count on this object.

Arguments:

    None.

Return Values:

    Returns the current reference count value.

--*/
{
    PAGED_CODE();
    return NonDelegatedAddRef();
}


COMDDKMETHOD
STDMETHODIMP_(ULONG)
CBaseUnknown::IndirectedRelease(
    )
/*++

Routine Description:

    Implements IIndirectedUnknown::IndirectedRelease. This method is used
    when the object's inner IUnknown is being called. It ensures that when
    the object is aggregated that a NonDelegatedRelease is called from
    within a Release function.

Arguments:

    None.

Return Values:

    Returns the current reference count value.

--*/
{
    PAGED_CODE();
    //
    // Ensure that the NonDelegatedRelease is called from an IUnknown->Release
    // method, rather than from some other function. This is so that future
    // stack manipulation will work when a release is performed on an aggregated
    // object.
    //
    return NonDelegatedRelease();
}


COMDDKMETHOD
STDMETHODIMP_(NTSTATUS)
CBaseUnknown::IndirectedQueryInterface(
    IN REFIID InterfaceId,
    OUT PVOID* Interface
    )
/*++

Routine Description:

    Implements IIndirectedUnknown::IndirectedQueryInterface. This just
    calls the NonDelegatedQueryInterface.

Arguments:

    InterfaceId -
        Contains the identifier of the interface to return.

    Interface -
        The place in which to put the pointer to the interface returned.

Return Values:

    Returns STATUS_SUCCESS if the interface was returned, else
    STATUS_INVALID_PARAMETER.

--*/
{
    PAGED_CODE();
    return NonDelegatedQueryInterface(InterfaceId,Interface);
}


extern "C"
COMDDKAPI
void
NTAPI
KoRelease(
    IN REFCLSID ClassId
    )
/*++

Routine Description:

    This is used for C implementations of COM servers accessed via
    KoCreateInstance, wherein CBaseUnknown cannot be used. This is expected
    to be called when the reference count on the object reaches zero. The
    function decrements the reference count on the module.

    This function must be called directly from the IUnknown->lpVtbl->Release()
    method of the object.

Arguments:

    ClassId -
        The class of the object whose usage count is to be decremented.

Return Values:

    Nothing.

--*/
{
    PAGED_CODE();
    //
    // This code is expecting to be called from IUnknown->lpVtbl->Release, and will
    // eventually use the new primitives to rearrange the stack so that it
    // is actually run after the calling function has returned.
    //
    // Release a reference count on the module which
    // supports the parent's class. On zero, the module is
    // marked for delayed removal.
    //
    DecrementObjectCount(ClassId);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\ks\kslog.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    kslog.cpp

Abstract:

    This module contains the KS logging implementation.

Author:

    Dale Sather  (DaleSat) 10-May-1999

--*/

#include "ksp.h"
#include "stdarg.h"

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA


#if DBG

extern "C" PVOID KsLog = NULL;
extern "C" ULONG KsLogSize = (1024*64);
extern "C" ULONG KsLogPosition = 0;
extern "C" ULONGLONG KsLogTicksPerSecond = 0;

#define STRW_DEVICENAME TEXT("\\Device\\KsLog")
#define STRW_LINKNAME TEXT("\\DosDevices\\KsLog")

extern "C"
NTKERNELAPI
NTSTATUS
IoCreateDriver (
    IN PUNICODE_STRING DriverName OPTIONAL,
    IN PDRIVER_INITIALIZE InitializationFunction
    );


NTSTATUS
KsLogDispatchCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PAGED_CODE();

    ASSERT(DeviceObject);
    ASSERT(Irp);

    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

    irpSp->FileObject->FsContext = ULongToPtr(0);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp,IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}


NTSTATUS
KsLogDispatchClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp,IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}


//
// mmGetSystemAddressForMdl() is defined as a macro in wdm.h which
// calls mmMapLockedPages() which is treated as an evil by verifier.
// mmMapLockedPages is reimplemented by mm via
// mmMapLockedPagesSpecifyCache(MDL,Mode,mmCaches,NULL,TRUE,HighPriority)
// where TRUE is to indicate a bug check, should the call fails.
// I don't need the bug check, therefore, I specify FALSE below.
//
#define KsGetSystemAddressForMdl(MDL)                       \
     (((MDL)->MdlFlags & (MDL_MAPPED_TO_SYSTEM_VA |         \
            MDL_SOURCE_IS_NONPAGED_POOL)) ?                 \
                  ((MDL)->MappedSystemVa) :                 \
                  (MmMapLockedPagesSpecifyCache((MDL),      \
                                    KernelMode,             \
                                    MmCached,               \
                                    NULL,                   \
                                    FALSE,                  \
                                    HighPagePriority)))
                                    
NTSTATUS
KsLogDispatchRead(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PAGED_CODE();

    ASSERT(DeviceObject);
    ASSERT(Irp);

    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

    ULONG prevPosition = PtrToUlong(irpSp->FileObject->FsContext);
    ULONG position = (ULONG)
        InterlockedExchange(
            PLONG(&KsLogPosition),
            LONG(KsLogPosition));

    //
    // Either kind of wrapping results in the position getting reset.
    //
    if ((prevPosition > position) || (prevPosition + KsLogSize < position)) {
        prevPosition = position;
    }

    ULONG remaining = irpSp->Parameters.Read.Length;
    ULONG copied = 0;

	PUCHAR dest;
    if ( NULL != Irp->MdlAddress &&
	     NULL != (dest = PUCHAR(KsGetSystemAddressForMdl(Irp->MdlAddress)))) {
	    //
	    // When remaining is 0, we have a null MdlAddress. Check before leap.
	    // MmGetSystemAddressForMdl requires allocation of resources, i.e.
	    // it could fail. Might be even better to use 
	    // MmMapLockedPagesSpecifyCache() instead to avoid possible bugcheck.
	    //
	    while (1) {
    	    position = (ULONG)
        	    InterlockedExchange(
            	    PLONG(&KsLogPosition),
                	LONG(KsLogPosition));

	        ULONG modPosition = prevPosition % KsLogSize;

    	    ULONG toCopy = position - prevPosition;
	        if (toCopy > remaining) {
    	        toCopy = remaining;
        	}
	        if (toCopy > KsLogSize - modPosition) {
    	        toCopy = KsLogSize - modPosition;
        	}

	        if (! toCopy) {
    	        break;
	        }

    	    RtlCopyMemory(dest,PUCHAR(KsLog) + modPosition,toCopy);
	        remaining -= toCopy;
    	    copied += toCopy;
	        dest += toCopy;
	        prevPosition += toCopy;
    	}
    }

    irpSp->FileObject->FsContext = ULongToPtr(prevPosition);
    Irp->IoStatus.Information = copied;
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp,IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}

NTSTATUS
_KsLogDriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    ASSERT(DriverObject);

    DriverObject->DriverUnload = KsNullDriverUnload;

    DriverObject->MajorFunction[IRP_MJ_CREATE] = KsLogDispatchCreate;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = KsLogDispatchClose;
    DriverObject->MajorFunction[IRP_MJ_READ] = KsLogDispatchRead;

    UNICODE_STRING deviceName;
    RtlInitUnicodeString(&deviceName,STRW_DEVICENAME);
    PDEVICE_OBJECT deviceObject;
    NTSTATUS status =
        IoCreateDevice(
            DriverObject,
            0,
            &deviceName,
            FILE_DEVICE_KS,
            FILE_DEVICE_SECURE_OPEN,
            FALSE,
            &deviceObject);

    if (! NT_SUCCESS(status)) {
        _DbgPrintF(DEBUGLVL_TERSE,("Failed to create KS log device (%p)",status));
        return status;
    }

    UNICODE_STRING linkName;
    RtlInitUnicodeString(&linkName,STRW_LINKNAME);
    status = IoCreateSymbolicLink(&linkName,&deviceName);

    if (NT_SUCCESS(status)) {
        deviceObject->Flags |= DO_DIRECT_IO;
        deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
    } else {
        _DbgPrintF(DEBUGLVL_TERSE,("Failed to create KS log symbolic link (%p)",status));
        return status;
    }

    return STATUS_SUCCESS;
}


void
_KsLogInit(
    void
    )
{
    KsLog = ExAllocatePoolWithTag(NonPagedPool,KsLogSize,'gLsK');
    if (KsLog) {
        RtlZeroMemory(KsLog,KsLogSize);
    }
    LARGE_INTEGER tps;
    KeQueryPerformanceCounter(&tps);
    KsLogTicksPerSecond = tps.QuadPart;

    NTSTATUS status = IoCreateDriver(NULL,_KsLogDriverEntry);
    if (! NT_SUCCESS(status)) {
        _DbgPrintF(DEBUGLVL_TERSE,("Failed to create KS log driver (%p)",status));
    }
}


void
_KsLogInitContext(
    OUT PKSLOG_ENTRY_CONTEXT Context,
    IN PKSPIN Pin OPTIONAL,
    IN PVOID Component OPTIONAL
    )
{
    ASSERT(Context);

    if (Pin) {
        Context->Graph = NULL;
        Context->Filter = ULONG_PTR(KspFilterInterface(KsPinGetParentFilter(Pin)));
        Context->Pin = ULONG_PTR(KspPinInterface(Pin));
    } else {
        Context->Graph = NULL;
        Context->Filter = NULL;
        Context->Pin = NULL;
    }

    Context->Component = ULONG_PTR(Component);
}

#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif // ALLOC_PRAGMA


void
_KsLog(
    IN PKSLOG_ENTRY_CONTEXT Context OPTIONAL,
    IN ULONG Code,
    IN ULONG_PTR Irp,
    IN ULONG_PTR Frame,
    IN PKSLOG_ENTRY Entry
    )
{
    if (! Entry) {
        return;
    }

    if (Context) {
        RtlCopyMemory(&Entry->Context,Context,sizeof(Entry->Context));
    } else {
        RtlZeroMemory(&Entry->Context,sizeof(Entry->Context));
    }
    Entry->Code = Code;
    Entry->Irp = Irp;
    Entry->Frame = Frame;
}


PKSLOG_ENTRY
_KsLogEntry(
    IN ULONG ExtSize,
    IN PVOID Ext OPTIONAL
    )
{
    ASSERT((ExtSize != 0) || (Ext == NULL));

    if (! KsLog) {
        return NULL;
    }

    ULONGLONG time = KeQueryPerformanceCounter(NULL).QuadPart;

    //
    // Size must be aligned and must include an appended size field.
    //
    ULONG size = (sizeof(KSLOG_ENTRY) + ExtSize + sizeof(ULONG) + FILE_QUAD_ALIGNMENT) & ~FILE_QUAD_ALIGNMENT;

    while (1) {
        //
        // Determine the current position.  This may change because we have no
        // lock on it.
        //
        ULONG position = (ULONG)
            InterlockedExchange(
                PLONG(&KsLogPosition),
                LONG(KsLogPosition));
        ULONG modPosition = position % KsLogSize;

        //
        // See if there is enough room for this entry.
        //
        if (modPosition + size > KsLogSize) {
            //
            // No.  Try to fill up the remaining space.
            //
            if (InterlockedCompareExchange(
                    PLONG(&KsLogPosition),
                    0,
                    LONG(position)) == LONG(position)) {
                //
                // Captured the space we want to fill.  Fill it.
                //
                PULONG p = PULONG(PUCHAR(KsLog) + modPosition);
                for (ULONG count = (KsLogSize - modPosition) / sizeof(ULONG); count--; p++) {
                    *p = FILE_QUAD_ALIGNMENT + 1;
                }
            }
            continue;
        }

        //
        // Try to capture space for the entry.
        //
        if (InterlockedCompareExchange(
                PLONG(&KsLogPosition),
                LONG(position + size),
                LONG(position)) == LONG(position)) {
            //
            // Captured the space.  Store what we can.
            //
            PKSLOG_ENTRY entry = PKSLOG_ENTRY(PUCHAR(KsLog) + modPosition);
            entry->Size = size;
            entry->Time = (time * 1000000) / KsLogTicksPerSecond;
            *PULONG(PUCHAR(entry) + size - sizeof(ULONG)) = size;
            if (Ext) {
                RtlCopyMemory(entry + 1,Ext,ExtSize);
            }
            return entry;
        }
    }

    return NULL;
}


PKSLOG_ENTRY
_KsLogEntryF(
    IN PCHAR Format OPTIONAL,
    ...
    )
{
    if (! KsLog) {
        return NULL;
    }

    CHAR buffer[512];
    ULONG stringSize;

    //
    // Determine the size of the entry.
    //
    if (Format) {
        va_list arglist;
        va_start(arglist,Format);
        stringSize = _vsnprintf(buffer,sizeof(buffer),Format,arglist);
        va_end(arglist);
    } else {
        stringSize = 0;
    }

    return _KsLogEntry(stringSize,buffer);
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\ks\kswmi.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 2000

Module Name:

    kswmi.h

Abstract:

    Internal header file for KS.

--*/

#ifndef _KSWMI_H_
#define _KSWMI_H_

#include <wmistr.h>
#include <evntrace.h>
//#include <wmiumkm.h> Jee is conveting this into 2 other files.

//++++++
#if (ENABLE_KSWMI) 
#define KSWMI( s ) s
#define KSWMI_S( s ) { s }
#define KSWMIWriteEvent( Wnod ) KsWmiWriteEvent( Wnod )

//++++++
#else // KSWMI == 0
#define KSWMI( s )
#define KSWMI_S( s )
#define KSWMIWriteEvent( Wnod )
//------
#endif // if (KSWMI)


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\ks\ksp.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    ksp.h

Abstract:

    Internal header file for KS.

--*/

// This will go away after Beta 1:
#define SIZE_COMPATIBILITY

#if !defined( _KSP_ )

#define _KSP_

#ifdef __cplusplus
extern "C" {
#endif

#ifndef WIN9X_KS

#ifdef USE_WDM_H
#include <wdm.h>
#define _WDMDDK_
#else

#define _WDMDDK_
#include <ntddk.h>


#if 0

//
// When enabled, forces all KS related allocations into special pool
//

#if defined( ExAllocatePoolWithTag )
#undef ExAllocatePoolWithTag
#endif
#define ExAllocatePoolWithTag( PoolType, NumberOfBytes, Tag ) ExAllocatePoolWithTagPriority( PoolType, NumberOfBytes, Tag, NormalPoolPrioritySpecialPoolOverrun )

#endif

NTKERNELAPI
VOID
SeCaptureSubjectContext (
    OUT PSECURITY_SUBJECT_CONTEXT SubjectContext
    );
NTKERNELAPI
VOID
SeLockSubjectContext(
    IN PSECURITY_SUBJECT_CONTEXT SubjectContext
    );
NTKERNELAPI
VOID
SeUnlockSubjectContext(
    IN PSECURITY_SUBJECT_CONTEXT SubjectContext
    );
NTKERNELAPI
VOID
SeReleaseSubjectContext (
    IN PSECURITY_SUBJECT_CONTEXT SubjectContext
    );
NTKERNELAPI
NTSTATUS
SeAppendPrivileges(
    PACCESS_STATE AccessState,
    PPRIVILEGE_SET Privileges
    );
NTKERNELAPI
VOID
SeFreePrivileges(
    IN PPRIVILEGE_SET Privileges
    );
NTKERNELAPI
VOID
SeOpenObjectAuditAlarm (
    IN PUNICODE_STRING ObjectTypeName,
    IN PVOID Object OPTIONAL,
    IN PUNICODE_STRING AbsoluteObjectName OPTIONAL,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PACCESS_STATE AccessState,
    IN BOOLEAN ObjectCreated,
    IN BOOLEAN AccessGranted,
    IN KPROCESSOR_MODE AccessMode,
    OUT PBOOLEAN GenerateOnClose
    );
NTKERNELAPI
NTSTATUS
SeQuerySecurityDescriptorInfo (
    IN PSECURITY_INFORMATION SecurityInformation,
    OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN OUT PULONG Length,
    IN PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor
    );
NTKERNELAPI
NTSTATUS
SeSetSecurityDescriptorInfo (
    IN PVOID Object OPTIONAL,
    IN PSECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN OUT PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
    IN POOL_TYPE PoolType,
    IN PGENERIC_MAPPING GenericMapping
    );
#endif

#else
#include <wdm.h>

//
// These are not defined for Win98.  Since Win98 doesn't do security
// anyway, we don't care about the case the special kernel APC hanging
// the thread indefinately as it doesn't exist under Win98.
//
#define KeEnterCriticalRegion()
#define KeLeaveCriticalRegion()

#endif

#ifdef _WIN64
#define DEFINE_POINTERALIGNMENT(Element)
#define INIT_POINTERALIGNMENT(Element)
#else //!_WIN64
#define DEFINE_POINTERALIGNMENT(Element) PVOID Element;
#define INIT_POINTERALIGNMENT(Element) Element = NULL
#endif //!_WIN64

#include <windef.h>
#include <stdio.h>

#define _KSCONTROL_
#include <unknown.h>
#include <ks.h>
#include <ksi.h>
#undef INTERFACE

//
// I don't want to try to include cfgmgr32 just for this.
//
#ifndef MAX_DEVICE_ID_LEN
#define MAX_DEVICE_ID_LEN 200
#endif // MAX_DEVICE_ID_LEN

#if (DBG)
//
// debugging specific constants
//
#define STR_MODULENAME "ks: "
#define DEBUG_VARIABLE KSDebug
#endif
#include <ksdebug.h>
#include <swenum.h>

#define KSIDENTIFIER_SUPPORTMASK            0x000fff00
#define KSIDENTIFIER_OPERATIONMASK          0x000000ff

//
// Internal object header structures
//

// Item was allocated.
#define CREATE_ENTRY_FLAG_COPIED    0x00000001
#define CREATE_ENTRY_FLAG_DELETED   0x00000002

typedef struct {
    LIST_ENTRY              ListEntry;
    PKSOBJECT_CREATE_ITEM   CreateItem;
    PFNKSITEMFREECALLBACK   ItemFreeCallback;
    ULONG                   RefCount;
    ULONG                   Flags;
} KSICREATE_ENTRY, *PKSICREATE_ENTRY;

typedef struct _KSIDEVICE_HEADER
KSIDEVICE_HEADER, *PKSIDEVICE_HEADER;

struct _KSIDEVICE_HEADER {
    LIST_ENTRY              ChildCreateHandlerList;
#ifndef WIN9X_KS
#ifndef USE_WDM_H
    ERESOURCE               SecurityDescriptorResource;
#endif
#endif // !WIN9X_KS
    PDEVICE_OBJECT          PnpDeviceObject;
    PBUS_INTERFACE_REFERENCE BusInterface;
    LIST_ENTRY              ObjectList;
    FAST_MUTEX              ObjectListLock;
    FAST_MUTEX              CreateListLock;
    LIST_ENTRY              PowerList;
    FAST_MUTEX              LoPowerListLock;
    KSPIN_LOCK              HiPowerListLock;
    PETHREAD                PowerEnumThread;
    PDEVICE_OBJECT          BaseDevice;
    PVOID                   Object;
    BOOLEAN                 QueriedBusInterface;
};

typedef struct _KSIOBJECT_HEADER
KSIOBJECT_HEADER, *PKSIOBJECT_HEADER;

struct _KSIOBJECT_HEADER {
    const KSDISPATCH_TABLE* DispatchTable;
    LIST_ENTRY              ChildCreateHandlerList;
    PKSOBJECT_CREATE_ITEM   CreateItem;
    ACCESS_MASK             ObjectAccess;
    LIST_ENTRY              ObjectList;
    LIST_ENTRY              PowerList;
    PDEVICE_OBJECT          BaseDevice;
    PDEVICE_OBJECT          TargetDevice;
    PFNKSCONTEXT_DISPATCH   PowerDispatch;
    PVOID                   PowerContext;
    KSTARGET_STATE          TargetState;
    PVOID                   Object;
    PKSIOBJECT_HEADER       Self;
    ULONG                   MinimumStackDepth;
};

#if !defined( IO_REPARSE )
//
// Use IO_REPARSE and irpSp->FileObject->FileName
//

#define IO_REPARSE                               (0)
#endif

//
// Pool tags
//

#define POOLTAG_DEVICE_ASSOCIATION      'adWS'
#define POOLTAG_DEVICE_BUSID            'ibWS'
#define POOLTAG_DEVICE_BUSREFERENCE     'rbWS'
#define POOLTAG_DEVICE_FDOEXTENSION     'dfWS'
#define POOLTAG_DEVICE_ID               'diWS'
#define POOLTAG_DEVICE_INSTANCEID       'iiWS'
#define POOLTAG_DEVICE_INTERFACEPATH    'piWS'
#define POOLTAG_DEVICE_NAME             'ndWS'
#define POOLTAG_DEVICE_PDOEXTENSION     'dpWS'
#define POOLTAG_DEVICE_REFERENCE        'rdWS'
#define POOLTAG_DEVICE_REFERENCE_STRING 'srWS'
#define POOLTAG_DEVICE_RELATIONS        'erWS'
#define POOLTAG_DEVICE_REPARSE_STRING   'prWS'
#define POOLTAG_DEVICE_DRIVER_REGISTRY  'rdWS'
#define POOLTAG_DEVICE_IO_BUFFER        'oiWS'
#define POOLTAG_KEY_INFORMATION         'ikWS'

//
// Sweeper timer frequency (initial)
//

#define SWEEPER_TIMER_FREQUENCY         -150000000L
#define SWEEPER_TIMER_FREQUENCY_IN_SECS 15L
#define MAXIMUM_TIMEOUT_IN_SECS         1200L

//
// Structure defintions
//

typedef enum {
    ExtensionTypePdo,
    ExtensionTypeFdo
} EXTENSION_TYPE;

typedef enum {
    SweeperDeviceActive,
    SweeperDeviceRemoval,
    SweeperDeviceRemoved
} SWEEPER_MARKER;

typedef enum {
    ReferenceRemoved,
    ReferenceAdded,
    ReferenceFailedStart,
    ReferenceWaitingForStart,
    ReferenceStarted,
    ReferenceStopped
} REFERENCE_STATE;

typedef struct {
    LIST_ENTRY      ListEntry,
                    DeviceAssociations,
                    IoQueue;
    PDEVICE_OBJECT  PhysicalDeviceObject;    // PDO passed into AddDevice()
    REFERENCE_STATE State;
    BOOLEAN         Referenced;
    GUID            DeviceId;
    SWEEPER_MARKER  SweeperMarker;
    PWCHAR          DeviceName;
    PWCHAR          BusReferenceString;
    PWCHAR          DeviceGuidString;

    LARGE_INTEGER   IdleStartTime;
    LARGE_INTEGER   TimeoutPeriod;
    LARGE_INTEGER   TimeoutRemaining;
#if (DEBUG_LOAD_TIME)
    LARGE_INTEGER   LoadTime;
#endif    

    WCHAR           DeviceReferenceString[1];

} DEVICE_REFERENCE, *PDEVICE_REFERENCE;

typedef struct {
    LIST_ENTRY      ListEntry;
    GUID            InterfaceId;
    UNICODE_STRING  linkName;

} DEVICE_ASSOCIATION, *PDEVICE_ASSOCIATION;

typedef struct {

    LIST_ENTRY      DeviceReferenceList;
    EXTENSION_TYPE  ExtensionType;
    ULONG           InterfaceReferenceCount;
    FAST_MUTEX      DeviceListMutex;
    UNICODE_STRING  linkName;
    PDEVICE_OBJECT  PhysicalDeviceObject;    // PDO passed into AddDevice()
    PDEVICE_OBJECT  PnpDeviceObject;         // Attached device for forwarding
    PDEVICE_OBJECT  FunctionalDeviceObject;
    ULONG           TimerScheduled;
    KTIMER          SweeperTimer;
    KDPC            SweeperDpc;
    WORK_QUEUE_ITEM SweeperWorkItem;
    UNICODE_STRING  BaseRegistryPath;
    ULONG           AttachedDevice;

    LARGE_INTEGER   CounterFrequency;
    LARGE_INTEGER   MaximumTimeout;
    WCHAR           BusPrefix[ 1 ];

} FDO_EXTENSION, *PFDO_EXTENSION;

typedef struct {

    LIST_ENTRY          ListEntry;          // Padding for extension size...
                                            // DO NOT REMOVE, ExtensionType
                                            // must be aligned in both
                                            // FDO_EXTENSION and PDO_EXTENSION.
    EXTENSION_TYPE      ExtensionType;
    PDEVICE_OBJECT      PhysicalDeviceObject;
    PDEVICE_REFERENCE   DeviceReference;
    PFDO_EXTENSION      BusDeviceExtension;
    ULONG               DeviceReferenceCount;

} PDO_EXTENSION, *PPDO_EXTENSION;

typedef
NTSTATUS
(*PFNVALIDATEDATAFORMAT)(
    IN PVOID Context,
    IN PKSDATAFORMAT DataFormat,
    IN PKSMULTIPLE_ITEM AttributeList OPTIONAL,
    IN const KSDATARANGE* DataRange,
    IN const KSATTRIBUTE_LIST* AttributeRange OPTIONAL
    );

typedef
NTSTATUS
(*PFNREGENUM_CALLBACK) (
    IN HANDLE EnumPathKey,
    IN PUNICODE_STRING KeyName,
    IN PVOID EnumContext );

typedef struct {
    PDEVICE_REFERENCE   DeviceReference;
    PFDO_EXTENSION      FdoExtension;
    PUNICODE_STRING     DeviceGuidString;
    PUNICODE_STRING     DeviceReferenceString;

} CREATE_ASSOCIATION_CONTEXT, *PCREATE_ASSOCIATION_CONTEXT;

typedef struct {
    PFNKSREMOVEEVENT    RemoveHandler;
    DEFINE_POINTERALIGNMENT(Alignment)
    KSEVENT             Event;
    KSEVENT_ENTRY       EventEntry;
} KSIEVENT_ENTRY, *PKSIEVENT_ENTRY;

//
// Macros
//

NTSTATUS __inline
CompleteIrp(
    PIRP Irp,
    NTSTATUS Status,
    CCHAR PriorityBoost
    )
{
    Irp->IoStatus.Status = Status;
    IoCompleteRequest( Irp, PriorityBoost );
    return Status;
}


// busenum.c

PWSTR
BuildBusId(
    IN PPDO_EXTENSION PdoExtension
    );

PWSTR
BuildInstanceId(
    IN PPDO_EXTENSION PdoExtension
    );

VOID
ClearDeviceReferenceMarks(
    IN PFDO_EXTENSION FdoExtension
    );

NTSTATUS
CreateDeviceAssociation(
    IN HANDLE InterfaceKey,
    IN PUNICODE_STRING KeyName,
    IN PVOID EnumContext
    );

NTSTATUS
CreateDeviceReference(
    IN HANDLE DeviceListKey,
    IN PUNICODE_STRING KeyName,
    IN PVOID EnumContext
    );

NTSTATUS
CreatePdo(
    IN PFDO_EXTENSION FdoExtension,
    IN PDEVICE_REFERENCE DeviceReference,
    OUT PDEVICE_OBJECT *DeviceObject
    );

NTSTATUS
InstallInterface(
    IN PSWENUM_INSTALL_INTERFACE Interface,
    IN PUNICODE_STRING BaseRegistryPath
    );

NTSTATUS
RemoveInterface(
    IN PSWENUM_INSTALL_INTERFACE Interface,
    IN PUNICODE_STRING BaseRegistryPath
    );

NTSTATUS
QueryDeviceRelations(
    IN PFDO_EXTENSION FdoExtension,
    IN DEVICE_RELATION_TYPE RelationType,
    OUT PDEVICE_RELATIONS *DeviceRelations
    );

NTSTATUS
QueryId(
    IN PPDO_EXTENSION PdoExtension,
    IN BUS_QUERY_ID_TYPE IdType,
    IN OUT PWSTR *BusQueryId
    );

NTSTATUS
RegisterDeviceAssociation(
    IN PFDO_EXTENSION FdoExtension,
    IN PDEVICE_REFERENCE DeviceReference,
    IN PDEVICE_ASSOCIATION DeviceAssociation
    );

NTSTATUS
RemoveDevice(
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
RemoveDeviceAssociations(
    IN PDEVICE_REFERENCE DeviceReference
    );

VOID
RemoveUnreferencedDevices(
    IN PFDO_EXTENSION FdoExtension
    );

NTSTATUS
StartDevice(
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
SweeperDeferredRoutine(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

NTSTATUS
ScanBus(
    IN PDEVICE_OBJECT FunctionalDeviceObject
    );

VOID
SweeperWorker(
    IN PVOID Context
    );

// irp.c

NTSTATUS
KsiCreateObjectType(
    IN HANDLE ParentHandle,
    IN PWCHAR RequestType,
    IN PVOID CreateParameter,
    IN ULONG CreateParameterLength,
    IN ACCESS_MASK DesiredAccess,
    OUT PHANDLE ObjectHandle
    );

NTSTATUS
KsiCopyCreateParameter(
    IN PIRP Irp,
    IN OUT PULONG CapturedSize,
    OUT PVOID* CapturedParameter
    );

NTSTATUS
KsiGetBusInterface(
    IN PKSIDEVICE_HEADER DeviceHeader
    );

NTSTATUS
KsiFreeMatchingObjectCreateItems(
    IN KSDEVICE_HEADER Header,
    IN PKSOBJECT_CREATE_ITEM Match
    );

// api.c

NTSTATUS
ReadNodeNameValue(
    IN PIRP Irp,
    IN const GUID* Category,
    OUT PVOID NameBuffer
    );

NTSTATUS
QueryReferenceBusInterface(
    IN PDEVICE_OBJECT PnpDeviceObject,
    OUT PBUS_INTERFACE_REFERENCE BusInterface
    );

// property.c

NTSTATUS
KspPropertyHandler(
    IN PIRP Irp,
    IN ULONG PropertySetsCount,
    IN const KSPROPERTY_SET* PropertySet,
    IN PFNKSALLOCATOR Allocator OPTIONAL,
    IN ULONG PropertyItemSize OPTIONAL,
    IN const KSAUTOMATION_TABLE*const* NodeAutomationTables OPTIONAL,
    IN ULONG NodesCount
    );

// method.c

NTSTATUS
KspMethodHandler(
    IN PIRP Irp,
    IN ULONG MethodSetsCount,
    IN const KSMETHOD_SET* MethodSet,
    IN PFNKSALLOCATOR Allocator OPTIONAL,
    IN ULONG MethodItemSize OPTIONAL,
    IN const KSAUTOMATION_TABLE*const* NodeAutomationTables OPTIONAL,
    IN ULONG NodesCount
    );

// event.c

NTSTATUS
KspEnableEvent(
    IN PIRP Irp,
    IN ULONG EventSetsCount,
    IN const KSEVENT_SET* EventSet,
    IN OUT PLIST_ENTRY EventsList OPTIONAL,
    IN KSEVENTS_LOCKTYPE EventsFlags OPTIONAL,
    IN PVOID EventsLock OPTIONAL,
    IN PFNKSALLOCATOR Allocator OPTIONAL,
    IN ULONG EventItemSize OPTIONAL,
    IN const KSAUTOMATION_TABLE*const* NodeAutomationTables OPTIONAL,
    IN ULONG NodesCount,
    IN BOOLEAN CopyItemAndSet
    );

// automat.cpp

NTSTATUS
KspHandleAutomationIoControl(
    IN PIRP Irp,
    IN const KSAUTOMATION_TABLE* AutomationTable OPTIONAL,
    IN PLIST_ENTRY EventList OPTIONAL,
    IN PKSPIN_LOCK EventListLock OPTIONAL,
    IN const KSAUTOMATION_TABLE*const* NodeAutomationTables OPTIONAL,
    IN ULONG NodesCount
    );

// thread.c

WORK_QUEUE_TYPE
KsiQueryWorkQueueType(
    IN PKSWORKER Worker
    );

typedef interface IKsTransport *PIKSTRANSPORT;
typedef interface IKsRetireFrame *PIKSRETIREFRAME;
typedef interface IKsPowerNotify *PIKSPOWERNOTIFY;
typedef interface IKsProcessingObject *PIKSPROCESSINGOBJECT;
typedef interface IKsConnection *PIKSCONNECTION;
typedef interface IKsDevice *PIKSDEVICE;
typedef interface IKsFilterFactory *PIKSFILTERFACTORY;
typedef interface IKsFilter *PIKSFILTER;
typedef interface IKsPin *PIKSPIN;
typedef interface IKsPipeSection *PIKSPIPESECTION;
typedef interface IKsRequestor *PIKSREQUESTOR;
typedef interface IKsQueue *PIKSQUEUE;
typedef interface IKsSplitter *PIKSSPLITTER;
typedef interface IKsReevaluate *PIKSREEVALUATE;
typedef interface IKsIrpCompletion *PIKSIRPCOMPLETION;

typedef struct {
    LIST_ENTRY ListEntry;
    KSPIN_LOCK SpinLock;
} INTERLOCKEDLIST_HEAD, *PINTERLOCKEDLIST_HEAD;

typedef struct {
    LIST_ENTRY ListEntry;
    PKSPIN_LOCK SpinLock;
} INTERLOCKEDLIST_ENTRY, *PINTERLOCKEDLIST_ENTRY;

#define InitializeInterlockedListHead(h) \
    InitializeListHead(&(h)->ListEntry); \
    KeInitializeSpinLock(&(h)->SpinLock)

typedef struct _KSPSTREAM_POINTER
KSPSTREAM_POINTER, *PKSPSTREAM_POINTER;
typedef struct _KSPSTREAM_POINTER_COPY_CONTEXT
KSPSTREAM_POINTER_COPY_CONTEXT, *PKSPSTREAM_POINTER_COPY_CONTEXT;
typedef struct _KSPSTREAM_POINTER_COPY
KSPSTREAM_POINTER_COPY, *PKSPSTREAM_POINTER_COPY;
typedef struct _KSPPROCESSPIN
KSPPROCESSPIN, *PKSPPROCESSPIN;
typedef struct _KSPPROCESSPIN_INDEXENTRY
KSPPROCESSPIN_INDEXENTRY, *PKSPPROCESSPIN_INDEXENTRY;
typedef struct _KSPPROCESSPIPESECTION
KSPPROCESSPIPESECTION, *PKSPPROCESSPIPESECTION;
typedef struct KSPX_
KSPX, *PKSPX;
typedef struct KSPX_DISPATCH_
KSPX_DISPATCH, *PKSPX_DISPATCH;
typedef struct KSPX_DESCRIPTOR_
KSPX_DESCRIPTOR, *PKSPX_DESCRIPTOR;
typedef struct _KSIOBJECTBAG
KSIOBJECTBAG, *PKSIOBJECTBAG;
typedef struct _KSIOBJECTBAG_ENTRY
KSIOBJECTBAG_ENTRY, *PKSIOBJECTBAG_ENTRY;
typedef struct _KSIDEVICEBAG_ENTRY
KSIDEVICEBAG_ENTRY, *PKSIDEVICEBAG_ENTRY;
typedef struct _KSIDEVICEBAG
KSIDEVICEBAG, *PKSIDEVICEBAG;

typedef
NTSTATUS
(*PFNKSXIRP)(
    IN OUT PKSPX X,
    IN PIRP Irp
    );

struct KSPX_DISPATCH_ {
    PFNKSXIRP Create;
    PFNKSXIRP Close;
};

struct KSPX_DESCRIPTOR_ {
    PKSPX_DISPATCH Dispatch;
};

struct KSPX_ {
    PKSPX_DESCRIPTOR Descriptor;
    KSOBJECT_BAG Bag;
    PVOID Context;
};

typedef struct _KSPX_EXT 
KSPX_EXT, *PKSPX_EXT;

struct _KSPX_EXT {
    LIST_ENTRY ChildList;
    LIST_ENTRY SiblingListEntry;
    PLIST_ENTRY SiblingListHead;
    PKSPX_EXT Parent;
    KSOBJECTTYPE ObjectType;
    PUNKNOWN Interface;
    PUNKNOWN AggregatedClientUnknown;
    PIKSDEVICE Device;
    PIKSREEVALUATE Reevaluator;
    PKMUTEX FilterControlMutex;
    const KSAUTOMATION_TABLE* AutomationTable;
    INTERLOCKEDLIST_HEAD EventList;
    KSPX Public;
};

typedef struct {
    ULONG ByteCount;
    ULONG Stride;
    ULONG MappingsAllocated;
    ULONG MappingsFilled;
    PMDL Mdl;
    PVOID MapRegisterBase;
    PKSMAPPING Mappings;
} KSPMAPPINGS_TABLE, *PKSPMAPPINGS_TABLE;

typedef struct _KSPPOWER_ENTRY {
    LIST_ENTRY ListEntry;
    PIKSPOWERNOTIFY PowerNotify;
} KSPPOWER_ENTRY, *PKSPPOWER_ENTRY;

typedef struct _KSPFRAME_HEADER
KSPFRAME_HEADER, *PKSPFRAME_HEADER;

typedef struct KSPIRP_FRAMING_
{
    ULONG OutputBufferLength;
    LONG RefCount;
    LONG QueuedFrameHeaderCount;
    PKSPFRAME_HEADER FrameHeaders;
} KSPIRP_FRAMING, *PKSPIRP_FRAMING;

#define IRP_FRAMING_IRP_STORAGE(Irp) \
    ((PKSPIRP_FRAMING)(&IoGetCurrentIrpStackLocation(Irp)->Parameters))

typedef enum _KSPFRAME_HEADER_TYPE 
{
    KSPFRAME_HEADER_TYPE_NORMAL = 0,
    KSPFRAME_HEADER_TYPE_GHOST
} KSPFRAME_HEADER_TYPE, *PKSPFRAME_HEADER_TYPE;

struct _KSPFRAME_HEADER
{
    LIST_ENTRY ListEntry;
    PKSPFRAME_HEADER NextFrameHeaderInIrp;
    PVOID Queue;
    PIRP OriginalIrp;
    PMDL Mdl;
    PIRP Irp;
    PKSPIRP_FRAMING IrpFraming;
    PKSSTREAM_HEADER StreamHeader;
    PVOID FrameBuffer;
    PKSPMAPPINGS_TABLE MappingsTable;
    ULONG StreamHeaderSize;
    ULONG FrameBufferSize;
    PVOID Context;
    LONG RefCount;
    PVOID OriginalData;
    NTSTATUS Status;
    BOOLEAN DismissalCall;
    KSPFRAME_HEADER_TYPE Type;
    PKSPSTREAM_POINTER FrameHolder;
    //PKSPFRAME_HEADER ParentFrameHeader;
    //PKSSPLITPIN SplitPins;
    //ULONG ChildrenOut;
};

typedef struct _KSPFRAME_HEADER_ATTACHED
{
    KSPFRAME_HEADER FrameHeader;
    KSSTREAM_HEADER StreamHeader;
} KSPFRAME_HEADER_ATTACHED, *PKSPFRAME_HEADER_ATTACHED;

typedef enum {
    KSPSTREAM_POINTER_STATE_UNLOCKED,
    KSPSTREAM_POINTER_STATE_LOCKED,
    KSPSTREAM_POINTER_STATE_CANCELLED,
    KSPSTREAM_POINTER_STATE_DELETED,
    KSPSTREAM_POINTER_STATE_CANCEL_PENDING,
    KSPSTREAM_POINTER_STATE_DEAD,
    KSPSTREAM_POINTER_STATE_TIMED_OUT,
    KSPSTREAM_POINTER_STATE_TIMER_RESCHEDULE
} KSPSTREAM_POINTER_STATE;

typedef enum {
    KSPSTREAM_POINTER_MOTION_NONE,
    KSPSTREAM_POINTER_MOTION_ADVANCE,
    KSPSTREAM_POINTER_MOTION_CLEAR,
    KSPSTREAM_POINTER_MOTION_FLUSH
} KSPSTREAM_POINTER_MOTION;

typedef enum {
    KSPSTREAM_POINTER_TYPE_NORMAL,
    KSPSTREAM_POINTER_TYPE_INTERNAL
} KSPSTREAM_POINTER_TYPE;

struct _KSPSTREAM_POINTER {
    LIST_ENTRY ListEntry;
    LIST_ENTRY TimeoutListEntry;
    LONGLONG TimeoutTime;
    PFNKSSTREAMPOINTER CancelCallback;
    PFNKSSTREAMPOINTER TimeoutCallback;
    KSPSTREAM_POINTER_STATE State;
    KSPSTREAM_POINTER_TYPE Type;
    ULONG Stride;
    PIKSQUEUE Queue;
    PKSPFRAME_HEADER FrameHeader;
    PKSPFRAME_HEADER FrameHeaderStarted;
    KSSTREAM_POINTER Public;
};

struct _KSPSTREAM_POINTER_COPY_CONTEXT {
    LIST_ENTRY ListEntry;
    union {
        PIKSQUEUE Queue;
        PVOID Filter;
    };
};

struct _KSPSTREAM_POINTER_COPY {
    KSPSTREAM_POINTER StreamPointer;
    KSPSTREAM_POINTER_COPY_CONTEXT CopyContext;
};

typedef USHORT KSPIRPDISPOSITION;

#define KSPIRPDISPOSITION_ROLLCALL         0xffff
#define KSPIRPDISPOSITION_NONE             0x0000
#define KSPIRPDISPOSITION_UNKNOWN          0x1000
#define KSPIRPDISPOSITION_ISKERNELMODE     0x2000
#define KSPIRPDISPOSITION_ISPAGED          0x4000
#define KSPIRPDISPOSITION_ISNONPAGED       0x8000
#define KSPIRPDISPOSITION_NEEDNONPAGED     0x4000
#define KSPIRPDISPOSITION_NEEDMDLS         0x8000
#define KSPIRPDISPOSITION_USEMDLADDRESS    0x4000
#define KSPIRPDISPOSITION_CANCEL           0x8000
#define KSPIRPDISPOSITION_PROBE \
    (KSPROBE_ALLOCATEMDL|\
     KSPROBE_PROBEANDLOCK|\
     KSPROBE_SYSTEMADDRESS)
#define KSPIRPDISPOSITION_PROBEFORREAD \
    (KSPROBE_STREAMREAD|KSPIRPDISPOSITION_PROBE)
#define KSPIRPDISPOSITION_PROBEFORWRITE \
    (KSPROBE_STREAMWRITE|KSPIRPDISPOSITION_PROBE)
#define KSPIRPDISPOSITION_PROBEFORMODIFY \
    (KSPROBE_STREAMWRITEMODIFY|KSPIRPDISPOSITION_PROBE)
#define KSPIRPDISPOSITION_PROBEFLAGMASK \
    (KSPROBE_STREAMREAD|\
     KSPROBE_STREAMWRITE|\
     KSPROBE_ALLOCATEMDL|\
     KSPROBE_PROBEANDLOCK|\
     KSPROBE_SYSTEMADDRESS|\
     KSPROBE_MODIFY|\
     KSPROBE_ALLOWFORMATCHANGE)

typedef UCHAR KSPTRANSPORTTYPE;

#define KSPTRANSPORTTYPE_QUEUE                  0x00
#define KSPTRANSPORTTYPE_REQUESTOR              0x01
#define KSPTRANSPORTTYPE_SPLITTER               0x02
#define KSPTRANSPORTTYPE_SPLITTERBRANCH         0x03

#define KSPTRANSPORTTYPE_PINSOURCE         0x04
#define KSPTRANSPORTTYPE_PINSINK           0x08
#define KSPTRANSPORTTYPE_PINEXTRA          0x10
#define KSPTRANSPORTTYPE_PININTRA          0x20
#define KSPTRANSPORTTYPE_PININPUT          0x40
#define KSPTRANSPORTTYPE_PINOUTPUT         0x80

#define KSPSTACKDEPTH_FIRSTBRANCH -1
#define KSPSTACKDEPTH_LASTBRANCH -2

typedef struct _KSPTRANSPORTCONFIG {
    KSPTRANSPORTTYPE TransportType;
    KSPIRPDISPOSITION IrpDisposition;
    CCHAR StackDepth;
} KSPTRANSPORTCONFIG, *PKSPTRANSPORTCONFIG;

typedef 
void 
(*PFNKSFRAMEDISMISSALCALLBACK)(
    IN PKSPSTREAM_POINTER StreamPointer,
    IN PKSPFRAME_HEADER FrameHeader,
    IN PVOID Context
    );

#define KspFastMutexIsAcquired(m)\
    ((m)->Count != 1)

#define KspMutexIsAcquired(m)\
    ((m)->Header.SignalState != 1)

#define KsInitializeWorkSinkItem(WorkItem,Object)\
    ExInitializeWorkItem(\
        WorkItem,\
        KsWorkSinkItemWorker,\
        static_cast<PIKSWORKSINK>(Object));

#define KspExtFromIrp(Irp)\
    reinterpret_cast<PKSPX_EXT>(\
        (*reinterpret_cast<PKSIOBJECT_HEADER*>(\
        IoGetCurrentIrpStackLocation(Irp)->\
        FileObject->\
        FsContext))->Object)

#define KspExtFromFileObject(FileObject)\
    reinterpret_cast<PKSPX_EXT>(\
        (*reinterpret_cast<PKSIOBJECT_HEADER*>(\
        FileObject->\
        FsContext))->Object)        

#define KspExtFromCreateIrp(Irp)\
    reinterpret_cast<PKSPX_EXT>(\
        (*reinterpret_cast<PKSIOBJECT_HEADER*>(\
        IoGetCurrentIrpStackLocation(Irp)->\
        FileObject->\
        RelatedFileObject->\
        FsContext))->Object)

#define DEFINE_CONTROL()\
    void\
    AcquireControl(\
        void\
        )\
    {\
        KeWaitForMutexObject (\
            m_Ext.FilterControlMutex,\
            Executive,\
            KernelMode,\
            FALSE,\
            NULL\
            );\
    };\
    void\
    ReleaseControl(\
        void\
        )\
    {\
        KeReleaseMutex (\
            m_Ext.FilterControlMutex,\
            FALSE\
            );\
    }

#define DEFINE_FROMIRP(CKsXxx)\
    static\
    CKsXxx *\
    FromIrp(\
        IN PIRP Irp\
        )\
    {\
        return\
            CONTAINING_RECORD(\
                KspExtFromIrp(Irp),\
                CKsXxx,\
                m_Ext);\
    }

#define DEFINE_FROMCREATEIRP(CKsXxx)\
    static\
    CKsXxx *\
    FromCreateIrp(\
        IN PIRP Irp\
    )\
    {\
        return\
            CONTAINING_RECORD(\
                KspExtFromCreateIrp(Irp),\
                CKsXxx,\
                m_Ext);\
    }

#define IMPLEMENT_GETSTRUCT(CKsXxx,PKSXXX)\
    PKSXXX\
    CKsXxx::\
    GetStruct(\
        void\
        )\
    {\
        return &m_Ext.Public;\
    }

#undef INTERFACE
#define INTERFACE IKsTransport
DECLARE_INTERFACE_(IKsTransport,IUnknown)
{
    STDMETHOD_(NTSTATUS, TransferKsIrp)(THIS_
        IN PIRP Irp,
        OUT PIKSTRANSPORT* NextTransport
        ) PURE;

    STDMETHOD_(void,DiscardKsIrp)(THIS_
        IN PIRP Irp,
        OUT PIKSTRANSPORT* NextTransport
        ) PURE;

    STDMETHOD_(void,Connect)(THIS_
        IN PIKSTRANSPORT NewTransport OPTIONAL,
        OUT PIKSTRANSPORT *OldTransport OPTIONAL,
        OUT PIKSTRANSPORT *BranchTransport OPTIONAL,
        IN KSPIN_DATAFLOW DataFlow
        ) PURE;

    STDMETHOD_(NTSTATUS, SetDeviceState)(THIS_
        IN KSSTATE NewState,
        IN KSSTATE OldState,
        OUT PIKSTRANSPORT* NextTransport
        ) PURE;

    STDMETHOD_(void,SetResetState)(THIS_
        IN KSRESET ksReset,
        OUT PIKSTRANSPORT* NextTransport
        ) PURE;

    STDMETHOD_(void,GetTransportConfig)(THIS_
        OUT PKSPTRANSPORTCONFIG Config,
        OUT PIKSTRANSPORT* NextTransport,
        OUT PIKSTRANSPORT* PrevTransport
        ) PURE;

    STDMETHOD_(void,SetTransportConfig)(THIS_
        IN const KSPTRANSPORTCONFIG* Config,
        OUT PIKSTRANSPORT* NextTransport,
        OUT PIKSTRANSPORT* PrevTransport
        ) PURE;

    STDMETHOD_(void,ResetTransportConfig)(THIS_
        OUT PIKSTRANSPORT* NextTransport,
        OUT PIKSTRANSPORT *PrevTransport
        ) PURE;
};
#undef INTERFACE

#define IMP_IKsTransport\
    STDMETHODIMP_(NTSTATUS)\
    TransferKsIrp(\
        IN PIRP pIrp,\
        OUT PIKSTRANSPORT* NextTransport\
        );\
    STDMETHODIMP_(void)\
    DiscardKsIrp(\
        IN PIRP pIrp,\
        OUT PIKSTRANSPORT* NextTransport\
        );\
    STDMETHODIMP_(void)\
    Connect(\
        IN PIKSTRANSPORT NewTransport OPTIONAL,\
        OUT PIKSTRANSPORT *OldTransport OPTIONAL,\
        OUT PIKSTRANSPORT *BranchTransport OPTIONAL,\
        IN KSPIN_DATAFLOW DataFlow\
        );\
    STDMETHODIMP_(NTSTATUS)\
    SetDeviceState(\
        IN KSSTATE NewState,\
        IN KSSTATE OldState,\
        OUT PIKSTRANSPORT* NextTransport\
        );\
    STDMETHODIMP_(void)\
    SetResetState(\
        IN KSRESET ksReset,\
        OUT PIKSTRANSPORT* NextTransport\
        );\
    STDMETHODIMP_(void)\
    GetTransportConfig(\
        OUT PKSPTRANSPORTCONFIG Config,\
        OUT PIKSTRANSPORT* NextTransport,\
        OUT PIKSTRANSPORT* PrevTransport\
        );\
    STDMETHODIMP_(void)\
    SetTransportConfig(\
        IN const KSPTRANSPORTCONFIG* Config,\
        OUT PIKSTRANSPORT* NextTransport,\
        OUT PIKSTRANSPORT* PrevTransport\
        );\
    STDMETHODIMP_(void)\
    ResetTransportConfig(\
        OUT PIKSTRANSPORT* NextTransport,\
        OUT PIKSTRANSPORT* PrevTransport\
        )

#undef INTERFACE
#define INTERFACE IKsRetireFrame
DECLARE_INTERFACE_(IKsRetireFrame,IUnknown)
{
    STDMETHOD_(void,RetireFrame)(THIS_
        IN PKSPFRAME_HEADER FrameHeader,
        IN NTSTATUS Status
        ) PURE;
};
#undef INTERFACE

#define IMP_IKsRetireFrame\
    STDMETHODIMP_(void) RetireFrame(\
        IN PKSPFRAME_HEADER FrameHeader,\
        IN NTSTATUS Status\
        )

#undef INTERFACE
#define INTERFACE IKsIrpCompletion
DECLARE_INTERFACE_(IKsIrpCompletion,IUnknown)
{
    STDMETHOD_(void,CompleteIrp)(THIS_
        IN PIRP Irp
        ) PURE;
};
#undef INTERFACE

#define IMP_IKsIrpCompletion\
    STDMETHODIMP_(void) CompleteIrp(\
        IN PIRP Irp\
        )

#undef INTERFACE
#define INTERFACE IKsPowerNotify
DECLARE_INTERFACE_(IKsPowerNotify,IUnknown)
{
    STDMETHOD_(void,Sleep)(THIS_
        IN DEVICE_POWER_STATE State
        ) PURE;

    STDMETHOD_(void,Wake)(THIS
        ) PURE;
};
#undef INTERFACE

#define IMP_IKsPowerNotify\
    STDMETHODIMP_(void) Sleep(\
        IN DEVICE_POWER_STATE State\
        );\
    STDMETHODIMP_(void) Wake(\
        void\
        )

#undef INTERFACE
#define INTERFACE IKsProcessingObject
DECLARE_INTERFACE_(IKsProcessingObject,IUnknown)
{
    STDMETHOD_(void,ProcessingObjectWork)(THIS
        ) PURE;

    STDMETHOD_(PKSGATE,GetAndGate)(THIS
        ) PURE;

    STDMETHOD_(void,Process)(THIS_
        IN BOOLEAN Asynchronous
        ) PURE;

    STDMETHOD_(void,Reset)(THIS
        ) PURE;

    STDMETHOD_(void,TriggerNotification)(THIS
        ) PURE;
};
#undef INTERFACE

#define IMP_IKsProcessingObject\
    STDMETHODIMP_(void) ProcessingObjectWork(\
        void\
        );\
    STDMETHODIMP_(PKSGATE) GetAndGate(\
        void\
        );\
    STDMETHODIMP_(void) Process(\
        IN BOOLEAN Asynchronous\
        );\
    STDMETHODIMP_(void) Reset(\
        void\
        );\
    STDMETHODIMP_(void) TriggerNotification(\
        void\
        )

#undef INTERFACE
#define INTERFACE IKsConnection
DECLARE_INTERFACE_(IKsConnection,IUnknown)
{
    STDMETHOD_(void,Disconnect)(THIS
        ) PURE;

    STDMETHOD_(NTSTATUS, Bypass)(THIS_
        IN PIKSTRANSPORT Source,
        IN PIKSTRANSPORT Sink
        ) PURE;

    STDMETHOD_(NTSTATUS, Unbypass)(THIS
        ) PURE;

    STDMETHOD_(NTSTATUS, FastHandshake)(THIS_
        IN PKSHANDSHAKE In,
        OUT PKSHANDSHAKE Out
        ) PURE;

    STDMETHOD_(PIKSFILTER,GetFilter)(THIS
        ) PURE;

    STDMETHOD_(BOOLEAN, CaptureBypassRights)(THIS_
        IN BOOLEAN TryState
        ) PURE;

};
#undef INTERFACE

#define IMP_IKsConnection\
    STDMETHODIMP_(void)\
    Disconnect(\
        );\
    STDMETHODIMP_(NTSTATUS)\
    Bypass(\
        IN PIKSTRANSPORT Source,\
        IN PIKSTRANSPORT Sink\
        );\
    STDMETHODIMP_(NTSTATUS)\
    Unbypass(\
        void\
        );\
    STDMETHODIMP_(NTSTATUS)\
    FastHandshake(\
        IN PKSHANDSHAKE In,\
        OUT PKSHANDSHAKE Out\
        );\
    STDMETHODIMP_(PIKSFILTER)\
    GetFilter(\
        void\
        );\
    STDMETHODIMP_(BOOLEAN)\
    CaptureBypassRights(THIS_\
        IN BOOLEAN TryState\
        )

#undef INTERFACE
#define INTERFACE IKsWorkSink
DECLARE_INTERFACE_(IKsWorkSink,IUnknown)
{
    STDMETHOD_(void,Work)(THIS
        ) PURE;
};
#undef INTERFACE

typedef IKsWorkSink *PIKSWORKSINK;

#define IMP_IKsWorkSink\
    STDMETHODIMP_(void) Work(\
        void\
        )

#undef INTERFACE
#define INTERFACE IKsDevice
DECLARE_INTERFACE_(IKsDevice,IUnknown)
{
    STDMETHOD_(PKSDEVICE,GetStruct)(THIS
        ) PURE;

    STDMETHOD_(void,InitializeObjectBag)(THIS_
        IN PKSIOBJECTBAG ObjectBag,
        IN PKMUTEX Mutex OPTIONAL
        ) PURE;

    STDMETHOD_(void,AcquireDevice)(THIS
        ) PURE;

    STDMETHOD_(void,ReleaseDevice)(THIS
        ) PURE;

    STDMETHOD_(void,GetAdapterObject)(THIS_
        OUT PADAPTER_OBJECT* AdapterObject,
        OUT PULONG MaxMappingByteCount,
        OUT PULONG MappingTableStride
        ) PURE;

    STDMETHOD_(void,AddPowerEntry)(THIS_
        IN PKSPPOWER_ENTRY PowerEntry,
        IN PIKSPOWERNOTIFY PowerNotify
        ) PURE;

    STDMETHOD_(void,RemovePowerEntry)(THIS_
        IN PKSPPOWER_ENTRY PowerEntry
        ) PURE;

    STDMETHOD_(NTSTATUS, PinStateChange)(THIS_
        IN PKSPIN Pin,
        IN PIRP Irp OPTIONAL,
        IN KSSTATE To,
        IN KSSTATE From
        ) PURE;

    STDMETHOD_(NTSTATUS, ArbitrateAdapterChannel)(THIS_
        IN ULONG MappingsNeeded,
        IN PDRIVER_CONTROL Callback,
        IN PVOID CallbackContext
        ) PURE;

    STDMETHOD_(NTSTATUS, CheckIoCapability)(THIS
        ) PURE;

};
#undef INTERFACE

#define IMP_IKsDevice\
    STDMETHODIMP_(PKSDEVICE) GetStruct(\
        void\
        );\
    STDMETHODIMP_(void) InitializeObjectBag(\
        IN PKSIOBJECTBAG ObjectBag,\
        IN PKMUTEX Mutex OPTIONAL\
        );\
    STDMETHODIMP_(void) AcquireDevice(\
        void\
        );\
    STDMETHODIMP_(void) ReleaseDevice(\
        void\
        );\
    STDMETHODIMP_(void) GetAdapterObject(\
        OUT PADAPTER_OBJECT* AdapterObject,\
        OUT PULONG MaxMappingByteCount,\
        OUT PULONG MappingTableStride\
        );\
    STDMETHODIMP_(void) AddPowerEntry(\
        IN PKSPPOWER_ENTRY PowerEntry,\
        IN PIKSPOWERNOTIFY PowerNotify\
        );\
    STDMETHODIMP_(void) RemovePowerEntry(\
        IN PKSPPOWER_ENTRY PowerEntry\
        );\
    STDMETHODIMP_(NTSTATUS) PinStateChange(\
        IN PKSPIN Pin,\
        IN PIRP Irp OPTIONAL,\
        IN KSSTATE To,\
        IN KSSTATE From\
        );\
    STDMETHODIMP_(NTSTATUS) ArbitrateAdapterChannel(\
        IN ULONG MappingsNeeded,\
        IN PDRIVER_CONTROL Callback,\
        IN PVOID CallbackContext\
        );\
    STDMETHODIMP_(NTSTATUS) CheckIoCapability(\
        void\
        )


#undef INTERFACE
#define INTERFACE IKsFilterFactory
DECLARE_INTERFACE_(IKsFilterFactory,IUnknown)
{
    STDMETHOD_(PKSFILTERFACTORY,GetStruct)(THIS
        ) PURE;

    STDMETHOD_(NTSTATUS, SetDeviceClassesState)(THIS_
        IN BOOLEAN NewState
        ) PURE;
};
#undef INTERFACE

#define IMP_IKsFilterFactory\
    STDMETHODIMP_(PKSFILTERFACTORY) GetStruct(\
        void\
        );\
    STDMETHODIMP_(NTSTATUS) SetDeviceClassesState(\
        IN BOOLEAN NewState\
        )

#undef INTERFACE
#define INTERFACE IKsFilter
DECLARE_INTERFACE_(IKsFilter,IUnknown)
{
    STDMETHOD_(PKSFILTER,GetStruct)(THIS
        ) PURE;

    STDMETHOD_(BOOLEAN,DoAllNecessaryPinsExist)(THIS
        ) PURE;

    STDMETHOD_(NTSTATUS, CreateNode)(THIS_
        IN PIRP Irp,
        IN PIKSPIN ParentPin OPTIONAL,
        IN PVOID Context OPTIONAL,
        IN PLIST_ENTRY SiblingList
        ) PURE;

    STDMETHOD_(NTSTATUS, BindProcessPinsToPipeSection)(THIS_
        IN PKSPPROCESSPIPESECTION PipeSection,
        IN PVOID PipeId OPTIONAL,
        IN PKSPIN Pin OPTIONAL,
        OUT PIKSPIN *MasterPin,
        OUT PKSGATE *AndGate
        ) PURE;

    STDMETHOD_(void,UnbindProcessPinsFromPipeSection)(THIS_
        IN PKSPPROCESSPIPESECTION PipeSection
        ) PURE;

    STDMETHOD_(NTSTATUS, AddProcessPin)(THIS_
        IN PKSPPROCESSPIN ProcessPin
        ) PURE;

    STDMETHOD_(void,RemoveProcessPin)(THIS_
        IN PKSPPROCESSPIN ProcessPin
        ) PURE;

    STDMETHOD_(BOOLEAN,ReprepareProcessPipeSection)(THIS_
        IN PKSPPROCESSPIPESECTION ProcessPipeSection,
        IN OUT PULONG Flags
        ) PURE;	

    STDMETHOD_(void,DeliverResetState)(THIS_
        IN PKSPPROCESSPIPESECTION ProcessPipe,
        IN KSRESET NewState
        ) PURE;

    STDMETHOD_(BOOLEAN,IsFrameHolding)(THIS
        ) PURE;

    STDMETHOD_(void,RegisterForCopyCallbacks)(THIS_
        IN PIKSQUEUE Queue,
        IN BOOLEAN Register
        ) PURE;

    #ifdef SUPPORT_DRM
    STDMETHOD_(PFNKSFILTERPROCESS,GetProcessDispatch)(THIS
        ) PURE;
    #endif // SUPPORT_DRM
};
#undef INTERFACE

#ifdef SUPPORT_DRM
#define IMP_IKsFilter\
    STDMETHODIMP_(PKSFILTER) GetStruct(\
        void\
        );\
    STDMETHODIMP_(BOOLEAN)\
    DoAllNecessaryPinsExist(\
        void\
        );\
    STDMETHODIMP_(NTSTATUS) CreateNode(\
        IN PIRP Irp,\
        IN PIKSPIN ParentPin OPTIONAL,\
        IN PVOID Context OPTIONAL,\
        IN PLIST_ENTRY SiblingList\
        );\
    STDMETHODIMP_(NTSTATUS) BindProcessPinsToPipeSection(\
        IN PKSPPROCESSPIPESECTION PipeSection,\
        IN PVOID PipeId OPTIONAL,\
        IN PKSPIN Pin OPTIONAL,\
        OUT PIKSPIN *MasterPin,\
        OUT PKSGATE *AndGate\
        );\
    STDMETHODIMP_(void) UnbindProcessPinsFromPipeSection(\
        IN PKSPPROCESSPIPESECTION PipeSection\
        );\
    STDMETHODIMP_(NTSTATUS) AddProcessPin(\
        IN PKSPPROCESSPIN ProcessPin\
        );\
    STDMETHODIMP_(void) RemoveProcessPin(\
        IN PKSPPROCESSPIN ProcessPin\
        );\
    STDMETHODIMP_(BOOLEAN) ReprepareProcessPipeSection(\
        IN PKSPPROCESSPIPESECTION ProcessPipeSection,\
        IN OUT PULONG Flags\
        );\
    STDMETHODIMP_(void) DeliverResetState(\
        IN PKSPPROCESSPIPESECTION ProcessPipe,\
        IN KSRESET NewState\
        );\
    STDMETHODIMP_(BOOLEAN) IsFrameHolding(\
        void\
        );\
    STDMETHODIMP_(void) RegisterForCopyCallbacks(\
        IN PIKSQUEUE Queue,\
        IN BOOLEAN Register\
        );\
    STDMETHODIMP_(PFNKSFILTERPROCESS) GetProcessDispatch(\
        void\
        )
#else // SUPPORT_DRM
#define IMP_IKsFilter\
    STDMETHODIMP_(PKSFILTER) GetStruct(\
        void\
        );\
    STDMETHODIMP_(BOOLEAN)\
    DoAllNecessaryPinsExist(\
        void\
        );\
    STDMETHODIMP_(NTSTATUS) CreateNode(\
        IN PIRP Irp,\
        IN PIKSPIN ParentPin OPTIONAL,\
        IN PVOID Context OPTIONAL,\
        IN PLIST_ENTRY SiblingList\
        );\
    STDMETHODIMP_(NTSTATUS) BindProcessPinsToPipeSection(\
        IN PKSPPROCESSPIPESECTION PipeSection,\
        IN PVOID PipeId OPTIONAL,\
        IN PKSPIN Pin OPTIONAL,\
        OUT PIKSPIN *MasterPin,\
        OUT PKSGATE *AndGate\
        );\
    STDMETHODIMP_(void) UnbindProcessPinsFromPipeSection(\
        IN PKSPPROCESSPIPESECTION PipeSection\
        );\
    STDMETHODIMP_(NTSTATUS) AddProcessPin(\
        IN PKSPPROCESSPIN ProcessPin\
        );\
    STDMETHODIMP_(void) RemoveProcessPin(\
        IN PKSPPROCESSPIN ProcessPin\
        );\
    STDMETHODIMP_(BOOLEAN) ReprepareProcessPipeSection(\
        IN PKSPPROCESSPIPESECTION ProcessPipeSection,\
        IN OUT PULONG Flags\
        );\
    STDMETHODIMP_(void) DeliverResetState(\
        IN PKSPPROCESSPIPESECTION ProcessPipe,\
        IN KSRESET NewState\
        );\
    STDMETHODIMP_(BOOLEAN) IsFrameHolding(\
        void\
        );\
    STDMETHODIMP_(void) RegisterForCopyCallbacks(\
        IN PIKSQUEUE Queue,\
        IN BOOLEAN Register\
        )
#endif // SUPPORT_DRM

#undef INTERFACE
#define INTERFACE IKsPin
DECLARE_INTERFACE_(IKsPin,IKsTransport)
{
    STDMETHOD_(PKSPIN,GetStruct)(THIS
        ) PURE;

    STDMETHOD_(PKSPPROCESSPIN,GetProcessPin)(THIS
        ) PURE;

    STDMETHOD_(NTSTATUS, AttemptBypass)(THIS
        ) PURE;

    STDMETHOD_(NTSTATUS, AttemptUnbypass)(THIS
        ) PURE;

    STDMETHOD_(void,GenerateConnectionEvents)(THIS_
        IN ULONG OptionsFlags
        ) PURE;

    STDMETHOD_(NTSTATUS, ClientSetDeviceState)(THIS_
        IN KSSTATE NewState,
        IN KSSTATE OldState
        ) PURE;
};
#undef INTERFACE

#define IMP_IKsPin\
    IMP_IKsTransport;\
    STDMETHODIMP_(PKSPIN) GetStruct(\
        void\
        );\
    STDMETHODIMP_(PKSPPROCESSPIN) GetProcessPin(\
        void\
        );\
    STDMETHODIMP_(NTSTATUS) AttemptBypass(\
        void\
        );\
    STDMETHODIMP_(NTSTATUS) AttemptUnbypass(\
        void\
        );\
    STDMETHODIMP_(void) GenerateConnectionEvents(\
        IN ULONG OptionsFlags\
        );\
    STDMETHODIMP_(NTSTATUS) ClientSetDeviceState(\
        IN KSSTATE NewState,\
        IN KSSTATE OldState\
        )

#undef INTERFACE
#define INTERFACE IKsPipeSection
DECLARE_INTERFACE_(IKsPipeSection,IUnknown)
{
    STDMETHOD_(NTSTATUS, SetDeviceState)(THIS_
        IN PIKSPIN Pin OPTIONAL,
        IN KSSTATE NewState
        ) PURE;

    STDMETHOD_(void,SetResetState)(THIS_
        IN PIKSPIN Pin,
        IN KSRESET NewState
        ) PURE;

    STDMETHOD_(void,GenerateConnectionEvents)(THIS_
        IN ULONG OptionsFlags
        ) PURE;

    STDMETHOD_(NTSTATUS, DistributeStateChangeToPins)(THIS_
        IN KSSTATE NewState,
        IN KSSTATE OldState
        ) PURE;

    STDMETHOD_(void,ConfigurationSet)(THIS_
        IN BOOLEAN Configured
        ) PURE;

    STDMETHOD_(void,UnbindProcessPins)(THIS
        ) PURE;

};
#undef INTERFACE

#define IMP_IKsPipeSection\
    STDMETHODIMP_(NTSTATUS) SetDeviceState(\
        IN PIKSPIN Pin OPTIONAL,\
        IN KSSTATE NewState\
        );\
    STDMETHODIMP_(void) SetResetState(\
        IN PIKSPIN Pin,\
        IN KSRESET NewState\
        );\
    STDMETHODIMP_(void) GenerateConnectionEvents(\
        IN ULONG OptionsFlags\
        );\
    STDMETHODIMP_(NTSTATUS) DistributeStateChangeToPins(\
        IN KSSTATE NewState,\
        IN KSSTATE OldState\
        );\
    STDMETHODIMP_(void) ConfigurationSet(\
        IN BOOLEAN Configured\
        );\
    STDMETHODIMP_(void) UnbindProcessPins (\
        void\
        )

#undef INTERFACE
#define INTERFACE IKsRequestor
DECLARE_INTERFACE_(IKsRequestor,IKsTransport)
{
    STDMETHOD_(NTSTATUS, SubmitFrame)(THIS_
        IN PKSPFRAME_HEADER FrameHeader
        ) PURE;
};
#undef INTERFACE

#define IMP_IKsRequestor\
    IMP_IKsTransport;\
    STDMETHODIMP_(NTSTATUS) SubmitFrame(\
        IN PKSPFRAME_HEADER FrameHeader\
        )

#undef INTERFACE
#define INTERFACE IKsQueue
DECLARE_INTERFACE_(IKsQueue,IKsTransport)
{
    STDMETHOD_(NTSTATUS, CloneStreamPointer)(THIS_
        OUT PKSPSTREAM_POINTER* StreamPointer,
        IN PFNKSSTREAMPOINTER CancelCallback OPTIONAL,
        IN ULONG ContextSize,
        IN PKSPSTREAM_POINTER StreamPointerToClone,
        IN KSPSTREAM_POINTER_TYPE StreamPointerType
        ) PURE;
    STDMETHOD_(void,DeleteStreamPointer)(THIS_
        IN PKSPSTREAM_POINTER StreamPointer
        ) PURE;
    STDMETHOD_(PKSPFRAME_HEADER,LockStreamPointer)(THIS_
        IN PKSPSTREAM_POINTER StreamPointer
        ) PURE;
    STDMETHOD_(void,UnlockStreamPointer)(THIS_
        IN PKSPSTREAM_POINTER StreamPointer,
        IN KSPSTREAM_POINTER_MOTION Motion
        ) PURE;
    STDMETHOD_(void,AdvanceUnlockedStreamPointer)(THIS_
        IN PKSPSTREAM_POINTER StreamPointer
        ) PURE;
    STDMETHOD_(PKSPSTREAM_POINTER,GetLeadingStreamPointer)(THIS_
        IN KSSTREAM_POINTER_STATE State
        ) PURE;
    STDMETHOD_(PKSPSTREAM_POINTER,GetTrailingStreamPointer)(THIS_
        IN KSSTREAM_POINTER_STATE State
        ) PURE;
    STDMETHOD_(void,ScheduleTimeout)(THIS_
        IN PKSPSTREAM_POINTER StreamPointer,
        IN PFNKSSTREAMPOINTER Callback,
        IN LONGLONG Interval
        ) PURE;
    STDMETHOD_(void,CancelTimeout)(THIS_
        IN PKSPSTREAM_POINTER StreamPointer
        ) PURE;
    STDMETHOD_(PKSPSTREAM_POINTER,GetFirstClone)(THIS
        ) PURE;
    STDMETHOD_(PKSPSTREAM_POINTER,GetNextClone)(THIS_
        IN PKSPSTREAM_POINTER StreamPointer
        ) PURE;
    STDMETHOD_(void,GetAvailableByteCount)(THIS_
        OUT PLONG InputDataBytes OPTIONAL,
        OUT PLONG OutputBufferBytes OPTIONAL
        ) PURE;
    STDMETHOD_(void,UpdateByteAvailability)(THIS_
        IN PKSPSTREAM_POINTER streamPointer,
        IN ULONG InUsed,
        IN ULONG OutUsed
        ) PURE;
    STDMETHOD_(NTSTATUS,SetStreamPointerStatusCode)(THIS_
        IN PKSPSTREAM_POINTER streamPointer,
        IN NTSTATUS Status
        ) PURE;
    STDMETHOD_(void,RegisterFrameDismissalCallback)(THIS_
        IN PFNKSFRAMEDISMISSALCALLBACK FrameDismissalCallback,
        IN PVOID FrameDismissalContext
        ) PURE;
    STDMETHOD_(BOOLEAN,GeneratesMappings)(THIS
        ) PURE;
    STDMETHOD_(void, CopyFrame)(THIS_
        IN PKSPSTREAM_POINTER sourcePointer
        ) PURE;
#if DBG
    STDMETHOD_(void,DbgPrintQueue)(THIS
        ) PURE;
#endif
};
#undef INTERFACE

#define IMP_IKsQueue\
    IMP_IKsTransport;\
    STDMETHODIMP_(NTSTATUS) CloneStreamPointer(\
        OUT PKSPSTREAM_POINTER* StreamPointer,\
        IN PFNKSSTREAMPOINTER CancelCallback OPTIONAL,\
        IN ULONG ContextSize,\
        IN PKSPSTREAM_POINTER StreamPointerToClone,\
        IN KSPSTREAM_POINTER_TYPE StreamPointerType\
        );\
    STDMETHODIMP_(void) DeleteStreamPointer(\
        IN PKSPSTREAM_POINTER StreamPointer\
        );\
    STDMETHODIMP_(PKSPFRAME_HEADER) LockStreamPointer(\
        IN PKSPSTREAM_POINTER StreamPointer\
        );\
    STDMETHODIMP_(void) UnlockStreamPointer(\
        IN PKSPSTREAM_POINTER StreamPointer,\
        IN KSPSTREAM_POINTER_MOTION Motion\
        );\
    STDMETHODIMP_(void) AdvanceUnlockedStreamPointer(\
        IN PKSPSTREAM_POINTER StreamPointer\
        );\
    STDMETHODIMP_(PKSPSTREAM_POINTER) GetLeadingStreamPointer(\
        IN KSSTREAM_POINTER_STATE State\
        );\
    STDMETHODIMP_(PKSPSTREAM_POINTER) GetTrailingStreamPointer(\
        IN KSSTREAM_POINTER_STATE State\
        );\
    STDMETHODIMP_(void) ScheduleTimeout(\
        IN PKSPSTREAM_POINTER StreamPointer,\
        IN PFNKSSTREAMPOINTER Callback,\
        IN LONGLONG Interval\
        );\
    STDMETHODIMP_(void) CancelTimeout(\
        IN PKSPSTREAM_POINTER StreamPointer\
        );\
    STDMETHODIMP_(PKSPSTREAM_POINTER) GetFirstClone(\
        void\
        );\
    STDMETHODIMP_(PKSPSTREAM_POINTER) GetNextClone(\
        IN PKSPSTREAM_POINTER StreamPointer\
        );\
    STDMETHODIMP_(void) GetAvailableByteCount(\
        OUT PLONG InputDataBytes OPTIONAL,\
        OUT PLONG OutputBufferBytes OPTIONAL\
        );\
    STDMETHODIMP_(void) UpdateByteAvailability(\
        IN PKSPSTREAM_POINTER streamPointer,\
        IN ULONG InUsed,\
        IN ULONG OutUsed\
        );\
    STDMETHODIMP_(NTSTATUS) SetStreamPointerStatusCode(\
        IN PKSPSTREAM_POINTER StreamPointer,\
        IN NTSTATUS Status\
        );\
    STDMETHODIMP_(void) RegisterFrameDismissalCallback(\
        IN PFNKSFRAMEDISMISSALCALLBACK FrameDismissalCallback,\
        IN PVOID FrameDismissalContext\
        );\
    STDMETHODIMP_(BOOLEAN) GeneratesMappings(\
        );\
    STDMETHODIMP_(void) CopyFrame(\
        IN PKSPSTREAM_POINTER sourcePointer\
        )

#undef INTERFACE
#define INTERFACE IKsSplitter
DECLARE_INTERFACE_(IKsSplitter,IKsTransport)
{
    STDMETHOD_(NTSTATUS, AddBranch)(THIS_
        IN PKSPIN Pin,
        IN const KSALLOCATOR_FRAMING_EX* AllocatorFraming OPTIONAL
        ) PURE;
};
#undef INTERFACE

#define IMP_IKsSplitter\
    IMP_IKsTransport;\
    STDMETHODIMP_(NTSTATUS) AddBranch(\
        IN PKSPIN Pin,\
        IN const KSALLOCATOR_FRAMING_EX* AllocatorFraming OPTIONAL\
        )

//
// IKsControl is defined in ks.h.
//
#define IMP_IKsControl\
    STDMETHODIMP_(NTSTATUS)\
    KsProperty(\
        IN PKSPROPERTY Property,\
        IN ULONG PropertyLength,\
        IN OUT LPVOID PropertyData,\
        IN ULONG DataLength,\
        OUT ULONG* BytesReturned\
        );\
    STDMETHODIMP_(NTSTATUS)\
    KsMethod(\
        IN PKSMETHOD Method,\
        IN ULONG MethodLength,\
        IN OUT LPVOID MethodData,\
        IN ULONG DataLength,\
        OUT ULONG* BytesReturned\
        );\
    STDMETHODIMP_(NTSTATUS)\
    KsEvent(\
        IN PKSEVENT Event OPTIONAL,\
        IN ULONG EventLength,\
        IN OUT LPVOID EventData,\
        IN ULONG DataLength,\
        OUT ULONG* BytesReturned\
        )

//
// IKsReferenceClock is defined in ks.h.
//
#define IMP_IKsReferenceClock\
    STDMETHODIMP_(LONGLONG)\
    GetTime(\
        void\
        );\
    STDMETHODIMP_(LONGLONG)\
    GetPhysicalTime(\
        void\
        );\
    STDMETHODIMP_(LONGLONG)\
    GetCorrelatedTime(\
        OUT PLONGLONG SystemTime\
        );\
    STDMETHODIMP_(LONGLONG)\
    GetCorrelatedPhysicalTime(\
        OUT PLONGLONG SystemTime\
        );\
    STDMETHODIMP_(NTSTATUS)\
    GetResolution(\
        OUT PKSRESOLUTION Resolution\
        );\
    STDMETHODIMP_(NTSTATUS)\
    GetState(\
        OUT PKSSTATE State\
        )

// WRM: Reevaluation
#undef INTERFACE
#define INTERFACE IKsReevaluate
DECLARE_INTERFACE_(IKsReevaluate, IUnknown) 
{
    //
    // Reevaluate is the method by which KsReevaluateObject will call into
    // the appropriate object and request reevaluation.  The reevaluator
    // will be responsible for reevaluating the associated build structures
    // (descriptors, etc...).  It will also pass down to any children
    // information which the children get from the parent on initialization
    // through ReevaluateCalldown on the child list.
    //

    STDMETHOD (Reevaluate)(THIS) PURE;

    //
    // Objects are responsible for knowing what the parameters to 
    // ReevaluateCalldown are.
    //

    STDMETHOD (ReevaluateCalldown) (THIS_
        IN ULONG ArgumentCount,
        ...
        ) PURE;

};
#undef INTERFACE

#define IMP_IKsReevaluate \
    STDMETHODIMP Reevaluate(); \
    STDMETHODIMP ReevaluateCalldown ( \
        IN ULONG ArgumentCount, \
        ... \
    );

struct _KSPPROCESSPIN {
    //
    // This first part is just like KSPROCESSPIN except that all the
    // PKSPROCESSPINs are replaced with PKSPPROCESSPINs.
    //
    PKSPIN Pin;
    PKSSTREAM_POINTER StreamPointer;
    PKSPPROCESSPIN InPlaceCounterpart;
    PKSPPROCESSPIN DelegateBranch;
    PKSPPROCESSPIN CopySource;
    PVOID Data;
    ULONG BytesAvailable;
    ULONG BytesUsed;
    ULONG Flags;
    BOOLEAN Terminate;
    //
    // The remainder is not in the public KSPROCESSPIN.
    //
    PKSPPROCESSPIPESECTION PipeSection;
    PKSPPROCESSPIN Next;
    HANDLE PipeId;
    PFILE_OBJECT AllocatorFileObject;
    PFNKSPINFRAMERETURN RetireFrameCallback;
    PFNKSPINIRPCOMPLETION IrpCompletionCallback;
    PKSGATE FrameGate;
    BOOLEAN FrameGateIsOr;
    PKSGATE StateGate;
};

BOOLEAN __inline
ProcessPinIsFrameSource(
    IN PKSPPROCESSPIN ProcessPin
    )
{
    return
        ProcessPin->AllocatorFileObject || 
        ProcessPin->RetireFrameCallback ||
        ((ProcessPin->Pin->Communication == KSPIN_COMMUNICATION_SINK) && 
         ProcessPin->Pin->ConnectionIsExternal);
}

struct _KSPPROCESSPIN_INDEXENTRY {
    PKSPPROCESSPIN *Pins;
    ULONG Count;
};

struct _KSPPROCESSPIPESECTION {
    LIST_ENTRY ListEntry;
    PIKSPIPESECTION PipeSection;
    PKSPPROCESSPIN Inputs;
    PKSPPROCESSPIN Outputs;
    LIST_ENTRY CopyDestinations;
    PIKSREQUESTOR Requestor;
    PIKSQUEUE Queue;
    PKSPSTREAM_POINTER StreamPointer;
    ULONG CopyPinId;
    BOOLEAN RequiredForProcessing;
};

typedef struct _KSDEVICE_EXT {
    LIST_ENTRY ChildList;
    LIST_ENTRY SiblingListEntry;
    PLIST_ENTRY SiblingListHead;
    PVOID Parent;
    KSOBJECTTYPE ObjectType;
    PIKSDEVICE Interface;
    PUNKNOWN AggregatedClientUnknown;
    PIKSDEVICE Device;
    PIKSREEVALUATE Reevaluator;
    PKMUTEX FilterControlMutex; // Not used
    const KSAUTOMATION_TABLE* AutomationTable; // Not used
    INTERLOCKEDLIST_HEAD EventList; // Not used

    KSDEVICE Public;
} KSDEVICE_EXT, *PKSDEVICE_EXT;

typedef struct _KSFILTERFACTORY_EXT {
    LIST_ENTRY ChildList;
    LIST_ENTRY SiblingListEntry;
    PLIST_ENTRY SiblingListHead;
    PKSDEVICE_EXT Parent;
    KSOBJECTTYPE ObjectType;
    PIKSFILTERFACTORY Interface;
    PUNKNOWN AggregatedClientUnknown;
    PIKSDEVICE Device;
    PIKSREEVALUATE Reevaluator;
    PKMUTEX FilterControlMutex; // Not used
    const KSAUTOMATION_TABLE* AutomationTable; // Not used
    INTERLOCKEDLIST_HEAD EventList; // Not used

    KSFILTERFACTORY Public;
} KSFILTERFACTORY_EXT, *PKSFILTERFACTORY_EXT;

typedef struct _KSFILTER_EXT {
    LIST_ENTRY ChildList;
    LIST_ENTRY SiblingListEntry;
    PLIST_ENTRY SiblingListHead;
    PKSFILTERFACTORY_EXT Parent;
    KSOBJECTTYPE ObjectType;
    PIKSFILTER Interface;
    PUNKNOWN AggregatedClientUnknown;
    PIKSDEVICE Device;
    PIKSREEVALUATE Reevaluator;
    PKMUTEX FilterControlMutex;
    const KSAUTOMATION_TABLE* AutomationTable;
    INTERLOCKEDLIST_HEAD EventList;

    KSFILTER Public;
} KSFILTER_EXT, *PKSFILTER_EXT;

#define KspFilterInterface(Filter)\
    CONTAINING_RECORD((Filter),KSFILTER_EXT,Public)->Interface

typedef struct _KSPIN_EXT {
    LIST_ENTRY ChildList;
    LIST_ENTRY SiblingListEntry;
    PLIST_ENTRY SiblingListHead;
    PKSFILTER_EXT Parent;
    KSOBJECTTYPE ObjectType;
    PIKSPIN Interface;
    PUNKNOWN AggregatedClientUnknown;
    PIKSDEVICE Device;
    PIKSREEVALUATE Reevaluator;
    PKMUTEX FilterControlMutex;
    const KSAUTOMATION_TABLE* AutomationTable;
    INTERLOCKEDLIST_HEAD EventList;

    KSPIN Public;
    PKSPPROCESSPIN ProcessPin;
    PVOID Reserved;
} KSPIN_EXT, *PKSPIN_EXT;

#define KspPinInterface(Pin)\
    CONTAINING_RECORD((Pin),KSPIN_EXT,Public)->Interface

#define STATIC_IKsTransport 0x3ef6ee3f, 0xd41, 0x11d2, 0xbe, 0xda, 0x0, 0xc0, 0x4f, 0x8e, 0xf4, 0x57
DEFINE_GUID(IID_IKsTransport,
0x3ef6ee3f, 0xd41, 0x11d2, 0xbe, 0xda, 0x0, 0xc0, 0x4f, 0x8e, 0xf4, 0x57);
#if defined(__cplusplus) && _MSC_VER >= 1100
struct __declspec(uuid("3EF6EE3F-0D41-11d2-BEDA-00C04F8EF457")) IKsTransport;
#endif
#define STATIC_IKsPowerNotify 0x3ef6ee47, 0xd41, 0x11d2, 0xbe, 0xda, 0x0, 0xc0, 0x4f, 0x8e, 0xf4, 0x57
DEFINE_GUID(IID_IKsPowerNotify,
0x3ef6ee47, 0xd41, 0x11d2, 0xbe, 0xda, 0x0, 0xc0, 0x4f, 0x8e, 0xf4, 0x57);
#if defined(__cplusplus) && _MSC_VER >= 1100
struct __declspec(uuid("3EF6EE47-0D41-11d2-BEDA-00C04F8EF457")) IKsPowerNotify;
#endif
#define STATIC_IKsProcessingObject 0x3ef6ee40, 0xd41, 0x11d2, 0xbe, 0xda, 0x0, 0xc0, 0x4f, 0x8e, 0xf4, 0x57
DEFINE_GUID(IID_IKsProcessingObject,
0x3ef6ee40, 0xd41, 0x11d2, 0xbe, 0xda, 0x0, 0xc0, 0x4f, 0x8e, 0xf4, 0x57);
#if defined(__cplusplus) && _MSC_VER >= 1100
struct __declspec(uuid("3EF6EE40-0D41-11d2-BEDA-00C04F8EF457")) IKsProcessingObject;
#endif
#define STATIC_IKsConnection 0x3ef6ee41, 0xd41, 0x11d2, 0xbe, 0xda, 0x0, 0xc0, 0x4f, 0x8e, 0xf4, 0x57
DEFINE_GUID(IID_IKsConnection,
0x3ef6ee41, 0xd41, 0x11d2, 0xbe, 0xda, 0x0, 0xc0, 0x4f, 0x8e, 0xf4, 0x57);
#if defined(__cplusplus) && _MSC_VER >= 1100
struct __declspec(uuid("3EF6EE41-0D41-11d2-BEDA-00C04F8EF457")) IKsConnection;
#endif
#define STATIC_IKsDevice 0x3ef6ee42, 0xd41, 0x11d2, 0xbe, 0xda, 0x0, 0xc0, 0x4f, 0x8e, 0xf4, 0x57
DEFINE_GUID(IID_IKsDevice,
0x3ef6ee42, 0xd41, 0x11d2, 0xbe, 0xda, 0x0, 0xc0, 0x4f, 0x8e, 0xf4, 0x57);
#if defined(__cplusplus) && _MSC_VER >= 1100
struct __declspec(uuid("3EF6EE42-0D41-11d2-BEDA-00C04F8EF457")) IKsDevice;
#endif
#define STATIC_IKsFilterFactory 0x3ef6ee43, 0xd41, 0x11d2, 0xbe, 0xda, 0x0, 0xc0, 0x4f, 0x8e, 0xf4, 0x57
DEFINE_GUID(IID_IKsFilterFactory,
0x3ef6ee43, 0xd41, 0x11d2, 0xbe, 0xda, 0x0, 0xc0, 0x4f, 0x8e, 0xf4, 0x57);
#if defined(__cplusplus) && _MSC_VER >= 1100
struct __declspec(uuid("3EF6EE43-0D41-11d2-BEDA-00C04F8EF457")) IKsFilterFactory;
#endif
#define STATIC_IKsFilter 0x3ef6ee44, 0xd41, 0x11d2, 0xbe, 0xda, 0x0, 0xc0, 0x4f, 0x8e, 0xf4, 0x57
DEFINE_GUID(IID_IKsFilter,
0x3ef6ee44, 0xd41, 0x11d2, 0xbe, 0xda, 0x0, 0xc0, 0x4f, 0x8e, 0xf4, 0x57);
#if defined(__cplusplus) && _MSC_VER >= 1100
struct __declspec(uuid("3EF6EE44-0D41-11d2-BEDA-00C04F8EF457")) IKsFilter;
#endif
#define STATIC_IKsPin 0x3ef6ee45, 0xd41, 0x11d2, 0xbe, 0xda, 0x0, 0xc0, 0x4f, 0x8e, 0xf4, 0x57
DEFINE_GUID(IID_IKsPin,
0x3ef6ee45, 0xd41, 0x11d2, 0xbe, 0xda, 0x0, 0xc0, 0x4f, 0x8e, 0xf4, 0x57);
#if defined(__cplusplus) && _MSC_VER >= 1100
struct __declspec(uuid("3EF6EE45-0D41-11d2-BEDA-00C04F8EF457")) IKsPin;
#endif
#define STATIC_IKsPipeSection 0x3ef6ee49, 0xd41, 0x11d2, 0xbe, 0xda, 0x0, 0xc0, 0x4f, 0x8e, 0xf4, 0x57
DEFINE_GUID(IID_IKsPipeSection,
0x3ef6ee49, 0xd41, 0x11d2, 0xbe, 0xda, 0x0, 0xc0, 0x4f, 0x8e, 0xf4, 0x57);
#if defined(__cplusplus) && _MSC_VER >= 1100
struct __declspec(uuid("3EF6EE49-0D41-11d2-BEDA-00C04F8EF457")) IKsPipeSection;
#endif
#define STATIC_IKsQueue 0x3ef6ee4a, 0xd41, 0x11d2, 0xbe, 0xda, 0x0, 0xc0, 0x4f, 0x8e, 0xf4, 0x57
DEFINE_GUID(IID_IKsQueue,
0x3ef6ee4a, 0xd41, 0x11d2, 0xbe, 0xda, 0x0, 0xc0, 0x4f, 0x8e, 0xf4, 0x57);
#if defined(__cplusplus) && _MSC_VER >= 1100
struct __declspec(uuid("3EF6EE4A-0D41-11d2-BEDA-00C04F8EF457")) IKsQueue;
#endif
#define STATIC_IKsSplitter 0x3ef6ee4b, 0xd41, 0x11d2, 0xbe, 0xda, 0x0, 0xc0, 0x4f, 0x8e, 0xf4, 0x57
DEFINE_GUID(IID_IKsSplitter,
0x3ef6ee4b, 0xd41, 0x11d2, 0xbe, 0xda, 0x0, 0xc0, 0x4f, 0x8e, 0xf4, 0x57);
#if defined(__cplusplus) && _MSC_VER >= 1100
struct __declspec(uuid("3EF6EE4B-0D41-11d2-BEDA-00C04F8EF457")) IKsSplitter;
#endif
#define STATIC_IKsWorkSink 0x3ef6ee4f, 0xd41, 0x11d2, 0xbe, 0xda, 0x0, 0xc0, 0x4f, 0x8e, 0xf4, 0x57
DEFINE_GUID(IID_IKsWorkSink,
0x3ef6ee4f, 0xd41, 0x11d2, 0xbe, 0xda, 0x0, 0xc0, 0x4f, 0x8e, 0xf4, 0x57);
#if defined(__cplusplus) && _MSC_VER >= 1100
struct __declspec(uuid("3EF6EE4F-0D41-11d2-BEDA-00C04F8EF457")) IKsWorkSink;
#endif
#define STATIC_IKsRetireFrame 0x3ef6ee46, 0xd41, 0x11d2, 0xbe, 0xda, 0x0, 0xc0, 0x4f, 0x8e, 0xf4, 0x57
DEFINE_GUID(IID_IKsRetireFrame,
0x3ef6ee46, 0xd41, 0x11d2, 0xbe, 0xda, 0x0, 0xc0, 0x4f, 0x8e, 0xf4, 0x57);
#if defined(__cplusplus) && _MSC_VER >= 1100
struct __declspec(uuid("3EF6EE46-0D41-11d2-BEDA-00C04F8EF457")) IKsRetireFrame;
#endif
#define STATIC_IKsIrpCompletion 0x52498bc8, 0x91ff, 0x4cc7, 0xb2, 0x89, 0xd2, 0xbf, 0xa9, 0x9, 0x90, 0x47
DEFINE_GUID(IID_IKsIrpCompletion,
0x52498bc8, 0x91ff, 0x4cc7, 0xb2, 0x89, 0xd2, 0xbf, 0xa9, 0x9, 0x90, 0x47);
#if defined(__cplusplus) && _MSC_VER >= 1100
struct __declspec(uuid("52498BC8-91FF-4cc7-B289-D2BFA9099047")) IKsIrpCompletion;
#endif

#define STATIC_KSPROPSETID_Frame 0xa60d8368, 0x5324, 0x4893, 0xb0, 0x20, 0xc4, 0x31, 0xa5, 0xb, 0xcb, 0xe3

typedef enum {
    KSPROPERTY_FRAME_HOLDING = 0
} KSPROPERTY_FRAME;

#define POOLTAG_FSCONTEXT 'cfSK'
#define POOLTAG_DEVICE 'edSK'
#define POOLTAG_FILTERFACTORY 'ffSK'
#define POOLTAG_FILTER 'ifSK'
#define POOLTAG_PINFACTORY 'fpSK'
#define POOLTAG_PIN 'npSK'
#define POOLTAG_PIPESECTION 'spSK'
#define POOLTAG_QUEUE 'uqSK'
#define POOLTAG_STREAMPOINTER 'psSK'
#define POOLTAG_NODE 'onSK'
#define POOLTAG_REQUESTOR 'gbSK'
#define POOLTAG_STREAMHEADER 'hsSK'
#define POOLTAG_PINFORMAT 'fpSK'
#define POOLTAG_ALLOCATORFRAMING 'faSK'
#define POOLTAG_CREATEITEMS 'icSK'
#define POOLTAG_AUTOMATION 'uaSK'
#define POOLTAG_AUTOMATIONTABLETABLE 'taSK'
#define POOLTAG_CLIENTFNS 'fcSK'
#define POOLTAG_DEVICEINTERFACE 'idSK'
#define POOLTAG_MAPPINGSTABLE 'tmSK'
#define POOLTAG_MAPPINGS 'amSK'
#define POOLTAG_PROCESSPINS 'ppSK'
#define POOLTAG_PROCESSPINSINDEX 'ipSK'
#define POOLTAG_SPLITTER 'psSK'
#define POOLTAG_SPLITTERBRANCH 'bsSK'
#define POOLTAG_FRAMEHEADER 'hfSK'
#define POOLTAG_PIPEPINLIST 'lpSK'
#define POOLTAG_DEVICEBAGENTRY 'ebSK'
#define POOLTAG_OBJECTBAGENTRY 'ebSK'
#define POOLTAG_DEVICEBAGHASHTABLE 'ebSK'
#define POOLTAG_OBJECTBAGHASHTABLE 'ebSK'
#define POOLTAG_FILEOBJECTTHUNK 'tfSK'
#define POOLTAG_TOPOLOGYCONNECTIONS 'ctSK'
#define POOLTAG_ACTIVATION 'caSK'
#define POOLTAG_OBJECTBAG 'boSK'

#define KSP_DEFAULT_REFERENCE_STRING L""

typedef struct {
    LIST_ENTRY ListEntry;
    const GUID *InterfaceClassGUID;
    UNICODE_STRING SymbolicLinkName;
} KSPDEVICECLASS, *PKSPDEVICECLASS;

#define DEFINE_FROMSTRUCT(CKsXxx,PKSXXX,m_ksXxx)\
    __inline\
    static\
    CKsXxx *\
    FromStruct(\
        IN PKSXXX Struct\
        );

#define IMPLEMENT_FROMSTRUCT(CKsXxx,PKSXXX,m_ksXxx)\
    CKsXxx *\
    CKsXxx::\
    FromStruct (\
        IN PKSXXX Struct\
        )\
    {\
        return CONTAINING_RECORD(Struct,CKsXxx,m_ksXxx);\
    }

#define KSP_BACKCONNECT KSPIN_DATAFLOW(0x80)
#define KSP_BACKCONNECT_IN KSPIN_DATAFLOW(KSPIN_DATAFLOW_IN | KSP_BACKCONNECT)
#define KSP_BACKCONNECT_OUT KSPIN_DATAFLOW(KSPIN_DATAFLOW_OUT | KSP_BACKCONNECT)

#define DEVICEBAGHASHTABLE_INITIALSIZE 32
#define OBJECTBAGHASHTABLE_INITIALSIZE 32
#define DEVICEBAGHASHTABLE_INITIALMASK (DEVICEBAGHASHTABLE_INITIALSIZE-1)
#define OBJECTBAGHASHTABLE_INITIALMASK (OBJECTBAGHASHTABLE_INITIALSIZE-1)
#define KspDeviceBagHash(b,x)\
    ((ULONG)(((ULONG_PTR(x) >> 13) ^ ULONG_PTR(x)) & b->HashMask))
#define KspObjectBagHash(b,x) KspDeviceBagHash(b,x)

struct _KSIOBJECTBAG
{
    PKSIDEVICEBAG DeviceBag;
    PLIST_ENTRY HashTable;
    ULONG HashTableEntryCount;
    ULONG HashMask;
    PKMUTEX Mutex;

    //
    // FULLMUTEX: In order to alleviate clients worrying about mutex twiddling,
    // the mutees are full.  If bags ever use mutexes other than control/device,
    // this must change.  MutexOrder == TRUE indicates that this mutex must
    // be taken before any MutexOrder == FALSE bag mutex.
    //
    BOOLEAN MutexOrder;
};

struct _KSIDEVICEBAG
{
    PLIST_ENTRY HashTable;
    ULONG HashTableEntryCount;
    ULONG HashMask;
    KMUTEX Mutex;
};

struct _KSIOBJECTBAG_ENTRY
{
    LIST_ENTRY ListEntry;
    PKSIDEVICEBAG_ENTRY DeviceBagEntry;
};

struct _KSIDEVICEBAG_ENTRY
{
    LIST_ENTRY ListEntry;
    PVOID Item;
    PFNKSFREE Free OPTIONAL;
    ULONG ReferenceCount;
};

NTSTATUS
KspCreateRequestor(
    OUT PIKSREQUESTOR* Requestor,
    IN PIKSPIPESECTION PipeSection,
    IN PIKSPIN Pin,
    IN PFILE_OBJECT AllocatorFileObject OPTIONAL,
    IN PIKSRETIREFRAME RetireFrame OPTIONAL,
    IN PIKSIRPCOMPLETION IrpCompletion OPTIONAL
    );

NTSTATUS
KspCreateSplitter(
    OUT PIKSSPLITTER* Splitter,
    IN PKSPIN Pin
    );

NTSTATUS
KspCreateFilterFactory(
    IN PKSDEVICE_EXT Parent,
    IN PLIST_ENTRY SiblingListHead,
    IN const KSFILTER_DESCRIPTOR* Descriptor,
    IN PWCHAR RefString OPTIONAL,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor OPTIONAL,
    IN ULONG CreateItemFlags,
    IN PFNKSFILTERFACTORYPOWER SleepCallback OPTIONAL,
    IN PFNKSFILTERFACTORYPOWER WakeCallback OPTIONAL,
    OUT PKSFILTERFACTORY* FilterFactory OPTIONAL
    );

NTSTATUS
KspCreateFilter(
    IN PIRP Irp,
    IN PKSFILTERFACTORY_EXT Parent,
    IN PLIST_ENTRY SiblingListHead,
    IN const KSFILTER_DESCRIPTOR* Descriptor,
    IN const KSAUTOMATION_TABLE* FilterAutomationTable,
    IN KSAUTOMATION_TABLE*const* PinAutomationTables,
    IN KSAUTOMATION_TABLE*const* NodeAutomationTables OPTIONAL,
    IN ULONG NodesCount
    );

NTSTATUS
KspCreatePin(
    IN PIRP Irp,
    IN PKSFILTER_EXT Parent,
    IN PLIST_ENTRY SiblingListHead,
    IN PKSPIN_CONNECT CreateParams,
    IN ULONG RequestSize,
    IN const KSPIN_DESCRIPTOR_EX* Descriptor,
    IN const KSAUTOMATION_TABLE* AutomationTable,
    IN KSAUTOMATION_TABLE*const* NodeAutomationTables OPTIONAL,
    IN ULONG NodesCount,
    IN PULONG FilterPinCount
    );

NTSTATUS
KspCreateQueue(
    OUT PIKSQUEUE* QueueTransport,
    IN ULONG Flags,
    IN PIKSPIPESECTION PipeSection,
    IN PIKSPROCESSINGOBJECT Filter,
    IN PKSPIN MasterPin,
    IN PKSGATE FrameGate OPTIONAL,
    IN BOOLEAN FrameGateIsOr,
    IN PKSGATE StateGate OPTIONAL,
    IN PIKSDEVICE Device,
    IN PDEVICE_OBJECT FunctionalDeviceObject,
    IN PADAPTER_OBJECT AdapterObject OPTIONAL,
    IN ULONG MaxMappingByteCount OPTIONAL,
    IN ULONG MappingTableStride OPTIONAL,
    IN BOOLEAN InputData,
    IN BOOLEAN OutputData
    );

NTSTATUS
KspCreatePipeSection(
    IN PVOID PipeId,
    IN PIKSPIN Pin,
    IN PIKSFILTER Filter,
    IN PIKSDEVICE Device
    );

NTSTATUS
KspCreateFileObjectThunk(
    OUT PUNKNOWN* Unknown,
    IN PFILE_OBJECT FileObject
    );

NTSTATUS
KspCreateAutomationTableTable(
    OUT PKSAUTOMATION_TABLE ** AutomationTableTable,
    IN ULONG DescriptorCount,
    IN ULONG DescriptorSize,
    IN const KSAUTOMATION_TABLE*const* DescriptorAutomationTables,
    IN const KSAUTOMATION_TABLE* BaseAutomationTable OPTIONAL,
    IN KSOBJECT_BAG Bag
    );

NTSTATUS
KspRegisterDeviceInterfaces(
    IN ULONG CategoriesCount,
    IN const GUID* Categories,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN PUNICODE_STRING RefString,
    OUT PLIST_ENTRY ListEntry
    );

NTSTATUS
KspSetDeviceInterfacesState(
    IN PLIST_ENTRY ListHead,
    IN BOOLEAN NewState
    );

void
KspFreeDeviceInterfaces(
    IN PLIST_ENTRY ListHead
    );

#if DBG
void
DbgPrintCircuit(
    IN PIKSTRANSPORT Transport,
    IN CCHAR Depth,
    IN CCHAR Direction
    );
#else
#define DbgPrintCircuit(t,d,dir)
#endif

NTSTATUS
KspPinPropertyHandler(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    IN OUT PVOID Data,
    IN ULONG DescriptorsCount,
    IN const KSPIN_DESCRIPTOR* Descriptor,
    IN ULONG DescriptorSize
    );

KSDDKAPI
NTSTATUS
NTAPI
KspValidateConnectRequest(
    IN PIRP Irp,
    IN ULONG DescriptorsCount,
    IN const KSPIN_DESCRIPTOR* Descriptor,
    IN ULONG DescriptorSize,
    OUT PKSPIN_CONNECT* Connect,
    OUT PULONG ConnectSize
    );

KSDDKAPI
NTSTATUS
NTAPI
KspValidateDataFormat(
    IN const KSPIN_DESCRIPTOR* Descriptor,
    IN PKSDATAFORMAT DataFormat,
    IN ULONG RequestSize,
    IN PFNVALIDATEDATAFORMAT ValidateCallback OPTIONAL,
    IN PVOID Context OPTIONAL
    );

KSDDKAPI
NTSTATUS
NTAPI
KspValidateTopologyNodeCreateRequest(
    IN PIRP Irp,
    IN ULONG TopologyNodesCount,
    OUT PKSNODE_CREATE* NodeCreate
    );

void
KspSetDeviceClassesState(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN NewState
    );

void
KspFreeDeviceClasses(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
KspCreate(
    IN PIRP Irp,
    IN ULONG CreateItemsCount,
    IN const KSOBJECT_CREATE_ITEM* CreateItems OPTIONAL,
    IN const KSDISPATCH_TABLE* DispatchTable,
    IN BOOLEAN RefParent,
    IN PKSPX_EXT Ext,
    IN PLIST_ENTRY SiblingListHead,
    IN PDEVICE_OBJECT TargetDevice
    );

NTSTATUS
KspClose(
    IN PIRP Irp,
    IN PKSPX_EXT Ext,
    IN BOOLEAN DerefParent
    );

NTSTATUS
KspDispatchClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

void
KspStandardConnect(
    IN PIKSTRANSPORT NewTransport OPTIONAL,
    OUT PIKSTRANSPORT *OldTransport OPTIONAL,
    OUT PIKSTRANSPORT *BranchTransport OPTIONAL,
    IN KSPIN_DATAFLOW DataFlow,
    IN PIKSTRANSPORT ThisTransport,
    IN PIKSTRANSPORT* SourceTransport,
    IN PIKSTRANSPORT* SinkTransport
    );

NTSTATUS
KspTransferKsIrp(
    IN PIKSTRANSPORT NewTransport,
    IN PIRP Irp
    );

void
KspDiscardKsIrp(
    IN PIKSTRANSPORT NewTransport,
    IN PIRP Irp
    );

void
KsWorkSinkItemWorker(
    IN PVOID Context
    );

NTSTATUS
KspInitializeDeviceBag(
    IN PKSIDEVICEBAG DeviceBag
    );

void
KspTerminateDeviceBag(
    IN PKSIDEVICEBAG DeviceBag
    );

ULONG
KspRemoveObjectBagEntry(
    IN PKSIOBJECTBAG ObjectBag,
    IN PKSIOBJECTBAG_ENTRY Entry,
    IN BOOLEAN Free
    );

void
KspTerminateObjectBag(
    IN PKSIOBJECTBAG ObjectBag
    );

PKSIDEVICEBAG_ENTRY
KspAcquireDeviceBagEntryForItem(
    IN PKSIDEVICEBAG DeviceBag,
    IN PVOID Item,
    IN PFNKSFREE Free OPTIONAL
    );

ULONG
KspReleaseDeviceBagEntry(
    IN PKSIDEVICEBAG DeviceBag,
    IN PKSIDEVICEBAG_ENTRY DeviceBagEntry,
    IN BOOLEAN Free
    );

PKSIOBJECTBAG_ENTRY
KspAddDeviceBagEntryToObjectBag(
    IN PKSIOBJECTBAG ObjectBag,
    IN PKSIDEVICEBAG_ENTRY DeviceBagEntry
    );

PKSIOBJECTBAG_ENTRY
KspFindObjectBagEntry(
    IN PKSIOBJECTBAG ObjectBag,
    IN PVOID Item
    );

#if DBG
BOOLEAN
KspIsDeviceMutexAcquired (
    IN PIKSDEVICE Device
    );
#endif // DBG

NTSTATUS
KspBuildFilterDataBlob (
    const KSFILTER_DESCRIPTOR *FilterDescriptor,
    OUT PUCHAR *FilterData,
    OUT PULONG FilterDataSize
    );

NTSTATUS
KspCacheAllFilterPinMediums (
    PUNICODE_STRING InterfaceString,
    const KSFILTER_DESCRIPTOR *FilterDescriptor
    );

#ifdef KS_ALLOCATION_TEST
#include <ksmemtst.h>
#endif // KS_ALLOCATION_TEST

typedef struct _KSLOG_ENTRY_CONTEXT
{
    ULONG_PTR Graph;
    ULONG_PTR Filter;
    ULONG_PTR Pin;
    ULONG_PTR Component;
} KSLOG_ENTRY_CONTEXT, *PKSLOG_ENTRY_CONTEXT;

typedef struct _KSLOG_ENTRY
{
    ULONG Size;
    ULONG Code;
    ULONGLONG Time;
    KSLOG_ENTRY_CONTEXT Context;
    ULONG_PTR Irp;
    ULONG_PTR Frame;
} KSLOG_ENTRY, *PKSLOG_ENTRY;

#define KSLOGCODE_VERB_MASK         0x00ff0000
#define KSLOGCODE_VERB_CREATE       0x00000000
#define KSLOGCODE_VERB_DESTROY      0x00010000
#define KSLOGCODE_VERB_SEND         0x00020000
#define KSLOGCODE_VERB_RECV         0x00030000

#define KSLOGCODE_NOUN_MASK         0xff000000
#define KSLOGCODE_NOUN_GRAPH        0x01000000
#define KSLOGCODE_NOUN_FILTER       0x02000000
#define KSLOGCODE_NOUN_PIN          0x03000000
#define KSLOGCODE_NOUN_QUEUE        0x04000000
#define KSLOGCODE_NOUN_REQUESTOR    0x05000000
#define KSLOGCODE_NOUN_SPLITTER     0x06000000
#define KSLOGCODE_NOUN_BRANCH       0x07000000
#define KSLOGCODE_NOUN_PIPESECTION  0x08000000

#define KSLOGCODE_TEXT              0x00000000
#define KSLOGCODE_KSSTART           0x00000001
#define KSLOGCODE_GRAPH_CREATE      (KSLOGCODE_NOUN_GRAPH|KSLOGCODE_VERB_CREATE)
#define KSLOGCODE_GRAPH_DESTROY     (KSLOGCODE_NOUN_GRAPH|KSLOGCODE_VERB_DESTROY)
#define KSLOGCODE_FILTER_CREATE     (KSLOGCODE_NOUN_FILTER|KSLOGCODE_VERB_CREATE)
#define KSLOGCODE_FILTER_DESTROY    (KSLOGCODE_NOUN_FILTER|KSLOGCODE_VERB_DESTROY)
#define KSLOGCODE_PIN_CREATE        (KSLOGCODE_NOUN_PIN|KSLOGCODE_VERB_CREATE)
#define KSLOGCODE_PIN_DESTROY       (KSLOGCODE_NOUN_PIN|KSLOGCODE_VERB_DESTROY)
#define KSLOGCODE_PIN_SEND          (KSLOGCODE_NOUN_PIN|KSLOGCODE_VERB_SEND)
#define KSLOGCODE_PIN_RECV          (KSLOGCODE_NOUN_PIN|KSLOGCODE_VERB_RECV)
#define KSLOGCODE_QUEUE_CREATE      (KSLOGCODE_NOUN_QUEUE|KSLOGCODE_VERB_CREATE)
#define KSLOGCODE_QUEUE_DESTROY     (KSLOGCODE_NOUN_QUEUE|KSLOGCODE_VERB_DESTROY)
#define KSLOGCODE_QUEUE_SEND        (KSLOGCODE_NOUN_QUEUE|KSLOGCODE_VERB_SEND)
#define KSLOGCODE_QUEUE_RECV        (KSLOGCODE_NOUN_QUEUE|KSLOGCODE_VERB_RECV)
#define KSLOGCODE_REQUESTOR_CREATE  (KSLOGCODE_NOUN_REQUESTOR|KSLOGCODE_VERB_CREATE)
#define KSLOGCODE_REQUESTOR_DESTROY (KSLOGCODE_NOUN_REQUESTOR|KSLOGCODE_VERB_DESTROY)
#define KSLOGCODE_REQUESTOR_SEND    (KSLOGCODE_NOUN_REQUESTOR|KSLOGCODE_VERB_SEND)
#define KSLOGCODE_REQUESTOR_RECV    (KSLOGCODE_NOUN_REQUESTOR|KSLOGCODE_VERB_RECV)
#define KSLOGCODE_SPLITTER_CREATE   (KSLOGCODE_NOUN_SPLITTER|KSLOGCODE_VERB_CREATE)
#define KSLOGCODE_SPLITTER_DESTROY  (KSLOGCODE_NOUN_SPLITTER|KSLOGCODE_VERB_DESTROY)
#define KSLOGCODE_SPLITTER_SEND     (KSLOGCODE_NOUN_SPLITTER|KSLOGCODE_VERB_SEND)
#define KSLOGCODE_SPLITTER_RECV     (KSLOGCODE_NOUN_SPLITTER|KSLOGCODE_VERB_RECV)
#define KSLOGCODE_BRANCH_CREATE     (KSLOGCODE_NOUN_BRANCH|KSLOGCODE_VERB_CREATE)
#define KSLOGCODE_BRANCH_DESTROY    (KSLOGCODE_NOUN_BRANCH|KSLOGCODE_VERB_DESTROY)
#define KSLOGCODE_BRANCH_SEND       (KSLOGCODE_NOUN_BRANCH|KSLOGCODE_VERB_SEND)
#define KSLOGCODE_BRANCH_RECV       (KSLOGCODE_NOUN_BRANCH|KSLOGCODE_VERB_RECV)
#define KSLOGCODE_PIPESECTION_CREATE    (KSLOGCODE_NOUN_PIPESECTION|KSLOGCODE_VERB_CREATE)
#define KSLOGCODE_PIPESECTION_DESTROY   (KSLOGCODE_NOUN_PIPESECTION|KSLOGCODE_VERB_DESTROY)

#if DBG

void
_KsLogInit(
    void
    );

void
_KsLogInitContext(
    OUT PKSLOG_ENTRY_CONTEXT Context,
    IN PKSPIN Pin OPTIONAL,
    IN PVOID Component OPTIONAL
    );

void
_KsLog(
    IN PKSLOG_ENTRY_CONTEXT Context OPTIONAL,
    IN ULONG Code,
    IN ULONG_PTR Irp,
    IN ULONG_PTR Frame,
    IN PKSLOG_ENTRY Entry
    );

PKSLOG_ENTRY
_KsLogEntry(
    IN ULONG ExtSize,
    IN PVOID Ext OPTIONAL
    );

PKSLOG_ENTRY
_KsLogEntryF(
    PCH Format,
    ...
    );

#define KsLogInit() \
    _KsLogInit()
#define DEFINE_LOG_CONTEXT(Context) \
    KSLOG_ENTRY_CONTEXT Context
#define KsLogInitContext(Context,Pin,Component) \
    _KsLogInitContext(Context,Pin,Component)
#define KsLogF(Context,Irp,Frame,Strings) \
    _KsLog(Context,KSLOGCODE_TEXT,(ULONG_PTR)Irp,(ULONG_PTR)Frame,_KsLogEntryF##Strings)
#define KsLog(Context,Code,Irp,Frame) \
    _KsLog(Context,Code,(ULONG_PTR)Irp,(ULONG_PTR)Frame,_KsLogEntry(0,NULL))

#else // !DBG

#define KsLogInit()
#define DEFINE_LOG_CONTEXT(Context)
#define KsLogInitContext(Context,Pin,Component)
#define KsLogF(Context,Irp,Frame,Strings)
#define KsLog(Context,Code,Irp,Frame)

#endif // !DBG

// johnlee this is the only switch to turn on (1) or off (0) ks PerfLog
#define KSPERFLOG_DRIVER 0
#include "ksperflog.h"

// johnlee this is the only switch to turn on WMI
#define ENABLE_KSWMI 0
#include "kswmi.h"

#ifdef __cplusplus
}
#endif // __cplusplus

#define DEBUGLVL_LIFETIME DEBUGLVL_VERBOSE
#define DEBUGLVL_METRICS DEBUGLVL_VERBOSE
#define DEBUGLVL_PIPES DEBUGLVL_VERBOSE
#define DEBUGLVL_FLOWEXCEPTIONS DEBUGLVL_VERBOSE
#define DEBUGLVL_CANCEL DEBUGLVL_VERBOSE
#define DEBUGLVL_EVENTS DEBUGLVL_VERBOSE
#define DEBUGLVL_DEVICESTATE DEBUGLVL_VERBOSE
#define DEBUGLVL_ALLOCATORS DEBUGLVL_VERBOSE
#define DEBUGLVL_INTERROGATION DEBUGLVL_VERBOSE
#define DEBUGLVL_CLOCKS DEBUGLVL_VERBOSE
#define DEBUGLVL_CONFIG DEBUGLVL_VERBOSE
#define DEBUGLVL_PROCESSINGCONTROL DEBUGLVL_VERBOSE
#define DEBUGLVL_PROCESSINGCONTROL_BLAB DEBUGLVL_BLAB
#define DEBUGLVL_POWER DEBUGLVL_VERBOSE

#endif // _KSP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\ks\ksperflog.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 2000

Module Name:

    ksperflog.h

Abstract:

    Internal header file for KS.

--*/

#ifndef _KSPERFLOG_H_
#define _KSPERFLOG_H_

//
// commons for KSPERFLOG_DRIVER and KSPERFLOG_PARSER
//
//-----------------------------------------------------------------
// The following groups and log types must be unique in perfmacros.h
// These should be in that header file. BUt need to wait until 
// it is checked in.
// In boot.ini with intrumented ntoskrnl.exe, use options
//  /perfmem=x to allocate x MB of buffer
//  /perftraceflags=<group masks> 
//      e.g. /perftraceflags=0x40447820+0x41+0x8002 to turn on 
//          4044872 in group 0, 4 in group 1 and 800 in group 2.
//
#define KSPERFLOG_XFER_GROUP    0x00010002
#define KSPERFLOG_PNP_GROUP     0x00020002
#define KS2PERFLOG_XFER_GROUP   0x00040002
#define KS2PERFLOG_PNP_GROUP    0x00080002

//#define PERFINFO_LOG_TYPE_DSHOW_AUDIOBREAK               1618
// 1500-1999 for dshow
#define PERFINFO_LOG_TYPE_KS_RECEIVE_READ       1550
#define PERFINFO_LOG_TYPE_KS_RECEIVE_WRITE      1551
#define PERFINFO_LOG_TYPE_KS_COMPLETE_READ      1552
#define PERFINFO_LOG_TYPE_KS_COMPLETE_WRITE     1553
#define PERFINFO_LOG_TYPE_KS_DEVICE_DRIVER      1554

#define PERFINFO_LOG_TYPE_KS_START_DEVICE       1556
#define PERFINFO_LOG_TYPE_KS_PNP_DEVICE         1557
#define PERFINFO_LOG_TYPE_KS_POWER_DEVICE       1558

#define PERFINFO_LOG_TYPE_KS2_FRECEIVE_READ     1560
#define PERFINFO_LOG_TYPE_KS2_FRECEIVE_WRITE    1561
#define PERFINFO_LOG_TYPE_KS2_FCOMPLETE_READ    1562
#define PERFINFO_LOG_TYPE_KS2_FCOMPLETE_WRITE   1563

#define PERFINFO_LOG_TYPE_KS2_PRECEIVE_READ     1564
#define PERFINFO_LOG_TYPE_KS2_PRECEIVE_WRITE    1565
#define PERFINFO_LOG_TYPE_KS2_PCOMPLETE_READ    1566
#define PERFINFO_LOG_TYPE_KS2_PCOMPLETE_WRITE   1567

#define PERFINFO_LOG_TYPE_KS2_START_DEVICE      1570
#define PERFINFO_LOG_TYPE_KS2_PNP_DEVICE        1571
#define PERFINFO_LOG_TYPE_KS2_POWER_DEVICE      1572

#define MAX_PRINT 128

#if ( KSPERFLOG_DRIVER || KSPERFLOG_PARSER )
#define KSPERFLOG( s ) s
#define KSPERFLOGS( s ) { s }
#else 
#define KSPERFLOG( s )
#define KSPERFLOGS( s ) 
#endif

//-----------------------------------------------------------------

//KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK
// include for ring0 driver logging. the counter part to parse
// logged records is KSPERFLOG_PARSER
//

#if KSPERFLOG_DRIVER

#define INITGUID
#include "stdarg.h"

#define PERFMACROS_DRIVER
#define PERFINFO_DDKDRIVERHACK
#define NTPERF

#include <perfinfokrn.h>

#define KSPERFLOG_SET_ON() \
    ( PerfBufHdr() && \
      (PerfBufHdr()->GlobalGroupMask.masks[PERF_GET_MASK_INDEX(KSPERFLOG_XFER_GROUP)] |=\
       KSPERFLOG_XFER_GROUP)\
    )

//ks---------------------------------------------------------------
// perfmacros.h defines PERF_MASK_TIMESTAMP close to GROUP.
// one would think it's a flag in group. But it is used with Tag.
//
void
__inline
KSPERFLOG_RECEIVE_READ( 
    PDEVICE_OBJECT pDeviceObject,
    PIRP pIrp,
    ULONG TotalBuffer ) 
{
    PerfkLog4Dwords( KSPERFLOG_XFER_GROUP,\
                     PERFINFO_LOG_TYPE_KS_RECEIVE_READ | PERF_MASK_TIMESTAMP,
                     KeGetCurrentIrql()<= DISPATCH_LEVEL ? KeGetCurrentThread():NULL,
                     pDeviceObject,
                     pIrp,
                     TotalBuffer);
}

void
__inline
KSPERFLOG_RECEIVE_WRITE( 
    PDEVICE_OBJECT pDeviceObject, 
    PIRP pIrp,
    ULONG TimeStampMs,
    ULONG TotalData ) 
{
    PerfkLog5Dwords( KSPERFLOG_XFER_GROUP,
                     PERFINFO_LOG_TYPE_KS_RECEIVE_WRITE | PERF_MASK_TIMESTAMP,
                     KeGetCurrentIrql()<= DISPATCH_LEVEL ? KeGetCurrentThread():NULL,
                     pDeviceObject,
                     pIrp,
                     TimeStampMs,
                     TotalData);
}


void
__inline
KSPERFLOG_START_DEVICE( 
    PDEVICE_OBJECT pDeviceObject,
    PIRP pIrp ) 
{
    int     cb;
    struct _DEVICE_DRIVER_INFO {
        PDEVICE_OBJECT pDeviceObject;
        PIRP           pIrp;
        PDRIVER_OBJECT pDriverObject;
        char pb[MAX_PRINT];
    } DeviceDriverInfo;

    DeviceDriverInfo.pDeviceObject= pDeviceObject;
    DeviceDriverInfo.pIrp = pIrp;
    DeviceDriverInfo.pDriverObject = pDeviceObject->DriverObject;
    if ( DeviceDriverInfo.pDriverObject->DriverName.Length == 0 ) {
        cb = 0;  
    }
    else {
        cb = _snprintf( DeviceDriverInfo.pb, 
                         MAX_PRINT, 
                         "%S", 
                         DeviceDriverInfo.pDriverObject->DriverName.Buffer );
    }
    PerfkLogBytes(
        KSPERFLOG_XFER_GROUP,
        PERFINFO_LOG_TYPE_KS_DEVICE_DRIVER | PERF_MASK_TIMESTAMP,
        (PBYTE)&DeviceDriverInfo,
        sizeof(DeviceDriverInfo) - (MAX_PRINT-cb));
}

void
__inline
KSPERFLOG_PNP_DEVICE( 
    PDEVICE_OBJECT pDeviceObject,
    PIRP pIrp,
    char MinorFunction ) 
{
    if ( MinorFunction == IRP_MN_START_DEVICE ) {
        KSPERFLOG_START_DEVICE( pDeviceObject, pIrp );
    }
    else {
        PerfkLog3Dwords( KSPERFLOG_XFER_GROUP,
                     PERFINFO_LOG_TYPE_KS_PNP_DEVICE | PERF_MASK_TIMESTAMP,
                     pDeviceObject,
                     pIrp,
                     (ULONG)MinorFunction );
    }
}   

    
//ks2--------------------------------------------------------------------------
void
__inline
KS2PERFLOG_FRECEIVE_READ( 
    PDEVICE_OBJECT pDeviceObject,
    PIRP pIrp,
    ULONG TotalBuffer ) 
{
    PerfkLog4Dwords( KSPERFLOG_XFER_GROUP,\
                     PERFINFO_LOG_TYPE_KS2_FRECEIVE_READ | PERF_MASK_TIMESTAMP,
                     KeGetCurrentIrql()<= DISPATCH_LEVEL ? KeGetCurrentThread():NULL,
                     pDeviceObject,
                     pIrp,
                     TotalBuffer);
}

void
__inline
KS2PERFLOG_FRECEIVE_WRITE( 
    PDEVICE_OBJECT pDeviceObject, 
    PIRP pIrp,
    ULONG TimeStampMs,
    ULONG TotalData ) 
{
    PerfkLog5Dwords( KSPERFLOG_XFER_GROUP,
                     PERFINFO_LOG_TYPE_KS2_FRECEIVE_WRITE | PERF_MASK_TIMESTAMP,
                     KeGetCurrentIrql()<= DISPATCH_LEVEL ? KeGetCurrentThread():NULL,
                     pDeviceObject,
                     pIrp,
                     TimeStampMs,
                     TotalData);
}

void
__inline
KS2PERFLOG_PRECEIVE_READ( 
    PDEVICE_OBJECT pDeviceObject,
    PIRP pIrp,
    ULONG TotalBuffer ) 
{
    PerfkLog4Dwords( KSPERFLOG_XFER_GROUP,\
                     PERFINFO_LOG_TYPE_KS2_PRECEIVE_READ | PERF_MASK_TIMESTAMP,
                     KeGetCurrentIrql()<= DISPATCH_LEVEL ? KeGetCurrentThread():NULL,
                     pDeviceObject,
                     pIrp,
                     TotalBuffer);
}

void
__inline
KS2PERFLOG_PRECEIVE_WRITE( 
    PDEVICE_OBJECT pDeviceObject, 
    PIRP pIrp,
    ULONG TimeStampMs,
    ULONG TotalData ) 
{
    PerfkLog5Dwords( KSPERFLOG_XFER_GROUP,
                     PERFINFO_LOG_TYPE_KS2_PRECEIVE_WRITE | PERF_MASK_TIMESTAMP,
                     KeGetCurrentIrql()<= DISPATCH_LEVEL ? KeGetCurrentThread():NULL,
                     pDeviceObject,
                     pIrp,
                     TimeStampMs,
                     TotalData);
}


void
__inline
KS2PERFLOG_START_DEVICE( 
    PDEVICE_OBJECT pDeviceObject,
    PIRP pIrp ) 
{
    int     cb;
    struct _DEVICE_DRIVER_INFO {
    	PKTHREAD	   pKThread;
        PDEVICE_OBJECT pDeviceObject;
        PIRP           pIrp;
        PDRIVER_OBJECT pDriverObject;
        char pb[MAX_PRINT];
    } DeviceDriverInfo;

	DeviceDriverInfo.pKThread=
			KeGetCurrentIrql()<= DISPATCH_LEVEL ? KeGetCurrentThread():NULL;
    DeviceDriverInfo.pDeviceObject= pDeviceObject;
    DeviceDriverInfo.pIrp = pIrp;
    DeviceDriverInfo.pDriverObject = pDeviceObject->DriverObject;
    if ( DeviceDriverInfo.pDriverObject->DriverName.Length == 0 ) {
        cb = 0;  
    }
    else {
        cb = _snprintf( DeviceDriverInfo.pb,
                         MAX_PRINT,
                         "%S", 
                         DeviceDriverInfo.pDriverObject->DriverName.Buffer );
    }
    PerfkLogBytes(
        KSPERFLOG_XFER_GROUP,
        PERFINFO_LOG_TYPE_KS_DEVICE_DRIVER | PERF_MASK_TIMESTAMP,
        (PBYTE)&DeviceDriverInfo,
        sizeof(DeviceDriverInfo) - (MAX_PRINT-cb));
}

void
__inline
KS2PERFLOG_PNP_DEVICE( 
    PDEVICE_OBJECT pDeviceObject,
    PIRP pIrp,
    char MinorFunction ) 
{
    if ( MinorFunction == IRP_MN_START_DEVICE ) {
        KS2PERFLOG_START_DEVICE( pDeviceObject, pIrp );
    }
    else {
        PerfkLog4Dwords( KSPERFLOG_XFER_GROUP,
                         PERFINFO_LOG_TYPE_KS2_PNP_DEVICE | PERF_MASK_TIMESTAMP,
                         KeGetCurrentIrql()<= DISPATCH_LEVEL ? KeGetCurrentThread():NULL,
                         pDeviceObject,
                         pIrp,
                         (ULONG)MinorFunction );
    }                         
}

#endif 
// end include for KSPERFLOG_DRIVER 
//kkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkk

//UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU
//
// include for ring3 parser to decode records logged by ring0 driver
//
#if KSPERFLOG_PARSER

#endif 
// end include for KSPERFLOG_PARSER
//uuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu



#endif // _KSPERFLOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\ks\method.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    method.c

Abstract:

    This module contains the helper functions for method sets, and
    method set handler code. These allow a device object to present a
    method set to a client, and allow the helper function to perform some
    of the basic parameter validation and routing based on a method set
    table.
--*/

#include "ksp.h"

#ifdef ALLOC_PRAGMA
const KSMETHOD_ITEM*
FASTCALL
FindMethodItem(
    IN const KSMETHOD_SET* MethodSet,
    IN ULONG MethodItemSize,
    IN ULONG MethodId
    );
const KSFASTMETHOD_ITEM*
FASTCALL
FindFastMethodItem(
    IN const KSMETHOD_SET* MethodSet,
    IN ULONG MethodId
    );

#pragma alloc_text(PAGE, FindMethodItem)
#pragma alloc_text(PAGE, KsMethodHandler)
#pragma alloc_text(PAGE, KsMethodHandlerWithAllocator)
#pragma alloc_text(PAGE, KspMethodHandler)
#pragma alloc_text(PAGE, FindFastMethodItem)
#pragma alloc_text(PAGE, KsFastMethodHandler)
#endif // ALLOC_PRAGMA


const KSMETHOD_ITEM*
FASTCALL
FindMethodItem(
    IN const KSMETHOD_SET* MethodSet,
    IN ULONG MethodItemSize,
    IN ULONG MethodId
    )
/*++

Routine Description:

    Given an method set structure locates the specified method item.

Arguments:

    MethodSet -
        Points to the method set to search.

    MethodItemSize -
        Contains the size of each Method item. This may be different
        than the standard method item size, since the items could be
        allocated on the fly, and contain context information.

    MethodId -
        Contains the method identifier to look for.

Return Value:

    Returns a pointer to the method identifier structure, or NULL if it could
    not be found.

--*/
{
    const KSMETHOD_ITEM* MethodItem;
    ULONG MethodsCount;

    MethodItem = MethodSet->MethodItem;
    for (MethodsCount = MethodSet->MethodsCount; 
        MethodsCount; 
        MethodsCount--, MethodItem = (const KSMETHOD_ITEM*)((PUCHAR)MethodItem + MethodItemSize)) {
        if (MethodId == MethodItem->MethodId) {
            return MethodItem;
        }
    }
    return NULL;
}


KSDDKAPI
NTSTATUS
NTAPI
KsMethodHandler(
    IN PIRP Irp,
    IN ULONG MethodSetsCount,
    IN const KSMETHOD_SET* MethodSet
    )
/*++

Routine Description:

    Handles method requests. Responds to all method identifiers defined
    by the sets. The owner of the method set may then perform pre- or
    post-filtering of the method handling. This function may only be
    called at PASSIVE_LEVEL.

Arguments:

    Irp -
        Contains the IRP with the method request being handled.

    MethodSetsCount -
        Indicates the number of method set structures being passed.

    MethodSet -
        Contains the pointer to the list of method set information.

Return Value:

    Returns STATUS_SUCCESS, else an error specific to the method being
    handled. Always sets the IO_STATUS_BLOCK.Information field of the
    PIRP.IoStatus element within the IRP, either through setting it to zero
    because of an internal error, or through a method handler setting it.
    It does not set the IO_STATUS_BLOCK.Status field, nor complete the IRP
    however.

--*/
{
    PAGED_CODE();
    return KspMethodHandler(Irp, MethodSetsCount, MethodSet, NULL, 0, NULL, 0);
}


KSDDKAPI
NTSTATUS
NTAPI
KsMethodHandlerWithAllocator(
    IN PIRP Irp,
    IN ULONG MethodSetsCount,
    IN const KSMETHOD_SET* MethodSet,
    IN PFNKSALLOCATOR Allocator OPTIONAL,
    IN ULONG MethodItemSize OPTIONAL
    )
/*++

Routine Description:

    Handles method requests. Responds to all method identifiers defined
    by the sets. The owner of the method set may then perform pre- or
    post-filtering of the method handling. This function may only be
    called at PASSIVE_LEVEL.

Arguments:

    Irp -
        Contains the IRP with the method request being handled.

    MethodSetsCount -
        Indicates the number of method set structures being passed.

    MethodSet -
        Contains the pointer to the list of method set information.

    Allocator -
        Optionally contains the callback with which a mapped buffer
        request will be made. If this is not provided, pool memory
        will be used. If specified, this is used to allocate memory
        for a method IRP using the callback. This can be used
        to allocate specific memory for method requests, such as
        mapped memory. Note that this assumes that method Irp's passed
        to a filter have not been manipulated before being sent. It is
        invalid to directly forward a method Irp.

    MethodItemSize -
        Optionally contains an alternate method item size to use when
        incrementing the current method item counter. If this is a
        non-zero value, it is assumed to contain the size of the increment,
        and directs the function to pass a pointer to the method item
        located in the DriverContext field accessed through the
        KSMETHOD_ITEM_IRP_STORAGE macro.

Return Value:

    Returns STATUS_SUCCESS, else an error specific to the method being
    handled. Always sets the IO_STATUS_BLOCK.Information field of the
    PIRP.IoStatus element within the IRP, either through setting it to zero
    because of an internal error, or through a method handler setting it.
    It does not set the IO_STATUS_BLOCK.Status field, nor complete the IRP
    however.

--*/
{
    PAGED_CODE();
    return KspMethodHandler(Irp, MethodSetsCount, MethodSet, Allocator, MethodItemSize, NULL, 0);
}


NTSTATUS
KspMethodHandler(
    IN PIRP Irp,
    IN ULONG MethodSetsCount,
    IN const KSMETHOD_SET* MethodSet,
    IN PFNKSALLOCATOR Allocator OPTIONAL,
    IN ULONG MethodItemSize OPTIONAL,
    IN const KSAUTOMATION_TABLE*const* NodeAutomationTables OPTIONAL,
    IN ULONG NodesCount
    )
/*++

Routine Description:

    Handles method requests. Responds to all method identifiers defined
    by the sets. The owner of the method set may then perform pre- or
    post-filtering of the method handling. This function may only be
    called at PASSIVE_LEVEL.

Arguments:

    Irp -
        Contains the IRP with the method request being handled.

    MethodSetsCount -
        Indicates the number of method set structures being passed.

    MethodSet -
        Contains the pointer to the list of method set information.

    Allocator -
        Optionally contains the callback with which a mapped buffer
        request will be made. If this is not provided, pool memory
        will be used. If specified, this is used to allocate memory
        for a method IRP using the callback. This can be used
        to allocate specific memory for method requests, such as
        mapped memory. Note that this assumes that method Irp's passed
        to a filter have not been manipulated before being sent. It is
        invalid to directly forward a method Irp.

    MethodItemSize -
        Optionally contains an alternate method item size to use when
        incrementing the current method item counter. If this is a
        non-zero value, it is assumed to contain the size of the increment,
        and directs the function to pass a pointer to the method item
        located in the DriverContext field accessed through the
        KSMETHOD_ITEM_IRP_STORAGE macro.

    NodeAutomationTables -
        Optional table of automation tables for nodes.

    NodesCount -
        Count of nodes.

Return Value:

    Returns STATUS_SUCCESS, else an error specific to the method being
    handled. Always sets the IO_STATUS_BLOCK.Information field of the
    PIRP.IoStatus element within the IRP, either through setting it to zero
    because of an internal error, or through a method handler setting it.
    It does not set the IO_STATUS_BLOCK.Status field, nor complete the IRP
    however.

--*/
{
    PIO_STACK_LOCATION IrpStack;
    ULONG InputBufferLength;
    ULONG OutputBufferLength;
    ULONG AlignedBufferLength;
    KSMETHOD LocalMethod;
    PVOID UserBuffer;
    PKSMETHOD Method;
    ULONG NodeId;
    ULONG LocalMethodItemSize;
    ULONG RemainingSetsCount;
    NTSTATUS Status;
    ULONG Flags;

    PAGED_CODE();
    //
    // Determine the offsets to both the Method and UserBuffer parameters based
    // on the lengths of the DeviceIoControl parameters. A single allocation is
    // used to buffer both parameters. The UserBuffer (or results on a support
    // query) is stored first, and the Method is stored second, on
    // FILE_QUAD_ALIGNMENT.
    //
    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    InputBufferLength = IrpStack->Parameters.DeviceIoControl.InputBufferLength;
    OutputBufferLength = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;
    AlignedBufferLength = (OutputBufferLength + FILE_QUAD_ALIGNMENT) & ~FILE_QUAD_ALIGNMENT;
    //
    // Determine if the parameters have already been buffered by a previous
    // call to this function.
    //
    if (!Irp->AssociatedIrp.SystemBuffer) {
        //
        // Initially just check for the minimal method parameter length. The
        // actual minimal length will be validated when the method item is found.
        // Also ensure that the output and input buffer lengths are not set so
        // large as to overflow when aligned or added.
        //
        if ((InputBufferLength < sizeof(*Method)) || (AlignedBufferLength < OutputBufferLength) || (AlignedBufferLength + InputBufferLength < AlignedBufferLength)) {
            return STATUS_INVALID_BUFFER_SIZE;
        }
        //
        // Retrieve a pointer to the method for use in searching for a handler.
        //
        if (Irp->RequestorMode != KernelMode) {
            try {
                //
                // Validate the pointer if the client is not trusted.
                //
                ProbeForRead(IrpStack->Parameters.DeviceIoControl.Type3InputBuffer, InputBufferLength, sizeof(BYTE));
                //
                // Get the flags and the node ID.
                //
                Flags = ((PKSMETHOD)IrpStack->Parameters.DeviceIoControl.Type3InputBuffer)->Flags;
                if ((Flags & KSMETHOD_TYPE_TOPOLOGY) && (InputBufferLength >= sizeof(KSM_NODE))) {
                    NodeId = ((PKSM_NODE)IrpStack->Parameters.DeviceIoControl.Type3InputBuffer)->NodeId;
                }
                //
                // Validate the flags.
                //
                switch (Flags & ~KSMETHOD_TYPE_TOPOLOGY) {
                    //
                    // Allow old flags.
                    //
                case KSMETHOD_TYPE_NONE:
                case KSMETHOD_TYPE_READ: //KSMETHOD_TYPE_SEND
                case KSMETHOD_TYPE_WRITE:
                case KSMETHOD_TYPE_MODIFY:
                case KSMETHOD_TYPE_NONE | KSMETHOD_TYPE_SOURCE:
                case KSMETHOD_TYPE_READ | KSMETHOD_TYPE_SOURCE:
                case KSMETHOD_TYPE_WRITE | KSMETHOD_TYPE_SOURCE:
                case KSMETHOD_TYPE_MODIFY | KSMETHOD_TYPE_SOURCE:
                    //
                    // Just copy the method for now to use in lookup, as the
                    // buffer cannot be set up yet.
                    //
                    LocalMethod = *(PKSMETHOD)IrpStack->Parameters.DeviceIoControl.Type3InputBuffer;
                    //
                    // Remove old flags.
                    //
                    LocalMethod.Flags = KSMETHOD_TYPE_SEND | (Flags & KSMETHOD_TYPE_TOPOLOGY);
                    Method = &LocalMethod;
                    break;
                case KSMETHOD_TYPE_SETSUPPORT:
                case KSMETHOD_TYPE_BASICSUPPORT:
                    if (Irp->RequestorMode != KernelMode) {
                        ProbeForWrite(Irp->UserBuffer, OutputBufferLength, sizeof(BYTE));
                    }
                    //
                    // The allocator is not used for support calls.
                    //
                    Irp->AssociatedIrp.SystemBuffer = ExAllocatePoolWithQuotaTag(NonPagedPool, AlignedBufferLength + InputBufferLength, 'ppSK');
                    Irp->Flags |= (IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER);
                    if (OutputBufferLength) {
                        Irp->Flags |= IRP_INPUT_OPERATION;
                    }
                    RtlCopyMemory(
                        (PUCHAR)Irp->AssociatedIrp.SystemBuffer + AlignedBufferLength,
                        IrpStack->Parameters.DeviceIoControl.Type3InputBuffer,
                        InputBufferLength);
                    Method = (PKSMETHOD)((PUCHAR)Irp->AssociatedIrp.SystemBuffer + AlignedBufferLength);
                    //
                    // Overwrite with previously captured flags.
                    //
                    Method->Flags = Flags;
                    //
                    // Store the flags so that an asynchronous operation can
                    // determine what type of buffering was used in the method.
                    // KsDispatchSpecificMethod uses this to determine where
                    // the Method parameter is.
                    //
                    KSMETHOD_TYPE_IRP_STORAGE(Irp) = Method->Flags;
                    break;
                default:
                    return STATUS_INVALID_PARAMETER;
                }
            } except (EXCEPTION_EXECUTE_HANDLER) {
                return GetExceptionCode();
            }
        } else {
            //
            // This is a trusted client, so use the original pointer, since it
            // is cheaper than determining where to point into the SystemBuffer.
            //
            Method = (PKSMETHOD)IrpStack->Parameters.DeviceIoControl.Type3InputBuffer;
        }
    } else if (KSMETHOD_TYPE_IRP_STORAGE(Irp) & KSMETHOD_TYPE_SOURCE) {
        Method = (PKSMETHOD)Irp->AssociatedIrp.SystemBuffer;
    } else {
        Method = (PKSMETHOD)((PUCHAR)Irp->AssociatedIrp.SystemBuffer + AlignedBufferLength);
    }
    //
    // Optionally call back if this is a node request.
    //
    Flags = Method->Flags;
    if (Flags & KSMETHOD_TYPE_TOPOLOGY) {
        //
        // Input buffer must include node fields.
        //
        if (InputBufferLength < sizeof(KSM_NODE)) {
            return STATUS_INVALID_BUFFER_SIZE;
        }
        if (NodeAutomationTables) {
            const KSAUTOMATION_TABLE* automationTable;
            //
            // If the method was not captured in the local buffer, we have not
            // extracted the node ID yet.  When the local buffer is used, the
            // node ID is extracted in the try/except above.
            //
            if (Method != &LocalMethod) {
                NodeId = ((PKSM_NODE) Method)->NodeId;
            }
            if (NodeId >= NodesCount) {
                return STATUS_INVALID_DEVICE_REQUEST;
            }
            automationTable = NodeAutomationTables[NodeId];
            if ((! automationTable) || (automationTable->MethodSetsCount == 0)) {
                return STATUS_NOT_FOUND;
            }
            MethodSetsCount = automationTable->MethodSetsCount;
            MethodSet = automationTable->MethodSets;
            MethodItemSize = automationTable->MethodItemSize;
        }
        Flags &= ~KSMETHOD_TYPE_TOPOLOGY;
    }
    //
    // Allow the caller to indicate a size for each method item.
    //
    if (MethodItemSize) {
        ASSERT(MethodItemSize >= sizeof(KSMETHOD_ITEM));
        LocalMethodItemSize = MethodItemSize;
    } else {
        LocalMethodItemSize = sizeof(KSMETHOD_ITEM);
    }
    //
    // Search for the specified Method set within the list of sets given. Don't modify
    // the MethodSetsCount so that it can be used later in case this is a query for
    // the list of sets supported. Don't do that comparison first (GUID_NULL),
    // because it is rare.
    //
    for (RemainingSetsCount = MethodSetsCount; RemainingSetsCount; MethodSet++, RemainingSetsCount--) {
        if (IsEqualGUIDAligned(&Method->Set, MethodSet->Set)) {
            const KSMETHOD_ITEM*    MethodItem;

            if (Flags & KSIDENTIFIER_SUPPORTMASK) {
                if (Flags == KSMETHOD_TYPE_SETSUPPORT) {
                    //
                    // Querying for support of this set in general.
                    //
                    return STATUS_SUCCESS;
                }
                //
                // Else querying for basic support of this set. The data
                // parameter must be long enough to contain the flags
                // returned.
                //
                if (OutputBufferLength < sizeof(OutputBufferLength)) {
                    return STATUS_BUFFER_TOO_SMALL;
                }
                //
                // Attempt to locate the method item within the set already found.
                //
                if (!(MethodItem = FindMethodItem(MethodSet, LocalMethodItemSize, Method->Id))) {
                    return STATUS_NOT_FOUND;
                }
                //
                // Some filters want to do their own processing, so a pointer to
                // the set is placed in any IRP forwarded.
                //
                KSMETHOD_SET_IRP_STORAGE(Irp) = MethodSet;
                //
                // Optionally provide method item context.
                //
                if (MethodItemSize) {
                    KSMETHOD_ITEM_IRP_STORAGE(Irp) = MethodItem;
                }
                //
                // The output for the flags is either an allocated system address,
                // or it is the original output buffer as passed by a trusted client,
                // which must be a system address.
                //
                UserBuffer = (Irp->RequestorMode == KernelMode) ?
                    Irp->UserBuffer : Irp->AssociatedIrp.SystemBuffer;
                //
                // If the item contains an entry for a query support handler of its
                // own, then call that handler. The return from that handler
                // indicates that:
                //
                // 1. The item is supported, and the handler filled in the request.
                // 2. The item is supported, but the handler did not fill anything in.
                // 3. The item is supported, but the handler is waiting to modify
                //    what is filled in.
                // 4. The item is not supported, and an error it to be returned.
                // 5. A pending return.
                //
                if (MethodItem->SupportHandler &&
                    (!NT_SUCCESS(Status = MethodItem->SupportHandler(Irp, Method, UserBuffer)) ||
                    (Status != STATUS_SOME_NOT_MAPPED)) &&
                    (Status != STATUS_MORE_PROCESSING_REQUIRED)) {
                    //
                    // If 1) the item is not supported, 2) it is supported and the
                    // handler filled in the request, or 3) a pending return, then
                    // return the status. For the case of the item being
                    // supported, and the handler not filling in the requested
                    // information, STATUS_SOME_NOT_MAPPED or
                    // STATUS_MORE_PROCESSING_REQUIRED will continue on with
                    // default processing.
                    //
                    return Status;
                } else {
                    Status = STATUS_SUCCESS;
                }
                //
                // Just return the flags for the type of method this is.
                //
                *(PULONG)UserBuffer = MethodItem->Flags;
                Irp->IoStatus.Information = sizeof(ULONG);
                //
                // If the handler wants to do some post-processing, then
                // pass along the request again. The support handler knows
                // that this is the post-processing query because
                // Irp->IoStatus.Information is non-zero.
                //
                if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
                    return MethodItem->SupportHandler(Irp, Method, UserBuffer);
                }
                return STATUS_SUCCESS;
            }
            //
            // Attempt to locate the method item within the set already found.
            //
            if (!(MethodItem = FindMethodItem(MethodSet, LocalMethodItemSize, Method->Id))) {
                break;
            }
            if (!Irp->AssociatedIrp.SystemBuffer) {
                //
                // Store the flags so that an asynchronous operation can
                // determine what type of buffering was used in the method.
                // KsDispatchSpecificMethod uses this to determine where
                // the Method parameter is.
                //
                // The Allocator callback may also use this to determine
                // flags to set.
                //
                KSMETHOD_TYPE_IRP_STORAGE(Irp) = MethodItem->Flags;
                try {
                    ULONG AllocateLength;

                    if (Irp->RequestorMode != KernelMode) {
                        //
                        // A KSMETHOD_TYPE_NONE is not probed.
                        //
                        if (MethodItem->Flags & KSMETHOD_TYPE_WRITE) {
                            //
                            // This covers KSMETHOD_TYPE_MODIFY since there is no
                            // such thing as write-only memory.
                            //
                            ProbeForWrite(Irp->UserBuffer, OutputBufferLength, sizeof(BYTE));
                        } else if (MethodItem->Flags & KSMETHOD_TYPE_READ) {
                            ProbeForRead(Irp->UserBuffer, OutputBufferLength, sizeof(BYTE));
                        }
                    }
                    AllocateLength = ((MethodItem->Flags & KSMETHOD_TYPE_SOURCE) ? 0 : AlignedBufferLength) + InputBufferLength;
                    //
                    // Allocate space for one or both parameters, and set
                    // the cleanup flags so that normal Irp completion will
                    // take care of the buffer.
                    //
                    if (Allocator) {
                        //
                        // The allocator callback places the buffer into SystemBuffer.
                        // The flags must be updated by the allocation function if
                        // they apply.
                        //
                        Status = Allocator(Irp, AllocateLength, (BOOLEAN)(OutputBufferLength && (MethodItem->Flags & KSMETHOD_TYPE_WRITE) && !(MethodItem->Flags & KSMETHOD_TYPE_SOURCE)));
                        if (!NT_SUCCESS(Status)) {
                            return Status;
                        }
                    } else {
                        //
                        // No allocator was specified, so just use pool memory.
                        //
                        Irp->AssociatedIrp.SystemBuffer = ExAllocatePoolWithQuotaTag(NonPagedPool, AllocateLength, 'ppSK');
                        Irp->Flags |= (IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER);
                    }
                    if (InputBufferLength > sizeof(*Method)) {
                        //
                        // Copy the Method parameter.
                        //
                        RtlCopyMemory(
                            (PUCHAR)Irp->AssociatedIrp.SystemBuffer + AllocateLength - InputBufferLength,
                            IrpStack->Parameters.DeviceIoControl.Type3InputBuffer,
                            InputBufferLength);
                    }
                    //
                    // Overwrite with captured data.
                    //
                    *(PKSMETHOD)((PUCHAR)Irp->AssociatedIrp.SystemBuffer + AllocateLength - InputBufferLength) = *Method;
                    Method = (PKSMETHOD)((PUCHAR)Irp->AssociatedIrp.SystemBuffer + AllocateLength - InputBufferLength);
                    //
                    // Prepare the parameter buffer.
                    //
                    if (MethodItem->Flags & KSMETHOD_TYPE_SOURCE) {
                        //
                        // If something other than None was selected, allocate
                        // an MDL for the data parameter, and probe it for the
                        // type specified. The Modify flag covers both Read and
                        // Write.
                        //
                        if (MethodItem->Flags & KSMETHOD_TYPE_MODIFY) {
                            if (OutputBufferLength) {
                                if (!(Irp->MdlAddress = IoAllocateMdl(Irp->UserBuffer, OutputBufferLength, FALSE, TRUE, Irp))) {
                                    ExRaiseStatus(STATUS_INSUFFICIENT_RESOURCES);
                                }
                                //
                                // Actually probe the data, assuming that the flags
                                // which are used in the method type are consistant
                                // with the probe flags.
                                //
                                // Probing and locking is the last thing which is
                                // done, because if it fails the failure path below
                                // assumes that the Mdl is not locked.
                                //
#if KSMETHOD_TYPE_READ - 1 != IoReadAccess
#error KSMETHOD_TYPE_READ - 1 != IoReadAccess
#endif // KSMETHOD_TYPE_READ - 1 != IoReadAccess
                                MmProbeAndLockPages(Irp->MdlAddress, Irp->RequestorMode, (LOCK_OPERATION)((MethodItem->Flags & KSMETHOD_TYPE_MODIFY) - 1));
                            }
                            //
                            // The system address is passed to the handler.
                            //
                            UserBuffer = MmGetSystemAddressForMdl(Irp->MdlAddress);
                        } else {
                            //
                            // Else the actual source address is passed, which has
                            // not been verified in any manner.
                            //
                            UserBuffer = Irp->UserBuffer;
                        }
                    } else if (OutputBufferLength) {
                        switch (MethodItem->Flags) {
                            case KSMETHOD_TYPE_READ:
                            case KSMETHOD_TYPE_MODIFY:
                                RtlCopyMemory(Irp->AssociatedIrp.SystemBuffer, 
                                    Irp->UserBuffer, 
                                    OutputBufferLength);
                                if (MethodItem->Flags == KSMETHOD_TYPE_READ) {
                                    break;
                                }
                                // no break;
                            case KSMETHOD_TYPE_WRITE:
                                if (!Allocator) {
                                    Irp->Flags |= IRP_INPUT_OPERATION;
                                }
                        }
                        UserBuffer = Irp->AssociatedIrp.SystemBuffer;
                    } else {
                        UserBuffer = NULL;
                    }
                } except (EXCEPTION_EXECUTE_HANDLER) {
                    //
                    // If an Mdl was allocated, then the only thing which could
                    // have failed would be probing or locking the pages. If
                    // this happens, the Mdl must be freed before returning,
                    // since Irp completion assumes any Mdl associated with
                    // an Irp is locked. Note that it is assumed that the
                    // pages are not locked.
                    //
                    if (Irp->MdlAddress) {
                        IoFreeMdl(Irp->MdlAddress);
                        Irp->MdlAddress = NULL;
                    }
                    return GetExceptionCode();
                }
            } else if (KSMETHOD_TYPE_IRP_STORAGE(Irp) & KSMETHOD_TYPE_SOURCE) {
                if (OutputBufferLength) {
                    if (KSMETHOD_TYPE_IRP_STORAGE(Irp) & ~(KSMETHOD_TYPE_SOURCE | KSMETHOD_TYPE_TOPOLOGY)) {
                        //
                        // The Read, Write, or Modify flag has been set, indicating that
                        // a system address probed as such should be used.
                        //
                        UserBuffer = MmGetSystemAddressForMdl(Irp->MdlAddress);
                    } else {
                        //
                        // Else the actual source address is passed, which has not been
                        // verified in any manner.
                        //
                        UserBuffer = Irp->UserBuffer;
                    }
                } else {
                    UserBuffer = NULL;
                }
            } else if (OutputBufferLength) {
                UserBuffer = Irp->AssociatedIrp.SystemBuffer;
            } else {
                UserBuffer = NULL;
            }
            //
            // Some filters want to do their own processing, so a pointer to
            // the set is placed in any IRP forwarded.
            //
            KSMETHOD_SET_IRP_STORAGE(Irp) = MethodSet;
            //
            // Optionally provide method item context.
            //
            if (MethodItemSize) {
                KSMETHOD_ITEM_IRP_STORAGE(Irp) = MethodItem;
            }
            if ((IrpStack->Parameters.DeviceIoControl.InputBufferLength < 
                    MethodItem->MinMethod) || 
                (OutputBufferLength < MethodItem->MinData)) {
                return STATUS_BUFFER_TOO_SMALL;
            }
            return MethodItem->MethodHandler(Irp, Method, UserBuffer);
        }
    }
    //
    // The outer loop looking for method sets fell through with no match. This may
    // indicate that this is a support query for the list of all method sets
    // supported.
    //
    if (!RemainingSetsCount) {
        //
        // Specifying a GUID_NULL as the set means that this is a support query
        // for all sets.
        //
        if (!IsEqualGUIDAligned(&Method->Set, &GUID_NULL)) {
            return STATUS_PROPSET_NOT_FOUND;
        }
        //
        // The support flag must have been used so that the IRP_INPUT_OPERATION
        // is set. For future expansion, the identifier within the set is forced
        // to be zero.
        //
        // WRM: Changed below from !Method->Id to Method->Id.  Otherwise,
        // we end up returning invalid parameter for valid set support
        // queries.
        //
        if (Method->Id || (Flags != KSMETHOD_TYPE_SETSUPPORT)) {
            return STATUS_INVALID_PARAMETER;
        }
        //
        // The query can request the length of the needed buffer, or can
        // specify a buffer which is at least long enough to contain the
        // complete list of GUID's.
        //
        if (!OutputBufferLength) {
            //
            // Return the size of the buffer needed for all the GUID's.
            //
            Irp->IoStatus.Information = MethodSetsCount * sizeof(GUID);
            return STATUS_BUFFER_OVERFLOW;
#ifdef SIZE_COMPATIBILITY
        } else if (OutputBufferLength == sizeof(OutputBufferLength)) {
            *(PULONG)Irp->AssociatedIrp.SystemBuffer = MethodSetsCount * sizeof(GUID);
            Irp->IoStatus.Information = sizeof(OutputBufferLength);
            return STATUS_SUCCESS;
#endif // SIZE_COMPATIBILITY
        } else if (OutputBufferLength < MethodSetsCount * sizeof(GUID)) {
            //
            // The buffer was too short for all the GUID's.
            //
            return STATUS_BUFFER_TOO_SMALL;
        } else {
            GUID* Guid;

            Irp->IoStatus.Information = MethodSetsCount * sizeof(*Guid);
            MethodSet -= MethodSetsCount;
            for (Guid = (GUID*)Irp->AssociatedIrp.SystemBuffer; 
                 MethodSetsCount; 
                 Guid++, MethodSet++, MethodSetsCount--) {
                *Guid = *MethodSet->Set;
            }
        }
        return STATUS_SUCCESS;
    }
    return STATUS_NOT_FOUND;
}


const KSFASTMETHOD_ITEM*
FASTCALL
FindFastMethodItem(
    IN const KSMETHOD_SET* MethodSet,
    IN ULONG MethodId
    )
/*++

Routine Description:

    Given an method set structure locates the specified fast method item.

Arguments:

    MethodSet -
        Points to the method set to search.

    MethodId -
        Contains the fast method identifier to look for.

Return Value:

    Returns a pointer to the fast method identifier structure, or NULL if it
    could not be found.

--*/
{
    const KSFASTMETHOD_ITEM* FastMethodItem;
    ULONG MethodsCount;

    FastMethodItem = MethodSet->FastIoTable;
    for (MethodsCount = MethodSet->FastIoCount; 
         MethodsCount; MethodsCount--, 
         FastMethodItem++) {
        if (MethodId == FastMethodItem->MethodId) {
            return FastMethodItem;
        }
    }
    return NULL;
}


KSDDKAPI
BOOLEAN
NTAPI
KsFastMethodHandler(
    IN PFILE_OBJECT FileObject,
    IN PKSMETHOD Method,
    IN ULONG MethodLength,
    IN OUT PVOID Data,
    IN ULONG DataLength,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN ULONG MethodSetsCount,
    IN const KSMETHOD_SET* MethodSet
    )
/*++

Routine Description:

    Handles methods requested through the fast I/O interface. Does not deal
    with method information support, just the methods themselves. In the
    former case, the function returns FALSE, which allows the caller to
    generate an IRP to deal with the request. The function also does not deal
    with extended method items. This function may only be called at
    PASSIVE_LEVEL.

Arguments:

    FileObject -
        The file object on which the request is being made.

    Method -
        The method to query set. Must be LONG aligned.

    MethodLength -
        The length of the Method parameter.

    Data -
        The associated buffer for the query set, in which the data is
        returned or placed.

    DataLength -
        The length of the Data parameter.

    IoStatus -
        Return status.

    MethodSetsCount -
        Indicates the number of method set structures being passed.

    MethodSet -
        Contains the pointer to the list of method set information.

Return Value:

    Returns TRUE if the request was handled, else FALSE if an IRP must be
    generated. Sets the Information and Status in IoStatus.

--*/
{
    KPROCESSOR_MODE ProcessorMode;
    KSMETHOD LocalMethod;
    ULONG RemainingSetsCount;

    PAGED_CODE();
    //
    // Initially just check for the minimal method parameter length. The
    // actual minimal length will be validated when the method item is found.
    //
    if (MethodLength < sizeof(LocalMethod)) {
        return FALSE;
    }
    ProcessorMode = ExGetPreviousMode();
    //
    // Validate the method if the client is not trusted, then capture it.
    //
    if (ProcessorMode != KernelMode) {
        try {
            ProbeForRead(Method, MethodLength, sizeof(ULONG));
            LocalMethod = *Method;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return FALSE;
        }
    } else {
        LocalMethod = *Method;
    }
    //
    // Must use the normal method handler for support queries.
    //
    if (LocalMethod.Flags & KSIDENTIFIER_SUPPORTMASK) {
        return FALSE;
    }
    for (RemainingSetsCount = MethodSetsCount; RemainingSetsCount; MethodSet++, RemainingSetsCount--) {
        if (IsEqualGUIDAligned(&LocalMethod.Set, MethodSet->Set)) {
            const KSFASTMETHOD_ITEM* FastMethodItem;
            const KSMETHOD_ITEM* MethodItem;

            //
            // Once the method set is found, determine if there is fast
            // I/O support for that method item.
            //
            if (!(FastMethodItem = FindFastMethodItem(MethodSet, LocalMethod.Id))) {
                return FALSE;
            }
            //
            // If there is fast I/O support, then the real method item needs to
            // be located in order to validate the parameter sizes.
            //
            if (!(MethodItem = FindMethodItem(MethodSet, sizeof(*MethodItem), LocalMethod.Id))) {
                return FALSE;
            }
            //
            // Validate the data if the client is not trusted.
            //
            if (ProcessorMode != KernelMode) {
                try {
                    if (MethodItem->Flags & KSMETHOD_TYPE_READ) {
                        //
                        // This covers KSMETHOD_TYPE_MODIFY since there is no
                        // such thing as write-only memory.
                        //
                        ProbeForRead(Data, DataLength, sizeof(BYTE));
                    } else if (MethodItem->Flags & KSMETHOD_TYPE_WRITE) {
                        ProbeForWrite(Data, DataLength, sizeof(BYTE));
                    }
                } except (EXCEPTION_EXECUTE_HANDLER) {
                    return FALSE;
                }
            }
            //
            // The bytes returned is always assumed to be initialized by the handler.
            //
            IoStatus->Information = 0;
            if (!FastMethodItem->MethodHandler) {
                return FALSE;
            }
            if ((MethodLength < MethodItem->MinMethod) || 
                (DataLength < MethodItem->MinData)) {
                return FALSE;
            }
            return FastMethodItem->MethodHandler(
                FileObject,
                Method,
                MethodLength,
                Data,
                DataLength,
                IoStatus);
        }
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\ks\resource.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    resource.c

Abstract:

    This module contains the helper functions for resource sets, and
    resource handler code. These allow a device object to present a
    resource method set to a client device object, and allow the helper
    functions to perform all the necessary work of managing the resource,
    with little or no intervention aside from initialization and cleanup.
--*/

#include "ksp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, KsCleanupResource)
#pragma alloc_text(PAGE, KsResourceHandler)
#pragma alloc_text(PAGE, KsInitializeResource)
#endif

struct _RESOURCE_POOL;

typedef
NTSTATUS
(*PRESOURCEINITIALIZE)(
    IN const struct _RESOURCE_POOL* ResourcePool,
    IN PVOID                        ResourceParams,
    OUT PVOID*                      Pool
    );

typedef
NTSTATUS
(*PRESOURCEHANDLER)(
    IN PVOID    Pool,
    IN PIRP     Irp
    );

typedef
NTSTATUS
(*PRESOURCECLEANUP)(
    IN PVOID    Pool
    );

typedef struct _RESOURCE_POOL {
    PRESOURCEINITIALIZE Initialize;
    PRESOURCEHANDLER    Handler;
    PRESOURCECLEANUP    Cleanup;
} RESOURCE_POOL, *PRESOURCE_POOL;

typedef struct {
    const GUID*     ResourceClass;
    RESOURCE_POOL   ResourcePool;
} RESOURCE_HANDLER, *PRESOURCE_HANDLER;

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA

static const RESOURCE_HANDLER ResourceHandler[] = {
    {
        &KSMETHODSETID_ResourceLinMemory,
        NULL,
        NULL,
        NULL
    },
    {
        &KSMETHODSETID_ResourceRectMemory,
        NULL,
        NULL,
        NULL
    },
    {
        NULL
    }
};

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif // ALLOC_DATA_PRAGMA


KSDDKAPI
NTSTATUS
NTAPI
KsCleanupResource(
    IN PVOID    Pool
    )
/*++

Routine Description:

    Cleans up any structures allocated internally with initialization of the
    resource handler. Any resources in the pool that are still allocated at
    cleanup time are ignored. This function may only be called at
    PASSIVE_LEVEL.

Arguments:

    Pool -
        Contains the pointer to pool information that was returned on
        initialization via KsInitializeResource.

Return Value:

    Returns STATUS_SUCCESS if succeeded, else a parameter validation error.

--*/
{
    return (*(PRESOURCE_POOL*)Pool)->Cleanup(Pool);
}


KSDDKAPI
NTSTATUS
NTAPI
KsResourceHandler(
    IN PIRP     Irp,
    IN PVOID    Pool
    )
/*++

Routine Description:

    Handles method set requests for a pool. Responds to all method
    identifiers within the standard resource method set. The owner of the
    resource pool may then perform pre- or post-filtering of method
    handling. The underlying handler for the class of resource manages
    shuffling of resource allocation based on priorities, and performs all
    resource requests for the resource pool. This function may only be
    called at PASSIVE_LEVEL.

Arguments:

    Irp -
        Contains the IRP with the resource request to be handled.

    Pool -
        Contains the pointer to pool information that was returned on
        initialization via KsInitializeResource.

Return Value:

    Returns STATUS_SUCCESS, else an error specific to the method
    being handled. Always sets the IO_STATUS_BLOCK.Information field of the
    PIRP.IoStatus element within the IRP. It does not set the
    IO_STATUS_BLOCK.Status field, nor complete the IRP however.

--*/
{
    return (*(PRESOURCE_POOL*)Pool)->Handler(Pool, Irp);
}


KSDDKAPI
NTSTATUS
NTAPI
KsInitializeResource(
    IN REFGUID  ResourceClass,
    IN PVOID    ResourceParams,
    OUT PVOID*  Pool
    )
/*++

Routine Description:

    Initializes a resource pool for use. This function may only be called at
    PASSIVE_LEVEL.

Arguments:

    ResourceClass -
        Contains the class or resource. The current supported classes are
        KSMETHODSETID_ResourceLinMemory and KSMETHODSETID_ResourceRectMemory.

    ResourceParams -
        Contains a pointer to resource class specific parameters. The contents
        are determined by the class of resource. In the case of
        KSMETHODSETID_ResourceLinMemory this would point to an
        KSRESOURCE_LINMEMORY_INITIALIZE structure. In the case of
        KSMETHODSETID_ResourceRectMemory this would point to an
        KSRESOURCE_RECTMEMORY_INITIALIZE structure.

    ResourceParams -
        The place in which to put a pointer which represents the pool. This is
        used to reference the pool in other calls.

    Pool -
        The place in which to put a pointer which represents the pool. This is
        used to reference the pool in other calls.

Return Value:

    Returns STATUS_SUCCESS if succeeded, else a parameter validation or
    memory error.

--*/
{
    ULONG   Handlers;

    for (Handlers = 0; ResourceHandler[Handlers].ResourceClass; Handlers++) {
        if (IsEqualGUIDAligned(ResourceClass, 
                               ResourceHandler[Handlers].ResourceClass)) {
            return ResourceHandler[Handlers].ResourcePool.Initialize( &ResourceHandler[Handlers].ResourcePool, 
                                                                      ResourceParams, 
                                                                      Pool);
        }
    }
    return STATUS_INVALID_PARAMETER;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\ks\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

// This contains the publics that will be needed for resource.c

#define KSRESOURCE_CHANGEF_QUERY        0x00000001
#define KSRESOURCE_CHANGEF_RELEASE      0x00000002
#define KSRESOURCE_CHANGEF_AVAILABLE    0x00000003

typedef struct {
    KSPROPERTY  Property;
    ULONG       PoolId;
    ULONG       Reserved;
} KSP_RESOURCE_POOL, *PKSP_RESOURCE_POOL;

typedef struct {
    KSP_RESOURCE_POOL   ResourcePool;
    PVOID               Memory;
    ULONG               Count;
} KSRESOURCE_CHANGE_MEMORY, *PKSRESOURCE_CHANGE_MEMORY;

typedef
NTSTATUS
(*PFNKSALLOCATION)(
    PVOID           ResourceChange,
    ULONG           Request,
    PVOID           Context
    );

typedef enum {
    KSMETHOD_RESOURCE_MEMORY_ALLOCATE,
    KSMETHOD_RESOURCE_MEMORY_COMPACT,
    KSMETHOD_RESOURCE_MEMORY_FREE,
    KSMETHOD_RESOURCE_MEMORY_LARGEST_FREE,
    KSMETHOD_RESOURCE_MEMORY_NOTIFY,
    KSMETHOD_RESOURCE_MEMORY_PRIORITY,
    KSMETHOD_RESOURCE_MEMORY_REALLOCATE,
    KSMETHOD_RESOURCE_MEMORY_RESOURCE_SIZE,
    KSMETHOD_RESOURCE_MEMORY_TOTAL_FREE
} KSMETHOD_RESOURCE_MEMORY;

#define STATIC_KSMETHODSETID_ResourceLinMemory \
    0xB5BBD1C0L, 0x62C8, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDEX(KSMETHODSETID_ResourceLinMemory);

typedef struct {
    KSPRIORITY      Priority;
    PFNKSALLOCATION AllocationFunction;
    PVOID           Context;
    ULONG           Size;
    PVOID           LinMemory;
} KSPRESOURCE_LINMEMORY_ALLOCATE, *PKSRESOURCE_LINMEMORY_ALLOCATE;

typedef struct {
    PVOID           LinMemory;
    ULONG           Size;
} KSRESOURCE_LINMEMORY_REALLOCATE, *PKSRESOURCE_LINMEMORY_REALLOCATE;

#define STATIC_KSMETHODSETID_ResourceRectMemory \
    0x063E5D60L, 0x62CA, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDEX(KSMETHODSETID_ResourceRectMemory);

typedef struct {
    ULONG   XSize;
    ULONG   YSize;
} KSRESOURCE_RECTMEMORY_SIZE, *PKSRESOURCE_RECTMEMORY_SIZE;

typedef struct {
    KSPRIORITY                  Priority;
    PFNKSALLOCATION             AllocationFunction;
    PVOID                       Context;
    KSRESOURCE_RECTMEMORY_SIZE  RectMemorySize;
    PVOID                       RectMemory;
} KSRESOURCE_RECTMEMORY_ALLOCATE, *PKSRESOURCE_RECTMEMORY_ALLOCATE;

typedef struct {
    PVOID                       RectMemory;
    KSRESOURCE_RECTMEMORY_SIZE  RectMemorySize;
} KSRESOURCE_RECTMEMORY_REALLOCATE, *PKSRESOURCE_RECTMEMORY_REALLOCATE;

//===========================================================================

#define STATIC_KSEVENTSETID_Resource\
    0x80EE0780L, 0x62CB, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDEX(KSEVENTSETID_Resource);

typedef enum {
    KSEVENT_RESOURCE_DEGRADED,
    KSEVENT_RESOURCE_LOST
} KSEVENT_RESOURCE;

typedef struct {
    ULONG    Size;
    PVOID    Base;
    ULONG    RangeSize;
    ULONG    Alignment;
} KSRESOURCE_LINMEMORY_INITIALIZE, *PKSRESOURCE_LINMEMORY_INITIALIZE;

typedef struct {
    ULONG    Size;
    PVOID    Base;
    ULONG    XRangeSize;
    ULONG    YRangeSize;
    ULONG    XAlignment;
    ULONG    YAlignment;
} KSRESOURCE_RECTMEMORY_INITIALIZE, *PKSRESOURCE_RECTMEMORY_INITIALIZE;

// resource.c:

KSDDKAPI
NTSTATUS
NTAPI
KsCleanupResource(
    IN PVOID Pool
    );

KSDDKAPI
NTSTATUS
NTAPI
KsResourceHandler(
    IN PIRP Irp,
    IN PVOID Pool
    );

KSDDKAPI
NTSTATUS
NTAPI
KsInitializeResource(
    IN REFGUID ResourceClass,
    IN PVOID ResourceParams,
    OUT PVOID* Pool
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\ks\property.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    property.c

Abstract:

    This module contains the helper functions for property sets, and
    property set handler code. These allow a device object to present a
    property set to a client, and allow the helper function to perform some
    of the basic parameter validation and routing based on a property set
    table.
--*/

#include "ksp.h"

#ifdef ALLOC_PRAGMA
const KSPROPERTY_ITEM*
FASTCALL
FindPropertyItem(
    IN const KSPROPERTY_SET* PropertySet,
    IN ULONG PropertyItemSize,
    IN ULONG PropertyId
    );
NTSTATUS
SerializePropertySet(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    IN const KSPROPERTY_SET* PropertySet,
    IN ULONG PropertyItemSize
    );
NTSTATUS
UnserializePropertySet(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    IN const KSPROPERTY_SET* PropertySet
    );
const KSFASTPROPERTY_ITEM*
FASTCALL
FindFastPropertyItem(
    IN const KSPROPERTY_SET* PropertySet,
    IN ULONG PropertyId
    );

#pragma alloc_text(PAGE, FindPropertyItem)
#pragma alloc_text(PAGE, SerializePropertySet)
#pragma alloc_text(PAGE, UnserializePropertySet)
#pragma alloc_text(PAGE, KsPropertyHandler)
#pragma alloc_text(PAGE, KsPropertyHandlerWithAllocator)
#pragma alloc_text(PAGE, KspPropertyHandler)
#pragma alloc_text(PAGE, KsFastPropertyHandler)
#pragma alloc_text(PAGE, FindFastPropertyItem)
#endif // ALLOC_PRAGMA


const KSPROPERTY_ITEM*
FASTCALL
FindPropertyItem(
    IN const KSPROPERTY_SET* PropertySet,
    IN ULONG PropertyItemSize,
    IN ULONG PropertyId
    )
/*++

Routine Description:

    Given an property set structure locates the specified property item.

Arguments:

    PropertySet -
        Points to the property set to search.

    PropertyItemSize -
        Contains the size of each property item. This may be different
        than the standard property item size, since the items could be
        allocated on the fly, and contain context information.

    PropertyId -
        Contains the property identifier to look for.

Return Value:

    Returns a pointer to the property identifier structure, or NULL if it could
    not be found.

--*/
{
    const KSPROPERTY_ITEM* PropertyItem;
    ULONG PropertiesCount;

    PropertyItem = PropertySet->PropertyItem;
    for (PropertiesCount = PropertySet->PropertiesCount; 
        PropertiesCount; 
        PropertiesCount--, PropertyItem = (const KSPROPERTY_ITEM*)((PUCHAR)PropertyItem + PropertyItemSize)) {
        if (PropertyId == PropertyItem->PropertyId) {
            return PropertyItem;
        }
    }
    return NULL;
}


NTSTATUS
SerializePropertySet(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    IN const KSPROPERTY_SET* PropertySet,
    IN ULONG PropertyItemSize
    )
/*++

Routine Description:

    Serialize the properties of the specified property set. Looks at each property
    in the set and determines if it should be serialized into the provided buffer.

Arguments:

    Irp -
        Contains the IRP with the property serialization request being handled.

    Property -
        Contains a copy of the original property parameter. This is used in
        formulating property set calls.

    PropertySet -
        Contains the pointer to the property set being serialized.

    PropertyItemSize -
        Contains the size of each property item. This may be different
        than the standard property item size, since the items could be
        allocated on the fly, and contain context information.

Return Value:

    Returns either the serialized property set, or the length of such a serialization.

--*/
{
    PIO_STACK_LOCATION IrpStack;
    ULONG InputBufferLength;
    ULONG OutputBufferLength;
    PVOID UserBuffer;
    KSPROPERTY LocalProperty, *pInputProperty;
    ULONG TotalBytes;
    const KSPROPERTY_ITEM* PropertyItem;
    ULONG SerializedPropertyCount;
    PKSPROPERTY_SERIALHDR SerializedHdr;
    ULONG PropertiesCount;

    if (Property->Id) {
        return STATUS_INVALID_PARAMETER;
    }
    UserBuffer = Irp->AssociatedIrp.SystemBuffer;
    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    InputBufferLength = IrpStack->Parameters.DeviceIoControl.InputBufferLength;
    OutputBufferLength = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;
    PropertyItem = PropertySet->PropertyItem;
    //
    // If this is not just a query for the serialized size, place the GUID for
    // the set in the buffer first, and leave room to put the total properties
    // count into the buffer after counting them.
    //
    if (OutputBufferLength) {
        if (OutputBufferLength < sizeof(*SerializedHdr)) {
            return STATUS_INVALID_BUFFER_SIZE;
        }
        //
        // Save a pointer to the place in which to put the count in order to
        // update it at the end, and initialize the set identifier.
        //
        SerializedHdr = (PKSPROPERTY_SERIALHDR)UserBuffer;
        SerializedHdr->PropertySet = *PropertySet->Set;
        //
        // Update the current buffer pointer to be after the header. Keep
        // count separately, since it may not actually fit into the return
        // buffer.
        //
        UserBuffer = SerializedHdr + 1;
        SerializedPropertyCount = 0;
    }
    //
    // Reuse a copy of the original property request in order to pass along any
    // property set instance information that the caller used.
    //
    pInputProperty = (PKSPROPERTY)IrpStack->Parameters.DeviceIoControl.Type3InputBuffer;
    //
    // Validate the pointer if the client is not trusted. The property
    // structure must be writable for unserializing. The property Id is
    // placed into the original buffer when making the driver request.
    //
    if (Irp->RequestorMode != KernelMode) {
        try {
            LocalProperty = *pInputProperty;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }
    } else {
        LocalProperty = *pInputProperty;
    }
    
    LocalProperty.Flags = KSPROPERTY_TYPE_GET;
    
    TotalBytes = sizeof(*SerializedHdr);
    //
    // Serialize the properties into the buffer. The format being:
    //     <header><data>[<ulong padding>]
    // Where no padding is needed for the last element.
    //
    for (PropertiesCount = 0;
        PropertiesCount < PropertySet->PropertiesCount;
        PropertiesCount++, PropertyItem = (const KSPROPERTY_ITEM*)((PUCHAR)PropertyItem + PropertyItemSize)) {
        if (PropertyItem->SerializedSize) {
            ULONG   QueriedPropertyItemSize;

            TotalBytes = (TotalBytes + FILE_LONG_ALIGNMENT) & ~FILE_LONG_ALIGNMENT;
            try {
                LocalProperty.Id = PropertyItem->PropertyId;
            } except (EXCEPTION_EXECUTE_HANDLER) {
                return GetExceptionCode();
            }
            if (PropertyItem->SerializedSize == (ULONG)-1) {
                NTSTATUS Status;

                //
                // Size is unknown, so retrieve it from the object.
                //
                Status = KsSynchronousIoControlDevice(
                    IrpStack->FileObject,
                    KernelMode,
                    IrpStack->Parameters.DeviceIoControl.IoControlCode,
                    &LocalProperty,
                    InputBufferLength,
                    NULL,
                    0,
                    &QueriedPropertyItemSize);
                //
                // Could be a zero length property.
                //
                if (!NT_SUCCESS(Status) && (Status != STATUS_BUFFER_OVERFLOW)) {
                    return Status;
                }
            } else {
                QueriedPropertyItemSize = PropertyItem->SerializedSize;
            }
            if (OutputBufferLength) {
                PKSPROPERTY_SERIAL PropertySerial;
                ULONG BytesReturned;
                NTSTATUS Status;

                //
                // Must have enough room to store the current size with padding,
                // plus the new item and its data.
                //
                if (OutputBufferLength < TotalBytes + sizeof(*PropertySerial) + QueriedPropertyItemSize) {
                    return STATUS_INVALID_BUFFER_SIZE;
                }
                (ULONG_PTR)UserBuffer = ((ULONG_PTR)UserBuffer + FILE_LONG_ALIGNMENT) & ~FILE_LONG_ALIGNMENT;
                PropertySerial = (PKSPROPERTY_SERIAL)UserBuffer;
                //
                // If the property item has type information, serialize it.
                //
                if (PropertyItem->Values) {
                    PropertySerial->PropTypeSet = PropertyItem->Values->PropTypeSet;
                } else {
                    PropertySerial->PropTypeSet.Set = GUID_NULL;
                    PropertySerial->PropTypeSet.Id = 0;
                    PropertySerial->PropTypeSet.Flags = 0;
                }
                //
                // Serialize the header, then request the value from the object.
                //
                PropertySerial->Id = PropertyItem->PropertyId;
                PropertySerial->PropertyLength = QueriedPropertyItemSize;
                UserBuffer = PropertySerial + 1;
                //
                // The property may have been zero length.
                //
                if (QueriedPropertyItemSize) {
                    if (!NT_SUCCESS(Status = KsSynchronousIoControlDevice(
                        IrpStack->FileObject,
                        KernelMode,
                        IrpStack->Parameters.DeviceIoControl.IoControlCode,
                        &LocalProperty,
                        InputBufferLength,
                        Irp->UserBuffer,
                        QueriedPropertyItemSize,
                        &BytesReturned))) {
                        //
                        // If one property fails, then no further properties are attempted.
                        //
                        return Status;
                    }
                    //
                    // Move data from original buffer, which might be a non-
                    // system address, to a system address.
                    //
                    try {
                        memcpy(UserBuffer, Irp->UserBuffer, BytesReturned);
                    } except (EXCEPTION_EXECUTE_HANDLER) {
                        return GetExceptionCode();
                    }
                    if (BytesReturned != QueriedPropertyItemSize) {
                        return STATUS_INVALID_BUFFER_SIZE;
                    }
                }
                (PUCHAR)UserBuffer += QueriedPropertyItemSize;
                SerializedPropertyCount++;
            }
            TotalBytes += sizeof(KSPROPERTY_SERIAL) + QueriedPropertyItemSize;
        }
    }
    //
    // Return either the total size needed for the serialized values, or the
    // values themselves, along with the total count.
    //
    Irp->IoStatus.Information = TotalBytes;
    if (OutputBufferLength) {
        SerializedHdr->Count = SerializedPropertyCount;
        return STATUS_SUCCESS;
    }
    return STATUS_BUFFER_OVERFLOW;
}
 

NTSTATUS
UnserializePropertySet(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    IN const KSPROPERTY_SET* PropertySet
    )
/*++

Routine Description:

    Unserialize the properties of the specified property set. Enumerates the
    items in the serialized buffer and sets the values of the specified property
    set.

Arguments:

    Irp -
        Contains the IRP with the property unserialization request being handled.

    Property -
        Contains a copy of the original property parameter. This is used in
        formulating property set calls.

    PropertySet -
        Contains the pointer to the property set being unserialized.

Return Value:

    Returns STATUS_SUCCESS if the property set was unserialized, else an error.

--*/
{
    PIO_STACK_LOCATION IrpStack;
    ULONG InputBufferLength;
    ULONG OutputBufferLength;
    PVOID UserBuffer;
    KSPROPERTY LocalProperty, *pInputProperty;
    ULONG SerializedPropertyCount;
    PKSPROPERTY_SERIALHDR SerializedHdr;

    if (Property->Id) {
        return STATUS_INVALID_PARAMETER;
    }
    UserBuffer = Irp->AssociatedIrp.SystemBuffer;
    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    InputBufferLength = IrpStack->Parameters.DeviceIoControl.InputBufferLength;
    OutputBufferLength = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;
    //
    // First validate the set GUID at the start of the buffer.
    //
    if (OutputBufferLength < sizeof(*SerializedHdr)) {
        return STATUS_INVALID_BUFFER_SIZE;
    }
    SerializedHdr = (PKSPROPERTY_SERIALHDR)UserBuffer;
    if (!IsEqualGUIDAligned(PropertySet->Set, &SerializedHdr->PropertySet)) {
        return STATUS_INVALID_PARAMETER;
    }
    //
    // Reuse a copy of the original property request in order to pass along any
    // property set instance information that the caller used.
    //
    pInputProperty = (PKSPROPERTY)IrpStack->Parameters.DeviceIoControl.Type3InputBuffer;
    //
    // Validate the pointer if the client is not trusted. The property
    // structure must be writable for unserializing. The property Id is
    // placed into the original buffer when making the driver request.
    //
    if (Irp->RequestorMode != KernelMode) {
        try {
            LocalProperty = *pInputProperty;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }
    } else {
        LocalProperty = *pInputProperty;
    }
    
    LocalProperty.Flags = KSPROPERTY_TYPE_SET;

    //
    // Store the number of serialized properties claimed to be present so the
    // original is not modified.
    //
    SerializedPropertyCount = SerializedHdr->Count;
    UserBuffer = SerializedHdr + 1;
    OutputBufferLength -= sizeof(*SerializedHdr);
    //
    // Enumerate the properties serialized in the buffer. The format being:
    //     <header><data>[<ulong padding>]
    // Where no padding is needed for the last element.
    //
    for (; OutputBufferLength && SerializedPropertyCount; SerializedPropertyCount--) {
        ULONG BytesReturned;
        PKSPROPERTY_SERIAL PropertySerial;
        NTSTATUS Status;

        if (OutputBufferLength < sizeof(*PropertySerial)) {
            //
            // The buffer is not large enough to hold even the header.
            //
            return STATUS_INVALID_BUFFER_SIZE;
        }
        PropertySerial = (PKSPROPERTY_SERIAL)UserBuffer;
        if (PropertySerial->PropTypeSet.Flags) {
            return STATUS_INVALID_PARAMETER;
        }
        try {
            LocalProperty.Id = PropertySerial->Id;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }
        OutputBufferLength -= sizeof(*PropertySerial);
        UserBuffer = PropertySerial + 1;
        if (PropertySerial->PropertyLength > OutputBufferLength) {
            //
            // The property length extracted is larger than the entire rest
            // of the buffer size.
            //
            return STATUS_INVALID_BUFFER_SIZE;
        }
        if (!NT_SUCCESS(Status = KsSynchronousIoControlDevice(
            IrpStack->FileObject,
            KernelMode,
            IrpStack->Parameters.DeviceIoControl.IoControlCode,
            &LocalProperty,
            InputBufferLength,
            (PUCHAR)Irp->UserBuffer + ((PUCHAR)UserBuffer - (PUCHAR)Irp->AssociatedIrp.SystemBuffer),
            PropertySerial->PropertyLength,
            &BytesReturned))) {
            //
            // If one property fails, then no further properties are attempted.
            //
            return Status;
        }
        //
        // Check to see if this was the last property in the list.
        //
        if (PropertySerial->PropertyLength < OutputBufferLength) {
            //
            // Add possible padding to make it FILE_LONG_ALIGNMENT.
            //
            PropertySerial->PropertyLength = (PropertySerial->PropertyLength + FILE_LONG_ALIGNMENT) & ~FILE_LONG_ALIGNMENT;
            if (PropertySerial->PropertyLength >= OutputBufferLength) {
                //
                // Either the last element was unneccessarily padded, or the
                // buffer was not long enough to cover the padding for the
                // next item.
                //
                return STATUS_INVALID_BUFFER_SIZE;
            }
        }
        (PUCHAR)UserBuffer += PropertySerial->PropertyLength;
        OutputBufferLength -= PropertySerial->PropertyLength;
    }
    if (OutputBufferLength || SerializedPropertyCount) {
        //
        // The properties were all set, but at least an error can be
        // returned since the size of the number of properties was
        // incorrect.
        //
        return STATUS_INFO_LENGTH_MISMATCH;
    }
    return STATUS_SUCCESS;
}


KSDDKAPI
NTSTATUS
NTAPI
KsPropertyHandler(
    IN PIRP Irp,
    IN ULONG PropertySetsCount,
    IN const KSPROPERTY_SET* PropertySet
    )
/*++

Routine Description:

    Handles property requests. Responds to all property identifiers defined
    by the sets. The owner of the property set may then perform pre- or
    post-filtering of the property handling. This function may only be
    called at PASSIVE_LEVEL.

Arguments:

    Irp -
        Contains the IRP with the property request being handled.

    PropertySetsCount -
        Indicates the number of property set structures being passed.

    PropertySet -
        Contains the pointer to the list of property set information.

Return Value:

    Returns STATUS_SUCCESS, else an error specific to the property being
    handled. Always sets the IO_STATUS_BLOCK.Information field of the
    PIRP.IoStatus element within the IRP, either through setting it to zero
    because of an internal error, or through a property handler setting it.
    It does not set the IO_STATUS_BLOCK.Status field, nor complete the IRP
    however.

--*/
{
    PAGED_CODE();
    return KspPropertyHandler(Irp, PropertySetsCount, PropertySet, NULL, 0, NULL, 0);
}


KSDDKAPI
NTSTATUS
NTAPI
KsPropertyHandlerWithAllocator(
    IN PIRP Irp,
    IN ULONG PropertySetsCount,
    IN const KSPROPERTY_SET* PropertySet,
    IN PFNKSALLOCATOR Allocator OPTIONAL,
    IN ULONG PropertyItemSize OPTIONAL
    )
/*++

Routine Description:

    Handles property requests. Responds to all property identifiers defined
    by the sets. The owner of the property set may then perform pre- or
    post-filtering of the property handling. This function may only be
    called at PASSIVE_LEVEL.

Arguments:

    Irp -
        Contains the IRP with the property request being handled.

    PropertySetsCount -
        Indicates the number of property set structures being passed.

    PropertySet -
        Contains the pointer to the list of property set information.

    Allocator -
        Optionally contains the callback with which a mapped buffer
        request will be made. If this is not provided, pool memory
        will be used. If specified, this is used to allocate memory
        for a property IRP using the callback. This can be used
        to allocate specific memory for property requests, such as
        mapped memory. Note that this assumes that property Irp's passed
        to a filter have not been manipulated before being sent. It is
        invalid to directly forward a property Irp.

    PropertyItemSize -
        Optionally contains an alternate property item size to use when
        incrementing the current property item counter. If this is a
        non-zero value, it is assumed to contain the size of the increment,
        and directs the function to pass a pointer to the property item
        located in the DriverContext field accessed through the
        KSPROPERTY_ITEM_IRP_STORAGE macro.

Return Value:

    Returns STATUS_SUCCESS, else an error specific to the property being
    handled. Always sets the IO_STATUS_BLOCK.Information field of the
    PIRP.IoStatus element within the IRP, either through setting it to zero
    because of an internal error, or through a property handler setting it.
    It does not set the IO_STATUS_BLOCK.Status field, nor complete the IRP
    however.

--*/
{
    PAGED_CODE();
    return KspPropertyHandler(Irp, PropertySetsCount, PropertySet, Allocator, PropertyItemSize, NULL, 0);
}


NTSTATUS
KspPropertyHandler(
    IN PIRP Irp,
    IN ULONG PropertySetsCount,
    IN const KSPROPERTY_SET* PropertySet,
    IN PFNKSALLOCATOR Allocator OPTIONAL,
    IN ULONG PropertyItemSize OPTIONAL,
    IN const KSAUTOMATION_TABLE*const* NodeAutomationTables OPTIONAL,
    IN ULONG NodesCount
    )
/*++

Routine Description:

    Handles property requests. Responds to all property identifiers defined
    by the sets. The owner of the property set may then perform pre- or
    post-filtering of the property handling. This function may only be
    called at PASSIVE_LEVEL.

Arguments:

    Irp -
        Contains the IRP with the property request being handled.

    PropertySetsCount -
        Indicates the number of property set structures being passed.

    PropertySet -
        Contains the pointer to the list of property set information.

    Allocator -
        Optionally contains the callback with which a mapped buffer
        request will be made. If this is not provided, pool memory
        will be used. If specified, this is used to allocate memory
        for a property IRP using the callback. This can be used
        to allocate specific memory for property requests, such as
        mapped memory. Note that this assumes that property Irp's passed
        to a filter have not been manipulated before being sent. It is
        invalid to directly forward a property Irp.

    PropertyItemSize -
        Optionally contains an alternate property item size to use when
        incrementing the current property item counter. If this is a
        non-zero value, it is assumed to contain the size of the increment,
        and directs the function to pass a pointer to the property item
        located in the DriverContext field accessed through the
        KSPROPERTY_ITEM_IRP_STORAGE macro.

    NodeAutomationTables -
        Optional table of automation tables for nodes.

    NodesCount -
        Count of nodes.

Return Value:

    Returns STATUS_SUCCESS, else an error specific to the property being
    handled. Always sets the IO_STATUS_BLOCK.Information field of the
    PIRP.IoStatus element within the IRP, either through setting it to zero
    because of an internal error, or through a property handler setting it.
    It does not set the IO_STATUS_BLOCK.Status field, nor complete the IRP
    however.

--*/
{
    PIO_STACK_LOCATION IrpStack;
    ULONG InputBufferLength;
    ULONG OutputBufferLength;
    ULONG AlignedBufferLength;
    PVOID UserBuffer;
    PKSPROPERTY Property;
    ULONG LocalPropertyItemSize;
    ULONG RemainingSetsCount;
    ULONG Flags;

    PAGED_CODE();
    //
    // Determine the offsets to both the Property and UserBuffer parameters based
    // on the lengths of the DeviceIoControl parameters. A single allocation is
    // used to buffer both parameters. The UserBuffer (or results on a support
    // query) is stored first, and the Property is stored second, on
    // FILE_QUAD_ALIGNMENT.
    //
    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    InputBufferLength = IrpStack->Parameters.DeviceIoControl.InputBufferLength;
    OutputBufferLength = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;
    AlignedBufferLength = (OutputBufferLength + FILE_QUAD_ALIGNMENT) & ~FILE_QUAD_ALIGNMENT;
    //
    // Determine if the parameters have already been buffered by a previous
    // call to this function.
    //
    if (!Irp->AssociatedIrp.SystemBuffer) {
        //
        // Initially just check for the minimal property parameter length. The
        // actual minimal length will be validated when the property item is found.
        // Also ensure that the output and input buffer lengths are not set so
        // large as to overflow when aligned or added.
        //
        if ((InputBufferLength < sizeof(*Property)) || (AlignedBufferLength < OutputBufferLength) || (AlignedBufferLength + InputBufferLength < AlignedBufferLength)) {
            return STATUS_INVALID_BUFFER_SIZE;
        }
        try {
            //
            // Validate the pointers if the client is not trusted.
            //
            if (Irp->RequestorMode != KernelMode) {
                ProbeForRead(IrpStack->Parameters.DeviceIoControl.Type3InputBuffer, InputBufferLength, sizeof(BYTE));
            }
            //
            // Capture flags first so that they can be used to determine allocation.
            //
            Flags = ((PKSPROPERTY)IrpStack->Parameters.DeviceIoControl.Type3InputBuffer)->Flags;
            //
            // Allocate space for both parameters, and set the cleanup flags
            // so that normal Irp completion will take care of the buffer.
            //
            if (Allocator && (Flags & (KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_SET))) {
                NTSTATUS    Status;

                //
                // The allocator callback places the buffer into SystemBuffer.
                // The flags must be updated by the allocation function if they
                // apply.
                //
                Status = Allocator(Irp, AlignedBufferLength + InputBufferLength, (BOOLEAN)(OutputBufferLength && (Flags & KSPROPERTY_TYPE_GET)));
                if (!NT_SUCCESS(Status)) {
                    return Status;
                }
            } else {
                //
                // No allocator was specified, so just use pool memory.
                //
                Irp->AssociatedIrp.SystemBuffer = ExAllocatePoolWithQuotaTag(NonPagedPool, AlignedBufferLength + InputBufferLength, 'ppSK');
                Irp->Flags |= (IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER);
            }
                        
            //
            // Copy the Property parameter.
            //
            RtlCopyMemory((PUCHAR)Irp->AssociatedIrp.SystemBuffer + AlignedBufferLength, IrpStack->Parameters.DeviceIoControl.Type3InputBuffer, InputBufferLength);
            
            //
            // Rewrite the previously captured flags.
            //
            ((PKSPROPERTY)((PUCHAR)Irp->AssociatedIrp.SystemBuffer + AlignedBufferLength))->Flags = Flags;
            Flags &= ~KSPROPERTY_TYPE_TOPOLOGY;
            //
            // Validate the request flags. At the same time set up the IRP flags
            // for an input operation if there is an input buffer available so
            // that Irp completion will copy the data to the client's original
            // buffer.
            //
            switch (Flags) {
            case KSPROPERTY_TYPE_GET:
                //
                // Some buggy dirvers, such as usb camera mini drivers, return IoStatus.Information of the size 
                // of a whole struct, but only write a dword. It discloses arbitray kernel content at the 
                // uninitialized memory. It is found in the sample driver. Consequently, many mini drivers 
                // minic the same behavior. This problem is not easy for usbcamd to mitigate. Here we are at a
                // convenient place to do so for them. The draw back of doing this extra zeroing is that this
                // penalizes all our clients with extra cpu cycles. Luckily, this overhead is either small or
                // not excecuted too frequently.
                //
                RtlZeroMemory((PUCHAR)Irp->AssociatedIrp.SystemBuffer, AlignedBufferLength );
                // fall through to continue the work             

            case KSPROPERTY_TYPE_SETSUPPORT:
            case KSPROPERTY_TYPE_BASICSUPPORT:
            case KSPROPERTY_TYPE_RELATIONS:
            case KSPROPERTY_TYPE_SERIALIZESET:
            case KSPROPERTY_TYPE_SERIALIZERAW:
            case KSPROPERTY_TYPE_SERIALIZESIZE:
            case KSPROPERTY_TYPE_DEFAULTVALUES:
                //
                // These are all input operations, and must be probed
                // when the client is not trusted.
                //
                if (OutputBufferLength) {
                    if (Irp->RequestorMode != KernelMode) {
                        ProbeForWrite(Irp->UserBuffer, OutputBufferLength, sizeof(BYTE));
                    }
                    //
                    // The allocator is only used for real property queries.
                    // So if used, it is responsible for setting flags.
                    //
                    if (!Allocator || (Flags != KSPROPERTY_TYPE_GET)) {
                        Irp->Flags |= IRP_INPUT_OPERATION;
                    }
                }
                break;
            case KSPROPERTY_TYPE_SET:
            case KSPROPERTY_TYPE_UNSERIALIZESET:
            case KSPROPERTY_TYPE_UNSERIALIZERAW:
                //
                // Thse are all output operations, and must be probed
                // when the client is not trusted. All data passed is
                // copied to the system buffer.
                //
                if (OutputBufferLength) {
                    if (Irp->RequestorMode != KernelMode) {
                        ProbeForRead(Irp->UserBuffer, OutputBufferLength, sizeof(BYTE));
                    }
                    RtlCopyMemory(Irp->AssociatedIrp.SystemBuffer, Irp->UserBuffer, OutputBufferLength);
                }
                break;
            default:
                return STATUS_INVALID_PARAMETER;
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }
    }
    //
    // If there are property parameters, retrieve a pointer to the buffered copy
    // of it. This is the first portion of the SystemBuffer.
    //
    if (OutputBufferLength) {
        UserBuffer = Irp->AssociatedIrp.SystemBuffer;
    } else {
        UserBuffer = NULL;
    }
    Property = (PKSPROPERTY)((PUCHAR)Irp->AssociatedIrp.SystemBuffer + AlignedBufferLength);
    //
    // Optionally call back if this is a node request.
    //
    Flags = Property->Flags;
    //
    // HACK!  This is done because wdmaud sets this bit when requesting node names (bug 320925).
    //
    if (IsEqualGUIDAligned(&Property->Set,&KSPROPSETID_Topology)) {
        Flags = Property->Flags & ~KSPROPERTY_TYPE_TOPOLOGY;
    }
    if (Flags & KSPROPERTY_TYPE_TOPOLOGY) {
        //
        // Input buffer must include the node ID.
        //
        PKSP_NODE nodeProperty = (PKSP_NODE) Property;
        if (InputBufferLength < sizeof(*nodeProperty)) {
            return STATUS_INVALID_BUFFER_SIZE;
        }
        if (NodeAutomationTables) {
            const KSAUTOMATION_TABLE* automationTable;
            if (nodeProperty->NodeId >= NodesCount) {
                return STATUS_INVALID_DEVICE_REQUEST;
            }
            automationTable = NodeAutomationTables[nodeProperty->NodeId];
            if ((! automationTable) || (automationTable->PropertySetsCount == 0)) {
                return STATUS_NOT_FOUND;
            }
            PropertySetsCount = automationTable->PropertySetsCount;
            PropertySet = automationTable->PropertySets;
            PropertyItemSize = automationTable->PropertyItemSize;
        }
        Flags = Property->Flags & ~KSPROPERTY_TYPE_TOPOLOGY;
    }

    //
    // Allow the caller to indicate a size for each property item.
    //
    if (PropertyItemSize) {
        ASSERT(PropertyItemSize >= sizeof(KSPROPERTY_ITEM));
        LocalPropertyItemSize = PropertyItemSize;
    } else {
        LocalPropertyItemSize = sizeof(KSPROPERTY_ITEM);
    }
    //
    // Search for the specified Property set within the list of sets given. Don't modify
    // the PropertySetsCount so that it can be used later in case this is a query for
    // the list of sets supported. Don't do that comparison first (GUID_NULL),
    // because it is rare.
    //
    for (RemainingSetsCount = PropertySetsCount; RemainingSetsCount; PropertySet++, RemainingSetsCount--) {
        if (IsEqualGUIDAligned(&Property->Set, PropertySet->Set)) {
            const KSPROPERTY_ITEM* PropertyItem;

            if (Flags & KSIDENTIFIER_SUPPORTMASK) {
                ULONG AccessFlags;
                PKSPROPERTY_DESCRIPTION Description;
                NTSTATUS Status;

                switch (Flags) {
                case KSPROPERTY_TYPE_SETSUPPORT:
                    //
                    // Querying for support of this set in general.
                    //
                    return STATUS_SUCCESS;

                case KSPROPERTY_TYPE_BASICSUPPORT:
                case KSPROPERTY_TYPE_DEFAULTVALUES:
                    //
                    // Querying for basic support or default values of this
                    // set. Either the data parameter is long enough to
                    // return the size of a full description, or it is long
                    // enough to actually hold the description.
                    //
                    if ((OutputBufferLength < sizeof(OutputBufferLength)) || ((OutputBufferLength > sizeof(OutputBufferLength)) && (OutputBufferLength < sizeof(*Description)))) {
                        return STATUS_BUFFER_TOO_SMALL;
                    }
                    break;

                case KSPROPERTY_TYPE_SERIALIZESET:
                    //
                    // The support handler does not need to deal with this.
                    //
                    return SerializePropertySet(Irp, Property, PropertySet, LocalPropertyItemSize);

                case KSPROPERTY_TYPE_UNSERIALIZESET:
                    //
                    // The support handler does not need to deal with this.
                    //
                    return UnserializePropertySet(Irp, Property, PropertySet);

                case KSPROPERTY_TYPE_SERIALIZERAW:
                case KSPROPERTY_TYPE_UNSERIALIZERAW:

                    //
                    // Attempt to locate the property item within the set already found.
                    // This implies that raw serializing/unserializing can only be
                    // performed against specific properties within the set. That
                    // handler however may place multiple property values within the
                    // buffer.
                    //
                    if (!(PropertyItem = FindPropertyItem(PropertySet, LocalPropertyItemSize, Property->Id))) {
                        return STATUS_NOT_FOUND;
                    }
                    //
                    // Raw unserialization can only be serviced by a support
                    // handler, since the data is in some internal format.
                    //
                    if (!PropertyItem->SupportHandler) {
                        return STATUS_INVALID_PARAMETER;
                    }
                    //
                    // Some filters want to do their own processing, so a pointer to
                    // the set is placed in any IRP forwarded.
                    //
                    KSPROPERTY_SET_IRP_STORAGE(Irp) = PropertySet;
                    //
                    // Optionally provide property item context.
                    //
                    if (PropertyItemSize) {
                        KSPROPERTY_ITEM_IRP_STORAGE(Irp) = PropertyItem;
                    }
                    return PropertyItem->SupportHandler(Irp, Property, UserBuffer);
                case KSPROPERTY_TYPE_SERIALIZESIZE:

                    //
                    // Query the size of the serialized property data. Fill in the
                    // actual data after finding the property item and trying the
                    // support handler for the item first.
                    //
                    if (OutputBufferLength < sizeof(OutputBufferLength)) {
                        return STATUS_BUFFER_TOO_SMALL;
                    }
                    break;

                }
                //
                // Attempt to locate the property item within the set already found.
                //
                if (!(PropertyItem = FindPropertyItem(PropertySet, LocalPropertyItemSize, Property->Id))) {
                    return STATUS_NOT_FOUND;
                }
                //
                // Some filters want to do their own processing, so a pointer to
                // the set is placed in any IRP forwarded.
                //
                KSPROPERTY_SET_IRP_STORAGE(Irp) = PropertySet;
                //
                // Optionally provide property item context.
                //
                if (PropertyItemSize) {
                    KSPROPERTY_ITEM_IRP_STORAGE(Irp) = PropertyItem;
                }
                //
                // If the item contains an entry for a query support handler of its
                // own, then call that handler. The return from that handler
                // indicates that:
                //
                // 1. The item is supported, and the handler filled in the request.
                // 2. The item is supported, but the handler did not fill anything in.
                // 3. The item is supported, but the handler is waiting to modify
                //    what is filled in.
                // 4. The item is not supported, and an error is to be returned.
                // 5. A pending return.
                //
                if (PropertyItem->SupportHandler &&
                    (!NT_SUCCESS(Status = PropertyItem->SupportHandler(Irp, Property, UserBuffer)) ||
                    (Status != STATUS_SOME_NOT_MAPPED)) &&
                    (Status != STATUS_MORE_PROCESSING_REQUIRED)) {
                    //
                    // If 1) the item is not supported, 2) it is supported and the
                    // handler filled in the request, or 3) a pending return, then
                    // return the status. For the case of the item being
                    // supported, and the handler not filling in the requested
                    // information, STATUS_SOME_NOT_MAPPED or
                    // STATUS_MORE_PROCESSING_REQUIRED will continue on with
                    // default processing.
                    //
                    return Status;
                } else {
                    Status = STATUS_SUCCESS;
                }
                if (Flags == KSPROPERTY_TYPE_RELATIONS) {
                    NTSTATUS ListStatus;

                    //
                    // Either copy the list of related properties to the
                    // UserBuffer, or return the size of buffer needed to copy
                    // all the related properties, and possibly the count of
                    // relations.
                    //
                    ListStatus = KsHandleSizedListQuery(
                        Irp,
                        PropertyItem->RelationsCount,
                        sizeof(*PropertyItem->Relations),
                        PropertyItem->Relations);
                    //
                    // If the query succeeded, and the handler wants to do
                    // some post-processing, then pass along the request
                    // again. The support handler knows that this is the
                    // post-processing query because Irp->IoStatus.Information
                    // is non-zero.
                    //
                    if (NT_SUCCESS(ListStatus) && (Status == STATUS_MORE_PROCESSING_REQUIRED)) {
                        ListStatus = PropertyItem->SupportHandler(Irp, Property, UserBuffer);
                    }
                    return ListStatus;
                } else if (Flags == KSPROPERTY_TYPE_SERIALIZESIZE) {
                    //
                    // Actually return the serialized size of the property data.
                    // The size of the caller's buffer has been checked above.
                    //
                    *(PULONG)UserBuffer = PropertyItem->SerializedSize;
                    Irp->IoStatus.Information = sizeof(PropertyItem->SerializedSize);
                    //
                    // Post-processing with the support handler is not performed
                    // in this case.
                    //
                    return STATUS_SUCCESS;
                }
                //
                // This is a basic support query. Either return the access
                // flags, or the KSPROPERTY_DESCRIPTION structure, or the
                // entire property description.
                //
                if (PropertyItem->GetPropertyHandler) {
                    AccessFlags = KSPROPERTY_TYPE_GET;
                } else {
                    AccessFlags = 0;
                }
                if (PropertyItem->SetPropertyHandler) {
                    AccessFlags |= KSPROPERTY_TYPE_SET;
                }
                Description = (PKSPROPERTY_DESCRIPTION)UserBuffer;
                //
                // The first element of the structure is the access flags,
                // so always fill this in no matter what the length of the
                // UserBuffer.
                //
                Description->AccessFlags = AccessFlags;
                //
                // If the UserBuffer is large enough, put at least the
                // description header in it, and possibly the entire description.
                //
                if (OutputBufferLength >= sizeof(*Description)) {
                    Description->Reserved = 0;
                    //
                    // The property item may not have specified the optional
                    // description information, so default values are filled in
                    // instead.
                    //
                    if (!PropertyItem->Values) {
                        Description->DescriptionSize = sizeof(*Description);
                        Description->PropTypeSet.Set = GUID_NULL;
                        Description->PropTypeSet.Id = 0;
                        Description->PropTypeSet.Flags = 0;
                        Description->MembersListCount = 0;
                        Irp->IoStatus.Information = sizeof(*Description);
                    } else {
                        ULONG MembersListCount;
                        const KSPROPERTY_MEMBERSLIST* MembersList;
                        ULONG DescriptionSize;

                        //
                        // First figure out how large of a buffer is needed for
                        // the full description. This size is always placed in
                        // the description header.
                        //
                        DescriptionSize = sizeof(*Description);
                        for (MembersListCount = PropertyItem->Values->MembersListCount, 
                                MembersList = PropertyItem->Values->MembersList; 
                             MembersListCount; 
                             MembersListCount--, MembersList++) {
                            //
                            // Only count the size of a default value if the query
                            // is for default values. Else return ranges.
                            //
                            if (MembersList->MembersHeader.Flags & KSPROPERTY_MEMBER_FLAG_DEFAULT) {
                                if (Flags == KSPROPERTY_TYPE_DEFAULTVALUES) {
                                    DescriptionSize += (sizeof(KSPROPERTY_MEMBERSHEADER) + MembersList->MembersHeader.MembersSize);
                                }
                            } else if (Flags == KSPROPERTY_TYPE_BASICSUPPORT) {
                                DescriptionSize += (sizeof(KSPROPERTY_MEMBERSHEADER) + MembersList->MembersHeader.MembersSize);
                            }
                        }
                        Description->DescriptionSize = DescriptionSize;
                        Description->PropTypeSet = PropertyItem->Values->PropTypeSet;
                        Description->MembersListCount = PropertyItem->Values->MembersListCount;
                        if (OutputBufferLength == sizeof(*Description)) {
                            //
                            // If this was just a query for the header, return it.
                            //
                            Irp->IoStatus.Information = sizeof(*Description);
                        } else if (OutputBufferLength < DescriptionSize) {
                            //
                            // If the UserBuffer was too small, then exit.
                            //
                            return STATUS_BUFFER_TOO_SMALL;
                        } else {
                            PVOID Values;

                            //
                            // Else the UserBuffer was large enough for the entire
                            // description, so serialize it into the buffer.
                            //
                            Values = Description + 1;
                            for (MembersListCount = PropertyItem->Values->MembersListCount, 
                                    MembersList = PropertyItem->Values->MembersList; 
                                 MembersListCount; 
                                 MembersListCount--, MembersList++) {
                                //
                                // Only copy a default value if default values are being
                                // requested. Else copy a range.
                                //
                                if (((MembersList->MembersHeader.Flags & KSPROPERTY_MEMBER_FLAG_DEFAULT) &&
                                     (Flags == KSPROPERTY_TYPE_DEFAULTVALUES)) ||
                                    (!(MembersList->MembersHeader.Flags & KSPROPERTY_MEMBER_FLAG_DEFAULT) &&
                                     (Flags == KSPROPERTY_TYPE_BASICSUPPORT))) {
                                    *(PKSPROPERTY_MEMBERSHEADER)Values = MembersList->MembersHeader;
                                    (PUCHAR)Values += sizeof(KSPROPERTY_MEMBERSHEADER);
                                    RtlCopyMemory(Values, MembersList->Members, MembersList->MembersHeader.MembersSize);
                                    (PUCHAR)Values += MembersList->MembersHeader.MembersSize;
                                }
                            }
                            Irp->IoStatus.Information = DescriptionSize;
                        }
                    }
                } else {
                    //
                    // Only the access flags can be returned.
                    //
                    Irp->IoStatus.Information = sizeof(Description->AccessFlags);
                }
                //
                // If the query succeeded, and the handler wants to do
                // some post-processing, then pass along the request
                // again. The support handler knows that this is the
                // post-processing query because Irp->IoStatus.Information
                // is non-zero.
                //
                if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
                    return PropertyItem->SupportHandler(Irp, Property, UserBuffer);
                }
                return STATUS_SUCCESS;
            }
            //
            // Attempt to locate the property item within the set already found.
            //
            if (!(PropertyItem = FindPropertyItem(PropertySet, LocalPropertyItemSize, Property->Id))) {
                break;
            }
            if ((InputBufferLength < PropertyItem->MinProperty) || 
                (OutputBufferLength < PropertyItem->MinData)) {
                return STATUS_BUFFER_TOO_SMALL;
            }
            //
            // Some filters want to do their own processing, so a pointer to
            // the set is placed in any IRP forwarded.
            //
            KSPROPERTY_SET_IRP_STORAGE(Irp) = PropertySet;
            //
            // Optionally provide property item context.
            //
            if (PropertyItemSize) {
                KSPROPERTY_ITEM_IRP_STORAGE(Irp) = PropertyItem;
            }
            if (Flags == KSPROPERTY_TYPE_GET) {
                //
                // If there is no Get handler for this property, then it cannot be
                // read, therefore it cannot be found.
                //
                if (!PropertyItem->GetPropertyHandler) {
                    break;
                }
                //
                // Initialize the return size to the minimum required buffer
                // length. For most properties, which are fixed length, this
                // means that the return size has already been set up for
                // them. Variable length properties obviously must always set
                // the return size. On a failure, the return size is ignored.
                //
                Irp->IoStatus.Information = PropertyItem->MinData;
                return PropertyItem->GetPropertyHandler(Irp, Property, UserBuffer);
            } else {
                //
                // If there is no Set handler for this property, then it cannot be
                // written, therefore it cannot be found.
                //
                if (!PropertyItem->SetPropertyHandler) {
                    break;
                }
                return PropertyItem->SetPropertyHandler(Irp, Property, UserBuffer);
            }
        }
    }
    //
    // The outer loop looking for property sets fell through with no match. This may
    // indicate that this is a support query for the list of all property sets
    // supported.
    //
    if (!RemainingSetsCount) {
        //
        // Specifying a GUID_NULL as the set means that this is a support query
        // for all sets.
        //
        if (!IsEqualGUIDAligned(&Property->Set, &GUID_NULL)) {
            return STATUS_PROPSET_NOT_FOUND;
        }
        //
        // The support flag must have been used so that the IRP_INPUT_OPERATION
        // is set. For future expansion, the identifier within the set is forced
        // to be zero.
        //
        if (Property->Id || (Flags != KSPROPERTY_TYPE_SETSUPPORT)) {
            return STATUS_INVALID_PARAMETER;
        }
        //
        // The query can request the length of the needed buffer, or can
        // specify a buffer which is at least long enough to contain the
        // complete list of GUID's.
        //
        if (!OutputBufferLength) {
            //
            // Return the size of the buffer needed for all the GUID's.
            //
            Irp->IoStatus.Information = PropertySetsCount * sizeof(GUID);
            return STATUS_BUFFER_OVERFLOW;
#ifdef SIZE_COMPATIBILITY
        } else if (OutputBufferLength == sizeof(OutputBufferLength)) {
            *(PULONG)Irp->AssociatedIrp.SystemBuffer = PropertySetsCount * sizeof(GUID);
            Irp->IoStatus.Information = sizeof(OutputBufferLength);
            return STATUS_SUCCESS;
#endif // SIZE_COMPATIBILITY
        } else if (OutputBufferLength < PropertySetsCount * sizeof(GUID)) {
            //
            // The buffer was too short for all the GUID's.
            //
            return STATUS_BUFFER_TOO_SMALL;
        } else {
            GUID* Guid;

            Irp->IoStatus.Information = PropertySetsCount * sizeof(*Guid);
            PropertySet -= PropertySetsCount;
            for (Guid = (GUID*)UserBuffer; 
                 PropertySetsCount; Guid++, PropertySet++, 
                 PropertySetsCount--)
                *Guid = *PropertySet->Set;
        }
        return STATUS_SUCCESS;
    }
    return STATUS_NOT_FOUND;
}


const KSFASTPROPERTY_ITEM*
FASTCALL
FindFastPropertyItem(
    IN const KSPROPERTY_SET* PropertySet,
    IN ULONG PropertyId
    )
/*++

Routine Description:

    Given a property set structure locates the specified fast property item.

Arguments:

    PropertySet -
        Points to the property set to search.

    PropertyId -
        Contains the fast property identifier to look for.

Return Value:

    Returns a pointer to the fast property identifier structure, or NULL if it
    could not be found.

--*/
{
    const KSFASTPROPERTY_ITEM* FastPropertyItem;
    ULONG PropertiesCount;

    FastPropertyItem = PropertySet->FastIoTable;
    for (PropertiesCount = PropertySet->FastIoCount; 
         PropertiesCount; 
         PropertiesCount--, FastPropertyItem++) {
        if (PropertyId == FastPropertyItem->PropertyId) {
            return FastPropertyItem;
        }
    }
    return NULL;
}


KSDDKAPI
BOOLEAN
NTAPI
KsFastPropertyHandler(
    IN PFILE_OBJECT FileObject,
    IN PKSPROPERTY Property,
    IN ULONG PropertyLength,
    IN OUT PVOID Data,
    IN ULONG DataLength,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN ULONG PropertySetsCount,
    IN const KSPROPERTY_SET* PropertySet
    )
/*++

Routine Description:

    Handles properties requested through the fast I/O interface. Does not deal
    with property information support, just the properties themselves. In the
    former case, the function returns FALSE, which allows the caller to
    generate an IRP to deal with the request. The function also does not deal
    with extended property items. This function may only be called at
    PASSIVE_LEVEL.

Arguments:

    FileObject -
        The file object on which the request is being made.

    Property -
        The property to query or set. Must be LONG aligned.

    PropertyLength -
        The length of the Property parameter.

    Data -
        The associated buffer for the query or set, in which the data is
        returned or placed.

    DataLength -
        The length of the Data parameter.

    IoStatus -
        Return status.

    PropertySetsCount -
        Indicates the number of property set structures being passed.

    PropertySet -
        Contains the pointer to the list of property set information.

Return Value:

    Returns TRUE if the request was handled, else FALSE if an IRP must be
    generated. Sets the Information and Status in IoStatus.

--*/
{
    KPROCESSOR_MODE ProcessorMode;
    KSPROPERTY LocalProperty;
    ULONG RemainingSetsCount;

    PAGED_CODE();
    //
    // Initially just check for the minimal property parameter length. The
    // actual minimal length will be validated when the property item is found.
    //
    if (PropertyLength < sizeof(LocalProperty)) {
        return FALSE;
    }
    ProcessorMode = ExGetPreviousMode();
    //
    // Validate the property if the client is not trusted, then capture it.
    //
    if (ProcessorMode != KernelMode) {
        try {
            ProbeForRead(Property, PropertyLength, sizeof(ULONG));
            LocalProperty = *Property;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return FALSE;
        }
    } else {
        LocalProperty = *Property;
    }
    //
    // Must use the normal property handler for support queries.
    //
    if (LocalProperty.Flags & KSIDENTIFIER_SUPPORTMASK) {
        return FALSE;
    }
    for (RemainingSetsCount = PropertySetsCount; RemainingSetsCount; PropertySet++, RemainingSetsCount--) {
        if (IsEqualGUIDAligned(&LocalProperty.Set, PropertySet->Set)) {
            const KSFASTPROPERTY_ITEM* FastPropertyItem;
            const KSPROPERTY_ITEM* PropertyItem;

            //
            // Once the property set is found, determine if there is fast
            // I/O support for that property item.
            //
            if (!(FastPropertyItem = FindFastPropertyItem(PropertySet, LocalProperty.Id))) {
                return FALSE;
            }
            //
            // If there is fast I/O support, then the real property item needs to
            // be located in order to validate the parameter sizes.
            //
            if (!(PropertyItem = FindPropertyItem(PropertySet, sizeof(*PropertyItem), LocalProperty.Id))) {
                return FALSE;
            }
            if ((PropertyLength < PropertyItem->MinProperty) || 
                (DataLength < PropertyItem->MinData)) {
                return FALSE;
            }
            if ((LocalProperty.Flags & ~KSPROPERTY_TYPE_TOPOLOGY) == KSPROPERTY_TYPE_GET) {
                if (!FastPropertyItem->GetPropertyHandler) {
                    return FALSE;
                }
                //
                // Validate the data if the client is not trusted.
                //
                if (ProcessorMode != KernelMode) {
                    try {
                        ProbeForWrite(Data, DataLength, sizeof(BYTE));
                    } 
                    except (EXCEPTION_EXECUTE_HANDLER) {
                        return FALSE;
                    }
                }
                //
                // The bytes returned is always assumed to be initialized by the handler.
                //
                IoStatus->Information = PropertyItem->MinProperty;
                return FastPropertyItem->GetPropertyHandler(
                    FileObject,
                    Property,
                    PropertyLength,
                    Data,
                    DataLength,
                    IoStatus);
            } else if ((LocalProperty.Flags & ~KSPROPERTY_TYPE_TOPOLOGY) == KSPROPERTY_TYPE_SET) {
                if (!FastPropertyItem->SetPropertyHandler) {
                    break;
                }
                //
                // Validate the data if the client is not trusted.
                //
                if (ProcessorMode != KernelMode) {
                    try {
                        ProbeForRead(Data, DataLength, sizeof(BYTE));
                    } 
                    except (EXCEPTION_EXECUTE_HANDLER) {
                        return FALSE;
                    }
                }
                IoStatus->Information = 0;
                return FastPropertyItem->SetPropertyHandler(
                    FileObject, 
                    Property,
                    PropertyLength, 
                    Data, 
                    DataLength, 
                    IoStatus);
            } else {
                break;
            }
        }
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\ks\shdevice.cpp ===
/*++

    Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    shdevice.c

Abstract:

    This module contains the filter  device implementation.

Author:

    Dale Sather (dalesat) 31-Jul-1998

--*/

#ifndef __KDEXT_ONLY__
#include "ksp.h"
#include <kcom.h>
#include <wdmguid.h>
#endif // __KDEXT_ONLY__

//ia64 does not like these in pageconst !!??
const WCHAR EnumString[] = L"Enum";
const WCHAR PnpIdString[] = L"PnpId";

//
// To make the bus enumeration code more readable:
//
//    AVSTREAM_BUSENUM_STRING: The prepended enumerator string
//    AVSTREAM_BUSENUM_STRING_LENGTH: The length of the above string in WCHARS
//    AVSTREAM_BUSENUM_SEPARATOR_LENGTH: The length of the separator "#" string
//                                       in WCHARS
//
#define AVSTREAM_BUSENUM_STRING L"AVStream\\"
#define AVSTREAM_BUSENUM_STRING_LENGTH \
    ((sizeof (AVSTREAM_BUSENUM_STRING) - 1) / sizeof (WCHAR))
#define AVSTREAM_BUSENUM_SEPARATOR_LENGTH 1

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")

#endif // ALLOC_DATA_PRAGMA

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA

//
// To support bus driver, put this struct right in the device extension
//
typedef struct _KSPDO_EXTENSION
{
    #define KS_PDO_SIGNATURE    'DPSK'  // KSPD sufficent to distinguish from FDO
    ULONG          m_PdoSignature;      // must be KS_PDO_SIGNATURE
    LONG           m_nOpenCount;
    PDEVICE_OBJECT m_pParentFdo;        // parent FDO enumerate me
    PDEVICE_OBJECT m_pNextPdo;          // my sibling, NULL terminated
    PDEVICE_OBJECT m_pMyPdo;            // my sibling, NULL terminated
    PWCHAR         m_pwcDeviceName;     // device name
    ULONG          m_ulDeviceIndex;     // instance id
    BOOLEAN        m_MarkedDelete;      // Is me makred inactive
} KSPDO_EXTENSION, *PKSPDO_EXTENSION;

typedef struct _ARBITER_CALLBACK_CONTEXT {

    PVOID Device;
    PDRIVER_CONTROL ClientCallback;
    PVOID ClientContext;

} ARBITER_CALLBACK_CONTEXT, *PARBITER_CALLBACK_CONTEXT;

//
// CKsDevice is the implementation of the  device.
//
class CKsDevice:
    public IKsDevice,
    public CBaseUnknown
{
#ifndef __KDEXT_ONLY__
private:
#else // __KDEXT_ONLY__
public:
#endif // __KDEXT_ONLY__
    KSDEVICE_EXT m_Ext;
    KSIDEVICEBAG m_DeviceBag;
    KSIOBJECTBAG m_ObjectBag;
    KMUTEX m_Mutex;
    WORK_QUEUE_ITEM m_PostPnpStartWorkItem;
    WORK_QUEUE_ITEM m_CloseWorkItem;
    INTERLOCKEDLIST_HEAD m_CloseIrpList;
    INTERLOCKEDLIST_HEAD m_PendingCreateIrpList;
    INTERLOCKEDLIST_HEAD m_PendingRunIrpList;
    PADAPTER_OBJECT m_AdapterObject;
    BUS_INTERFACE_STANDARD m_BusInterfaceStandard;
    ULONG m_MaxMappingByteCount;
    ULONG m_MappingTableStride;
    DEVICE_POWER_STATE m_DeviceStateMap[PowerSystemMaximum];
    LIST_ENTRY m_PowerNotifyList;
    KMUTEX m_PowerNotifyMutex;
    ULONG m_ActivePinCount;
    PVOID m_SystemStateHandle;
    BOOLEAN m_CreatesMayProceed;
    BOOLEAN m_RunsMayProceed;
    BOOLEAN m_IsParentFdo;              // to support bus driver

    //
    // If this is false, streaming I/O requests will fail with
    // STATUS_INVALID_DEVICE_REQUEST.
    //
    BOOLEAN m_AllowIo;

    //
    // NOTE: This is temporary until the Pnp code gets overhauled.
    //
    BOOLEAN m_FailCreates;

    //
    // Adapter object arbitration.
    //
    KSPIN_LOCK m_AdapterArbiterLock;
    LONG m_AdapterArbiterOutstandingAllocations;
    ARBITER_CALLBACK_CONTEXT m_ArbiterContext;


public:
    BOOLEAN m_ChildEnumedFromRegistry;  // to support bus driver
    PDEVICE_OBJECT m_pNextChildPdo;     // to support bus driver
    DEFINE_STD_UNKNOWN();
    IMP_IKsDevice;
    DEFINE_FROMSTRUCT(CKsDevice,PKSDEVICE,m_Ext.Public);

    __inline
    static
    CKsDevice *
    FromDeviceObject(
        IN PDEVICE_OBJECT DeviceObject
        );

    CKsDevice(PUNKNOWN OuterUnknown);
    ~CKsDevice();

    NTSTATUS
    GetBusInterfaceStandard(
        );
    NTSTATUS
    Init(
        IN PDEVICE_OBJECT FunctionalDeviceObject,
        IN PDEVICE_OBJECT PhysicalDeviceObject,
        IN PDEVICE_OBJECT NextDeviceObject,
        IN const KSDEVICE_DESCRIPTOR* Descriptor
        );
    static
    NTSTATUS
    ForwardIrpCompletionRoutine(
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp,
        IN PVOID Context
        );
    NTSTATUS
    ForwardIrpSynchronous(
        IN PIRP Irp
        );
    NTSTATUS
    CompleteIrp(
        IN PIRP Irp,
        IN NTSTATUS Status
        );
    static
    NTSTATUS
    DispatchPnp(
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
        );
    static
    NTSTATUS
    DispatchPower(
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
        );
    static
    void
    RequestPowerIrpCompletion(
        IN PDEVICE_OBJECT DeviceObject,
        IN UCHAR MinorFunction,
        IN POWER_STATE PowerState,
        IN PVOID Context,
        IN PIO_STATUS_BLOCK IoStatus
        );
    static
    void
    PostPnpStartWorker(
        IN PVOID Context
        );
    static
    void
    CloseWorker(
        IN PVOID Context
        );
    static
    IO_ALLOCATION_ACTION
    ArbitrateAdapterCallback (
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Reserved,
        IN PVOID MapRegisterBase,
        IN PVOID Context
        );
    NTSTATUS
    PnpStart(
        IN PIRP Irp
        );
    void
    PnpStop(
        IN PIRP Irp
        );
    NTSTATUS
    PnpQueryCapabilities(
        IN PIRP Irp
        );
    static
    NTSTATUS
    DispatchCreate(
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
        );
    void
    QueuePendedClose(
        IN PIRP Irp
        );
    void
    RedispatchPendingCreates(
        void
        );
    void
    RedispatchPendingRuns(
        void
        );
    void
    RegisterAdapterObject(
        IN PADAPTER_OBJECT AdapterObject,
        IN ULONG MaxMappingByteCount,
        IN ULONG MappingTableStride
        )
    {
        ASSERT(AdapterObject);
        ASSERT(MaxMappingByteCount);
        ASSERT((MaxMappingByteCount & FILE_QUAD_ALIGNMENT) == 0);
        ASSERT(MappingTableStride);
        ASSERT((MappingTableStride & FILE_QUAD_ALIGNMENT) == 0);

        m_AdapterObject = AdapterObject;
        m_MaxMappingByteCount = MaxMappingByteCount;
        m_MappingTableStride = MappingTableStride;
    }
    static
    NTSTATUS
    GetSetBusDataIrpCompletionRoutine(
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp,
        IN PVOID Context
    );
    ULONG
    GetSetBusDataIrp(
        IN ULONG DataType,
        IN PVOID Buffer,
        IN ULONG Offset,
        IN ULONG Length,
        IN BOOLEAN GetRequest
    );
    //
    // Millennium bus drivers currently do not support QUERY_INTERFACE
    // Irps; thus, this interface will never be acquired
    // and hardware drivers will not be able to access the bus.
    //
    // If the interface has been acquired, use it; otherwise, send the request
    // via an Irp.
    //
    ULONG
    __inline
    SetBusData(
        IN ULONG DataType,
        IN PVOID Buffer,
        IN ULONG Offset,
        IN ULONG Length
        );

    ULONG
    __inline
    GetBusData(
        IN ULONG DataType,
        IN PVOID Buffer,
        IN ULONG Offset,
        IN ULONG Length
        );

    //
    // To support bus driver
    //
    
    NTSTATUS EnumerateChildren(PIRP Irp);
    NTSTATUS CreateChildPdo(IN PWCHAR PnpId, IN ULONG InstanceNumber);

#if DBG
    friend BOOLEAN KspIsDeviceMutexAcquired (
    IN PIKSDEVICE Device
        );
#endif // DBG

};

#ifndef __KDEXT_ONLY__

IMPLEMENT_STD_UNKNOWN(CKsDevice)
IMPLEMENT_GETSTRUCT(CKsDevice,PKSDEVICE);


NTSTATUS
GetRegistryValue(
    IN HANDLE Handle,
    IN PWCHAR KeyNameString,
    IN ULONG KeyNameStringLength,
    IN PVOID Data,
    IN ULONG DataLength
    )
/*++

Routine Description:

    Reads the specified registry value

Arguments:

    Handle - handle to the registry key
    KeyNameString - value to read
    KeyNameStringLength - length of string
    Data - buffer to read data into
    DataLength - length of data buffer

Return Value:

    NTSTATUS returned as appropriate

--*/
{
    NTSTATUS        Status = STATUS_INSUFFICIENT_RESOURCES;
    UNICODE_STRING  KeyName;
    ULONG           Length;
    PKEY_VALUE_FULL_INFORMATION FullInfo;

    PAGED_CODE();

    RtlInitUnicodeString(&KeyName, KeyNameString);

    Length = sizeof(KEY_VALUE_FULL_INFORMATION) + KeyNameStringLength + DataLength;

    FullInfo = (PKEY_VALUE_FULL_INFORMATION)ExAllocatePool(PagedPool, Length);

    if (FullInfo) {
        Status = ZwQueryValueKey(Handle,
                                 &KeyName,
                                 KeyValueFullInformation,
                                 FullInfo,
                                 Length,
                                 &Length);

        if (NT_SUCCESS(Status)) {

            if (DataLength >= FullInfo->DataLength) {
                RtlCopyMemory(Data,
                              ((PUCHAR) FullInfo) + FullInfo->DataOffset,
                              FullInfo->DataLength);

            } else {

                Status = STATUS_BUFFER_TOO_SMALL;
            }
        }
        ExFreePool(FullInfo);

    }
    return Status;
}

NTSTATUS
CKsDevice::CreateChildPdo(
    IN PWCHAR PnpId,
    IN ULONG InstanceNumber
    )
/*++

Routine Description:

    Called to create a PDO for a child device.

Arguments:

    PnpId - ID of device to create

    ChildNode - node for the device

Return Value:

    Status is returned.

--*/
{
    PDEVICE_OBJECT  ChildPdo;
    NTSTATUS        Status;
    PWCHAR          NameBuffer;
    PKSPDO_EXTENSION pKsPdoExtension;

    PAGED_CODE();

    //
    // create a PDO for the child device.
    //

    Status = IoCreateDevice(m_Ext.Public.FunctionalDeviceObject->DriverObject,
                            sizeof(KSPDO_EXTENSION),
                            NULL,
                            FILE_DEVICE_UNKNOWN,
                            FILE_AUTOGENERATED_DEVICE_NAME | FILE_DEVICE_SECURE_OPEN,
                            FALSE,
                            &ChildPdo);

    if (!NT_SUCCESS(Status)) {
        _DbgPrintF(DEBUGLVL_ERROR,("[CreateChildPdo failed]"));
        return Status;
    }

    //
    // set the stack size to be the # of stacks used by the FDO.
    //

    ChildPdo->StackSize = m_Ext.Public.FunctionalDeviceObject->StackSize+1;

    //
    // Initialize fields in the ChildDeviceExtension.
    //

    pKsPdoExtension = (PKSPDO_EXTENSION)ChildPdo->DeviceExtension;
    pKsPdoExtension->m_PdoSignature = KS_PDO_SIGNATURE;
    pKsPdoExtension->m_pMyPdo = ChildPdo;
    pKsPdoExtension->m_nOpenCount = 0;
    pKsPdoExtension->m_MarkedDelete = FALSE;
    pKsPdoExtension->m_pParentFdo = m_Ext.Public.FunctionalDeviceObject;
    pKsPdoExtension->m_pNextPdo = m_pNextChildPdo;
    pKsPdoExtension->m_ulDeviceIndex = InstanceNumber;

    m_pNextChildPdo = ChildPdo;
    pKsPdoExtension->m_pwcDeviceName = NULL;
    
    //
    // create a new string for the device name and save it away in the device
    // extension.   BUGBUG - I spent about 4 hours trying to find a way to
    // get unicode strings to work with this.   If you ask me why I didn't
    // use a unicode string, I will taunt you and #%*&# in your general
    // direction.
    //

    if (NameBuffer = (PWCHAR)ExAllocatePool(PagedPool, wcslen(PnpId) * 2 + 2)) {
        wcscpy(NameBuffer, PnpId);

        //
        // save the device name pointer. this is freed when the device is removed.
        //

        pKsPdoExtension->m_pwcDeviceName = NameBuffer;
    }

    ChildPdo->Flags |= DO_POWER_PAGABLE;
    ChildPdo->Flags &= ~DO_DEVICE_INITIALIZING;
    return Status;
}

NTSTATUS
CKsDevice::EnumerateChildren(
    PIRP Irp
    )
/*++

Description:

    To ease mini driver writer to write a driver for a device with
    children. We offer this easy way of putting child device names
    at the registry. This is somewhat static but still allows inf file
    to change the child device list. It is easy and suffecient for
    most cases. The optimal solution is for the mini driver to really
    scan the bus for devices at run time.

    Device mutex must be acquire before calling this function.


Argument:

--*/
{
    #define MAX_STRING_LENGTH 256
    BYTE           PnpId[MAX_STRING_LENGTH];
    PDEVICE_RELATIONS DeviceRelations = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS        Status;
    HANDLE          ParentKey, RootKey, ChildKey;
    UNICODE_STRING  UnicodeEnumName;
    ULONG           NumberOfChildren, RelationsSize;
    PDEVICE_OBJECT  *ChildPdo;

    PDEVICE_OBJECT pNextChildPdo;
    PKSPDO_EXTENSION pKsPdoExtension;

    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB,("[EnumChildren]%x %s\n",
                m_Ext.Public.FunctionalDeviceObject,
                m_ChildEnumedFromRegistry ? "has enumed":"1st Time"));

    if ( !m_ChildEnumedFromRegistry ) {

        //
        // we haven't enumerated children from the registry do it now.
        //

        Status = IoOpenDeviceRegistryKey(m_Ext.Public.PhysicalDeviceObject,
                                         PLUGPLAY_REGKEY_DRIVER,
                                         STANDARD_RIGHTS_ALL,
                                         &ParentKey);

        m_ChildEnumedFromRegistry = TRUE;
        
        if (!NT_SUCCESS(Status)) {
            _DbgPrintF(DEBUGLVL_ERROR,("[EnumChildren] couldn't open registry\n"));
            return STATUS_NOT_IMPLEMENTED;

        }
        //
        // create the subkey for the enum section, in the form "\enum"
        //

        RtlInitUnicodeString(&UnicodeEnumName, EnumString);

        //
        // read the registry to determine if children are present.
        //

        InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeEnumName,
                               OBJ_CASE_INSENSITIVE,
                               ParentKey,
                               NULL);

        Status = ZwOpenKey(&RootKey, KEY_READ, &ObjectAttributes);
        
        if (!NT_SUCCESS(Status)) {

            ZwClose(ParentKey);
            return Status;
        }

        //
        // Loop through all the values until either no more entries exist, or an
        // error occurs.
        //

        for (NumberOfChildren = 0;; NumberOfChildren++) {

            ULONG           BytesReturned;
            PKEY_BASIC_INFORMATION BasicInfoBuffer;
            KEY_BASIC_INFORMATION BasicInfoHeader;

            //
            // Retrieve the value size.
            //

            Status = ZwEnumerateKey(
                                RootKey,
                                NumberOfChildren,
                                KeyBasicInformation,
                                &BasicInfoHeader,
                                sizeof(BasicInfoHeader),
                                &BytesReturned);

            if ((Status != STATUS_BUFFER_OVERFLOW) && !NT_SUCCESS(Status)) {

                //
                // exit the loop, as we either had an error or reached the end
                // of the list of keys.
                //

                break;
            }

            //
            // Allocate a buffer for the actual size of data needed.
            //

            BasicInfoBuffer = (PKEY_BASIC_INFORMATION)
                                ExAllocatePool(PagedPool, BytesReturned);

            if (!BasicInfoBuffer) {
                break;
            }
            //
            // Retrieve the name of the nth child device
            //

            Status = ZwEnumerateKey(
                                RootKey,
                                NumberOfChildren,
                                KeyBasicInformation,
                                BasicInfoBuffer,
                                BytesReturned,
                                &BytesReturned);

            if (!NT_SUCCESS(Status)) {

                ExFreePool(BasicInfoBuffer);
                break;

            }
            //
            // build object attributes for the key, & try to open it.
            //

            UnicodeEnumName.Length = (USHORT) BasicInfoBuffer->NameLength;
            UnicodeEnumName.MaximumLength = (USHORT) BasicInfoBuffer->NameLength;
            UnicodeEnumName.Buffer = (PWCHAR) BasicInfoBuffer->Name;

            InitializeObjectAttributes(&ObjectAttributes,
                                   &UnicodeEnumName,
                                   OBJ_CASE_INSENSITIVE,
                                   RootKey,
                                   NULL);

            Status = ZwOpenKey(&ChildKey, KEY_READ, &ObjectAttributes);

            if (!NT_SUCCESS(Status)) {

                ExFreePool(BasicInfoBuffer);
                break;
            }

            //
            // we've now opened the key for the child.  We next read in the PNPID
            // value, and if present, create a PDO of that name.
            //

            Status = GetRegistryValue(ChildKey,
                                      (PWCHAR) PnpIdString,
                                      sizeof(PnpIdString),
                                      PnpId,
                                      MAX_STRING_LENGTH);

            if (!NT_SUCCESS(Status)) {

                ExFreePool(BasicInfoBuffer);
                ZwClose(ChildKey);
                break;
            }

            //
            // create a PDO representing the child.
            //

            Status = CreateChildPdo((PWCHAR)PnpId,
                                    NumberOfChildren);

            //
            // free the Basic info buffer and close the child key
            //

            ExFreePool(BasicInfoBuffer);
            ZwClose(ChildKey);

            if (!NT_SUCCESS(Status)) {

                //
                // break out of the loop if we could not create the PDO
                //
                _DbgPrintF(DEBUGLVL_ERROR,("[CreateChildPdo failed]"));
                break;
            }
        }

        //
        // close the root and parent keys and free the ID buffer
        //

        ZwClose(RootKey);
        ZwClose(ParentKey);

        //
        // we now have processed all children, and have a linked list of
        // them.
        //

        if (!NumberOfChildren) {

            //
            // if no children, just return not supported.  this means that the
            // device did not have children.
            //

            return (STATUS_NOT_IMPLEMENTED);

        }
        m_IsParentFdo = TRUE;
    }

    else {

        //
        // count children which are not marked delete pending
        //

        pNextChildPdo = m_pNextChildPdo;
        NumberOfChildren = 0;

        while ( NULL != pNextChildPdo ) {

            pKsPdoExtension = (PKSPDO_EXTENSION)(pNextChildPdo->DeviceExtension);

            if (!pKsPdoExtension->m_MarkedDelete){
                NumberOfChildren++;
            }

            pNextChildPdo = pKsPdoExtension->m_pNextPdo;
        }
    }

    //
    // Allocate the device relations buffer. This will be freed by the caller.
    //

    RelationsSize = sizeof(DEVICE_RELATIONS) + (NumberOfChildren * sizeof(PDEVICE_OBJECT));

    DeviceRelations = (PDEVICE_RELATIONS)ExAllocatePool(PagedPool, RelationsSize);

    if (DeviceRelations == NULL) {

        //
        // return, but keep the list of children allocated.
        //

        _DbgPrintF(DEBUGLVL_ERROR,("[EnumChildren] Failed to allocate Relation"));
        return STATUS_INSUFFICIENT_RESOURCES;

    }

    RtlZeroMemory(DeviceRelations, RelationsSize);

    //
    // Walk our chain of children, and initialize the relations
    //

    ChildPdo = &(DeviceRelations->Objects[0]);

    //
    // get the 1st child from the parent device extension anchor
    //

    pNextChildPdo = m_pNextChildPdo;
    
    while ( NULL != pNextChildPdo ) {

        pKsPdoExtension = (PKSPDO_EXTENSION)(pNextChildPdo->DeviceExtension);

        _DbgPrintF(DEBUGLVL_BLAB,("Enumed Child DevObj %x%s marked delete\n",
                    pNextChildPdo,
                    pKsPdoExtension->m_MarkedDelete ? "" : " not"));

        if ( pKsPdoExtension->m_MarkedDelete ) {
            pNextChildPdo = pKsPdoExtension->m_pNextPdo;
            continue;
        }

        *ChildPdo = pNextChildPdo;
        pNextChildPdo = pKsPdoExtension->m_pNextPdo;

        //
        // per DDK doc we need to inc ref count
        //
        ObReferenceObject( *ChildPdo );

        ChildPdo++;

    }                           // while Children


    DeviceRelations->Count = NumberOfChildren;

    //
    // Stuff that pDeviceRelations into the IRP and return SUCCESS.
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = (ULONG_PTR) DeviceRelations;

    return STATUS_SUCCESS;

}



KSDDKAPI
NTSTATUS
NTAPI
KsInitializeDriver(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPathName,
    IN const KSDEVICE_DESCRIPTOR* Descriptor OPTIONAL
    )

/*++

Routine Description:

    This routine initializes the driver object of a client driver.
    It is usually called from the client driver's DriverEntry.  IRP
    dispatch, AddDevice and DriverUnload are all initialized.  An
    optional device descriptor is associated with the driver so it can
    be used at AddDevice time to create a device with the desired
    characteristics.  Clients willing to handle driver initialization
    themselves don't necessarily need to call this function.  Also,
    dispatch functions installed by this function can be replaced after
    this function has completed.

Arguments:

    DriverObject -
        Contains a pointer to the driver object to be initialized.

    RegistryPathName -
        Contains a pointer to the registry path name passed to DriverEntry.

    Descriptor -
        Contains an optional pointer to a device descriptor to be used during
        AddDevice to create a new device.

Return Value:

    STATUS_SUCCESS or an error status from IoAllocateDriverObjectExtension.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsInitializeDriver]"));

    PAGED_CODE();

    ASSERT(DriverObject);
    ASSERT(RegistryPathName);

    //
    // Hang the device descriptor off the driver.
    //
    NTSTATUS status = STATUS_SUCCESS;

    if (Descriptor) {
        PKSDEVICE_DESCRIPTOR* descriptorInExt;
        status =
            IoAllocateDriverObjectExtension(
                DriverObject,
                PVOID(KsInitializeDriver),
                sizeof(*descriptorInExt),
                reinterpret_cast<PVOID*>(&descriptorInExt));

        if (NT_SUCCESS(status)) {
            *descriptorInExt =
                PKSDEVICE_DESCRIPTOR(Descriptor);
        }
    }

    if (NT_SUCCESS(status)) {
        DriverObject->MajorFunction[IRP_MJ_PNP] =
            CKsDevice::DispatchPnp;
        DriverObject->MajorFunction[IRP_MJ_POWER] =
            CKsDevice::DispatchPower;
        DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] =
            KsDefaultForwardIrp;
        DriverObject->DriverExtension->AddDevice = KsAddDevice;
        DriverObject->DriverUnload = KsNullDriverUnload;

        DriverObject->MajorFunction[IRP_MJ_CREATE] =
            CKsDevice::DispatchCreate;
        KsSetMajorFunctionHandler(DriverObject,IRP_MJ_CLOSE);
        KsSetMajorFunctionHandler(DriverObject,IRP_MJ_DEVICE_CONTROL);
    }

    return status;
}


KSDDKAPI
NTSTATUS
NTAPI
KsAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )

/*++

Routine Description:

    This routine is the AddDevice handler for the .  It creates a
    device for use with the .  If a device descriptor is supplied in
    the driver object extension, the described device is created.  Other-
    wise the device is created with default characteristics and no filter
    factories.  If the device descriptor is supplied and it supplies a
    create dispatch function, that function is called.

Arguments:

    DriverObject -
        The driver object of the client driver.

    PhysicalDeviceObject -
        The physical device object.

Return Value:

    STATUS_SUCCESS or an error status from IoCreateDevice or
    KsInitializeDevice.
--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsAddDevice]"));

    PAGED_CODE();

    ASSERT(DriverObject);
    ASSERT(PhysicalDeviceObject);

    //
    // Get the extension.
    //
    PKSDEVICE_DESCRIPTOR* descriptorInExt =
        (PKSDEVICE_DESCRIPTOR *)(
            IoGetDriverObjectExtension(
                DriverObject,
                PVOID(KsInitializeDriver)));

    //
    // Create the device.
    //
    return
        KsCreateDevice(
            DriverObject,
            PhysicalDeviceObject,
            descriptorInExt ? *descriptorInExt : NULL,
            0,
            NULL);
}


KSDDKAPI
NTSTATUS
NTAPI
KsCreateDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN const KSDEVICE_DESCRIPTOR* Descriptor OPTIONAL,
    IN ULONG ExtensionSize OPTIONAL,
    OUT PKSDEVICE* Device OPTIONAL
    )

/*++

Routine Description:

    This routine creates a device for the .  It is called by
    KS's AddDevice handler and may be called by client drivers that
    handle AddDevice themselves.  If a device descriptor is supplied, the
    described device is created.  Otherwise the device is created with
    default characteristics and no filter factories.  If the device
    descriptor is supplied and it supplies a create dispatch function,
    that function is called.

Arguments:

    DriverObject -
        The driver object of the client driver.

    PhysicalDeviceObject -
        The physical device object.

    Descriptor -
        Optional device descriptor describing the device to be created.

    ExtensionSize -
        The size of the device extension.  If this is zero, the default
        extension size is used.  If not, it must be at least
        sizeof(KSDEVICE_HEADER);

    Device -
        Contains an optional pointer to the location at which to deposit
        a pointer to the device.

Return Value:

    STATUS_SUCCESS or an error status from IoCreateDevice or
    KsInitializeDevice.
--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsCreateDevice]"));

    PAGED_CODE();

    ASSERT(DriverObject);
    ASSERT(PhysicalDeviceObject);
    ASSERT((ExtensionSize == 0) || (ExtensionSize >= sizeof(KSDEVICE_HEADER)));

    //
    // Determine the device extension size.
    //
    if (ExtensionSize == 0) {
        ExtensionSize = sizeof(KSDEVICE_HEADER);
    }

    //
    // Create the device.
    //
    PDEVICE_OBJECT FunctionalDeviceObject;
    NTSTATUS status =
        IoCreateDevice(
            DriverObject,
            ExtensionSize,
            NULL,
            FILE_DEVICE_KS,
            FILE_DEVICE_SECURE_OPEN,
            FALSE,
            &FunctionalDeviceObject);

    if (NT_SUCCESS(status)) {
        //
        // Attach to the device stack.
        //
        PDEVICE_OBJECT nextDeviceObject =
            IoAttachDeviceToDeviceStack(
                FunctionalDeviceObject,
                PhysicalDeviceObject);

        if (nextDeviceObject) {
            //
            // Set device bits.
            //
            FunctionalDeviceObject->Flags |= DO_POWER_PAGABLE;

            //
            // Initialize the  device.
            //
            status =
                KsInitializeDevice(
                    FunctionalDeviceObject,
                    PhysicalDeviceObject,
                    nextDeviceObject,
                    Descriptor);
        } else {
            status = STATUS_DEVICE_REMOVED;
        }

        if (NT_SUCCESS(status)) {
            //
            // Indicate the device is initialized.
            //
            FunctionalDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
            if (Device) {
                *Device = KsGetDeviceForDeviceObject(FunctionalDeviceObject);
            }
        } else {
            //
            // Clean up on failure.
            //
            if (nextDeviceObject) {
                IoDetachDevice(nextDeviceObject);
            }
            IoDeleteDevice(FunctionalDeviceObject);
        }
    }

    return status;
}


NTSTATUS
CKsDevice::
GetSetBusDataIrpCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

    Routine Description:

        Completion routine for GetBusDataIrp's sending an irp
        down to the bus to read or write config space.

    Arguments:

    Return Value:

--*/

{

    ASSERT (DeviceObject);
    ASSERT (Irp);
    ASSERT (Context);

    KeSetEvent(PKEVENT(Context), IO_NO_INCREMENT, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;

}


ULONG
CKsDevice::
GetSetBusDataIrp(
    IN ULONG DataType,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length,
    IN BOOLEAN GetRequest
    )

/*++

    Routine Description:

        Get or set bus data in config space.  Since the Millennium PCI
        bus drivers do not yet support processing of WDM Irp's, the
        query interface for the standard bus interface will fail, and
        any Ks2.0 driver will fail to load under Millennium.  If this
        is the case, we ignore the failure and send read / write requests
        via Irp instead of using the standard bus interface.

        NOTE: The major disadvantage of this is that you cannot touch
        bus data at Irql > PASSIVE_LEVEL if the interface hasn't been
        acquired.  A W2K Ks2.0 driver can get and set bus data at
        DISPATCH_LEVEL.  The same driver attempting to run under
        Millennium will assert since sending this Irp then is not valid.

    Arguments:

        DataType -
            The space into which we're writing or reading

        Buffer -
            The buffer we're writing from or reading into

        Offset -
            The offset into config space

        Length -
            Number of bytes to read / write

    Return Value:

        Number of bytes read or written.

--*/

{
    PIRP Irp;
    PIO_STACK_LOCATION NextStack;
    NTSTATUS Status;
    KEVENT event;
    ULONG BytesUsed = 0;

    ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);

    Irp = IoAllocateIrp (m_Ext.Public.NextDeviceObject -> StackSize,
        FALSE);
    if (!Irp) {
        return 0;
    }
    KeInitializeEvent(&event, NotificationEvent, FALSE);

    IoSetCompletionRoutine(Irp,
                           GetSetBusDataIrpCompletionRoutine,
                           &event,
                           TRUE,
                           TRUE,
                           TRUE);


    NextStack = IoGetNextIrpStackLocation(Irp);
    ASSERT(NextStack != NULL);
    NextStack -> MajorFunction = IRP_MJ_PNP;
    NextStack -> MinorFunction = GetRequest ? IRP_MN_READ_CONFIG :
        IRP_MN_WRITE_CONFIG;
    NextStack -> Parameters.ReadWriteConfig.WhichSpace = DataType;
    NextStack -> Parameters.ReadWriteConfig.Buffer = Buffer;
    NextStack -> Parameters.ReadWriteConfig.Offset = Offset;
    NextStack -> Parameters.ReadWriteConfig.Length = Length;

    Status = IoCallDriver(m_Ext.Public.NextDeviceObject,
                          Irp);

    if (Status == STATUS_PENDING) {
        KeWaitForSingleObject(
                              &event,
                              Suspended,
                              KernelMode,
                              FALSE,
                              NULL);
    }
    if (NT_SUCCESS(Status)) {

        //
        // Hopefully, NT based OS's won't ever need to get or set bus data
        // via Irp....  Millennium, on the other hand, has bus drivers which
        // don't support the standard interface and must.  They also do not
        // set Irp -> IoStatus.Information to bytes actually read / written,
        // so we must simply return Length because of this.
        //

#ifndef WIN9X_KS
        BytesUsed = (int) Irp -> IoStatus.Information;
#else // WIN9X_KS
        BytesUsed = Length;
#endif // WIN9X_KS

    }
    IoFreeIrp(Irp);

    return BytesUsed;

}

NTSTATUS
EnumGetCaps(
    IN PKSPDO_EXTENSION DeviceExtension,
    OUT PDEVICE_CAPABILITIES Capabilities
    )
/*++

Routine Description:

    Called to get the capabilities of a child
    Copied from stream class.

Arguments:

    DeviceExtension - child device extension
    Capibilities - capabilities structure

Return Value:

    Status is returned.

--*/

{
    ULONG           i;
    PAGED_CODE();

    //
    // fill in the structure with non-controversial values
    //

    Capabilities->SystemWake = PowerSystemUnspecified;
    Capabilities->DeviceWake = PowerDeviceUnspecified;
    Capabilities->D1Latency = 10;
    Capabilities->D2Latency = 10;
    Capabilities->D3Latency = 10;
    Capabilities->LockSupported = FALSE;
    Capabilities->EjectSupported = FALSE;
    Capabilities->Removable = FALSE;
    Capabilities->DockDevice = FALSE;
    Capabilities->UniqueID = FALSE; // set to false so PNP will make us

    for (i = 0; i < PowerSystemMaximum; i++) {
        Capabilities->DeviceState[i] = PowerDeviceD0;

    }

    return STATUS_SUCCESS;
}

NTSTATUS
BuildChildIds (
    IN PDEVICE_OBJECT ParentPDO,
    IN BOOLEAN HardwareIDs,
    IN PWCHAR ChildDeviceName,
    OUT PWCHAR *IDBuffer
    )

/*++

Routine Description:

    Called to build the hardware ID or compatible ID list for a child device.
    This list is built based on the old AVStream\<vendor PnPId> naming
    style as a compatible ID and everything else as a munged version of
    the corresponding parent ID (with child information prepended)

Arguments:

    ParentPDO -
        The PDO of the parent

    HardwareIDs -
        TRUE -
            Build hardware ID list

        FALSE -
            Build compatible ID list

    ChildDeviceName -
        The vendor supplied PnPId which used to be the device ID.

Return Value:

    Success / Failure

--*/

{
    PWCHAR ParentId = NULL;
    PWCHAR ChildId = NULL;
    PWCHAR NameBuffer;
    ULONG ParentIdLength;
    NTSTATUS Status;

    PAGED_CODE();

    //
    // The format for the HWId & CompatId now is going to be:
    //
    // AVStream\<vendor supplied PnPId>#<parent ID (w \ -> # replacement)
    //
    // Since we have no understanding of the format of the ID string
    // (as we can be on any bus) and we cannot simply report the most
    // specific ID, all HWIDs from the parent will need to be munged
    // and reported as child HWIDs.
    //
    Status = IoGetDeviceProperty (
        ParentPDO,
        HardwareIDs ? 
            DevicePropertyHardwareID : DevicePropertyCompatibleIDs,
        0,
        NULL,
        &ParentIdLength
        );

    //
    // If the device has no compat IDs and doesn't return a NULL MULTI-SZ,
    // special case the addition of the old HWID.
    //
    if (Status != STATUS_BUFFER_TOO_SMALL && !HardwareIDs) {

        //
        // Length for: AVStream\<vendor ID>00
        //
        ULONG CompatLength = sizeof (WCHAR) * (
            AVSTREAM_BUSENUM_STRING_LENGTH +
            wcslen (ChildDeviceName)
            ) + 2 * sizeof (UNICODE_NULL);

        NameBuffer = (PWCHAR)ExAllocatePool (PagedPool, CompatLength);
        
        if (!NameBuffer) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        } else {
            RtlZeroMemory (NameBuffer, CompatLength);
            swprintf (
                NameBuffer,
                AVSTREAM_BUSENUM_STRING L"%s",
                ChildDeviceName
                );

            //
            // Double NULL terminated by virtue of the RtlZeroMemory.
            //
            *IDBuffer = NameBuffer;
        }

        return Status;
    }

    while (Status == STATUS_BUFFER_TOO_SMALL) {

        if (ParentId) {
            ExFreePool (ParentId);
        }

        ParentId = 
            (PWCHAR) ExAllocatePool (PagedPool, ParentIdLength);

        if (!ParentId) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        } else {
            Status = IoGetDeviceProperty (
                ParentPDO,
                HardwareIDs ?
                    DevicePropertyHardwareID : DevicePropertyCompatibleIDs,
                ParentIdLength,
                ParentId,
                &ParentIdLength
                );
        }
    }

    if (NT_SUCCESS (Status)) {
        //
        // Count the total string length of all parent ID's, add necessary
        // munging, and allocate a buffer large enough to report back
        // the MULTI_SZ child HWIDs.
        //
        PWCHAR CurCh = ParentId;
        ULONG ParentLength = 0;
        ULONG ParentCount = 0;
        ULONG ChildLength;

        while (*CurCh) {
            for (; *CurCh; CurCh++) {
                //
                // Munge \ into #
                //
                if (*CurCh == L'\\') *CurCh = L'#';
                ParentLength++;
            }
            CurCh++;
            ParentCount++;
        }

        //
        // Account for parent strings total then for adding AVStream\ # NULL
        // for each string then for the <vendor PnPId> for each 
        // string.  The additional wchar is for the extra NULL terminator
        // for the MULTI_SZ.
        //
        ChildLength = sizeof (WCHAR) * (
            ParentLength +
            ParentCount * (
                AVSTREAM_BUSENUM_STRING_LENGTH +
                AVSTREAM_BUSENUM_SEPARATOR_LENGTH +
                1 + /* each NULL terminator for each string of the MULTI_SZ */
                wcslen (ChildDeviceName) 
                )
            ) + sizeof (UNICODE_NULL);

        //
        // If the string is an empty MULTI_SZ, we need a NULL string at the
        // beginning.
        //
        if (!ParentCount) {
            ChildLength += sizeof (UNICODE_NULL);
        }

        //
        // We need the old hardware ID tacked as least ranked compat ID if that
        // is what we are querying.
        //
        if (!HardwareIDs) {
            ChildLength += sizeof (WCHAR) * (
                AVSTREAM_BUSENUM_STRING_LENGTH +
                wcslen (ChildDeviceName) 
                ) + sizeof (UNICODE_NULL);
        }

        ChildId = NameBuffer = (PWCHAR)ExAllocatePool (PagedPool, ChildLength);

        if (!NameBuffer) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }

        if (NT_SUCCESS (Status)) {
            RtlZeroMemory (NameBuffer, ChildLength);
            CurCh = ParentId;

            //
            // Munge each parent ID into a child ID by prefixing the
            // AVStream\<vendor PnPId># string.
            //
            while (ParentCount--) {

                ASSERT (*CurCh != 0);

                _snwprintf (
                    NameBuffer,
                    MAX_DEVICE_ID_LEN - 1,
                    AVSTREAM_BUSENUM_STRING L"%s#%s",
                    ChildDeviceName, 
                    CurCh
                    );

                NameBuffer += wcslen (NameBuffer) + 1;
                CurCh += wcslen (CurCh) + 1;

            }
        }

        //
        // Tack on the old hardware ID if we're reporting the new compat IDs.
        //
        if (!HardwareIDs) {
            swprintf (
                NameBuffer,
                AVSTREAM_BUSENUM_STRING L"%s",
                ChildDeviceName
                );
        }

    }

    if (NT_SUCCESS (Status)) {
        *IDBuffer = ChildId;
    }
    else {
        if (ChildId) ExFreePool (ChildId);
    }

    if (ParentId) {
        ExFreePool (ParentId);
    }

    return Status;

}

NTSTATUS
QueryEnumId(
    IN PDEVICE_OBJECT DeviceObject,
    IN BUS_QUERY_ID_TYPE BusQueryIdType,
    IN OUT PWSTR * BusQueryId
    )
/*++

Routine Description:

    Called to get the ID of a child device
    Copied from stream class

Arguments:

    DeviceObject - device object from child
    QueryIdType - ID type from PNP
    BusQueryId - buffer containing the info requested if successful

Return Value:

    Status is returned.

--*/

{


    PWSTR            NameBuffer = NULL;
    NTSTATUS         Status = STATUS_SUCCESS;
    PKSPDO_EXTENSION DeviceExtension =(PKSPDO_EXTENSION) DeviceObject->DeviceExtension;
    PKSDEVICE Device = KsGetDeviceForDeviceObject (
        DeviceExtension -> m_pParentFdo
        );

    PAGED_CODE();

    //
    // process the query
    //

    switch (BusQueryIdType) {

    case BusQueryDeviceID:
        //
        // In order not to orphan any devices installed prior to changing the
        // format of the hardware ID's, the device ID will continue to be
        // reported as AVStream\<vendor supplied PnPId> (also a CID) while
        // the hardware ID will contain the more specific munged names.
        //
        NameBuffer = (PWCHAR)ExAllocatePool (
            PagedPool,
            sizeof (WCHAR) * (
                AVSTREAM_BUSENUM_STRING_LENGTH +
                wcslen (DeviceExtension -> m_pwcDeviceName)
                ) + sizeof (UNICODE_NULL)
            );

        swprintf (
            NameBuffer,
            AVSTREAM_BUSENUM_STRING L"%s",
            DeviceExtension -> m_pwcDeviceName
            );

        break;

    case BusQueryCompatibleIDs:

        //
        // Compatible IDs are reported as:
        //
        //      AVStream\<Vendor PnPId>
        //          - This was the old hardware / device ID
        //
        //      AVStream\<Vendor PnPId>#<Munged Parent Compat ID>
        //          - These are new compat IDs based off EVERY parent compat ID
        //  
        Status = BuildChildIds (
            Device -> PhysicalDeviceObject,
            FALSE,
            DeviceExtension -> m_pwcDeviceName,
            &NameBuffer
            );

        break;

    case BusQueryHardwareIDs:
        
        //
        // Hardware IDs are reported as:
        //
        //      AVStream\<Vendor PnPId>#<Munged Parent Hardware ID>
        //          - These are new hardware IDs pased off EVERY parent HWId
        //
        Status = BuildChildIds (
            Device -> PhysicalDeviceObject,
            TRUE,
            DeviceExtension -> m_pwcDeviceName,
            &NameBuffer
            );

        break;


    case BusQueryInstanceID:

        {

            UNICODE_STRING  DeviceName;
            WCHAR           Buffer[8];

            //
            // convert the instance # from the device extension to unicode,
            // then copy it over to the output buffer.
            //

            DeviceName.Buffer = Buffer;
            DeviceName.Length = 0;
            DeviceName.MaximumLength = 8;

            RtlIntegerToUnicodeString(DeviceExtension->m_ulDeviceIndex,
                                      10,
                                      &DeviceName);

            NameBuffer = (PWCHAR)ExAllocatePool (
                PagedPool,
                8 * sizeof (WCHAR)
                );

            if (!NameBuffer) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            } else {
                RtlZeroMemory (NameBuffer, 8 * sizeof (WCHAR));
                wcscpy(NameBuffer, DeviceName.Buffer);
            }

            break;

        }

    default:

        return (STATUS_NOT_SUPPORTED);
    }

    //
    // return the string and good status.
    //

    *BusQueryId = NameBuffer;

    return (Status);

}

NTSTATUS
PdoDispatchPnp(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
/*++

    Description:

        All PnP messages for a PDO is redirected here to process properly

    Arguments:

        DeviceObject - the Pdo for a child device
        Irp - the PnP Irp to process

    Return:

        NTSTATUS

--*/
{
    PKSPDO_EXTENSION ChildExtension = (PKSPDO_EXTENSION)DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION IrpStack= IoGetCurrentIrpStackLocation(Irp);
    PIO_STACK_LOCATION NextStack;
    NTSTATUS Status;

    ASSERT( ChildExtension->m_PdoSignature == KS_PDO_SIGNATURE );
    
    switch (IrpStack->MinorFunction) {

        case IRP_MN_QUERY_INTERFACE:
           
            IoCopyCurrentIrpStackLocationToNext( Irp );
            
            _DbgPrintF(DEBUGLVL_BLAB,
                        ("Child PDO=%x forwards Query_Interface to Parent FDO=%x\n",
                       DeviceObject,
                       ChildExtension->m_pParentFdo));

            return (IoCallDriver(ChildExtension->m_pParentFdo,
                                 Irp));

        case IRP_MN_START_DEVICE:
            _DbgPrintF(DEBUGLVL_BLAB,
                        ("StartChild DevObj=%x Flags=%x\n",
                        DeviceObject,
                        ChildExtension->m_MarkedDelete ));
            ChildExtension->m_MarkedDelete = FALSE;
            Status = STATUS_SUCCESS;
            goto done;

        case IRP_MN_QUERY_STOP_DEVICE:
        case IRP_MN_QUERY_REMOVE_DEVICE:
        case IRP_MN_STOP_DEVICE:
        case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
            Status = STATUS_SUCCESS;
            goto done;

        case IRP_MN_QUERY_DEVICE_RELATIONS:

            if (IrpStack->Parameters.QueryDeviceRelations.Type == TargetDeviceRelation) {

                PDEVICE_RELATIONS DeviceRelations = NULL;

                DeviceRelations = (PDEVICE_RELATIONS)
                    ExAllocatePool(PagedPool, sizeof(*DeviceRelations));

                if (DeviceRelations == NULL) {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                } else {
                    //
                    // TargetDeviceRelation reported PDOs need to be ref'ed.
                    // PNP will deref this later.
                    //
                    ObReferenceObject(DeviceObject);
                    DeviceRelations->Count = 1;
                    DeviceRelations->Objects[0] = DeviceObject;
                    Status = STATUS_SUCCESS;
                }

                Irp->IoStatus.Information = (ULONG_PTR) DeviceRelations;

            } else {
                Status = Irp->IoStatus.Status;
            }

            goto done;

        case IRP_MN_REMOVE_DEVICE:
            {           
            PDEVICE_OBJECT pPdo;
            PKSPDO_EXTENSION pPdoExt;
            
            CKsDevice *device = CKsDevice::
                FromDeviceObject(ChildExtension->m_pParentFdo);

            _DbgPrintF(DEBUGLVL_ERROR,
                        ("Child PDO %x receives REMOVE\n",
                        DeviceObject ));
            //
            // When a PDO first receives this msg, it is usually forwarded
            // from FDO. We can't just delete this PDO, but mark it delete
            // pending.
            //

            if ( !ChildExtension->m_MarkedDelete ) {
                //ChildExtension->m_MarkedDelete = TRUE;
                Status = STATUS_SUCCESS;
                goto done;
            }
            
            //
            // free the device name string if it exists.
            //

            if (ChildExtension->m_pwcDeviceName) {

                ExFreePool(ChildExtension->m_pwcDeviceName);
            }

            //
            // delete the PDO
            //

            IoDeleteDevice(DeviceObject);

            Status = STATUS_SUCCESS;
            }
            goto done;

        case IRP_MN_QUERY_CAPABILITIES:

            Status = EnumGetCaps(ChildExtension,
                      IrpStack->Parameters.DeviceCapabilities.Capabilities);
            goto done;

        case IRP_MN_QUERY_ID:

            //
            // process the ID query for the child devnode.
            //

            Status = QueryEnumId(DeviceObject,
                                   IrpStack->Parameters.QueryId.IdType,
                                   (PWSTR *) & (Irp->IoStatus.Information));
            goto done;

        default:
            Status = STATUS_NOT_SUPPORTED;
    }

    done: {
        Irp->IoStatus.Status = Status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return (Status);
    }
}





NTSTATUS
CKsDevice::
DispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine dispatches PnP IRPs directed at the device.

Arguments:

    DeviceObject -
        The device object recieving the IRP.

    Irp -
        The IRP.

Return Value:

    STATUS_SUCCESS or an error status.
--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsDevice::DispatchPnp]"));

    PAGED_CODE();

    ASSERT(DeviceObject);
    ASSERT(Irp);

    //
    // to support bus driver
    //
    PKSPDO_EXTENSION pKsPdoExtension = (PKSPDO_EXTENSION)DeviceObject->DeviceExtension;

    if ( KS_PDO_SIGNATURE == pKsPdoExtension->m_PdoSignature ) {
        //
        // sent to PDO
        //
        return PdoDispatchPnp( DeviceObject, Irp );
    }
    

    CKsDevice *device = CKsDevice::FromDeviceObject(DeviceObject);

    NTSTATUS status = STATUS_SUCCESS;

    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

    switch (irpSp->MinorFunction) {
    case IRP_MN_START_DEVICE:
        //
        // Queue up creates.
        //
        device->m_CreatesMayProceed = FALSE;

        //
        // Forward request and start.
        //
        status = device->ForwardIrpSynchronous(Irp);

        if (NT_SUCCESS(status)) {
            //
            // Do start processing.
            //
            status = device->PnpStart(Irp);
        } else {
            _DbgPrintF(DEBUGLVL_TERSE,
                ("[CKsDevice::DispatchPnp] parent failed to start (%08x)",status));
            device->RedispatchPendingCreates();
            device->CompleteIrp(Irp,status);
        }
        break;

    case IRP_MN_STOP_DEVICE:
        //
        // Stop and forward request.
        //
        if (device->m_Ext.Public.Started) {
            device->PnpStop(Irp);
        } else {
            _DbgPrintF(DEBUGLVL_TERSE,
                ("[CKsDevice::DispatchPnp] stop recieved in unstarted state"));
        }

        device->RedispatchPendingCreates();

        IoSkipCurrentIrpStackLocation(Irp);
        status = IoCallDriver(device->m_Ext.Public.NextDeviceObject,Irp);
        break;

    case IRP_MN_REMOVE_DEVICE:
        //
        // Perform stop if required.
        //
        if (device->m_Ext.Public.Started) {
            _DbgPrintF(DEBUGLVL_VERBOSE,
                ("[CKsDevice::DispatchPnp] remove recieved in started state"));
            device->PnpStop(Irp);
            KspFreeDeviceClasses(device->m_Ext.Public.FunctionalDeviceObject);
        }

        device->RedispatchPendingCreates();

        //
        // Let the client know.
        //
        if (device->m_Ext.Public.Descriptor &&
            device->m_Ext.Public.Descriptor->Dispatch &&
            device->m_Ext.Public.Descriptor->Dispatch->Remove) {
            device->m_Ext.Public.Descriptor->Dispatch->Remove(
                &device->m_Ext.Public,
                Irp);
        }

        {
            //
            // Grab the next device object before the  device goes away.
            //
            PDEVICE_OBJECT nextDeviceObject =
                device->m_Ext.Public.NextDeviceObject;

            device->AcquireDevice ();

            //
            // Mark Child Pdo's if any and delete them before the parent
            // is terminated.
            //
            PDEVICE_OBJECT ChildPdo = device->m_pNextChildPdo;
            while (ChildPdo) {

                PKSPDO_EXTENSION PdoExtension = (PKSPDO_EXTENSION)
                    (ChildPdo -> DeviceExtension);

                PDEVICE_OBJECT NextChildPdo = PdoExtension -> m_pNextPdo;
                PdoExtension -> m_pNextPdo = NULL;

                PdoExtension -> m_MarkedDelete = TRUE;
                IoDeleteDevice (ChildPdo);

                ChildPdo = NextChildPdo;

            }
            device->m_pNextChildPdo = NULL;

            device->ReleaseDevice ();

            //
            // Terminate KS support.
            //
            KsTerminateDevice(DeviceObject);

            //
            // Forward the request.
            //
            Irp->IoStatus.Status = STATUS_SUCCESS;
            IoSkipCurrentIrpStackLocation(Irp);
            status = IoCallDriver(nextDeviceObject,Irp);

            #ifndef WIN9X_KS // WinME: 142427 (present on 9x's)

            //
            // Gone for good.
            //
            IoDetachDevice(nextDeviceObject);
            IoDeleteDevice(DeviceObject);

            #endif // WIN9X_KS
        }
        break;

    case IRP_MN_QUERY_STOP_DEVICE:
        //
        // Acquire the device because we don't want to race with creates.
        //
        device->AcquireDevice();

        //
        // Pass down the query.
        //
        Irp->IoStatus.Status = STATUS_SUCCESS;
        status = device->ForwardIrpSynchronous(Irp);
        if (NT_SUCCESS(status)) {
            //
            // Disallow creates.
            //
            device->m_CreatesMayProceed = FALSE;

            //
            // Let the client know.
            //
            if (device->m_Ext.Public.Descriptor &&
                device->m_Ext.Public.Descriptor->Dispatch &&
                device->m_Ext.Public.Descriptor->Dispatch->QueryStop) {
                status = device->m_Ext.Public.Descriptor->Dispatch->
                    QueryStop(&device->m_Ext.Public,Irp);
                #if DBG
                if (status == STATUS_PENDING) {
                    _DbgPrintF(DEBUGLVL_ERROR,
                    ("CLIENT BUG:  IRP_MN_QUERY_STOP_DEVICE handler returned STATUS_PENDING"));
                }
                #endif
            }
        }

        device->ReleaseDevice();

        device->CompleteIrp(Irp,status);

        break;

    case IRP_MN_QUERY_REMOVE_DEVICE:
        //
        // Acquire the device because we don't want to race with creates.
        //
        device->AcquireDevice();

        //
        // Pass down the query.
        //
        Irp->IoStatus.Status = STATUS_SUCCESS;
        status = device->ForwardIrpSynchronous(Irp);
        if (NT_SUCCESS(status)) {
            //
            // Disallow creates.
            //
            device->m_CreatesMayProceed = FALSE;

            //
            // Let the client know.
            //
            if (device->m_Ext.Public.Descriptor &&
                device->m_Ext.Public.Descriptor->Dispatch &&
                device->m_Ext.Public.Descriptor->Dispatch->QueryRemove) {
                status = device->m_Ext.Public.Descriptor->Dispatch->
                    QueryRemove(&device->m_Ext.Public,Irp);
                #if DBG
                if (status == STATUS_PENDING) {
                    _DbgPrintF(DEBUGLVL_ERROR,
                    ("CLIENT BUG:  IRP_MN_QUERY_REMOVE_DEVICE handler returned STATUS_PENDING"));
                }
                #endif
            }
        }

        device->ReleaseDevice();

        device->CompleteIrp(Irp,status);
        break;

    case IRP_MN_CANCEL_STOP_DEVICE:
        //
        // Creates are allowed because we won't be moving/stopping.
        //
        device->RedispatchPendingCreates();

        if (device->m_Ext.Public.Descriptor &&
            device->m_Ext.Public.Descriptor->Dispatch &&
            device->m_Ext.Public.Descriptor->Dispatch->CancelStop) {
            device->m_Ext.Public.Descriptor->Dispatch->
                CancelStop(&device->m_Ext.Public,Irp);
        }

        IoSkipCurrentIrpStackLocation(Irp);
        Irp->IoStatus.Status = STATUS_SUCCESS;
        status = IoCallDriver(device->m_Ext.Public.NextDeviceObject,Irp);
        break;

    case IRP_MN_CANCEL_REMOVE_DEVICE:
        //
        // Creates are allowed because we won't be moving/stopping.
        //
        device->RedispatchPendingCreates();

        if (device->m_Ext.Public.Descriptor &&
            device->m_Ext.Public.Descriptor->Dispatch &&
            device->m_Ext.Public.Descriptor->Dispatch->CancelRemove) {
            device->m_Ext.Public.Descriptor->Dispatch->
                CancelRemove(&device->m_Ext.Public,Irp);
        }

        IoSkipCurrentIrpStackLocation(Irp);
        status = IoCallDriver(device->m_Ext.Public.NextDeviceObject,Irp);
        break;

    case IRP_MN_SURPRISE_REMOVAL:

        device->AcquireDevice();

        KspSetDeviceClassesState(device->m_Ext.Public.FunctionalDeviceObject,
            FALSE);
        KspFreeDeviceClasses(device->m_Ext.Public.FunctionalDeviceObject);

        //
        // Disallow certain I/O requests to the minidriver.
        //
        device->m_AllowIo = FALSE;

        //
        // NOTE: This is temporary until the Pnp code gets overhauled.  Fail
        // any creates while in surprise remove state.
        //
        device->m_FailCreates = TRUE;

        //
        // TODO:  Is this all?
        //
        //_asm int 3;
        if (device->m_Ext.Public.Descriptor &&
            device->m_Ext.Public.Descriptor->Dispatch &&
            device->m_Ext.Public.Descriptor->Dispatch->SurpriseRemoval) {
            device->m_Ext.Public.Descriptor->Dispatch->
                SurpriseRemoval(&device->m_Ext.Public,Irp);
            //
            // need to pass down the Irp unless  the mini driver veto this
            // ( how can it veto this ? no ways! )
            //
        }

        device->ReleaseDevice();
        device->RedispatchPendingCreates ();

        //
        // pass it down per PnP rules.
        //
        //device->CompleteIrp(Irp,status);
        IoSkipCurrentIrpStackLocation(Irp);
        status = IoCallDriver(device->m_Ext.Public.NextDeviceObject,Irp);
        break;

    case IRP_MN_QUERY_CAPABILITIES:
        //
        // Pass this down to the PDO synchronously.  If that works, think
        // about it some more.
        //
        Irp->IoStatus.Status = STATUS_SUCCESS;
        status = device->ForwardIrpSynchronous(Irp);
        if (NT_SUCCESS(status)) {
            status = device->PnpQueryCapabilities(Irp);
        }
        device->CompleteIrp(Irp,status);
        break;

    case IRP_MN_QUERY_DEVICE_RELATIONS:
    
        switch (irpSp->Parameters.QueryDeviceRelations.Type) {

        case BusRelations:

            //
            // invoke routine to enumerate any child devices
            //

            status = device->EnumerateChildren(Irp);
            //
            // need to always pass down, don't complete it
            //
            //device->CompleteIrp(Irp,status);
            //
            // fall thru to skip stack and calldown
            //break;

        case TargetDeviceRelation:
        default:
            IoSkipCurrentIrpStackLocation(Irp);
            status = IoCallDriver(device->m_Ext.Public.NextDeviceObject,Irp);
        }

        break;

    case IRP_MN_QUERY_INTERFACE:

        //
        // if we are a bus driver and there is a QI handler call down.
        //
        
        if ( device->m_IsParentFdo &&
             device->m_Ext.Public.Descriptor->Version >= MIN_DEV_VER_FOR_QI &&
             device->m_Ext.Public.Descriptor->Dispatch->QueryInterface ) {
            
            //
            // we have the full size of dispatch table, and we
            // have the QueryInterface handler.
            //

            status = device->m_Ext.Public.Descriptor->Dispatch->
                QueryInterface(&device->m_Ext.Public, Irp);
            if ( status != STATUS_NOT_SUPPORTED &&
                 !NT_SUCCESS( status ) ) {
                //
                // Mini driver explicitly fail this call, short circuit Irp
                //
                device->CompleteIrp(Irp,status);
                break;
            }
            Irp->IoStatus.Status = status;
        }

        //
        // not handled or success, continue to send it down
        //
        IoSkipCurrentIrpStackLocation(Irp);
        status = IoCallDriver(device->m_Ext.Public.NextDeviceObject,Irp);
        break;

    default:
        IoSkipCurrentIrpStackLocation(Irp);
        status = IoCallDriver(device->m_Ext.Public.NextDeviceObject,Irp);
        break;
    }

    return status;
}

#ifdef DONTNEEDTOVALIDATEANYMORE

#define ValidateCapabilities(Capabilities,Whom)

#else // !DONTNEEDTOVALIDATEANYMORE

void
ValidateCapabilities(
    IN PDEVICE_CAPABILITIES Capabilities,
    IN PCHAR Whom
    )

/*++

Routine Description:

    This routine validates a capabilities structure and corrects any error it
    finds.

Arguments:

    Capabilities -
        Contains a pointer to the capabilities structure.

    Whom -
        Contains a pointer to a string indicating the party who filled in the
        structure.

Return Value:

    Status.

--*/

{
    //
    // We should be awake while we're working.
    //
    if (Capabilities->DeviceState[PowerSystemWorking] != PowerDeviceD0) {
        _DbgPrintF(DEBUGLVL_TERSE,("%s BUG:  CAPABILITIES DeviceState[PowerSystemWorking] != PowerDeviceD0",Whom));
        Capabilities->DeviceState[PowerSystemWorking] = PowerDeviceD0;
    }

    //
    // We should be asleep while we're sleeping.
    //
    for (ULONG state = ULONG(PowerSystemSleeping1); state <= ULONG(PowerSystemShutdown); state++) {
        if (Capabilities->DeviceState[state] == PowerDeviceD0) {
            _DbgPrintF(DEBUGLVL_TERSE,("%s BUG:  CAPABILITIES DeviceState[%d] == PowerDeviceD0",Whom,state));
            Capabilities->DeviceState[state] = PowerDeviceD3;
        }
    }
}

#endif // !DONTNEEDTOVALIDATEANYMORE

NTSTATUS
CKsDevice::
PnpQueryCapabilities(
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine does processing relating to a PNP query capabilities IRP.

Arguments:

    Irp -
        Contains a pointer to the PnP query capabilities IRP to be processed.

Return Value:

    Status.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsDevice::PnpQueryCapabilities]"));
    _DbgPrintF(DEBUGLVL_POWER,("[CKsDevice::PnpQueryCapabilities]"));

    PAGED_CODE();

    ASSERT(Irp);

    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_CAPABILITIES capabilities =
        irpSp->Parameters.DeviceCapabilities.Capabilities;
    ASSERT(capabilities);
    ASSERT(capabilities->Size >= sizeof(*capabilities));

    ValidateCapabilities(capabilities,"PDO");

    //
    // Pass the structure to the client.
    //
    NTSTATUS status;
    if (m_Ext.Public.Descriptor &&
        m_Ext.Public.Descriptor->Dispatch &&
        m_Ext.Public.Descriptor->Dispatch->QueryCapabilities) {

        status =
            m_Ext.Public.Descriptor->Dispatch->
                QueryCapabilities(&m_Ext.Public,Irp,capabilities);
        #if DBG
        if (status == STATUS_PENDING) {
            _DbgPrintF(DEBUGLVL_ERROR,
            ("CLIENT BUG:  IRP_MN_QUERY_CAPABILITIES handler returned STATUS_PENDING"));
        }
        #endif
        ValidateCapabilities(capabilities,"CLIENT");
    } else {
        status = STATUS_SUCCESS;
    }

    //
    // Copy the state map for future reference.
    //
    if (NT_SUCCESS(status)) {
        RtlCopyMemory(
            m_DeviceStateMap,
            capabilities->DeviceState,
            sizeof(m_DeviceStateMap));

        _DbgPrintF(DEBUGLVL_POWER,
            ("IRP_MN_QUERY_CAPABILITIES(%p,%p)  PowerSystemUnspecified = %d",
            m_Ext.Public.FunctionalDeviceObject,
            Irp,capabilities->DeviceState[PowerSystemUnspecified]));
        _DbgPrintF(DEBUGLVL_POWER,
            ("IRP_MN_QUERY_CAPABILITIES(%p,%p)  PowerSystemWorking = %d",
            m_Ext.Public.FunctionalDeviceObject,Irp,
            capabilities->DeviceState[PowerSystemWorking]));
        _DbgPrintF(DEBUGLVL_POWER,
            ("IRP_MN_QUERY_CAPABILITIES(%p,%p)  PowerSystemSleeping1 = %d",
            m_Ext.Public.FunctionalDeviceObject,Irp,
            capabilities->DeviceState[PowerSystemSleeping1]));
        _DbgPrintF(DEBUGLVL_POWER,
            ("IRP_MN_QUERY_CAPABILITIES(%p,%p)  PowerSystemSleeping2 = %d",
            m_Ext.Public.FunctionalDeviceObject,Irp,
            capabilities->DeviceState[PowerSystemSleeping2]));
        _DbgPrintF(DEBUGLVL_POWER,
            ("IRP_MN_QUERY_CAPABILITIES(%p,%p)  PowerSystemSleeping3 = %d",
            m_Ext.Public.FunctionalDeviceObject,Irp,
            capabilities->DeviceState[PowerSystemSleeping3]));
        _DbgPrintF(DEBUGLVL_POWER,
            ("IRP_MN_QUERY_CAPABILITIES(%p,%p)  PowerSystemHibernate = %d",
            m_Ext.Public.FunctionalDeviceObject,Irp,
            capabilities->DeviceState[PowerSystemHibernate]));
        _DbgPrintF(DEBUGLVL_POWER,
            ("IRP_MN_QUERY_CAPABILITIES(%p,%p)  PowerSystemShutdown = %d",
            m_Ext.Public.FunctionalDeviceObject,Irp,
            capabilities->DeviceState[PowerSystemShutdown]));
        _DbgPrintF(DEBUGLVL_POWER,
            ("IRP_MN_QUERY_CAPABILITIES(%p,%p)  SystemWake = %d",
            m_Ext.Public.FunctionalDeviceObject,Irp,
            capabilities->SystemWake));
        _DbgPrintF(DEBUGLVL_POWER,
            ("IRP_MN_QUERY_CAPABILITIES(%p,%p)  DeviceWake = %d",
            m_Ext.Public.FunctionalDeviceObject,Irp,
            capabilities->DeviceWake));
    } else {
        _DbgPrintF(DEBUGLVL_POWER,
            ("IRP_MN_QUERY_CAPABILITIES(%p,%p) client returned status %08x",
            m_Ext.Public.FunctionalDeviceObject,Irp,status));
    }

    return status;
}


void
CKsDevice::
PostPnpStartWorker(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is the entry point for the work queue item that performs
    post-PnP-start processing.  It is only used when the dispatch table
    contains a client callback for this purpose.

Arguments:

    Context -
        Contains a pointer to the device implementation.

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsDevice::PostPnpStartWorker]"));

    PAGED_CODE();

    ASSERT(Context);

    CKsDevice *device = (CKsDevice *) Context;

    device->AcquireDevice();

    //
    // Tell the client.
    //
    NTSTATUS status = STATUS_SUCCESS;
    if (device->m_Ext.Public.Descriptor &&
        device->m_Ext.Public.Descriptor->Dispatch &&
        device->m_Ext.Public.Descriptor->Dispatch->PostStart) {
        status =
            device->m_Ext.Public.Descriptor->Dispatch->
                PostStart(&device->m_Ext.Public);
        #if DBG
        if (status == STATUS_PENDING) {
            _DbgPrintF(DEBUGLVL_ERROR,
                ("CLIENT BUG:  post-pnp-start callback returned STATUS_PENDING"));
        }
        #endif
    }

    device->ReleaseDevice();

    if (NT_SUCCESS(status)) {
        //
        // Ready to go.  Creates won't actually go through until we call
        // RedispatchPendingCreates(), which sets CreatesMayProceed.
        //
        device->m_Ext.Public.Started = TRUE;

        //
        // Turn on the device interfaces.
        //
        KspSetDeviceClassesState(device->m_Ext.Public.FunctionalDeviceObject,TRUE);
    }
    else
    {
        //
        // Failed.  Redispatching the creates causes them to fail.
        //
        _DbgPrintF(DEBUGLVL_TERSE,("[PostPnpStartWorker] client failed to start (0x%08x)",status));
    }

    //
    // Redispatch the creates.
    //
    _DbgPrintF(DEBUGLVL_VERBOSE,("[PostPnpStartWorker] redispatching pending creates"));
    if (device->m_Ext.Public.Started) {
        device->m_AllowIo = TRUE;
        device->m_FailCreates = FALSE;
    }
    else
        device->m_AllowIo = FALSE;
    device->RedispatchPendingCreates();
}


void
CKsDevice::
CloseWorker(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is the entry point for the work queue item that performs
    terminal processing for pended close IRPs and pended, failed create IRPs.
    In both cases, the action taken is to redispatch the IRP through the
    object header.

Arguments:

    Context -
        Contains a pointer to the device implementation.

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsDevice::CloseWorker]"));

    PAGED_CODE();

    ASSERT(Context);

    CKsDevice *device = (CKsDevice *) Context;

    while (1) {
        PIRP irp =
            KsRemoveIrpFromCancelableQueue(
                &device->m_CloseIrpList.ListEntry,
                &device->m_CloseIrpList.SpinLock,
                KsListEntryHead,
                KsAcquireAndRemoveOnlySingleItem);

        if (! irp) {
            break;
        }

        //
        // To complete processing of the IRP, we call the close dispatch
        // function on the file object.  This function is prepared to handle
        // pended closes and pended, failed creates.
        //
        PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(irp);

        PKSIOBJECT_HEADER objectHeader =
            *(PKSIOBJECT_HEADER*)irpSp->FileObject->FsContext;
        ASSERT(objectHeader);

        objectHeader->DispatchTable->Close(irpSp->DeviceObject,irp);
    }
}


NTSTATUS
CKsDevice::
PnpStart(
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine does processing relating to a PNP start IRP.

Arguments:

    Irp -
        Contains a pointer to the PnP start IRP to be processed.

Return Value:

    Status.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsDevice::PnpStart]"));

    PAGED_CODE();

    ASSERT(Irp);

    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

    AcquireDevice();

    //
    // Start the client.
    //
    NTSTATUS status = STATUS_SUCCESS;
    if (m_Ext.Public.Descriptor &&
        m_Ext.Public.Descriptor->Dispatch &&
        m_Ext.Public.Descriptor->Dispatch->Start) {
        status =
            m_Ext.Public.Descriptor->Dispatch->Start(
                &m_Ext.Public,
                Irp,
                irpSp->Parameters.StartDevice.AllocatedResourcesTranslated,
                irpSp->Parameters.StartDevice.AllocatedResources);
#if DBG
        if (status == STATUS_PENDING) {
            _DbgPrintF(DEBUGLVL_ERROR,
            ("CLIENT BUG:  IRP_MN_START_DEVICE handler returned STATUS_PENDING"));
        }
#endif
    }

    BOOLEAN queuePostStartWorker =
        NT_SUCCESS(status) &&
        m_Ext.Public.Descriptor &&
        m_Ext.Public.Descriptor->Dispatch &&
        m_Ext.Public.Descriptor->Dispatch->PostStart;

    ReleaseDevice();

    if (queuePostStartWorker) {
        //
        // The client wants to do more in a worker after start.  We will
        // wait to redispatch the creates until after that.
        //
        ExInitializeWorkItem(
            &m_PostPnpStartWorkItem,PostPnpStartWorker,this);

        ExQueueWorkItem(&m_PostPnpStartWorkItem,DelayedWorkQueue);
    } else {
        if (NT_SUCCESS(status)) {
            //
            // Ready to go.  Creates won't actually go through until we call
            // RedispatchPendingCreates(), which sets CreatesMayProceed.
            //
            m_Ext.Public.Started = TRUE;

            //
            // Turn on the device interfaces.
            //
            KspSetDeviceClassesState(m_Ext.Public.FunctionalDeviceObject,TRUE);
        }
        else
        {
            //
            // Failed.  Redispatching the creates causes them to fail.
            //
            _DbgPrintF(DEBUGLVL_TERSE,
                ("[CKsDevice::PnpStart] client failed to start (0x%08x)",status));
        }

        //
        // Redispatch the creates.
        //
        _DbgPrintF(DEBUGLVL_VERBOSE,
            ("[CKsDevice::PnpStart] redispatching pending creates"));

        if (m_Ext.Public.Started) {
            m_AllowIo = TRUE;
            m_FailCreates = FALSE;
        }
        else
            m_AllowIo = FALSE;
        RedispatchPendingCreates();
    }

    CompleteIrp(Irp,status);

    return status;
}


void
CKsDevice::
PnpStop(
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs processing relating to a PNP stop IRP.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsDevice::PnpStop]"));

    PAGED_CODE();

    ASSERT(Irp);

    //
    // Turn off the device interfaces.
    //
    KspSetDeviceClassesState(m_Ext.Public.FunctionalDeviceObject,FALSE);
        &(*(PKSIDEVICE_HEADER*)
            m_Ext.Public.FunctionalDeviceObject->DeviceExtension)->
                ChildCreateHandlerList,

    //
    // Indicate we have closed up shop.
    //
    m_Ext.Public.Started = FALSE;
    m_CreatesMayProceed = FALSE;
    m_AllowIo = FALSE;

    //
    // Let the client know.
    //
    if (m_Ext.Public.Descriptor &&
        m_Ext.Public.Descriptor->Dispatch &&
        m_Ext.Public.Descriptor->Dispatch->Stop) {
        m_Ext.Public.Descriptor->Dispatch->
            Stop(&m_Ext.Public,Irp);
    }

    //
    // Delete any filter factories with the FREEONSTOP flag.
    //
    KSOBJECT_CREATE_ITEM match;
    RtlZeroMemory(&match,sizeof(match));
    match.Flags = KSCREATE_ITEM_FREEONSTOP;
    KsiFreeMatchingObjectCreateItems(
        *reinterpret_cast<KSDEVICE_HEADER*>(
            m_Ext.Public.FunctionalDeviceObject->DeviceExtension),
        &match);
}


NTSTATUS
CKsDevice::
DispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine dispatches power IRPs directed at the device.

Arguments:

    DeviceObject -
        The device object recieving the IRP.

    Irp -
        The IRP.

Return Value:

    STATUS_SUCCESS or an error status.

--*/

{
    NTSTATUS status;

    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_POWER,("[CKsDevice::DispatchPower]"));

    ASSERT(DeviceObject);
    ASSERT(Irp);

    //
    // to support bus driver
    //
    PKSPDO_EXTENSION pKsPdoExtension = (PKSPDO_EXTENSION)DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

    if ( KS_PDO_SIGNATURE == pKsPdoExtension->m_PdoSignature ) {
    
        //
        // we are the PDO. Set not_supported unless the Irp is properly formed.
        //      
        status = STATUS_NOT_SUPPORTED;

        //
        // succeed all Irp with proper power parameters
        //
        switch ( irpSp->MinorFunction ) {
        case IRP_MN_QUERY_POWER:
        case IRP_MN_SET_POWER:
            switch ( irpSp->Parameters.Power.Type ) {
            case SystemPowerState:
                if ( irpSp->Parameters.Power.State.SystemState < PowerSystemMaximum ) {
                    status = STATUS_SUCCESS;
                }
                break;
            case DevicePowerState:
                if ( irpSp->Parameters.Power.State.DeviceState < PowerDeviceMaximum ) {
                    status = STATUS_SUCCESS;
                }
                break;
            default:
                // power type out of range
                break;
            }
            break;
        default:
            // unknown power Irp
            break;
        }
            
        PoStartNextPowerIrp( Irp );
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return (status);
    }
    
    CKsDevice *device = CKsDevice::FromDeviceObject(DeviceObject);

    switch (irpSp->MinorFunction) {
    case IRP_MN_QUERY_POWER:
    {
        //
        // State change query.  First we acquire the device because
        // we may want to permit a transition to sleep based on a
        // zero active pin count and the blessing of the client.
        //
        #if DBG
        if (irpSp->Parameters.Power.Type == DevicePowerState) {
            _DbgPrintF(DEBUGLVL_POWER,("IRP_MN_QUERY_POWER(%p,%p) DevicePowerState from %d to %d",
                DeviceObject,Irp,device->m_Ext.Public.DevicePowerState,
                irpSp->Parameters.Power.State.DeviceState));
        } else {
            _DbgPrintF(DEBUGLVL_POWER,("IRP_MN_QUERY_POWER(%p,%p) SystemPowerState from %d to %d",
                DeviceObject,Irp,device->m_Ext.Public.SystemPowerState,
                irpSp->Parameters.Power.State.SystemState));
        }
        #endif
        device->AcquireDevice();
        if ((irpSp->Parameters.Power.Type == DevicePowerState) ||
            (irpSp->Parameters.Power.State.SystemState != PowerSystemShutdown) ||
            (device->m_ActivePinCount == 0)) {

            //
            // Nothing to prevent the change.  Ask the client.
            //
            if (device->m_Ext.Public.Descriptor &&
                device->m_Ext.Public.Descriptor->Dispatch &&
                device->m_Ext.Public.Descriptor->Dispatch->QueryPower) {
                if (irpSp->Parameters.Power.Type == DevicePowerState) {
                    //
                    // Device query.  Send the device states.
                    //
                    status =
                        device->m_Ext.Public.Descriptor->Dispatch->QueryPower(
                            &device->m_Ext.Public,
                            Irp,
                            irpSp->Parameters.Power.State.DeviceState,
                            device->m_Ext.Public.DevicePowerState,
                            PowerSystemUnspecified,
                            PowerSystemUnspecified,
                            irpSp->Parameters.Power.ShutdownType);
                } else {
                    //
                    // System query.  Send the system states and associated
                    // device states.
                    //
                    status =
                        device->m_Ext.Public.Descriptor->Dispatch->QueryPower(
                            &device->m_Ext.Public,
                            Irp,
                            device->m_DeviceStateMap[irpSp->Parameters.Power.State.SystemState],
                            device->m_Ext.Public.DevicePowerState,
                            irpSp->Parameters.Power.State.SystemState,
                            device->m_Ext.Public.SystemPowerState,
                            irpSp->Parameters.Power.ShutdownType);
                }
                #if DBG
                if (status == STATUS_PENDING) {
                    _DbgPrintF(DEBUGLVL_ERROR,
                        ("CLIENT BUG:  QueryPower handler returned STATUS_PENDING"));
                }
                #endif
            } else {
                status = STATUS_SUCCESS;
            }

            if (NT_SUCCESS(status)) {
                //
                // Start pending run requests if it looks like we are
                // going to shut down.  Release the device right
                // after that so run requests can unblock and get
                // pended.
                //
                if ((irpSp->Parameters.Power.Type == SystemPowerState) &&
                    (irpSp->Parameters.Power.State.SystemState ==
                     PowerSystemShutdown)) {
                    device->m_RunsMayProceed = FALSE;
                    _DbgPrintF(DEBUGLVL_POWER,
                            ("IRP_MN_QUERY_POWER(%p,%p) successful:  will pend run requests",
                            DeviceObject,Irp));
                } else {
                    _DbgPrintF(DEBUGLVL_POWER,
                        ("IRP_MN_QUERY_POWER(%p,%p) successful",DeviceObject,Irp));
                }
                device->ReleaseDevice();
                //
                // Fall through so the IRP gets sent down the stack.
                //
                break;
            } else {
                _DbgPrintF(DEBUGLVL_POWER,
                    ("IRP_MN_QUERY_POWER(%p,%p) failed (%08x):  client returned error",
                    DeviceObject,Irp,status));
            }
        } else {
            //
            // We have active pins:  not ready to sleep.
            //
            _DbgPrintF(DEBUGLVL_POWER,
                ("IRP_MN_QUERY_POWER(%p,%p) failed (STATUS_UNSUCCESSFUL):  active pin count is %d",
                DeviceObject,Irp,device->m_ActivePinCount));
            status = STATUS_UNSUCCESSFUL;
        }

        //
        // Release the device because the windows between the system
        // state check and setting m_RunsMayProceed is closed.  If  any
        // runs were pending for any reason, redispatch them.
        //
        device->ReleaseDevice();
        device->RedispatchPendingRuns();

        PoStartNextPowerIrp(Irp);
        device->CompleteIrp(Irp,status);
        return status;
    }

    case IRP_MN_SET_POWER:
        if (irpSp->Parameters.Power.Type == DevicePowerState) {

            DEVICE_POWER_STATE OldDevicePowerState; 

            _DbgPrintF(DEBUGLVL_POWER,
                ("IRP_MN_SET_POWER(%p,%p) DevicePowerState from %d to %d",
                DeviceObject,Irp,device->m_Ext.Public.DevicePowerState,
                irpSp->Parameters.Power.State.DeviceState));
            //
            // Device state change.
            //
            if (device->m_Ext.Public.DevicePowerState >
                irpSp->Parameters.Power.State.DeviceState) {
                //
                // Waking...need to tell the PDO first.
                //
                device->ForwardIrpSynchronous(Irp);

                //
                // Notify client at the device level.
                //
                device->AcquireDevice();

                if (device->m_Ext.Public.Descriptor &&
                    device->m_Ext.Public.Descriptor->Dispatch &&
                    device->m_Ext.Public.Descriptor->Dispatch->SetPower) {
                    device->m_Ext.Public.Descriptor->Dispatch->SetPower(
                        &device->m_Ext.Public,
                        Irp,
                        irpSp->Parameters.Power.State.DeviceState,
                        device->m_Ext.Public.DevicePowerState);
                }

                //
                // Because we're twiddling with the power notification list,
                // we must now hold the mutex associated with it as well.
                //
                KeWaitForMutexObject (
                    &device->m_PowerNotifyMutex,
                    Executive,
                    KernelMode,
                    FALSE,
                    NULL
                    );

                //
                // Record the change.
                //
                device->m_Ext.Public.DevicePowerState =
                    irpSp->Parameters.Power.State.DeviceState;

                //
                // Wake up all the power notify sinks.  Do this in Flink
                // order:  we promised the client this, and it makes sense
                // cause parents end up at the top of the list.
                //
                for (PLIST_ENTRY listEntry = device->m_PowerNotifyList.Flink;
                     listEntry != &device->m_PowerNotifyList;
                     listEntry = listEntry->Flink) {
                    PKSPPOWER_ENTRY entry =
                        CONTAINING_RECORD(listEntry,KSPPOWER_ENTRY,ListEntry);
                    ASSERT(entry->PowerNotify);
                    entry->PowerNotify->Wake();
                }

                KeReleaseMutex (&device->m_PowerNotifyMutex, FALSE);
                device->ReleaseDevice();

                //
                // Set power state on the device object for notification purposes.
                //
                PoSetPowerState(
                    DeviceObject,
                    DevicePowerState,
                    irpSp->Parameters.Power.State);

                PoStartNextPowerIrp(Irp);
                device->CompleteIrp(Irp,STATUS_SUCCESS);
                return STATUS_SUCCESS;
            }

            //
            // Going to sleep.
            // Set power state on the device object for notification purposes.
            //
            PoSetPowerState(
                DeviceObject,
                DevicePowerState,
                irpSp->Parameters.Power.State);

            //
            // Record the change.
            //
            device->AcquireDevice();

            //
            // Because we're twiddling with the power notification list,
            // we must now hold the mutex associated with it as well.
            //
            KeWaitForMutexObject (
                &device->m_PowerNotifyMutex,
                Executive,
                KernelMode,
                FALSE,
                NULL
                );

            OldDevicePowerState = device->m_Ext.Public.DevicePowerState;
            device->m_Ext.Public.DevicePowerState =
                irpSp->Parameters.Power.State.DeviceState;

            //
            // Tuck in all the power notify sinks.  Do this in Blink
            // order:  we promised the client this, and it makes sense
            // cause parents end up at the top of the list.
            //
            for (PLIST_ENTRY listEntry = device->m_PowerNotifyList.Blink;
                 listEntry != &device->m_PowerNotifyList;
                 listEntry = listEntry->Blink) {
                PKSPPOWER_ENTRY entry =
                    CONTAINING_RECORD(listEntry,KSPPOWER_ENTRY,ListEntry);
                ASSERT(entry->PowerNotify);
                entry->PowerNotify->Sleep(device->m_Ext.Public.DevicePowerState);
            }
            KeReleaseMutex (&device->m_PowerNotifyMutex, FALSE);

            //
            // Notify client at the device level.
            //
            if (device->m_Ext.Public.Descriptor &&
                device->m_Ext.Public.Descriptor->Dispatch &&
                device->m_Ext.Public.Descriptor->Dispatch->SetPower) {
                device->m_Ext.Public.Descriptor->Dispatch->SetPower(
                    &device->m_Ext.Public,
                    Irp,
                    irpSp->Parameters.Power.State.DeviceState,
                    OldDevicePowerState);
            }

            device->ReleaseDevice();

            //
            // Fall through so the IRP gets sent down the stack.
            //
            break;
        } else {
            _DbgPrintF(DEBUGLVL_POWER,
                ("IRP_MN_SET_POWER(%p,%p) SystemPowerState from %d to %d",
                DeviceObject,Irp,device->m_Ext.Public.SystemPowerState,
                irpSp->Parameters.Power.State.SystemState));
                
            //
            // System state change request.  We take the mutex only because
            // we want to guarantee the stability of the system power state
            // while the device is acquired.
            //
            device->AcquireDevice();
            device->m_Ext.Public.SystemPowerState =
                irpSp->Parameters.Power.State.SystemState;
            device->ReleaseDevice();

            //
            // Redispatch any pending run requests that may have been waiting.
            // We don't want the device mutex here.  Any run requests that
            // arrive before we allow runs to proceed will just get queued
            // and redispatched anyway.  Taking the mutex while dispatching
            // can cause deadlock.
            //
            device->RedispatchPendingRuns();

            //
            // Look up the device state in the table.
            //
            POWER_STATE newPowerState;
            newPowerState.DeviceState =
                device->m_DeviceStateMap[irpSp->Parameters.Power.State.SystemState];

            ASSERT((newPowerState.DeviceState >= PowerDeviceD0) ||
                   (newPowerState.DeviceState <= PowerDeviceD3));

            if (newPowerState.DeviceState != device->m_Ext.Public.DevicePowerState) {
                //
                // Request a new device power state.
                //
                Irp->Tail.Overlay.DriverContext[0] = device;
                Irp->IoStatus.Status = STATUS_PENDING;
                IoMarkIrpPending(Irp);

                _DbgPrintF(DEBUGLVL_POWER,
                    ("IRP_MN_SET_POWER(%p,%p) requesting device IRP_MN_SET_POWER",
                    DeviceObject,Irp));
                    
                NTSTATUS status =
                    PoRequestPowerIrp(
                        device->m_Ext.Public.NextDeviceObject,
                        IRP_MN_SET_POWER,
                        newPowerState,
                        &CKsDevice::RequestPowerIrpCompletion,
                        Irp,
                        NULL);

                if (status != STATUS_PENDING) {

                    _DbgPrintF(DEBUGLVL_POWER,
                        ("IRP_MN_SET_POWER(%p,%p) PoRequestPowerIrp returned status %08x",
                        DeviceObject,Irp,status));
                        
                    PoStartNextPowerIrp(Irp);
                    device->CompleteIrp(Irp,status);
                }
                return status;
            }
        }
    }

    //
    // Let the PDO handle the IRP.
    //
    PoStartNextPowerIrp(Irp);
    IoSkipCurrentIrpStackLocation(Irp);
    return PoCallDriver(device->m_Ext.Public.NextDeviceObject,Irp);
}

#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif // ALLOC_PRAGMA

IMPLEMENT_FROMSTRUCT(CKsDevice,PKSDEVICE,m_Ext.Public);

CKsDevice *
CKsDevice::
FromDeviceObject(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    Return the CKsDevice object associated with a given device object.

Arguments:

    DeviceObject -
        The device object in question

Return Value:

    The CKsDevice object associated with DeviceObject

--*/

{
    return FromStruct(
        PKSDEVICE(
            (*(PKSIDEVICE_HEADER*) DeviceObject->DeviceExtension)->
                Object));
}


ULONG
CKsDevice::
SetBusData(
    IN ULONG DataType,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )

/*++

Routine Description:

    Helper for KsDeviceSetBusData.  This either calls through the bus 
    interface (NT os) or sends the bus data set request to the bus driver via
    an Irp (9x os)

--*/

{
    if (m_BusInterfaceStandard.SetBusData)
        return m_BusInterfaceStandard.SetBusData(
            m_BusInterfaceStandard.Context,
            DataType,
            Buffer,
            Offset,
            Length);
    else
        return GetSetBusDataIrp (DataType, Buffer, Offset,
            Length, FALSE);
}


ULONG
CKsDevice::
GetBusData(
    IN ULONG DataType,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )

/*++

Routine Description:

    Helper for KsDeviceGetBusData.  This either calls through the bus
    interface (NT os) or sends the bus data get request to the bus driver via
    an Irp (9x os)

--*/

{
    if (m_BusInterfaceStandard.GetBusData)
        return m_BusInterfaceStandard.GetBusData(
            m_BusInterfaceStandard.Context,
            DataType,
            Buffer,
            Offset,
            Length);
    else
        return GetSetBusDataIrp (DataType, Buffer, Offset,
            Length, TRUE);
}


STDMETHODIMP
CKsDevice::
CheckIoCapability (
    void
    )

/*++

Routine Description:

    Check whether I/O is permissible to the minidriver or not.  This will
    return an appropriate status code to fail requests with if not.

    Should the device be stopped, in surprise removal, etc...  this routine
    will return a failure code.  Objects which need to fail I/O based on
    device state should use this mechanism through the IKsDevice interface.

Arguments:

    None

Return Value:

    STATUS_SUCCESS:
        Device is in normal state; I/O may proceed

    !NT_SUCCESS():
        Fail I/O with the returned status code

--*/

{

    //
    // If the device isn't in a stopped / surprise removed state, return
    // that the I/O may proceed.  Otherwise, fail with
    // STATUS_INVALID_DEVICE_REQUEST.
    //
    if (m_AllowIo) return STATUS_SUCCESS;
    else return STATUS_INVALID_DEVICE_REQUEST;

}

IO_ALLOCATION_ACTION
CKsDevice::
ArbitrateAdapterCallback (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Reserved,
    IN PVOID MapRegisterBase,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine handles callbacks from IoAllocateAdapterChannel and passes
    them onto whatever client needs the callback.  The device intercepts
    callbacks in order to arbitrate access to the DMA adapter.

Arguments:

    As per PDRIVER_CONTROL

Return Value:

    As per PDRIVER_CONTROL

--*/

{

    IO_ALLOCATION_ACTION Action = DeallocateObject;

    PARBITER_CALLBACK_CONTEXT ArbiterContext =
        (PARBITER_CALLBACK_CONTEXT)Context;

    if (ArbiterContext->ClientCallback) {
        Action = ArbiterContext->ClientCallback (
            DeviceObject,
            Reserved,
            MapRegisterBase,
            ArbiterContext->ClientContext
            );
    }

    //
    // TODO:
    //
    // If we ever rearchitect the DMA engine and have some arbitration queue,
    // it would get serviced if the decrement count is zero.  On the other
    // hand, a rearchitecting would not necessarily use this mechanism.
    //
    InterlockedDecrement (&(((CKsDevice *)(ArbiterContext->Device))->
        m_AdapterArbiterOutstandingAllocations));

    return Action;

}

NTSTATUS
CKsDevice::
ArbitrateAdapterChannel (
    IN ULONG MappingsNeeded,
    IN PDRIVER_CONTROL Callback,
    IN PVOID CallbackContext
    )

/*++

Routine Description:

    Arbitrate access to the DMA adapter object.  There was a mistake in the
    original engine that waited at DISPATCH_LEVEL for mappings.  We can not
    do that.  The temporary solution to this is to not wait and cancel the
    Irp if a wait happens (original idea, not mine).  This fixes the
    deadlock if you're running on PAE, Win64 >4gb or with a non-scatter/gather
    device.  However, it introduces another major difficulty, which is why
    this routine exists.

    It's quite conceivable to have someone running an Audio/Video capture
    filter on a multi-proc.  Imagine the case where one stream (say audio)
    is being serviced (buffer arrivals) on processor A and the other stream
    (say video) is being serviced on processor B.  There's currently DMA
    transfers pending and all map registers are used up (because we're PAE,
    Win64 >4gb, or non s/g hardware).  A calls IoAllocateAdapterChannel and
    waits for callback.  Before the callback happens, B does the same.
    This will explode: NT cannot handle two waits on the same DMA adapter.
    The callbacks will be completely bogus.  Thus, the device (CKsDevice) must
    arbiter access to the adapter and ensure that there are never simultaneous
    requests pending for channel space.

    THIS FUNCTION MUST BE CALLED AT DISPATCH_LEVEL.  NO_EXCEPTIONS!

Arguments:

    MappingsNeeded -
        The client is still responsible for determining how many map registers
        (mappings) are needed.  This is the count of mappings.

    Callback -
        The client's callback.  This would normally be the callback to
        IoAllocateAdapterChannel, but we arbitrate this.

    CallbackContext -
        The client's callback context.  This would normally be the callback
        context to IoAllocateAdapterChannel, but we arbitrate this.

Return Value:

    As per IoAllocateAdapterChannel or STATUS_DEVICE_BUSY if there's
    a pending allocation and we can't wait on the adapter.  TODO: this
    result should change to success if there's a rearchitecture of DMA.

--*/

{

    NTSTATUS status = STATUS_SUCCESS;

    //
    // Acquire the arbiter lock.  This assures that we don't have two threads
    // simultaneously allocating channel space from the DMA adapter.
    //
    KeAcquireSpinLockAtDpcLevel (&m_AdapterArbiterLock);

    //
    // If there is currently an outstanding adapter allocation which has not
    // yet received callback due to lack of map registers, we cannot proceed.
    // Calling IoAllocateAdapterChannel while a callback is pending is suicide
    // on NT.
    //
    if (InterlockedIncrement (&m_AdapterArbiterOutstandingAllocations) == 1) {

        //
        // Fill out the callback context.  The callback will be a callback
        // for the arbiter.  The arbiter's callback calls the client's
        // callback and then decrements the outstanding allocations count
        // so other callers can use the adapter.
        //
        m_ArbiterContext.Device = (PVOID)this;
        m_ArbiterContext.ClientCallback = Callback;
        m_ArbiterContext.ClientContext = CallbackContext;

        status = IoAllocateAdapterChannel (
            m_AdapterObject,
            m_Ext.Public.FunctionalDeviceObject,
            MappingsNeeded,
            CKsDevice::ArbitrateAdapterCallback,
            (PVOID)&m_ArbiterContext
            );

        //
        // If we couldn't allocate the adapter channel, we need to bop back
        // down the arbiter count. 
        //
        if (!NT_SUCCESS (status)) {
            InterlockedDecrement (&m_AdapterArbiterOutstandingAllocations);
        }

    } else {
        //
        // TODO:
        //
        // The whole DMA engine here needs a rearchitecting.  Eventually,
        // we may wish to have an arbitration queue (once the queues and
        // clients can deal with pended map generation).
        //
        // In the mean time, just bop the arbiter count back down.
        //
        status = STATUS_DEVICE_BUSY;
        InterlockedDecrement (&m_AdapterArbiterOutstandingAllocations);
    }

    KeReleaseSpinLockFromDpcLevel (&m_AdapterArbiterLock);

    return status;

}

void
CKsDevice::
RequestPowerIrpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )

/*++

Routine Description:

    This routine handles the completion callback for PoRequestPowerIrp.  It
    is called when the requested power IRP has completed.

Arguments:

    DeviceObject -
        Contains a pointer to the target device object for the requested power
        IRP.

    MinorFunction -
        Contains the requested minor function.

    PowerState -
        Contains the new power state requested.

    Context -
        Contains the context passed to PoRequestPowerIrp.  In this case, it
        will be the system power IRP that inspired the request.

    IoStatus -
        Contiains a pointer to the status block of the completed IRP.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsDevice::RequestPowerIrpCompletion]"));

    ASSERT(DeviceObject);
    ASSERT(Context);

    PIRP irp = reinterpret_cast<PIRP>(Context);

    _DbgPrintF(DEBUGLVL_POWER,("IRP_MN_SET_POWER(%p,%p) completion",DeviceObject,irp,IoStatus->Status));

    CKsDevice *device =
        reinterpret_cast<CKsDevice *>(irp->Tail.Overlay.DriverContext[0]);

    PoStartNextPowerIrp(irp);
    IoSkipCurrentIrpStackLocation(irp);
    ASSERT(DeviceObject == device->m_Ext.Public.NextDeviceObject); // TODO:  If this is the case, we don't need the DriverContext
    PoCallDriver(device->m_Ext.Public.NextDeviceObject,irp);
}


NTSTATUS
CKsDevice::
ForwardIrpCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine handles the completion of an IRP which has been forwarded
    to the next PNP device object.

Arguments:

Return Value:

--*/

{
    ASSERT(DeviceObject);
    ASSERT(Irp);
    ASSERT(Context);

    KeSetEvent(PKEVENT(Context),IO_NO_INCREMENT,FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA

extern "C"
NTSTATUS
DispatchCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


NTSTATUS
CKsDevice::
DispatchCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This function dispatches create IRPs.

Arguments:

    DeviceObject -
        Contains a pointer to the device object to which the specific file
        object belongs.

    Irp -
        Contains a pointer to the Create IRP.

Return Value:

    STATUS_DEVICE_NOT_READY, STATUS_PENDING or the result of further
    dispatching.

--*/
{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsDevice::DispatchCreate]"));

    PAGED_CODE();

    ASSERT(DeviceObject);
    ASSERT(Irp);

    NTSTATUS status;

    CKsDevice *device = CKsDevice::FromDeviceObject(DeviceObject);

    device->AcquireDevice();

    if (device->m_FailCreates) {
        status = STATUS_INVALID_DEVICE_STATE;
    } else if (! device->m_CreatesMayProceed) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("[CKsDevice::DispatchCreate]  pending create request"));

        IoMarkIrpPending(Irp);
        KsAddIrpToCancelableQueue(
            &device->m_PendingCreateIrpList.ListEntry,
            &device->m_PendingCreateIrpList.SpinLock,
            Irp,
            KsListEntryTail,
            NULL);
        status = STATUS_PENDING;
    } else if (! device->m_Ext.Public.Started) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("[CKsDevice::DispatchCreate]  refusing create request"));
        status = STATUS_DEVICE_NOT_READY;
    } else {
        _DbgPrintF(DEBUGLVL_VERBOSE,("[CKsDevice::DispatchCreate]  validating create request"));
        status = STATUS_SUCCESS;
    }

    device->ReleaseDevice();

    #if ( DBG0 )
    //
    // Throw an extra open. A mini driver should not acquire any resources
    // until Acquire state. Therefore, opens should not be failed because of
    // out of driver resources. The extra open could cause false positive but
    // we do it at DBG build only. It's beter safe than sorry.
    //
    if ( status == STATUS_SUCCESS ) {
        PFILE_OBJECT pFileObject;
        NTSTATUS     testStatus;
        CCHAR        StackSize;
        
        pFileObject = IoGetCurrentIrpStackLocation(Irp)->FileObject;
        StackSize = Irp->StackCount;
        
        //
        // normal op
        //
        status = ::DispatchCreate(DeviceObject,Irp);

        if ( status == STATUS_SUCCESS && pFileObject ) {
            //
            // only test if success, ignore the pending case
            //
            testIrp = IoAllocateIrp( StatckSize, FALSE );
            
            testStatus = ::DispatchCreate(DeviceObject,testIrp);
            ASSERT( STATUS_SUCCESS == testStatus );
            testStatus = ::DispatchClose(DeviceObject, testIrp );
            ASSERT( STATUS_SUCCESS == testStatus );
            ExFreePool( pFileObject );
            IoFreeIrp( testIrp );           
        }
    } else if (status != STATUS_PENDING) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
    }

    #else // not (DBG)
    
    if (status == STATUS_SUCCESS) {
        status = ::DispatchCreate(DeviceObject,Irp);
    } else if (status != STATUS_PENDING) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
    }
    #endif

    return status;
}


NTSTATUS
CKsDevice::
ForwardIrpSynchronous(
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine forwards a PnP IRP to the next device object.  The IRP is
    not completed at this level, this function does not return until the
    lower driver has completed the IRP.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsDevice::ForwardIrpSynchronous]"));

    PAGED_CODE();

    ASSERT(Irp);

    NTSTATUS status;

    PIO_STACK_LOCATION irpSp =
        IoGetCurrentIrpStackLocation(Irp);
    PIO_STACK_LOCATION nextIrpSp =
        IoGetNextIrpStackLocation(Irp);

    nextIrpSp->MajorFunction = irpSp->MajorFunction;
    nextIrpSp->MinorFunction = irpSp->MinorFunction;
    nextIrpSp->Flags = irpSp->Flags;
    nextIrpSp->Control = irpSp->Control;
    nextIrpSp->Parameters = irpSp->Parameters;
    nextIrpSp->FileObject = irpSp->FileObject;

    KEVENT event;
    KeInitializeEvent(&event,NotificationEvent,FALSE);

    IoSetCompletionRoutine(
        Irp,
        ForwardIrpCompletionRoutine,
        &event,     // Context
        TRUE,       // InvokeOnSuccess
        TRUE,       // InvokeOnError
        TRUE);      // InvokeOnCancel

    if (irpSp->MajorFunction == IRP_MJ_POWER) {
        status = PoCallDriver(m_Ext.Public.NextDeviceObject,Irp);
    } else {
        status = IoCallDriver(m_Ext.Public.NextDeviceObject,Irp);
    }

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(
            &event,
            Suspended,
            KernelMode,
            FALSE,
            NULL);
        status = Irp->IoStatus.Status;
    }

    return status;
}


NTSTATUS
CKsDevice::
CompleteIrp(
    IN PIRP Irp,
    IN NTSTATUS status
    )

/*++

Routine Description:

    This routine completes an IRP unless status is STATUS_PENDING.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsDevice::CompleteIrp]"));

    PAGED_CODE();

    ASSERT(Irp);

    if (status != STATUS_PENDING) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp,IO_NO_INCREMENT);
    }

    return status;
}


KSDDKAPI
NTSTATUS
NTAPI
KsInitializeDevice(
    IN PDEVICE_OBJECT FunctionalDeviceObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN PDEVICE_OBJECT NextDeviceObject,
    IN const KSDEVICE_DESCRIPTOR* Descriptor OPTIONAL
    )

/*++

Routine Description:

    This routine initializes a device for use with the .

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsInitializeDevice]"));

    PAGED_CODE();

    ASSERT(FunctionalDeviceObject);
    ASSERT(PhysicalDeviceObject);
    ASSERT(NextDeviceObject);

    CKsDevice *device =
        new(NonPagedPool,POOLTAG_DEVICE) CKsDevice(NULL);

    NTSTATUS status;
    if (device) {
        device->AddRef();
        status = device->Init(
            FunctionalDeviceObject,
            PhysicalDeviceObject,
            NextDeviceObject,
            Descriptor);
        device->Release();
    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return status;
}


KSDDKAPI
void
NTAPI
KsTerminateDevice(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine terminates a device for use with the .

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsTerminateDevice]"));

    PAGED_CODE();

    ASSERT(DeviceObject);

    PKSIDEVICE_HEADER deviceHeader =
        *(PKSIDEVICE_HEADER *)(DeviceObject->DeviceExtension);

    if (deviceHeader) {
        PKSDEVICE Device = PKSDEVICE(deviceHeader->Object);

        #ifndef WIN9X_KS // WinME: 142427 (present on 9x's)

        //
        // Free the device header first because this releases the filter
        // factories.  The filter factories remove themselves from the
        // device's child list, which needs to exist.
        //
        deviceHeader->Object = NULL;

        KsFreeDeviceHeader(KSDEVICE_HEADER(deviceHeader));

        #endif // WIN9X_KS

        if (Device) {
            CKsDevice::FromStruct(Device)->Release();
        }
    }
}


CKsDevice::
CKsDevice(PUNKNOWN OuterUnknown):
    CBaseUnknown(OuterUnknown)
{
}


CKsDevice::
~CKsDevice(
    void
    )

/*++

Routine Description:

    This routine destructs a  device object.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsDevice::~CKsDevice]"));

    PAGED_CODE();

    #ifdef WIN9X_KS // WinME: 142427 (present on 9x's)

    //
    // Complete deferred deletion of device header.
    //
    // NOTE: If filter factories hold references on the device...  This
    // could become an issue.
    //
    PKSIDEVICE_HEADER deviceHeader =
        *(PKSIDEVICE_HEADER *)(m_Ext.Public.FunctionalDeviceObject->
        DeviceExtension);
    PDEVICE_OBJECT nextDeviceObject = m_Ext.Public.NextDeviceObject;
    PDEVICE_OBJECT DeviceObject = m_Ext.Public.FunctionalDeviceObject;


    if (deviceHeader) {
        //
        // Free the device header first because this releases the filter
        // factories.  The filter factories remove themselves from the
        // device's child list, which needs to exist.
        //
        PKSDEVICE Device = PKSDEVICE(deviceHeader->Object);
        deviceHeader->Object = NULL;

        KsFreeDeviceHeader(KSDEVICE_HEADER(deviceHeader));

        //
        // Gone for good.
        //
        IoDetachDevice(nextDeviceObject);
        IoDeleteDevice(DeviceObject);

        #if DBG
            DbgPrint ("    Deferred dhdr deletion!\n");
        #endif // DBG

    }

    #endif // WIN9X_KS

    ASSERT(IsListEmpty(&m_PowerNotifyList));

    if (m_Ext.AggregatedClientUnknown) {
        m_Ext.AggregatedClientUnknown->Release();
    }

    KspTerminateObjectBag(&m_ObjectBag);
    KspTerminateDeviceBag(&m_DeviceBag);

    if (m_BusInterfaceStandard.Size) {
        m_BusInterfaceStandard.InterfaceDereference(m_BusInterfaceStandard.Context);
    }
}


STDMETHODIMP
CKsDevice::
NonDelegatedQueryInterface(
    IN REFIID InterfaceId,
    OUT PVOID* InterfacePointer
    )

/*++

Routine Description:

    This routine obtains an interface to a device object.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsDevice::NonDelegatedQueryInterface]"));

    PAGED_CODE();

    ASSERT(InterfacePointer);

    NTSTATUS status = STATUS_SUCCESS;

    if (IsEqualGUIDAligned(InterfaceId,__uuidof(IKsDevice))) {
        *InterfacePointer = reinterpret_cast<PVOID>(static_cast<PIKSDEVICE>(this));
        AddRef();
    } else {
        status =
            CBaseUnknown::NonDelegatedQueryInterface(
                InterfaceId,
                InterfacePointer);
        if (! NT_SUCCESS(status) && m_Ext.AggregatedClientUnknown) {
            status = m_Ext.AggregatedClientUnknown->
                QueryInterface(InterfaceId,InterfacePointer);
        }
    }

    return status;
}


NTSTATUS
CKsDevice::
GetBusInterfaceStandard(
    )
{
    //
    // There is no file object associated with this Irp, so the event may be
    // located on the stack as a non-object manager object.
    //
    KEVENT event;
    KeInitializeEvent(&event, NotificationEvent, FALSE);
    IO_STATUS_BLOCK ioStatusBlock;
    PIRP irp = IoBuildSynchronousFsdRequest(
        IRP_MJ_PNP,
        m_Ext.Public.NextDeviceObject,
        NULL,
        0,
        NULL,
        &event,
        &ioStatusBlock);
    NTSTATUS status;
    if (irp) {
        irp->RequestorMode = KernelMode;
        irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        PIO_STACK_LOCATION irpStackNext = IoGetNextIrpStackLocation(irp);
        //
        // Create an interface query out of the Irp.
        //
        irpStackNext->MinorFunction = IRP_MN_QUERY_INTERFACE;
        irpStackNext->Parameters.QueryInterface.InterfaceType = &GUID_BUS_INTERFACE_STANDARD;
        irpStackNext->Parameters.QueryInterface.Size = sizeof(m_BusInterfaceStandard);
        irpStackNext->Parameters.QueryInterface.Version = 1;
        irpStackNext->Parameters.QueryInterface.Interface = reinterpret_cast<PINTERFACE>(&m_BusInterfaceStandard);
        irpStackNext->Parameters.QueryInterface.InterfaceSpecificData = NULL;
        status = IoCallDriver(m_Ext.Public.NextDeviceObject, irp);
        if (status == STATUS_PENDING) {
            //
            // This waits using KernelMode, so that the stack, and therefore the
            // event on that stack, is not paged out.
            //
            KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
            status = ioStatusBlock.Status;
        }
        if (!NT_SUCCESS(status)) {
            //
            // HACKHACK: (WRM 8/23/99)
            //
            // Unfortunately, the Millennium PCI Bus drivers don't support
            // processing of WDM Irps (CONFIG_IRP) and thus return
            // STATUS_NOT_IMPLEMENTED.  A Ks2.0 hardware driver won't be
            // able to use Ks functions to touch the bus under Millennium.
            // This is why STATUS_NOT_IMPLEMENTED is handled like this.
            //
            if (status == STATUS_NOT_SUPPORTED ||
                status == STATUS_NOT_IMPLEMENTED) {
                status = STATUS_SUCCESS;
            }
            //
            // In case the bus decided to write in values, then return an error.
            // non-NULL values are asserted in later calls, and used to determine
            // if the interface was acquired during object destruction.
            // Also possible here that Millennium PCI bus drivers did not
            // support the query.
            //
            RtlZeroMemory(&m_BusInterfaceStandard, sizeof(m_BusInterfaceStandard));
        }
    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }
    return status;
}


NTSTATUS
CKsDevice::
Init(
    IN PDEVICE_OBJECT FunctionalDeviceObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN PDEVICE_OBJECT NextDeviceObject,
    IN const KSDEVICE_DESCRIPTOR* Descriptor OPTIONAL
    )

/*++

Routine Description:

    This routine initializes a  device object.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsDevice::Init]"));

    PAGED_CODE();

    ASSERT(FunctionalDeviceObject);
    ASSERT(PhysicalDeviceObject);
    ASSERT(NextDeviceObject);

    InitializeListHead(&m_Ext.ChildList);
    m_Ext.ObjectType = KsObjectTypeDevice;
    m_Ext.Interface = this;
    m_Ext.Device = this;

    m_Ext.Public.Descriptor = Descriptor;
    m_Ext.Public.Bag = reinterpret_cast<KSOBJECT_BAG>(&m_ObjectBag);
    m_Ext.Public.FunctionalDeviceObject = FunctionalDeviceObject;
    m_Ext.Public.PhysicalDeviceObject = PhysicalDeviceObject;
    m_Ext.Public.NextDeviceObject = NextDeviceObject;

    KeInitializeMutex(&m_PowerNotifyMutex, 0);
    KeInitializeMutex(&m_Mutex, 0);

    ExInitializeWorkItem(&m_CloseWorkItem,CloseWorker,this);
    InitializeInterlockedListHead(&m_CloseIrpList);
    InitializeInterlockedListHead(&m_PendingCreateIrpList);
    InitializeInterlockedListHead(&m_PendingRunIrpList);
    InitializeListHead(&m_PowerNotifyList);
    m_RunsMayProceed = TRUE;

    // to support bus driver
    m_IsParentFdo = FALSE;              // till found
    m_ChildEnumedFromRegistry = FALSE;  // need to check registry
    m_pNextChildPdo = NULL;

    // This will get set on PnP start or poststart depending.
    m_AllowIo = FALSE;
    
    // NOTE: This is temporary until the Pnp code gets overhauled.
    m_FailCreates = FALSE;

    m_AdapterArbiterOutstandingAllocations = 0;
    KeInitializeSpinLock (&m_AdapterArbiterLock);

    KspInitializeDeviceBag(&m_DeviceBag);
    InitializeObjectBag(&m_ObjectBag,NULL);

    //
    // Set the current power states.
    //
    m_Ext.Public.DevicePowerState = PowerDeviceD0;
    m_Ext.Public.SystemPowerState = PowerSystemWorking;

    //
    // Allocate a device header if we need to.
    //
    NTSTATUS status;
    PKSIDEVICE_HEADER deviceHeader =
        *(PKSIDEVICE_HEADER *)(FunctionalDeviceObject->DeviceExtension);

    if (! deviceHeader) {
        //
        // We need to allocate a header.
        //
        status = KsAllocateDeviceHeader(
            (KSDEVICE_HEADER *) &deviceHeader,0,NULL);

        if (NT_SUCCESS(status)) {
            *(PKSIDEVICE_HEADER *)
                (FunctionalDeviceObject->DeviceExtension) =
                    deviceHeader;
        }
    } else {
        status = STATUS_SUCCESS;
    }

    //
    // Install the  structure in the header.
    //
    if (NT_SUCCESS(status)) {
        deviceHeader->Object = PVOID(&m_Ext.Public);
    }

    //
    // Set up device header for PnP and power management.
    //
    if (NT_SUCCESS(status)) {
        KsSetDevicePnpAndBaseObject(
            *reinterpret_cast<KSDEVICE_HEADER*>(
                FunctionalDeviceObject->DeviceExtension),
            NextDeviceObject,
            FunctionalDeviceObject);
    }

    if (NT_SUCCESS(status)) {
        status = GetBusInterfaceStandard();
    }

    //
    // Create filter factories.
    //
    if (NT_SUCCESS(status) && Descriptor) {
        //AcquireDevice();
        const KSFILTER_DESCRIPTOR*const* filterDescriptor =
            Descriptor->FilterDescriptors;
        for (ULONG ul = Descriptor->FilterDescriptorsCount;
             NT_SUCCESS(status) && ul--;
             filterDescriptor++) {
            status =
                KspCreateFilterFactory(
                    &m_Ext,
                    &m_Ext.ChildList,
                    *filterDescriptor,
                    NULL,
                    NULL,
                    0,
                    NULL,
                    NULL,
                    NULL);
        }
        //ReleaseDevice();
    }

    //
    // Call the add callback if there is one.
    //
    if (NT_SUCCESS(status) &&
        Descriptor &&
        Descriptor->Dispatch &&
        Descriptor->Dispatch->Add) {
        status = Descriptor->Dispatch->Add(&m_Ext.Public);
#if DBG
        if (status == STATUS_PENDING) {
            _DbgPrintF(DEBUGLVL_ERROR,("CLIENT BUG:  AddDevice (Create) handler returned STATUS_PENDING"));
        }
#endif
    }

    //
    // Add a reference for the device header's reference to the object.
    //
    AddRef();

    //
    // Cleanup on failure. KsTerminateDevice() assumes there is a reference
    // for the device header, so it's OK that we already AddRef()ed.
    //
    if (! NT_SUCCESS(status)) {
        KsTerminateDevice(FunctionalDeviceObject);
    }

    return status;
}


STDMETHODIMP_(void)
CKsDevice::
AcquireDevice(
    void
    )

/*++

Routine Description:

    This routine acquires sychronized access to the device.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsDevice::AcquireDevice]"));

    PAGED_CODE();

    KeWaitForMutexObject (
        &m_Mutex,
        Executive,
        KernelMode,
        FALSE,
        NULL
        );
}


STDMETHODIMP_(void)
CKsDevice::
ReleaseDevice(
    void
    )

/*++

Routine Description:

    This routine releases sychronized access to the device.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsDevice::ReleaseDevice]"));

    PAGED_CODE();

    KeReleaseMutex (
        &m_Mutex,
        FALSE
        );

}


KSDDKAPI
void
NTAPI
KsAcquireDevice(
    IN PKSDEVICE Device
    )

/*++

Routine Description:

    This routine acquires sychronized access to the device.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsAcquireDevice]"));

    PAGED_CODE();

    ASSERT(Device);

    CKsDevice::FromStruct(Device)->AcquireDevice();
}


KSDDKAPI
void
NTAPI
KsReleaseDevice(
    IN PKSDEVICE Device
    )

/*++

Routine Description:

    This routine releases sychronized access to the device.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsReleaseDevice]"));

    PAGED_CODE();

    ASSERT(Device);

    CKsDevice::FromStruct(Device)->ReleaseDevice();
}


STDMETHODIMP_(void)
CKsDevice::
GetAdapterObject(
    OUT PADAPTER_OBJECT* AdapterObject,
    OUT PULONG MaxMappingByteCount,
    OUT PULONG MappingTableStride
    )

/*++

Routine Description:

    This routine gets the adapter object and related information.

Arguments:

    AdapterObject -
        Contains a pointer to the location at which to deposit a pointer to the
        adapter object.  The pointer to the adapter object will be NULL if no
        adapter object has been registered.

    MaxMappingByteCount -
        Contains a pointer to the location at which to deposit the maximum
        mapping byte count.  The count will be zero if no adapter object has
        been registered.

    MappingTableStride -
        Contains a pointer to the location at which to deposit the mapping
        table stride.  The count will be zero if no adapter object has been
        registered.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsDevice::GetAdapterObject]"));

    PAGED_CODE();

    ASSERT(AdapterObject);
    ASSERT(MaxMappingByteCount);
    ASSERT(MappingTableStride);

    *AdapterObject = m_AdapterObject;
    *MaxMappingByteCount = m_MaxMappingByteCount;
    *MappingTableStride = m_MappingTableStride;
}

#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif // ALLOC_PRAGMA


KSDDKAPI
PKSDEVICE
NTAPI
KsGetDeviceForDeviceObject(
    IN PDEVICE_OBJECT FunctionalDeviceObject
    )

/*++

Routine Description:

    This routine returns the KSDEVICE associated with a given functional
    device object.  If a child PDO is passed, this routine will return
    NULL.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsGetDeviceForDeviceObject]"));

    ASSERT(FunctionalDeviceObject);

    PKSPDO_EXTENSION pKsPdoExtension = 
        (PKSPDO_EXTENSION)FunctionalDeviceObject->DeviceExtension;

    //
    // Return NULL for a child PDO. 
    //
    if (KS_PDO_SIGNATURE == pKsPdoExtension->m_PdoSignature) 
        return NULL;

    return
        PKSDEVICE(
            (*(PKSIDEVICE_HEADER*) FunctionalDeviceObject->DeviceExtension)->
                Object);
}


KSDDKAPI
void
NTAPI
KsCompletePendingRequest(
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine completes a pending request.

Arguments:

    Irp -
        Contains a pointer to the IRP to complete.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsCompletePendingRequest]"));

    ASSERT(Irp);

    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

    switch (irpSp->MajorFunction) {
    case IRP_MJ_CREATE:
        //
        // Create IRPs can just be completed if they succeed.  Otherwise they
        // fall through and are treated like close IRPs.
        //
        if (NT_SUCCESS(Irp->IoStatus.Status)) {
            IoCompleteRequest(Irp,IO_NO_INCREMENT);
            break;
        }

    case IRP_MJ_CLOSE:
        //
        // Close IRPs and failed creates need to be redispatched through the
        // object header.  This can only be done at passive level, so we use
        // a worker if we are not there already.
        //
        if (KeGetCurrentIrql() == PASSIVE_LEVEL) {
            //
            // Passive level...dispatch the IRP as a close throught the object
            // header.  Even failed creates get dispatched this way.
            //
            PKSIOBJECT_HEADER objectHeader =
                *(PKSIOBJECT_HEADER*)irpSp->FileObject->FsContext;
            ASSERT(objectHeader);

            objectHeader->DispatchTable->Close(irpSp->DeviceObject,Irp);
        } else {
            //
            // Not passive...tell the device to queue the IRP for completion by
            // CloseWorker.
            //
            CKsDevice *device =
                CKsDevice::FromDeviceObject(irpSp->DeviceObject);
            device->QueuePendedClose(Irp);
        }
        break;

        // TODO:  Deallocation for automation.
    default:
        //
        // All other IRPs are simply completed.
        //
        IoCompleteRequest(Irp,IO_NO_INCREMENT);
        break;
    }
}


void
CKsDevice::
QueuePendedClose(
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine queues a pended close or a pended, failed create for
    completion by a work item.

Arguments:

    Irp -
        Contains a pointer to the IRP to queue.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsDevice::QueuePendedClose]"));

    ASSERT(Irp);

    KsAddIrpToCancelableQueue(
        &m_CloseIrpList.ListEntry,
        &m_CloseIrpList.SpinLock,
        Irp,
        KsListEntryTail,
        NULL);

    ExQueueWorkItem(&m_CloseWorkItem,DelayedWorkQueue);
}

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA


STDMETHODIMP_(void)
CKsDevice::
InitializeObjectBag(
    IN PKSIOBJECTBAG ObjectBag,
    IN PKMUTEX Mutex OPTIONAL
    )

/*++

Routine Description:

    This routine initializes an object bag.

Arguments:

    ObjectBag -
        Contains a pointer to the object bag to be initialized.

    Mutex -
        Contains an optional pointer to a mutex which should
        be taken whenever the bag is used.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsDevice::InitializeObjectBag]"));

    PAGED_CODE();

    ASSERT(ObjectBag);

    ObjectBag->HashTableEntryCount = OBJECTBAGHASHTABLE_INITIALSIZE;
    ObjectBag->HashMask = OBJECTBAGHASHTABLE_INITIALMASK;
    ObjectBag->DeviceBag = &m_DeviceBag;
    if (Mutex) {
        ObjectBag->Mutex = Mutex;
    } else {
        ObjectBag->Mutex = &m_Mutex;
    }

    //
    // FULLMUTEX: when two bag mutexes must be taken in the context of the
    // same thread, we must know what order to take them.  This pertains
    // to the fullmutex changes.
    //
    ObjectBag -> MutexOrder =
        (ObjectBag -> Mutex == &m_Mutex);
}


STDMETHODIMP_(void)
CKsDevice::
AddPowerEntry(
    IN PKSPPOWER_ENTRY PowerEntry,
    IN PIKSPOWERNOTIFY PowerNotify
    )

/*++

Routine Description:

    This routine adds a power entry to the power notification list.  The
    PowerNotify argument is copied into the entry.

    NOTE:

        Previously, this required the device mutex held.  This created a
        deadlock scenario due to resource acquisition order.  These routines
        are synchronized with a new fast mutex and use of the list is
        synchronized with both.  It is no longer necessary to have the device
        mutex held while calling this routine (although it is harmless if
        already acquired).

Arguments:

    PowerEntry -
        Contains a pointer to a power entry to add to the power notification
        list.  This entry must not be in the list already, and its
        ProcessingObject field should be NULL to indicate this.

    PowerNotify -
        Contains a pointer to the power notification interface to be added
        to the list using the entry.  This value is copied into the
        PowerNotify field of the PowerEntry.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsDevice::AddPowerEntry]"));

    PAGED_CODE();

    ASSERT(PowerEntry);
    ASSERT(PowerNotify);
    ASSERT(! PowerEntry->PowerNotify);

    KeWaitForMutexObject (
        &m_PowerNotifyMutex,
        Executive,
        KernelMode,
        FALSE,
        NULL
        );

    PowerEntry->PowerNotify = PowerNotify;
    InsertTailList(&m_PowerNotifyList,&PowerEntry->ListEntry);
    if (m_Ext.Public.DevicePowerState > PowerDeviceD0) {
        PowerNotify->Sleep(m_Ext.Public.DevicePowerState);
    }

    KeReleaseMutex (&m_PowerNotifyMutex, FALSE);

}


STDMETHODIMP_(void)
CKsDevice::
RemovePowerEntry(
    IN PKSPPOWER_ENTRY PowerEntry
    )

/*++

Routine Description:

    This routine remove a power entry to the power notification list.  The
    PowerNotify field of the power entry is cleared.

    NOTE:

        Previously, this required the device mutex held.  This created a
        deadlock scenario due to resource acquisition order.  These routines
        are synchronized with a new fast mutex and use of the list is
        synchronized with both.  It is no longer necessary to have the device
        mutex held while calling this routine (although it is harmless if
        already acquired).

Arguments:

    PowerEntry -
        Contains a pointer to a power entry to remove to the power notification
        list.  This entry must be in the list if and only if its PowerNotify
        field is non-NULL.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsDevice::RemovePowerEntry]"));

    PAGED_CODE();

    ASSERT(PowerEntry);

    KeWaitForMutexObject (
        &m_PowerNotifyMutex,
        Executive,
        KernelMode,
        FALSE,
        NULL
        );

    if (PowerEntry->PowerNotify) {
        RemoveEntryList(&PowerEntry->ListEntry);
        PowerEntry->PowerNotify = NULL;
    }

    KeReleaseMutex (&m_PowerNotifyMutex, FALSE);
}


STDMETHODIMP
CKsDevice::
PinStateChange(
    IN PKSPIN Pin,
    IN PIRP Irp OPTIONAL,
    IN KSSTATE To,
    IN KSSTATE From
    )

/*++

Routine Description:

    This routine is called when a pin changes connection state.  The call
    informs the device of the change and determines if the change can occur.
    If the change can occur, STATUS_SUCCESS is returned.  If the change must
    wait for a power state change, STATUS_PENDING is returned.  If the change
    cannot occur due to the power state, an error status is returned.

Arguments:

    Pin -
        Contains a pointer to the pin which is changing state.

    Irp -
        Contains an optional pointer to the state change request.  If no IRP
        is supplied, this indicates that a previous pin state change has
        failed, and its effect needs to be undone.

    To -
        Contains the new state.

    From -
        Contains the previous state.

Return Value:

    Status.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsDevice::PinStateChange]"));

    PAGED_CODE();

    ASSERT(Pin);

    //
    // TODO:  Most of power policy can be implemented here.
    //

    AcquireDevice();

    NTSTATUS status;
    if (To == From) {
        //
        // Not interested in no-ops.
        //
        status = STATUS_SUCCESS;
    } else if (To == KSSTATE_RUN) {
        //
        // Going to the run state.
        //
        if (! m_RunsMayProceed) {
            //
            // We are holding on to these IRPs for now.
            //
            _DbgPrintF(DEBUGLVL_POWER,("device %p pending run request %p",m_Ext.Public.FunctionalDeviceObject,Irp));
            IoMarkIrpPending(Irp);
            KsAddIrpToCancelableQueue(
                &m_PendingRunIrpList.ListEntry,
                &m_PendingRunIrpList.SpinLock,
                Irp,
                KsListEntryTail,
                NULL);
            status = STATUS_PENDING;
        } else if ((m_Ext.Public.SystemPowerState == PowerSystemShutdown) && Irp) {
            //
            // The system is shutting down.  Fail the IRP.
            //
            _DbgPrintF(DEBUGLVL_POWER,("device %p failing run request %p",m_Ext.Public.FunctionalDeviceObject,Irp));
            status = STATUS_DEVICE_NOT_READY;
        } else {
            //
            // The system is not shutting down.  The transition may occur,
            // but the device may be asleep.
            //
            if ((m_ActivePinCount++ == 0) &&
                IoIsWdmVersionAvailable(0x01,0x10)) {
                //
                // Indicate we need the system.
                //
                _DbgPrintF(DEBUGLVL_POWER,("device %p active pin count is now non-zero:  calling PoRegisterSystemState",m_Ext.Public.FunctionalDeviceObject));
                #ifndef WIN98GOLD_KS
                m_SystemStateHandle =
                    PoRegisterSystemState(
                        m_SystemStateHandle,
                        ES_SYSTEM_REQUIRED | ES_CONTINUOUS);
                #endif
            }
            status = STATUS_SUCCESS;
        }
    } else if (From == KSSTATE_RUN) {
        //
        // Leaving the run state.
        //
        if ((m_ActivePinCount-- == 1) && IoIsWdmVersionAvailable(0x01,0x10)) {
            //
            // Indicate we no longer need the system.
            //
            _DbgPrintF(DEBUGLVL_POWER,("device %p active pin count is now zero:  calling PoUnregisterSystemState",m_Ext.Public.FunctionalDeviceObject));
            #ifndef WIN98GOLD_KS
            PoUnregisterSystemState(m_SystemStateHandle);
            m_SystemStateHandle = NULL;
            #endif
        }
        status = STATUS_SUCCESS;
    } else {
        //
        // Other transitions.
        //
        status = STATUS_SUCCESS;
    }

    ReleaseDevice();

    return status;
}


void
CKsDevice::
RedispatchPendingCreates(
    void
    )

/*++

Routine Description:

    This routine redispatches create IRPs which were pended because a QUERY_STOP
    or QUERY_REMOVE was in effect.

Arguments:

    None.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsDevice::RedispatchPendingCreates]"));

    PAGED_CODE();

    m_CreatesMayProceed = TRUE;
    while (1) {
        PIRP irp =
            KsRemoveIrpFromCancelableQueue(
                &m_PendingCreateIrpList.ListEntry,
                &m_PendingCreateIrpList.SpinLock,
                KsListEntryHead,
                KsAcquireAndRemoveOnlySingleItem);

        if (! irp) {
            break;
        }

        KsDispatchIrp(m_Ext.Public.FunctionalDeviceObject,irp);
    }
}


void
CKsDevice::
RedispatchPendingRuns(
    void
    )

/*++

Routine Description:

    This routine redispatches run IRPs which were pended because a QUERY_POWER
    was in effect.

Arguments:

    None.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_POWER,("[CKsDevice::RedispatchPendingRuns]"));

    PAGED_CODE();

    m_RunsMayProceed = TRUE;
    while (1) {
        PIRP irp =
            KsRemoveIrpFromCancelableQueue(
                &m_PendingRunIrpList.ListEntry,
                &m_PendingRunIrpList.SpinLock,
                KsListEntryHead,
                KsAcquireAndRemoveOnlySingleItem);

        if (! irp) {
            break;
        }

        KsDispatchIrp(m_Ext.Public.FunctionalDeviceObject,irp);
    }
}


KSDDKAPI
NTSTATUS
NTAPI
KsCreateFilterFactory(
    IN PDEVICE_OBJECT DeviceObject,
    IN const KSFILTER_DESCRIPTOR* Descriptor,
    IN PWCHAR RefString OPTIONAL,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor OPTIONAL,
    IN ULONG CreateItemFlags,
    IN PFNKSFILTERFACTORYPOWER SleepCallback OPTIONAL,
    IN PFNKSFILTERFACTORYPOWER WakeCallback OPTIONAL,
    OUT PKSFILTERFACTORY* FilterFactory OPTIONAL
    )

/*++

Routine Description:

    This routine creates a new KS filter factory.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsCreateFilterFactory]"));

    PAGED_CODE();

    ASSERT(DeviceObject);
    ASSERT(Descriptor);

    PKSIDEVICE_HEADER deviceHeader =
        *(PKSIDEVICE_HEADER *)(DeviceObject->DeviceExtension);
    ASSERT(deviceHeader);

    PKSDEVICE device = PKSDEVICE(deviceHeader->Object);
    ASSERT(device);

    return
        KspCreateFilterFactory(
            CONTAINING_RECORD(device,KSDEVICE_EXT,Public),
            &CONTAINING_RECORD(device,KSDEVICE_EXT,Public)->ChildList,
            Descriptor,
            RefString,
            SecurityDescriptor,
            CreateItemFlags,
            SleepCallback,
            WakeCallback,
            FilterFactory);
}


KSDDKAPI
void
NTAPI
KsDeviceRegisterAdapterObject(
    IN PKSDEVICE Device,
    IN PADAPTER_OBJECT AdapterObject,
    IN ULONG MaxMappingByteCount,
    IN ULONG MappingTableStride
    )

/*++

Routine Description:

    This routine registers an adapter object for scatter/gather operations.

Arguments:

    Device -
        Contains a pointer to the KS device object.

    AdapterObject -
        Contains a pointer to the adapter object being registered.

    MaxMappingByteCount -
        Contains the maximum number of bytes allowed in any given mapping
        for adapters that have a limited transfer size.  This must be a
        multiple of 8.

    MappingTableStride -
        Contains the size in bytes of the mapping table entries that KS will
        generate.  This must be at least sizeof(KSMAPPING) and a multiple of 8.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsDeviceRegisterAdapterObject]"));

    PAGED_CODE();

    ASSERT(Device);
    ASSERT(AdapterObject);
    ASSERT(MaxMappingByteCount);
    ASSERT((MaxMappingByteCount & FILE_QUAD_ALIGNMENT) == 0);
    ASSERT(MappingTableStride);
    ASSERT((MappingTableStride & FILE_QUAD_ALIGNMENT) == 0);

    CKsDevice* device = CKsDevice::FromStruct(Device);

    device->
        RegisterAdapterObject(
            AdapterObject,
            MaxMappingByteCount,
            MappingTableStride);
}


KSDDKAPI
NTSTATUS
NTAPI
KsAllocateObjectBag(
    IN PKSDEVICE Device,
    OUT KSOBJECT_BAG* ObjectBag
    )

/*++

Routine Description:

    This routine creates an object bag.

Arguments:

    Device -
        Contains a pointer to the device with which the bag is to be
        associated.

    ObjectBag -
        Contains a pointer to the location at which the object bag
        is to be deposited.

Return Value:

    Status.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsAllocateObjectBag]"));

    PAGED_CODE();

    ASSERT(Device);
    ASSERT(ObjectBag);

    PKSIOBJECTBAG objectBag = new(PagedPool,POOLTAG_OBJECTBAG) KSIOBJECTBAG;

    NTSTATUS status;
    if (objectBag) {
        status = STATUS_SUCCESS;
        CKsDevice::FromStruct(Device)->InitializeObjectBag(objectBag,NULL);
        *ObjectBag = reinterpret_cast<KSOBJECT_BAG>(objectBag);
    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return status;
}


KSDDKAPI
void
NTAPI
KsFreeObjectBag(
    IN KSOBJECT_BAG ObjectBag
    )

/*++

Routine Description:

    This routine deletes an object bag a object bag.

Arguments:

    ObjectBag -
        Contains a pointer to the object bag to be deleted.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsFreeObjectBag]"));

    PAGED_CODE();

    ASSERT(ObjectBag);

    PKSIOBJECTBAG objectBag = reinterpret_cast<PKSIOBJECTBAG>(ObjectBag);

    KspTerminateObjectBag(objectBag);

    delete objectBag;
}

#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif // ALLOC_PRAGMA

#if DBG

BOOLEAN
KspIsDeviceMutexAcquired (
    IN PIKSDEVICE Device
    )

/*++

Routine Description:

    Debug routine.  Returns whether or not the device mutex for a particular
    device is held.

--*/

{

    PKMUTEX Mutex = &(((CKsDevice *)Device) -> m_Mutex);

    //
    // KeReadStateMutex -> KeReadStateMutant (undefined?).  Just read the
    // thing; this is debug code.
    //
    return (BOOLEAN)((Mutex -> Header.SignalState) != 1);

}

#endif // DBG


KSDDKAPI
ULONG
NTAPI
KsDeviceGetBusData(
    IN PKSDEVICE Device,
    IN ULONG DataType,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine reads data from the bus.

Arguments:

    Device -
        Contains the device whose bus is queried.

    DataType -
        The space from which the data is to be read.

    Buffer -
        The buffer in which to place the data read.

    Offset -
        The offset into the data space.

    Length -
        The number of bytes to read.

Return Value:

    Returns the number of bytes read.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsDeviceGetBusData]"));

    ASSERT(Device);

    return CKsDevice::FromStruct(Device)->GetBusData(DataType, Buffer, Offset, Length);
}



KSDDKAPI
ULONG
NTAPI
KsDeviceSetBusData(
    IN PKSDEVICE Device,
    IN ULONG DataType,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine writes data on the bus.

Arguments:

    Device -
        Contains the device whose bus is queried.

    DataType -
        The space from which the data is to be written.

    Buffer -
        The buffer containing the data to write.

    Offset -
        The offset into the data space.

    Length -
        The number of bytes to write

Return Value:

    Returns the number of bytes written.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsDeviceSetBusData]"));

    ASSERT(Device);

    return CKsDevice::FromStruct(Device)->SetBusData(DataType, Buffer, Offset, Length);
}

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA


KSDDKAPI
NTSTATUS
NTAPI
KsDispatchIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This function is used to multiplex any valid Irp to a specific file context.
    It assumes the client is using the KSDISPATCH_TABLE method of dispatching
    IRP's. This function is assigned when a filter uses
    KsSetMajorFunctionHandler.

Arguments:

    DeviceObject -
        Contains the device object to which the specific file object belongs.

    Irp -
        Contains the Irp to pass on to the specific file context.

Return Value:

    Returns the value of the Irp function.

--*/
{
    PKSIOBJECT_HEADER ObjectHeader;
    PIO_STACK_LOCATION IrpStack;

    PAGED_CODE();
    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    //
    // If there is an entry in the DriverObject for this major Irp class, then
    // there must be an entry in the dispatch table which either points to
    // KsDispatchInvalidDeviceRequest, or points to a real dispatch function.
    //
    // Also allow create requests directed to CreateItem's on a device object
    // to be accepted. In this case there will not be an existing object header
    // pointer in FsContext.
    //
    if (IrpStack->FileObject && IrpStack->FileObject->FsContext) {
        ObjectHeader = *(PKSIOBJECT_HEADER*)IrpStack->FileObject->FsContext;
#if DBG
    } else {
        ObjectHeader = NULL;
#endif
    }
    switch (IrpStack->MajorFunction) {
    case IRP_MJ_PNP:
        if ((*(PKSIDEVICE_HEADER*) DeviceObject->DeviceExtension)->Object) {
            return CKsDevice::DispatchPnp(DeviceObject, Irp);
        } else {
            return KsDefaultDispatchPnp(DeviceObject, Irp);
        }
    case IRP_MJ_POWER:
        if ((*(PKSIDEVICE_HEADER*) DeviceObject->DeviceExtension)->Object) {
            return CKsDevice::DispatchPower(DeviceObject, Irp);
        } else {
            return KsDefaultDispatchPower(DeviceObject, Irp);
        }
    case IRP_MJ_SYSTEM_CONTROL:
        return KsDefaultForwardIrp(DeviceObject, Irp);
    case IRP_MJ_CREATE:
        if ((*(PKSIDEVICE_HEADER*) DeviceObject->DeviceExtension)->Object) {
            return CKsDevice::DispatchCreate(DeviceObject, Irp);
        } else {
            return DispatchCreate(DeviceObject, Irp);
        }
    case IRP_MJ_CLOSE:
        ASSERT(ObjectHeader);
        return ObjectHeader->DispatchTable->Close(DeviceObject, Irp);
    case IRP_MJ_DEVICE_CONTROL:
        ASSERT(ObjectHeader);
        return ObjectHeader->DispatchTable->DeviceIoControl(DeviceObject, Irp);
    case IRP_MJ_READ:
        ASSERT(ObjectHeader);
        return ObjectHeader->DispatchTable->Read(DeviceObject, Irp);
    case IRP_MJ_WRITE:
        ASSERT(ObjectHeader);
        return ObjectHeader->DispatchTable->Write(DeviceObject, Irp);
    case IRP_MJ_FLUSH_BUFFERS:
        ASSERT(ObjectHeader);
        return ObjectHeader->DispatchTable->Flush(DeviceObject, Irp);
    case IRP_MJ_QUERY_SECURITY:
        ASSERT(ObjectHeader);
        return ObjectHeader->DispatchTable->QuerySecurity(DeviceObject, Irp);
    case IRP_MJ_SET_SECURITY:
        ASSERT(ObjectHeader);
        return ObjectHeader->DispatchTable->SetSecurity(DeviceObject, Irp);
    }
    return KsDispatchInvalidDeviceRequest(DeviceObject, Irp);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\ks\shffact.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    shffact.cpp

Abstract:

    This module contains the implementation of the kernel streaming 
    filter factory object.

Author:

    Dale Sather  (DaleSat) 31-Jul-1998

--*/

#ifndef __KDEXT_ONLY__
#include "ksp.h"
#include <kcom.h>
#endif // __KDEXT_ONLY__

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA

//
// Base automation tables for the filter and pin.  There is no base automation
// for nodes.
//
extern const KSAUTOMATION_TABLE FilterAutomationTable;    // shfilt.cpp
extern const KSAUTOMATION_TABLE PinAutomationTable;       // shpin.cpp

//
// CKsFilterFactory is the implementation of the kernel  filter
// factory object.
//
class CKsFilterFactory
:   public IKsFilterFactory,
    public IKsPowerNotify,
    public CBaseUnknown
{
#ifndef __KDEXT_ONLY__
private:
#else
public:
#endif // __KDEXT_ONLY__
    KSFILTERFACTORY_EXT m_Ext;
    KSIOBJECTBAG m_ObjectBag;
    LIST_ENTRY m_ChildFilterList;
    PKSAUTOMATION_TABLE m_FilterAutomationTable;
    PKSAUTOMATION_TABLE* m_PinAutomationTables;
    PKSAUTOMATION_TABLE* m_NodeAutomationTables;
    ULONG m_NodesCount;
    LIST_ENTRY m_DeviceClasses;
    BOOLEAN m_DeviceClassesState;
    KSPPOWER_ENTRY m_PowerEntry;
    PFNKSFILTERFACTORYPOWER m_DispatchSleep;
    PFNKSFILTERFACTORYPOWER m_DispatchWake;
    
public:
    static
    NTSTATUS
    DispatchCreate(
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
        );
    static
    void
    ItemFreeCallback(
        IN PKSOBJECT_CREATE_ITEM CreateItem
        );

public:
    DEFINE_STD_UNKNOWN();
    IMP_IKsFilterFactory;
    IMP_IKsPowerNotify;
    DEFINE_FROMSTRUCT(
        CKsFilterFactory,
        PKSFILTERFACTORY,
        m_Ext.Public);

    CKsFilterFactory(PUNKNOWN OuterUnknown):
        CBaseUnknown(OuterUnknown) 
    {
    }
    ~CKsFilterFactory();

    NTSTATUS
    Init(
        IN PKSDEVICE_EXT Parent,
        IN PLIST_ENTRY SiblingListHead,
        IN const KSFILTER_DESCRIPTOR* Descriptor,
        IN PWCHAR RefString OPTIONAL,
        IN PSECURITY_DESCRIPTOR SecurityDescriptor OPTIONAL,
        IN ULONG CreateItemFlags,
        IN PFNKSFILTERFACTORYPOWER SleepCallback OPTIONAL,
        IN PFNKSFILTERFACTORYPOWER WakeCallback OPTIONAL,
        OUT PKSFILTERFACTORY* FilterFactory OPTIONAL
        );
    NTSTATUS
    AddCreateItem(
        IN PUNICODE_STRING RefString,
        IN PSECURITY_DESCRIPTOR SecurityDescriptor OPTIONAL,
        IN ULONG CreateItemFlags
        );
    PIKSDEVICE
    GetParent(
        void
        )
    {
        return m_Ext.Device;
    };
    PLIST_ENTRY
    GetDeviceClasses(
        void
        )
    {
        return &m_DeviceClasses;
    };
    NTSTATUS
    UpdateCacheData (
        IN const KSFILTER_DESCRIPTOR *FilterDescriptor OPTIONAL
        );
    void
    DestroyDeviceClasses (
        );
};

#ifndef __KDEXT_ONLY__

IMPLEMENT_STD_UNKNOWN(CKsFilterFactory)
IMPLEMENT_GETSTRUCT(CKsFilterFactory,PKSFILTERFACTORY);
IMPLEMENT_FROMSTRUCT(CKsFilterFactory,PKSFILTERFACTORY,m_Ext.Public);


NTSTATUS
KspCreateFilterFactory(
    IN PKSDEVICE_EXT Parent,
    IN PLIST_ENTRY SiblingListHead,
    IN const KSFILTER_DESCRIPTOR* Descriptor,
    IN PWCHAR RefString OPTIONAL,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor OPTIONAL,
    IN ULONG CreateItemFlags,
    IN PFNKSFILTERFACTORYPOWER SleepCallback OPTIONAL,
    IN PFNKSFILTERFACTORYPOWER WakeCallback OPTIONAL,
    OUT PKSFILTERFACTORY* FilterFactory OPTIONAL
    )

/*++

Routine Description:

    This routine creates a new KS filter factory.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KspCreateFilterFactory]"));

    PAGED_CODE();

    ASSERT(Parent);
    ASSERT(Descriptor);

    Parent->Device->AcquireDevice();

    CKsFilterFactory *filterFactory =
        new(NonPagedPool,POOLTAG_FILTERFACTORY) CKsFilterFactory(NULL);

    NTSTATUS status;
    if (filterFactory) {
        filterFactory->AddRef();
        status = 
            filterFactory->Init(
                Parent,
                SiblingListHead,
                Descriptor,
                RefString,
                SecurityDescriptor,
                CreateItemFlags,
                SleepCallback,
                WakeCallback,
                FilterFactory);
        filterFactory->Release();
    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    Parent->Device->ReleaseDevice();

    return status;
}


CKsFilterFactory::
~CKsFilterFactory(
    void
    )

/*++

Routine Description:

    This routine destructs a filter factory object.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsFilterFactory::~CKsFilterFactory]"));

    PAGED_CODE();

    //
    // Synchronize removal from the lists.
    //
    // It's possible that we fail before initializing m_Ext if the filter
    // descriptor supplies some invalid parameters.  In this case, we do
    // not attempt to touch the device.  [In this case, the list removals
    // will not happen either].
    //

    if (m_Ext.Device)
        m_Ext.Device->AcquireDevice();

    if (m_Ext.SiblingListEntry.Flink) {
        RemoveEntryList(&m_Ext.SiblingListEntry);
    }

    if (m_Ext.Device) {
        m_Ext.Device->RemovePowerEntry(&m_PowerEntry);
        m_Ext.Device->ReleaseDevice();
    }

    if (m_Ext.AggregatedClientUnknown) {
        m_Ext.AggregatedClientUnknown->Release();
    }

#if (DBG)
    if (m_ChildFilterList.Flink && ! IsListEmpty(&m_ChildFilterList)) {
        _DbgPrintF(DEBUGLVL_ERROR,("[CKsFilterFactory::~CKsFilterFactory] ERROR:  filter instances still exist"));
    }
#endif

    KspTerminateObjectBag(&m_ObjectBag);
}


STDMETHODIMP_(NTSTATUS)
CKsFilterFactory::
NonDelegatedQueryInterface(
    IN REFIID InterfaceId,
    OUT PVOID* InterfacePointer
    )

/*++

Routine Description:

    This routine obtains an interface to a filter factory object.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsFilterFactory::NonDelegatedQueryInterface]"));

    PAGED_CODE();

    ASSERT(InterfacePointer);

    NTSTATUS status = STATUS_SUCCESS;

    if (IsEqualGUIDAligned(InterfaceId,__uuidof(IKsFilterFactory))) {
        *InterfacePointer = reinterpret_cast<PVOID>(static_cast<PIKSFILTERFACTORY>(this));
        AddRef();
    } else 
    if (IsEqualGUIDAligned(InterfaceId,__uuidof(IKsPowerNotify))) {
        *InterfacePointer = reinterpret_cast<PVOID>(static_cast<PIKSPOWERNOTIFY>(this));
        AddRef();
    } else {
		status = 
            CBaseUnknown::NonDelegatedQueryInterface(
                InterfaceId,
                InterfacePointer);
		if (! NT_SUCCESS(status) && m_Ext.AggregatedClientUnknown) {
            status = m_Ext.AggregatedClientUnknown->
                QueryInterface(InterfaceId,InterfacePointer);
        }
    }

    return status;
}


NTSTATUS
CKsFilterFactory::
Init(
    IN PKSDEVICE_EXT Parent,
    IN PLIST_ENTRY SiblingListHead,
    IN const KSFILTER_DESCRIPTOR* Descriptor,
    IN PWCHAR RefString OPTIONAL,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor OPTIONAL,
    IN ULONG CreateItemFlags,
    IN PFNKSFILTERFACTORYPOWER SleepCallback OPTIONAL,
    IN PFNKSFILTERFACTORYPOWER WakeCallback OPTIONAL,
    OUT PKSFILTERFACTORY* FilterFactory OPTIONAL
    )

/*++

Routine Description:

    This routine initializes a filter factory object.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsFilterFactory::Init]"));

    PAGED_CODE();

    ASSERT(Parent);
    ASSERT(SiblingListHead);
    ASSERT(Descriptor);

    if (Descriptor->Version != KSFILTER_DESCRIPTOR_VERSION) {
        _DbgPrintF(DEBUGLVL_TERSE,("KS client filter descriptor version number is incorrect"));
        return STATUS_UNSUCCESSFUL;
    }

    InitializeListHead(&m_Ext.ChildList);
    InsertTailList(SiblingListHead,&m_Ext.SiblingListEntry);
    m_Ext.SiblingListHead = SiblingListHead;
    m_Ext.Parent = Parent;
    m_Ext.ObjectType = KsObjectTypeFilterFactory;
    m_Ext.Interface = this;
    m_Ext.Device = Parent->Device;

    InitializeListHead(&m_DeviceClasses);
    InitializeListHead(&m_ChildFilterList);

    m_Ext.Public.FilterDescriptor = Descriptor;
    m_Ext.Public.Context = Parent->Public.Context;
    m_Ext.Public.Bag = reinterpret_cast<KSOBJECT_BAG>(&m_ObjectBag);
    m_Ext.Device->InitializeObjectBag(&m_ObjectBag,NULL);
    m_DispatchSleep = SleepCallback;
    m_DispatchWake = WakeCallback;

    NTSTATUS status = STATUS_SUCCESS;

    //
    // Initialize the filter automation table.  This is freed by the
    // destructor, so no cleanup is required in this function.
    //
    if (Descriptor->AutomationTable) {
        status =
            KsMergeAutomationTables(
                &m_FilterAutomationTable,
                const_cast<PKSAUTOMATION_TABLE>(Descriptor->AutomationTable),
                const_cast<PKSAUTOMATION_TABLE>(&FilterAutomationTable),
                m_Ext.Public.Bag);
    } else {
        m_FilterAutomationTable =
            PKSAUTOMATION_TABLE(&FilterAutomationTable);
    }

    //
    // Initialize the pin table of automation tables.  This is freed by the
    // destructor, so no cleanup is required in this function.
    //
    if (NT_SUCCESS(status)) {
        if (Descriptor->PinDescriptorsCount) { 
            status =
                KspCreateAutomationTableTable(
                    &m_PinAutomationTables,
                    Descriptor->PinDescriptorsCount,
                    Descriptor->PinDescriptorSize,
                    &Descriptor->PinDescriptors->AutomationTable,
                    &PinAutomationTable,
                    m_Ext.Public.Bag);
        } else {
            m_PinAutomationTables = NULL;
        }
    }

    //
    // Initialize the node table of automation tables.  This is freed by the
    // destructor, so no cleanup is required in this function.
    //
    if (NT_SUCCESS(status)) {
        m_NodesCount = Descriptor->NodeDescriptorsCount;
        if (m_NodesCount) {
            status =
                KspCreateAutomationTableTable(
                    &m_NodeAutomationTables,
                    m_NodesCount,
                    Descriptor->NodeDescriptorSize,
                    &Descriptor->NodeDescriptors->AutomationTable,
                    NULL,
                    m_Ext.Public.Bag);
        } else {
            m_NodeAutomationTables = NULL;
        }
    }

    //
    // Register device classes and add a create item to the device header.
    //
    if (NT_SUCCESS(status)) {
        UNICODE_STRING refString;
        BOOLEAN mustFreeString = FALSE;

        //
        // Create a reference unicode string.
        //
        if (RefString) {
            //
            // String argument was supplied - use it.
            //
            RtlInitUnicodeString(&refString,RefString);
        }
        else if (Descriptor->ReferenceGuid) {
            //
            // Descriptor has reference GUID - use that.
            //
            status = RtlStringFromGUID(*Descriptor->ReferenceGuid,&refString);

            mustFreeString = NT_SUCCESS(status);
        } else {
            //
            // Use a default reference string.
            //
            RtlInitUnicodeString(&refString,KSP_DEFAULT_REFERENCE_STRING);
        }

        //
        // Register (but do not enable) device interfaces.
        //
        if (NT_SUCCESS(status)) {
            PKSIDEVICE_HEADER deviceHeader = *(PKSIDEVICE_HEADER *)
                (m_Ext.Device->GetStruct()->FunctionalDeviceObject->DeviceExtension);
            ASSERT(deviceHeader);
            if (KsiGetBusInterface(deviceHeader) == STATUS_NOT_SUPPORTED) {
                status =
                    KspRegisterDeviceInterfaces(
                        Descriptor->CategoriesCount,
                        Descriptor->Categories,
                        m_Ext.Device->GetStruct()->PhysicalDeviceObject,
                        &refString,
                        &m_DeviceClasses);
            }
        }

        if (NT_SUCCESS(status)) {
            status = 
                AddCreateItem(&refString,SecurityDescriptor,CreateItemFlags);
        }

        if (mustFreeString) {
            RtlFreeUnicodeString(&refString);
        }
    }

    if (NT_SUCCESS(status)) {
        Parent->Device->AddPowerEntry(&m_PowerEntry,this);
        if (FilterFactory) {
            *FilterFactory = &m_Ext.Public;
        }
    }

    return status;
}


STDMETHODIMP_(void)
CKsFilterFactory::
Sleep(
    IN DEVICE_POWER_STATE State
    )

/*++

Routine Description:

    This routine handles notification that the device is going to sleep.

Arguments:

    State -
        Contains the device power state.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsFilterFactory::Sleep]"));

    PAGED_CODE();

    if (m_DispatchSleep) {
        m_DispatchSleep(&m_Ext.Public,State);
    }
}


STDMETHODIMP_(void)
CKsFilterFactory::
Wake(
    void
    )

/*++

Routine Description:

    This routine handles notification that the device is waking.

Arguments:

    None.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsFilterFactory::Wake]"));

    PAGED_CODE();

    if (m_DispatchWake) {
        m_DispatchWake(&m_Ext.Public,PowerDeviceD0);
    }
}


NTSTATUS
CKsFilterFactory::
AddCreateItem(
    IN PUNICODE_STRING RefString,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor OPTIONAL,
    IN ULONG CreateItemFlags
    )

/*++

Routine Description:

    This routine adds a create item for a filter factory object.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsFilterFactory::AddCreateItem]"));

    PAGED_CODE();

    KSOBJECT_CREATE_ITEM createItem;

    //
    // Initialize the create item.
    //
    createItem.Create = CKsFilterFactory::DispatchCreate;
    createItem.Context = &(m_Ext.Public);
    createItem.ObjectClass = *RefString;
    createItem.SecurityDescriptor = SecurityDescriptor;
    createItem.Flags = CreateItemFlags;

    NTSTATUS status =
        KsAllocateObjectCreateItem(
            *(KSDEVICE_HEADER *)
             (m_Ext.Device->GetStruct()->FunctionalDeviceObject->DeviceExtension),
            &createItem,
            TRUE,
            CKsFilterFactory::ItemFreeCallback);

    if (NT_SUCCESS(status)) {
        AddRef();
    }

    return status;
}


NTSTATUS
CKsFilterFactory::
SetDeviceClassesState(
    IN BOOLEAN NewState
    )

/*++

Routine Description:

    This routine sets the state of the device classes registered by a filter
    factory.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsFilterFactory::SetDeviceClassesState]"));

    PAGED_CODE();

    NTSTATUS status = STATUS_SUCCESS;
    NewState = (NewState != FALSE);
    if (NewState != (m_DeviceClassesState != FALSE)) {
        status = 
            KspSetDeviceInterfacesState(
                &m_DeviceClasses,
                NewState);

        if (NT_SUCCESS(status)) {
            m_DeviceClassesState = NewState;
        }
    }

    return status;
}


void
CKsFilterFactory::
DestroyDeviceClasses (
    )

/*++

Routine Description:

    This routine destroys all device classes belonging to this filter factory.

Arguments:

    None

Return Value:

    None

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsFilterFactory::DestroyDeviceClasses]"));

    PAGED_CODE();

    KspFreeDeviceInterfaces(&m_DeviceClasses);

}



NTSTATUS
CKsFilterFactory::
DispatchCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine dispatches create IRPs.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_VERBOSE,("[CKsFilterFactory::DispatchCreate] IRP %p DEVICE_OBJECT %p",Irp,DeviceObject));

    PAGED_CODE();

    ASSERT(DeviceObject);
    ASSERT(Irp);

    //
    // Get a pointer to the target object.
    //
    CKsFilterFactory *filterFactory = 
        CKsFilterFactory::FromStruct (
            reinterpret_cast<PKSFILTERFACTORY>(
                KSCREATE_ITEM_IRP_STORAGE(Irp)->Context
                )
            );

    //
    // We acquire the device to keep the descriptor stable during the
    // create.  Also, because we are updating the list of filters, we
    // need to synchronize with anyone wanting to walk that list.
    //
    filterFactory->m_Ext.Device->AcquireDevice();
    NTSTATUS status = 
        KspCreateFilter(
            Irp,
            &filterFactory->m_Ext,
            &filterFactory->m_Ext.ChildList,
            filterFactory->m_Ext.Public.FilterDescriptor,
            filterFactory->m_FilterAutomationTable,
            filterFactory->m_PinAutomationTables,
            filterFactory->m_NodeAutomationTables,
            filterFactory->m_NodesCount);
    filterFactory->m_Ext.Device->ReleaseDevice();

    if (status != STATUS_PENDING) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp,IO_NO_INCREMENT);
    }

    return status;
}


void
CKsFilterFactory::
ItemFreeCallback(
    IN PKSOBJECT_CREATE_ITEM CreateItem
    )

/*++

Routine Description:

    This routine handles a notification that the create item associated with
    a filter factory is being freed.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsFilterFactory::ItemFreeCallback]"));

    PAGED_CODE();

    ASSERT(CreateItem);

    //
    // Get a pointer to the target object.
    //
    CKsFilterFactory *filterFactory = 
        CKsFilterFactory::FromStruct (
            reinterpret_cast<PKSFILTERFACTORY>(CreateItem->Context)
            );

    //
    // Free the device interfaces list.  This is done now so that if someone
    // manually deletes a filter factory with instances still present, we
    // disable the interfaces, but do not actually destroy the factory until
    // the instances close.
    //
    if (filterFactory->m_DeviceClassesState) {
        KspSetDeviceInterfacesState(&filterFactory->m_DeviceClasses,FALSE);
        filterFactory->m_DeviceClassesState = FALSE;
    }

    if (filterFactory->m_DeviceClasses.Flink) {
        KspFreeDeviceInterfaces(&filterFactory->m_DeviceClasses);
    }

    //
    // This callback indicates the deletion of a create item for this filter
    // factory.  There may be more than one, so we only delete when the count
    // hits zero.
    //
    filterFactory->Release();
}


NTSTATUS
CKsFilterFactory::
UpdateCacheData (
    IN const KSFILTER_DESCRIPTOR *FilterDescriptor OPTIONAL
    )

/*++

Routine Description:

    Update the FilterData and Medium cache for a given filter factory.
    If the filter factory uses dynamic pins and needs to update information
    for pins which do not yet exist, an optional filter descriptor containing
    all relevant information about the pins which do not yet exist may be
    passed.

    FilterData and Medium cache will be updated for **ALL CATEGORIES** 
    specified in the used Filter Descriptor (if FilterDescriptor is NULL,
    it will be the factory's descriptor).

Arguments:

    FilterDescriptor -
        An optional filter descriptor which FilterData and Medium cache
        will be based off.  If this is NULL, the FilterFactory's descriptor
        will be used instead.

Return Value:

    Success / Failure

--*/

{

    PAGED_CODE();

    const KSFILTER_DESCRIPTOR *Descriptor = FilterDescriptor ?
        FilterDescriptor : m_Ext.Public.FilterDescriptor;

    PUCHAR FilterData = NULL;
    ULONG FilterDataLength = 0;

    NTSTATUS Status =
        KspBuildFilterDataBlob (
            Descriptor,
            &FilterData,
            &FilterDataLength
            );

    if (NT_SUCCESS (Status)) {

        //
        // Update the registry for every category on the filter.
        //
        const GUID *Category = Descriptor->Categories;
        for (ULONG CategoriesCount = 0;
            NT_SUCCESS (Status) && 
                CategoriesCount < Descriptor->CategoriesCount;
            CategoriesCount++
            ) {

            PKSPDEVICECLASS DeviceClass;

            //
            // Find the device class corresponding to *Category
            //
            for (PLIST_ENTRY ListEntry = m_DeviceClasses.Flink;
                ListEntry != &m_DeviceClasses;
                ListEntry = ListEntry->Flink
                ) {

                DeviceClass = (PKSPDEVICECLASS)
                    CONTAINING_RECORD (
                        ListEntry,
                        KSPDEVICECLASS,
                        ListEntry
                        );

                if (IsEqualGUIDAligned (
                    *DeviceClass->InterfaceClassGUID,
                    *Category
                    )) {

                    break;

                }

            }

            //
            // If the category matches nothing in the registered interfaces,
            // the category in the descriptor passed in is bogus.
            //
            if (ListEntry == &m_DeviceClasses) {
                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            HANDLE DeviceInterfaceKey;

            //
            // Open the FilterData key and write the FilterData blob to the
            // FilterData key for this interface.
            //
            Status = IoOpenDeviceInterfaceRegistryKey (
                &(DeviceClass->SymbolicLinkName),
                STANDARD_RIGHTS_ALL,
                &DeviceInterfaceKey
                );

            if (NT_SUCCESS (Status)) {

                UNICODE_STRING FilterDataString;

                RtlInitUnicodeString (&FilterDataString, L"FilterData");

                Status = ZwSetValueKey (
                    DeviceInterfaceKey,
                    &FilterDataString,
                    0,
                    REG_BINARY,
                    FilterData,
                    FilterDataLength
                    );

                ZwClose (DeviceInterfaceKey);

            }

            //
            // Cache the Mediums for the pins on this filter for this 
            // particular device interface.
            //
            if (NT_SUCCESS (Status)) {
                Status = KspCacheAllFilterPinMediums (
                    &(DeviceClass->SymbolicLinkName),
                    Descriptor
                    );
            }

            Category++;

        }

    }

    if (FilterData) {
        ExFreePool (FilterData);
    }

    return Status;

}


KSDDKAPI
NTSTATUS
NTAPI
KsFilterFactorySetDeviceClassesState(
    IN PKSFILTERFACTORY FilterFactory,
    IN BOOLEAN NewState
    )

/*++

Routine Description:

    This routine sets the state of the device classes.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsFilterFactorySetDeviceClassesState]"));

    PAGED_CODE();

    ASSERT(FilterFactory);

    return 
        CKsFilterFactory::FromStruct(FilterFactory)->
            SetDeviceClassesState(NewState);
}


KSDDKAPI
NTSTATUS
NTAPI
KsFilterFactoryAddCreateItem(
    IN PKSFILTERFACTORY FilterFactory,
    IN PWCHAR RefString,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor OPTIONAL,
    IN ULONG CreateItemFlags
    )

/*++

Routine Description:

    This routine adds a create item for a filter factory object.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsFilterFactoryAddCreateItem]"));

    PAGED_CODE();

    ASSERT(FilterFactory);

    CKsFilterFactory *filter =
        CKsFilterFactory::FromStruct(FilterFactory);

    //
    // Create a reference unicode string.
    //
    UNICODE_STRING refString;
    RtlInitUnicodeString(&refString,RefString);

    return filter->AddCreateItem(&refString,SecurityDescriptor,CreateItemFlags);
}


void
KspSetDeviceClassesState(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN NewState
    )

/*++

Routine Description:

    This routine sets the device classes state for all filter factories on a
    device.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KspSetDeviceClassesState]"));

    PAGED_CODE();

    PLIST_ENTRY listHead =
        &(*(PKSIDEVICE_HEADER*) DeviceObject->DeviceExtension)->ChildCreateHandlerList;

    for(PLIST_ENTRY listEntry = listHead->Flink; 
        listEntry != listHead; 
        listEntry = listEntry->Flink) {
        PKSICREATE_ENTRY entry = CONTAINING_RECORD(listEntry,KSICREATE_ENTRY,ListEntry);

        if (entry->CreateItem->Create == CKsFilterFactory::DispatchCreate) {
            CKsFilterFactory *filterFactory =
                CKsFilterFactory::FromStruct (
                    reinterpret_cast<PKSFILTERFACTORY>(
                        entry->CreateItem->Context
                        )
                    );

            filterFactory->SetDeviceClassesState(NewState);
        }
    }
}


void
KspFreeDeviceClasses(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine frees all device classes for all filter factories on a
    device.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KspSetDeviceClassesState]"));

    PAGED_CODE();

    PLIST_ENTRY listHead =
        &(*(PKSIDEVICE_HEADER*) DeviceObject->DeviceExtension)->ChildCreateHandlerList;

    for(PLIST_ENTRY listEntry = listHead->Flink; 
        listEntry != listHead; 
        listEntry = listEntry->Flink) {
        PKSICREATE_ENTRY entry = CONTAINING_RECORD(listEntry,KSICREATE_ENTRY,ListEntry);

        if (entry->CreateItem->Create == CKsFilterFactory::DispatchCreate) {
            CKsFilterFactory *filterFactory =
                CKsFilterFactory::FromStruct (
                    reinterpret_cast<PKSFILTERFACTORY>(
                        entry->CreateItem->Context
                        )
                    );

            filterFactory->DestroyDeviceClasses();

        }
    }
}


KSDDKAPI
PUNICODE_STRING
NTAPI
KsFilterFactoryGetSymbolicLink(
    IN PKSFILTERFACTORY FilterFactory
    )

/*++

Routine Description:

    This routine gets a symbolic link for a filter factory.  If the filter
    factory has no device interfaces registered, this function returns NULL.

Arguments:

    FilterFactory -
        Contains a pointer to the filter factory.

Return Value:

    A pointer to a symbolic link for the filter factory, or NULL if the
    filter factory has no device interfaces registered.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsFilterFactoryGetSymbolicLink]"));

    PAGED_CODE();

    PLIST_ENTRY deviceClasses = 
        CKsFilterFactory::FromStruct(FilterFactory)->GetDeviceClasses();

    PUNICODE_STRING link;
    if (deviceClasses->Flink == deviceClasses) {
        link = NULL;
    } else {
        PKSPDEVICECLASS deviceClass = PKSPDEVICECLASS(deviceClasses->Flink);
        link = &deviceClass->SymbolicLinkName;
    }

    return link;
}


KSDDKAPI
NTSTATUS
NTAPI
KsFilterFactoryUpdateCacheData(
    IN PKSFILTERFACTORY FilterFactory,
    IN const KSFILTER_DESCRIPTOR *FilterDescriptor OPTIONAL
    )

/*++

Routine Description:

    Update the FilterData and Medium cache for a given filter factory.
    If the filter factory uses dynamic pins and needs to update information
    for pins which do not yet exist, an optional filter descriptor containing
    all relevant information about the pins which do not yet exist may be
    passed.

    FilterData and Medium cache will be updated for **ALL CATEGORIES** 
    specified in the used Filter Descriptor (if FilterDescriptor is NULL,
    it will be the factory's descriptor).

Arguments:

    FilterFactory -
        The filter factory to update FilterData and Medium cache in the
        registry

    FilterDescriptor -
        An optional filter descriptor which FilterData and Medium cache
        will be based off.  If this is NULL, the FilterFactory's descriptor
        will be used instead.

Return Value:

    Success / Failure

--*/

{

    PAGED_CODE();

    ASSERT (FilterFactory);

    return CKsFilterFactory::FromStruct (FilterFactory) ->
        UpdateCacheData (FilterDescriptor);

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\ks\shfilt.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    shfilt.cpp

Abstract:

    This module contains the implementation of the kernel streaming 
    filter object.

Author:

    Dale Sather  (DaleSat) 31-Jul-1998

--*/

#ifndef __KDEXT_ONLY__
#include "ksp.h"
#include <kcom.h>
#endif // __KDEXT_ONLY__

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA

//
// GFX:
//
// This is the GUID for the frame property set (frame holding for GFX).  This
// shouldn't be exported.
//
#ifndef __KDEXT_ONLY__
GUID KSPROPSETID_Frame = {STATIC_KSPROPSETID_Frame};
#endif // __KDEXT_ONLY__

extern const KSAUTOMATION_TABLE PinAutomationTable;         // shpin.cpp

#define PROCESS_PIN_ALLOCATION_INCREMENT 4

class CKsPinFactory
{
public:
    ULONG m_PinCount;
    ULONG m_BoundPinCount;
    LIST_ENTRY m_ChildPinList;
    const KSAUTOMATION_TABLE* m_AutomationTable;
    PKSPPROCESSPIPESECTION m_CopySourcePipeSection;
    PKSPPROCESSPIN m_CopySourcePin;
    ULONG m_InstancesNecessaryForProcessing;
    ULONG m_ProcessPinsIndexAllocation;
      
    //
    // NOTE: The below two or gates are used for automatically setting up
    // or instance effects on frame arrival and state change.  These are
    // initialized dynamically at bind time of the first pin and are
    // uninitialized dynamically at unbind time.
    //
    // They are **ONLY** relevant to filter-centric filters.
    //
    KSGATE m_FrameGate;
    KSGATE m_StateGate;
};

//
// CKsFilter is the private implementation of the kernel  
// filter object.
//
class CKsFilter:
    public IKsFilter,
    public IKsProcessingObject,
    public IKsPowerNotify,
    public IKsControl,
    public CBaseUnknown
{
#ifndef __KDEXT_ONLY__
private:
#else // __KDEXT_ONLY__
public:
#endif // __KDEXT_ONLY__
    KSFILTER_EXT m_Ext;
    KSIOBJECTBAG m_ObjectBag;
    KSAUTOMATION_TABLE *const* m_NodeAutomationTables;
    ULONG m_NodesCount;
    LIST_ENTRY m_ChildNodeList;
    KMUTEX m_ControlMutex;
    ULONG m_PinFactoriesCount;
    ULONG m_PinFactoriesAllocated;
    CKsPinFactory* m_PinFactories;
    LIST_ENTRY m_InputPipes;
    LIST_ENTRY m_OutputPipes;
    PKSPPROCESSPIN_INDEXENTRY m_ProcessPinsIndex;
    WORK_QUEUE_ITEM m_WorkItem;
    WORK_QUEUE_TYPE m_WorkQueueType;
    PKSWORKER m_Worker;
    PFNKSFILTERPROCESS m_DispatchProcess;
    PFNKSFILTERVOID m_DispatchReset;
    PFNKSFILTERPOWER m_DispatchSleep;
    PFNKSFILTERPOWER m_DispatchWake;
    BOOLEAN m_ProcessPassive;
    BOOLEAN m_ReceiveZeroLengthSamples;
    BOOLEAN m_FrameHolding;
    KSGATE m_AndGate;
    KSPPOWER_ENTRY m_PowerEntry;
    volatile ULONG m_ProcessOnRelease;
    ULONG m_DefaultConnectionsCount;
    PKSTOPOLOGY_CONNECTION m_DefaultConnections;
    KMUTEX m_Mutex;
    PFILE_OBJECT m_FileObject;
    PKEVENT m_CloseEvent;

    LONG m_TriggeringEvents;
    LONG m_FramesWaitingForCopy;
    INTERLOCKEDLIST_HEAD m_CopyFrames;

    PULONG m_RelatedPinFactoryIds;

public:
    static
    NTSTATUS
    DispatchCreatePin(
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
        );
    static
    NTSTATUS
    DispatchCreateNode(
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
        );
    static
    NTSTATUS
    DispatchDeviceIoControl(
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
        );
    static
    NTSTATUS
    DispatchClose(
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
        );
    static
    NTSTATUS
    Property_Pin(
        IN PIRP Irp,
        IN PKSP_PIN PinInstance,
        IN OUT PVOID Data
        );
    static
    NTSTATUS
    Property_Topology(
        IN PIRP Irp,
        IN PKSPROPERTY Property,
        IN OUT PVOID Data
        );
    static
    NTSTATUS
    Property_General_ComponentId(
        IN PIRP Irp,
        IN PKSPROPERTY Property,
        IN OUT PVOID Data
        );
    static
    NTSTATUS
    Property_Frame_Holding(
        IN PIRP Irp,
        IN PKSPROPERTY Property,
        IN PVOID Data
        );
    NTSTATUS
    GrowProcessPinsTable(
        IN ULONG PinId
        );
    void
    SetCopySource(
        IN PKSPPROCESSPIPESECTION ProcessPipeSection OPTIONAL,
        IN ULONG PinId
        );
    void
    AddCopyDestination(
        IN PKSPPROCESSPIPESECTION ProcessPipeSection,
        IN ULONG PinId
        );
    void
    EstablishCopyRelationships(
        IN PKSPPROCESSPIPESECTION ProcessPipeSection,
        IN ULONG PinId
        );
    void
    FindNewCopySource(
        IN PKSPPROCESSPIPESECTION ProcessPipeSection
        );
    BOOLEAN
    PrepareProcessPipeSection(
        IN PKSPPROCESSPIPESECTION ProcessPipeSection,
        IN BOOLEAN Reprepare
        );
    void
    UnprepareProcessPipeSection(
        IN PKSPPROCESSPIPESECTION ProcessPipeSection,
        IN OUT PULONG Flags,
        IN BOOLEAN Reprepare
        );
    void
    CopyToDestinations(
        IN PKSPPROCESSPIPESECTION ProcessPipeSection,
        IN ULONG Flags,
        IN BOOLEAN EndOfStream
        );
    BOOL
    ConstructDefaultTopology(
        );
    NTSTATUS
    AddPinFactory (
        IN const KSPIN_DESCRIPTOR_EX *const Descriptor,
        OUT PULONG AssignedId
        );
    NTSTATUS
    AddNode (
        IN const KSNODE_DESCRIPTOR *const Descriptor,
        OUT PULONG AssignedId
        );
    NTSTATUS
    AddTopologyConnections (
        IN ULONG NewConnectionsCount,
        IN const KSTOPOLOGY_CONNECTION *const Connections
        );
    void	
    TraceTopologicalOutput (
        IN ULONG ConnectionsCount,
        IN const KSTOPOLOGY_CONNECTION *Connections,
        IN const KSTOPOLOGY_CONNECTION *StartConnection,
        IN OUT PULONG RelatedFactories,
        OUT PULONG RelatedFactoryIds
        );
    ULONG
    FollowFromTopology (
        IN ULONG PinFactoryId,
        OUT PULONG RelatedFactoryIds
        );

public:
    DEFINE_STD_UNKNOWN();
    STDMETHODIMP_(ULONG)
    NonDelegatedRelease(
        void
        );
    IMP_IKsFilter;
    IMP_IKsProcessingObject;
    IMP_IKsPowerNotify;
    IMP_IKsControl;
    DEFINE_FROMSTRUCT(CKsFilter,PKSFILTER,m_Ext.Public);
    DEFINE_FROMIRP(CKsFilter);
    DEFINE_FROMCREATEIRP(CKsFilter);

    CKsFilter(PUNKNOWN OuterUnknown):
        CBaseUnknown(OuterUnknown) 
    {
    }
    ~CKsFilter();

    NTSTATUS
    Init(
        IN PIRP Irp,
        IN PKSFILTERFACTORY_EXT Parent,
        IN PLIST_ENTRY SiblingListHead,
        IN const KSFILTER_DESCRIPTOR* Descriptor,
        IN const KSAUTOMATION_TABLE* FilterAutomationTable,
        IN KSAUTOMATION_TABLE*const* PinAutomationTables,
        IN KSAUTOMATION_TABLE*const* NodeAutomationTables OPTIONAL,
        IN ULONG NodesCount
        );
    PIKSFILTERFACTORY
    GetParent(
        void
        )
    {
        return m_Ext.Parent->Interface;
    };
    PLIST_ENTRY
    GetChildPinList(
        IN ULONG PinId
        )
    {
        ASSERT(PinId < m_PinFactoriesCount);
        return &m_PinFactories[PinId].m_ChildPinList;
    };
    ULONG
    GetChildPinCount(
        IN ULONG PinId
        )
    {
        ASSERT(PinId < m_PinFactoriesCount);
        return m_PinFactories[PinId].m_PinCount;
    };
    void
    AcquireControl(
        void
        )
    {
        KeWaitForMutexObject (
            &m_ControlMutex,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );
    }
    void
    ReleaseControl(
        void
        )
    {
        KeReleaseMutex (
            &m_ControlMutex,
            FALSE
            );
    }
    void
    AcquireProcessSync(
        void
        )
    {
        KeWaitForSingleObject(
            &m_Mutex,
            Executive,
            KernelMode,
            FALSE,
            NULL);
    }
    void
    ReleaseProcessSync(
        void
        );
    void
    SetPowerCallbacks(
        IN PFNKSFILTERPOWER Sleep OPTIONAL,
        IN PFNKSFILTERPOWER Wake OPTIONAL
        )
    {
        m_DispatchSleep = Sleep;
        m_DispatchWake = Wake;
    }
    NTSTATUS
    EvaluateDescriptor(
        void
        );

private:
    void
    UnbindProcessPinFromPipeSection(
        IN PKSPPROCESSPIN ProcessPin
        );
    void
    UnbindProcessPinsFromPipeSectionUnsafe(
        IN PKSPPROCESSPIPESECTION PipeSection
        );
    void
    HoldProcessing (
        );
    void
    RestoreProcessing (
        );
    static
    void
    SplitCopyOnDismissal (
        IN PKSPSTREAM_POINTER StreamPointer,
        IN PKSPFRAME_HEADER FrameHeader,
        IN CKsFilter *Filter
        );
    static
    void
    ReleaseCopyReference (
        IN PKSSTREAM_POINTER streamPointer
        );
    BOOLEAN
    DistributeCopyFrames (
        IN BOOLEAN AcquireSpinLock,
        IN BOOLEAN AcquireMutex
        ); 
    NTSTATUS
    DeferDestinationCopy (
        IN PKSPSTREAM_POINTER StreamPointer
        );
};

#ifndef __KDEXT_ONLY__

IMPLEMENT_STD_UNKNOWN(CKsFilter)
IMPLEMENT_GETSTRUCT(CKsFilter,PKSFILTER);

static const WCHAR PinTypeName[] = KSSTRING_Pin;
static const WCHAR NodeTypeName[] = KSSTRING_TopologyNode;

static const
KSOBJECT_CREATE_ITEM 
FilterCreateItems[] = {
    DEFINE_KSCREATE_ITEM(CKsFilter::DispatchCreatePin,PinTypeName,NULL),
    DEFINE_KSCREATE_ITEM(CKsFilter::DispatchCreateNode,NodeTypeName,NULL)
};

DEFINE_KSDISPATCH_TABLE(
    FilterDispatchTable,
    CKsFilter::DispatchDeviceIoControl,
    KsDispatchInvalidDeviceRequest,
    KsDispatchInvalidDeviceRequest,
    KsDispatchInvalidDeviceRequest,
    CKsFilter::DispatchClose,
    KsDispatchQuerySecurity,
    KsDispatchSetSecurity,
    KsDispatchFastIoDeviceControlFailure,
    KsDispatchFastReadFailure,
    KsDispatchFastWriteFailure);

DEFINE_KSPROPERTY_TABLE(FilterPinPropertyItems) {
    DEFINE_KSPROPERTY_ITEM_PIN_CINSTANCES(
        CKsFilter::Property_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_CTYPES(
        CKsFilter::Property_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_DATAFLOW(
        CKsFilter::Property_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_DATARANGES(
        CKsFilter::Property_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_DATAINTERSECTION(
        CKsFilter::Property_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_INTERFACES(
        CKsFilter::Property_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_MEDIUMS(
        CKsFilter::Property_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_COMMUNICATION(
        CKsFilter::Property_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_NECESSARYINSTANCES(
        CKsFilter::Property_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_CATEGORY(
        CKsFilter::Property_Pin),
    DEFINE_KSPROPERTY_ITEM_PIN_NAME(
        CKsFilter::Property_Pin)
//
//  Not implemented:
//
//  KSPROPERTY_PIN_PHYSICALCONNECTION,
//  KSPROPERTY_PIN_CONSTRAINEDDATARANGES,
//  KSPROPERTY_PIN_PROPOSEDATAFORMAT
//
};

DEFINE_KSPROPERTY_TOPOLOGYSET(
    FilterTopologyPropertyItems,
    CKsFilter::Property_Topology);

DEFINE_KSPROPERTY_TABLE(FilterGeneralPropertyItems) {
    DEFINE_KSPROPERTY_ITEM_GENERAL_COMPONENTID(
        CKsFilter::Property_General_ComponentId)
};

DEFINE_KSPROPERTY_TABLE(FilterFramePropertyItems) {
    DEFINE_KSPROPERTY_ITEM(
        KSPROPERTY_FRAME_HOLDING,
        CKsFilter::Property_Frame_Holding,
        sizeof (KSPROPERTY),
        sizeof (BOOL),
        CKsFilter::Property_Frame_Holding,
        NULL, 0, NULL, NULL, 0
        )
};

DEFINE_KSPROPERTY_SET_TABLE(FilterPropertySets) {
    DEFINE_KSPROPERTY_SET(
        &KSPROPSETID_Pin,
        SIZEOF_ARRAY(FilterPinPropertyItems),
        FilterPinPropertyItems,
        0,
        NULL),
    DEFINE_KSPROPERTY_SET(
        &KSPROPSETID_Topology,
        SIZEOF_ARRAY(FilterTopologyPropertyItems),
        FilterTopologyPropertyItems,
        0,
        NULL),
    DEFINE_KSPROPERTY_SET(
        &KSPROPSETID_General,
        SIZEOF_ARRAY(FilterGeneralPropertyItems),
        FilterGeneralPropertyItems,
        0,
        NULL),
    DEFINE_KSPROPERTY_SET(
        &KSPROPSETID_Frame,
        SIZEOF_ARRAY(FilterFramePropertyItems),
        FilterFramePropertyItems,
        0,
        NULL)
};

extern
DEFINE_KSAUTOMATION_TABLE(FilterAutomationTable) {
    DEFINE_KSAUTOMATION_PROPERTIES(FilterPropertySets),
    DEFINE_KSAUTOMATION_METHODS_NULL,
    DEFINE_KSAUTOMATION_EVENTS_NULL
};

#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif // ALLOC_PRAGMA

IMPLEMENT_FROMSTRUCT(CKsFilter,PKSFILTER,m_Ext.Public);

void
CKsFilter::
ReleaseProcessSync(
    void
    )
{
    KeReleaseMutex(&m_Mutex,FALSE);

    //
    // Any frames which were left over and couldn't be copied must
    // be copied now.
    //
    // Not spinlocking this is optimization.  In the unlikely case we
    // miss the frame, the next processing or mutex release will 
    // automatically pick it up.  This avoids an extra spinlock every time
    // the process mutex is released (unless something is already waiting
    // for copy).
    //
    if (m_FramesWaitingForCopy > 0) 
        DistributeCopyFrames (TRUE, TRUE);

    while ( m_ProcessOnRelease ) {
        if (InterlockedCompareExchange(PLONG(&m_ProcessOnRelease),0,2)==2) {
#ifndef __KDEXT_ONLY__
            ProcessingObjectWork();
            break;
#endif // __KDEXT_ONLY__
        }
    }
}
#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA


NTSTATUS
KspCreateFilter(
    IN PIRP Irp,
    IN PKSFILTERFACTORY_EXT Parent,
    IN PLIST_ENTRY SiblingListHead,
    IN const KSFILTER_DESCRIPTOR* Descriptor,
    IN const KSAUTOMATION_TABLE* FilterAutomationTable,
    IN KSAUTOMATION_TABLE*const* PinAutomationTables,
    IN KSAUTOMATION_TABLE*const* NodeAutomationTables OPTIONAL,
    IN ULONG NodesCount
    )

/*++

Routine Description:

    This routine creates a new KS filter.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KspCreateFilter]"));

    PAGED_CODE();

    ASSERT(Irp);
    ASSERT(Parent);
    ASSERT(SiblingListHead);
    ASSERT(Descriptor);
    ASSERT(FilterAutomationTable);

    NTSTATUS status;

    //
    // Make sure caller is allowed to create the filter.
    //
    if ((Descriptor->Flags&KSFILTER_FLAG_DENY_USERMODE_ACCESS) &&
        Irp->RequestorMode != KernelMode ) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    CKsFilter *filter =
        new(NonPagedPool,POOLTAG_FILTER) CKsFilter(NULL);

    if (filter) {
        filter->AddRef();
        status = 
            filter->Init(
                Irp,
                Parent,
                SiblingListHead,
                Descriptor,
                FilterAutomationTable,
                PinAutomationTables,
                NodeAutomationTables,
                NodesCount);
        filter->Release();
    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return status;
}


CKsFilter::
~CKsFilter(
    void
    )

/*++

Routine Description:

    This routine destructs a filter.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsFilter::~CKsFilter]"));

    PAGED_CODE();

    if (m_Ext.AggregatedClientUnknown) {
        m_Ext.AggregatedClientUnknown->Release();
    }

#if (DBG)
    if (! IsListEmpty(&m_ChildNodeList)) {
        _DbgPrintF(DEBUGLVL_ERROR,("[CKsFilter::~CKsFilter] ERROR:  node instances still exist"));
    }
#endif

    if (m_PinFactories) {
#if (DBG)
        //
        // Make sure all the pins have gone away.
        //
        CKsPinFactory *pinFactory = m_PinFactories;
        for(ULONG pinId = 0;
            pinId < m_PinFactoriesCount;
            pinId++, pinFactory++) {
            if (! IsListEmpty(&pinFactory->m_ChildPinList)) {
                _DbgPrintF(DEBUGLVL_ERROR,("[CKsFilter::~CKsFilter] ERROR:  instances of pin %d still exist (0x%08x)",pinId,&pinFactory->m_ChildPinList));
            }
        }
#endif
        delete [] m_PinFactories;
    }

    if (m_ProcessPinsIndex) {
        for(ULONG pinId = 0; pinId < m_PinFactoriesCount; pinId++) {
            if (m_ProcessPinsIndex[pinId].Pins) {
                delete [] m_ProcessPinsIndex[pinId].Pins;
            }
        }
        delete [] m_ProcessPinsIndex;
    }

    if (m_RelatedPinFactoryIds) {
        delete [] m_RelatedPinFactoryIds;
    }

    if (m_DefaultConnections) {
        delete [] m_DefaultConnections;
    }

    KspTerminateObjectBag(&m_ObjectBag);

}


STDMETHODIMP
CKsFilter::
NonDelegatedQueryInterface(
    IN REFIID InterfaceId,
    OUT PVOID* InterfacePointer
    )

/*++

Routine Description:

    This routine obtains an interface to a filter object.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsFilter::NonDelegatedQueryInterface]"));

    PAGED_CODE();

    ASSERT(InterfacePointer);

    NTSTATUS status = STATUS_SUCCESS;

    if (IsEqualGUIDAligned(InterfaceId,__uuidof(IKsFilter))) {
        *InterfacePointer = reinterpret_cast<PVOID>(static_cast<PIKSFILTER>(this));
        AddRef();
    } else
    if (IsEqualGUIDAligned(InterfaceId,__uuidof(IKsControl))) {
        *InterfacePointer = reinterpret_cast<PVOID>(static_cast<PIKSCONTROL>(this));
        AddRef();
    } else 
    if (IsEqualGUIDAligned(InterfaceId,__uuidof(IKsPowerNotify))) {
        *InterfacePointer = reinterpret_cast<PVOID>(static_cast<PIKSPOWERNOTIFY>(this));
        AddRef();
    } else 
    if (IsEqualGUIDAligned(InterfaceId,__uuidof(IKsProcessingObject))) {
        *InterfacePointer = reinterpret_cast<PVOID>(static_cast<PIKSPROCESSINGOBJECT>(this));
        AddRef();
    } else {
        status = 
            CBaseUnknown::NonDelegatedQueryInterface(
                InterfaceId,
                InterfacePointer);
        if (! NT_SUCCESS(status) && m_Ext.AggregatedClientUnknown) {
            status = m_Ext.AggregatedClientUnknown->
                QueryInterface(InterfaceId,InterfacePointer);
        }
    }

    return status;
}


STDMETHODIMP_(ULONG)
CKsFilter::
NonDelegatedRelease(
    void
    )
/*++

Routine Description:

    Implements INonDelegatedUnknown::NonDelegatedRelease. Decrements
    the reference count on this object. If the reference count reaches
    zero, the object is deleted and if the ClassId was specified on the
    constructor, the reference count on the module which supports the
    class passed in on the constructor is decremented.

    This function must be called directly from the IUnknown::Release()
    method of the object.

Arguments:

    None.

Return Values:

    Returns the current reference count value.

--*/
{
    PAGED_CODE();

    LONG    RefCount;

    //
    // This code is expecting to be called from IUnknown->Release, and will
    // eventually use the new primitives to rearrange the stack so that it
    // is actually run after the calling function has returned.
    //
    if (!(RefCount = InterlockedDecrement(&m_RefCount))) {
        //
        // Cache the event pointer is case DispatchClose() is blocked on
        // object deletion.
        //
        PKEVENT closeEvent = m_CloseEvent;

        //
        // Make CBaseUnknown do the final release.
        //
        m_RefCount++;
        CBaseUnknown::NonDelegatedRelease();

        //
        // Set the close event if there is one.  This only happens when
        // DispatchClose is waiting for the object to get deleted.  The
        // event itself is on the stack of the thread doing the close,
        // so we can safely access the event through this cached pointer.
        //
        if (closeEvent) {
            KeSetEvent(closeEvent,IO_NO_INCREMENT,FALSE);
        }
    }
    return RefCount;
}


NTSTATUS
CKsFilter::
Init(
    IN PIRP Irp,
    IN PKSFILTERFACTORY_EXT Parent,
    IN PLIST_ENTRY SiblingListHead,
    IN const KSFILTER_DESCRIPTOR* Descriptor,
    IN const KSAUTOMATION_TABLE* FilterAutomationTable,
    IN KSAUTOMATION_TABLE*const* PinAutomationTables,
    IN KSAUTOMATION_TABLE*const* NodeAutomationTables OPTIONAL,
    IN ULONG NodesCount
    )

/*++

Routine Description:

    This routine initializes a filter object.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsFilter::Init]"));

    PAGED_CODE();

    ASSERT(Irp);
    ASSERT(Parent);
    ASSERT(SiblingListHead);
    ASSERT(Descriptor);
    ASSERT(FilterAutomationTable);

    //
    // Initialize the generic object members.
    //
    InitializeListHead(&m_Ext.ChildList);
    m_Ext.Parent = Parent;
    m_Ext.ObjectType = KsObjectTypeFilter;
    m_Ext.Interface = this;
    m_Ext.Device = Parent->Device;
    m_Ext.FilterControlMutex = &m_ControlMutex;
    m_Ext.AutomationTable = FilterAutomationTable;
    InitializeInterlockedListHead(&m_Ext.EventList);
    m_Ext.Public.Descriptor = Descriptor;
    m_Ext.Public.Context = Parent->Public.Context;
    m_Ext.Public.Bag = reinterpret_cast<KSOBJECT_BAG>(&m_ObjectBag);
    m_Ext.Device->InitializeObjectBag(&m_ObjectBag,&m_ControlMutex);
    InitializeListHead(&m_InputPipes);
    InitializeListHead(&m_OutputPipes);
    m_ProcessOnRelease = 0;
    KeInitializeMutex(&m_Mutex,0);
    KsGateInitializeAnd(&m_AndGate,NULL);

    InitializeInterlockedListHead(&m_CopyFrames);

    //
    // Initialize filter-specific members.
    //
    m_NodeAutomationTables = NodeAutomationTables;
    m_NodesCount = NodesCount;

    InitializeListHead(&m_ChildNodeList);
    KeInitializeMutex (&m_ControlMutex, 0);
    m_FileObject = IoGetCurrentIrpStackLocation(Irp)->FileObject;

    //
    // Cache processing items from the descriptor.
    //
    if (Descriptor->Dispatch) {
        m_DispatchProcess = Descriptor->Dispatch->Process;
        m_DispatchReset = Descriptor->Dispatch->Reset;
        if (m_DispatchProcess) {
            m_Ext.Device->AddPowerEntry(&m_PowerEntry,this);
        }
    }
    m_ProcessPassive = ((Descriptor->Flags & KSFILTER_FLAG_DISPATCH_LEVEL_PROCESSING) == 0);
    m_WorkQueueType = DelayedWorkQueue;
    if (Descriptor->Flags & KSFILTER_FLAG_CRITICAL_PROCESSING) {
        m_WorkQueueType = CriticalWorkQueue;
    }
    if (Descriptor->Flags & KSFILTER_FLAG_HYPERCRITICAL_PROCESSING) {
        m_WorkQueueType = HyperCriticalWorkQueue;
    }
    m_ReceiveZeroLengthSamples = ((Descriptor -> Flags & KSFILTER_FLAG_RECEIVE_ZERO_LENGTH_SAMPLES) != 0);

    //
    // Register work sink item for processing.   IKsProcessingObject looks like
    // it's derived from IKsWorkSink, but the function name is not Work(), it's
    // ProcessingObjectWork().  That's why IKsProcessingObject is reinterpreted
    // as IKsWorkSink
    //
    KsInitializeWorkSinkItem(
        &m_WorkItem,
        reinterpret_cast<IKsWorkSink*>(
            static_cast<IKsProcessingObject*>(this)));
    KsRegisterWorker(m_WorkQueueType, &m_Worker);

    //
    // Allocate the pin factory array.  This allocation is safely undone in
    // the destructor, so there's no need to clean it up if this function
    // fails.
    //
    m_PinFactoriesCount = Descriptor->PinDescriptorsCount;
    m_PinFactoriesAllocated = Descriptor->PinDescriptorsCount;
    if (m_PinFactoriesCount) { 
        m_PinFactories = 
            new(PagedPool,POOLTAG_PINFACTORY) 
                CKsPinFactory[m_PinFactoriesCount];
        m_ProcessPinsIndex = 
            new(NonPagedPool,POOLTAG_PROCESSPINSINDEX) 
                KSPPROCESSPIN_INDEXENTRY[m_PinFactoriesCount];
        m_RelatedPinFactoryIds = 
            new(PagedPool,'pRsK')
                ULONG[m_PinFactoriesCount];
    } else {
        m_PinFactories = NULL;
        m_ProcessPinsIndex = NULL;
        m_RelatedPinFactoryIds = NULL;
    }

    NTSTATUS status;
    if ((! ConstructDefaultTopology()) ||
        (! m_PinFactories && m_PinFactoriesCount) || 
        (! m_ProcessPinsIndex && m_PinFactoriesCount) || 
        (! m_RelatedPinFactoryIds && m_PinFactoriesCount)) {
        //
        // Out of memory.
        //
        status = STATUS_INSUFFICIENT_RESOURCES;
        if (m_PinFactories) {
            delete [] m_PinFactories;
            m_PinFactories = NULL;
        }
        if (m_ProcessPinsIndex) {
            delete [] m_ProcessPinsIndex;
            m_ProcessPinsIndex = NULL;
        }
        if (m_RelatedPinFactoryIds) {
            delete [] m_RelatedPinFactoryIds;
            m_RelatedPinFactoryIds = NULL;
        }
    } else {
        //
        // Initialize the pin factories.
        //
        CKsPinFactory *pinFactory = m_PinFactories;
        const KSPIN_DESCRIPTOR_EX *pinDescriptor = Descriptor->PinDescriptors;
        for(ULONG pinId = 0; 
            pinId < m_PinFactoriesCount; 
            pinId++, pinFactory++) {
            //
            // Initialize this pin factory.
            //
            pinFactory->m_PinCount = 0;
            InitializeListHead(&pinFactory->m_ChildPinList);
            pinFactory->m_AutomationTable = *PinAutomationTables++;

            //
            // Check necessary pin count.
            // TODO:  What about private mediums/interfaces?
            //
            if (((pinDescriptor->Flags & 
                  KSPIN_FLAG_FRAMES_NOT_REQUIRED_FOR_PROCESSING) == 0) &&
                pinDescriptor->InstancesNecessary) {
                pinFactory->m_InstancesNecessaryForProcessing = 
                    pinDescriptor->InstancesNecessary;
                KsGateAddOffInputToAnd(&m_AndGate);
                _DbgPrintF(DEBUGLVL_PROCESSINGCONTROL,("#### Filter%p.Init:  off%p-->%d (pin type needs pins)",this,&m_AndGate,m_AndGate.Count));
            } else if (((pinDescriptor->Flags &
                KSPIN_FLAG_SOME_FRAMES_REQUIRED_FOR_PROCESSING) != 0) &&
                pinDescriptor->InstancesNecessary) {
                pinFactory->m_InstancesNecessaryForProcessing = 1;
                KsGateAddOffInputToAnd(&m_AndGate);
            }

            if (pinDescriptor->Flags & 
                KSPIN_FLAG_SOME_FRAMES_REQUIRED_FOR_PROCESSING) {

                KsGateInitializeOr (&pinFactory->m_FrameGate, &m_AndGate);

                //
                // Add an input to the gate.  This will "open" the gate and 
                // allow necessary instances to make an impact.  Otherwise,
                // we'd never process until a queue had frames.  This would
                // be bad for 0 necessary instance pins.
                //
                KsGateAddOnInputToOr (&pinFactory->m_FrameGate);
            }

            if (pinDescriptor->Flags &
                KSPIN_FLAG_PROCESS_IF_ANY_IN_RUN_STATE) {

                KsGateInitializeOr (&pinFactory->m_StateGate, &m_AndGate);

                //
                // Add an input to the gate.  This will "open" the gate and
                // allow necessary instances to make an impact.  Otherwise,
                // we'd never process until a pin went into the run state.
                // This would be bad for 0 necessary instance pins.
                //
                KsGateAddOnInputToOr (&pinFactory->m_StateGate);
            }

            pinDescriptor = 
                PKSPIN_DESCRIPTOR_EX(
                    PUCHAR(pinDescriptor) + Descriptor->PinDescriptorSize);
        }

        //
        // Reference the bus.  This tells SWENUM to keep us loaded.  If this is
        // not an SWENUM device, the call is harmless.
        //
        PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);
        status = 
            KsReferenceBusObject(
                *(KSDEVICE_HEADER *)(irpSp->DeviceObject->DeviceExtension));
    }

    BOOLEAN cleanup = FALSE;

    //
    // Call the object create function to do most of the work.  We take the
    // control mutex for the convenience of the client:  bag functions want
    // the mutex taken.
    //
    if (NT_SUCCESS(status)) {
        AddRef();
        AcquireControl();
        status = 
            KspCreate(
                Irp,
                SIZEOF_ARRAY(FilterCreateItems),
                FilterCreateItems,
                &FilterDispatchTable,
                FALSE,
                reinterpret_cast<PKSPX_EXT>(&m_Ext),
                SiblingListHead,
                NULL);
        ReleaseControl();
    } else 
        cleanup = TRUE;


    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (Irp);
    //
    // If we failed prior to KspCreate or we failed in KspCreate in the
    // object header creation process, we must manually perform any cleanup
    // which would ordinarily be done in DispatchClose.
    //
    if (cleanup ||
        (!NT_SUCCESS (status) && Irp->IoStatus.Status ==
            STATUS_MORE_PROCESSING_REQUIRED &&
            irpSp->FileObject->FsContext == NULL)) {

        if (Descriptor->Dispatch && m_DispatchProcess) 
            m_Ext.Device->RemovePowerEntry(&m_PowerEntry);

        if (m_Worker)
            KsUnregisterWorker (m_Worker);
    }

    //
    // Reference our parent.  This prevents the filter factory from 
    // disappearing while the filter is active.  It's rare, but possible
    // that the filter factory is closed (pnp stop) while a filter is
    // opened and a property query comes in on the filter...  the automation
    // table is owned by the factory.
    //
    if (NT_SUCCESS (status)) 
        m_Ext.Parent->Interface->AddRef();

    return status;
}


NTSTATUS
CKsFilter::
EvaluateDescriptor(
    void
    )

/*++

Routine Description:

    This routine evaluates the filter descriptor.

    THE FILTER CONTROL MUTEX SHOULD BE TAKEN PRIOR TO CALLING THIS FUNCTION.

Arguments:

    None.

Return Value:

    Status.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsFilter::EvaluateDescriptor]"));

    PAGED_CODE();

    const KSFILTER_DESCRIPTOR* descriptor = m_Ext.Public.Descriptor;

    //
    // Cache processing items from the descriptor.
    //
    AcquireProcessSync();

    if (descriptor->Dispatch) {
        if (descriptor->Dispatch->Process && ! m_DispatchProcess) {
            m_Ext.Device->AddPowerEntry(&m_PowerEntry,this);
        }
        m_DispatchProcess = descriptor->Dispatch->Process;
        m_DispatchReset = descriptor->Dispatch->Reset;
    } else {
        if (m_DispatchProcess) {
            m_Ext.Device->RemovePowerEntry(&m_PowerEntry);
        }
        m_DispatchProcess = NULL;
        m_DispatchReset = NULL;
    }

    m_ProcessPassive = ((descriptor->Flags & KSFILTER_FLAG_DISPATCH_LEVEL_PROCESSING) == 0);
    m_WorkQueueType = DelayedWorkQueue;
    if (descriptor->Flags & KSFILTER_FLAG_CRITICAL_PROCESSING) {
        m_WorkQueueType = CriticalWorkQueue;
    }
    if (descriptor->Flags & KSFILTER_FLAG_HYPERCRITICAL_PROCESSING) {
        m_WorkQueueType = HyperCriticalWorkQueue;
    }

    ReleaseProcessSync();

    //
    // Has the number of pin factories changed?
    //
    if (m_PinFactoriesCount != descriptor->PinDescriptorsCount) {
        //
        // Hold off processing while we mess with the and gate.
        //
        KsGateAddOffInputToAnd(&m_AndGate);

        //
        // Remove any effect on the and gate introduced by necessary instances.
        //
        CKsPinFactory *pinFactory = m_PinFactories;
        for(ULONG pinId = 0; pinId < m_PinFactoriesCount; pinFactory++, pinId++) {
            if (pinFactory->m_BoundPinCount < 
                pinFactory->m_InstancesNecessaryForProcessing) {
                KsGateRemoveOffInputFromAnd(&m_AndGate);
                _DbgPrintF(DEBUGLVL_PROCESSINGCONTROL,("#### Filter%p.EvaluateDescriptor:  on%p-->%d (pin type needs pins)",this,&m_AndGate,m_AndGate.Count));
            }
        }

        //
        // Allocate more memory for pin arrays if required.
        //
        if (m_PinFactoriesAllocated < descriptor->PinDescriptorsCount) {
            CKsPinFactory* pinFactories = 
                new(PagedPool,POOLTAG_PINFACTORY) 
                    CKsPinFactory[descriptor->PinDescriptorsCount];
            PKSPPROCESSPIN_INDEXENTRY processPinsIndex =
                new(NonPagedPool,POOLTAG_PROCESSPINSINDEX) 
                    KSPPROCESSPIN_INDEXENTRY[descriptor->PinDescriptorsCount];

            if (pinFactories && processPinsIndex) {
                //
                // Allocations went OK.  Do copies and fixups.
                //
                m_PinFactoriesAllocated = descriptor->PinDescriptorsCount;

                RtlCopyMemory(
                    pinFactories,
                    m_PinFactories,
                    sizeof(*pinFactories) * m_PinFactoriesCount);
                delete [] m_PinFactories;
                m_PinFactories = pinFactories;
                
                pinFactory = m_PinFactories;
                for(ULONG pinId = 0; pinId < m_PinFactoriesCount; pinFactory++, pinId++) {
                    pinFactory->m_ChildPinList.Flink->Blink = &pinFactory->m_ChildPinList;
                    pinFactory->m_ChildPinList.Blink->Flink = &pinFactory->m_ChildPinList;
                }
                for (; pinId < m_PinFactoriesAllocated; pinFactory++, pinId++) {
                    InitializeListHead(&pinFactory->m_ChildPinList);
                }

                RtlCopyMemory(
                    processPinsIndex,
                    m_ProcessPinsIndex,
                    sizeof(*processPinsIndex) * m_PinFactoriesCount);
                delete [] m_ProcessPinsIndex;
                m_ProcessPinsIndex = processPinsIndex;
            } else {
                //
                // Allocations failed.
                //
                if (pinFactories) {
                    delete [] pinFactories;
                }
                if (processPinsIndex) {
                    delete [] processPinsIndex;
                }
                return STATUS_INSUFFICIENT_RESOURCES;
            }
        } else if (m_PinFactoriesCount > descriptor->PinDescriptorsCount) {
            //
            // Fewer pins...clean up unused entries.
            //
            pinFactory = m_PinFactories + descriptor->PinDescriptorsCount;
            for(ULONG pinId = descriptor->PinDescriptorsCount; 
                pinId < m_PinFactoriesCount; 
                pinFactory++, pinId++) {
                ASSERT(pinFactory->m_PinCount == 0);
                ASSERT(pinFactory->m_BoundPinCount == 0);
                ASSERT(IsListEmpty(&pinFactory->m_ChildPinList));
                //pinFactory->m_AutomationTable
                ASSERT(! pinFactory->m_CopySourcePipeSection);
                ASSERT(! pinFactory->m_CopySourcePin);
                pinFactory->m_InstancesNecessaryForProcessing = 0;
            }
        }

        m_PinFactoriesCount = descriptor->PinDescriptorsCount;

        //
        // Restore any effect on the and gate introduced by necessary instances.
        //
        pinFactory = m_PinFactories;
        const KSPIN_DESCRIPTOR_EX *pinDescriptor = descriptor->PinDescriptors;
        for(pinId = 0; pinId < m_PinFactoriesCount; pinFactory++, pinId++) {
            //
            // Check necessary pin count.
            // TODO:  What about private mediums/interfaces?
            //
            if (((pinDescriptor->Flags & 
                  KSPIN_FLAG_FRAMES_NOT_REQUIRED_FOR_PROCESSING) == 0) &&
                pinDescriptor->InstancesNecessary) {
                pinFactory->m_InstancesNecessaryForProcessing = 
                    pinDescriptor->InstancesNecessary;
                KsGateAddOffInputToAnd(&m_AndGate);
                _DbgPrintF(DEBUGLVL_PROCESSINGCONTROL,("#### Filter%p.EvaluateDescriptor:  off%p-->%d (pin type needs pins)",this,&m_AndGate,m_AndGate.Count));
            } else {
                pinFactory->m_InstancesNecessaryForProcessing = 0;
            }

            ASSERT(pinFactory->m_PinCount <= pinDescriptor->InstancesPossible);

            pinDescriptor = 
                PKSPIN_DESCRIPTOR_EX(
                    PUCHAR(pinDescriptor) + descriptor->PinDescriptorSize);
        }

        //
        // Stop holding off processing.
        //
        KsGateRemoveOffInputFromAnd(&m_AndGate);
    }

    //
    // See if node count changed.
    //
    NTSTATUS status;
    if (m_NodesCount != descriptor->NodeDescriptorsCount) {
        //
        // Yes.  Cache the new count.
        //
        m_NodesCount = descriptor->NodeDescriptorsCount;

        //
        // Trash the old automation table table.
        //
        if (m_NodeAutomationTables) {
            KsRemoveItemFromObjectBag(
                m_Ext.Public.Bag,
                const_cast<PKSAUTOMATION_TABLE*>(m_NodeAutomationTables),
                TRUE);
            m_NodeAutomationTables = NULL;
        }

        //
        // Create a new automation table.
        //
        if (m_NodesCount) {
            status =
                KspCreateAutomationTableTable(
                    const_cast<PKSAUTOMATION_TABLE**>(&m_NodeAutomationTables),
                    m_NodesCount,
                    descriptor->NodeDescriptorSize,
                    &descriptor->NodeDescriptors->AutomationTable,
                    NULL,
                    m_Ext.Public.Bag);
        } else {
            status = STATUS_SUCCESS;
        }
    } else {
        status = STATUS_SUCCESS;
    }

    return status;
}

#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif // ALLOC_PRAGMA


STDMETHODIMP_(PKSGATE)
CKsFilter::
GetAndGate(
    void
    )

/*++

Routine Description:

    This routine gets a pointer to the KSGATE that controls processing for
    the filter.

Arguments:

    None.

Return Value:

    A pointer to the and gate.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsFilter::GetAndGate]"));

    return &m_AndGate;
}


STDMETHODIMP_(void)
CKsFilter::
TriggerNotification (
    void
    )

/*++

Routine Description:

    A triggering event has happened on this processing object.  This is merely
    a notification.  All we do is increment the event counter.

Arguments:

    None

Return Value:

    None

--*/

{

    InterlockedIncrement (&m_TriggeringEvents);

}

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA


STDMETHODIMP
CKsFilter::
KsProperty(
    IN PKSPROPERTY Property,
    IN ULONG PropertyLength,
    IN OUT LPVOID PropertyData,
    IN ULONG DataLength,
    OUT ULONG* BytesReturned
    )

/*++

Routine Description:

    This routine sends a property request to the file object.

Arguments:

Return Value:

    Status.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsFilter::KsProperty]"));

    PAGED_CODE();

    ASSERT(Property);
    ASSERT(PropertyLength >= sizeof(*Property));
    ASSERT(PropertyData || (DataLength == 0));
    ASSERT(BytesReturned);
    ASSERT(m_FileObject);

    return
        KsSynchronousIoControlDevice(
            m_FileObject,
            KernelMode,
            IOCTL_KS_PROPERTY,
            Property,
            PropertyLength,
            PropertyData,
            DataLength,
            BytesReturned);
}


STDMETHODIMP
CKsFilter::
KsMethod(
    IN PKSMETHOD Method,
    IN ULONG MethodLength,
    IN OUT LPVOID MethodData,
    IN ULONG DataLength,
    OUT ULONG* BytesReturned
    )

/*++

Routine Description:

    This routine sends a method request to the file object.

Arguments:

Return Value:

    Status.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsFilter::KsMethod]"));

    PAGED_CODE();

    ASSERT(Method);
    ASSERT(MethodLength >= sizeof(*Method));
    ASSERT(MethodData || (DataLength == 0));
    ASSERT(BytesReturned);
    ASSERT(m_FileObject);

    return
        KsSynchronousIoControlDevice(
            m_FileObject,
            KernelMode,
            IOCTL_KS_METHOD,
            Method,
            MethodLength,
            MethodData,
            DataLength,
            BytesReturned);
}


STDMETHODIMP
CKsFilter::
KsEvent(
    IN PKSEVENT Event OPTIONAL,
    IN ULONG EventLength,
    IN OUT LPVOID EventData,
    IN ULONG DataLength,
    OUT ULONG* BytesReturned
    )

/*++

Routine Description:

    This routine sends an event request to the file object.

Arguments:

Return Value:

    Status.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsFilter::KsEvent]"));

    PAGED_CODE();

    ASSERT(Event);
    ASSERT(EventLength >= sizeof(*Event));
    ASSERT(EventData || (DataLength == 0));
    ASSERT(BytesReturned);
    ASSERT(m_FileObject);

    //
    // If an event structure is present, this must either be an Enable or
    // or a Support query.  Otherwise this must be a Disable.
    //
    if (EventLength) {
        return 
            KsSynchronousIoControlDevice(
                m_FileObject,
                KernelMode,
                IOCTL_KS_ENABLE_EVENT,
                Event,
                EventLength,
                EventData,
                DataLength,
                BytesReturned);
    } else {
        return 
            KsSynchronousIoControlDevice(
                m_FileObject,
                KernelMode,
                IOCTL_KS_DISABLE_EVENT,
                EventData,
                DataLength,
                NULL,
                0,
                BytesReturned);
    }
}


NTSTATUS
CKsFilter::
DispatchCreatePin(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine dispatches a create IRP to create pins.

Arguments:

    DeviceObject -
        Contains a pointer to the device object.

    Irp -
        Contains a pointer to the create IRP.

Return Value:

    STATUS_SUCCESS or error status.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsFilter::DispatchCreatePin]"));

    PAGED_CODE();

    ASSERT(DeviceObject);
    ASSERT(Irp);

    //
    // Get a pointer to the target object.
    //
    CKsFilter *filter = CKsFilter::FromCreateIrp(Irp);

    //
    // We take the control mutex here to synchronize with changes to the
    // descriptor and access to the object heirarchy.
    //
    filter->AcquireControl();

    //
    // Validate request and get parameters.
    //
    PKSPIN_CONNECT createParams;
    ULONG requestSize;
    NTSTATUS status =
        KspValidateConnectRequest(
            Irp,
            filter->m_Ext.Public.Descriptor->PinDescriptorsCount,
            &filter->m_Ext.Public.Descriptor->PinDescriptors->PinDescriptor,
            filter->m_Ext.Public.Descriptor->PinDescriptorSize,
            &createParams,
            &requestSize);

    //
    // Check instance counts.
    //
    if (NT_SUCCESS(status)) {
        CKsPinFactory *pinFactory = 
            &filter->m_PinFactories[createParams->PinId];
        const KSPIN_DESCRIPTOR_EX *descriptor = 
            PKSPIN_DESCRIPTOR_EX(
                PUCHAR(filter->m_Ext.Public.Descriptor->PinDescriptors) +
                (filter->m_Ext.Public.Descriptor->PinDescriptorSize *
                 createParams->PinId));

        if (pinFactory->m_PinCount >= descriptor->InstancesPossible) {
            status = STATUS_UNSUCCESSFUL;
        } else {
            //
            // Create the pin.
            //
            status = 
                KspCreatePin(
                    Irp,
                    &filter->m_Ext,
                    &pinFactory->m_ChildPinList,
                    createParams,
                    requestSize - sizeof(KSPIN_CONNECT),
                    descriptor,
                    pinFactory->m_AutomationTable,
                    filter->m_NodeAutomationTables,
                    filter->m_NodesCount,
                    &pinFactory->m_PinCount);
        }
    }

    filter->ReleaseControl();

    if (status != STATUS_PENDING) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp,IO_NO_INCREMENT);
    }

    return status;
}


NTSTATUS
CKsFilter::
DispatchCreateNode(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine dispatches a create IRP to create nodes.

Arguments:

    DeviceObject -
        Contains a pointer to the device object.

    Irp -
        Contains a pointer to the create IRP.

Return Value:

    STATUS_SUCCESS or error status.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsFilter::DispatchCreateNode]"));

    PAGED_CODE();

    ASSERT(DeviceObject);
    ASSERT(Irp);

    //
    // Get a pointer to the target object.
    //
    CKsFilter *filter = CKsFilter::FromCreateIrp(Irp);

    NTSTATUS status =
        filter->CreateNode(
            Irp,
            NULL,
            filter->m_Ext.Public.Context,
            &filter->m_ChildNodeList);

    if (status != STATUS_PENDING) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp,IO_NO_INCREMENT);
    }

    return status;
}


NTSTATUS
CKsFilter::
CreateNode(
    IN PIRP Irp,
    IN PIKSPIN ParentPin OPTIONAL,
    IN PVOID Context OPTIONAL,
    IN PLIST_ENTRY SiblingList
    )

/*++

Routine Description:

    This routine creates nodes.

Arguments:

    Irp -
        Contains a pointer to the create IRP.

Return Value:

    STATUS_SUCCESS or error status.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsFilter::CreateNode]"));

    PAGED_CODE();

    ASSERT(Irp);
    ASSERT(SiblingList);

    //
    // We take the control mutex here to synchronize with changes to the
    // descriptor and access to the object heirarchy.
    //
    AcquireControl();

    //
    // Validate request and get parameters.
    //
    PKSNODE_CREATE createParams;
    NTSTATUS status =
        KspValidateTopologyNodeCreateRequest(
            Irp,
            m_NodesCount,
            &createParams);

    //
    // Create the node.
    //
    if (NT_SUCCESS(status)) {
        const KSNODE_DESCRIPTOR *nodeDescriptor =
            (const KSNODE_DESCRIPTOR *)
            (PUCHAR(m_Ext.Public.Descriptor->NodeDescriptors) +
             (m_Ext.Public.Descriptor->NodeDescriptorSize *
              createParams->Node));

        status = STATUS_INVALID_DEVICE_REQUEST;
        // TODO
    }

    ReleaseControl();

    return status;
}


NTSTATUS
CKsFilter::
DispatchDeviceIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine dispatches IOCTL IRPs.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsFilter::DispatchDeviceIoControl]"));

    PAGED_CODE();

    ASSERT(DeviceObject);
    ASSERT(Irp);

    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);
    ASSERT(irpSp);

    //
    // log perf johnlee
    //
    KSPERFLOGS (
       	PKSSTREAM_HEADER pKsStreamHeader;
       	pKsStreamHeader = (PKSSTREAM_HEADER)Irp->AssociatedIrp.SystemBuffer;
       	ULONG	TimeStampMs;
       	ULONG	TotalSize;
       	ULONG	HeaderSize;
       	ULONG 	BufferSize;

        switch (irpSp->Parameters.DeviceIoControl.IoControlCode)
        {
            case IOCTL_KS_READ_STREAM: {
				//
				// compute total size
				//
            	TotalSize = 0;
            	if ( pKsStreamHeader ) {
            		BufferSize = irpSp->Parameters.DeviceIoControl.OutputBufferLength;
	           		while ( BufferSize >= pKsStreamHeader->Size ) {
	           			BufferSize -= pKsStreamHeader->Size;
	           			TotalSize += pKsStreamHeader->FrameExtent;
	           		}
	           		ASSERT( 0 == BufferSize );
            	}
                //KdPrint(("PerfIsAnyGroupOn=%x\n", PerfIsAnyGroupOn()));
                KS2PERFLOG_FRECEIVE_READ( DeviceObject, Irp, TotalSize );
            } break;

            case IOCTL_KS_WRITE_STREAM: {
            	if ( pKsStreamHeader && 
            		 (pKsStreamHeader->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_TIMEVALID)){
            		TimeStampMs =(ULONG)
            			(pKsStreamHeader->PresentationTime.Time / (__int64)10000);
            	}
            	else {
            		TimeStampMs = 0;
            	}

				//
				// compute total size
				//
            	TotalSize = 0;
            	if ( pKsStreamHeader ) {
            		BufferSize = irpSp->Parameters.DeviceIoControl.OutputBufferLength;
	           		while ( BufferSize >= pKsStreamHeader->Size ) {
	           			BufferSize -= pKsStreamHeader->Size;
	           			TotalSize += pKsStreamHeader->DataUsed;
	           		}
	           		ASSERT( 0 == BufferSize );
            	}

                //KdPrint(("PerfIsAnyGroupOn=%x\n", PerfIsAnyGroupOn()));
                KS2PERFLOG_FRECEIVE_WRITE( DeviceObject, Irp, TimeStampMs, TotalSize );
            } break;
                        
        }
    ) // KSPERFLOGS
    
    //
    // Get a pointer to the target object.
    //
    CKsFilter *filter = CKsFilter::FromIrp(Irp);

    NTSTATUS status = 
        KspHandleAutomationIoControl(
            Irp,
            filter->m_Ext.AutomationTable,
            &filter->m_Ext.EventList.ListEntry,
            &filter->m_Ext.EventList.SpinLock,
            filter->m_NodeAutomationTables,
            filter->m_NodesCount);

    if (status != STATUS_PENDING) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp,IO_NO_INCREMENT);
    }

    return status;
}


NTSTATUS
CKsFilter::
DispatchClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine dispatches a close IRP.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsFilter::DispatchClose]"));

    PAGED_CODE();

    ASSERT(DeviceObject);
    ASSERT(Irp);

    //
    // Get a pointer to the target object.
    //
    CKsFilter *filter = CKsFilter::FromIrp(Irp);

    //
    // Remove the object from the power list.
    //
    if (Irp->IoStatus.Status != STATUS_MORE_PROCESSING_REQUIRED)
        filter->m_Ext.Device->AcquireDevice();

    filter->m_Ext.Device->RemovePowerEntry(&filter->m_PowerEntry);

    if (Irp->IoStatus.Status != STATUS_MORE_PROCESSING_REQUIRED)
        filter->m_Ext.Device->ReleaseDevice();

    //
    // Unregister the processing object worker.  This will wait on 
    // uncompleted process work items.
    //
    if (filter->m_Worker) {
        KsUnregisterWorker (filter->m_Worker);
        _DbgPrintF(DEBUGLVL_VERBOSE,("#### filter%p.DispatchClose m_Worker = NULL (%p)",filter,filter->m_Worker));
        filter->m_Worker = NULL;
    }

    //
    // Call the helper.
    //
    NTSTATUS status = 
        KspClose(
            Irp,
            reinterpret_cast<PKSPX_EXT>(&filter->m_Ext),
            FALSE);

    if (status != STATUS_PENDING) {
        //
        // Dereference the bus object.
        //
        KsDereferenceBusObject(
            *(KSDEVICE_HEADER *)(DeviceObject->DeviceExtension));

        //
        // STATUS_MORE_PROCESSING_REQUIRED indicates we are using the close
        // dispatch to synchronously fail a create.  In that case, no sync is
        // required, and the create dispatch will do the completion.
        //
        if (status == STATUS_MORE_PROCESSING_REQUIRED) {
            filter->Release();
        } else {

            PIKSFILTERFACTORY ParentFactory = filter->GetParent();

            //
            // Release the filter.  First we set up the synchronization event.  If
            // there are still outstanding references after the delete, we need
            // to wait on that event for the references to go away.
            //
            KEVENT closeEvent;
            KeInitializeEvent(&closeEvent,SynchronizationEvent,FALSE);
            filter->m_CloseEvent = &closeEvent;
            if (filter->Release()) {
                _DbgPrintF(DEBUGLVL_TERSE,("#### Filter%p.DispatchClose:  waiting for references to go away",filter));
                KeWaitForSingleObject(
                    &closeEvent,
                    Suspended,
                    KernelMode,
                    FALSE,
                    NULL
                );
                _DbgPrintF(DEBUGLVL_TERSE,("#### Filter%p.DispatchClose:  done waiting for references to go away",filter));
            }

            //
            // Release our ref on our parent factory.  This will allow the
            // parent factory to be deleted in some circumstances
            // (Manbugs 39087)
            //
            ParentFactory->Release();

            IoCompleteRequest(Irp,IO_NO_INCREMENT);
        }
    }

    return status;
}


NTSTATUS
CKsFilter::
Property_Pin(
    IN PIRP Irp,
    IN PKSP_PIN PinInstance,
    IN OUT PVOID Data
    )

/*++

Routine Description:

    This routine handles pin property requests.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsFilter::Property_Pin]"));

    PAGED_CODE();

    ASSERT(Irp);
    ASSERT(PinInstance);

    //
    // Get a pointer to the target object.
    //
    CKsFilter *filter = CKsFilter::FromIrp(Irp);

    filter->AcquireControl();

    NTSTATUS status = STATUS_SUCCESS;

    switch (PinInstance->Property.Id) {
    case KSPROPERTY_PIN_CTYPES:
    case KSPROPERTY_PIN_DATAFLOW:
    case KSPROPERTY_PIN_DATARANGES:
    case KSPROPERTY_PIN_CONSTRAINEDDATARANGES:
    case KSPROPERTY_PIN_INTERFACES:
    case KSPROPERTY_PIN_MEDIUMS:
    case KSPROPERTY_PIN_COMMUNICATION:
    case KSPROPERTY_PIN_CATEGORY:
    case KSPROPERTY_PIN_NAME:
        //
        // Use the standard handler for these static properties.
        //
        status =
            KspPinPropertyHandler(
                Irp,
                &PinInstance->Property,
                Data,
                filter->m_Ext.Public.Descriptor->PinDescriptorsCount,
                &filter->m_Ext.Public.Descriptor->
                    PinDescriptors->PinDescriptor,
                filter->m_Ext.Public.Descriptor->PinDescriptorSize);
        filter->ReleaseControl();
        return status;
    }

    //
    // Ensure that the identifier is within the range of pins.
    //
    if ((PinInstance->PinId >=
         filter->m_Ext.Public.Descriptor->PinDescriptorsCount) ||
        PinInstance->Reserved) {
        filter->ReleaseControl();
        return STATUS_INVALID_PARAMETER;
    }

    const KSPIN_DESCRIPTOR_EX *pinDescriptor = 
        PKSPIN_DESCRIPTOR_EX(
            PUCHAR(filter->m_Ext.Public.Descriptor->PinDescriptors) +
            (filter->m_Ext.Public.Descriptor->PinDescriptorSize *
             PinInstance->PinId));
    CKsPinFactory *pinFactory = 
        &filter->m_PinFactories[PinInstance->PinId];

    switch (PinInstance->Property.Id) {
    case KSPROPERTY_PIN_DATAINTERSECTION:
        //
        // Return the data intersection for this pin if the intersect
        // handler is supplied.
        //
        status =
            KsPinDataIntersectionEx(
                Irp,
                PinInstance,
                Data,
                filter->m_Ext.Public.Descriptor->
                    PinDescriptorsCount,
                &filter->m_Ext.Public.Descriptor->
                    PinDescriptors->PinDescriptor,
                filter->m_Ext.Public.Descriptor->PinDescriptorSize,
                pinDescriptor->IntersectHandler,
                &filter->m_Ext.Public);
        break;

    case KSPROPERTY_PIN_CINSTANCES:
        //
        // Return the instance count for this pin.
        //
        {
            PKSPIN_CINSTANCES pinInstanceCount = PKSPIN_CINSTANCES(Data);

            pinInstanceCount->PossibleCount = pinDescriptor->InstancesPossible;
            pinInstanceCount->CurrentCount = pinFactory->m_PinCount;
        }
        break;

    case KSPROPERTY_PIN_NECESSARYINSTANCES:
        //
        // Return the necessary instance count for this pin.
        //
        *PULONG(Data) = pinDescriptor->InstancesNecessary;
        Irp->IoStatus.Information = sizeof(ULONG);
        break;

    default:
        status = STATUS_NOT_FOUND;
        break;
    }

    filter->ReleaseControl();

    return status;
}


NTSTATUS
CKsFilter::
Property_Topology(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    IN OUT PVOID Data
    )

/*++

Routine Description:

    This routine handles topology property requests.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsFilter::Property_Topology]"));

    PAGED_CODE();

    ASSERT(Irp);
    ASSERT(Property);

    //
    // Get a pointer to the target object.
    //
    CKsFilter *filter = CKsFilter::FromIrp(Irp);

    filter->AcquireControl();

    const KSFILTER_DESCRIPTOR *filterDescriptor =
        filter->m_Ext.Public.Descriptor;

    NTSTATUS status;

    switch (Property->Id)
    {
    case KSPROPERTY_TOPOLOGY_CATEGORIES:
        //
        // Return the categories for this filter.
        //
        status =
            KsHandleSizedListQuery(
                Irp,
                filterDescriptor->CategoriesCount,
                sizeof(*filterDescriptor->Categories),
                filterDescriptor->Categories);
        break;

    case KSPROPERTY_TOPOLOGY_NODES:
        //
        // Return the nodes for this filter.
        //
        {
            ULONG outputBufferLength =
                IoGetCurrentIrpStackLocation(Irp)->
                    Parameters.DeviceIoControl.OutputBufferLength;

            ULONG length =
                sizeof(KSMULTIPLE_ITEM) +
                (filterDescriptor->NodeDescriptorsCount *
                 sizeof(GUID));

            if (outputBufferLength == 0) {
                //
                // Only the size was requested. Return a warning with the size.
                //
                Irp->IoStatus.Information = length;
                status = STATUS_BUFFER_OVERFLOW;
            } else if (outputBufferLength >= sizeof(KSMULTIPLE_ITEM)) {
                PKSMULTIPLE_ITEM multipleItem = 
                    PKSMULTIPLE_ITEM(Irp->AssociatedIrp.SystemBuffer);

                //
                // Always return the byte count and count of items.
                //
                multipleItem->Size = length;
                multipleItem->Count = 
                    filterDescriptor->NodeDescriptorsCount;

                //
                // See if there is room for the rest of the information.
                //
                if (outputBufferLength >= length) {
                    //
                    // Long enough for the size/count and the list of items.
                    //
                    GUID *guid = (GUID *)(multipleItem + 1);
                    const KSNODE_DESCRIPTOR *nodeDescriptor =
                        filterDescriptor->NodeDescriptors;
                    for(ULONG count = multipleItem->Count;
                        count--;
                        guid++,
                        nodeDescriptor = 
                            (const KSNODE_DESCRIPTOR *)
                            (PUCHAR(nodeDescriptor) +
                             filterDescriptor->NodeDescriptorSize)) {
                        *guid = *nodeDescriptor->Type;
                    }
                    Irp->IoStatus.Information = length;
                    status = STATUS_SUCCESS;
                } else if (outputBufferLength == sizeof(KSMULTIPLE_ITEM)) {
                    //
                    // It is valid just to request the size/count.
                    //
                    Irp->IoStatus.Information = sizeof(KSMULTIPLE_ITEM);
                    status = STATUS_SUCCESS;
                } else {
                    status = STATUS_BUFFER_TOO_SMALL;
                }
            } else {
                //
                // Too small of a buffer was passed.
                //
                status = STATUS_BUFFER_TOO_SMALL;
            }
        }
        break;

    case KSPROPERTY_TOPOLOGY_CONNECTIONS:
        //
        // Return the connections for this filter.
        //
        if (!filterDescriptor->ConnectionsCount && (filterDescriptor->NodeDescriptorsCount == 1)) {
            //
            // This filter uses the default topology, which is to produce
            // a topology with a single node that connects all input pins
            // to inputs on that node, and all output pins to outputs on
            // the node. Each pin id matches the id of the connection on
            // the node.
            //
            status =
                KsHandleSizedListQuery(
                    Irp,
                    filter->m_DefaultConnectionsCount,
                    sizeof(*filter->m_DefaultConnections),
                    filter->m_DefaultConnections);
        } else {
            status =
                KsHandleSizedListQuery(
                    Irp,
                    filterDescriptor->ConnectionsCount,
                    sizeof(*filterDescriptor->Connections),
                    filterDescriptor->Connections);
        }
        break;

    case KSPROPERTY_TOPOLOGY_NAME:
        //
        // Return the name of the requested node.
        //
        {
            ULONG nodeId = *PULONG(Property + 1);
            if (nodeId >= filterDescriptor->NodeDescriptorsCount) {
                status = STATUS_INVALID_PARAMETER;
            } else {
                const KSNODE_DESCRIPTOR *nodeDescriptor =
                    (const KSNODE_DESCRIPTOR *)
                    (PUCHAR(filterDescriptor->NodeDescriptors) +
                     (filterDescriptor->NodeDescriptorSize *
                      nodeId));

                if (nodeDescriptor->Name &&
                    ! IsEqualGUIDAligned(
                        *nodeDescriptor->Name,GUID_NULL)) {
                    //
                    // The entry must be in the registry if the device 
                    // specifies a name.
                    //
                    status =
                        ReadNodeNameValue(
                            Irp,
                            nodeDescriptor->Name,
                            Data);
                }
                else
                {
                    //
                    // Default to using the GUID of the topology node type.
                    //
                    ASSERT(nodeDescriptor->Type);
                    status =
                        ReadNodeNameValue(
                            Irp,
                            nodeDescriptor->Type,
                            Data);
                }
            }
        }
        break;

    default:
        status = STATUS_NOT_FOUND;
        break;
    }

    filter->ReleaseControl();

    return status;
}


NTSTATUS
CKsFilter::
Property_General_ComponentId(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    IN OUT PVOID Data
    )

/*++

Routine Description:

    This routine handles component ID property requests.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsFilter::Property_General_ComponentId]"));

    PAGED_CODE();

    ASSERT(Irp);
    ASSERT(Property);
    ASSERT(Data);

    //
    // Get a pointer to the target object.
    //
    CKsFilter *filter = CKsFilter::FromIrp(Irp);

    filter->AcquireControl();

    const KSFILTER_DESCRIPTOR *filterDescriptor =
        filter->m_Ext.Public.Descriptor;

    NTSTATUS status;

    if (filterDescriptor->ComponentId) {
        RtlCopyMemory(
            Data,
            filterDescriptor->ComponentId,
            sizeof(KSCOMPONENTID));
        status = STATUS_SUCCESS;
    } else {
        status = STATUS_NOT_FOUND;
    }

    filter->ReleaseControl();

    return status;
}


STDMETHODIMP_(BOOLEAN)
CKsFilter::
IsFrameHolding (
    void
    )

/*++

Routine Description:

    Return whether or not the filter is frame holding.  This is used in the
    pipe code to determine whether or not ENFORCE_FIFO should be attached to
    any input pipes.

    The control mutex should be held while calling this function.

Arguments:

    None

Return Value:

    Whether or not frame holding is enabled.

--*/

{

    return m_FrameHolding;

}


NTSTATUS
CKsFilter::
Property_Frame_Holding (
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    IN OUT PVOID Data
    )

/*++

Routine Description:

    Internal property called to enforce frame holding for 1 in, 1 out filters
    where the input pin is not a source and the output pin owns the pipe's
    requestor.

    This is used temporarily to prevent glitching in the audio stack due to
    GFX. 

Arguments:

Return Value:

--*/

{

    //
    // Get a pointer to the object.
    //
    CKsFilter *Filter = CKsFilter::FromIrp (Irp);
    PBOOL FrameHolding = (PBOOL)Data;

    //
    // Assume it's valid until we deem it otherwise.
    //
    NTSTATUS Status = STATUS_SUCCESS;

    Filter->AcquireControl ();

    if (Property->Flags & KSPROPERTY_TYPE_GET) {

        *FrameHolding = (BOOL)Filter->m_FrameHolding;

    } else  {
    
        //
        // Check for 1-in, 1-out criteria where input can be a sink and output
        // can be a source.  Additional checks will be made before actually 
        // holding frames.
        //
        const KSFILTER_DESCRIPTOR *Descriptor = Filter->m_Ext.Public.Descriptor;
    
        if (Descriptor->Dispatch &&
            Descriptor->Dispatch->Process &&
            Descriptor->PinDescriptorsCount == 2) {
    
            const KSPIN_DESCRIPTOR_EX *PinDescriptor = 
                Descriptor -> PinDescriptors;
    
            for (ULONG i = 0; 
                i < Descriptor->PinDescriptorsCount && NT_SUCCESS (Status); 
                i++) {

                //
                // Ensure that no pins of this type are bound.  Bound pins 
                // indicate they're not in the stop state!
                //
                if (Filter->m_PinFactories[i].m_BoundPinCount != 0) {
                    Status = STATUS_INVALID_DEVICE_STATE;
                    break;
                }

                switch (PinDescriptor -> PinDescriptor.DataFlow) {
    
                    case KSPIN_DATAFLOW_IN:
                        //
                        // Only 1 instance of the input pin is allowed!
                        //
                        if (PinDescriptor -> PinDescriptor.Communication ==
                            KSPIN_COMMUNICATION_SOURCE ||
                            PinDescriptor -> InstancesPossible > 1) {
                            Status = STATUS_INVALID_DEVICE_REQUEST;
                        }
    
                        break;
    
                    case KSPIN_DATAFLOW_OUT:
                        //
                        // Ensure the output pin isn't a sink.  Only 1 instance
                        // of the output pin is allowed unless the output pin
                        // is a splitter pin.
                        //
                        if (PinDescriptor -> PinDescriptor.Communication ==
                                KSPIN_COMMUNICATION_SINK ||
                            (PinDescriptor -> InstancesPossible > 1 &&
                             ((PinDescriptor -> Flags & KSPIN_FLAG_SPLITTER) == 
                                0))) {
                            Status = STATUS_INVALID_DEVICE_REQUEST;
                        }
                        break;
    
                    default:
                        Status = STATUS_INVALID_DEVICE_REQUEST;
                        break;
    
                }
    
                PinDescriptor = (const KSPIN_DESCRIPTOR_EX *)
                    (PUCHAR (PinDescriptor) + 
                    Descriptor -> PinDescriptorSize);
    
            }
    
        } else {
            //
            // If there aren't 2 descriptors, it's not 1-1.  If there's
            // no filter process dispatch, it's not filter-centric and turning
            // this on is bad.
            //
            Status = STATUS_INVALID_DEVICE_REQUEST;
        }

        if (NT_SUCCESS (Status)) {
            Filter -> m_FrameHolding = (BOOLEAN)(*FrameHolding);
        }

    }

    Filter->ReleaseControl ();

    return Status;

}


NTSTATUS
CKsFilter::
GrowProcessPinsTable(
    IN ULONG PinId
    )

/*++

Routine Description:

    This routine creates a new process pins table with a different
    allocated size.

Arguments:

    PinId -
        Contains the ID of the table that needs to grow.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsFilter::GrowProcessPinsTable]"));

    PAGED_CODE();

    ASSERT(m_ProcessPinsIndex);
    ASSERT(PinId < m_PinFactoriesCount);

    ULONG size = m_PinFactories[PinId].m_ProcessPinsIndexAllocation;
    if (size) {
        size *= 2;
    } else {
        size = 1;
    }

    //
    // Allocate the required memory.
    //
    PKSPPROCESSPIN *newTable =
        new(NonPagedPool,POOLTAG_PROCESSPINS) 
            PKSPPROCESSPIN[size];

    if (! newTable) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Copy and free the old table.
    //
    if (m_ProcessPinsIndex[PinId].Pins) {
        RtlCopyMemory(
            newTable,
            m_ProcessPinsIndex[PinId].Pins,
            m_ProcessPinsIndex[PinId].Count * sizeof(*newTable));

        delete [] m_ProcessPinsIndex[PinId].Pins;
    }

    //
    // Install the new table.
    //
    m_ProcessPinsIndex[PinId].Pins = newTable;
    m_PinFactories[PinId].m_ProcessPinsIndexAllocation = size;
    
    return STATUS_SUCCESS;
}


STDMETHODIMP_(BOOLEAN)
CKsFilter::
DoAllNecessaryPinsExist(
    void
    )

/*++

Routine Description:

    This routine determines if all required pins have been connected.

Arguments:

    None.

Return Value:

    Status.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsFilter::DoAllNecessaryPinsExist]"));

    PAGED_CODE();

    ASSERT(KspMutexIsAcquired(&m_ControlMutex));

    CKsPinFactory *pinFactory = m_PinFactories;
    const KSPIN_DESCRIPTOR_EX *pinDescriptor = m_Ext.Public.Descriptor->PinDescriptors;
    for(ULONG pinId = 0;
        pinId < m_PinFactoriesCount;
        pinId++, pinFactory++) {

        if (pinFactory->m_PinCount < pinDescriptor->InstancesNecessary) {
            _DbgPrintF(DEBUGLVL_TERSE,("#### Filter%p.DoAllNecessaryPinsExist:  returning FALSE because there must be %d instances of pin type %d and there are currently only %d instances",this,pinDescriptor->InstancesNecessary,pinId,pinFactory->m_PinCount));
            return FALSE;
        }

        pinDescriptor = 
            PKSPIN_DESCRIPTOR_EX(
                PUCHAR(pinDescriptor) + m_Ext.Public.Descriptor->PinDescriptorSize);
    }

    return TRUE;
}


STDMETHODIMP 
CKsFilter::
AddProcessPin(
    IN PKSPPROCESSPIN ProcessPin
    )

/*++

Routine Description:

    This routine adds a process pin to the process pins table.

Arguments:

    ProcessPin -
        Contains a pointer to the process pin to add.

Return Value:

    Status.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsFilter::AddProcessPin]"));
    _DbgPrintF(DEBUGLVL_VERBOSE,("#### Filter%p.AddProcessPin:  pin%p",this,ProcessPin->Pin));

    PAGED_CODE();

    ASSERT(ProcessPin);

    AcquireProcessSync();

    PKSPPROCESSPIN_INDEXENTRY index =
        &m_ProcessPinsIndex[ProcessPin->Pin->Id];

    //
    // See if we need to allocate a larger table.
    //
    if (m_PinFactories[ProcessPin->Pin->Id].m_ProcessPinsIndexAllocation == 
        index->Count) {
        NTSTATUS status = GrowProcessPinsTable(ProcessPin->Pin->Id);
        if (! NT_SUCCESS(status)) {
            ReleaseProcessSync();
            return status;
        }
    }

    //
    // Add the process pin to the table.
    //
    index->Pins[index->Count] = ProcessPin;
    index->Count++;

    //
    // Allow processing for bridge pins that have enough instances.
    //
    if ((ProcessPin->Pin->Communication == KSPIN_COMMUNICATION_BRIDGE) &&
        (index->Count == ProcessPin->Pin->Descriptor->InstancesNecessary)) {
        KsGateTurnInputOn(&m_AndGate);
        _DbgPrintF(DEBUGLVL_PROCESSINGCONTROL,("#### Filter%p.AddProcessPin:  on%p-->%d",this,&m_AndGate,m_AndGate.Count));
        ASSERT(m_AndGate.Count <= 1);
    }

    ReleaseProcessSync();

    return STATUS_SUCCESS;
}


STDMETHODIMP_(void)
CKsFilter::
RemoveProcessPin(
    IN PKSPPROCESSPIN ProcessPin
    )

/*++

Routine Description:

    This routine removes a process pin from the process pins table.

Arguments:

    ProcessPin -
        Contains a pointer to the pin to remove.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsFilter::RemoveProcessPin]"));
    _DbgPrintF(DEBUGLVL_VERBOSE,("#### Filter%p.RemoveProcessPin:  pin%p",this,ProcessPin->Pin));

    PAGED_CODE();

    ASSERT(ProcessPin);

    //
    // If the process pin is bound to a pipe section, stop the circuit.  This
    // only happens when pins are closed in a state other than STOP.
    //
    if (ProcessPin->PipeSection) {
        _DbgPrintF(DEBUGLVL_PIPES,("#### Filter%p.RemoveProcessPin:  pin%p stopping pipe section",this,ProcessPin->Pin));
        ProcessPin->PipeSection->PipeSection->
            SetDeviceState(NULL,KSSTATE_STOP);

        if (ProcessPin->PipeSection) {
            UnbindProcessPinsFromPipeSection(ProcessPin->PipeSection);
        }
    }

    AcquireProcessSync();

    PKSPPROCESSPIN_INDEXENTRY index =
        &m_ProcessPinsIndex[ProcessPin->Pin->Id];

    //
    // Prevent processing for bridge pins that don't have enough instances.
    //
    if ((ProcessPin->Pin->Communication == KSPIN_COMMUNICATION_BRIDGE) &&
        (index->Count == ProcessPin->Pin->Descriptor->InstancesNecessary)) {
        KsGateTurnInputOff(&m_AndGate);
        _DbgPrintF(DEBUGLVL_PROCESSINGCONTROL,("#### Filter%p.RemoveProcessPin:  off%p-->%d",this,&m_AndGate,m_AndGate.Count));
    }

    //
    // Find the entry.
    //
    PKSPPROCESSPIN *processPinEntry = index->Pins;
    for (ULONG count = index->Count; count--; processPinEntry++) {
        if (*processPinEntry == ProcessPin) {
            if (count) {
                RtlMoveMemory(
                    processPinEntry,
                    processPinEntry + 1,
                    count * sizeof(*processPinEntry));
            }
            //
            // Let's not leave dangling pointers around for the client to
            // see.  Granted, the client should always check Count, but I'd
            // rather NULL out the pointer.
            //
            index->Pins[--index->Count] = NULL;
            break;
        }
    }

    ReleaseProcessSync();
}

#ifdef SUPPORT_DRM

//
// HACKHACK: BUGBUG:
//
// See comments regarding DRM properties implemented in AVStream
//

PFNKSFILTERPROCESS
CKsFilter::
GetProcessDispatch(
    )

/*++

Routine Description:

    This routine returns the dispatch function we're using

--*/

{

    return m_DispatchProcess;

}

#endif // SUPPORT_DRM


void
CKsFilter::
RegisterForCopyCallbacks (
    IN PIKSQUEUE Queue,
    IN BOOLEAN Register
    )

/*++

Routine Description:

    This routine causes the queue to register for any copy callbacks if 
    required.  The queue's frame dismissal callback is used for pin-centric
    splitting.

Arguments:

    Queue -
        The queue to register on

    Register -
        Indication of whether to register or unregister the callback

Return Value:

    None

--*/

{

    if (!m_DispatchProcess) {
        if (Register) 
            Queue -> RegisterFrameDismissalCallback (
                (PFNKSFRAMEDISMISSALCALLBACK)CKsFilter::SplitCopyOnDismissal,
                (PVOID)this
                );
        else 
            Queue -> RegisterFrameDismissalCallback (
                NULL,
                NULL
                );
    }
}


void
CKsFilter::
SetCopySource(
    IN PKSPPROCESSPIPESECTION ProcessPipeSection OPTIONAL,
    IN ULONG PinId
    )

/*++

Routine Description:

    This routine installs a new copy source for a splitter pin.

Arguments:

    ProcessPipeSection -
        Contains a pointer to the copy source pipe section.

    PinId -
        Contains ID of splitting pin.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsFilter::SetCopySource]"));

    PAGED_CODE();

    ASSERT(PinId < m_PinFactoriesCount);

    CKsPinFactory *pinFactory = &m_PinFactories[PinId];

    PKSPPROCESSPIPESECTION oldCopySource = 
        pinFactory->m_CopySourcePipeSection;

    if (oldCopySource) {
        //
        // If there are any frames sitting waiting, they have to go
        // right now.  If they don't, the copy destinations will never
        // see them.
        //
        KIRQL oldIrql;

        DistributeCopyFrames (TRUE, FALSE);

        //
        // Remove the old source from whatever list it was in.
        //
        RemoveEntryList(&oldCopySource->ListEntry);

        //
        // Only copy sources have this pin ID.
        //
        oldCopySource->CopyPinId = ULONG(-1);

        //
        // Unregister any dismissal callbacks that were set in place
        //
        if (oldCopySource && oldCopySource->Queue)
            RegisterForCopyCallbacks (
                oldCopySource->Queue,
                FALSE
                );

    }

    if (ProcessPipeSection) {
        //
        // Put the new source in the right list of pipes.
        //
        if (ProcessPipeSection->Inputs) {
            InsertTailList(&m_InputPipes,&ProcessPipeSection->ListEntry);
        } else {
            InsertTailList(&m_OutputPipes,&ProcessPipeSection->ListEntry);
        }

        //
        // Find the new copy source pin.
        //
        for(PKSPPROCESSPIN copySourcePin = ProcessPipeSection->Outputs; 
            copySourcePin; 
            copySourcePin = copySourcePin->Next) {
            if (copySourcePin->Pin->Id == PinId) {
                break;
            }
        }

        if (! copySourcePin) {
            return;
        }

        pinFactory->m_CopySourcePin = copySourcePin;
        pinFactory->m_CopySourcePipeSection = ProcessPipeSection;
        ProcessPipeSection->CopyPinId = PinId;

        //
        // If the queue has been created, register a copy callback for frame
        // dismissal.  If not, the pipe will perform this action.
        //
        if (ProcessPipeSection->Queue)
            RegisterForCopyCallbacks (
                ProcessPipeSection->Queue,
                TRUE
                );

        if (oldCopySource && ! IsListEmpty(&oldCopySource->CopyDestinations)) {
            //
            // Steal the list of destinations.
            //
            ProcessPipeSection->CopyDestinations = oldCopySource->CopyDestinations;
            ProcessPipeSection->CopyDestinations.Flink->Blink = 
                &ProcessPipeSection->CopyDestinations;
            ProcessPipeSection->CopyDestinations.Blink->Flink = 
                &ProcessPipeSection->CopyDestinations;
            InitializeListHead(&oldCopySource->CopyDestinations);

            //
            // Set the copy source pointers in all the pipe sections.
            //
            for(PLIST_ENTRY listEntry = ProcessPipeSection->CopyDestinations.Flink;
                listEntry != &ProcessPipeSection->CopyDestinations;
                listEntry = listEntry->Flink) {
                PKSPPROCESSPIPESECTION pipeSection =
                    CONTAINING_RECORD(listEntry,KSPPROCESSPIPESECTION,ListEntry);

                //
                // Set the process pin pointers.
                //
                for(PKSPPROCESSPIN processPin = pipeSection->Outputs; 
                    processPin; 
                    processPin = processPin->Next) {
                    if (processPin->Pin->Id == PinId) {
                        processPin->CopySource = copySourcePin;
                    }
                }
            }
        }
    } else {
        //
        // No more pipes to serve as copy source.
        //
        pinFactory->m_CopySourcePipeSection = NULL;
        pinFactory->m_CopySourcePin = NULL;

        ASSERT((! oldCopySource) || IsListEmpty(&oldCopySource->CopyDestinations));
    }
}


void
CKsFilter::
AddCopyDestination(
    IN PKSPPROCESSPIPESECTION ProcessPipeSection,
    IN ULONG PinId
    )

/*++

Routine Description:

    This routine installs a new copy destination for a splitter pin.

Arguments:

    ProcessPipeSection -
        Contains a pointer to the copy source pipe section.

    PinId -
        Contains ID of splitting pin.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsFilter::AddCopyDestination]"));

    PAGED_CODE();

    ASSERT(ProcessPipeSection);
    ASSERT(PinId < m_PinFactoriesCount);

    CKsPinFactory *pinFactory = &m_PinFactories[PinId];

    PKSPPROCESSPIPESECTION copySource = 
        pinFactory->m_CopySourcePipeSection;
    PKSPPROCESSPIN copySourcePin = 
        pinFactory->m_CopySourcePin;

    ASSERT(copySource);

    //
    // Add the pipe to the list of destinations.
    //
    InsertTailList(
        &copySource->CopyDestinations,
        &ProcessPipeSection->ListEntry);

    //
    // Set the process pin pointers.
    //
    for(PKSPPROCESSPIN processPin = ProcessPipeSection->Outputs; 
        processPin; 
        processPin = processPin->Next) {
        if (processPin->Pin->Id == PinId) {
            processPin->CopySource = copySourcePin;
        }
    }
}


void
CKsFilter::
EstablishCopyRelationships(
    IN PKSPPROCESSPIPESECTION ProcessPipeSection,
    IN ULONG PinId
    )

/*++

Routine Description:

    This routine establishes copy relationships for a newly-bound pipe section.

Arguments:

    ProcessPipeSection -
        Contains a pointer to the pipe section.

    PinId -
        Contains ID of splitting pin.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsFilter::EstablishCopyRelationships]"));

    PAGED_CODE();

    ASSERT(ProcessPipeSection);
    ASSERT(PinId < m_PinFactoriesCount);

    PKSPPROCESSPIPESECTION oldCopySource = 
        m_PinFactories[PinId].m_CopySourcePipeSection;

    if (ProcessPipeSection->Inputs || ! oldCopySource) {
        //
        // Either this pipe has inputs or there is no copy source, so this
        // pipe must be the copy source.
        //
        if (oldCopySource && oldCopySource->Inputs) {
            _DbgPrintF(DEBUGLVL_TERSE,("#### Filter%p.EstablishCopyRelationships:  two pipes on splitter pin have input pins",this));
        }

        SetCopySource(ProcessPipeSection,PinId);

        if (oldCopySource) {
            AddCopyDestination(oldCopySource,PinId);
        }
    } else {
        //
        // This pipe section has no inputs, so it can use the existing
        // copy source.
        //
        AddCopyDestination(ProcessPipeSection,PinId);
    }
}


void
CKsFilter::
FindNewCopySource(
    IN PKSPPROCESSPIPESECTION ProcessPipeSection
    )

/*++

Routine Description:

    This routine finds a new copy source for copy destinations attached to a
    pipe section.

Arguments:

    ProcessPipeSection -
        Contains a pointer to the current copy source.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsFilter::FindNewCopySource]"));

    PAGED_CODE();

    ASSERT(ProcessPipeSection);

    ULONG pinId = ProcessPipeSection->CopyPinId;

    if (IsListEmpty(&ProcessPipeSection->CopyDestinations)) {
        //
        // No more pipes to serve as copy source.
        //
        SetCopySource(NULL,pinId);
    } else {
        //
        // Pick a pipe section to be the new copy source.
        //
        PLIST_ENTRY listEntry = 
            RemoveHeadList(&ProcessPipeSection->CopyDestinations);
        PKSPPROCESSPIPESECTION copySource =
            CONTAINING_RECORD(listEntry,KSPPROCESSPIPESECTION,ListEntry);

        SetCopySource(copySource,pinId);

        //
        // Clear the new source's process pin pointers.
        //
        for(PKSPPROCESSPIN processPin = copySource->Outputs; 
            processPin; 
            processPin = processPin->Next) {
            if (processPin->Pin->Id == pinId) {
                processPin->CopySource = NULL;
            }
        }
    }
}


STDMETHODIMP
CKsFilter::
BindProcessPinsToPipeSection(
    IN PKSPPROCESSPIPESECTION PipeSection,
    IN PVOID PipeId OPTIONAL,
    IN PKSPIN Pin OPTIONAL,
    OUT PIKSPIN *MasterPin,
    OUT PKSGATE *AndGate
    )

/*++

Routine Description:

    This routine binds process pins to a pipe section.

Arguments:

    None.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsFilter::BindProcessPinsToPipeSection]"));
    _DbgPrintF(DEBUGLVL_VERBOSE,("#### Filter%p.BindProcessPinsToPipeSection:  pipe%p id=%p",this,PipeSection->PipeSection,PipeId));

    PAGED_CODE();

    ASSERT(KspMutexIsAcquired(&m_ControlMutex));

    ASSERT(PipeSection);
    ASSERT(MasterPin);
    ASSERT(AndGate);

    //
    // Bind pins to the pipe section and look for a master pin.
    //
    PKSPPROCESSPIN prevInput;
    PKSPPROCESSPIN prevOutput;
    PKSPPROCESSPIN masterPin = NULL;
    ULONG splitterPinId = ULONG(-1);
    NTSTATUS status = STATUS_SUCCESS;

    PipeSection->Inputs = NULL;
    PipeSection->Outputs = NULL;

    AcquireProcessSync();

    //
    // For each pin factory.
    //
    CKsPinFactory *pinFactory = &m_PinFactories[Pin ? Pin->Id : 0];
    for(ULONG pinId = Pin ? Pin->Id : 0; 
        NT_SUCCESS(status) && (pinId < m_PinFactoriesCount); 
        pinId++, pinFactory++) {
        //
        // For each pin instance.
        //
        PKSPPROCESSPIN_INDEXENTRY index = &m_ProcessPinsIndex[pinId];
        PKSPPROCESSPIN *processPinEntry = index->Pins;
        for (ULONG count = index->Count; count--; processPinEntry++) {
            PKSPPROCESSPIN processPin = *processPinEntry;
            //
            // If this pin is not in the indicated pipe.  Do nothing.
            //
            if ((processPin->PipeId != PipeId) || 
                (Pin && (processPin->Pin != Pin))) {
                continue;
            } 

            //
            // This pin is already bound to a pipe.  The graph manager has made
            // a mistake.
            //
            if (processPin->PipeSection) {
                _DbgPrintF(DEBUGLVL_TERSE,("#### Filter%p.BindProcessPinsToPipeSection:  THIS PIN IS ALREADY BOUND pin%p %p",this,KspPinInterface(processPin->Pin),processPin));
                status = STATUS_UNSUCCESSFUL;
                break;
            } 

            processPin->PipeSection = PipeSection;

            if (processPin->Pin->DataFlow == KSPIN_DATAFLOW_IN) {
                //
                // This is an input pin.
                //
                if (! PipeSection->Inputs) {
                    PipeSection->Inputs = processPin;
                } else {
                    processPin->DelegateBranch = PipeSection->Inputs;
                    prevInput->Next = processPin;
                }
                prevInput = processPin;
            } else {
                //
                // This is an output pin.
                //
                if (! PipeSection->Outputs) {
                    PipeSection->Outputs = processPin;
                } else {
                    processPin->DelegateBranch = PipeSection->Outputs;
                    prevOutput->Next = processPin;
                }
                prevOutput = processPin;

                //
                // Check to see if we need to deal with copy sources.
                //
                if (processPin->Pin->Descriptor->Flags & KSPIN_FLAG_SPLITTER) {
#if DBG
                    if ((splitterPinId != ULONG(-1)) && (splitterPinId != processPin->Pin->Id)) {
                        _DbgPrintF(DEBUGLVL_ERROR,("CLIENT BUG:  pipe spans multiple KSPIN_FLAG_SPLITTER pins"));
                    }
#endif
                    splitterPinId = processPin->Pin->Id;
                }
            }

            //
            // Check to see if this pin should be the master pin.  Any pin can
            // be the master pin, but we have preferences in this order:
            //
            // 1) A pin that is a frame source.
            // 2) An input pin.
            //
            // The first is exclusive, so if we find one of those, it is
            // the master pin.  Otherwise, we use the best alternate based on
            // the second preference.
            //
            if (ProcessPinIsFrameSource(processPin)) {
                masterPin = processPin;
            }

            //
            // Check to see if this gets us above the necessary pin threshold.
            //
            pinFactory->m_BoundPinCount++;

            //
            // Set up or instancing on frame arrival if the client specifies
            // it.
            //
            // NOTE: This is done here because of the fact that an or gate
            // with no inputs is closed.  Attaching it before at least one
            // pin is bound will hose 0 necessary instance pins.
            //
            if (processPin->Pin->Descriptor->Flags & 
                KSPIN_FLAG_SOME_FRAMES_REQUIRED_FOR_PROCESSING) {

                //
                // If this is the first pin attaching to the gate,
                // lower the initial count on the gate.
                //
                if (pinFactory->m_BoundPinCount == 1) {
                    KsGateTurnInputOff (&pinFactory->m_FrameGate);
                }

                KsPinAttachOrGate (processPin->Pin, 
                    &pinFactory->m_FrameGate);

            }

            if (processPin->Pin->Descriptor->Flags &
                KSPIN_FLAG_PROCESS_IF_ANY_IN_RUN_STATE) {

                //
                // If this is the first pin attaching to the gate,
                // lower the initial count on the gate.
                //
                if (pinFactory->m_BoundPinCount == 1) {
                    KsGateTurnInputOff (&pinFactory->m_StateGate);
                }

                processPin->StateGate = &pinFactory->m_StateGate;
            }

            if (pinFactory->m_BoundPinCount == 
                pinFactory->m_InstancesNecessaryForProcessing) {
                KsGateTurnInputOn(&m_AndGate);
                _DbgPrintF(DEBUGLVL_PROCESSINGCONTROL,("#### Filter%p.BindProcessPinsToPipeSection:  on%p-->%d",this,&m_AndGate,m_AndGate.Count));
                ASSERT(m_AndGate.Count <= 1);
            }

            if (Pin) {
                break;
            }
        }

        if (Pin) {
            break;
        }
    }

    if (NT_SUCCESS(status)) {
        //
        // Connect in-place counterparts.
        //
        if (PipeSection->Inputs && PipeSection->Outputs) {
            PipeSection->Inputs->InPlaceCounterpart = PipeSection->Outputs;
            PipeSection->Outputs->InPlaceCounterpart = PipeSection->Inputs;
        }

        //
        // Identify a copy source or put the pipe section in one of the lists.
        //
        if (splitterPinId != ULONG(-1)) {
            EstablishCopyRelationships(PipeSection,splitterPinId);
        } else if (PipeSection->Inputs) {
            InsertTailList(&m_InputPipes,&PipeSection->ListEntry);
        } else {
            InsertTailList(&m_OutputPipes,&PipeSection->ListEntry);
        }

        //
        // Select the master pin.
        //
        if (PipeSection->Inputs &&
            ((! masterPin) ||
             ProcessPinIsFrameSource(PipeSection->Inputs))) {
            masterPin = PipeSection->Inputs;
        } else
        if (PipeSection->Outputs &&
            ((! masterPin) ||
             ProcessPinIsFrameSource(PipeSection->Outputs))) {
            masterPin = PipeSection->Outputs;
        }

        ASSERT(masterPin);

        PipeSection->RequiredForProcessing =
            ((masterPin->Pin->Descriptor->Flags & 
              (KSPIN_FLAG_FRAMES_NOT_REQUIRED_FOR_PROCESSING |
               KSPIN_FLAG_SOME_FRAMES_REQUIRED_FOR_PROCESSING)) == 0);

        *MasterPin = KspPinInterface(masterPin->Pin);

        *AndGate = &m_AndGate;

        //
        // We disallow processing here and allow the pipe to allow it again.
        // The pipe is able to control when processing will resume.
        //
        KsGateAddOffInputToAnd(&m_AndGate);
        _DbgPrintF(DEBUGLVL_PROCESSINGCONTROL,("#### Filter%p.BindProcessPinsToPipeSection:  off%p-->%d",this,&m_AndGate,m_AndGate.Count));
    } else {
        //
        // Clean up.
        //
        UnbindProcessPinsFromPipeSectionUnsafe(PipeSection);
    }

    ReleaseProcessSync();

    return status;
}


STDMETHODIMP_(void)
CKsFilter::
UnbindProcessPinsFromPipeSection(
    IN PKSPPROCESSPIPESECTION PipeSection
    )

/*++

Routine Description:

    This routine unbinds all process pins from a given pipe section.

Arguments:

    None.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsFilter::UnbindProcessPinsFromPipeSection]"));

    PAGED_CODE();

    ASSERT(PipeSection);
    _DbgPrintF(DEBUGLVL_VERBOSE,("#### Filter%p.UnbindProcessPinsFromPipeSection:  pipe%p",this,PipeSection->PipeSection));


    AcquireProcessSync();
    UnbindProcessPinsFromPipeSectionUnsafe(PipeSection);
    ReleaseProcessSync();
}


void
CKsFilter::
UnbindProcessPinFromPipeSection(
    IN PKSPPROCESSPIN ProcessPin
    )

/*++

Routine Description:

    This routine unbinds a given process pin from a pipe section.

Arguments:

    None.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsFilter::UnbindProcessPinFromPipeSection]"));

    PAGED_CODE();

    ASSERT(ProcessPin);

    //
    // Check to see if this gets us below the necessary pin threshold.
    //
    CKsPinFactory *pinFactory = &m_PinFactories[ProcessPin->Pin->Id];
    if (pinFactory->m_BoundPinCount == 
        pinFactory->m_InstancesNecessaryForProcessing) {
        KsGateTurnInputOff(&m_AndGate);
        _DbgPrintF(DEBUGLVL_PROCESSINGCONTROL,("#### Filter%p.UnbindProcessPinFromPipeSection:  off%p-->%d",this,&m_AndGate,m_AndGate.Count));
    }
    pinFactory->m_BoundPinCount--;

    //
    // If the pin specifies that or instancing is to be done, we must terminate
    // the or instance gate at unbinding of the last pin in the factory.  To
    // do otherwise will hose 0 necessary instance pins.
    //
    if (pinFactory->m_BoundPinCount == 0) {
        if (ProcessPin->Pin->Descriptor->Flags & 
            KSPIN_FLAG_SOME_FRAMES_REQUIRED_FOR_PROCESSING) {

            //
            // In order to preserve behavior for 0 necessary instance pins,
            // add an on input to the 'or' gate.
            //
            KsGateTurnInputOn (&pinFactory->m_FrameGate);

        }
        
        if (ProcessPin->Pin->Descriptor->Flags &
            KSPIN_FLAG_PROCESS_IF_ANY_IN_RUN_STATE) {

            //
            // In order to preserve behavior for 0 necessary instance pins,
            // add an on input to the 'or' gate.
            //
            KsGateTurnInputOn (&pinFactory->m_StateGate);
        }
    }

    ProcessPin->InPlaceCounterpart = NULL;
    ProcessPin->DelegateBranch = NULL;
    ProcessPin->CopySource = NULL;
    ProcessPin->PipeSection = NULL;
    ProcessPin->Next = NULL;
}


void
CKsFilter::
UnbindProcessPinsFromPipeSectionUnsafe(
    IN PKSPPROCESSPIPESECTION PipeSection
    )

/*++

Routine Description:

    This routine unbinds all process pins from a given pipe section.

Arguments:

    None.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsFilter::UnbindProcessPinsFromPipeSectionUnsafe]"));

    PAGED_CODE();

    ASSERT(PipeSection);
    _DbgPrintF(DEBUGLVL_VERBOSE,("#### Filter%p.UnbindProcessPinsFromPipeSectionUnsafe:  pipe%p",this,PipeSection->PipeSection));

    if (PipeSection->CopyPinId != ULONG(-1)) {
        //
        // Find a new copy source for the list of copy destinations.
        //
        FindNewCopySource(PipeSection);
    } else if (PipeSection->ListEntry.Flink) {
        //
        // Remove the pipe section from whatever list it was in.
        //
        RemoveEntryList(&PipeSection->ListEntry);
    }

    //
    // Unbind the pins.
    //
    while (PipeSection->Inputs) {
        PKSPPROCESSPIN processPin = PipeSection->Inputs;
        PipeSection->Inputs = processPin->Next;
        UnbindProcessPinFromPipeSection(processPin);
    }
    ASSERT(PipeSection);
    while (PipeSection->Outputs) {
        ASSERT(PipeSection->Outputs);
        PKSPPROCESSPIN processPin = PipeSection->Outputs;
        ASSERT(processPin);
        PipeSection->Outputs = processPin->Next;
        UnbindProcessPinFromPipeSection(processPin);
    }

    //
    // Clean up the pipe section.
    //
    PipeSection->ListEntry.Flink = NULL;
    PipeSection->ListEntry.Blink = NULL;
    PipeSection->RequiredForProcessing = FALSE;
}


BOOL
CKsFilter::
ConstructDefaultTopology(
    )
/*++

Routine Description:

    This routine optionally constructs a default topology for a filter.

Arguments:

    None.

Return Value:

    TRUE if no topology was needed, or it was constructed, else FALSE if a
    memory error occurred.

--*/

{
    //
    // If there is no explicit topology in the descriptor, and the filter
    // contains only a single, then construct a default topology. Just for
    // sanity, ensure that the filter has at least a single pin.
    //
    PKSTOPOLOGY_CONNECTION newConnections;
    ULONG newConnectionsCount;

    if (!m_Ext.Public.Descriptor->ConnectionsCount &&
        (m_Ext.Public.Descriptor->NodeDescriptorsCount == 1) &&
        m_Ext.Public.Descriptor->PinDescriptorsCount) {
        newConnections = new(PagedPool,POOLTAG_TOPOLOGYCONNECTIONS) KSTOPOLOGY_CONNECTION[m_Ext.Public.Descriptor->PinDescriptorsCount];
        if (!newConnections) {
            return FALSE;
        }
        const KSPIN_DESCRIPTOR_EX* PinDescriptors = m_Ext.Public.Descriptor->PinDescriptors;
        //
        // Each pin maps to a connection point of the same id number on the
        // single topology node. The only difference between pins is whether
        // they are input or output.
        //
        for (newConnectionsCount = 0; newConnectionsCount < m_Ext.Public.Descriptor->PinDescriptorsCount; newConnectionsCount++) {
            if (PinDescriptors->PinDescriptor.DataFlow == KSPIN_DATAFLOW_IN) {
                newConnections[newConnectionsCount].FromNode = KSFILTER_NODE;
                newConnections[newConnectionsCount].ToNode = 0;
            } else {
                newConnections[newConnectionsCount].FromNode = 0;
                newConnections[newConnectionsCount].ToNode = KSFILTER_NODE;
            }
            newConnections[newConnectionsCount].FromNodePin = newConnectionsCount;
            newConnections[newConnectionsCount].ToNodePin = newConnectionsCount;
            PinDescriptors = 
                reinterpret_cast<const KSPIN_DESCRIPTOR_EX*>(
                    reinterpret_cast<const UCHAR *>(PinDescriptors) + 
                        m_Ext.Public.Descriptor->PinDescriptorSize);
        }
    } else {
        newConnections = NULL;
        newConnectionsCount = 0;
    }
    if (m_DefaultConnections) {
        delete [] m_DefaultConnections;
    }
    m_DefaultConnections = newConnections;
    m_DefaultConnectionsCount = newConnectionsCount;
    return TRUE;
}

#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif // ALLOC_PRAGMA


BOOLEAN
CKsFilter::
DistributeCopyFrames (
    IN BOOLEAN AcquireSpinLock,
    IN BOOLEAN AcquireMutex
    )

/*++

Routine Description:

    This routine distributes waiting frames to destination pipes.  This will
    often be called at dispatch level.  

Arguments:

    AcquireSpinLock -
        Specifies whether or not there is a need to acquire the copy list
        lock.

    AcquireMutex -
        Specifies whether or not there is need to acquire the processing
        mutex.  If this is false, we assume the processing mutex is already
        held!

Return Value:

    Whether or not distribution succeeded.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsFilter::DistributeCopyFrames]"));

    KIRQL OldIrql;

    if (AcquireSpinLock) 
        KeAcquireSpinLock (&m_CopyFrames.SpinLock, &OldIrql);

    if (AcquireMutex) {
        LARGE_INTEGER timeout;
        timeout.QuadPart = 0;
        NTSTATUS status = 
            KeWaitForSingleObject(
                &m_Mutex,
                Executive,
                KernelMode,
                FALSE,
                &timeout);

        if (status == STATUS_TIMEOUT) {
            if (AcquireSpinLock) 
                KeReleaseSpinLock (&m_CopyFrames.SpinLock, OldIrql);
            return FALSE;
        }
    }

    //
    // The list spinlock had better be held as well as the mutex.
    //
    PLIST_ENTRY ListEntry, NextListEntry;

    for (ListEntry = m_CopyFrames.ListEntry.Flink;
        ListEntry != &(m_CopyFrames.ListEntry);
        ListEntry = NextListEntry) {

        //
        // Get all the junk we need to copy the frame to destinations.
        // Note that this may result in it getting requeued in the destination
        // queue if there's no buffers available for it to go into.
        //
        PKSPSTREAM_POINTER_COPY_CONTEXT CopyContext = 
            (PKSPSTREAM_POINTER_COPY_CONTEXT)CONTAINING_RECORD (
                ListEntry, KSPSTREAM_POINTER_COPY_CONTEXT, ListEntry
                );

        PKSPSTREAM_POINTER StreamPointer = (PKSPSTREAM_POINTER)&
            (((PKSPSTREAM_POINTER_COPY)CONTAINING_RECORD (
                CopyContext, KSPSTREAM_POINTER_COPY, CopyContext
                ))->StreamPointer);

        PKSPPROCESSPIPESECTION ProcessPipeSection = 
            CONTAINING_RECORD (StreamPointer->Public.Pin, KSPIN_EXT, Public)->
                ProcessPin->PipeSection;

        ProcessPipeSection -> StreamPointer = StreamPointer;

        //
        // NOTE:
        //
        // If this is used as a general mechanism for filter-centric splitting
        // as well, the pipe section flags will need to be stored in the 
        // cloned context information and or'ed in with the options flags
        // to produce the final flags.
        //
        CopyToDestinations (
            ProcessPipeSection,
            StreamPointer->Public.StreamHeader->OptionsFlags,
            FALSE
            );

        NextListEntry = ListEntry->Flink;

        //
        // Pull the stream pointer off the copy frames list.  By this point,
        // **THE FILTER** doesn't care about the frame.  It's possible that
        // one of the destinations wasn't ready to copy and queued.  But if
        // they did, they created a clone and queued the clone.
        //
        RemoveEntryList (ListEntry);	

        //
        // Get rid of this clone, from our perspective, we're done with it...
        // CopyToDestinations may have queued the blasted thing in some
        // destination queue because of lack of buffer availability.
        //
        // It's a game of shuffle the frameref.
        //
        ProcessPipeSection->Queue->DeleteStreamPointer (StreamPointer);

    }

    //
    // We have guaranteed exclusion on m_FramesWaitingForCopy because the
    // list spinlock is held.
    //
    m_FramesWaitingForCopy = 0;

    if (AcquireMutex) {
        ReleaseProcessSync ();
    }

    if (AcquireSpinLock)
        KeReleaseSpinLock (&m_CopyFrames.SpinLock, OldIrql);

    return TRUE;

}


void
CKsFilter::
ReleaseCopyReference (
    IN PKSSTREAM_POINTER streamPointer
    )

/*++

Routine Description:

    Things get really fun here.  Because we can't block at DISPATCH_LEVEL
    for SplitCopyOnDismissal to grab the process mutex as required by
    CopyToDestinations, we have to keep a queue of frames needing to be 
    copied.  The unfortunate thing about this is that we need to have them
    cancellable.  That's the wonder of this routine: handle such cancellation.

Arguments:

    streamPointer -
        The stream pointer being cancelled (external)

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsFilter::ReleaseCopyReference]"));

    KIRQL oldIrql;

    PKSPSTREAM_POINTER pstreamPointer = (PKSPSTREAM_POINTER)
        CONTAINING_RECORD(streamPointer, KSPSTREAM_POINTER, Public);

    PKSPSTREAM_POINTER_COPY_CONTEXT CopyContext =
        (PKSPSTREAM_POINTER_COPY_CONTEXT)streamPointer -> Context;

    CKsFilter *Filter = (CKsFilter *)CopyContext -> Filter;

    KeAcquireSpinLock (&Filter->m_CopyFrames.SpinLock, &oldIrql);

    //
    // Remove the stream pointer from the list and blow it away.
    //
    if (CopyContext->ListEntry.Flink != NULL &&
        !IsListEmpty (&CopyContext->ListEntry)) {

        RemoveEntryList (&CopyContext->ListEntry);
        CopyContext->ListEntry.Flink = NULL; 

        pstreamPointer->Queue->DeleteStreamPointer (pstreamPointer);
    }

    KeReleaseSpinLock (&Filter->m_CopyFrames.SpinLock, oldIrql);

}


NTSTATUS
CKsFilter::
DeferDestinationCopy (
    IN PKSPSTREAM_POINTER StreamPointer
    )

/*++

Routine Description:

    This routine defers a copy to destinations call until later time by
    cloning StreamPointer, queueing the clone, and performing the copy 
    at a later time.

    It is imperative that in-order copying be maintained.  CopyToDestinations
    requires the process mutex held, but SplitCopyOnDismissal happens at
    DISPATCH_LEVEL.  We cannot block for pin-splitting.  Thus, if we can't
    get the mutex, we MUST queue.  This routine performs the clone/queue
    operation.

Arguments:

    StreamPointer -
        The stream pointer referencing the frame needing to be copied to
        destination pipes.

Notes:

    THE COPY FRAME LIST LOCK MUST BE HELD BEFORE CALLING THIS

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsFilter::DeferDestinationCopy]"));

    NTSTATUS status = STATUS_SUCCESS;

    PKSPSTREAM_POINTER ClonePointer;
    PKSPSTREAM_POINTER_COPY_CONTEXT CopyContext;

    status = StreamPointer->Queue->CloneStreamPointer (
        &ClonePointer,
        CKsFilter::ReleaseCopyReference,
        sizeof (KSPSTREAM_POINTER_COPY_CONTEXT),
        StreamPointer,
        KSPSTREAM_POINTER_TYPE_INTERNAL
        );

    //
    // If the above failed, drop the frame on the floor; there 
    // wasn't enough memory to hold the clone.
    //
    if (NT_SUCCESS (status)) {

        ASSERT (ClonePointer->State == 
            KSPSTREAM_POINTER_STATE_LOCKED);

        CopyContext = (PKSPSTREAM_POINTER_COPY_CONTEXT)
            (ClonePointer + 1);

        //
        // Guaranteed exclusion.  List spinlock is held.
        //
        m_FramesWaitingForCopy++;

        //
        // Shove the stream pointer onto the list.  Another 
        // thread will deal with this.
        //
        InsertTailList (
            &m_CopyFrames.ListEntry,
            &CopyContext->ListEntry
            );

        StreamPointer->Queue->UnlockStreamPointer (ClonePointer,
            KSPSTREAM_POINTER_MOTION_NONE);
    }

    return status;

}


void
CKsFilter::
SplitCopyOnDismissal (
    IN PKSPSTREAM_POINTER StreamPointer,
    IN PKSPFRAME_HEADER FrameHeader,
    IN CKsFilter *Filter
    )

/*++

Routine Description:

    This is a callback made by a pin-centric queue for a pin which is being
    split.  The callback is responsible for taking the frame and copying
    to any destinations.

    Given that this callback is made in the context of a queue with the 
    queue spinlock held, we can pretty much be assured we're running at
    DISPATCH_LEVEL.

Arguments:

    StreamPointer -
        The stream pointer which moved and caused the dismissal to occur

    FrameHeader -
        The frame header being dismissed

    Filter -
        The filter this is happening on (this function is static)

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsFilter::SplitCopyOnDismissal]"));

    if (StreamPointer && FrameHeader) {
    
        PKSPPROCESSPIPESECTION ProcessPipeSection = 
            CONTAINING_RECORD (StreamPointer->Public.Pin, KSPIN_EXT, Public)->
                ProcessPin->PipeSection;
    
        KIRQL oldIrql;
    
        if (ProcessPipeSection) {
    
            //
            // We need the process mutex held.  We cannot wait for it.  If we
            // fail to grab it, we must ref the frame and hold it until it's 
            // copied.  In order to synchronize and guarantee no out of order
            // completion, we must hold the frame copy spinlock BEFORE the mutex
            // is grabbed (this may look strange...  keep in mind we already are
            // at DISPATCH_LEVEL the vast majority of the time).
            //
            KeAcquireSpinLock (&Filter->m_CopyFrames.SpinLock, &oldIrql);

            LARGE_INTEGER timeout;
            timeout.QuadPart = 0;

            NTSTATUS status;

            status = 
                KeWaitForSingleObject(
                    &Filter->m_Mutex,
                    Executive,
                    KernelMode,
                    FALSE,
                    &timeout);
    
            //
            // This evaluation must short.  If we timeout we must not call
            // DistributeCopyFrames.  We defer if 1) we didn't get the mutex
            // or 2) the distribution fails.  [Note that at this moment,
            // the distribution shouldn't fail if the mutex is held!]
            //
            if (status == STATUS_TIMEOUT || 
                !Filter->DistributeCopyFrames (FALSE, FALSE)) {
                //
                // We don't really care about the return code from this. 
                // If it didn't defer successfully, the frame gets dropped
                // on the floor and there's no way to deal with that.
                //
                Filter->DeferDestinationCopy (StreamPointer);
                KeReleaseSpinLock (&Filter->m_CopyFrames.SpinLock, oldIrql);
                return;
            } 

            KeReleaseSpinLock (&Filter->m_CopyFrames.SpinLock, oldIrql);

            ProcessPipeSection->StreamPointer = StreamPointer;
    
            Filter->CopyToDestinations (
                ProcessPipeSection,
                StreamPointer->Public.StreamHeader->OptionsFlags |
                    ProcessPipeSection->Outputs->Flags,
                FALSE
                );

            Filter->ReleaseProcessSync ();
        }
    }
}


STDMETHODIMP_(void)
CKsFilter::
Process(
    IN BOOLEAN Asynchronous
    )

/*++

Routine Description:

    This routine invokes frame processing in an arbitrary context.

Arguments:

    None.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsFilter::Process]"));

    if (Asynchronous ||
        (m_ProcessPassive && (KeGetCurrentIrql() > PASSIVE_LEVEL))) {
        KsQueueWorkItem(m_Worker, &m_WorkItem);
    } else {
        ProcessingObjectWork();
    }
}

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA


STDMETHODIMP_(void)
CKsFilter::
Reset(
    void
    )

/*++

Routine Description:

    This routine transmits a reset to the client when a flush occurs.

Arguments:

    None.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsFilter::Reset]"));

    PAGED_CODE();

    AcquireProcessSync();

    if (m_DispatchReset) {
        m_DispatchReset(&m_Ext.Public); // TODO this will get called once per pipe
    }

    ReleaseProcessSync();
}


void
CKsFilter::
TraceTopologicalOutput (
    IN ULONG ConnectionsCount,
    IN const KSTOPOLOGY_CONNECTION *Connections,
    IN const KSTOPOLOGY_CONNECTION *StartConnection,
    IN OUT PULONG RelatedFactories,
    OUT PULONG RelatedFactoryIds
    )

/*++

Routine Description:

    This is a helper for FollowFromTopology.  It traces the topology chain
    and reports any topologically related output pin factories in the
    inpassed arrays.

    The starting connection from FollowFromTopology should always be a 
    connection from KSFILTER_NODE.

Arguments:

    ConnectionsCount -
        Number of topology connections in the filter

    Connections -
        Topology connections in the filter

    StartConnection -
        The starting topology connection (starting trace point)

    RelatedFactories -
        Count of the number of factories in RelatedFactoryIds

    RelatedFactoryIds -
        Contains any related output pin factory ids

Return Value:

    None


--*/

{

    _DbgPrintF(DEBUGLVL_BLAB,("[CKsFilter::TraceTopologicalOutput]"));

    PAGED_CODE();

    //
    // Walk through topology; find any topology nodes that the output of 
    // StartConnection is a source for.  If they are related to an output
    // pin factory, add that factory to the list.  If they are attached to
    // another node, recurse and travel down the topology chain.
    //
    ULONG RemainingConnections = ConnectionsCount;
    const KSTOPOLOGY_CONNECTION *Connection = Connections;
    for ( ; RemainingConnections; RemainingConnections--, Connection++) {

        //
        // If this is a relevant connection, figure out what to do from there.
        //
        if ((Connection != StartConnection) &&
            (Connection->FromNode == StartConnection->ToNode)) {

            //
            // If the connection out of the node in question is to a pin
            // on a filter, the pin factory is related topologically and
            // we're done.  We need to ensure that the pin factory id in
            // question doesn't already appear in the list because it's
            // possible to have a topology 0 -> A -> B/C -> D -> 1.
            //
            if (Connection->ToNode == KSFILTER_NODE) {

                for (ULONG i = 0; i < *RelatedFactories; i++) {
                    if (RelatedFactoryIds [i] == Connection->ToNodePin)
                        continue;
                }

                RelatedFactoryIds [(*RelatedFactories)++] = 
                    Connection->ToNodePin;

            } else {

                //
                // The connection out of the start node points to another
                // topology node.  We need to recursively walk down the
                // topology chain.
                //
                TraceTopologicalOutput (
                    ConnectionsCount,
                    Connections,
                    Connection,
                    RelatedFactories,
                    RelatedFactoryIds
                    );

            }
        }
    }
}


ULONG
CKsFilter::
FollowFromTopology (
    IN ULONG PinFactoryId,
    OUT PULONG RelatedFactoryIds
    )

/*++

Routine Description:

    Determine the topological relationships of PinFactoryId.  Note that this
    only finds topologically related output pins.  The caller is
    responsible for providing storage for the topological information. 
    RelatedFactoryIds should be at least at large as the count of output
    pin factories on the filter.

Arguments:

    PinFactoryId -
        The pin factory id to find topologically related output pins for.

    RelatedFactoryIds -
        Pin factory ids of topologically related output pins will be placed
        here

Return Value:

        The number of topologically related output pin factory id's

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsFilter::FollowFromTopology]"));

    PAGED_CODE();

    ASSERT (RelatedFactoryIds);

    const KSFILTER_DESCRIPTOR *filterDescriptor = 
        m_Ext.Public.Descriptor;

    ULONG ConnectionsCount;
    const KSTOPOLOGY_CONNECTION *TopologyConnections;

    ULONG RelatedFactories = 0;

    //
    // Determine whether we're using the default topology or a topology
    // supplied by the minidriver.  Note that in order to avoid circular
    // topology (this would be a minidriver error) locking the kernel, we
    // must be able to modify the connections table temporarily. 
    //
    // We must make a duplicate copy of the table specifically for the reasons
    // mentioned above.  We can't be modifying the table because of 
    // A) the possibility of receiving a topology query while this is
    // happening, B) the fact that a client's topology connections can
    // be static
    //
    if (!filterDescriptor->ConnectionsCount && 
        (filterDescriptor->NodeDescriptorsCount == 1)) {

        ConnectionsCount = m_DefaultConnectionsCount;
        TopologyConnections = const_cast <const KSTOPOLOGY_CONNECTION *>
            (m_DefaultConnections);

    } else {

        ConnectionsCount = filterDescriptor->ConnectionsCount;
        TopologyConnections = filterDescriptor->Connections;

    }

    //
    // Go through the topology and find the topology connection that
    // originates from the pin factory.
    //
    ULONG RemainingConnections = ConnectionsCount;
    const KSTOPOLOGY_CONNECTION *Connection = TopologyConnections;
    for ( ; RemainingConnections; RemainingConnections--, Connection++) {

        if (Connection->FromNode == KSFILTER_NODE &&
            Connection->FromNodePin == PinFactoryId) {

            //
            // If this is the originating connection out of the pin factory,
            // trace through the topology.
            //
            TraceTopologicalOutput (
                ConnectionsCount,
                TopologyConnections,
                Connection,
                &RelatedFactories,
                RelatedFactoryIds
                );

            break;

        }

    }

    return RelatedFactories;

}
    

STDMETHODIMP_(void)
CKsFilter::
DeliverResetState(
    IN PKSPPROCESSPIPESECTION ProcessPipe,
    IN KSRESET NewState
    )

/*++

Routine Description:

    Deliver a reset state notification to any process pipe section which
    is topologically related to any input pin in the process pipe section
    specified.

    The reasoning behind this is that output queues shunt frames after EOS;
    however, a begin/end flush requires that we be able to receive more data
    despite this EOS.  If the output queues don't get some notification, they
    continue to shunt buffers and we can never move data.

Arguments:

    ProcessPipe -
        The process pipe section mastered by the pin which received the
        reset ioctl.  Any pipe sections containing topologically related
        output pins to the input pins in this pipe section must receive
        notification of the reset.  They must clear their EOS flag as
        appropriate.

    NewState -
        The reset state sent in the IOCTL to the master pin.

Return Value:

    Success / Failure (we must allocate temporary memory to trace through
    the topology.  This may fail in low memory situations)

--*/

{

    _DbgPrintF(DEBUGLVL_BLAB,("[CKsFilter::DeliverResetState]"));
    

    PAGED_CODE();

    PKSPPROCESSPIN ProcessPin;
    ULONG PinFactoryId = (ULONG)-1;

    //
    // Walk through all input pins in this pipe section.
    //
    for (ProcessPin = ProcessPipe -> Inputs; ProcessPin;
        ProcessPin = ProcessPin -> Next) {

        //
        // If we've already visited this pin id, don't retrace our steps.
        //
        if (PinFactoryId == ProcessPin->Pin->Id)
            continue;

        PinFactoryId = ProcessPin -> Pin -> Id;

        //
        // MUSTCHECK:
        //
        // If it's possible to have input pins in the same pipe with factory
        // id's such that it's A B A, this is broken.
        // 

        //
        // Find the topologically related output pin factory ids for this
        // pin factory id.
        //
        ULONG RelatedFactories = FollowFromTopology (
            PinFactoryId,
            m_RelatedPinFactoryIds
            );

        //
        // If there are any topologically related output pins, we have to find
        // them.
        //
        if (RelatedFactories) {

            //
            // In order to safely use the process pins table to find all
            // instances of topologically related output pins, we must hold
            // the process mutex.
            //
            AcquireProcessSync ();

            //
            // Walk through all topologically related output factories.
            //
            ULONG RemainingFactories = RelatedFactories;
            PULONG OutputFactoryId = m_RelatedPinFactoryIds;

            for ( ; RemainingFactories; 
                 RemainingFactories--, OutputFactoryId++) {

                //
                // OutputFactoryId is a topologically related output pin 
                // factory.  Find all instances of this factory.  We can safely
                // use the process pins table to do this because we're not
                // going to be getting a reset ioctl in the stop state.
                //
                PKSPPROCESSPIN_INDEXENTRY Index =
                    &m_ProcessPinsIndex [*OutputFactoryId];

                ULONG PinInstances = Index->Count;
                PKSPPROCESSPIN *ProcessPinOut = Index->Pins;

                for ( ; PinInstances; PinInstances--, ProcessPinOut++) {

                    //
                    // When we inform the pipe, make it appear as though
                    // the request is coming from ProcessPinOut.  Since only
                    // the master pin is honored by the pipe, this should
                    // make is such that we don't signal the pipe multiple
                    // times.
                    //
                    // ASSUMPTION: I'm making an implicit assumption here
                    // that the pipe WILL get flushed at least once by this
                    // method.  ie: We don't have a pipe with two different
                    // factory ids (I don't think that's possible...  If I'm
                    // wrong, this needs fixed) or that there's an input
                    // pin which is topologically related to an output pin
                    // doing an inplace transform from a different input
                    // pin (I don't think that's possible...  or it would
                    // be a very strange topological relationship).
                    //
                    PKSPIN_EXT PinOutExt =
                        (PKSPIN_EXT)CONTAINING_RECORD (
                            (*ProcessPinOut)->Pin,
                            KSPIN_EXT,
                            Public
                            );

                    //
                    // MUSTCHECK: 
                    //
                    // Do I really want a set reset state... or do I want
                    // some other message...?
                    //

                    //
                    // We only actually deliver the message if the
                    // topologically related output pin isn't in the same pipe!
                    // Otherwise, we're delivering to a pipe which has already
                    // gotten the message (although it'd ignore it since the
                    // output isn't master).
                    //
                    if ((*ProcessPinOut)->PipeSection != ProcessPipe) 
                        (*ProcessPinOut)->PipeSection->PipeSection->
                            SetResetState (
                                PinOutExt->Interface,
                                NewState
                                );

                }
            }

            ReleaseProcessSync ();
        }
    }
}


STDMETHODIMP_(void)
CKsFilter::
Sleep(
    IN DEVICE_POWER_STATE State
    )

/*++

Routine Description:

    This routine handles notification that the device is going to sleep.

Arguments:

    State -
        Contains the device power state.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsFilter::Sleep]"));

    PAGED_CODE();

    KsGateAddOffInputToAnd(&m_AndGate);

    AcquireProcessSync();
    ReleaseProcessSync();

    if (m_DispatchSleep) {
        m_DispatchSleep(&m_Ext.Public,State); // TODO this will get called once per pipe
    }
}


STDMETHODIMP_(void)
CKsFilter::
Wake(
    void
    )

/*++

Routine Description:

    This routine handles notification that the device is waking.

Arguments:

    None.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsFilter::Wake]"));

    PAGED_CODE();

    KsGateRemoveOffInputFromAnd(&m_AndGate);

    if (m_DispatchWake) {
        m_DispatchWake(&m_Ext.Public,PowerDeviceD0); // TODO this will get called once per pipe
    }

    if (KsGateCaptureThreshold(&m_AndGate)) {
        Process(TRUE);
    }
}

#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif // ALLOC_PRAGMA


BOOLEAN
CKsFilter::
PrepareProcessPipeSection(
    IN PKSPPROCESSPIPESECTION ProcessPipeSection,
    IN BOOLEAN Reprepare
    )

/*++

Routine Description:

    This routine prepares a process pipe section for processing.

Arguments:

    None.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[PrepareProcessPipeSection]"));

    ASSERT(ProcessPipeSection);

    //
    // Acquire the leading edge stream pointer.
    //
    PKSPSTREAM_POINTER pointer;
    BOOLEAN bFailToZeroLength = FALSE;
    BOOLEAN Fail = FALSE;

    //
    // If the queue isn't attached to the process pipe, it means that
    // we're in the process of shutting down...  one of the sections not
    // in charge of the pipe has stopped, the one in charge has not, and the
    // one in charge transfers data through the pipe.
    //
    // In this case, we simply can't prepare this section.  We may pend because
    // of this and the frame will get shunted out at flush time.
    //
    if (ProcessPipeSection->Queue) {
        pointer = ProcessPipeSection->Queue->
            GetLeadingStreamPointer(KSSTREAM_POINTER_STATE_LOCKED);

        //
        // If the filter doesn't want to receive zero length samples
        // (originally, we just kicked them and only propogated EOS), discard
        // the sample.  Do not discard EOS!
        //
        if (pointer && pointer->Public.Offset->Count == 0 && 
            !m_ReceiveZeroLengthSamples) {

            NTSTATUS Status = STATUS_SUCCESS;
            do {
                //
                // NOTE: Any auto-propogated flags must be added to this list
                //
                if (pointer->Public.StreamHeader->OptionsFlags &
                    KSSTREAM_HEADER_OPTIONSF_ENDOFSTREAM) {
                    Fail =  TRUE;
                    break;
                }
                Status = KsStreamPointerAdvance (&(pointer->Public));
                if (NT_SUCCESS (Status)) {
                    //
                    // If we hit a non-zero length sample, use it.
                    //
                    if (pointer->Public.Offset->Count != 0)
                        break;
                } else {
                    //
                    // If we ran off the edge of the queue because of a
                    // zero length sample, set a flag so we don't later
                    // raise warnings about missing frames.
                    //
                    bFailToZeroLength = TRUE;
                }
            } while (NT_SUCCESS (Status));

            //
            // If we didn't advance successfully, we don't have data.
            //
            if (!NT_SUCCESS (Status))
                pointer = NULL;
        }
    }
    else
        pointer = NULL;
    
#if DBG
    //
    // If we failed due to kicking out a zero length packet that the filter
    // wasn't able to handle, don't raise this warning.
    //
    if (!bFailToZeroLength && !Reprepare && 
        ProcessPipeSection->RequiredForProcessing && ! pointer) {
        _DbgPrintF(DEBUGLVL_TERSE,("[PrepareProcessPipeSection] missing frame"));
    }
#endif
    ProcessPipeSection->StreamPointer = pointer;
    if (pointer) {
        //
        // Distribute the edge information to input pins.
        //
        for(PKSPPROCESSPIN processPin = ProcessPipeSection->Inputs; 
            processPin; 
            processPin = processPin->Next) {
            processPin->StreamPointer = &pointer->Public;
            processPin->Data = pointer->Public.OffsetIn.Data;
            processPin->BytesAvailable = pointer->Public.OffsetIn.Remaining;
        }

        //
        // Distribute the edge information to output pins.
        //
        for(processPin = ProcessPipeSection->Outputs; 
            processPin; 
            processPin = processPin->Next) {
            processPin->StreamPointer = &pointer->Public;
            processPin->Data = pointer->Public.OffsetOut.Data;
            processPin->BytesAvailable = pointer->Public.OffsetOut.Remaining;
        }
    }

    return 
        (!Fail && (
            (! ProcessPipeSection->RequiredForProcessing) || 
            (pointer)
            ));
}


void
CKsFilter::
UnprepareProcessPipeSection(
    IN PKSPPROCESSPIPESECTION ProcessPipeSection,
    IN OUT PULONG Flags,
    IN BOOLEAN Reprepare
    )

/*++

Routine Description:

    This routine unprepares a process pipe section after processing.

Arguments:

    None.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[UnprepareProcessPipeSection]"));

    ASSERT(ProcessPipeSection);
    ASSERT(Flags);

    PKSPSTREAM_POINTER pointer = ProcessPipeSection->StreamPointer;

    if (pointer) {
        BOOLEAN terminate;
        ULONG inBytesUsed;
        ULONG outBytesUsed;

        if (ProcessPipeSection->Inputs) {
            inBytesUsed = ProcessPipeSection->Inputs->BytesUsed;
            pointer->Public.OffsetIn.Remaining -= inBytesUsed;
            pointer->Public.OffsetIn.Data += inBytesUsed;

            //
            // m_ReceiveZeroLengthSamples must short the Count check.  
            // Originally, these didn't make it to the client.  In order
            // not to break existing clients, you can flag whether you want
            // them or not.  If you don't, the old behavior is applied through
            // the m_ReceiveZeroLengthSamples short.  Same goes for below.
            //
            if (pointer->Public.OffsetIn.Remaining == 0 &&
                (!m_ReceiveZeroLengthSamples || 
                 pointer->Public.OffsetIn.Count != 0)) {
                terminate = TRUE;
            } else {
                terminate = ProcessPipeSection->Inputs->Terminate;
            }
        } else {
            inBytesUsed = 0;
            terminate = FALSE;
        }

        if (ProcessPipeSection->Outputs) {
            outBytesUsed = ProcessPipeSection->Outputs->BytesUsed;
            pointer->Public.OffsetOut.Remaining -= outBytesUsed;
            pointer->Public.OffsetOut.Data += outBytesUsed;

            //
            // m_ReceiveZeroLengthSamples must short the Count check.  See
            // above for reasons.
            //
            if (pointer->Public.OffsetOut.Remaining == 0 &&
                (!m_ReceiveZeroLengthSamples ||
                 pointer->Public.OffsetOut.Count != 0)) {
                terminate = TRUE;
            } else {
                terminate = 
                    terminate || ProcessPipeSection->Outputs->Terminate;
            }

            *Flags |= ProcessPipeSection->Outputs->Flags;
        } else {
            outBytesUsed = 0;
        }

        //
        // 'Or' in the indicated flags and check for end of stream.
        //
        BOOLEAN endOfStream = FALSE;
        if (*Flags) {
            pointer->Public.StreamHeader->OptionsFlags |= *Flags;
            if ((*Flags) & KSSTREAM_HEADER_OPTIONSF_ENDOFSTREAM) {
                endOfStream = TRUE;
                terminate = TRUE;
            }
        }

        //
        // Handle frame termination.
        //
        if (terminate) {
            // TODO 'bit clumsy here - what to do about flags?
            if (pointer->Public.StreamHeader->OptionsFlags & 
                KSSTREAM_HEADER_OPTIONSF_ENDOFSTREAM) {
                endOfStream = TRUE;
                *Flags |= KSSTREAM_HEADER_OPTIONSF_ENDOFSTREAM;
            }

            if (ProcessPipeSection->Outputs) {
                pointer->Public.StreamHeader->DataUsed =
                    pointer->Public.OffsetOut.Count -
                    pointer->Public.OffsetOut.Remaining;
            }
            
            if (! IsListEmpty(&ProcessPipeSection->CopyDestinations)) {
                CopyToDestinations(ProcessPipeSection,*Flags,endOfStream);
            }
        }

        //
        // Update byte availability if necessary.
        //
        if (inBytesUsed || outBytesUsed) 
            ProcessPipeSection->Queue->UpdateByteAvailability(
                pointer, inBytesUsed, outBytesUsed);


        //
        // TODO:  what if client failed?
        //

        //
        // Clean up all the input pins.
        //
        for(PKSPPROCESSPIN processPin = ProcessPipeSection->Inputs; 
            processPin; 
            processPin = processPin->Next) {
            processPin->StreamPointer = NULL;
            processPin->Data = NULL;
            processPin->BytesAvailable = 0;
            processPin->BytesUsed = 0;
            processPin->Flags = 0;
            processPin->Terminate = FALSE;
        }

        //
        // Clean up all the output pins.
        //
        for(processPin = ProcessPipeSection->Outputs; 
            processPin; 
            processPin = processPin->Next) {
            processPin->StreamPointer = NULL;
            processPin->Data = NULL;
            processPin->BytesAvailable = 0;
            processPin->BytesUsed = 0;
            processPin->Flags = 0;
            processPin->Terminate = FALSE;
        }

        //
        // All done with this stream pointer now.
        //
        if (!Reprepare || terminate) 
            ProcessPipeSection->Queue->
                UnlockStreamPointer(
                    pointer,
                    terminate ? KSPSTREAM_POINTER_MOTION_ADVANCE : KSPSTREAM_POINTER_MOTION_NONE);
    }
}


BOOLEAN
CKsFilter::
ReprepareProcessPipeSection(
    IN PKSPPROCESSPIPESECTION ProcessPipeSection,
    IN OUT PULONG Flags
    )

/*++

Routine Description:

    Reprepare the process pipe section.  Update any process pin information
    and stream pointers for process pins / stream pointers associated with
    this process pipe section.

Arguments:

Return Value:

--*/

{

    _DbgPrintF(DEBUGLVL_BLAB,("[CKsFilter::ReprepareProcessPipeSection]"));

    //
    // The logic of trying to enforce frame holding gets a lot more complicated
    // if they start updating things on a pin-by-pin basis inside the processing
    // routine.  If GFX's are enabling frame holding, they aren't calling
    // KsProcessPinUpdate.
    //
    ASSERT (!m_FrameHolding);
    
    UnprepareProcessPipeSection (
        ProcessPipeSection,
        Flags,
        TRUE
    );

    return PrepareProcessPipeSection (
        ProcessPipeSection,
        TRUE
    );

}


void
CKsFilter::
CopyToDestinations(
    IN PKSPPROCESSPIPESECTION ProcessPipeSection,
    IN ULONG Flags,
    IN BOOLEAN EndOfStream
    )

/*++

Routine Description:

    This routine copies a frame to other output pipes to implement automatic
    splitter output pins..

Arguments:

    None.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CopyToDestinations]"));

    ASSERT(ProcessPipeSection);

    PKSPSTREAM_POINTER sourcePointer = ProcessPipeSection->StreamPointer;
    ULONG bytesToCopy;
    PUCHAR data;

    if (!ProcessPipeSection->Queue->GeneratesMappings()) {
        bytesToCopy = (ULONG)
            sourcePointer->Public.OffsetOut.Count -
            sourcePointer->Public.OffsetOut.Remaining;
        data = (PUCHAR)(sourcePointer->FrameHeader->FrameBuffer);
    } else {
        bytesToCopy = sourcePointer->Public.StreamHeader->DataUsed;
        data = (PUCHAR)MmGetMdlVirtualAddress (sourcePointer->FrameHeader->Mdl);
    }

    for(PLIST_ENTRY listEntry = ProcessPipeSection->CopyDestinations.Flink;
        listEntry != &ProcessPipeSection->CopyDestinations;
        listEntry = listEntry->Flink) {
        PKSPPROCESSPIPESECTION pipeSection =
            CONTAINING_RECORD(listEntry,KSPPROCESSPIPESECTION,ListEntry);

        PKSPSTREAM_POINTER pointer = 
            pipeSection->Queue->
                GetLeadingStreamPointer(KSSTREAM_POINTER_STATE_LOCKED);

        if (! pointer) {
            _DbgPrintF(DEBUGLVL_TERSE,("#### Filter%p.CopyToDestinations:  could not acquire destination leading edge",this));

            //
            // In pin-centric splitting, we cannot drop the frame...  just
            // because of the way the callbacks to the minidriver work, we can
            // get 2-1 or 3-1 drop-good ratios.
            //
            // Only if we're not filter centric do we make this callback.
            // Since the filter is either pin or filter-centric, this is
            // an appropriate check.
            //
            if (!m_DispatchProcess)
                pipeSection->Queue->CopyFrame (sourcePointer);

            continue;
        }

        if (pointer->Public.OffsetOut.Remaining < bytesToCopy) {
            _DbgPrintF(DEBUGLVL_TERSE,("#### Filter%p.CopyToDestinations:  destination frame too small (%d vs %d)",this,pointer->Public.OffsetOut.Remaining,bytesToCopy));
        } else {
            BOOLEAN GeneratesMappings = pipeSection->Queue->GeneratesMappings();

            RtlCopyMemory(
                GeneratesMappings ?
                    MmGetMdlVirtualAddress (pointer->FrameHeader->Mdl) :
                    pointer->Public.OffsetOut.Data,
                data,
                bytesToCopy);

            if (!GeneratesMappings) {
                pointer->Public.OffsetOut.Remaining -= bytesToCopy;
                pointer->Public.OffsetOut.Data += bytesToCopy;
            } else {
                // 
                // NOTE: This isn't a problem now because split frames are
                // kicked out immediately regardless whether they are filled
                // or not.  I do not bother to recompute Remaining and reset
                // the mapping pointer.  The frame gets kicked out anyway
                //
            }

            //
            // If we need to hold frames and there's a frame held on the
            // source side, the destination side must hold the frame as well.
            //
            if (m_FrameHolding) {
                //
                // If frame holding is on at this point, we're guaranteed
                // safety in doing this because we've already checked that
                // the frame came from a requestor which allocated this way.
                //
                PKSPFRAME_HEADER AttachedSourceHeader =
                    &CONTAINING_RECORD (
                        sourcePointer->Public.StreamHeader,
                        KSPFRAME_HEADER_ATTACHED,
                        StreamHeader)->FrameHeader;

                PKSPSTREAM_POINTER SourceHolder = 
                    AttachedSourceHeader->FrameHolder;

                if (SourceHolder) {
                    PKSPFRAME_HEADER AttachedDestHeader =
                        &CONTAINING_RECORD (
                            pointer->Public.StreamHeader,
                            KSPFRAME_HEADER_ATTACHED,
                            StreamHeader)->FrameHeader;

                    //
                    // If the output doesn't already point to a frame to hold,
                    // have it hold this input frame.
                    //
                    if (AttachedDestHeader->FrameHolder == NULL) {
                        if (!NT_SUCCESS (
                            SourceHolder->Queue->CloneStreamPointer (
                                &AttachedDestHeader->FrameHolder,
                                NULL,
                                0,
                                SourceHolder,
                                KSPSTREAM_POINTER_TYPE_NORMAL
                                ))) {
                            
                            //
                            // If there wasn't enough memory, let the glitch
                            // happen.
                            //
                            AttachedDestHeader->FrameHolder = NULL;
                        }
                    }
                }
            }
        }

        PKSSTREAM_HEADER destHeader = pointer->Public.StreamHeader;
        PKSSTREAM_HEADER sourceHeader = sourcePointer->Public.StreamHeader;

        destHeader->OptionsFlags |= Flags;
        destHeader->DataUsed = bytesToCopy;

        destHeader->PresentationTime = sourceHeader->PresentationTime;
        destHeader->Duration = sourceHeader->Duration;
        destHeader->TypeSpecificFlags = sourceHeader->TypeSpecificFlags;

        //
        // Copy extended stream header information if present.
        //
        if (destHeader->Size > sizeof (KSSTREAM_HEADER) &&
            destHeader->Size >= sourceHeader->Size) {
            RtlCopyMemory (
                destHeader + 1, sourceHeader + 1, sourceHeader->Size -
                    sizeof (KSSTREAM_HEADER)
                );
        }
            
        pointer->Queue->
            UnlockStreamPointer(pointer,KSPSTREAM_POINTER_MOTION_ADVANCE);
    }
}


STDMETHODIMP_(void)
CKsFilter::
ProcessingObjectWork(
    void
    )

/*++

Routine Description:

    This routine processes frames.

Arguments:

    None.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsFilter::ProcessingObjectWork]"));

    //
    // We syncronize with KeWaitForSingleObject() so the code we synchronize with
    // may be paged even if processing is done at DISPATCH_LEVEL.  If we are
    // at DISPATCH_LEVEL, we can't wait here, so we arrange to be called again.
    //
    if (KeGetCurrentIrql() == PASSIVE_LEVEL) {
        //
        // Simple wait.
        //
        KeWaitForSingleObject(
            &m_Mutex,
            Executive,
            KernelMode,
            FALSE,
            NULL);
    } else {
        //
        // Wait with zero timeout and arrange to be called if we don't get
        // the mutex.
        //
        ASSERT( !m_ProcessOnRelease );
        m_ProcessOnRelease = 1;

        //
        // We have to synchronize with a thread that owns the mutex when we
        // start servicing this DISPATCH_LEVEL processing request.  We CANNOT
        // run if the current thread already owns the mutex.  Dispatch level
        // processing must treat an already owned mutex as a semaphore and
        // NOT reacquire it.
        //
        if (KeReadStateMutex(&m_Mutex) != 1) {
            m_ProcessOnRelease = 2;
            return;
        }

        LARGE_INTEGER timeout;
        timeout.QuadPart = 0;
        NTSTATUS status = 
            KeWaitForSingleObject(
                &m_Mutex,
                Executive,
                KernelMode,
                FALSE,
                &timeout);

        if (status == STATUS_TIMEOUT) {
            m_ProcessOnRelease = 2;
            return;
        }

        m_ProcessOnRelease = 0;
    }

    ASSERT(m_DispatchProcess);

    //
    // Loop until we are out of data.
    //
    NTSTATUS status;
    while (1) {
        BOOLEAN ProcessOnPend = FALSE;

        status = STATUS_SUCCESS;

        //
        // Make sure processing hasn't been turned off since invocation.
        //
        ASSERT(m_AndGate.Count <= 0);
        if (m_AndGate.Count == 0) {

            //
            // GFX:
            //
            // From the local analysis by Prefast, these vars might not be
            // initialized in some conditions. It is not obvious that this
            // can be proven impossible. The "ASSERT (InputPointer && OutputPointer)"
            // below seems to indicate that this should be the case. But
            // it's followed by a real check on the two vars. Therefore, 
            // Initlaizing them is a consistent treatment as well as a safer measure.
            //
            PKSPSTREAM_POINTER InputPointer=NULL;
            PKSPSTREAM_POINTER OutputPointer=NULL;
            
            //
            // Because we process on queue deletion, it's possible that
            // we triggered a processing dispatch on stop of the last 
            // pin on the filter where the pin factory specifies zero 
            // necessary instances.  The queue doesn't have a way to determine
            // this prior to kicking off the attempt; however, we know here.
            // If there aren't any pipes, we have hit this situation; simply
            // bail out and don't process.
            //
            if (IsListEmpty(&m_InputPipes) && IsListEmpty(&m_OutputPipes)) {
                KsGateTurnInputOn(&m_AndGate);
                break;
            }

            //
            // Reset the trigger counter.
            //
            InterlockedExchange(&m_TriggeringEvents, 0);

            //
            // Prepare each pipe having input pins.
            //
            for(PLIST_ENTRY listEntry = m_InputPipes.Flink;
                listEntry != &m_InputPipes;
                listEntry = listEntry->Flink) {
                PKSPPROCESSPIPESECTION pipeSection =
                    CONTAINING_RECORD(listEntry,KSPPROCESSPIPESECTION,ListEntry);

                if (! PrepareProcessPipeSection(pipeSection, FALSE)) {
                    //
                    // Since micro-samples weren't originally allowed to
                    // propogate down to the filter, we have special checks
                    // for filters which need to receive them (via a flag).
                    // Any micro-sample which has made it here is one which
                    // requires flag propogation and cannot arbitrarily
                    // pend (to do so would cause deadlock potential).  Set
                    // STATUS_MORE_PROCESSING_REQUIRED to indicate that we
                    // must continue.
                    //
                    if (pipeSection->StreamPointer &&
                        pipeSection->StreamPointer->Public.Offset->Count == 0) {
                        status = STATUS_MORE_PROCESSING_REQUIRED;
                    } else {
                        status = STATUS_PENDING;
                    }
                }

                //
                // GFX:
                //
                if (m_FrameHolding &&
                    status != STATUS_PENDING) {
                    //
                    // Verify that frame holding is valid.  Shut it off if
                    // for some reason, it is not.
                    //
                    if (pipeSection->Requestor ||
                        listEntry->Flink != &m_InputPipes ||
                        pipeSection->Outputs != NULL) {
                        m_FrameHolding = FALSE;
                    } else {
                        InputPointer = pipeSection->StreamPointer;
                    }
                }

            }

            //
            // Prepare each pipe having only output pins.
            //
            for(listEntry = m_OutputPipes.Flink;
                listEntry != &m_OutputPipes;
                listEntry = listEntry->Flink) {
                PKSPPROCESSPIPESECTION pipeSection =
                    CONTAINING_RECORD(listEntry,KSPPROCESSPIPESECTION,ListEntry);

                if (! PrepareProcessPipeSection(pipeSection, FALSE)) {
                    status = STATUS_PENDING;
                }

                //
                // GFX:
                //
                if (m_FrameHolding &&
                    status != STATUS_PENDING) {
                    //
                    // Verify that frame holding is valid.  Shut it off if
                    // for some reason, it is not.
                    //
                    if (!pipeSection->Requestor ||
                        listEntry->Flink != &m_OutputPipes ||
                        pipeSection->Inputs != NULL) {
                        m_FrameHolding = FALSE;
                    } else {
                        OutputPointer = pipeSection->StreamPointer;
                    }
                }
            }

            //
            // GFX:
            //
            // If we are enabling frame holding, hold the input frame until
            // the output frame completes.  This is only valid for 1-1 
            // sink->source filters.
            //
            // m_FrameHolding set indicates that it **IS VALID** to perform
            // this operation.
            //
            if (m_FrameHolding &&
                status != STATUS_PENDING) {

                ASSERT (InputPointer && OutputPointer);
                if (InputPointer && OutputPointer) {
                    //
                    // Clone the input pointer and associate it with the 
                    // output pointer.  We cannot simply associate it with
                    // the frame header, because each queue is currently
                    // allocating and destroying its own frame headers.  We 
                    // must go to the attached frame header that the requestor
                    // tagged.  We are safe to do this because we've already
                    // checked conditions (1-in, 1-out, out owns requestor,
                    // requestor right before queue).
                    //
                    PKSPFRAME_HEADER AttachedHeader =
                        &CONTAINING_RECORD (
                            OutputPointer->Public.StreamHeader,
                            KSPFRAME_HEADER_ATTACHED,
                            StreamHeader)->FrameHeader;

                    if (!AttachedHeader->FrameHolder) {
                        if (!NT_SUCCESS (InputPointer->Queue->
                            CloneStreamPointer (
                                &AttachedHeader->FrameHolder,
                                NULL,
                                0,
                                InputPointer,
                                KSPSTREAM_POINTER_TYPE_NORMAL
                                )
                            )) {

                            //
                            // If we ran out of resources, let the glitch 
                            // happen.
                            //
                            AttachedHeader->FrameHolder = NULL;
                        }
                    }
                }
            }

            //
            // Call the client function if we are still happy.
            //
            if (status != STATUS_PENDING &&
                status != STATUS_MORE_PROCESSING_REQUIRED) {
                status = 
                    m_DispatchProcess(
                        &m_Ext.Public,
                        reinterpret_cast<PKSPROCESSPIN_INDEXENTRY>(
                            m_ProcessPinsIndex));
            }

            //
            // Clean up.  
            //
            ULONG flags = 0;

            //
            // Unprepare each pipe having input pins.
            //
            for(listEntry = m_InputPipes.Flink; 
                listEntry != &m_InputPipes;
                listEntry = listEntry->Flink) {
                PKSPPROCESSPIPESECTION pipeSection =
                    CONTAINING_RECORD(listEntry,KSPPROCESSPIPESECTION,ListEntry);
                UnprepareProcessPipeSection(pipeSection,&flags,FALSE);
            }

            //
            // Unprepare each pipe having only output pins.
            //
            for(listEntry = m_OutputPipes.Flink; 
                listEntry != &m_OutputPipes;
                listEntry = listEntry->Flink) {
                PKSPPROCESSPIPESECTION pipeSection =
                    CONTAINING_RECORD(listEntry,KSPPROCESSPIPESECTION,ListEntry);
                UnprepareProcessPipeSection(pipeSection,&flags,FALSE);
            }

            //
            // If we had to use unprepares to propogate flags, we should not
            // just arbitrarily pend, we can deadlock (we can have multiple
            // EOS's on input).
            //
            // Normally, this will simply return.
            //
            if (status == STATUS_MORE_PROCESSING_REQUIRED)
                status = STATUS_SUCCESS;

            if ((status == STATUS_PENDING) || ! NT_SUCCESS(status)) {
                KsGateTurnInputOn(&m_AndGate);
                if (m_TriggeringEvents == 0)
                    break;

                ProcessOnPend = TRUE;
            }
        }

        //
        // Determine if we have enough data to continue.
        //
        if (m_AndGate.Count != 0) {
            if (!ProcessOnPend)
                KsGateTurnInputOn(&m_AndGate);

            if (! KsGateCaptureThreshold(&m_AndGate)) {
                break;
            }
        } else if (ProcessOnPend) {
            //
            // If we've gotten here, one of two things has happened. 
            //
            //     1: Another thread captured threshold and will process.
            //
            //     2: The client lowered the gate manually.
            //
            // There is no way to detect which case here.  We will break out
            // and release the mutex.  If processing was to recommence, this
            // will defer it to the waiting thread.
            //
            break;
        }
    }

    ReleaseProcessSync();
}


void
CKsFilter::
HoldProcessing (
)

/*++

Routine Description:

    Hold off processing while we mess with the filter.  We will remove any
    effect due to necessary instances incase the caller changes anything
    regarding necessary instances (dynamic addition / deletion / etc)

Arguments:

    None

Return Value:

    None

--*/

{

    //
    // Hold off processing while we mess with the and gate.
    //
    KsGateAddOffInputToAnd(&m_AndGate);

    //
    // Remove any effect on the and gate introduced by necessary instances.
    //
    CKsPinFactory *pinFactory = m_PinFactories;
    for(ULONG pinId = 0; pinId < m_PinFactoriesCount; pinFactory++, pinId++) {
        if (pinFactory->m_BoundPinCount < 
            pinFactory->m_InstancesNecessaryForProcessing) {
            KsGateRemoveOffInputFromAnd(&m_AndGate);
            _DbgPrintF(DEBUGLVL_PROCESSINGCONTROL,("#### Filter%p.EvaluateDescriptor:  on%p-->%d (pin type needs pins)",this,&m_AndGate,m_AndGate.Count));
        }
    }
}


void
CKsFilter::
RestoreProcessing (
)

/*++

Routine Description:

    Restore the hold on processing induced by HoldProcessing.  This will
    restore any effects on the gate due to necessary instances of pins, etc...
    and will turn on the input offed in HoldProcessing

Arguments:

    None

Return Value:

    None

--*/

{
    CKsPinFactory *pinFactory;
    //
    // Restore any effect on the and gate introduced by necessary instances.
    //
    pinFactory = m_PinFactories;
    const KSPIN_DESCRIPTOR_EX *pinDescriptor = 
        m_Ext.Public.Descriptor->PinDescriptors;
    for(ULONG pinId = 0; pinId < m_PinFactoriesCount; pinFactory++, pinId++) {
        //
        // Check necessary pin count.
        // TODO:  What about private mediums/interfaces?
        //
        if (((pinDescriptor->Flags & 
              KSPIN_FLAG_FRAMES_NOT_REQUIRED_FOR_PROCESSING) == 0) &&
            pinDescriptor->InstancesNecessary) {
            pinFactory->m_InstancesNecessaryForProcessing = 
                pinDescriptor->InstancesNecessary;
            KsGateAddOffInputToAnd(&m_AndGate);
            _DbgPrintF(DEBUGLVL_PROCESSINGCONTROL,("#### Filter%p.EvaluateDescriptor:  off%p-->%d (pin type needs pins)",this,&m_AndGate,m_AndGate.Count));
        } else if (((pinDescriptor->Flags &
            KSPIN_FLAG_SOME_FRAMES_REQUIRED_FOR_PROCESSING) != 0) &&
            pinDescriptor->InstancesNecessary) {
            pinFactory->m_InstancesNecessaryForProcessing = 1;
            KsGateAddOffInputToAnd(&m_AndGate);
        } else {
            pinFactory->m_InstancesNecessaryForProcessing = 0;
        }

        ASSERT(pinFactory->m_PinCount <= pinDescriptor->InstancesPossible);

        pinDescriptor = 
            PKSPIN_DESCRIPTOR_EX(
                PUCHAR(pinDescriptor) + m_Ext.Public.Descriptor->
                PinDescriptorSize);
    }

    //
    // Stop holding off processing.
    //
    KsGateRemoveOffInputFromAnd(&m_AndGate);

}


NTSTATUS
CKsFilter::
AddPinFactory (
    IN const KSPIN_DESCRIPTOR_EX *const Descriptor,
    OUT PULONG AssignedId
    )

/*++

Routine Description:

    Add a new pin factory to this filter.  The new pin factory will have
    an assigned ID which will be passed back to the caller.

Arguments:

    Descriptor -
        The descriptor for the pin factory being added.

    AssignedId -
        The numeric Id of the new pin factory.  This is passed back to
        the caller.

Return Value:

    Success / failure as NTSTATUS

Notes:

    THE CALLER **MUST** HOLD THE FILTER CONTROL MUTEX PRIOR TO CALLING THIS
    ROUTINE.

--*/

{ 

    PKSFILTER_DESCRIPTOR *FilterDescriptor = 
        const_cast<PKSFILTER_DESCRIPTOR *>(&m_Ext.Public.Descriptor);
    ULONG PinDescriptorSize = (*FilterDescriptor) -> PinDescriptorSize;
    ULONG PinDescriptorsCount = (*FilterDescriptor) -> PinDescriptorsCount;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG NewPinFactoryId;

    // 
    // Make sure the client isn't specifying this as 0.  
    //
    ASSERT (PinDescriptorSize != 0);
    if (PinDescriptorSize == 0)
        return STATUS_INVALID_PARAMETER;
   
    // FULLMUTEX: due to the full mutex change, this can be done now
    AcquireControl ();

    HoldProcessing ();

    //
    // Ensure we have edit access to the descriptors
    //
    Status = _KsEdit (m_Ext.Public.Bag,
        (PVOID *)FilterDescriptor, sizeof (**FilterDescriptor),
        sizeof (**FilterDescriptor), 'dfSK');

    if (NT_SUCCESS (Status)) {
        //
        // Resize the pin descriptor list, ensure we have access to it,
        // and add in the new descriptor.
        //
        // We do not yet count for deletion reuse: client IDs shift on
        // deletion (MUSTFIX):
        //
        Status = _KsEdit (m_Ext.Public.Bag,
            (PVOID *)(&((*FilterDescriptor) -> PinDescriptors)),
            PinDescriptorSize * (PinDescriptorsCount + 1),
            PinDescriptorSize * PinDescriptorsCount,
            'dpSK');
    }

    CKsPinFactory *pinFactories = NULL;
    PKSPPROCESSPIN_INDEXENTRY processPinsIndex = NULL;
    PULONG relatedPinFactoryIds = NULL;

    if (NT_SUCCESS (Status)) {

        pinFactories =
            new(PagedPool, POOLTAG_PINFACTORY)
                CKsPinFactory [PinDescriptorsCount + 1];
        processPinsIndex =
            new(NonPagedPool,POOLTAG_PROCESSPINSINDEX) 
                KSPPROCESSPIN_INDEXENTRY[PinDescriptorsCount + 1];
        relatedPinFactoryIds =
            new(PagedPool,'pRsK')
                ULONG[PinDescriptorsCount + 1];
    
        if (!pinFactories || !processPinsIndex || !relatedPinFactoryIds) 
            Status = STATUS_INSUFFICIENT_RESOURCES;

    }

    PKSAUTOMATION_TABLE *NewPinAutomationTables = NULL;

    //
    // Build automation table for the new pin.
    //
    if (NT_SUCCESS (Status)) {

        Status = KspCreateAutomationTableTable (
            &NewPinAutomationTables,
            1,
            PinDescriptorSize,
            &Descriptor -> AutomationTable,
            &PinAutomationTable,
            m_Ext.Public.Bag);
    }

    //
    // All memory has been allocated.  No operation can fail from now on.
    // The reevaluate calldown currently cannot fail.
    //
    if (NT_SUCCESS (Status)) {
    
        RtlCopyMemory ((PUCHAR)((*FilterDescriptor) -> PinDescriptors) +
            PinDescriptorSize * PinDescriptorsCount,
            Descriptor,
            PinDescriptorSize);
    
        NewPinFactoryId = PinDescriptorsCount;
        (*FilterDescriptor) -> PinDescriptorsCount = ++PinDescriptorsCount;
    
        //
        // Update the pin factories
        //
        CKsPinFactory *pinFactory = m_PinFactories;
        for (ULONG pinId = 0; pinId < m_PinFactoriesCount;
            pinFactory++, pinId++) 
    
            if (IsListEmpty (&pinFactory -> m_ChildPinList)) 
                pinFactory -> m_ChildPinList.Flink =
                    pinFactory -> m_ChildPinList.Blink =
                    NULL;
    
        m_PinFactoriesAllocated = PinDescriptorsCount;
    
        if (m_PinFactories && m_PinFactoriesCount) {
            RtlCopyMemory (pinFactories, m_PinFactories, 
                sizeof (CKsPinFactory) * m_PinFactoriesCount);
            delete [] m_PinFactories;
        }
        m_PinFactories = pinFactories;
    
        if (m_ProcessPinsIndex && m_PinFactoriesCount) {
            RtlCopyMemory(processPinsIndex, m_ProcessPinsIndex,
                sizeof(*processPinsIndex) * m_PinFactoriesCount);
            delete [] m_ProcessPinsIndex;
        }
        m_ProcessPinsIndex = processPinsIndex;

        if (m_RelatedPinFactoryIds) {
            delete [] m_RelatedPinFactoryIds;
        }
        m_RelatedPinFactoryIds = relatedPinFactoryIds;
    
        pinFactory = m_PinFactories;    
        for (pinId = 0; pinId < m_PinFactoriesCount; pinFactory++, pinId++) {
            if (pinFactory -> m_ChildPinList.Flink == NULL)
                InitializeListHead (&pinFactory -> m_ChildPinList);
            else {
                pinFactory -> m_ChildPinList.Flink -> Blink =
                    &pinFactory -> m_ChildPinList;
                pinFactory -> m_ChildPinList.Blink -> Flink =
                    &pinFactory -> m_ChildPinList;
            }
    
            PLIST_ENTRY Child;
    
            //
            // Inform our children of the changes
            //
    
            for (Child = pinFactory -> m_ChildPinList.Flink;
                Child != &pinFactory -> m_ChildPinList;
                Child = Child -> Flink) {
    
                PKSPX_EXT ext = CONTAINING_RECORD (Child, KSPX_EXT,
                    SiblingListEntry);
    
                if (ext -> Reevaluator) {
                    Status = ext -> Reevaluator -> ReevaluateCalldown (3, 
                        &((*FilterDescriptor) -> PinDescriptors [pinId]),
                        &pinFactory -> m_PinCount,
                        &pinFactory -> m_ChildPinList);
    
                    //
                    // The mechanism as it exists currently cannot fail.  At
                    // some future point, this may change and this code will
                    // need modified to deal with it.
                    //
                    ASSERT (NT_SUCCESS (Status));
                }
            }
        }

        InitializeListHead (&pinFactory -> m_ChildPinList);
        pinFactory -> m_AutomationTable = *NewPinAutomationTables;

        if (Descriptor->Flags & 
            KSPIN_FLAG_SOME_FRAMES_REQUIRED_FOR_PROCESSING) {

            KsGateInitializeOr (&pinFactory->m_FrameGate, &m_AndGate);

            //
            // Add an input to the gate.  This will "open" the gate and 
            // allow necessary instances to make an impact.  Otherwise,
            // we'd never process until a queue had frames.  This would
            // be bad for 0 necessary instance pins.
            //
            KsGateAddOnInputToOr (&pinFactory->m_FrameGate);
        }

        if (Descriptor->Flags &
            KSPIN_FLAG_PROCESS_IF_ANY_IN_RUN_STATE) {

            KsGateInitializeOr (&pinFactory->m_StateGate, &m_AndGate);

            //
            // Add an input to the gate.  This will "open" the gate and
            // allow necessary instances to make an impact.  Otherwise,
            // we'd never process until a pin went into the run state.
            // This would be bad for 0 necessary instance pins.
            //
            KsGateAddOnInputToOr (&pinFactory->m_StateGate);
        }
    
        m_PinFactoriesCount = PinDescriptorsCount;

        *AssignedId = NewPinFactoryId;
    }

    if (NewPinAutomationTables) {
        KsRemoveItemFromObjectBag (m_Ext.Public.Bag,
            NewPinAutomationTables,
            TRUE
            );
    }

    //
    // Clean up anything on error.
    //
    if (!NT_SUCCESS (Status)) {
        if (pinFactories) {
            delete [] pinFactories;
            pinFactories = NULL;
        }
        if (processPinsIndex) {
            delete [] processPinsIndex;
            processPinsIndex = NULL;
        }
        if (relatedPinFactoryIds) {
            delete [] relatedPinFactoryIds;
            relatedPinFactoryIds = NULL;
        }
    }

    RestoreProcessing ();

    // FULLMUTEX: due to the full mutex change, this can be done now
    ReleaseControl ();
    
    return Status;

}


NTSTATUS
CKsFilter::
AddNode (
    IN const KSNODE_DESCRIPTOR *const Descriptor,
    OUT PULONG AssignedId
    )

/*++

Routine Description:

    Add a topology node to a filter.  The assigned ID will be passed back
    to the caller.

Arguments:

    Descriptor -
        The node descriptor for the node to be added to the filter

    AssignedId -
        The Id assigned to the topology node will be passed back to the caller
        through this

Return Value:

    Success / failure as NTSTATUS

Notes:

    THE CALLER **MUST** HOLD THE FILTER CONTROL MUTEX PRIOR TO CALLING THIS
    ROUTINE.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PKSFILTER_DESCRIPTOR *FilterDescriptor = 
        const_cast<PKSFILTER_DESCRIPTOR *>(&m_Ext.Public.Descriptor);
    ULONG NodeDescriptorSize = (*FilterDescriptor) -> NodeDescriptorSize;
    ULONG NodeDescriptorsCount = (*FilterDescriptor) -> NodeDescriptorsCount;

    ULONG NewNodeId;

    //
    // Make sure the client doesn't specify this as zero.
    //
    ASSERT (NodeDescriptorSize != 0);
    if (NodeDescriptorSize == 0)
        return STATUS_INVALID_PARAMETER;

    // FULLMUTEX: due to the full mutex change, this can be done now
    AcquireControl ();

    HoldProcessing ();

    //
    // Ensure we have edit access to the descriptor
    //
    Status = _KsEdit (m_Ext.Public.Bag,
        (PVOID *)FilterDescriptor, sizeof (**FilterDescriptor),
        sizeof (**FilterDescriptor), 'dfSK');

    if (NT_SUCCESS (Status)) {
        //
        // Resize the node descriptor list, ensure we have access to it,
        // and add in the new descriptor.
        //
        // We do not yet count for deletion reuse: client IDs shift on
        // deletion (MUSTFIX):
        //
        Status = _KsEdit (m_Ext.Public.Bag,
            (PVOID *)(&((*FilterDescriptor) -> NodeDescriptors)),
            NodeDescriptorSize * (NodeDescriptorsCount + 1),
            NodeDescriptorSize * NodeDescriptorsCount,
            'dnSK');
    }

    KSAUTOMATION_TABLE *const* NewNodeAutomationTables;

    if (NT_SUCCESS (Status)) {

        RtlCopyMemory ((PUCHAR)((*FilterDescriptor) -> NodeDescriptors) +
            NodeDescriptorSize * NodeDescriptorsCount,
            Descriptor,
            NodeDescriptorSize);

        Status = KspCreateAutomationTableTable (
            const_cast <PKSAUTOMATION_TABLE **>(&NewNodeAutomationTables),
            m_NodesCount + 1,
            NodeDescriptorSize,
            &((*FilterDescriptor) -> NodeDescriptors -> AutomationTable),
            NULL,
            m_Ext.Public.Bag);

        //
        // If we didn't succeed in creating the new automation table for some
        // reason, we'll fail and zero out the node descriptor that was just
        // added.  Since we never incremented the count, all we did was shuffle
        // around memory so far.
        //
        if (!NT_SUCCESS (Status)) {
            RtlZeroMemory (
                (PUCHAR)((*FilterDescriptor) -> NodeDescriptors) +
                    NodeDescriptorSize * NodeDescriptorsCount,
                    NodeDescriptorSize
                    );
        }
    }

    if (NT_SUCCESS (Status)) {
    
        NewNodeId = NodeDescriptorsCount;
        (*FilterDescriptor) -> NodeDescriptorsCount = ++NodeDescriptorsCount;
    
        m_NodesCount = NodeDescriptorsCount;
    

        if (!ConstructDefaultTopology ()) 
            Status = STATUS_INSUFFICIENT_RESOURCES;

        //
        // If we ran out of memory in building default topology, back out
        // the changes.
        //
        if (!NT_SUCCESS (Status)) {

            (*FilterDescriptor) -> NodeDescriptorsCount--;
            m_NodesCount--;

            RtlZeroMemory (
                (PUCHAR)((*FilterDescriptor) -> NodeDescriptors) +
                    NodeDescriptorSize * NodeDescriptorsCount,
                    NodeDescriptorSize
                    );

            //
            // Ditch the new automation tables and never overwrite the old
            // ones.
            //
            KsRemoveItemFromObjectBag (
                m_Ext.Public.Bag,
                const_cast<PKSAUTOMATION_TABLE *>(NewNodeAutomationTables),
                TRUE
                );

        } else {

            if (m_NodeAutomationTables) {
                KsRemoveItemFromObjectBag (
                    m_Ext.Public.Bag,
                    const_cast<PKSAUTOMATION_TABLE *>(m_NodeAutomationTables),
                    TRUE);
            }

            m_NodeAutomationTables = NewNodeAutomationTables;
    
            ASSERT (NewNodeAutomationTables);
    
            *AssignedId = NewNodeId;
        }
    }

    RestoreProcessing ();

    // FULLMUTEX: due to the full mutex change, this can be done now
    ReleaseControl ();

    return Status;

}


NTSTATUS
KspFilterValidateTopologyConnectionRequest (
    IN PKSFILTER Filter,
    IN const KSTOPOLOGY_CONNECTION *TopologyConnection
) {

/*++

Routine Description:

    Return whether or not the requested topology connection is valid
    for the given filter instance.

Arguments:

    Filter -
        The filter instance on which to check the given topology connection

    TopologyConnection -
        The topology connection to verify

Return Value:

    STATUS_SUCCESS -
        The topology connection is valid

    !STATUS_SUCCESS -
        Something is wrong with the topology connection

--*/

    //
    // Check validity on the source end of the topology connection.
    //
    if (TopologyConnection -> FromNode != KSFILTER_NODE) {

        //
        // Check that the referenced topology node really exists
        //
        if (TopologyConnection -> FromNode >= Filter -> Descriptor -> 
            NodeDescriptorsCount)

            return STATUS_INVALID_PARAMETER; // better error code?

    } else {

        //
        // Check that the referenced pin really exists and is indeed an
        // input pin.
        //
        if (TopologyConnection -> FromNodePin >= Filter -> Descriptor -> 
            PinDescriptorsCount || Filter -> Descriptor -> 
            PinDescriptors [TopologyConnection -> FromNodePin].PinDescriptor.
            DataFlow == KSPIN_DATAFLOW_OUT)

            return STATUS_INVALID_PARAMETER;

    }

    //
    // Check validity on the destination end of the topology connection.
    //
    if (TopologyConnection -> ToNode != KSFILTER_NODE) {

        //
        // Check that the referenced topology node really exists
        //
        if (TopologyConnection -> ToNode >= Filter -> Descriptor -> 
            NodeDescriptorsCount )

            return STATUS_INVALID_PARAMETER;

    } else {

        //
        // Check that the referenced pin really exists and is indeed an
        // output pin.
        //

        if (TopologyConnection -> ToNodePin >= Filter -> Descriptor -> 
            PinDescriptorsCount || Filter -> Descriptor -> 
            PinDescriptors [TopologyConnection -> ToNodePin].PinDescriptor.
            DataFlow == KSPIN_DATAFLOW_IN)

            return STATUS_INVALID_PARAMETER;

    }

    return STATUS_SUCCESS;

}


NTSTATUS
CKsFilter::
AddTopologyConnections (
    IN ULONG NewConnectionsCount,
    IN const KSTOPOLOGY_CONNECTION *const NewTopologyConnections
    )

/*++

Routine Description:

    Add new topology connections to the filter.

Arguments:

    NewConnectionsCount -
        The number of new topology connections in NewTopologyConnections

    NewTopologyConnections -
        A table of topology connections to add to the filter.

Return Value:

    Success / failure as NTSTATUS

Notes:

    THE CALLER **MUST** HOLD THE FILTER CONTROL MUTEX PRIOR TO CALLING THIS
    ROUTINE.

--*/

{

    NTSTATUS Status = STATUS_SUCCESS;
    PKSFILTER_DESCRIPTOR *FilterDescriptor = 
        const_cast<PKSFILTER_DESCRIPTOR *>(&m_Ext.Public.Descriptor);
    const KSTOPOLOGY_CONNECTION *CurConnection =  NewTopologyConnections;
    ULONG ConnectionsCount = (*FilterDescriptor) -> ConnectionsCount;

    //
    // Acquire control mutex now so incase two threads attempt to update
    // topology at the same time, the verification checks don't clash
    //

    // FULLMUTEX: due to the full mutex change, this can be done now
    AcquireControl ();

    //
    // Walk through the list of requested topology connections and
    // verify that the requested connection can really be made.
    //


    for (ULONG CurNode = NewConnectionsCount; CurNode;
        CurNode--, CurConnection++) {

        if (!NT_SUCCESS (Status = KspFilterValidateTopologyConnectionRequest (
            &m_Ext.Public, CurConnection))) {

            // ReleaseControl ();
            return Status;

        }

    }

    HoldProcessing ();

    //
    // Ensure we have edit access to the descriptor
    //
    Status = _KsEdit (m_Ext.Public.Bag,
        (PVOID *)FilterDescriptor, sizeof (**FilterDescriptor),
        sizeof (**FilterDescriptor), 'dfSK');

    if (NT_SUCCESS (Status)) {
        Status = _KsEdit (m_Ext.Public.Bag,
            (PVOID *)(&((*FilterDescriptor) -> Connections)),
            sizeof (KSTOPOLOGY_CONNECTION) * (ConnectionsCount + 
                NewConnectionsCount),
            sizeof (KSTOPOLOGY_CONNECTION) * ConnectionsCount,
            'ctSK');
    }

    if (NT_SUCCESS (Status)) {
        RtlCopyMemory ((PVOID)((*FilterDescriptor) -> Connections + 
            ConnectionsCount), NewTopologyConnections, 
            sizeof (KSTOPOLOGY_CONNECTION) * NewConnectionsCount);

        if (!ConstructDefaultTopology ())
            Status = STATUS_INSUFFICIENT_RESOURCES;

        //
        // If we ran out of memory, back out the change.
        //
        if (!NT_SUCCESS (Status)) {
            RtlZeroMemory (
                (PVOID)((*FilterDescriptor) -> Connections +
                    ConnectionsCount),
                sizeof (KSTOPOLOGY_CONNECTION)
                );
        }
    }

    if (NT_SUCCESS (Status)) {
        (*FilterDescriptor) -> ConnectionsCount += NewConnectionsCount;
        ConnectionsCount += NewConnectionsCount;
    }

    RestoreProcessing ();

    // FULLMUTEX: due to the full mutex change, this can be done now
    ReleaseControl ();

    return Status;

}


KSDDKAPI
PKSGATE
NTAPI
KsFilterGetAndGate(
    IN PKSFILTER Filter
    )

/*++

Routine Description:

    This routine gets the KSGATE that controls processing for the filter.

Arguments:

    Filter -
        Contains a pointer to the public filter object.

Return Value:

    A pointer to the KSGATE that controls processing for the filter.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsFilterGetAndGate]"));

    ASSERT(Filter);

    CKsFilter *filter = CKsFilter::FromStruct(Filter);

    return filter->GetAndGate();
}

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA


KSDDKAPI
void
NTAPI
KsFilterAcquireProcessingMutex(
    IN PKSFILTER Filter
    )

/*++

Routine Description:

    This routine acquires the processing mutex.

Arguments:

    Filter -
        Contains a pointer to the public filter object.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsFilterAcquireProcessingMutex]"));

    PAGED_CODE();

    ASSERT(Filter);

    CKsFilter *filter = CKsFilter::FromStruct(Filter);

    filter->AcquireProcessSync();
}


KSDDKAPI
void
NTAPI
KsFilterReleaseProcessingMutex(
    IN PKSFILTER Filter
    )

/*++

Routine Description:

    This routine releases the processing mutex.

Arguments:

    Filter -
        Contains a pointer to the public filter object.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsFilterReleaseProcessingMutex]"));

    PAGED_CODE();

    ASSERT(Filter);

    CKsFilter *filter = CKsFilter::FromStruct(Filter);

    filter->ReleaseProcessSync();
}

#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif // ALLOC_PRAGMA


KSDDKAPI
void
NTAPI
KsFilterAttemptProcessing(
    IN PKSFILTER Filter,
    IN BOOLEAN Asynchronous
    )

/*++

Routine Description:

    This routine attempts filter processing.

Arguments:

    Filter -
        Contains a pointer to the public filter object.

    Asynchronous - 
        Contains an indication of whether processing should occur
        asyncronously with respect to the calling thread.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsFilterAttemptProcessing]"));

    ASSERT(Filter);

    CKsFilter *filter = CKsFilter::FromStruct(Filter);

    //
    // Manually attempting processing is a triggerable event.  If they
    // are currently processing and pend, we call them back due to this.
    //
    filter->TriggerNotification();

    if (KsGateCaptureThreshold(filter->GetAndGate())) {
        filter->Process(Asynchronous);
    }
}

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA


KSDDKAPI
ULONG
NTAPI
KsFilterGetChildPinCount(
    IN PKSFILTER Filter,
    IN ULONG PinId
    )

/*++

Routine Description:

    This routine obtains a filter's child pin count.

Arguments:

    Filter -
        Points to the filter structure.

    PinId -
        The ID of the child pins to be counted.

Return Value:

    The number of pins currently instantiated of the indicated type.  If the
    PinId is out of range, 0 is returned.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsFilterGetChildPinCount]"));

    PAGED_CODE();

    ASSERT(Filter);

    if (PinId >= Filter->Descriptor->PinDescriptorsCount) {
        return 0;
    }

    return CKsFilter::FromStruct(Filter)->GetChildPinCount(PinId);
}


KSDDKAPI
PKSPIN
NTAPI
KsFilterGetFirstChildPin(
    IN PKSFILTER Filter,
    IN ULONG PinId
    )

/*++

Routine Description:

    This routine obtains a filter's first child pin.

Arguments:

    Filter -
        Points to the filter structure.

    PinId -
        The ID of the child pin to be obtained.

Return Value:

    A pointer to the first child pin.  NULL is returned if PinId is out of
    range or there are no pins of the indicated type.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsFilterGetFirstChildPin]"));

    PAGED_CODE();

    ASSERT(Filter);

    //
    // This requires that the control mutex be held in order to safely
    // use any return value.  Ensure this.
    // 
#if DBG
    PKSFILTER_EXT Ext = (PKSFILTER_EXT)CONTAINING_RECORD (
        Filter, KSFILTER_EXT, Public
        );

    if (!KspMutexIsAcquired (Ext -> FilterControlMutex)) {
        _DbgPrintF(DEBUGLVL_ERROR,("CLIENT BUG:  unsychronized access to object hierarchy - need to acquire control mutex"));
    }
#endif // DBG

    if (PinId >= Filter->Descriptor->PinDescriptorsCount) {
        return NULL;
    }

    PLIST_ENTRY listEntry = 
        CKsFilter::FromStruct(Filter)->GetChildPinList(PinId);

    if (listEntry->Flink == listEntry) {
        return NULL;
    } else {
        return 
            &CONTAINING_RECORD(listEntry->Flink,KSPIN_EXT,SiblingListEntry)->
                Public;
    }
}

#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif // ALLOC_PRAGMA


KSDDKAPI
PKSFILTER
NTAPI
KsGetFilterFromIrp(
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns the filter to which an IRP was submitted.

Arguments:

    Irp -
        Contains a pointer to an IRP which must have been sent to a file
        object corresponding to a filter, pin or node.

Return Value:

    A pointer to the filter to which the IRP was submitted.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsGetFilterFromIrp]"));

    ASSERT(Irp);

    //
    // Check for device level Irps...
    //
    if (IoGetCurrentIrpStackLocation (Irp)->FileObject == NULL)
        return NULL;

    PKSPX_EXT ext = KspExtFromIrp(Irp);

    if (ext->ObjectType == KsObjectTypeFilter) {
        return PKSFILTER(&ext->Public);
    } else if (ext->ObjectType == KsObjectTypePin) {
        return KsPinGetParentFilter(PKSPIN(&ext->Public));
    } else {
        ASSERT(! "No support for node objects yet");
        return NULL;
    }
}


KSDDKAPI
ULONG
NTAPI
KsGetNodeIdFromIrp(
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns the ID of the node to which an IRP was submitted.

Arguments:

    Irp -
        Contains a pointer to an IRP which must have been sent to a file
        object corresponding to a filter, pin or node.

Return Value:

    The ID of the node to which the IRP was submitted or KSNODE_FILTER.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsGetNodeIdFromIrp]"));

    ASSERT(Irp);

    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);
    ASSERT(irpSp);

    //
    // Input buffer must be large enough.
    //
    if (irpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(KSP_NODE)) {
        return KSFILTER_NODE;
    }

    //
    // Generally, the copy of the input buffer has this offset in the system buffer.
    //
    ULONG offset = (irpSp->Parameters.DeviceIoControl.OutputBufferLength + FILE_QUAD_ALIGNMENT) & ~FILE_QUAD_ALIGNMENT;

    switch (irpSp->Parameters.DeviceIoControl.IoControlCode)
    {
    case IOCTL_KS_METHOD:
        //
        // In this case, there is no copy of the output buffer.
        //
        if (KSMETHOD_TYPE_IRP_STORAGE(Irp) & KSMETHOD_TYPE_SOURCE) {
            offset = 0;
        }
        // Fall through.
    case IOCTL_KS_PROPERTY:
    case IOCTL_KS_ENABLE_EVENT:
        return PKSP_NODE(PUCHAR(Irp->AssociatedIrp.SystemBuffer) + offset)->NodeId;
    default:
        return KSFILTER_NODE;
    }
}

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA


KSDDKAPI
void
NTAPI
KsFilterRegisterPowerCallbacks(
    IN PKSFILTER Filter,
    IN PFNKSFILTERPOWER Sleep OPTIONAL,
    IN PFNKSFILTERPOWER Wake OPTIONAL
    )

/*++

Routine Description:

    This routine registers power managment callbacks.

Arguments:

    Filter -
        Contains a pointer to the filter for which callbacks are being 
        registered.

    Sleep -
        Contains an optional pointer to the sleep callback.

    Wake -
        Contains an optional pointer to the wake callback.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsFilterRegisterPowerCallbacks]"));

    PAGED_CODE();

    ASSERT(Filter);

    CKsFilter::FromStruct(Filter)->SetPowerCallbacks(Sleep,Wake);
}


KSDDKAPI
NTSTATUS
NTAPI
KsFilterCreatePinFactory (
    IN PKSFILTER Filter,
    IN const KSPIN_DESCRIPTOR_EX *const Descriptor,
    OUT PULONG AssignedId
)

/*++

Routine Description:

    Create a new pin factory on the specified filter.  

Arguments:

    Filter -
        The filter on which to create a new pin factory

    Descriptor -
        The pin descriptor describing the new pin factory

    AssignedId -
        The numeric Id assigned to the pin factory will be passed back
        through this.

Return Value:

    Success / failure as NTSTATUS

Notes:

    THE CALLER **MUST** HOLD THE FILTER CONTROL MUTEX PRIOR TO CALLING THIS
    ROUTINE.

--*/

{

    PAGED_CODE();

    ASSERT (Filter);
    ASSERT (Descriptor);
    ASSERT (AssignedId);

    return CKsFilter::FromStruct (Filter) ->
        AddPinFactory (Descriptor, AssignedId);

}


KSDDKAPI
NTSTATUS
NTAPI
KsFilterCreateNode (
    IN PKSFILTER Filter,
    IN const KSNODE_DESCRIPTOR *const Descriptor,
    OUT PULONG AssignedId
)

/*++

Routine Description:

    Add a topology node to the specified filter.  Note that this does not
    add any new topology connections.  It will only add the node.  Topology
    connections through the new node must be made via 
    KsFilterAddTopologyConnections.

Arguments:

    Filter -
        The filter on which to add a new topology node.

    Descriptor -
        A node descriptor describing the new topology node to be added.

    AssignedId -
        The numeric Id assigned to the topology node will be passed back here.

Return Value:

    Success / failure as NTSTATUS

Notes:

    THE CALLER **MUST** HOLD THE FILTER CONTROL MUTEX PRIOR TO CALLING THIS
    ROUTINE.

--*/

{

    ASSERT (Filter);
    ASSERT (Descriptor);
    ASSERT (AssignedId);

    return CKsFilter::FromStruct (Filter) ->
        AddNode (Descriptor, AssignedId);

}


KSDDKAPI
NTSTATUS
NTAPI
KsFilterAddTopologyConnections (
    IN PKSFILTER Filter,
    IN ULONG NewConnectionsCount,
    IN const KSTOPOLOGY_CONNECTION *const Connections
) 

/*++

Routine Description:

    Add a number of new topology connections to the specified filter.  Note
    that this does not add new nodes.  This only allows new connections to
    existing nodes.  Note that existing topology connections will be kept.

Arguments:

    Filter -
        The filter on which to add new topology connections

    NewConnectionsCount -
        Indicates how many new topology connections will be specified in
        Connections.

    Connections -
        Points to a table of KSTOPOLOGY_CONNECTIONs describing the new
        topology connections to be added to the filter.

Return Value:

    Success / failure as NTSTATUS.  Note: if a topology connection is invalid
    due to a non-existant node Id, etc...  STATUS_INVALID_PARAMETER will
    be passed back.


Notes:

    THE CALLER **MUST** HOLD THE FILTER CONTROL MUTEX PRIOR TO CALLING THIS
    ROUTINE.

--*/

{

    ASSERT (Filter);
    ASSERT (NewConnectionsCount > 0);
    ASSERT (Connections);

    return CKsFilter::FromStruct (Filter) ->
        AddTopologyConnections (NewConnectionsCount, Connections);

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\ks\shmisc.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    shmisc.cpp

Abstract:

    This module contains miscellaneous functions for the kernel streaming
    filter .

Author:

    Dale Sather  (DaleSat) 31-Jul-1998

--*/

#include "ksp.h"
#include <kcom.h>

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA


NTSTATUS
KspCreate(
    IN PIRP Irp,
    IN ULONG CreateItemsCount,
    IN const KSOBJECT_CREATE_ITEM* CreateItems OPTIONAL,
    IN const KSDISPATCH_TABLE* DispatchTable,
    IN BOOLEAN RefParent,
    IN PKSPX_EXT Ext,
    IN PLIST_ENTRY SiblingListHead,
    IN PDEVICE_OBJECT TargetDevice
    )

/*++

Routine Description:

    This routine performs generic processing relating to a create IRP.  If
    this function fails, it always cleans up by redispatching the IRP through
    the object's close dispatch.  The IRP will also get dispatched through
    the close dispatch if the client pends the IRP and fails it later.  This
    allows the caller (the specific object) to clean up as required.

Arguments:

    Irp -
        Contains a pointer to the create IRP.

    CreateItemsCount -
        Contains a count of the create items for the new object.  Zero is
        permitted.

    CreateItems -
        Contains a pointer to the array of create items for the new object.
        NULL is OK.

    DispatchTable -
        Contains a pointer to the IRP dispatch table for the new object.

    RefParent -
        Indicates whether the parent object should be referenced.  If this
        argument is TRUE and there is no parent object, this routine will
        ASSERT.

    Ext -
        Contains a pointer to a generic extended  structure.

    SiblingListHead -
        The head of the list to which this object should be added.  There is
        a list entry in *X for this purpose.

    TargetDevice -
        Contains a pointer to the optional target device.  This is associated
        with the created object for the purposes of stack depth calculation.

Return Value:

    STATUS_SUCCESS, STATUS_PENDING or some indication of failure.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KspCreate]"));

    PAGED_CODE();

    ASSERT(Irp);
    ASSERT(DispatchTable);
    ASSERT(Ext);
    ASSERT(SiblingListHead);

    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Optionally reference the parent file object.
    //
    if (RefParent) {
        ASSERT(irpSp->FileObject->RelatedFileObject);
        ObReferenceObject(irpSp->FileObject->RelatedFileObject);
    }

    //
    // Enlist in the sibling list. 
    //
    InsertTailList(SiblingListHead,&Ext->SiblingListEntry);
    Ext->SiblingListHead = SiblingListHead;

    //
    // Allocate the header if there isn't one already.
    //
    PKSIOBJECT_HEADER* fsContext = 
        (PKSIOBJECT_HEADER*)(irpSp->FileObject->FsContext);
    PKSIOBJECT_HEADER objectHeader;
    NTSTATUS status;
    if (fsContext && *fsContext) {
        //
        // There already is one.
        //
        objectHeader = *fsContext;
        status = STATUS_SUCCESS;
    } else {
        status =
            KsAllocateObjectHeader(
                (KSOBJECT_HEADER*)(&objectHeader),
                CreateItemsCount,
                const_cast<PKSOBJECT_CREATE_ITEM>(CreateItems),
                Irp,
                DispatchTable);

        if (NT_SUCCESS(status)) {
            if (! fsContext) {
                //
                // Use the header as the context.
                //
                fsContext = &objectHeader->Self;
                irpSp->FileObject->FsContext = fsContext;
            }
            *fsContext = objectHeader;
        } else {
        	//
        	// when alloc fails, make it
        	//
        	objectHeader = NULL;
		}
    }

    if (NT_SUCCESS(status)) {
        //
        // Install a pointer to the  structure in the object header.
        //
        objectHeader->Object = PVOID(Ext);

        //
        // Set the power dispatch function.
        //
#if 0
        KsSetPowerDispatch(objectHeader,KspDispatchPower,PVOID(Ext));
#endif
        //
        // Set the target device object if required.
        //
        if (TargetDevice) {
            KsSetTargetDeviceObject(objectHeader,TargetDevice);
        }
    }

    //
    // Give the client a chance.
    //
    if (NT_SUCCESS(status) &&
        Ext->Public.Descriptor->Dispatch &&
        Ext->Public.Descriptor->Dispatch->Create) {
        status = Ext->Public.Descriptor->Dispatch->Create(&Ext->Public,Irp);
    }

    if (! NT_SUCCESS(status) ) {
    	//
        // If we fail, we clean up by calling the close dispatch function.  It is
        // prepared to handle failed creates.  We set the IRP status to 
        // STATUS_MORE_PROCESSING_REQUIRED to let the close dispatch know we
        // don't want it to complete the IRP.  Eventually, the caller will put
        // the correct status in the IRP and complete it.
        //
        Irp->IoStatus.Status = STATUS_MORE_PROCESSING_REQUIRED;

        //
        // Unfortunately, if the object header creation failed, we cannot
        // close.  It is the caller's responsibility to cleanup anything
        // on this type of failure by detecting a non-successful status
        // code returned and a more processing required in the irp status
        //
        if (objectHeader != NULL)
            DispatchTable->Close(irpSp->DeviceObject,Irp);
    } 

    return status;
}


NTSTATUS
KspClose(
    IN PIRP Irp,
    IN PKSPX_EXT Ext,
    IN BOOLEAN DerefParent   
    )

/*++

Routine Description:

    This routine performs generic processing related to a close IRP.  It will
    also handle completion of failed create IRPs.

Arguments:

    Irp -
        Contains a pointer to the close IRP requiring processing.

    Ext -
        Contains a pointer to a generic extended  structure.

    DerefParent -
        Contains an indication of whether or not the parent object should be
        dereferenced.

Return Value:

    STATUS_SUCCESS or...

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KspClose]"));

    PAGED_CODE();

    ASSERT(Irp);

    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Take the control mutex if this is not a filter to synchronize access to
    // the object hierarchy.  If it is a filter, synchronize access to the
    // device-level hierarchy by taking the device mutex.
    //
    if (Irp->IoStatus.Status != STATUS_MORE_PROCESSING_REQUIRED) {
        if (! irpSp->FileObject->RelatedFileObject) {
            Ext->Device->AcquireDevice();
        }
        
        KeWaitForMutexObject (
            Ext->FilterControlMutex,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );

    }

    //
    // This function gets called synchronously with the dispatching of a close
    // IRP, asynchronously when the client is done with a close IRP it has
    // marked pending, synchronously with the failure of a create IRP, and 
    // asynchronously when the client is done with a create IRP it has marked
    // pending and subsequently failed.  The following test makes sure we are
    // doing the first of the four.
    //
    if ((irpSp->MajorFunction == IRP_MJ_CLOSE) && 
        ! (irpSp->Control & SL_PENDING_RETURNED)) {
        //
        // Free all remaining events.
        //
        KsFreeEventList(
            irpSp->FileObject,
            &Ext->EventList.ListEntry,
            KSEVENTS_SPINLOCK,
            &Ext->EventList.SpinLock);

        //
        // Give the client a chance to clean up.
        //
        if (Ext->Public.Descriptor->Dispatch &&
            Ext->Public.Descriptor->Dispatch->Close) {
            NTSTATUS status = Ext->Public.Descriptor->Dispatch->Close(&Ext->Public,Irp);

            //
            // If the client pends the IRP, we will finish cleaning up when
            // the IRP is redispatched for completion.
            //
            if (status == STATUS_PENDING) {
                if (irpSp->FileObject->RelatedFileObject) {

                    KeReleaseMutex (
                        Ext->FilterControlMutex,
                        FALSE
                        );
                } else {
                    Ext->Device->ReleaseDevice();
                }
                return status;
            } else {
                Irp->IoStatus.Status = status;
            }
        } else {
            //
            // Indicate a positive outcome.
            //
            Irp->IoStatus.Status = STATUS_SUCCESS;
        }
    }

    //
    // Defect from the sibling list.
    //
    RemoveEntryList(&Ext->SiblingListEntry);

    //
    // Release the control mutex if this is not a filter.  If it is a filter,
    // release the device mutex.
    //
    if (Irp->IoStatus.Status != STATUS_MORE_PROCESSING_REQUIRED) {

        KeReleaseMutex (
            Ext->FilterControlMutex,
            FALSE
            );
        if (! irpSp->FileObject->RelatedFileObject) {
            Ext->Device->ReleaseDevice();
        }
    }

    //
    // Free header and context if they still exist.
    //
    PKSIOBJECT_HEADER* fsContext = 
        (PKSIOBJECT_HEADER*)(irpSp->FileObject->FsContext);
    if (fsContext) {
        if (*fsContext) {
            if (fsContext == &(*fsContext)->Self) {
                //
                // The context is the header.  Just free it.
                //
                KsFreeObjectHeader(KSOBJECT_HEADER(*fsContext));
            } else {
                //
                // The context is the header.  Just free it.
                //
                KsFreeObjectHeader(KSOBJECT_HEADER(*fsContext));
                ExFreePool(fsContext);
            }
        } else {
            //
            // Just a context...no object header.
            //
            ExFreePool(fsContext);
        }
    }

    //
    // Optionally dereference the parent object.
    //
    if (DerefParent) {
        ASSERT(irpSp->FileObject->RelatedFileObject);
        ObDereferenceObject(irpSp->FileObject->RelatedFileObject);
    }

    return Irp->IoStatus.Status;
}


NTSTATUS
KspDispatchClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine dispatches close IRPs.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KspDispatchClose]"));

    PAGED_CODE();

    ASSERT(DeviceObject);
    ASSERT(Irp);

    //
    // Get a pointer to the extended public structure.
    //
    PKSPX_EXT ext = KspExtFromIrp(Irp);

    //
    // Call the helper.
    //
    NTSTATUS status = KspClose(Irp,ext,FALSE);
    
    if (status != STATUS_PENDING) {
        //
        // STATUS_MORE_PROCESSING_REQUIRED indicates we are using the close
        // dispatch to synchronously fail a create.  The create dispatch
        // will do the completion.
        //
        if (status != STATUS_MORE_PROCESSING_REQUIRED) {
            IoCompleteRequest(Irp,IO_NO_INCREMENT);
        }

        //
        // Delete the object.
        //
        ext->Interface->Release();
    }

    return status;
}


void
KsWorkSinkItemWorker(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine calls a worker function on a work sink interface.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsWorkSinkItemWorker]"));

    PAGED_CODE();

    ASSERT(Context);

    PIKSWORKSINK(Context)->Work();
}


NTSTATUS
KspRegisterDeviceInterfaces(
    IN ULONG CategoriesCount,
    IN const GUID* Categories,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN PUNICODE_STRING RefString,
    OUT PLIST_ENTRY ListEntry
    )

/*++

Routine Description:

    This routine registers device classes based on a list of GUIDs and
    creates a list of the registered classes which contains the generated
    symbolic link names.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KspRegisterDeviceInterfaces]"));

    PAGED_CODE();

    ASSERT(RefString);

    NTSTATUS status = STATUS_SUCCESS;

    for(; CategoriesCount--; Categories++) {
        //
        // Register the device interface.
        //
        UNICODE_STRING linkName;
        status = 
            IoRegisterDeviceInterface(
                PhysicalDeviceObject,
                Categories,
                RefString,
                &linkName);

        if (NT_SUCCESS(status)) {
            //
            // Save the symbolic link name in a list for cleanup.
            //
            PKSPDEVICECLASS deviceClass = 
                new(PagedPool,POOLTAG_DEVICEINTERFACE) KSPDEVICECLASS;

            if (deviceClass) {
                deviceClass->SymbolicLinkName = linkName;
                deviceClass->InterfaceClassGUID = Categories;

                InsertTailList(
                    ListEntry,
                    &deviceClass->ListEntry);
            } else {
                _DbgPrintF(DEBUGLVL_TERSE,("[KspRegisterDeviceInterfaces] failed to allocate device class list entry"));
                RtlFreeUnicodeString(&linkName);
                status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
        } else {
            _DbgPrintF(DEBUGLVL_TERSE,("[KspRegisterDeviceInterfaces] IoRegisterDeviceInterface failed (0x%08x)",status));
            break;
        }
    }

    return status;
}


NTSTATUS
KspSetDeviceInterfacesState(
    IN PLIST_ENTRY ListHead,
    IN BOOLEAN NewState
    )

/*++

Routine Description:

    This routine sets the state of device interfaces in a list.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KspSetDeviceInterfacesState]"));

    PAGED_CODE();

    ASSERT(ListHead);

    NTSTATUS status = STATUS_SUCCESS;

    for(PLIST_ENTRY listEntry = ListHead->Flink;
        listEntry != ListHead;
        listEntry = listEntry->Flink) {
        PKSPDEVICECLASS deviceClass = PKSPDEVICECLASS(listEntry);

        status = IoSetDeviceInterfaceState(
            &deviceClass->SymbolicLinkName,NewState);
    }

    return status;
}


void
KspFreeDeviceInterfaces(
    IN PLIST_ENTRY ListHead
    )

/*++

Routine Description:

    This routine frees a list of device interfaces.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KspFreeDeviceInterfaces]"));

    PAGED_CODE();

    ASSERT(ListHead);

    while (! IsListEmpty(ListHead)) {
        PKSPDEVICECLASS deviceClass =
            (PKSPDEVICECLASS) RemoveHeadList(ListHead);

        RtlFreeUnicodeString(&deviceClass->SymbolicLinkName);

        delete deviceClass;
    }
}

KSDDKAPI
void
NTAPI
KsAddEvent(
    IN PVOID Object,
    IN PKSEVENT_ENTRY EventEntry
    )

/*++

Routine Description:

    This routine adds events to an object's event list.

Arguments:

    Object -
        Contains a pointer to the object.

    EventEntry -
        Contains a pointer to the event to be added.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsAddEvent]"));

    PAGED_CODE();

    ASSERT(Object);
    ASSERT(EventEntry);

    PKSPX_EXT ext = CONTAINING_RECORD(Object,KSPX_EXT,Public);

    ExInterlockedInsertTailList(
        &ext->EventList.ListEntry,
        &EventEntry->ListEntry,
        &ext->EventList.SpinLock);
}


KSDDKAPI
NTSTATUS    
NTAPI
KsDefaultAddEventHandler(
    IN PIRP Irp,
    IN PKSEVENTDATA EventData,
    IN OUT PKSEVENT_ENTRY EventEntry
    )

/*++

Routine Description:

    This routine handles connection event 'add' requests.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::KsDefaultAddEventHandler]"));

    PAGED_CODE();

    ASSERT(Irp);
    ASSERT(EventData);
    ASSERT(EventEntry);

    //
    // Get a pointer to the target object.
    //
    PKSPX_EXT ext = KspExtFromIrp(Irp);

    ExInterlockedInsertTailList(
        &ext->EventList.ListEntry,
        &EventEntry->ListEntry,
        &ext->EventList.SpinLock);

    return STATUS_SUCCESS;
}    

#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif // ALLOC_PRAGMA


KSDDKAPI
void
NTAPI
KsGenerateEvents(
    IN PVOID Object,
    IN const GUID* EventSet OPTIONAL,
    IN ULONG EventId,
    IN ULONG DataSize,
    IN PVOID Data OPTIONAL,
    IN PFNKSGENERATEEVENTCALLBACK CallBack OPTIONAL,
    IN PVOID CallBackContext OPTIONAL
    )

/*++

Routine Description:

    This routine generates events.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsGenerateEvents]"));

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    ASSERT(Object);

    PKSPX_EXT ext = CONTAINING_RECORD(Object,KSPX_EXT,Public);
    GUID LocalEventSet;

    //
    // NOTE:
    //
    // If EventSet is specified, copy it onto the stack.  This field will
    // be accessed with a spinlock held and is frequently a GUID specified
    // through linkage with ksguid.lib.  These are all pageconst!
    //
    if (EventSet) 
    {
        LocalEventSet = *EventSet;
    }

    //
    // Generate all events of the indicated type.
    //
    if (! IsListEmpty(&ext->EventList.ListEntry))
    {
        KIRQL oldIrql;
        KeAcquireSpinLock(&ext->EventList.SpinLock,&oldIrql);

        for(PLIST_ENTRY listEntry = ext->EventList.ListEntry.Flink; 
            listEntry != &ext->EventList.ListEntry;) {
            PKSIEVENT_ENTRY eventEntry = 
                CONTAINING_RECORD(
                    listEntry,
                    KSIEVENT_ENTRY,
                    EventEntry.ListEntry);

            //
            // Get next before generating in case the event is removed.
            //
            listEntry = listEntry->Flink;
            
            //
            // Generate the event if...
            // ...id matches, and
            // ...no set was specified or the set matches, and
            // ...no callback was specified or the callback says ok
            //
            if ((eventEntry->Event.Id == EventId) &&
                ((! EventSet) ||
                 IsEqualGUIDAligned(
                    LocalEventSet,
                    eventEntry->Event.Set)) &&
                ((! CallBack) ||
                 CallBack(CallBackContext,&eventEntry->EventEntry))) {
                KsGenerateDataEvent(
                    &eventEntry->EventEntry,
                    DataSize,
                    Data);
            }
        }

        KeReleaseSpinLock(&ext->EventList.SpinLock,oldIrql);
    }
}    

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA

#if 0


NTSTATUS
KspDispatchPower(
    IN PVOID Context,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine dispatches power IRPs, passing control to the client's
    handler.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KspDispatchPower]"));

    PAGED_CODE();

    ASSERT(Context);
    ASSERT(Irp);

    //
    // Get a pointer to the extended  structure.
    //
    PKSPX_EXT ext = reinterpret_cast<PKSPX_EXT>(Context);

    //
    // If there's a client interface, call it.
    //
    NTSTATUS status = STATUS_SUCCESS;
    if (ext->Public.Descriptor->Dispatch &&
        ext->Public.Descriptor->Dispatch->Power) {
        status = ext->Public.Descriptor->Dispatch->Power(&ext->Public,Irp);
#if DBG
        if (status == STATUS_PENDING) {
            _DbgPrintF(DEBUGLVL_ERROR,("CLIENT BUG:  power management handler returned STATUS_PENDING"));
        }
#endif
    }

    return status;
}

#endif


void
KspStandardConnect(
    IN PIKSTRANSPORT NewTransport OPTIONAL,
    OUT PIKSTRANSPORT *OldTransport OPTIONAL,
    OUT PIKSTRANSPORT *BranchTransport OPTIONAL,
    IN KSPIN_DATAFLOW DataFlow,
    IN PIKSTRANSPORT ThisTransport,
    IN PIKSTRANSPORT* SourceTransport,
    IN PIKSTRANSPORT* SinkTransport
    )

/*++

Routine Description:

    This routine establishes a transport connection.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KspStandardConnect]"));

    PAGED_CODE();

    ASSERT(ThisTransport);
    ASSERT(SourceTransport);
    ASSERT(SinkTransport);

    if (BranchTransport) {
        *BranchTransport = NULL;
    }

    //
    // Make sure this object sticks around until we are done.
    //
    ThisTransport->AddRef();

    PIKSTRANSPORT* transport =
        (DataFlow & KSPIN_DATAFLOW_IN) ?
        SourceTransport :
        SinkTransport;

    //
    // Release the current source/sink.
    //
    if (*transport) {
        //
        // First disconnect the old back link.  If we are connecting a back
        // link for a new connection, we need to do this too.  If we are
        // clearing a back link (disconnecting), this request came from the
        // component we're connected to, so we don't bounce back again.
        //
        switch (DataFlow) {
        case KSPIN_DATAFLOW_IN:
            (*transport)->Connect(NULL,NULL,NULL,KSP_BACKCONNECT_OUT);
            break;

        case KSPIN_DATAFLOW_OUT:
            (*transport)->Connect(NULL,NULL,NULL,KSP_BACKCONNECT_IN);
            break;
        
        case KSP_BACKCONNECT_IN:
            if (NewTransport) {
                (*transport)->Connect(NULL,NULL,NULL,KSP_BACKCONNECT_OUT);
            }
            break;

        case KSP_BACKCONNECT_OUT:
            if (NewTransport) {
                (*transport)->Connect(NULL,NULL,NULL,KSP_BACKCONNECT_IN);
            }
            break;
        }

        //
        // Now release the old neighbor or hand it off to the caller.
        //
        if (OldTransport) {
            *OldTransport = *transport;
        } else {
            (*transport)->Release();
        }
    } else if (OldTransport) {
        *OldTransport = NULL;
    }

    //
    // Copy the new source/sink.
    //
    *transport = NewTransport;

    if (NewTransport) {
        //
        // Add a reference if necessary.
        //
        NewTransport->AddRef();

        //
        // Do the back connect if necessary.
        //
        switch (DataFlow) {
        case KSPIN_DATAFLOW_IN:
            NewTransport->Connect(ThisTransport,NULL,NULL,KSP_BACKCONNECT_OUT);
            break;

        case KSPIN_DATAFLOW_OUT:
            NewTransport->Connect(ThisTransport,NULL,NULL,KSP_BACKCONNECT_IN);
            break;
        }
    }

    //
    // Now this object may die if it has no references.
    //
    ThisTransport->Release();
}

#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif // ALLOC_PRAGMA


NTSTATUS
KspTransferKsIrp(
    IN PIKSTRANSPORT NewTransport,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine transfers a streaming IRP using the kernel streaming 
    transport.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KspTransferKsIrp]"));

    ASSERT(NewTransport);
    ASSERT(Irp);

    NTSTATUS status;
    while (NewTransport) {
        PIKSTRANSPORT nextTransport;
        status = NewTransport->TransferKsIrp(Irp,&nextTransport);

        ASSERT(NT_SUCCESS(status) || ! nextTransport);

        NewTransport = nextTransport;
    }

    return status;
}


void
KspDiscardKsIrp(
    IN PIKSTRANSPORT NewTransport,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine discards a streaming IRP using the kernel streaming 
    transport.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KspDiscardKsIrp]"));

    ASSERT(NewTransport);
    ASSERT(Irp);

    while (NewTransport) {
        PIKSTRANSPORT nextTransport;
        NewTransport->DiscardKsIrp(Irp,&nextTransport);
        NewTransport = nextTransport;
    }
}


KSDDKAPI
KSOBJECTTYPE
NTAPI
KsGetObjectTypeFromIrp(
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns the  object type from an IRP.

Arguments:

    Irp -
        Contains a pointer to an IRP which must have been sent to a file
        object corresponding to a  object.

Return Value:

    The type of the object.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsGetObjectTypeFromIrp]"));

    ASSERT(Irp);

    //
    // If FileObject == NULL, we assume that they've passed us a device level
    // Irp.
    //
    if (IoGetCurrentIrpStackLocation (Irp)->FileObject == NULL)
        return KsObjectTypeDevice;

    PKSPX_EXT ext = KspExtFromIrp(Irp);

    return KspExtFromIrp(Irp)->ObjectType;
}

KSDDKAPI
PVOID
NTAPI
KsGetObjectFromFileObject(
    IN PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This routine returns the KS object associated with a file object.

Arguments:

    FileObject -
        Contains a pointer to the file object.

Return Value:

    A pointer to the KS object.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsGetObjectFromFileObject]"));

    ASSERT(FileObject);

    return PVOID(&KspExtFromFileObject(FileObject)->Public);
}


KSDDKAPI
KSOBJECTTYPE
NTAPI
KsGetObjectTypeFromFileObject(
    IN PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This routine returns the KS object type associated with a file object.

Arguments:

    FileObject -
        Contains a pointer to the file object.

Return Value:

    The object type.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsGetObjectTypeFromFileObject]"));

    ASSERT(FileObject);

    return KspExtFromFileObject(FileObject)->ObjectType;
}


#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA


KSDDKAPI
void
NTAPI
KsAcquireControl(
    IN PVOID Object
    )

/*++

Routine Description:

    This routine acquires the control mutex for an object.

Arguments:

    Object -
        Contains a pointer to an object.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsAcquireControl]"));

    PAGED_CODE();

    ASSERT(Object);

    PKSPX_EXT ext = CONTAINING_RECORD(Object,KSPX_EXT,Public);

    KeWaitForMutexObject (
        ext->FilterControlMutex,
        Executive,
        KernelMode,
        FALSE,
        NULL
        );
}


KSDDKAPI
void
NTAPI
KsReleaseControl(
    IN PVOID Object
    )

/*++

Routine Description:

    This routine releases the control mutex for an object.

Arguments:

    Object -
        Contains a pointer to an object.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsReleaseControl]"));

    PAGED_CODE();

    ASSERT(Object);

    PKSPX_EXT ext = CONTAINING_RECORD(Object,KSPX_EXT,Public);

    KeReleaseMutex (
        ext->FilterControlMutex,
        FALSE
        );
}


KSDDKAPI
PKSDEVICE
NTAPI
KsGetDevice(
    IN PVOID Object
    )

/*++

Routine Description:

    This routine gets the device for any file object.

Arguments:

    Object -
        Contains a pointer to an object.

Return Value:

    A pointer to the device.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsGetDevice]"));

    PAGED_CODE();

    ASSERT(Object);

    PKSPX_EXT ext = CONTAINING_RECORD(Object,KSPX_EXT,Public);

    return ext->Device->GetStruct();
}


KSDDKAPI
PUNKNOWN
NTAPI
KsRegisterAggregatedClientUnknown(
    IN PVOID Object,
    IN PUNKNOWN ClientUnknown 
    )

/*++

Routine Description:

    This routine registers a client unknown for aggregation.

Arguments:

    Object -
        Contains a pointer to an object.

    ClientUnknown -
        Contains a pointer to the client's undelegated IUnknown 
        interface.

Return Value:

    The outer unknown for the KS object.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsRegisterAggregatedClientUnknown]"));

    PAGED_CODE();

    ASSERT(Object);
    ASSERT(ClientUnknown);

    PKSPX_EXT ext = CONTAINING_RECORD(Object,KSPX_EXT,Public);

    if (ext->AggregatedClientUnknown) {
        ext->AggregatedClientUnknown->Release();
    }
    ext->AggregatedClientUnknown = ClientUnknown;
    ext->AggregatedClientUnknown->AddRef();

    return ext->Interface;
}


KSDDKAPI
PUNKNOWN
NTAPI
KsGetOuterUnknown(
    IN PVOID Object
    )

/*++

Routine Description:

    This routine gets the outer unknown for aggregation.

Arguments:

    Object -
        Contains a pointer to an object.

Return Value:

    The outer unknown for the KS object.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsGetOuterUnknown]"));

    PAGED_CODE();

    ASSERT(Object);

    PKSPX_EXT ext = CONTAINING_RECORD(Object,KSPX_EXT,Public);

    return ext->Interface;
}

#if DBG

void
DbgPrintCircuit(
    IN PIKSTRANSPORT Transport,
    IN CCHAR Depth,
    IN CCHAR Direction
    )

/*++

Routine Description:

    This routine spews a transport circuit.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[DbgPrintCircuit]"));

    PAGED_CODE();

    ASSERT(Transport);

    KSPTRANSPORTCONFIG config;
    config.TransportType = 0;
    config.IrpDisposition = KSPIRPDISPOSITION_ROLLCALL;
    config.StackDepth = Depth;
    PIKSTRANSPORT transport = Transport;
    while (transport) {
        PIKSTRANSPORT next;
        PIKSTRANSPORT prev;

        transport->SetTransportConfig(&config,&next,&prev);

        if (Direction < 0) {
            transport = prev;
        } else {
            transport = next;
        }

        if (transport == Transport) {
            break;
        }
    }
}

#endif


NTSTATUS
KspInitializeDeviceBag(
    IN PKSIDEVICEBAG DeviceBag
    )

/*++

Routine Description:

    This routine initializes a device bag.

Arguments:

    DeviceBag -
        Contains a pointer to the bag to be initialized

Return Value:

    STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KspInitializeDeviceBag]"));

    PAGED_CODE();

    ASSERT(DeviceBag);

    //
    // Create and initialize the hash table.
    //
    KeInitializeMutex(&DeviceBag->Mutex, 0);

    DeviceBag->HashTableEntryCount = DEVICEBAGHASHTABLE_INITIALSIZE;
    DeviceBag->HashMask = DEVICEBAGHASHTABLE_INITIALMASK;
    DeviceBag->HashTable =
        new(PagedPool,POOLTAG_DEVICEBAGHASHTABLE) 
            LIST_ENTRY[DEVICEBAGHASHTABLE_INITIALSIZE];

    if (DeviceBag->HashTable) {
        PLIST_ENTRY entry = DeviceBag->HashTable;
        for (ULONG count = DEVICEBAGHASHTABLE_INITIALSIZE; count--; entry++) {
            InitializeListHead(entry);
        }
        return STATUS_SUCCESS;
    } else {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
}


void
KspTerminateDeviceBag(
    IN PKSIDEVICEBAG DeviceBag
    )

/*++

Routine Description:

    This routine terminates a device bag.

Arguments:

    DeviceBag -
        Contains a pointer to the bag to be terminated.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KspTerminateDeviceBag]"));

    PAGED_CODE();

    ASSERT(DeviceBag);

    if (DeviceBag->HashTable) {
#if DBG
        PLIST_ENTRY entry = DeviceBag->HashTable;
        for (ULONG count = DEVICEBAGHASHTABLE_INITIALSIZE; count--; entry++) {
            ASSERT(IsListEmpty(entry));
        }
#endif
        delete [] DeviceBag->HashTable;
        DeviceBag->HashTable = NULL;
    }
}


ULONG
KspRemoveObjectBagEntry(
    IN PKSIOBJECTBAG ObjectBag,
    IN PKSIOBJECTBAG_ENTRY Entry,
    IN BOOLEAN Free
    )

/*++

Routine Description:

    This routine removes an entry from an object bag, optionally freeing the
    item.

Arguments:

    ObjectBag -
        Contains a pointer to the bag.

    Entry -
        Contains a pointer to the entry to be removed.

    Free -
        Contains an indication of whether the item is to be freed if its
        reference count reaches zero as a result of the function call.

Return Value:

    The number of references to the item prior to the call to this function.
    If the return value is 1, there are no more references to the item when
    the function call completes.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KspRemoveObjectBagEntry]"));

    PAGED_CODE();

    ASSERT(ObjectBag);
    ASSERT(Entry);

    PKSIDEVICEBAG_ENTRY deviceBagEntry = Entry->DeviceBagEntry;
    RemoveEntryList (&Entry -> ListEntry);

    delete Entry;

    return KspReleaseDeviceBagEntry(ObjectBag->DeviceBag,deviceBagEntry,Free);
}


void
KspTerminateObjectBag(
    IN PKSIOBJECTBAG ObjectBag
    )

/*++

Routine Description:

    This routine terminates an object bag.

Arguments:

    ObjectBag -
        Contains a pointer to the bag.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KspTerminateObjectBag]"));

    PAGED_CODE();

    ASSERT(ObjectBag);

    if (ObjectBag->HashTable) {
        PLIST_ENTRY HashChain = ObjectBag->HashTable;
        for (ULONG count = ObjectBag->HashTableEntryCount; count--; 
            HashChain++) {

            while (!IsListEmpty (HashChain)) {

                PKSIOBJECTBAG_ENTRY BagEntry = (PKSIOBJECTBAG_ENTRY)
                    CONTAINING_RECORD (
                        HashChain->Flink, 
                        KSIOBJECTBAG_ENTRY, 
                        ListEntry
                        );

                KspRemoveObjectBagEntry(ObjectBag,BagEntry,TRUE);

            }
        }
        delete [] ObjectBag->HashTable;
    }
}


PKSIDEVICEBAG_ENTRY
KspAcquireDeviceBagEntryForItem(
    IN PKSIDEVICEBAG DeviceBag,
    IN PVOID Item,
    IN PFNKSFREE Free OPTIONAL
    )

/*++

Routine Description:

    This routine acquires an entry from a device bag.

Arguments:

    DeviceBag -
        Contains a pointer to the bag from which the entry is to be acquired.

    Item -
        Contains a pointer to the item.

    Free -
        Contains an optional pointer to a function to be used to free
        the item.  If this argument is NULL, the item is freed by
        passing it to ExFreePool.

Return Value:

    The device entry or NULL if memory could not be allocated for the item.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KspAcquireDeviceBagEntryForItem]"));

    PAGED_CODE();

    ASSERT(DeviceBag);
    ASSERT(Item);

    KeWaitForMutexObject (
        &DeviceBag->Mutex,
        Executive,
        KernelMode,
        FALSE,
        NULL
        );

    //
    // Look for the entry in the hash table.
    //
    PLIST_ENTRY listHead = 
        &DeviceBag->HashTable[KspDeviceBagHash(DeviceBag,Item)];
    PKSIDEVICEBAG_ENTRY deviceEntry = NULL;
    for(PLIST_ENTRY listEntry = listHead->Flink;
        listEntry != listHead;
        listEntry = listEntry->Flink) {
        PKSIDEVICEBAG_ENTRY entry =
            CONTAINING_RECORD(listEntry,KSIDEVICEBAG_ENTRY,ListEntry);

        if (entry->Item == Item) {
            _DbgPrintF(DEBUGLVL_VERBOSE,("[KspAcquireDeviceBagEntryForItem] new reference to old item %p",Item));
            entry->ReferenceCount++;
            deviceEntry = entry;
            break;
        }
    }

    if (! deviceEntry) {
        //
        // Allocate a new entry and add it to the list.
        //
        deviceEntry = 
            new(PagedPool,POOLTAG_DEVICEBAGENTRY) KSIDEVICEBAG_ENTRY;

        if (deviceEntry) {
            _DbgPrintF(DEBUGLVL_VERBOSE,("[KspAcquireDeviceBagEntryForItem] new item %p",Item));
            InsertHeadList(listHead,&deviceEntry->ListEntry);
            deviceEntry->Item = Item;
            deviceEntry->Free = Free;
            deviceEntry->ReferenceCount = 1;
        }
    }

    KeReleaseMutex (
        &DeviceBag->Mutex,
        FALSE
        );

    return deviceEntry;
}


ULONG
KspReleaseDeviceBagEntry(
    IN PKSIDEVICEBAG DeviceBag,
    IN PKSIDEVICEBAG_ENTRY DeviceBagEntry,
    IN BOOLEAN Free
    )

/*++

Routine Description:

    This routine acquires an entry from a device bag.

Arguments:

    DeviceBag -
        Contains a pointer to the bag from which the entry is to be released.

    DeviceBagEntry -
        Contains a pointer to the entry to be released.

    Free -
        Contains an indication of whether the item should be freed if it has
        no other references.

Return Value:

    The number of references to the entry prior to release.  A reference count
    of 1 indicates that the call to this function released the last reference 
    to the entry.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KspReleaseDeviceBagEntry]"));

    PAGED_CODE();

    ASSERT(DeviceBag);
    ASSERT(DeviceBagEntry);

    KeWaitForMutexObject (
        &DeviceBag->Mutex,
        Executive,
        KernelMode,
        FALSE,
        NULL
        );

    ULONG referenceCount = DeviceBagEntry->ReferenceCount--;

    if (referenceCount == 1) {
        if (Free) {
            _DbgPrintF(DEBUGLVL_VERBOSE,("[KspReleaseDeviceBagEntry] freeing %p",DeviceBagEntry->Item));
            if (DeviceBagEntry->Free) {
                DeviceBagEntry->Free(DeviceBagEntry->Item);
            } else {
                ExFreePool(DeviceBagEntry->Item);
            }

            RemoveEntryList(&DeviceBagEntry->ListEntry);
            delete DeviceBagEntry;
        }
    }

    KeReleaseMutex (
        &DeviceBag->Mutex,
        FALSE
        );

    return referenceCount;
}


PKSIOBJECTBAG_ENTRY
KspAddDeviceBagEntryToObjectBag(
    IN PKSIOBJECTBAG ObjectBag,
    IN PKSIDEVICEBAG_ENTRY DeviceBagEntry
    )

/*++

Routine Description:

    This routine adds a device bag entry to an object bag.

Arguments:

    ObjectBag -
        Contains a pointer to the bag.

    DeviceBagEntry -
        Contains a pointer to the device bag entry to be added.

Return Value:

    The new object bag entry or NULL if memory could not be allocated to
    complete the operation.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KspAddDeviceBagEntryToObjectBag]"));

    PAGED_CODE();

    ASSERT(ObjectBag);
    ASSERT(DeviceBagEntry);

    //
    // Allocate a new entry and add it to the list.
    //
    PKSIOBJECTBAG_ENTRY objectEntry = 
        new(PagedPool,POOLTAG_OBJECTBAGENTRY) KSIOBJECTBAG_ENTRY;

    if (! objectEntry) {
        return NULL;
    }

    if (! ObjectBag->HashTable) {
        ObjectBag->HashTable =
            new(PagedPool,POOLTAG_OBJECTBAGHASHTABLE) 
                LIST_ENTRY[OBJECTBAGHASHTABLE_INITIALSIZE];

        if (! ObjectBag->HashTable) {
            delete objectEntry;
            return NULL;
        } else {
            PLIST_ENTRY HashChain = ObjectBag->HashTable;

            for (ULONG i = OBJECTBAGHASHTABLE_INITIALSIZE; i; 
                i--, HashChain++) {

                InitializeListHead (HashChain);

            }
        }
    }

    //
    // Find the hash table entry.
    //
    PLIST_ENTRY HashChain =
        &(ObjectBag->
            HashTable[KspObjectBagHash(ObjectBag,DeviceBagEntry->Item)]);

    objectEntry->DeviceBagEntry = DeviceBagEntry;
    InsertHeadList (HashChain, &(objectEntry->ListEntry));

    return objectEntry;
}


KSDDKAPI
NTSTATUS
NTAPI
KsAddItemToObjectBag(
    IN KSOBJECT_BAG ObjectBag,
    IN PVOID Item,
    IN PFNKSFREE Free OPTIONAL
    )

/*++

Routine Description:

    This routine adds an item to an object bag.

Arguments:

    ObjectBag -
        Contains a pointer to the bag to which the item is to be added.

    Item -
        Contains a pointer to the item to be added.

    Free -
        Contains an optional pointer to a function to be used to free
        the item.  If this argument is NULL, the item is freed by
        passing it to ExFreePool.

Return Value:

    STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsAddItemToObjectBag]"));

    PAGED_CODE();

    ASSERT(ObjectBag);
    ASSERT(Item);

    _DbgPrintF(DEBUGLVL_VERBOSE,("KsAddItemToObjectBag  %p item=%p",ObjectBag,Item));

    PKSIOBJECTBAG bag = reinterpret_cast<PKSIOBJECTBAG>(ObjectBag);
    NTSTATUS Status = STATUS_SUCCESS;

    KeWaitForSingleObject (
        bag->Mutex,
        Executive,
        KernelMode,
        FALSE,
        NULL
        );

    PKSIDEVICEBAG_ENTRY deviceBagEntry = 
        KspAcquireDeviceBagEntryForItem(bag->DeviceBag,Item,Free);

    if (! deviceBagEntry) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
    else if (! KspAddDeviceBagEntryToObjectBag(bag,deviceBagEntry)) {
        KspReleaseDeviceBagEntry(bag->DeviceBag,deviceBagEntry,FALSE);
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    KeReleaseMutex (
        bag->Mutex,
        FALSE
        );

    return Status;
}


PKSIOBJECTBAG_ENTRY
KspFindObjectBagEntry(
    IN PKSIOBJECTBAG ObjectBag,
    IN PVOID Item
    )

/*++

Routine Description:

    This routine finds an entry in an object bag.

Arguments:

    ObjectBag -
        Contains a pointer to the bag.

    Item -
        Contains a pointer to the item to be found.

Return Value:

    A pointer to the entry, or NULL if the item was not found in
    the bag.  This value, when not NULL, is suitable for submission to
    KspRemoveObjectBagEntry.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KspFindObjectBagEntry]"));

    PAGED_CODE();

    ASSERT(ObjectBag);
    ASSERT(Item);

    if (ObjectBag->HashTable) {
        //
        // Start at the hash table entry.
        //
        PLIST_ENTRY HashChain =
            &(ObjectBag->HashTable[KspObjectBagHash(ObjectBag,Item)]);

        //
        // Find the end of the list, bailing out if the item is found.
        //
        for (PLIST_ENTRY Entry = HashChain -> Flink;
            Entry != HashChain;
            Entry = Entry -> Flink) {

            PKSIOBJECTBAG_ENTRY BagEntry = (PKSIOBJECTBAG_ENTRY)
                CONTAINING_RECORD (
                    Entry,
                    KSIOBJECTBAG_ENTRY,
                    ListEntry
                    );

            if (BagEntry -> DeviceBagEntry -> Item == Item) {
                return BagEntry;
            }
        }
    }

    return NULL;
}


KSDDKAPI
ULONG
NTAPI
KsRemoveItemFromObjectBag(
    IN KSOBJECT_BAG ObjectBag,
    IN PVOID Item,
    IN BOOLEAN Free
    )

/*++

Routine Description:

    This routine removes an item from an object bag.

Arguments:

    ObjectBag -
        Contains a pointer to the bag from which the item is to be removed.

    Item -
        Contains a pointer to the item to be removed.

    Free -
        Contains an indication of whether the item should be freed if it has
        no other references.

Return Value:

    The number of references to the item prior to removal.  A reference count
    of 0 indicates that the item was not in the bag.  A reference count of 1
    indicates that the call to this function removed the last reference to
    item, and there is no longer any object bag associated with the device
    bag which contains an entry for the item.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsRemoveItemFromObjectBag]"));

    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_VERBOSE,("KsRemoveItemFromObjectBag  %p item=%p",ObjectBag,Item));

    ASSERT(ObjectBag);
    ASSERT(Item);

    PKSIOBJECTBAG bag = reinterpret_cast<PKSIOBJECTBAG>(ObjectBag);
    ULONG RefCount = 0;

    KeWaitForSingleObject (
        bag->Mutex,
        Executive,
        KernelMode,
        FALSE,
        NULL
        );

    PKSIOBJECTBAG_ENTRY Entry = KspFindObjectBagEntry(bag,Item);

    if (Entry) {
        RefCount = KspRemoveObjectBagEntry(bag,Entry,Free);
    }

    KeReleaseMutex (
        bag->Mutex,
        FALSE
        );

    return RefCount;
}


KSDDKAPI
NTSTATUS
NTAPI
KsCopyObjectBagItems(
    IN KSOBJECT_BAG ObjectBagDestination,
    IN KSOBJECT_BAG ObjectBagSource
    )

/*++

Routine Description:

    This routine copies all the items in a bag into another bag.

Arguments:

    ObjectBagDestination -
        Contains the bag into which items will be copied.

    ObjectBagSource -
        Contains the bag from which items will be copied.

Return Value:

    Status.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsCopyObjectBagItems]"));
    _DbgPrintF(DEBUGLVL_VERBOSE,("KsCopyObjectBagItems  to %p from %p",ObjectBagDestination,ObjectBagSource));

    PAGED_CODE();

    ASSERT(ObjectBagDestination);
    ASSERT(ObjectBagSource);

    PKSIOBJECTBAG bagSource = reinterpret_cast<PKSIOBJECTBAG>(ObjectBagSource);
    PKSIOBJECTBAG bagDestination = 
        reinterpret_cast<PKSIOBJECTBAG>(ObjectBagDestination);

    NTSTATUS status = STATUS_SUCCESS;
    PKMUTEX FirstMutex, SecondMutex;

    //
    // FULLMUTEX:
    //
    // Guarantee that the order we grab mutexes is such that any bag with
    // MutexOrder marked as TRUE has its mutex taken before any bag with
    // MutexOrder marked as FALSE.
    //
    if (bagSource->MutexOrder) {
        FirstMutex = bagSource->Mutex;
        SecondMutex = bagDestination->Mutex;	
    }
    else {
        FirstMutex = bagDestination->Mutex;
        SecondMutex = bagSource->Mutex;
    }

    KeWaitForSingleObject (
        FirstMutex,
        Executive,
        KernelMode,
        FALSE,
        NULL
        );

    if (FirstMutex != SecondMutex) {
        KeWaitForSingleObject (
            SecondMutex,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );
    }

    if (bagSource->HashTable) {
        PLIST_ENTRY HashChain = bagSource->HashTable;
        for (ULONG count = bagSource->HashTableEntryCount; count--; 
            HashChain++) {

            for (PLIST_ENTRY Entry = HashChain -> Flink;
                Entry != HashChain;
                Entry = Entry -> Flink) {

                PKSIOBJECTBAG_ENTRY BagEntry = (PKSIOBJECTBAG_ENTRY)
                    CONTAINING_RECORD (
                        Entry,
                        KSIOBJECTBAG_ENTRY,
                        ListEntry
                        );
            
                status = 
                    KsAddItemToObjectBag(
                        ObjectBagDestination,
                        BagEntry->DeviceBagEntry->Item,
                        BagEntry->DeviceBagEntry->Free
                        );

                if (! NT_SUCCESS(status)) {
                    break;
                }
            }
        }
    }

    if (FirstMutex != SecondMutex) {
        KeReleaseMutex (
            SecondMutex,
            FALSE
            );
    }

    KeReleaseMutex (
        FirstMutex,
        FALSE
        );
        

    return STATUS_SUCCESS;
}


KSDDKAPI
NTSTATUS
NTAPI
_KsEdit(
    IN KSOBJECT_BAG ObjectBag,
    IN OUT PVOID* PointerToPointerToItem,
    IN ULONG NewSize,
    IN ULONG OldSize,
    IN ULONG Tag
    )

/*++

Routine Description:

    This routine insures that an item to be edited is in a specified
    object bag.

Arguments:

    ObjectBag -
        Contains a pointer to the bag in which the item to be edited must be
        included.

    PointerToPointerToItem -
        Contains a pointer to a pointer to the item to be edited.  If the item
        is not in the bag, OldSize is less than NewSize, or the item is NULL, 
        *PointerToPointer is modified to point to a new item which is in the 
        bag and is NewSize bytes long.

    NewSize -
        Contains the minimum size of the item to be edited.  The item will be
        replaced with a new copy if OldSize this size.

    OldSize -
        Contains the size of the old item.  This is used to determine how much
        data to copy from an old item not in the bag to a new replacement item.

    Tag -
        Contains the tag to use for new allocations.

Return Value:

    STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[_KsEdit]"));

    PAGED_CODE();

    ASSERT(ObjectBag);
    ASSERT(PointerToPointerToItem);
    ASSERT(NewSize);

    PKSIOBJECTBAG bag = reinterpret_cast<PKSIOBJECTBAG>(ObjectBag);
    NTSTATUS Status = STATUS_SUCCESS;

    KeWaitForSingleObject (
        bag->Mutex,
        Executive,
        KernelMode,
        FALSE,
        NULL
        );

    //
    // Find the item in the object bag.
    //
    PKSIOBJECTBAG_ENTRY entry;
    if (*PointerToPointerToItem) {
        entry = KspFindObjectBagEntry(bag,*PointerToPointerToItem);
    } else {
        entry = NULL;
    }

    if ((! entry) || (NewSize > OldSize)) {
        //
        // Either the item is not in the bag or it is too small.
        //
        PVOID newItem = ExAllocatePoolWithTag(PagedPool,NewSize,Tag);

        if (! newItem) {
            //
            // Failed to allocate.
            //
            Status = STATUS_INSUFFICIENT_RESOURCES;
        } else if (! NT_SUCCESS(KsAddItemToObjectBag(ObjectBag,newItem,NULL))) {
            //
            // Failed to attach.
            //
            ExFreePool(newItem);
            Status = STATUS_INSUFFICIENT_RESOURCES;
        } else {
            if (*PointerToPointerToItem) {
                //
                // Copy the old item and zero any growth.
                //
                if (NewSize > OldSize) {
                    RtlCopyMemory(newItem,*PointerToPointerToItem,OldSize);
                    RtlZeroMemory(PUCHAR(newItem) + OldSize,NewSize - OldSize);
                } else {
                    RtlCopyMemory(newItem,*PointerToPointerToItem,NewSize);
                }

                //
                // Detach the old item from the bag.
                //
                if (entry) {
                    KspRemoveObjectBagEntry(bag,entry,TRUE);
                }
            } else {
                //
                // There is no old item.  Zero the new item.
                //
                RtlZeroMemory(newItem,NewSize);
            }

            //
            // Install the new item.
            //
            *PointerToPointerToItem = newItem;
        }
    }

    KeReleaseMutex (
        bag->Mutex,
        FALSE
        );

    return Status;
}


KSDDKAPI
PVOID
NTAPI
KsGetParent(
    IN PVOID Object
    )

/*++

Routine Description:

    This routine obtains an object's parent object.

Arguments:

    Object -
        Points to the object structure.

Return Value:

    A pointer to the parent object structure.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsGetParent]"));

    PAGED_CODE();

    ASSERT(Object);

    PKSPX_EXT ext = CONTAINING_RECORD(Object,KSPX_EXT,Public);

    if (ext->Parent) {
        return &ext->Parent->Public;
    } else {
        return NULL;
    }
}


KSDDKAPI
PKSFILTER 
NTAPI
KsPinGetParentFilter(
    IN PKSPIN Pin
    )

/*++

Routine Description:

    This routine obtains a filter given a pin.

Arguments:

    Pin -
        Points to the pin structure.

Return Value:

    A pointer to the parent filter structure.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsGetParentFilter]"));

    PAGED_CODE();

    ASSERT(Pin);

    return (PKSFILTER) KsGetParent((PVOID) Pin);
}


KSDDKAPI
PVOID
NTAPI
KsGetFirstChild(
    IN PVOID Object
    )

/*++

Routine Description:

    This routine obtains an object's first child object.

Arguments:

    Object -
        Points to the object structure.

Return Value:

    A pointer to the first child object.  NULL is returned if there are no
    child objects.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsGetFirstChild]"));

    PAGED_CODE();

    ASSERT(Object);

    PKSPX_EXT ext = CONTAINING_RECORD(Object,KSPX_EXT,Public);

    //
    // In debug, ensure that the caller has the proper synchronization objects
    // held.
    //
    // NOTE: we shouldn't be called for pins anyway.
    //
#if DBG
    if (ext -> ObjectType == KsObjectTypeDevice ||
        ext -> ObjectType == KsObjectTypeFilterFactory) {
        if (!KspIsDeviceMutexAcquired (ext->Device)) {
            _DbgPrintF(DEBUGLVL_ERROR,("CLIENT BUG:  unsychronized access to object hierarchy - need to acquire device mutex"));
        }
    }
#endif // DBG

    if (IsListEmpty(&ext->ChildList)) {
        return NULL;
    } else {
        return 
            &CONTAINING_RECORD(ext->ChildList.Flink,KSPX_EXT,SiblingListEntry)->
                Public;
    }
}


KSDDKAPI
PVOID
NTAPI
KsGetNextSibling(
    IN PVOID Object
    )

/*++

Routine Description:

    This routine obtains an object's next sibling object.

Arguments:

    Object -
        Points to the object structure.

Return Value:

    A pointer to the next sibling object.  NULL is returned if there is
    no next sibling object.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsGetNextSibling]"));

    PAGED_CODE();

    ASSERT(Object);

    PKSPX_EXT ext = CONTAINING_RECORD(Object,KSPX_EXT,Public);

    //
    // In debug, ensure that the caller has the proper synchronization objects
    // held.
    //
#if DBG
    if (ext -> ObjectType == KsObjectTypePin) {
        if (!KspMutexIsAcquired (ext->FilterControlMutex)) {
            _DbgPrintF(DEBUGLVL_ERROR,("CLIENT BUG:  unsychronized access to object hierarchy - need to acquire control mutex"));
        }
    } else {
        if (!KspIsDeviceMutexAcquired (ext->Device)) {
            _DbgPrintF(DEBUGLVL_ERROR,("CLIENT BUG:  unsychronized access to object hierarchy - need to acquire device mutex"));
        }
    }
#endif // DBG

    if (ext->SiblingListEntry.Flink == ext->SiblingListHead) {
        return NULL;
    } else {
        return 
            &CONTAINING_RECORD(ext->SiblingListEntry.Flink,KSPX_EXT,SiblingListEntry)->
                Public;
    }
}




KSDDKAPI
PKSPIN 
NTAPI
KsPinGetNextSiblingPin(
    IN PKSPIN Pin
    )

/*++

Routine Description:

    This routine obtains a pins's next sibling object.

Arguments:

    Pin -
        Points to the Pin structure.

Return Value:

    A pointer to the next sibling object.  NULL is returned if there is
    no next sibling object.

--*/

{
   _DbgPrintF(DEBUGLVL_BLAB,("[KsPinGetNextSiblingPin]"));

   PAGED_CODE();

   ASSERT(Pin);

    return (PKSPIN) KsGetNextSibling((PVOID) Pin);
}

//
// CKsFileObjectThunk is the implementation of the thunk object which 
// exposes interfaces for PFILE_OBJECTs..
//
class CKsFileObjectThunk:
    public IKsControl,
    public CBaseUnknown
{
private:
    PFILE_OBJECT m_FileObject;

public:
    DEFINE_STD_UNKNOWN();
    IMP_IKsControl;

    CKsFileObjectThunk(PUNKNOWN OuterUnknown):
        CBaseUnknown(OuterUnknown) 
    {
    }
    ~CKsFileObjectThunk();

    NTSTATUS
    Init(
        IN PFILE_OBJECT FileObject
        );
};

IMPLEMENT_STD_UNKNOWN(CKsFileObjectThunk)


NTSTATUS
KspCreateFileObjectThunk(
    OUT PUNKNOWN* Unknown,
    IN PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This routine creates a new control file object object.

Arguments:

    Unknown -
        Contains a pointer to the location at which the IUnknown interface
        for the object will be deposited.

    FileObject -
        Contains a pointer to the file object to be thunked.

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KspCreateFileObjectThunk]"));

    PAGED_CODE();

    ASSERT(Unknown);
    ASSERT(FileObject);

    CKsFileObjectThunk *object =
        new(PagedPool,POOLTAG_FILEOBJECTTHUNK) CKsFileObjectThunk(NULL);

    NTSTATUS status;
    if (object) {
        object->AddRef();
        status = object->Init(FileObject);

        if (NT_SUCCESS(status)) {
            *Unknown = static_cast<PUNKNOWN>(object);
        } else {
            object->Release();
        }
    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return status;
}


CKsFileObjectThunk::
~CKsFileObjectThunk(
    void
    )

/*++

Routine Description:

    This routine destructs a control file object object.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsFileObjectThunk::~CKsFileObjectThunk]"));

    PAGED_CODE();

    if (m_FileObject) {
        ObDereferenceObject(m_FileObject);
    }
}


STDMETHODIMP_(NTSTATUS)
CKsFileObjectThunk::
NonDelegatedQueryInterface(
    IN REFIID InterfaceId,
    OUT PVOID* InterfacePointer
    )

/*++

Routine Description:

    This routine obtains an interface to a control file object object.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsFileObjectThunk::NonDelegatedQueryInterface]"));

    PAGED_CODE();

    ASSERT(InterfacePointer);

    NTSTATUS status = STATUS_SUCCESS;

    if (IsEqualGUIDAligned(InterfaceId,__uuidof(IKsControl))) {
        *InterfacePointer = reinterpret_cast<PVOID>(static_cast<PIKSCONTROL>(this));
        AddRef();
    } else {
        status = CBaseUnknown::NonDelegatedQueryInterface(InterfaceId,InterfacePointer);
    }

    return status;
}


NTSTATUS
CKsFileObjectThunk::
Init(
    IN PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This routine initializes a control file object object.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsFileObjectThunk::Init]"));

    PAGED_CODE();

    ASSERT(FileObject);
    ASSERT(! m_FileObject);

    m_FileObject = FileObject;
    ObReferenceObject(m_FileObject);

    return STATUS_SUCCESS;
}


STDMETHODIMP_(NTSTATUS)
CKsFileObjectThunk::
KsProperty(
    IN PKSPROPERTY Property,
    IN ULONG PropertyLength,
    IN OUT LPVOID PropertyData,
    IN ULONG DataLength,
    OUT ULONG* BytesReturned
    )

/*++

Routine Description:

    This routine sends a property request to the file object.

Arguments:

Return Value:

    Status.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsFileObjectThunk::KsProperty]"));

    PAGED_CODE();

    ASSERT(Property);
    ASSERT(PropertyLength >= sizeof(*Property));
    ASSERT(PropertyData || (DataLength == 0));
    ASSERT(BytesReturned);
    ASSERT(m_FileObject);

    return
        KsSynchronousIoControlDevice(
            m_FileObject,
            KernelMode,
            IOCTL_KS_PROPERTY,
            Property,
            PropertyLength,
            PropertyData,
            DataLength,
            BytesReturned);
}


STDMETHODIMP_(NTSTATUS)
CKsFileObjectThunk::
KsMethod(
    IN PKSMETHOD Method,
    IN ULONG MethodLength,
    IN OUT LPVOID MethodData,
    IN ULONG DataLength,
    OUT ULONG* BytesReturned
    )

/*++

Routine Description:

    This routine sends a method request to the file object.

Arguments:

Return Value:

    Status.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsFileObjectThunk::KsMethod]"));

    PAGED_CODE();

    ASSERT(Method);
    ASSERT(MethodLength >= sizeof(*Method));
    ASSERT(MethodData || (DataLength == 0));
    ASSERT(BytesReturned);
    ASSERT(m_FileObject);

    return
        KsSynchronousIoControlDevice(
            m_FileObject,
            KernelMode,
            IOCTL_KS_METHOD,
            Method,
            MethodLength,
            MethodData,
            DataLength,
            BytesReturned);
}


STDMETHODIMP_(NTSTATUS)
CKsFileObjectThunk::
KsEvent(
    IN PKSEVENT Event OPTIONAL,
    IN ULONG EventLength,
    IN OUT LPVOID EventData,
    IN ULONG DataLength,
    OUT ULONG* BytesReturned
    )

/*++

Routine Description:

    This routine sends an event request to the file object.

Arguments:

Return Value:

    Status.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsFileObjectThunk::KsEvent]"));

    PAGED_CODE();

    ASSERT(Event);
    ASSERT(EventLength >= sizeof(*Event));
    ASSERT(EventData || (DataLength == 0));
    ASSERT(BytesReturned);
    ASSERT(m_FileObject);

    //
    // If an event structure is present, this must either be an Enable or
    // or a Support query.  Otherwise this must be a Disable.
    //
    if (EventLength) {
        return 
            KsSynchronousIoControlDevice(
                m_FileObject,
                KernelMode,
                IOCTL_KS_ENABLE_EVENT,
                Event,
                EventLength,
                EventData,
                DataLength,
                BytesReturned);
    } else {
        return 
            KsSynchronousIoControlDevice(
                m_FileObject,
                KernelMode,
                IOCTL_KS_DISABLE_EVENT,
                EventData,
                DataLength,
                NULL,
                0,
                BytesReturned);
    }
}

#define FCC(ch4) ((((DWORD)(ch4) & 0xFF) << 24) |     \
                  (((DWORD)(ch4) & 0xFF00) << 8) |    \
                  (((DWORD)(ch4) & 0xFF0000) >> 8) |  \
                  (((DWORD)(ch4) & 0xFF000000) >> 24))

// OK to have zero instances of pin In this case you will have to
// Create a pin to have even one instance
#define REG_PIN_B_ZERO 0x1

// The filter renders this input
#define REG_PIN_B_RENDERER 0x2

// OK to create many instance of  pin
#define REG_PIN_B_MANY 0x4

// This is an Output pin
#define REG_PIN_B_OUTPUT 0x8

typedef struct {
    ULONG           Version;
    ULONG           Merit;
    ULONG           Pins;
    ULONG           Reserved;
}               REGFILTER_REG;

typedef struct {
    ULONG           Signature;
    ULONG           Flags;
    ULONG           PossibleInstances;
    ULONG           MediaTypes;
    ULONG           MediumTypes;
    ULONG           CategoryOffset;
    ULONG           MediumOffset;   // By definition, we always have a Medium
}               REGFILTERPINS_REG2;

KSDDKAPI
NTSTATUS
NTAPI
KsRegisterFilterWithNoKSPins(
                                      IN PDEVICE_OBJECT DeviceObject,
                                      IN const GUID * InterfaceClassGUID,
                                      IN ULONG PinCount,
                                      IN BOOL * PinDirection,
                                      IN KSPIN_MEDIUM * MediumList,
                                      IN OPTIONAL GUID * CategoryList
)
/*++

Routine Description:

    This routine is used to register filters with DShow which have no
    KS pins and therefore do not stream in kernel mode.  This is typically
    used for TvTuners, Crossbars, and the like.  On exit, a new binary
    registry key, "FilterData" is created which contains the Mediums and
    optionally the Categories for each pin on the filter.

Arguments:

    DeviceObject -
           Device object

    InterfaceClassGUID
           GUID representing the class to register

    PinCount -
           Count of the number of pins on this filter

    PinDirection -
           Array of BOOLS indicating pin direction for each pin (length PinCount)
           If TRUE, this pin is an output pin

    MediumList -
           Array of PKSMEDIUM_DATA (length PinCount)

    CategoryList -
           Array of GUIDs indicating pin categories (length PinCount) OPTIONAL


Return Value:

    NTSTATUS SUCCESS if the Blob was created

--*/
{
    NTSTATUS        Status;
    ULONG           CurrentPin;
    ULONG           TotalCategories;
    REGFILTER_REG  *RegFilter;
    REGFILTERPINS_REG2 *RegPin;
    GUID           *CategoryCache;
    PKSPIN_MEDIUM   MediumCache;
    ULONG           FilterDataLength;
    PUCHAR          FilterData;
    PWSTR           SymbolicLinkList;

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    if ((PinCount == 0) || (!InterfaceClassGUID) || (!PinDirection) || (!MediumList)) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }
    //
    // Calculate the maximum amount of space which could be taken up by
    // this cache data.
    //

    TotalCategories = (CategoryList ? PinCount : 0);

    FilterDataLength = sizeof(REGFILTER_REG) +
        PinCount * sizeof(REGFILTERPINS_REG2) +
        PinCount * sizeof(KSPIN_MEDIUM) +
        TotalCategories * sizeof(GUID);
    //
    // Allocate space to create the BLOB
    //

    FilterData = (PUCHAR)ExAllocatePool(PagedPool, FilterDataLength);
    if (!FilterData) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    //
    // Place the header in the data, defaulting the Merit to "unused".
    //

    RegFilter = (REGFILTER_REG *) FilterData;
    RegFilter->Version = 2;
    RegFilter->Merit = 0x200000;
    RegFilter->Pins = PinCount;
    RegFilter->Reserved = 0;

    //
    // Calculate the offset to the list of pins, and to the
    // MediumList and CategoryList
    //

    RegPin = (REGFILTERPINS_REG2 *) (RegFilter + 1);
    MediumCache = (PKSPIN_MEDIUM) ((PUCHAR) (RegPin + PinCount));
    CategoryCache = (GUID *) (MediumCache + PinCount);

    //
    // Create each pin header, followed by the list of Mediums
    // followed by the list of optional categories.
    //

    for (CurrentPin = 0; CurrentPin < PinCount; CurrentPin++, RegPin++) {

        //
        // Initialize the pin header.
        //

        RegPin->Signature = FCC('0pi3');
        (*(PUCHAR) & RegPin->Signature) += (BYTE) CurrentPin;
        RegPin->Flags = (PinDirection[CurrentPin] ? REG_PIN_B_OUTPUT : 0);
        RegPin->PossibleInstances = 1;
        RegPin->MediaTypes = 0;
        RegPin->MediumTypes = 1;
        RegPin->MediumOffset = (ULONG) ((PUCHAR) MediumCache - (PUCHAR) FilterData);

        *MediumCache++ = MediumList[CurrentPin];

        if (CategoryList) {
            RegPin->CategoryOffset = (ULONG) ((PUCHAR) CategoryCache - (PUCHAR) FilterData);
            *CategoryCache++ = CategoryList[CurrentPin];
        } else {
            RegPin->CategoryOffset = 0;
        }

    }

    //
    // Now create the BLOB in the registry
    //

	//
	// Note for using the flag DEVICE_INTERFACE_INCLUDE_NONACTIVE following:
	// PnP change circa 3/30/99 made the funtion IoSetDeviceInterfaceState() become
	// asynchronous. It returns SUCCESS even when the enabling is deferred. Now when
	// we arrive here, the DeviceInterface is still not enabled, we receive empty 
	// Symbolic link if the flag is not set. Here we only try to write relevent
	// FilterData to the registry. I argue this should be fine for 
	// 1. Currently, if a device is removed, the registry key for the DeviceClass
	//	  remains and with FilterData.Whatever components use the FilterData should
	//	  be able to handle if the device is removed by either check Control\Linked
	//	  or handling the failure in attempt to make connection to the non-exiting device.
	// 2. I have found that if a device is moved between slots ( PCI, USB ports ) the
	//	  DeviceInterface at DeviceClass is reused or at lease become the first entry in 
	//    the registry. Therefore, we will be updating the right entry with the proposed flag.
	//
    if (NT_SUCCESS(Status = IoGetDeviceInterfaces(
                       InterfaceClassGUID,   // ie.&KSCATEGORY_TVTUNER,etc.
                       DeviceObject, // IN PDEVICE_OBJECT PhysicalDeviceObject,OPTIONAL,
                       DEVICE_INTERFACE_INCLUDE_NONACTIVE,    // IN ULONG Flags,
                       &SymbolicLinkList // OUT PWSTR *SymbolicLinkList
                       ))) {
        UNICODE_STRING  SymbolicLinkListU;
        HANDLE          DeviceInterfaceKey;

        RtlInitUnicodeString(&SymbolicLinkListU, SymbolicLinkList);

#if 0
        DebugPrint((DebugLevelVerbose,
                    "NoKSPin for SymbolicLink %S\n",
                    SymbolicLinkList ));
#endif // 0
                    
        if (NT_SUCCESS(Status = IoOpenDeviceInterfaceRegistryKey(
                           &SymbolicLinkListU,    // IN PUNICODE_STRING SymbolicLinkName,
                           STANDARD_RIGHTS_ALL,   // IN ACCESS_MASK DesiredAccess,
                           &DeviceInterfaceKey    // OUT PHANDLE DeviceInterfaceKey
                           ))) {

            UNICODE_STRING  FilterDataString;

            RtlInitUnicodeString(&FilterDataString, L"FilterData");

            Status = ZwSetValueKey(DeviceInterfaceKey,
                                   &FilterDataString,
                                   0,
                                   REG_BINARY,
                                   FilterData,
                                   FilterDataLength);

            ZwClose(DeviceInterfaceKey);
        }
        
        // START NEW MEDIUM CACHING CODE
        for (CurrentPin = 0; CurrentPin < PinCount; CurrentPin++) {
            NTSTATUS LocalStatus;

            LocalStatus = KsCacheMedium(&SymbolicLinkListU, 
                                        &MediumList[CurrentPin],
                                        (DWORD) ((PinDirection[CurrentPin] ? 1 : 0))   // 1 == output
                                        );
            #if 0 //DBG
            if (LocalStatus != STATUS_SUCCESS) {
                DebugPrint((DebugLevelError,
                           "KsCacheMedium: SymbolicLink = %S, Status = %x\n",
                           SymbolicLinkListU.Buffer, LocalStatus));
            }
            #endif
        }
        // END NEW MEDIUM CACHING CODE
        
        ExFreePool(SymbolicLinkList);
    }
    ExFreePool(RegFilter);

    return Status;
}


ULONG
KspInsertCacheItem (
    IN PUCHAR ItemToCache,
    IN PUCHAR CacheBase,
    IN ULONG CacheItemSize,
    IN PULONG CacheItems
    )

/*++

Routine Description:

    Insert a GUID into the GUID cache for creating FilterData registry
    blobs.

Arguments:

    ItemToCache -
        The GUID to cache

    CacheBase -
        The base address of the GUID cache

    CacheItemSize -
        The size of cache items for this cache, including ItemToCache

    CacheItems -
        Points to a ULONG containing the number of items currently in the 
        cache.

Return Value:

    The offset into the cache where the item exists.

--*/

{

    //
    // Check to see whether the item to cache is already contained in
    // the cache.
    //
    for (ULONG i = 0; i < *CacheItems; i++) {

        if (RtlCompareMemory (
            ItemToCache,
            CacheBase + i * CacheItemSize,
            CacheItemSize
            ) == CacheItemSize) {

            //
            // If the item is already contained in the cache, don't recache
            // it; save registry space.
            //
            break;

        }

    }

    if (i >= *CacheItems) {
        RtlCopyMemory (
            CacheBase + (*CacheItems * CacheItemSize),
            ItemToCache,
            CacheItemSize
            );

        i = *CacheItems;

        (*CacheItems)++;
    }

    //
    // Return the offset into the cache that the item fits.
    //
    return (i * CacheItemSize);

}

typedef struct {
    ULONG           Signature;
    ULONG           Flags;
    ULONG           PossibleInstances;
    ULONG           MediaTypes;
    ULONG           MediumTypes;
    ULONG           Category;
}               REGFILTERPINS_REG3;

typedef struct {
    ULONG           Signature;
    ULONG           Reserved;
    ULONG           MajorType;
    ULONG           MinorType;
}               REGPINTYPES_REG2;


NTSTATUS
KspBuildFilterDataBlob (
    IN const KSFILTER_DESCRIPTOR *FilterDescriptor,
    OUT PUCHAR *FilterData,
    OUT PULONG FilterDataLength
    )

/*++

Routine Description:

    For a given filter descriptor, build the registry FilterData blob that
    is used by the graph builder.

Arguments:

    FilterDescriptor -
        The filter descriptor to build the filter data blob for.

    FilterData -
        The filter data blob will be placed here.  Note that the caller
        is responsible for freeing the memory.

    FilterDataLength -
        The size of the filter data blob will be placed here.

Return Value:

    Success / Failure

--*/

{
    PAGED_CODE();

    ASSERT (FilterDescriptor);
    ASSERT (FilterData);
    ASSERT (FilterDataLength);

    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Count the number of pins, the number of mediums on each pin,
    // and the number of data ranges on each pin to determine
    // how much memory will be required for the filterdata key.
    //
    ULONG MediumsCount = 0;
    ULONG DataRangesCount = 0;

    const KSPIN_DESCRIPTOR_EX *PinDescriptor = FilterDescriptor->PinDescriptors;
    for (ULONG PinDescriptorsCount = FilterDescriptor->PinDescriptorsCount;
        PinDescriptorsCount;
        PinDescriptorsCount--
        ) {

        //
        // Update the count of the number of mediums and data ranges
        //
        MediumsCount += PinDescriptor->PinDescriptor.MediumsCount;
        DataRangesCount += PinDescriptor->PinDescriptor.DataRangesCount;

        //
        // Walk to the next pin descriptor by size offset specified in
        // the filter descriptor.
        //
        PinDescriptor = (const KSPIN_DESCRIPTOR_EX *)(
            (PUCHAR)PinDescriptor + FilterDescriptor->PinDescriptorSize
            );

    }

    ULONG TotalGUIDCachePotential =
        FilterDescriptor->PinDescriptorsCount +
        DataRangesCount * 2;

    //
    // Allocate enough memory for the FilterData blob in the registry.
    //
    *FilterDataLength =
        // Initial filter description
        sizeof (REGFILTER_REG) +

        // each pin description
        FilterDescriptor->PinDescriptorsCount * sizeof (REGFILTERPINS_REG3) +

        // each media type description
        DataRangesCount * sizeof (REGPINTYPES_REG2) +

        // each medium description
        MediumsCount * sizeof (ULONG) +
        
        // mediums cached
        MediumsCount * sizeof (KSPIN_MEDIUM) +

        // category GUIDs cached
        TotalGUIDCachePotential * sizeof (GUID);


    *FilterData = (PUCHAR)
        ExAllocatePool (PagedPool, *FilterDataLength);

    if (!*FilterData) {
        *FilterDataLength = 0;
        Status = STATUS_INSUFFICIENT_RESOURCES;
    } else {

        //
        // The GUID cache follows all the filter/pin/media type structures in
        // the filter data blob.
        //
        ULONG GuidCacheOffset =
            sizeof (REGFILTER_REG) +
            FilterDescriptor->PinDescriptorsCount * sizeof(REGFILTERPINS_REG3) +
            DataRangesCount * sizeof(REGPINTYPES_REG2) +
            MediumsCount * sizeof (ULONG);

        GUID *GuidCacheBase = (GUID *)((PUCHAR)*FilterData + GuidCacheOffset);

        ULONG GuidCacheItems = 0;

        //
        // The medium cache (not the registry medium cache), but the cached
        // list of mediums in the FilterData blob follows the GUID cache.  It
        // may need to shift down later if there were items referenced out
        // of the existing cache entries.
        //
        ULONG MediumCacheOffset =
            GuidCacheOffset + (TotalGUIDCachePotential * sizeof (GUID));

        KSPIN_MEDIUM *MediumCacheBase = (KSPIN_MEDIUM *)
            ((PUCHAR)*FilterData + MediumCacheOffset);

        ULONG MediumCacheItems = 0;

        RtlZeroMemory (*FilterData, *FilterDataLength);

        REGFILTER_REG *RegFilter;
        REGFILTERPINS_REG3 *RegPin;
        REGPINTYPES_REG2 *RegPinType;
        ULONG *RegPinMedium;

        RegFilter = (REGFILTER_REG *)*FilterData;
        RegFilter->Version = 2;
        RegFilter->Merit = 0x200000;
        RegFilter->Pins = FilterDescriptor->PinDescriptorsCount;
        RegFilter->Reserved = 0;

        //
        // Walk through each pin in the filter descriptor yet again and 
        // actually build the registry blob.
        //
        PinDescriptor = FilterDescriptor->PinDescriptors;
        RegPin = (REGFILTERPINS_REG3 *)(RegFilter + 1);
        for (ULONG CurrentPin = 0;
            CurrentPin < FilterDescriptor->PinDescriptorsCount;
            CurrentPin++
            ) {


            RegPin->Signature = FCC('0pi3');
            (*(PUCHAR)&RegPin->Signature) += (BYTE)CurrentPin;

            //
            // Set the requisite flags if the pin is multi-instance.
            //
            if (PinDescriptor->InstancesPossible > 1) {
                RegPin->Flags |= REG_PIN_B_MANY;
            }

            //
            // Set all the counts on mediums, media types, etc...
            //
            RegPin->MediaTypes = PinDescriptor->PinDescriptor.DataRangesCount;
            RegPin->MediumTypes = PinDescriptor->PinDescriptor.MediumsCount;
            RegPin->PossibleInstances = PinDescriptor->InstancesPossible; 

            if (PinDescriptor->PinDescriptor.Category) {	
                RegPin->Category = GuidCacheOffset +
                    KspInsertCacheItem (
                        (PUCHAR)PinDescriptor->PinDescriptor.Category,
                        (PUCHAR)GuidCacheBase,
                        sizeof (GUID),
                        &GuidCacheItems
                        );
            } else {
                RegPin->Category = 0;
            }

            //
            // Append all media types supported on the pin
            //
            RegPinType = (REGPINTYPES_REG2 *)(RegPin + 1);
            for (ULONG CurrentType = 0;
                CurrentType < PinDescriptor->PinDescriptor.DataRangesCount;
                CurrentType++
                ) {

                const KSDATARANGE *DataRange =
                    PinDescriptor->PinDescriptor.DataRanges [CurrentType];

                RegPinType->Signature = FCC('0ty3');
                (*(PUCHAR)&RegPinType->Signature) += (BYTE)CurrentType;
                RegPinType->Reserved = 0;

                RegPinType->MajorType = GuidCacheOffset +
                    KspInsertCacheItem (
                        (PUCHAR)&(DataRange->MajorFormat),
                        (PUCHAR)GuidCacheBase,
                        sizeof (GUID),
                        &GuidCacheItems
                        );
                RegPinType->MinorType = GuidCacheOffset +
                    KspInsertCacheItem (
                        (PUCHAR)&(DataRange->SubFormat),
                        (PUCHAR)GuidCacheBase,
                        sizeof (GUID),
                        &GuidCacheItems
                        );

                //
                // Walk forward one media type.
                //
                RegPinType++;

            }

            //
            // Append the list of mediums.
            //
            const KSPIN_MEDIUM *Medium = PinDescriptor->PinDescriptor.Mediums;
            RegPinMedium = (PULONG)RegPinType;
            for (ULONG CurrentMedium = 0;
                CurrentMedium < PinDescriptor->PinDescriptor.MediumsCount;
                CurrentMedium++
                ) {

                *RegPinMedium++ = MediumCacheOffset +
                    KspInsertCacheItem (
                        (PUCHAR)Medium,
                        (PUCHAR)MediumCacheBase,
                        sizeof (KSPIN_MEDIUM),
                        &MediumCacheItems
                        );

            }

            RegPin = (REGFILTERPINS_REG3 *)RegPinMedium;

        }

        ASSERT (GuidCacheItems < TotalGUIDCachePotential);

        //
        // Find out how much empty space sits between the GUID cache
        // and the medium cache in the constructed blob and remove it.
        //
        ULONG OffsetAdjustment =
            (TotalGUIDCachePotential - GuidCacheItems) * sizeof (GUID);

        if (OffsetAdjustment) {
            
            //
            // Walk through all medium offsets and change the offsets to
            // pack the GUID and Medium cache together in the blob.
            //
            RegPin = (REGFILTERPINS_REG3 *)(RegFilter + 1);
            for (CurrentPin = 0;
                CurrentPin < FilterDescriptor->PinDescriptorsCount;
                CurrentPin++
                ) {

                RegPinMedium = (PULONG)(
                    (REGPINTYPES_REG2 *)(RegPin + 1) +
                    RegPin -> MediaTypes
                    );

                for (ULONG CurrentMedium = 0;
                    CurrentMedium < RegPin -> MediumTypes;
                    CurrentMedium++
                    ) {

                    *RegPinMedium -= OffsetAdjustment;
                    RegPinMedium++;
                }

                //
                // Increment to the next pin header position.
                //
                RegPin = (REGFILTERPINS_REG3 *)RegPinMedium;

            }

            //
            // Move the medium entries down, and adjust the overall size.
            //
            RtlMoveMemory (
                (PUCHAR)MediumCacheBase - OffsetAdjustment,
                MediumCacheBase,
                MediumCacheItems * sizeof (KSPIN_MEDIUM)
                );

            //
            // Adjust the total length by the size of the empty space between
            // the GUID cache and the Medium cache.
            //
            *FilterDataLength -= OffsetAdjustment;

        }

        //
        // Adjust the total length by the size of the empty space following
        // the medium cache.
        //
        *FilterDataLength -= (MediumsCount - MediumCacheItems) *
            sizeof (KSPIN_MEDIUM);

    }

    return Status;

}


NTSTATUS
KspCacheAllFilterPinMediums (
    PUNICODE_STRING InterfaceString,
    const KSFILTER_DESCRIPTOR *FilterDescriptor
    )

/*++

Routine Description:

    Update the medium cache for all mediums on all pins on the filter 
    described by FilterDescriptor.  The filter interface to be used is 
    specified by InterfaceString.

Arguments:

    InterfaceString -
        The device interface to register under the cache for the mediums
        on all pins on the specified filter

    FilterDescriptor -
        Describes the filter to update the medium cache for.

Return Value:

    Success / Failure

--*/

{

    PAGED_CODE();

    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Walk through all pins on the filter and cache their mediums.
    //
    const KSPIN_DESCRIPTOR_EX *PinDescriptor = FilterDescriptor->PinDescriptors;
    for (ULONG CurrentPin = 0;
        NT_SUCCESS (Status) && 
            CurrentPin < FilterDescriptor->PinDescriptorsCount;
        CurrentPin++
        ) {

        //
        // Walk through all mediums on the given pin and cache each of them
        // under the specified device interface.
        //
        const KSPIN_MEDIUM *Medium = PinDescriptor->PinDescriptor.Mediums;
        for (ULONG CurrentMedium = 0;
            NT_SUCCESS (Status) &&
                CurrentMedium < PinDescriptor->PinDescriptor.MediumsCount;
            CurrentMedium++
            ) {

            //
            // Cache the given medium on the given pin under the device 
            // interface passed in. 
            //
            Status = KsCacheMedium (
                InterfaceString,
                (PKSPIN_MEDIUM)Medium,
                PinDescriptor->PinDescriptor.DataFlow == KSPIN_DATAFLOW_OUT ?
                    1 : 0
                );

            Medium++;

        } 

        PinDescriptor = (const KSPIN_DESCRIPTOR_EX *)(
            (PUCHAR)PinDescriptor + FilterDescriptor->PinDescriptorSize
            );
        
    }

    return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\ks\sources.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1995 - 1999

Module Name:

    sources.inc.

!ENDIF

TARGETNAME=ks
TARGETPATH=obj
TARGETTYPE=EXPORT_DRIVER

TARGETLIBS=$(DDK_LIB_PATH)\ksguid.lib $(SDK_LIB_PATH)\wdmguid.lib

INCLUDES=..

MSC_WARNING_LEVEL=/W3 /WX
C_DEFINES=$(C_DEFINES) -D_WIN32 -D_KSDDK_ -D_COMDDK_ -D_UNICODE -DUNICODE -D_NO_SYS_GUID_OPERATOR_EQ_

LINKER_FLAGS =$(LINKER_FLAGS) -merge:PAGECONST=PAGE

DLLDEF=$(O)\$(TARGETNAME).def

#to avoid new compiler/linker tool to generate reference to_aulldvrm
#which is not supported in ntoskrnl of win2k
!if $(386)
LINKER_FLAGS=$(LINKER_FLAGS) $(SDK_LIB_PATH)\int64.lib
!endif

SOURCES=\
        ..\ks.rc\
        ..\alloc.c\
        ..\api.c\
        ..\automat.cpp\
        ..\busenum.c\
        ..\clock.c\
        ..\connect.c\
        ..\device.c\
        ..\event.c\
        ..\irp.c\
        ..\kcom.cpp\
        ..\method.c\
        ..\property.c\
        ..\shdevice.cpp\
        ..\shffact.cpp\
        ..\shfilt.cpp\
        ..\shmisc.cpp\
        ..\shpin.cpp\
        ..\shpipe.cpp\
        ..\shqueue.cpp\
        ..\shreq.cpp\
        ..\shsplit.cpp\
        ..\thread.c\
        ..\topology.c\
        ..\kslog.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\ks\shpin.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    shpin.cpp

Abstract:

    This module contains the implementation of the kernel streaming 
    pin object.

Author:

    Dale Sather  (DaleSat) 31-Jul-1998

--*/

#ifndef __KDEXT_ONLY__
#include "ksp.h"
#include <kcom.h>
#include <stdarg.h>
#ifdef SUPPORT_DRM
#include "ksmedia.h"
#endif // SUPPORT_DRM
#endif // __KDEXT_ONLY__

#ifdef SUPPORT_DRM
#include "drmk.h"
#endif // SUPPORT_DRM

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif // ALLOC_DATA_PRAGMA

//
// PULL this out of PAGECONST.  We can fire connection events at DPC.
//
const GUID g_KSEVENTSETID_Connection = {STATIC_KSEVENTSETID_Connection};

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA

//
// IRPLIST_ENTRY is used for the list of outstanding IRPs.  This structure is
// overlayed on the Parameters section of the current IRP stack location.  The
// reserved PVOID at the top preserves the OutputBufferLength, which is the
// only parameter that needs to be preserved.
//
typedef struct IRPLIST_ENTRY_
{
    PVOID Reserved;
    PIRP Irp;
    LIST_ENTRY ListEntry;
} IRPLIST_ENTRY, *PIRPLIST_ENTRY;

#define IRPLIST_ENTRY_IRP_STORAGE(Irp) \
    PIRPLIST_ENTRY(&IoGetCurrentIrpStackLocation(Irp)->Parameters)

#ifdef SUPPORT_DRM

//
// HACKHACK: BUGBUG:
//
// See comments on the DRM property using this.
//
typedef struct _DRMCONTENTID_DATA {

    ULONG ContentId;
    DRMRIGHTS DrmRights;

} DRMCONTENTID_DATA, *PDRMCONTENTID_DATA;

#endif // SUPPORT_DRM

//
// CKsPin is the implementation of the kernel  pin object.
//
class CKsPin:
    public IKsPin,
    public IKsProcessingObject,
    public IKsPowerNotify,
    public IKsWorkSink,
    public IKsConnection,
    public IKsControl,
    public IKsReferenceClock,
    public IKsRetireFrame,
    public IKsReevaluate,
    public IKsIrpCompletion,
    public CBaseUnknown
{
#ifndef __KDEXT_ONLY__
private:
#else // __KDEXT_ONLY__
public:
#endif // __KDEXT_ONLY__
    KSPIN_EXT m_Ext;
    KSIOBJECTBAG m_ObjectBag;
    KSPPROCESSPIN m_Process;
    PIKSFILTER m_Parent;
    LIST_ENTRY m_ChildNodeList;
    KSAUTOMATION_TABLE*const* m_NodeAutomationTables;
    ULONG m_NodesCount;
    PULONG m_FilterPinCount;

    PIKSTRANSPORT m_TransportSink;
    PIKSTRANSPORT m_TransportSource;
    BOOLEAN m_Flushing;
    KSSTATE m_State;

    PIKSTRANSPORT m_PreIntraSink;
    PIKSTRANSPORT m_PreIntraSource;

    WORK_QUEUE_ITEM m_WorkItem;

    INTERLOCKEDLIST_HEAD m_IrpsToSend;
    INTERLOCKEDLIST_HEAD m_IrpsOutstanding;
    LONG m_IrpsWaitingToTransfer;

    KSPIN_LOCK m_DefaultClockLock;

    PIKSCONNECTION m_ConnectedPinInterface;
    PKSWORKER m_Worker;

    PFILE_OBJECT m_FileObject;
    PFILE_OBJECT m_ConnectionFileObject;
    PDEVICE_OBJECT m_ConnectionDeviceObject;
    PKEVENT m_CloseEvent;

    PKSDEFAULTCLOCK m_DefaultClock;

    PFILE_OBJECT m_MasterClockFileObject;
    KSCLOCK_FUNCTIONTABLE m_ClockFunctionTable;
    LONG m_ClockRef;
    KEVENT m_ClockEvent;

    PKSIOBJECT_HEADER m_Header;

    ULONG m_IrpsCompletedOutOfOrder;
    ULONG m_StreamingIrpsSourced;
    ULONG m_StreamingIrpsDispatched;
    ULONG m_StreamingIrpsRoutedSynchronously;

    //
    // Much as in the requestor, this mandates that we wait until all frames
    // have cycled back around to the sink before we complete a stop.
    //
    // >1 on this indicates that there are active frames in the circuit
    // 1 indicates that there aren't active frames in the circuit
    // 0 indicates that a stop is proceeding
    //
    // If a stop is attempted, a decrement is performed and if non-zero
    // we wait on StopEvent until all Irps come back to the pin.
    //
    ULONG m_ActiveFrameCountPlusOne;
    KEVENT m_StopEvent;

    KSGATE m_AndGate;
    KSPPOWER_ENTRY m_PowerEntry;
    BOOLEAN m_ProcessPassive;
    WORK_QUEUE_ITEM m_WorkItemProcessing;
    WORK_QUEUE_TYPE m_WorkQueueType;
    PKSWORKER m_ProcessingWorker;
    PFNKSPIN m_DispatchProcess;
    PFNKSPINVOID m_DispatchReset;
    PFNKSPINPOWER m_DispatchSleep;
    PFNKSPINPOWER m_DispatchWake;
    PFNKSPINSETDEVICESTATE m_DispatchSetDeviceState;
    volatile ULONG m_ProcessOnRelease;
    KMUTEX m_Mutex;

    PFNKSPINHANDSHAKE m_HandshakeCallback;

    LONG m_TriggeringEvents;

    LONG m_BypassRights;
    BOOLEAN m_AddedProcessPin;

private:
    NTSTATUS
    SetDataFormat(
        IN PKSDATAFORMAT DataFormat,
        IN ULONG RequestSize
        );
    static
    NTSTATUS
    ValidateDataFormat(
        IN PVOID Context,
        IN PKSDATAFORMAT DataFormat,
        IN PKSMULTIPLE_ITEM AttributeList OPTIONAL,
        IN const KSDATARANGE* DataRange,
        IN const KSATTRIBUTE_LIST* AttributeRange OPTIONAL
        );
    BOOLEAN
    UseStandardTransport(
        void
        );
    static
    NTSTATUS
    IoCompletionRoutine(
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp,
        IN PVOID Context
        );
    void
    CancelIrpsOutstanding(
        void
        );
    void
    DecrementIrpCirculation (
        );

public:
    static
    NTSTATUS
    DispatchCreateAllocator(
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
        );
    static
    NTSTATUS
    DispatchCreateClock(
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
        );
    static
    NTSTATUS
    DispatchCreateNode(
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
        );
    static
    NTSTATUS
    DispatchDeviceIoControl(
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
        );
    static
    NTSTATUS
    DispatchClose(
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
        );
    static
    NTSTATUS
    Property_ConnectionState(
        IN PIRP Irp,
        IN PKSPROPERTY Property,
        IN OUT PKSSTATE State
        );
    static
    NTSTATUS
    Property_ConnectionDataFormat(
        IN PIRP Irp,
        IN PKSPROPERTY Property,
        IN OUT PKSDATAFORMAT DataFormat
        );
#if 0
    static
    NTSTATUS
    Property_ConnectionAllocatorFraming(
        IN PIRP Irp,
        IN PKSPROPERTY Property,
        IN PKSALLOCATOR_FRAMING Framing
        );
#endif
    static
    NTSTATUS
    Property_ConnectionAllocatorFramingEx(
        IN PIRP Irp,
        IN PKSPROPERTY Property,
        IN OUT PKSALLOCATOR_FRAMING_EX Framing
        );
    static
    NTSTATUS
    Property_ConnectionAcquireOrdering(
        IN PIRP Irp,
        IN PKSPROPERTY Property,
        IN OUT PBOOL Ordering
        );
    static
    NTSTATUS
    Property_StreamAllocator(
        IN PIRP Irp,
        IN PKSPROPERTY Property,
        IN OUT PHANDLE Handle
        );
    static
    NTSTATUS
    Property_StreamMasterClock(
        IN PIRP Irp,
        IN PKSPROPERTY Property,
        IN OUT PHANDLE Handle
        );
    static
    NTSTATUS
    Property_StreamPipeId(
        IN PIRP Irp,
        IN PKSPROPERTY Property,
        IN OUT PHANDLE Handle
        );
    static
    NTSTATUS
    Property_StreamInterfaceHeaderSize(
        IN PIRP Irp,
        IN PKSPROPERTY Property,
        OUT PULONG HeaderSize
        );
    static
    NTSTATUS    
    Support_Connection(
        IN PIRP Irp,
        IN PKSEVENT Event,
        OUT PVOID Data
        );
    static
    NTSTATUS
    AddEvent_Connection(
        IN PIRP Irp,
        IN PKSEVENTDATA EventData,
        IN OUT PKSEVENT_ENTRY EventEntry
        );
    #ifdef SUPPORT_DRM
    static
    NTSTATUS
    Property_DRMAudioStreamContentId(
        IN PIRP Irp,
        IN PKSP_DRMAUDIOSTREAM_CONTENTID Property,
        OUT PDRMCONTENTID_DATA DrmData
        );
    #endif // SUPPORT_DRM
    BOOLEAN
    UpdateProcessPin(
        );
    void
    GetCopyRelationships(
        OUT PKSPIN* CopySource,
        OUT PKSPIN* DelegateBranch
        );

public:
    DEFINE_LOG_CONTEXT(m_Log);
    DEFINE_STD_UNKNOWN();
    STDMETHODIMP_(ULONG)
    NonDelegatedRelease(
        );
    IMP_IKsPin;
    IMP_IKsProcessingObject;
    IMP_IKsPowerNotify;
    IMP_IKsWorkSink;
    IMP_IKsConnection;
    IMP_IKsControl;
    IMP_IKsReferenceClock;
    IMP_IKsRetireFrame;
    IMP_IKsReevaluate;
    IMP_IKsIrpCompletion;
    DEFINE_FROMSTRUCT(CKsPin,PKSPIN,m_Ext.Public);
    DEFINE_FROMIRP(CKsPin);
    DEFINE_FROMCREATEIRP(CKsPin);
    DEFINE_CONTROL();

    CKsPin(PUNKNOWN OuterUnknown):
        CBaseUnknown(OuterUnknown) 
    {
    }
    ~CKsPin();

    NTSTATUS
    Init(
        IN PIRP Irp,
        IN PKSFILTER_EXT Parent,
        IN PLIST_ENTRY SiblingListHead,
        IN PKSPIN_CONNECT CreateParams,
        IN ULONG RequestSize,
        IN const KSPIN_DESCRIPTOR_EX* Descriptor,
        IN const KSAUTOMATION_TABLE* AutomationTable,
        IN KSAUTOMATION_TABLE*const* NodeAutomationTables OPTIONAL,
        IN ULONG NodesCount,
        IN PULONG FilterPinCount
        );
    NTSTATUS
    InitiateHandshake(
        IN PKSHANDSHAKE In,
        OUT PKSHANDSHAKE Out
        );
    PIKSFILTER
    GetParent(
        void
        )
    {
        return m_Parent;
    };
    PIKSCONNECTION
    GetConnectionInterface(
        void
        )
    {
        if (m_ConnectedPinInterface) {
            m_ConnectedPinInterface->AddRef();
            return m_ConnectedPinInterface;
        } else {
            return NULL;
        }
    }
    PFILE_OBJECT
    GetConnectionFileObject(
        void
        )
    {
        return m_ConnectionFileObject;
    }
    PDEVICE_OBJECT
    GetConnectionDeviceObject(
        void
        )
    {
        return m_ConnectionDeviceObject;
    }
    PFILE_OBJECT
    GetMasterClockFileObject(
        void
        )
    {
        return m_MasterClockFileObject;
    }
    void
    SetHandshakeCallback(
        IN PFNKSPINHANDSHAKE Callback
        )
    {
        m_HandshakeCallback = Callback;
    }
    VOID
    SetPinClockState(
        IN KSSTATE State
        );
    VOID
    SetPinClockTime(
        IN LONGLONG Time
        );
    void
    AcquireProcessSync(
        void
        )
    {
        KeWaitForSingleObject(
            &m_Mutex,
            Executive,
            KernelMode,
            FALSE,
            NULL);
    }
    void
    ReleaseProcessSync(
        void
        );
    NTSTATUS
    SubmitFrame(
        IN PVOID Data OPTIONAL,
        IN ULONG Size OPTIONAL,
        IN PMDL Mdl OPTIONAL,
        IN PKSSTREAM_HEADER StreamHeader OPTIONAL,
        IN PVOID Context OPTIONAL
        );
    void
    SetPowerCallbacks(
        IN PFNKSPINPOWER Sleep OPTIONAL,
        IN PFNKSPINPOWER Wake OPTIONAL
        )
    {
        m_DispatchSleep = Sleep;
        m_DispatchWake = Wake;
    }
        
#if DBG
    void
    RollCallDetail(
        void
        );
#endif
};

#ifndef __KDEXT_ONLY__

IMPLEMENT_STD_UNKNOWN(CKsPin)
IMPLEMENT_GETSTRUCT(CKsPin,PKSPIN);

static const WCHAR AllocatorTypeName[] = KSSTRING_Allocator;
static const WCHAR ClockTypeName[] = KSSTRING_Clock;
static const WCHAR NodeTypeName[] = KSSTRING_TopologyNode;

static const
KSOBJECT_CREATE_ITEM 
PinCreateItems[] = {
    DEFINE_KSCREATE_ITEM(CKsPin::DispatchCreateAllocator,AllocatorTypeName,NULL),
    DEFINE_KSCREATE_ITEM(CKsPin::DispatchCreateClock,ClockTypeName,NULL),
    DEFINE_KSCREATE_ITEM(CKsPin::DispatchCreateNode,NodeTypeName,NULL)
};

DEFINE_KSDISPATCH_TABLE(
    PinDispatchTable,
    CKsPin::DispatchDeviceIoControl,
    KsDispatchInvalidDeviceRequest,
    KsDispatchInvalidDeviceRequest,
    KsDispatchInvalidDeviceRequest,
    CKsPin::DispatchClose,
    KsDispatchQuerySecurity,
    KsDispatchSetSecurity,
    KsDispatchFastIoDeviceControlFailure,
    KsDispatchFastReadFailure,
    KsDispatchFastWriteFailure);

DEFINE_KSPROPERTY_TABLE(PinConnectionPropertyItems) {
    DEFINE_KSPROPERTY_ITEM_CONNECTION_STATE(
        CKsPin::Property_ConnectionState,
        CKsPin::Property_ConnectionState),
    DEFINE_KSPROPERTY_ITEM(
        KSPROPERTY_CONNECTION_DATAFORMAT,
        CKsPin::Property_ConnectionDataFormat,
        sizeof(KSPROPERTY),
        0,
        CKsPin::Property_ConnectionDataFormat,
        NULL, 0, NULL, 
        CKsPin::Property_ConnectionDataFormat, // Support handler in case pin is fixed-format.
        0),
    DEFINE_KSPROPERTY_ITEM_CONNECTION_ALLOCATORFRAMING_EX(
        CKsPin::Property_ConnectionAllocatorFramingEx),
    DEFINE_KSPROPERTY_ITEM_CONNECTION_ACQUIREORDERING(
        CKsPin::Property_ConnectionAcquireOrdering)
//
//  Not implemented:
//
//  KSPROPERTY_CONNECTION_PRIORITY
//  KSPROPERTY_CONNECTION_PROPOSEDATAFORMAT
//  KSPROPERTY_CONNECTION_ALLOCATORFRAMING
//
};

DEFINE_KSPROPERTY_TABLE(PinStreamPropertyItems){
    DEFINE_KSPROPERTY_ITEM_STREAM_ALLOCATOR(
        CKsPin::Property_StreamAllocator,
        CKsPin::Property_StreamAllocator),
    DEFINE_KSPROPERTY_ITEM_STREAM_MASTERCLOCK(
        CKsPin::Property_StreamMasterClock,
        CKsPin::Property_StreamMasterClock),
    DEFINE_KSPROPERTY_ITEM_STREAM_PIPE_ID(
        CKsPin::Property_StreamPipeId,
        CKsPin::Property_StreamPipeId)
//
//  Not implemented:
//
//  KSPROPERTY_STREAM_QUALITY
//  KSPROPERTY_STREAM_DEGRADATION
//  KSPROPERTY_STREAM_TIMEFORMAT
//  KSPROPERTY_STREAM_PRESENTATIONTIME
//  KSPROPERTY_STREAM_PRESENTATIONEXTENT
//  KSPROPERTY_STREAM_FRAMETIME
//  KSPROPERTY_STREAM_RATECAPABILITY
//  KSPROPERTY_STREAM_RATE
//
};

DEFINE_KSPROPERTY_STREAMINTERFACESET(
    PinStreamInterfacePropertyItems,
    CKsPin::Property_StreamInterfaceHeaderSize);

DEFINE_KSPROPERTY_SET_TABLE(PinPropertySets) {
    DEFINE_KSPROPERTY_SET(
        &KSPROPSETID_Connection,
        SIZEOF_ARRAY(PinConnectionPropertyItems),
        PinConnectionPropertyItems,
        0,
        NULL),
    DEFINE_KSPROPERTY_SET(
        &KSPROPSETID_Stream,
        SIZEOF_ARRAY(PinStreamPropertyItems),
        PinStreamPropertyItems,
        0,
        NULL),
    DEFINE_KSPROPERTY_SET(
        &KSPROPSETID_StreamInterface,
        SIZEOF_ARRAY(PinStreamInterfacePropertyItems),
        PinStreamInterfacePropertyItems,
        0,
        NULL)
};

DEFINE_KSEVENT_TABLE(PinConnectionEventItems) {
    DEFINE_KSEVENT_ITEM(
        KSEVENT_CONNECTION_POSITIONUPDATE,
        sizeof(KSEVENTDATA),
        0,
        PFNKSADDEVENT(CKsPin::AddEvent_Connection),
        NULL,
        NULL),
    DEFINE_KSEVENT_ITEM(
        KSEVENT_CONNECTION_DATADISCONTINUITY,
        sizeof(KSEVENTDATA),
        0,
        PFNKSADDEVENT(CKsPin::AddEvent_Connection),
        NULL,
        NULL),
    DEFINE_KSEVENT_ITEM(
        KSEVENT_CONNECTION_TIMEDISCONTINUITY,
        sizeof(KSEVENTDATA),
        0,
        PFNKSADDEVENT(CKsPin::AddEvent_Connection),
        NULL,
        NULL),
    DEFINE_KSEVENT_ITEM(
        KSEVENT_CONNECTION_PRIORITY,
        sizeof(KSEVENTDATA),
        0,
        PFNKSADDEVENT(CKsPin::AddEvent_Connection),
        NULL,
        NULL),
    DEFINE_KSEVENT_ITEM(
        KSEVENT_CONNECTION_ENDOFSTREAM,
        sizeof(KSEVENTDATA),
        0,
        PFNKSADDEVENT(CKsPin::AddEvent_Connection),
        NULL,
        CKsPin::Support_Connection),
};

DEFINE_KSEVENT_SET_TABLE(PinEventSets) {
    DEFINE_KSEVENT_SET(
        &KSEVENTSETID_Connection,
        SIZEOF_ARRAY(PinConnectionEventItems),
        PinConnectionEventItems)
};

extern
DEFINE_KSAUTOMATION_TABLE(PinAutomationTable) {
    DEFINE_KSAUTOMATION_PROPERTIES(PinPropertySets),
    DEFINE_KSAUTOMATION_METHODS_NULL,
    DEFINE_KSAUTOMATION_EVENTS(PinEventSets)
};

#ifdef SUPPORT_DRM
//
// HACKHACK: BUGBUG:
//
// This is an ugly evil last minute hack for DRM.  AVStream currently
// has no support for layering properties.  Unfortunately, DRM requires
// that the content id property be handled both by the class and
// minidriver.  It also requires a callback into DRM which means that
// KS will have to link against the DRM lib.  This **MUST** be changed
// for DX8 or Whistler to use a cleaner method.
//
DEFINE_KSPROPERTY_TABLE(DRMPropertyItems) {
    DEFINE_KSPROPERTY_ITEM(
        KSPROPERTY_DRMAUDIOSTREAM_CONTENTID,
        NULL,
        sizeof (KSP_DRMAUDIOSTREAM_CONTENTID),
        sizeof (DRMCONTENTID_DATA),
        CKsPin::Property_DRMAudioStreamContentId,
        NULL, 0, NULL, NULL, 0
    )
};

DEFINE_KSPROPERTY_SET_TABLE(DRMPropertySets) {
    DEFINE_KSPROPERTY_SET(
        &KSPROPSETID_DrmAudioStream,
        SIZEOF_ARRAY(DRMPropertyItems),
        DRMPropertyItems,
        0,
        NULL
    )
};

DEFINE_KSAUTOMATION_TABLE(DRMAutomationTable) {
    DEFINE_KSAUTOMATION_PROPERTIES(DRMPropertySets),
    DEFINE_KSAUTOMATION_METHODS_NULL,
    DEFINE_KSAUTOMATION_EVENTS_NULL
};
#endif // SUPPORT_DRM

#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif // ALLOC_PRAGMA

IMPLEMENT_FROMSTRUCT(CKsPin,PKSPIN,m_Ext.Public);

void
CKsPin::
ReleaseProcessSync(
    void
    )
{
    KeReleaseMutex(&m_Mutex,FALSE);

    while ( m_ProcessOnRelease ) {
        if (InterlockedCompareExchange(PLONG(&m_ProcessOnRelease),0,2)==2) {
#ifndef __KDEXT_ONLY__
            ProcessingObjectWork();
            break;
#endif // __KDEXT_ONLY__
        }
    }
}

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA


NTSTATUS
KspCreatePin(
    IN PIRP Irp,
    IN PKSFILTER_EXT Parent,
    IN PLIST_ENTRY SiblingListHead,
    IN PKSPIN_CONNECT CreateParams,
    IN ULONG RequestSize,
    IN const KSPIN_DESCRIPTOR_EX* Descriptor,
    IN const KSAUTOMATION_TABLE* AutomationTable,
    IN KSAUTOMATION_TABLE*const* NodeAutomationTables OPTIONAL,
    IN ULONG NodesCount,
    IN PULONG FilterPinCount
    )

/*++

Routine Description:

    This routine creates a new pin object.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KspCreatePin]"));

    PAGED_CODE();

    ASSERT(Irp);
    ASSERT(Parent);
    ASSERT(SiblingListHead);
    ASSERT(CreateParams);
    ASSERT(RequestSize);
    ASSERT(Descriptor);
    ASSERT(AutomationTable);
    ASSERT(NodeAutomationTables || ! NodesCount);
    ASSERT(FilterPinCount);

    //
    // Make sure caller is allowed to create the filter.
    //
    if ((Descriptor->Flags&KSPIN_FLAG_DENY_USERMODE_ACCESS) &&
        Irp->RequestorMode != KernelMode ) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Create the pin object.
    //
    CKsPin *pin =
        new(NonPagedPool,POOLTAG_PIN) CKsPin(NULL);

    NTSTATUS status;
    if (pin) {
        pin->AddRef();

        status = 
            pin->Init(
                Irp,
                Parent,
                SiblingListHead,
                CreateParams,
                RequestSize,
                Descriptor,
                AutomationTable,
                NodeAutomationTables,
                NodesCount,
                FilterPinCount);

        pin->Release();
    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return status;
}


CKsPin::
~CKsPin(
    void
    )

/*++

Routine Description:

    This routine destructs a pin object.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::~CKsPin(0x%08x)]",this));
    _DbgPrintF(DEBUGLVL_LIFETIME,("#### Pin%p.~",this));
    if (m_StreamingIrpsSourced) {
        _DbgPrintF(DEBUGLVL_METRICS,("     Pin%p.~:  m_StreamingIrpsSourced=%d",this,m_StreamingIrpsSourced));
    }
    if (m_StreamingIrpsDispatched) {
        _DbgPrintF(DEBUGLVL_METRICS,("     Pin%p.~:  m_StreamingIrpsDispatched=%d",this,m_StreamingIrpsDispatched));
    }
    if (m_StreamingIrpsRoutedSynchronously) {
        _DbgPrintF(DEBUGLVL_METRICS,("     Pin%p.~:  m_StreamingIrpsRoutedSynchronously=%d",this,m_StreamingIrpsRoutedSynchronously));
    }

    PAGED_CODE();

    ASSERT(! m_TransportSink);
    ASSERT(! m_TransportSource);

    if (m_Ext.AggregatedClientUnknown) {
        m_Ext.AggregatedClientUnknown->Release();
    }

#if (DBG)
    if (! IsListEmpty(&m_ChildNodeList)) {
        _DbgPrintF(DEBUGLVL_ERROR,("[CKsPin::~CKsPin] ERROR:  node instances still exist"));
    }
#endif

    if (m_Ext.Public.ConnectionFormat) {
        ExFreePool(m_Ext.Public.ConnectionFormat);
        m_Ext.Public.ConnectionFormat = NULL;
        m_Ext.Public.AttributeList = NULL;
    }

    KspTerminateObjectBag(&m_ObjectBag);

    KsLog(&m_Log,KSLOGCODE_PIN_DESTROY,NULL,NULL);
}


STDMETHODIMP
CKsPin::
NonDelegatedQueryInterface(
    IN REFIID InterfaceId,
    OUT PVOID* InterfacePointer
    )

/*++

Routine Description:

    This routine obtains an interface to a pin object.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::NonDelegatedQueryInterface]"));

    PAGED_CODE();

    ASSERT(InterfacePointer);

    NTSTATUS status = STATUS_SUCCESS;

    if (IsEqualGUIDAligned(InterfaceId,__uuidof(IKsTransport))) {
        *InterfacePointer = reinterpret_cast<PVOID>(static_cast<PIKSTRANSPORT>(this));
        AddRef();
    } else 
    if (IsEqualGUIDAligned(InterfaceId,__uuidof(IKsControl))) {
        *InterfacePointer = reinterpret_cast<PVOID>(static_cast<PIKSCONTROL>(this));
        AddRef();
    } else 
    if (IsEqualGUIDAligned(InterfaceId,__uuidof(IKsPin))) {
        *InterfacePointer = reinterpret_cast<PVOID>(static_cast<PIKSPIN>(this));
        AddRef();
    } else 
    if (IsEqualGUIDAligned(InterfaceId,__uuidof(IKsProcessingObject))) {
        *InterfacePointer = reinterpret_cast<PVOID>(static_cast<PIKSPROCESSINGOBJECT>(this));
        AddRef();
    } else 
    if (IsEqualGUIDAligned(InterfaceId,__uuidof(IKsPowerNotify))) {
        *InterfacePointer = reinterpret_cast<PVOID>(static_cast<PIKSPOWERNOTIFY>(this));
        AddRef();
    } else 
    if (IsEqualGUIDAligned(InterfaceId,__uuidof(IKsRetireFrame))) {
        *InterfacePointer = reinterpret_cast<PVOID>(static_cast<PIKSRETIREFRAME>(this));
        AddRef();
    } else 
    if (IsEqualGUIDAligned(InterfaceId,__uuidof(IKsWorkSink))) {
        *InterfacePointer = reinterpret_cast<PVOID>(static_cast<PIKSWORKSINK>(this));
        AddRef();
    } else
    if (IsEqualGUIDAligned(InterfaceId,__uuidof(IKsIrpCompletion))) {
        *InterfacePointer = reinterpret_cast<PVOID>(static_cast<PIKSIRPCOMPLETION>(this));
        AddRef();
    } else {
        status = 
            CBaseUnknown::NonDelegatedQueryInterface(
                InterfaceId,
                InterfacePointer);
        if (! NT_SUCCESS(status) && m_Ext.AggregatedClientUnknown) {
            status = m_Ext.AggregatedClientUnknown->
                QueryInterface(InterfaceId,InterfacePointer);
        }
    }

    return status;
}


STDMETHODIMP_(ULONG)
CKsPin::
NonDelegatedRelease(
    )
/*++

Routine Description:

    Implements INonDelegatedUnknown::NonDelegatedRelease. Decrements
    the reference count on this object. If the reference count reaches
    zero, the object is deleted and if the ClassId was specified on the
    constructor, the reference count on the module which supports the
    class passed in on the constructor is decremented.

    This function must be called directly from the IUnknown::Release()
    method of the object.

Arguments:

    None.

Return Values:

    Returns the current reference count value.

--*/
{
    PAGED_CODE();

    LONG    RefCount;

    //
    // This code is expecting to be called from IUnknown->Release, and will
    // eventually use the new primitives to rearrange the stack so that it
    // is actually run after the calling function has returned.
    //
    if (!(RefCount = InterlockedDecrement(&m_RefCount))) {
        //
        // Cache the event pointer is case DispatchClose() is blocked on
        // object deletion.
        //
        PKEVENT closeEvent = m_CloseEvent;

        //
        // Make CBaseUnknown do the final release.
        //
        m_RefCount++;
        CBaseUnknown::NonDelegatedRelease();

        //
        // Set the close event if there is one.  This only happens when
        // DispatchClose is waiting for the object to get deleted.  The
        // event itself is on the stack of the thread doing the close,
        // so we can safely access the event through this cached pointer.
        //
        if (closeEvent) {
            KeSetEvent(closeEvent,IO_NO_INCREMENT,FALSE);
        }
    }
    return RefCount;
}


NTSTATUS
CKsPin::
Init(
    IN PIRP Irp,
    IN PKSFILTER_EXT Parent,
    IN PLIST_ENTRY SiblingListHead,
    IN PKSPIN_CONNECT CreateParams,
    IN ULONG RequestSize,
    IN const KSPIN_DESCRIPTOR_EX* Descriptor,
    IN const KSAUTOMATION_TABLE* AutomationTable,
    IN KSAUTOMATION_TABLE*const* NodeAutomationTables OPTIONAL,
    IN ULONG NodesCount,
    IN PULONG FilterPinCount
    ) 

/*++

Routine Description:

    This routine initializes a pin object.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::Init]"));

    PAGED_CODE();

    ASSERT(Irp);
    ASSERT(Parent);
    ASSERT(SiblingListHead);
    ASSERT(CreateParams);
    ASSERT(RequestSize);
    ASSERT(Descriptor);
    ASSERT(AutomationTable);
    ASSERT(NodeAutomationTables || ! NodesCount);
    ASSERT(FilterPinCount);

    //
    // Initialize the public structure.
    //
    InitializeListHead(&m_Ext.ChildList);
    m_Ext.Parent = Parent;
    m_Ext.ObjectType = KsObjectTypePin;
    m_Ext.Interface = this;
    m_Ext.Device = Parent->Device;
    m_Ext.FilterControlMutex = Parent->FilterControlMutex;
    m_Ext.AutomationTable = AutomationTable;
    m_Ext.Reevaluator = (PIKSREEVALUATE)this;
    InitializeInterlockedListHead(&m_Ext.EventList);
    m_Ext.ProcessPin = &m_Process;
    m_Ext.Public.Descriptor = Descriptor;
    m_Ext.Public.Context = Parent->Public.Context;
    m_Ext.Public.Id = CreateParams->PinId;
    m_Ext.Public.Communication = 
        KSPIN_COMMUNICATION(
            ULONG(Descriptor->PinDescriptor.Communication) & 
            ~ULONG(KSPIN_COMMUNICATION_SOURCE));
    m_Ext.Public.ConnectionIsExternal = TRUE;
    m_Ext.Public.ConnectionInterface = CreateParams->Interface;
    m_Ext.Public.ConnectionMedium = CreateParams->Medium;
    m_Ext.Public.ConnectionPriority = CreateParams->Priority;
    m_Ext.Public.DeviceState = KSSTATE_STOP;
    m_Ext.Public.ResetState = KSRESET_END;
    m_Ext.Public.Bag = reinterpret_cast<KSOBJECT_BAG>(&m_ObjectBag);
    m_Ext.Device->InitializeObjectBag(&m_ObjectBag,m_Ext.FilterControlMutex);
    m_ProcessOnRelease = 0;
    KeInitializeMutex(&m_Mutex,0);
    KsGateInitializeAnd(&m_AndGate,NULL);

    //
    // Create an off input on the gate to ensure that no erroneous dispatches
    // occur on queue deletion.  This input will change state on transitions
    // between STOP and ACQUIRE.
    //
    _DbgPrintF(DEBUGLVL_PROCESSINGCONTROL,("#### Pin%p.Init:  add%p-->%d",this,&m_AndGate,m_AndGate.Count));
    KsGateAddOffInputToAnd (&m_AndGate);

    // 
    // This is a one-based count of IRPs in circulation.  We decrement it when
    // we go to stop state and block until it hits zero.
    //
    m_ActiveFrameCountPlusOne = 1;
    KeInitializeEvent (&m_StopEvent, SynchronizationEvent, FALSE);

    //
    // Initialize the process pin structure.
    //
    m_Process.Pin = &m_Ext.Public;

    //
    // Initialize pin-specific members.
    //
    m_Parent = Parent->Interface;
    m_NodeAutomationTables = NodeAutomationTables;
    m_NodesCount = NodesCount;
    m_FilterPinCount = FilterPinCount;
    InitializeListHead(&m_ChildNodeList);
    m_FileObject = IoGetCurrentIrpStackLocation(Irp)->FileObject;

    KsInitializeWorkSinkItem(&m_WorkItem,this);
    NTSTATUS status = KsRegisterCountedWorker(HyperCriticalWorkQueue,&m_WorkItem,&m_Worker);

    //
    // Cache processing items from the descriptor.
    //
    if (Descriptor->Dispatch) {
        m_DispatchProcess = Descriptor->Dispatch->Process;
        m_DispatchReset = Descriptor->Dispatch->Reset;
        m_DispatchSetDeviceState = Descriptor->Dispatch->SetDeviceState;
        if (m_DispatchProcess) {
            m_Ext.Device->AddPowerEntry(&m_PowerEntry,this);
        }
    }
    m_ProcessPassive = ((Descriptor->Flags & KSPIN_FLAG_DISPATCH_LEVEL_PROCESSING) == 0);
    m_WorkQueueType = DelayedWorkQueue;
    if (Descriptor->Flags & KSPIN_FLAG_CRITICAL_PROCESSING) {
        m_WorkQueueType = CriticalWorkQueue;
    }
    if (Descriptor->Flags & KSPIN_FLAG_HYPERCRITICAL_PROCESSING) {
        m_WorkQueueType = HyperCriticalWorkQueue;
    }

    //
    // Register work sink item for processing.   IKsProcessingObject looks like
    // it's derived from IKsWorkSink, but the function name is not Work(), it's
    // ProcessingObjectWork().  That's why IKsProcessingObject is reinterpreted
    // as IKsWorkSink
    //
    KsInitializeWorkSinkItem(
        &m_WorkItemProcessing,
        reinterpret_cast<IKsWorkSink*>(
            static_cast<IKsProcessingObject*>(this)));
    KsRegisterWorker(m_WorkQueueType, &m_ProcessingWorker);

    InitializeInterlockedListHead(&m_IrpsToSend);
    InitializeInterlockedListHead(&m_IrpsOutstanding);

    m_State = KSSTATE_STOP;
    m_Ext.Public.DataFlow = m_Ext.Public.Descriptor->PinDescriptor.DataFlow;

    KeInitializeEvent(&m_ClockEvent,SynchronizationEvent,FALSE);

    KsLogInitContext(&m_Log,&m_Ext.Public,this);
    KsLog(&m_Log,KSLOGCODE_PIN_CREATE,NULL,NULL);

    //
    // Reference the next pin if this is a source.  This must be undone if
    // this function fails.
    //
    if (NT_SUCCESS(status) && CreateParams->PinToHandle) {
        m_Ext.Public.Communication = KSPIN_COMMUNICATION_SOURCE;

        status =
            ObReferenceObjectByHandle(
                CreateParams->PinToHandle,
                GENERIC_READ | GENERIC_WRITE,
                *IoFileObjectType,
                KernelMode,
                (PVOID *) &m_ConnectionFileObject,
                NULL);

        if (NT_SUCCESS(status)) {
            m_ConnectionDeviceObject = 
                IoGetRelatedDeviceObject(m_ConnectionFileObject);
        }
    }

    //
    // Establish the underlying connection if this is a source pin and the
    // other pin is also a  pin.
    //
    if (m_ConnectionFileObject)
    {
        KSHANDSHAKE in;
        KSHANDSHAKE out;

        in.ProtocolId = __uuidof(IKsConnection);
        in.Argument1 = PIKSCONNECTION(this);
        in.Argument2 = &m_Ext.Public;

        NTSTATUS handshakeStatus = InitiateHandshake(&in,&out);
        if (handshakeStatus == STATUS_INVALID_DEVICE_REQUEST) {
            //
            // Handshake was not understood.  The sink is not a shell pin, but
            // we play nice anyway.
            //
        } else if (NT_SUCCESS(handshakeStatus)) {
            //
            // Handshake was understood and successful.  There is a reference
            // on the pin interface that must be released later.
            //
            m_ConnectedPinInterface = PIKSCONNECTION(out.Argument1);
            m_Ext.Public.ConnectionIsExternal = FALSE;
        } else {
            //
            // Handshake was understood, but we have been brutally rejected by
            // the sink pin.  This connection must fail.  In this case, we
            // assume that there is no interface that must be dereferenced.
            //
            status = handshakeStatus;
        }

    }

    //
    // Copy the format.
    //
    if (NT_SUCCESS(status)) {
        status = SetDataFormat(PKSDATAFORMAT(CreateParams + 1),RequestSize);
    }

    BOOLEAN cleanup = FALSE;

    //
    // Call the standard create function to do most of the work.
    //
    if (NT_SUCCESS(status)) {
        //
        // Increment instance count.
        //
        (*m_FilterPinCount)++;

        //
        // We wait until this point to take a reference so the caller's
        // release will destroy the object if we never make it here.  If
        // we do make it here, KspCreate() takes over.  It will
        // dispatch this IRP through our close routine in case of failure.
        // The close routine will do the Release() we need to balance
        // this AddRef().
        //
        AddRef();
        status =
            KspCreate(
                Irp,
                SIZEOF_ARRAY(PinCreateItems),
                PinCreateItems,
                &PinDispatchTable,
                TRUE,
                reinterpret_cast<PKSPX_EXT>(&m_Ext),
                SiblingListHead,
                NULL);

        //
        // Get a pointer to the header in case we need to set the stack depth.
        //
        if (NT_SUCCESS(status)) {
            //
            // Tell the filter there is a new pin.
            //
            m_Parent->AddProcessPin(&m_Process);
            m_AddedProcessPin = TRUE;

            m_Header = *reinterpret_cast<PKSIOBJECT_HEADER*>(m_FileObject->FsContext);
        }
    } else
        cleanup = TRUE;

    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation (Irp);
    //
    // If we failed prior to KspCreate or we failed in KspCreate in the
    // object header creation process, we must manually perform any cleanup
    // which would ordinarily be done in DispatchClose.
    //
    if (cleanup || 
        (!NT_SUCCESS (status) && Irp->IoStatus.Status ==
            STATUS_MORE_PROCESSING_REQUIRED &&
            irpSp -> FileObject->FsContext == NULL)) {

        if (Descriptor->Dispatch && m_DispatchProcess) {
            m_Ext.Device->RemovePowerEntry(&m_PowerEntry);
        }

        if (m_Worker)
            KsUnregisterWorker (m_Worker);
        
        if (m_ProcessingWorker) 
            KsUnregisterWorker (m_ProcessingWorker);

        if (m_ConnectionFileObject) {
            if (m_ConnectedPinInterface) {
                m_ConnectedPinInterface->Disconnect();
                m_ConnectedPinInterface->Release();
                m_ConnectedPinInterface = NULL;
            }
            ObDereferenceObject (m_ConnectionFileObject);
        }

    }

    _DbgPrintF(DEBUGLVL_LIFETIME,(
        "#### Pin%p.Init:  status %p  id %d  flow %s  connFO %p  connPin %p",
        this,
        status,
        m_Ext.Public.Id,
        (m_Ext.Public.DataFlow == KSPIN_DATAFLOW_IN) ? "IN" : "OUT",
        m_ConnectionFileObject,
        m_ConnectedPinInterface));
    return status;
}


NTSTATUS
CKsPin::
InitiateHandshake(
    IN PKSHANDSHAKE In,
    OUT PKSHANDSHAKE Out
    )

/*++

Routine Description:

    This routine performs a protocol handshake with a connected pin.

Arguments:

    In -
        Points to a structure containing the handshake information to
        be passed to the connected pin.

    Out -
        Points to a structure to be filled with the handshake information
        from the connected pin.

Return Value:

    Status.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::InitiateHandshake]"));

    PAGED_CODE();

    ASSERT(In);
    ASSERT(Out);

    NTSTATUS status = STATUS_INVALID_DEVICE_REQUEST;
    if (m_ConnectedPinInterface) {
        //
        // Private connection exists...use it.
        //
        status = m_ConnectedPinInterface->FastHandshake(In,Out);
    } else if (m_ConnectionFileObject) {
        //
        // No private connection...must do IOCTL.
        //
        ULONG bytesReturned;

        status =
            KsSynchronousIoControlDevice(
                m_ConnectionFileObject,
                KernelMode,
                IOCTL_KS_HANDSHAKE,
                PVOID(In),
                sizeof(*In),
                PVOID(Out),
                sizeof(*Out),
                &bytesReturned);

        if (NT_SUCCESS(status) && (bytesReturned != sizeof(*Out))) {
            status = STATUS_INVALID_BUFFER_SIZE;
        }
    }

    return status;
}


STDMETHODIMP
CKsPin::
FastHandshake(
    IN PKSHANDSHAKE In,
    OUT PKSHANDSHAKE Out
    )

/*++

Routine Description:

    This routine performs a handshake operation in response to a request by the
    connected pin.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::FastHandshake]"));

    PAGED_CODE();

    ASSERT(In);
    ASSERT(Out);

    NTSTATUS status;
    if (IsEqualGUID(In->ProtocolId,__uuidof(IKsConnection))) {
        //
        // Connection protocol...handle it here.  There is no reference on the
        // pin interface, so it must be AddRef() if all goes well.
        //

        //
        // Acquire control mutex so descriptor is stable.
        //
        AcquireControl();
        m_ConnectedPinInterface = PIKSCONNECTION(In->Argument1);
        m_Ext.Public.ConnectionIsExternal = FALSE;
        if (m_Ext.Public.Descriptor->Dispatch && 
            m_Ext.Public.Descriptor->Dispatch->Connect) {
            //
            // Tell the client.
            //
            status = m_Ext.Public.Descriptor->Dispatch->Connect(&m_Ext.Public);
        } else {
            status = STATUS_SUCCESS;
        }
        ReleaseControl();

        if (status == STATUS_PENDING) {
#if DBG
            _DbgPrintF(DEBUGLVL_ERROR,("CLIENT BUG:  connect handler returned STATUS_PENDING"));
#endif
            status = STATUS_UNSUCCESSFUL;
        } else if (NT_SUCCESS(status)) {
            Out->ProtocolId = In->ProtocolId;
            Out->Argument1 = PIKSCONNECTION(this);
            Out->Argument2 = &m_Ext.Public;

            m_ConnectedPinInterface->AddRef();
            AddRef();
        } else {
#if DBG
            if (status == STATUS_INVALID_DEVICE_REQUEST) {
                _DbgPrintF(DEBUGLVL_ERROR,("CLIENT BUG:  connect handler returned STATUS_INVALID_DEVICE_REQUEST"));
            }
#endif
            status = STATUS_UNSUCCESSFUL;
        }
    } else {
        //
        // Acquire control mutex so descriptor is stable.
        //
        AcquireControl();
        if (m_HandshakeCallback) {
            //
            // Unknown protocol...ask the client.
            //
            status = m_HandshakeCallback(&m_Ext.Public,In,Out);
        } else {
            status = STATUS_INVALID_DEVICE_REQUEST;
        }
        ReleaseControl();
    }

    return status;
}


STDMETHODIMP_(PIKSFILTER)
CKsPin::
GetFilter(
    void
    )

/*++

Routine Description:

    This routine returns a referenced interface for the parent filter.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::GetFilter]"));

    PAGED_CODE();

    PIKSFILTER filter = GetParent();
    ASSERT(filter);

    filter->AddRef();

    return filter;
}


STDMETHODIMP
CKsPin::
KsProperty(
    IN PKSPROPERTY Property,
    IN ULONG PropertyLength,
    IN OUT LPVOID PropertyData,
    IN ULONG DataLength,
    OUT ULONG* BytesReturned
    )

/*++

Routine Description:

    This routine sends a property request to the file object.

Arguments:

Return Value:

    Status.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::KsProperty]"));

    PAGED_CODE();

    ASSERT(Property);
    ASSERT(PropertyLength >= sizeof(*Property));
    ASSERT(PropertyData || (DataLength == 0));
    ASSERT(BytesReturned);
    ASSERT(m_FileObject);

    return
        KsSynchronousIoControlDevice(
            m_FileObject,
            KernelMode,
            IOCTL_KS_PROPERTY,
            Property,
            PropertyLength,
            PropertyData,
            DataLength,
            BytesReturned);
}


STDMETHODIMP
CKsPin::
KsMethod(
    IN PKSMETHOD Method,
    IN ULONG MethodLength,
    IN OUT LPVOID MethodData,
    IN ULONG DataLength,
    OUT ULONG* BytesReturned
    )

/*++

Routine Description:

    This routine sends a method request to the file object.

Arguments:

Return Value:

    Status.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::KsMethod]"));

    PAGED_CODE();

    ASSERT(Method);
    ASSERT(MethodLength >= sizeof(*Method));
    ASSERT(MethodData || (DataLength == 0));
    ASSERT(BytesReturned);
    ASSERT(m_FileObject);

    return
        KsSynchronousIoControlDevice(
            m_FileObject,
            KernelMode,
            IOCTL_KS_METHOD,
            Method,
            MethodLength,
            MethodData,
            DataLength,
            BytesReturned);
}


STDMETHODIMP
CKsPin::
KsEvent(
    IN PKSEVENT Event OPTIONAL,
    IN ULONG EventLength,
    IN OUT LPVOID EventData,
    IN ULONG DataLength,
    OUT ULONG* BytesReturned
    )

/*++

Routine Description:

    This routine sends an event request to the file object.

Arguments:

Return Value:

    Status.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::KsEvent]"));

    PAGED_CODE();

    ASSERT(Event);
    ASSERT(EventLength >= sizeof(*Event));
    ASSERT(EventData || (DataLength == 0));
    ASSERT(BytesReturned);
    ASSERT(m_FileObject);

    //
    // If an event structure is present, this must either be an Enable or
    // or a Support query.  Otherwise this must be a Disable.
    //
    if (EventLength) {
        return 
            KsSynchronousIoControlDevice(
                m_FileObject,
                KernelMode,
                IOCTL_KS_ENABLE_EVENT,
                Event,
                EventLength,
                EventData,
                DataLength,
                BytesReturned);
    } else {
        return 
            KsSynchronousIoControlDevice(
                m_FileObject,
                KernelMode,
                IOCTL_KS_DISABLE_EVENT,
                EventData,
                DataLength,
                NULL,
                0,
                BytesReturned);
    }
}

#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif // ALLOC_PRAGMA


STDMETHODIMP_(LONGLONG)
CKsPin::
GetTime(
    void
    )

/*++

Routine Description:

    This routine gets the current time from the reference clock.

Arguments:

    None.

Return Value:

    The current time according to the reference clock.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::GetTime]"));

    LONGLONG result;
    if (InterlockedIncrement(&m_ClockRef) > 1) {
        result = m_ClockFunctionTable.GetTime(m_MasterClockFileObject);
    } else {
        result = 0;
    }

    if (InterlockedDecrement(&m_ClockRef) == 0) {
        KeSetEvent(&m_ClockEvent,IO_NO_INCREMENT,FALSE);
    }

    return result;
}


STDMETHODIMP_(LONGLONG)
CKsPin::
GetPhysicalTime(
    void
    )

/*++

Routine Description:

    This routine gets the current physical time from the reference clock.

Arguments:

    None.

Return Value:

    The current physical time according to the reference clock.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::GetPhysicalTime]"));

    LONGLONG result;
    if (InterlockedIncrement(&m_ClockRef) > 1) {
        result = m_ClockFunctionTable.GetPhysicalTime(m_MasterClockFileObject);
    } else {
        result = 0;
    }

    if (InterlockedDecrement(&m_ClockRef) == 0) {
        KeSetEvent(&m_ClockEvent,IO_NO_INCREMENT,FALSE);
    }

    return result;
}


STDMETHODIMP_(LONGLONG)
CKsPin::
GetCorrelatedTime(
    OUT PLONGLONG SystemTime
    )

/*++

Routine Description:

    This routine gets the current time and correlated system time from the
    reference clock.

Arguments:

    SystemTime -
        Contains the location at which the correlated system time should be
        deposited.

Return Value:

    The current time according to the reference clock.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::GetCorrelatedTime]"));

    ASSERT(SystemTime);

    LONGLONG result;
    if (InterlockedIncrement(&m_ClockRef) > 1) {
        result = 
            m_ClockFunctionTable.GetCorrelatedTime(
                m_MasterClockFileObject,SystemTime);
    } else {
        result = 0;
    }

    if (InterlockedDecrement(&m_ClockRef) == 0) {
        KeSetEvent(&m_ClockEvent,IO_NO_INCREMENT,FALSE);
    }

    return result;
}


STDMETHODIMP_(LONGLONG)
CKsPin::
GetCorrelatedPhysicalTime(
    OUT PLONGLONG SystemTime
    )

/*++

Routine Description:

    This routine gets the current physical time and correlated system time from 
    the reference clock.

Arguments:

    SystemTime -
        Contains the location at which the correlated system time should be
        deposited.

Return Value:

    The current physical time according to the reference clock.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::GetCorrelatedPhysicalTime]"));

    ASSERT(SystemTime);

    LONGLONG result;
    if (InterlockedIncrement(&m_ClockRef) > 1) {
        result = 
            m_ClockFunctionTable.GetCorrelatedPhysicalTime(
                m_MasterClockFileObject,SystemTime);
    } else {
        result = 0;
    }

    if (InterlockedDecrement(&m_ClockRef) == 0) {
        KeSetEvent(&m_ClockEvent,IO_NO_INCREMENT,FALSE);
    }

    return result;
}

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA


STDMETHODIMP
CKsPin::
GetResolution(
    OUT PKSRESOLUTION Resolution
    )

/*++

Routine Description:

    This routine gets the resolution of the reference clock.

Arguments:

    State -
        Contains a pointer to the location at which the resolution should be 
        deposited.

Return Value:

    Status.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::GetResolution]"));

    PAGED_CODE();

    ASSERT(Resolution);

    AcquireControl();

    NTSTATUS status;
    if (m_MasterClockFileObject) {
        KSPROPERTY property;
        property.Set = KSPROPSETID_Clock;
        property.Id = KSPROPERTY_CLOCK_RESOLUTION;
        property.Flags = KSPROPERTY_TYPE_GET;

        ULONG bytesReturned;
        status =
            KsSynchronousIoControlDevice(
                m_MasterClockFileObject,
                KernelMode,
                IOCTL_KS_PROPERTY,
                PVOID(&property),
                sizeof(property),
                PVOID(Resolution),
                sizeof(*Resolution),
                &bytesReturned);

        if (NT_SUCCESS(status) && 
            (bytesReturned != sizeof(*Resolution))) {
            status = STATUS_INVALID_BUFFER_SIZE;
        }
    } else {
        status = STATUS_DEVICE_NOT_READY;
    }

    ReleaseControl();

    return status;
}


STDMETHODIMP
CKsPin::
GetState(
    OUT PKSSTATE State
    )

/*++

Routine Description:

    This routine gets the current state of the reference clock.

Arguments:

    State -
        Contains a pointer to the location at which the state should be 
        deposited.

Return Value:

    Status.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::GetState]"));

    PAGED_CODE();

    ASSERT(State);

    AcquireControl();

    NTSTATUS status;
    if (m_MasterClockFileObject) {
        KSPROPERTY property;
        property.Set = KSPROPSETID_Clock;
        property.Id = KSPROPERTY_CLOCK_STATE;
        property.Flags = KSPROPERTY_TYPE_GET;

        ULONG bytesReturned;
        status =
            KsSynchronousIoControlDevice(
                m_MasterClockFileObject,
                KernelMode,
                IOCTL_KS_PROPERTY,
                PVOID(&property),
                sizeof(property),
                PVOID(State),
                sizeof(*State),
                &bytesReturned);

        if (NT_SUCCESS(status) && 
            (bytesReturned != sizeof(*State))) {
            status = STATUS_INVALID_BUFFER_SIZE;
        }
    } else {
        status = STATUS_DEVICE_NOT_READY;
    }

    ReleaseControl();

    return status;
}


STDMETHODIMP_(void)
CKsPin::
Disconnect(
    void
    )

/*++

Routine Description:

    This routine receives an indication that the connected pin is disconnecting.

Arguments:

    None.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::Disconnect]"));

    PAGED_CODE();

    //
    // Acquire control mutex so descriptor is stable.
    //
    AcquireControl();
    ASSERT(! m_ConnectionFileObject);
    ASSERT(m_ConnectedPinInterface);

    if (m_Ext.Public.Descriptor->Dispatch && 
        m_Ext.Public.Descriptor->Dispatch->Disconnect) {
        //
        // Tell the client.
        //
        m_Ext.Public.Descriptor->Dispatch->Disconnect(&m_Ext.Public);
    }

    m_ConnectedPinInterface->Release();
    m_ConnectedPinInterface = NULL;

    ReleaseControl();
}


STDMETHODIMP_(PKSPPROCESSPIN)
CKsPin::
GetProcessPin(
    void
    )

/*++

Routine Description:

    This routine returns a pointer to the process pin structure for the pin.

Arguments:
    
    None.

Return Value:

    A pointer to the process pin structure for the pin.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::GetProcessPin]"));

    PAGED_CODE();

    return &m_Process;
}


STDMETHODIMP
CKsPin::
AttemptBypass(
    void
    )

/*++

Routine Description:

    This routine attempts to make transport connections that bypass the
    connected pins.  This may fail if the connected pin is not a  pin
    or has not underdone circuit construction.  If the latter is true, the
    connecting pin will attempt bypass later, and all will be well.

Arguments:
    
    None.

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::AttemptBypass]"));

    PAGED_CODE();

    ASSERT(m_TransportSource);
    ASSERT(m_TransportSink);

    NTSTATUS status;
    if (! m_ConnectedPinInterface) {
        //
        // This is an extra-shell pin.  Don't need to try.
        //
        status = STATUS_SUCCESS;
    } else {
        
        PIKSTRANSPORT PreIntraSink = m_TransportSink;
        PIKSTRANSPORT PreIntraSource = m_TransportSource;

        //
        // This is an intra-shell pin.  Give it a try.
        //
        status = 
            m_ConnectedPinInterface->Bypass(
                m_TransportSource,m_TransportSink);

        //
        // If we bypassed the pins in the connection successfully, remember the
        // transports we had set up prior to completing the intra section
        // of the pipe.  This allows us to disconnect sections of a circuit
        // later.  Note that we do not hold refcount on the prebypassed
        // transports.  This means that we must be extraordinarily careful
        // about when we use them.
        //
        if (NT_SUCCESS (status)) {
            m_PreIntraSink = PreIntraSink;
            m_PreIntraSource = PreIntraSource;
        } else {
            m_PreIntraSink = m_PreIntraSource = NULL;
        }

        ASSERT((! m_TransportSource) || ! NT_SUCCESS(status));
        ASSERT((! m_TransportSink) || ! NT_SUCCESS(status));
    }

    return status;
}


STDMETHODIMP_(BOOLEAN)
CKsPin::
CaptureBypassRights(
    IN BOOLEAN TryState
    )

/*++

Routine Description:

    This routine allows only one thread to capture exclusive rights to bypass
    a connection.  It's an interlocked switch controlled by the sink pin in
    a connection.

Arguments:

    TryState -
        If TRUE, indicates that the thread wants to attempt to capture bypass
        rights.  If FALSE, indicates that the thread WITH bypass rights wants
        to release them.

Return Value:

    Success / Failure

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::CaptureBypassRights]"));

    //
    // Because of the property that the sink pin must exist when the source
    // pin exists, the sink is in control of the bypass rights.  If we're the
    // source, defer to the sink (it must exist).
    //
    if (m_ConnectionFileObject) {
        ASSERT (m_ConnectedPinInterface);

        return m_ConnectedPinInterface->CaptureBypassRights (TryState);

    } else {

        if (TryState) {
            return (InterlockedCompareExchange (&m_BypassRights, 1, 0) == 0);
        } else {
            BOOLEAN Release =
                (InterlockedCompareExchange (&m_BypassRights, 0, 1) == 1);

            //
            // If this assert fires, some thread without rights called
            // CaptureBypassRights (FALSE);
            //
            ASSERT (Release);

            return Release;

        }

    }

}


STDMETHODIMP
CKsPin::
Bypass(
    IN PIKSTRANSPORT Source,
    IN PIKSTRANSPORT Sink
    )

/*++

Routine Description:

    This routine makes transport connections that bypass the connected pins.

Arguments:

    Source -
        The connected pin's source of IRPs, which will become the new source
        of IRPs for our sink.

    Sink -
        The connected pin's destination for IRPs, which will become the new
        destination for IRPs for our source.

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::Bypass]"));

    PAGED_CODE();

    ASSERT(Source);
    ASSERT(Sink);

    //
    // Check for simultaneous bypass.  Prevent two pins that are simultaneously
    // going to try the bypass from both succeeding.
    //
    if (!CaptureBypassRights (TRUE)) {
        //
        // Both pins are simultaneously going to acquire.  Whichever gets the
        // bypass rights performs the bypass.  The one that didn't will return
        // failure.
        //
        return STATUS_INVALID_DEVICE_STATE;
    }

    //
    // NOTE: This is SIMPLY and ONLY to shut driver verifier deadlock detection
    // up.  Yes, there's a cyclic mutex grab here.  No because of the above,
    // it can **NEVER** cause a deadlock.
    //
    // If we fail this test and we're going up, we will attempt the bypass
    // later.  If we pass this test and are going down, the next test will
    // catch it in the mutex.
    //
    if (!m_TransportSource || !m_TransportSink) {
        CaptureBypassRights (FALSE);
        return STATUS_INVALID_DEVICE_STATE;
    }

    AcquireControl();

    NTSTATUS status;
    if (m_TransportSource && m_TransportSink) {

        //
        // Save the routing of the circuit before the bypass happened.  In
        // the failure case of building the circuit, we may be asked to
        // unbypass the connection.
        //
        PIKSTRANSPORT PreIntraSource = m_TransportSource;
        PIKSTRANSPORT PreIntraSink = m_TransportSink;

        //
        // We are ready...hook them up.
        //
        m_TransportSource->Connect(Sink,NULL,NULL,KSPIN_DATAFLOW_OUT);
        m_TransportSink->Connect(Source,NULL,NULL,KSPIN_DATAFLOW_IN);

        m_PreIntraSource = PreIntraSource;
        m_PreIntraSink = PreIntraSink;

        //
        // Release our transport connections.  The pin is no longer in
        // the circuit.
        //
        ASSERT(! m_TransportSource);
        ASSERT(! m_TransportSink);

        _DbgPrintF(DEBUGLVL_PIPES,("#### Pin%p.Bypass:  successful",this));

        status = STATUS_SUCCESS;
    } else {
        //
        // Not ready yet.  We will request bypass later.
        //
        ASSERT(! m_TransportSource);
        ASSERT(! m_TransportSink);
        status = STATUS_INVALID_DEVICE_STATE;
    }

    ReleaseControl();

    //
    // Release exclusive rights to the bypass switch.
    //
    CaptureBypassRights (FALSE);

    return status;
}


STDMETHODIMP
CKsPin::
AttemptUnbypass(
    )

/*++

Routine Description:

    This routine attempts to back out the bypass of two pins breaking an intra-
    pipe.  The pin remembers the connections it made when bypassed so that
    it can perform this operation.

Arguments:

    None

Return Value:

    Success / Failure

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::AttemptUnbypass]"));

    PAGED_CODE();

    if (!m_ConnectedPinInterface) {
        //
        // If the pin is an extra-pin, just return success; it was never
        // bypassed.
        //
        return STATUS_SUCCESS;
    }

    NTSTATUS Status = m_ConnectedPinInterface -> Unbypass ();
    if (NT_SUCCESS (Status)) Status = Unbypass ();

    return Status;

}


STDMETHODIMP
CKsPin::
Unbypass(
    )

/*++

Routine Description:

    This routine backs out the bypass of the current pin.

Arguments:

    None

Return Value:

    Success / Failure

--*/

{

    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::Unbypass]"));

    PAGED_CODE();

    //
    // If we we're not bypassed, return success automatically.
    //
    if (m_TransportSource || m_TransportSink)
        return STATUS_SUCCESS;

    ASSERT (m_PreIntraSink && m_PreIntraSource);
    if (!m_PreIntraSink || !m_PreIntraSource)
        return STATUS_UNSUCCESSFUL;

    PIKSTRANSPORT PreIntraSink = m_PreIntraSink;
    PIKSTRANSPORT PreIntraSource = m_PreIntraSource;

    //
    // Reroute the section of the circuit corresponding to the intra-
    // section around this pin.  The connection will automatically reset
    // m_PreIntraSink and m_PreIntraSource for safety.  We keep a local copy
    // on the stack.
    //
    PreIntraSource -> Connect (PIKSTRANSPORT(this), NULL, NULL,   
        KSPIN_DATAFLOW_OUT);
    PreIntraSink -> Connect (PIKSTRANSPORT(this), NULL, NULL,
        KSPIN_DATAFLOW_IN);

    ASSERT (m_PreIntraSource == NULL && m_PreIntraSink == NULL);

    return STATUS_SUCCESS;

}


STDMETHODIMP_(void)
CKsPin::
Work(
    void
    )

/*++

Routine Description:

    This routine performs work in a worker thread.  In particular, it sends
    IRPs to the connected pin using IoCallDriver().

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::Work]"));

    PAGED_CODE();

    //
    // Send all IRPs in the queue.
    //
    do {
        PIRP irp =
            KsRemoveIrpFromCancelableQueue(
                &m_IrpsToSend.ListEntry,
                &m_IrpsToSend.SpinLock,
                KsListEntryHead,
                KsAcquireAndRemoveOnlySingleItem);

        //
        // Irps may have been cancelled, but the loop must still run through
        // the reference counting.
        //
        if (irp) {
            if (m_Flushing || (m_State == KSSTATE_STOP)) {
                if (PKSSTREAM_HEADER(irp->AssociatedIrp.SystemBuffer)->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_ENDOFSTREAM) {
                    _DbgPrintF(DEBUGLVL_FLOWEXCEPTIONS,("#### Pin%p.Work:  shunting EOS irp%p",this,irp));
                }

                //
                // Shunt IRPs to the next component if we are reset or stopped.
                //
                _DbgPrintF(DEBUGLVL_FLOWEXCEPTIONS,("#### Pin%p.Work:  shunting irp%p",this,irp));
                KsLog(&m_Log,KSLOGCODE_PIN_SEND,irp,NULL);
                KspTransferKsIrp(m_TransportSink,irp);
            } else {
                if (PKSSTREAM_HEADER(irp->AssociatedIrp.SystemBuffer)->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_ENDOFSTREAM) {
                    _DbgPrintF(DEBUGLVL_FLOWEXCEPTIONS,("#### Pin%p.Work:  forwarding EOS irp%p",this,irp));
                }

                //
                // Set up the next stack location for the callee.  
                //
                IoCopyCurrentIrpStackLocationToNext(irp);

                PIO_STACK_LOCATION irpSp = IoGetNextIrpStackLocation(irp);

                irpSp->Parameters.DeviceIoControl.IoControlCode =
                    (m_Ext.Public.DataFlow == KSPIN_DATAFLOW_OUT) ?
                     IOCTL_KS_WRITE_STREAM : IOCTL_KS_READ_STREAM;
                irpSp->DeviceObject = m_ConnectionDeviceObject;
                irpSp->FileObject = m_ConnectionFileObject;

                //
                // Add the IRP to the list of outstanding IRPs.
                //
                PIRPLIST_ENTRY irpListEntry = IRPLIST_ENTRY_IRP_STORAGE(irp);
                irpListEntry->Irp = irp;
                ExInterlockedInsertTailList(
                    &m_IrpsOutstanding.ListEntry,
                    &irpListEntry->ListEntry,
                    &m_IrpsOutstanding.SpinLock);

                IoSetCompletionRoutine(
                    irp,
                    CKsPin::IoCompletionRoutine,
                    PVOID(this),
                    TRUE,
                    TRUE,
                    TRUE);

                m_StreamingIrpsSourced++;
                IoCallDriver(m_ConnectionDeviceObject,irp);
            }
        }
    } while (KsDecrementCountedWorker(m_Worker));
}

#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif // ALLOC_PRAGMA


BOOLEAN
CKsPin::
UpdateProcessPin(
    )

/*++

Routine Description:

    This routine updates a process pin via the BytesUsed, Terminate fields
    as UnprepareProcessPipeSection would.  Typically, this will be used by
    clients in the context of their processing dispatch in filter-centric
    processing when they wish to advance the process pin's pointers into
    the data stream.  Note: this will update every process pin on the
    process pipe section for our process pin.

Arguments:

Return Value:

    As PrepareProcessPipeSection. 

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::UpdateProcessPin]"));

    ULONG Flags = 0;

    //
    // If there is no pipe (they call this in a stop state), return FALSE 
    //
    if (m_Process.PipeSection == NULL) return FALSE;

    return m_Parent -> ReprepareProcessPipeSection (
        m_Process.PipeSection,
        &Flags
    );

}


STDMETHODIMP
CKsPin::
TransferKsIrp(
    IN PIRP Irp,
    OUT PIKSTRANSPORT* NextTransport
    )

/*++

Routine Description:

    This routine handles the arrival of a streaming IRP via the  
    transport.

Arguments:

    Irp -
        Contains a pointer to the streaming IRP to be transferred.

    NextTransport -
        Contains a pointer to a location at which to deposit a pointer
        to the next transport interface to recieve the IRP.  May be set
        to NULL indicating the IRP should not be forwarded further.

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::TransferKsIrp]"));

    ASSERT(NextTransport);

    NTSTATUS status;

    KsLog(&m_Log,KSLOGCODE_PIN_RECV,Irp,NULL);

    if (m_ConnectionFileObject) {
        //
        // Source pin.
        //
        if (m_Flushing || (m_State == KSSTATE_STOP) ||
            !NT_SUCCESS(Irp->IoStatus.Status)) {
            //
            // Shunt IRPs to the next component if we are reset or stopped or
            // the Irp has non-successful status.
            //
            _DbgPrintF(DEBUGLVL_FLOWEXCEPTIONS,("#### Pin%p.TransferKsIrp:  shunting irp%p",this,Irp));
            KsLog(&m_Log,KSLOGCODE_PIN_SEND,Irp,NULL);
            *NextTransport = m_TransportSink;

            status = STATUS_SUCCESS;

        } else {
            //
            // Send the IRP to the next device.
            //
            KsAddIrpToCancelableQueue(
                &m_IrpsToSend.ListEntry,
                &m_IrpsToSend.SpinLock,
                Irp,
                KsListEntryTail,
                NULL);

            KsIncrementCountedWorker(m_Worker);
            *NextTransport = NULL;

            status = STATUS_PENDING;
        }

    } else {
        //
        // Sink pin:  complete the IRP.
        //
        KsLog(&m_Log,KSLOGCODE_PIN_SEND,Irp,NULL);
        Irp->IoStatus.Information = 
            IoGetCurrentIrpStackLocation(Irp)->
                Parameters.DeviceIoControl.OutputBufferLength;
        IoCompleteRequest(Irp,IO_NO_INCREMENT);
        *NextTransport = NULL;

        //
        // Take the irp out of circulation.  This will release our hold
        // on circuit shutdown.
        //
        DecrementIrpCirculation ();

        status = STATUS_PENDING;
    }

    return status;
}


STDMETHODIMP_(void)
CKsPin::
DiscardKsIrp(
    IN PIRP Irp,
    OUT PIKSTRANSPORT* NextTransport
    )

/*++

Routine Description:

    This routine discards a streaming IRP.

Arguments:

    Irp -
        Contains a pointer to the streaming IRP to be discarded.

    NextTransport -
        Contains a pointer to a location at which to deposit a pointer
        to the next transport interface to recieve the IRP.  May be set
        to NULL indicating the IRP should not be forwarded further.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::DiscardKsIrp]"));

    ASSERT(NextTransport);

    if (m_ConnectionFileObject) {
        //
        // Source pin.  Send it along.
        //
        *NextTransport = m_TransportSink;
    } else {
        //
        // Sink pin:  complete the IRP.
        //
        Irp->IoStatus.Information = 
            IoGetCurrentIrpStackLocation(Irp)->
                Parameters.DeviceIoControl.OutputBufferLength;
        IoCompleteRequest(Irp,IO_NO_INCREMENT);
        *NextTransport = NULL;

        DecrementIrpCirculation ();
    }
}


void
CKsPin::
DecrementIrpCirculation (
    void
    )

/*++

Routine Description:

    Account for an Irp on a sink pin removed from circulation.  This will
    signal the stop event on a sink pin.

Arguments:

    None

Return Value:

    None

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::DecrementIrpCirculation]"));

    //
    // This will only get signalled if a sink pin has transitioned to stop
    // and is waiting on Irps coming back around the circuit to the sink
    // pin.
    //
    if (! InterlockedDecrement(PLONG(&m_ActiveFrameCountPlusOne))) {
        KeSetEvent (&m_StopEvent, IO_NO_INCREMENT, FALSE);
    }

}


void
CKsPin::
CancelIrpsOutstanding(
    void
    )
/*++

Routine Description:

    Cancels all IRP's on the outstanding IRPs list.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::CancelIrpsOutstanding]"));

    //
    // This algorithm searches for uncancelled IRPs starting at the head of
    // the list.  Every time such an IRP is found, it is cancelled, and the
    // search starts over at the head.  This will be very efficient, generally,
    // because IRPs will be removed by the completion routine when they are
    // cancelled.
    //
    for (;;) {
        //
        // Take the spinlock and search for an uncancelled IRP.  Because the
        // completion routine acquires the same spinlock, we know IRPs on this
        // list will not be completely cancelled as long as we have the 
        // spinlock.
        //
        PIRP irp = NULL;
        KIRQL oldIrql;
        KeAcquireSpinLock(&m_IrpsOutstanding.SpinLock,&oldIrql);
        for(PLIST_ENTRY listEntry = m_IrpsOutstanding.ListEntry.Flink;
            listEntry != &m_IrpsOutstanding.ListEntry;
            listEntry = listEntry->Flink) {
                PIRPLIST_ENTRY irpListEntry = 
                    CONTAINING_RECORD(listEntry,IRPLIST_ENTRY,ListEntry);

                if (! irpListEntry->Irp->Cancel) {
                    irp = irpListEntry->Irp;
                    _DbgPrintF(DEBUGLVL_CANCEL,("#### Pin%p.CancelIrpsOutstanding:  uncancelled IRP %p",this,irp));
                    break;
                } else {
                    _DbgPrintF(DEBUGLVL_CANCEL,("#### Pin%p.CancelIrpsOutstanding:  cancelled IRP %p",this,irpListEntry->Irp));
                }
            }

        //
        // If there are no uncancelled IRPs, we are done.
        //
        if (! irp) {
            KeReleaseSpinLock(&m_IrpsOutstanding.SpinLock,oldIrql);
            break;
        }

        //
        // Mark the IRP cancelled whether we can call the cancel routine now
        // or not.
        // 
        irp->Cancel = TRUE;

        //
        // If the cancel routine has already been removed, then this IRP
        // can only be marked as canceled, and not actually canceled, as
        // another execution thread has acquired it. The assumption is that
        // the processing will be completed, and the IRP removed from the list
        // some time in the near future.
        //
        // If the element has not been acquired, then acquire it and cancel it.
        // Otherwise, it's time to find another victim.
        //
        PDRIVER_CANCEL driverCancel = IoSetCancelRoutine(irp,NULL);

        //
        // Since the Irp has been acquired by removing the cancel routine, or
        // there is no cancel routine and we will not be cancelling, it is safe 
        // to release the list lock.
        //
        KeReleaseSpinLock(&m_IrpsOutstanding.SpinLock,oldIrql);

        if (driverCancel) {
            _DbgPrintF(DEBUGLVL_CANCEL,("#### Pin%p.CancelIrpsOutstanding:  cancelling IRP %p",this,irp));
            //
            // This needs to be acquired since cancel routines expect it, and
            // in order to synchronize with NTOS trying to cancel Irp's.
            //
            IoAcquireCancelSpinLock(&irp->CancelIrql);
            driverCancel(IoGetCurrentIrpStackLocation(irp)->DeviceObject,irp);
        } else {
            _DbgPrintF(DEBUGLVL_CANCEL,("#### Pin%p.CancelIrpsOutstanding:  uncancelable IRP %p",this,irp));
        }
    }
}


STDMETHODIMP_(void)
CKsPin::
GenerateConnectionEvents(
    IN ULONG OptionsFlags
    )

/*++

Routine Description:

    This routine generates connection events on the completion of streaming
    IRP processing.

Arguments:

    OptionsFlags -
        Contains the options flags from the stream header of the IRP.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::GenerateConnectEvents]"));

    //
    // Signal events based on option flags.
    //
    if (OptionsFlags & KSSTREAM_HEADER_OPTIONSF_ENDOFSTREAM) {
        _DbgPrintF(DEBUGLVL_EVENTS,("#### Pin%p.GenerateConnectEvents:  KSEVENT_CONNECTION_ENDOFSTREAM",this));
        KsGenerateEvents(
            &m_Ext.Public,
            &g_KSEVENTSETID_Connection,
            KSEVENT_CONNECTION_ENDOFSTREAM,
            0,
            NULL,
            NULL,
            NULL);
    }
    
    if (OptionsFlags & KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY) {
        _DbgPrintF(DEBUGLVL_EVENTS,("#### Pin%p.GenerateConnectEvents:  KSEVENT_CONNECTION_DATADISCONTINUITY",this));
        KsGenerateEvents(
            &m_Ext.Public,
            &g_KSEVENTSETID_Connection,
            KSEVENT_CONNECTION_DATADISCONTINUITY,
            0,
            NULL,
            NULL,
            NULL);
    }
    
    if (OptionsFlags & KSSTREAM_HEADER_OPTIONSF_TIMEDISCONTINUITY) {
        _DbgPrintF(DEBUGLVL_EVENTS,("#### Pin%p.GenerateConnectEvents:  KSEVENT_CONNECTION_TIMEDISCONTINUITY",this));
        KsGenerateEvents(
            &m_Ext.Public,
            &g_KSEVENTSETID_Connection,
            KSEVENT_CONNECTION_TIMEDISCONTINUITY,
            0,
            NULL,
            NULL,
            NULL);
    }            
}


NTSTATUS
CKsPin::
IoCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine handles the completion of an IRP.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::IoCompletionRoutine] 0x%08x",Irp));

//    ASSERT(DeviceObject);
    ASSERT(Irp);
    ASSERT(Context);

    CKsPin *pin = (CKsPin *) Context;

    //
    // Count IRPs waiting to get transferred.
    //
    InterlockedIncrement(&pin->m_IrpsWaitingToTransfer);

    //
    // Mark this IRP ready to transfer.
    //
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);
    ASSERT(irpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL);
    irpSp->MajorFunction = 0;

    //
    // Loop while there are IRPs waiting to transfer.  This loop breaks out
    // if the head IRP on the list is not ready.
    //
    NTSTATUS status = STATUS_MORE_PROCESSING_REQUIRED;
    while (pin->m_IrpsWaitingToTransfer) {
        //
        // Check the head of the list to see if it is ready to transfer.
        //
        KIRQL oldIrql;
        KeAcquireSpinLock(&pin->m_IrpsOutstanding.SpinLock,&oldIrql);
        PIRP IrpToTransfer;
        if (IsListEmpty(&pin->m_IrpsOutstanding.ListEntry)) {
            //
            // The list is empty.  Someone else got here first.
            //
            IrpToTransfer = NULL;
        } else {
            //
            // Check the head.
            //
            PIRPLIST_ENTRY irpListEntry = 
                CONTAINING_RECORD(
                    pin->m_IrpsOutstanding.ListEntry.Flink,
                    IRPLIST_ENTRY,
                    ListEntry);
            irpSp =
                CONTAINING_RECORD(
                    irpListEntry,
                    IO_STACK_LOCATION,
                    Parameters);

            if (irpSp->MajorFunction == 0) {
                //
                // This one is ready to go.
                //
                IrpToTransfer = irpListEntry->Irp;
                RemoveEntryList(&irpListEntry->ListEntry);
                irpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
            } else {
                //
                // Not ready yet...got IRPs out of order.
                //
                IrpToTransfer = NULL;
            }
        }
        KeReleaseSpinLock(&pin->m_IrpsOutstanding.SpinLock,oldIrql);

        if (! IrpToTransfer) {
            break;
        }

        InterlockedDecrement(&pin->m_IrpsWaitingToTransfer);
        if (IrpToTransfer != Irp) {
            pin->m_IrpsCompletedOutOfOrder++;
        }

#if (DBG)
        if (IrpToTransfer->Cancel) {
            _DbgPrintF(DEBUGLVL_FLOWEXCEPTIONS,("#### Pin%p.IoCompletionRoutine:  got cancelled IRP %p",pin,IrpToTransfer));
        }
        if (! NT_SUCCESS(IrpToTransfer->IoStatus.Status)) {
            _DbgPrintF(DEBUGLVL_FLOWEXCEPTIONS,("#### Pin%p.IoCompletionRoutine:  got failed IRP %p status %08x",pin,IrpToTransfer,IrpToTransfer->IoStatus.Status));
        }
#endif

        NTSTATUS status;
        if (pin->m_TransportSink) {
            //
            // The transport circuit is up, so we can forward the IRP.
            //
            KsLog(&pin->m_Log,KSLOGCODE_PIN_SEND,IrpToTransfer,NULL);

            if ( STATUS_INVALID_DEVICE_REQUEST != 
                    IrpToTransfer->IoStatus.Status  &&
                STATUS_INVALID_DEVICE_STATE != 
                    IrpToTransfer->IoStatus.Status ) {
	            status = KspTransferKsIrp(pin->m_TransportSink,IrpToTransfer);
            } else {
            	//
            	// connected device is removed, need to shut off the queue from 
            	// sending more Irps which would be a tight loop doing no good but harm.
            	//
            	KspDiscardKsIrp(pin->m_TransportSink,IrpToTransfer);
            	status = STATUS_INVALID_DEVICE_REQUEST;
            }
            
        } else {
            //
            // The transport circuit is down.  This means the IRP came from another
            // filter, and we can just complete this IRP.
            //
            KsLog(&pin->m_Log,KSLOGCODE_PIN_SEND,IrpToTransfer,NULL);
            IoCompleteRequest(IrpToTransfer,IO_NO_INCREMENT);
            status = STATUS_SUCCESS;
        }
    }

    //
    // Transport objects typically return STATUS_PENDING meaning that the
    // IRP won't go back the way it came.
    //
    if (status == STATUS_PENDING) {
        status = STATUS_MORE_PROCESSING_REQUIRED;
    }

    return status;
}

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA


STDMETHODIMP_(void)
CKsPin::
Connect(
    IN PIKSTRANSPORT NewTransport OPTIONAL,
    OUT PIKSTRANSPORT *OldTransport OPTIONAL,
    OUT PIKSTRANSPORT *BranchTransport OPTIONAL,
    IN KSPIN_DATAFLOW DataFlow
    )

/*++

Routine Description:

    This routine establishes a  transport connection.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::Connect]"));

    PAGED_CODE();

    //
    // If we're changing the connections of this pin, reset the pre-intra
    // pointers.  The bypass routine will set them.
    //
    m_PreIntraSink = m_PreIntraSource = NULL;

    KspStandardConnect(
        NewTransport,
        OldTransport,
        BranchTransport,
        DataFlow,
        PIKSTRANSPORT(this),
        &m_TransportSource,
        &m_TransportSink);
}


STDMETHODIMP
CKsPin::
SetDeviceState(
    IN KSSTATE NewState,
    IN KSSTATE OldState,
    OUT PIKSTRANSPORT* NextTransport
    )

/*++

Routine Description:

    This routine handles notification that the device state has changed.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::SetDeviceState(0x%08x)]",this));
    _DbgPrintF(DEBUGLVL_DEVICESTATE,("#### Pin%p.SetDeviceState:  from %d to %d",this,OldState,NewState));

    PAGED_CODE();

    ASSERT(NextTransport);

    if (m_State != NewState) {
        if (NewState == KSSTATE_ACQUIRE && OldState == KSSTATE_STOP)
            //
            // The pin doesn't disappear with the circuit; therefore, we
            // have to kick the irp counter back up so that when the pin
            // starts again, there isn't an invalid count.
            //
            m_ActiveFrameCountPlusOne = 1;

        m_State = NewState;

        if (NewState > OldState) {
            *NextTransport = m_TransportSink;
        } else {
            *NextTransport = m_TransportSource;
        }

        if (NewState == KSSTATE_STOP) {
            CancelIrpsOutstanding();
        }

        //
        // If this is an external sink pin, its participation in stack depth
        // calculations needs to be controlled based on state.
        //
        if ((! m_ConnectionFileObject) && 
            (! m_ConnectedPinInterface) && 
            ((OldState == KSSTATE_STOP) || (NewState == KSSTATE_STOP))) {

            //
            // Only set the target if we're actually passing data from an
            // extra-sink through an extra-source at some later point.  This
            // should only happen on the top component of the pipe and should
            // be safe because the state transition holds the master sections'
            // related control mutex.
            //
            if (OldState == KSSTATE_STOP && m_Process.InPlaceCounterpart) {
                CKsPin *TargetPinSource = CKsPin::FromStruct (
                    m_Process.InPlaceCounterpart->Pin
                    );

                ASSERT (TargetPinSource->m_ConnectionDeviceObject);

                KsSetTargetDeviceObject (
                    m_Header,
                    TargetPinSource->m_ConnectionDeviceObject
                    );
            }

            if (NewState == KSSTATE_STOP) {
                //
                // Once we stop, we're no longer an in-place, so we get rid of
                // the target device object.
                //
                KsSetTargetDeviceObject (
                    m_Header,
                    NULL
                    );
            }

            KsSetTargetState(
                reinterpret_cast<KSOBJECT_HEADER>(m_Header),
                (OldState == KSSTATE_STOP) ? 
                    KSTARGET_STATE_ENABLED : 
                    KSTARGET_STATE_DISABLED);
            KsRecalculateStackDepth(
                *reinterpret_cast<KSDEVICE_HEADER*>(
                    m_Ext.Device->GetStruct()->
                        FunctionalDeviceObject->DeviceExtension),
                FALSE);
        }
    } else {
        //
        // Block until all IRPs have made their way back around to the
        // sink pin.  In the event this is not a sink pin, this will not
        // block because the circulation count is always 1.
        //
        if (NewState == KSSTATE_STOP && OldState == KSSTATE_ACQUIRE && 
            !m_ConnectionFileObject) {

            if (InterlockedDecrement (PLONG(&m_ActiveFrameCountPlusOne))) {
                LARGE_INTEGER timeout;
                NTSTATUS status;

#if DBG
                _DbgPrintF(DEBUGLVL_TERSE,("#### Pin%p.SetDeviceState: waiting for %d active IRPs to return",this,m_ActiveFrameCountPlusOne));
                timeout.QuadPart = -150000000L;
                status =
                    KeWaitForSingleObject (
                        &m_StopEvent,
                        Suspended,
                        KernelMode,
                        FALSE,
                        &timeout);
                    
                if (status == STATUS_TIMEOUT) {
                    _DbgPrintF(DEBUGLVL_TERSE,("#### Pin%p.SetDeviceState: WAITED 15 SECONDS",this));
                    _DbgPrintF(DEBUGLVL_TERSE,("#### Pin%p.SetDeviceState: waiting for %d active IRPs to return", this, m_ActiveFrameCountPlusOne));

                    DbgPrintCircuit(this,1,0);
#endif // DBG

                    status = 
                        KeWaitForSingleObject(
                            &m_StopEvent,
                            Suspended,
                            KernelMode,
                            FALSE,
                            NULL);
#if DBG
                }
                _DbgPrintF(DEBUGLVL_TERSE,("#### Pin%p.SetDeviceState: done waiting",this));
#endif // DBG
            }
        }

        *NextTransport = NULL;
    }

    return STATUS_SUCCESS;
}


STDMETHODIMP_(void)
CKsPin::
GetTransportConfig(
    OUT PKSPTRANSPORTCONFIG Config,
    OUT PIKSTRANSPORT* NextTransport,
    OUT PIKSTRANSPORT* PrevTransport
    )

/*++

Routine Description:

    This routine gets transport configuration information.

Arguments:

    Config -
        Contains a pointer to the location where configuration requirements
        for this object should be deposited.

    NextTransport -
        Contains a pointer to the location at which the next transport
        interface should be deposited.

    PrevTransport -
        Contains a pointer to the location at which the previous transport
        interfaction should be deposited.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::GetTransportConfig]"));

    PAGED_CODE();

    ASSERT(Config);
    ASSERT(NextTransport);
    ASSERT(PrevTransport);

    //
    // Build the transport type.
    //
    if (m_ConnectionFileObject) {
        Config->TransportType = KSPTRANSPORTTYPE_PINSOURCE;
    } else {
        Config->TransportType = KSPTRANSPORTTYPE_PINSINK;
    }

    if (m_ConnectedPinInterface) {
        Config->TransportType |= KSPTRANSPORTTYPE_PININTRA;
    } else {
        Config->TransportType |= KSPTRANSPORTTYPE_PINEXTRA;
    }

    if (m_Ext.Public.DataFlow == KSPIN_DATAFLOW_OUT) {
        Config->TransportType |= KSPTRANSPORTTYPE_PINOUTPUT;
    } else {
        Config->TransportType |= KSPTRANSPORTTYPE_PININPUT;
    }

    //
    // External sinks have unknown disposition.
    //
    if ((! m_ConnectionFileObject) && (! m_ConnectedPinInterface)) {
        Config->IrpDisposition = KSPIRPDISPOSITION_UNKNOWN;
    } else {
        Config->IrpDisposition = KSPIRPDISPOSITION_NONE;
    }

    //
    // Only external sources have significant stack depth.
    //
    if (m_ConnectionFileObject && ! m_ConnectedPinInterface) {
        Config->StackDepth = 
            m_ConnectionDeviceObject->StackSize + 1;
    } else {
        Config->StackDepth = 1;
    }

    *NextTransport = m_TransportSink;
    *PrevTransport = m_TransportSource;
}

#if DBG

#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif // ALLOC_PRAGMA


void
CKsPin::
RollCallDetail(
    void
    )

/*++

Routine Description:

    This routine prints detailed information for the transport rollcall.

Arguments:

    None.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::RollCallDetail]"));

    DbgPrint("        IRPs waiting to transfer = %d\n",m_IrpsWaitingToTransfer);
    DbgPrint("        IRPs outstanding\n");
    KIRQL oldIrql;
    KeAcquireSpinLock(&m_IrpsOutstanding.SpinLock,&oldIrql);
    for(PLIST_ENTRY listEntry = m_IrpsOutstanding.ListEntry.Flink;
        listEntry != &m_IrpsOutstanding.ListEntry;
        listEntry = listEntry->Flink) {
            PIRPLIST_ENTRY irpListEntry = 
                CONTAINING_RECORD(listEntry,IRPLIST_ENTRY,ListEntry);
            DbgPrint("            IRP %p\n",irpListEntry->Irp);
    }
    KeReleaseSpinLock(&m_IrpsOutstanding.SpinLock,oldIrql);

    DbgPrint("        IRPs to send\n");
    KeAcquireSpinLock(&m_IrpsToSend.SpinLock,&oldIrql);
    for(listEntry = m_IrpsToSend.ListEntry.Flink;
        listEntry != &m_IrpsToSend.ListEntry;
        listEntry = listEntry->Flink) {
            PIRP irp = 
                CONTAINING_RECORD(listEntry,IRP,Tail.Overlay.ListEntry);
            DbgPrint("            IRP %p\n",irp);
    }
    KeReleaseSpinLock(&m_IrpsToSend.SpinLock,oldIrql);
}

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA

#endif


STDMETHODIMP_(void)
CKsPin::
SetTransportConfig(
    IN const KSPTRANSPORTCONFIG* Config,
    OUT PIKSTRANSPORT* NextTransport,
    OUT PIKSTRANSPORT* PrevTransport
    )

/*++

Routine Description:

    This routine sets transport configuration information.

Arguments:

    Config -
        Contains a pointer to the new configuration settings for this object.

    NextTransport -
        Contains a pointer to the location at which the next transport
        interface should be deposited.

    PrevTransport -
        Contains a pointer to the location at which the previous transport
        interfaction should be deposited.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::SetTransportConfig]"));

    PAGED_CODE();

    ASSERT(Config);
    ASSERT(NextTransport);
    ASSERT(PrevTransport);

#if DBG
    if (Config->IrpDisposition == KSPIRPDISPOSITION_ROLLCALL) {
        ULONG references = AddRef() - 1; Release();
        DbgPrint("    Pin%p %d (%s,%s) refs=%d\n",this,m_Ext.Public.Id,m_ConnectionFileObject ? "src" : "snk",m_Ext.Public.DataFlow == KSPIN_DATAFLOW_OUT ? "out" : "in",references);
        if (Config->StackDepth) {
            RollCallDetail();
        }
    } else 
#endif
    {
        //
        // Set the minimum stack depth in the header.  If this is a external
        // sink pin, the 'target' will get enabled on the transition to
        // acquire.
        //
        m_Header->MinimumStackDepth = Config->StackDepth;
    }

    *NextTransport = m_TransportSink;
    *PrevTransport = m_TransportSource;
}


STDMETHODIMP_(void)
CKsPin::
ResetTransportConfig(
    OUT PIKSTRANSPORT* NextTransport,
    OUT PIKSTRANSPORT* PrevTransport
    )

/*++

Routine Description:

    Reset the transport configuration for the requestor.  This indicates that
    something is wrong with the pipe and that any previously set configuration
    is now invalid.

Arguments:

    NextTransport -
        Contains a pointer to the location at which the next transport
        interface should be depobranchd.

    PrevTransport -
        Contains a pointer to the location at which the previous transport
        interfaction should be depobranchd.

Return Value:

    None

--*/

{

    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::ResetTransportConfig]"));

    PAGED_CODE ();

    ASSERT (NextTransport);
    ASSERT (PrevTransport);

    m_Header->MinimumStackDepth = 0;

    *NextTransport = m_TransportSink;
    *PrevTransport = m_TransportSource;

}


STDMETHODIMP_(void)
CKsPin::
SetResetState(
    IN KSRESET ksReset,
    OUT PIKSTRANSPORT* NextTransport
    )

/*++

Routine Description:

    This routine handles notification that the reset state has changed.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::SetResetState]"));

    PAGED_CODE();

    ASSERT(NextTransport);

    if (m_Flushing != (ksReset == KSRESET_BEGIN)) {
        *NextTransport = m_TransportSink;
        m_Flushing = (ksReset == KSRESET_BEGIN);
        if (m_Flushing) {
            CancelIrpsOutstanding();
        }
    } else {
        *NextTransport = NULL;
    }
}


NTSTATUS
CKsPin::
DispatchCreateAllocator(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine dispatches create IRPs to create allocators.

Arguments:

    DeviceObject -
        Contains a pointer to the device object.

    Irp -
        Contains a pointer to the create IRP.

Return Value:

    STATUS_SUCCESS or error status.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::DispatchCreateAllocator]"));

    PAGED_CODE();

    ASSERT(DeviceObject);
    ASSERT(Irp);

    //
    // Get a pointer to the target object.
    //
    CKsPin *pin = CKsPin::FromCreateIrp(Irp);

    pin->AcquireControl();

    _DbgPrintF(DEBUGLVL_ALLOCATORS,("#### Pin%p.DispatchCreateAllocator",pin));

    NTSTATUS status;
    if ((pin->m_Ext.Public.Descriptor->Dispatch) &&
        (pin->m_Ext.Public.Descriptor->Dispatch->Allocator)) {
        //
        // Client wants to implement the allocator.
        //
        status =
            KsCreateDefaultAllocatorEx(
                Irp,
                &pin->m_Ext.Public,
                pin->m_Ext.Public.Descriptor->Dispatch->Allocator->Allocate,
                pin->m_Ext.Public.Descriptor->Dispatch->Allocator->Free,
                PFNKSINITIALIZEALLOCATOR(
                    pin->m_Ext.Public.Descriptor->Dispatch->Allocator->InitializeAllocator),
                pin->m_Ext.Public.Descriptor->Dispatch->Allocator->DeleteAllocator);
    } else {
        //
        // Client is not implementing an allocator.  Create the default.
        //
        status = KsCreateDefaultAllocator(Irp);
    }

    pin->ReleaseControl();

    if (status != STATUS_PENDING) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp,IO_NO_INCREMENT);
    }

    return status;
}


NTSTATUS
CKsPin::
DispatchCreateClock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine dispatches create IRPs to create clocks.

Arguments:

    DeviceObject -
        Contains a pointer to the device object.

    Irp -
        Contains a pointer to the create IRP.

Return Value:

    STATUS_SUCCESS or error status.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::DispatchCreateClock]"));

    PAGED_CODE();

    ASSERT(DeviceObject);
    ASSERT(Irp);

    //
    // Get a pointer to the target object.
    //
    CKsPin *pin = CKsPin::FromCreateIrp(Irp);

    pin->AcquireControl();

    //
    // Create a clock if the client wants to.  We do not require the clock flag
    // if there are dispatch functions.  This prevents some client head-
    // scratching.
    //
    NTSTATUS status;
    if ((pin->m_Ext.Public.Descriptor->Dispatch &&
         pin->m_Ext.Public.Descriptor->Dispatch->Clock) ||
        (pin->m_Ext.Public.Descriptor->Flags & KSPIN_FLAG_IMPLEMENT_CLOCK)) {
        //
        // Create the default clock if we need to.
        //
        if (! pin->m_DefaultClock) {
            KeInitializeSpinLock(&pin->m_DefaultClockLock);
            if (pin->m_Ext.Public.Descriptor->Dispatch &&
                pin->m_Ext.Public.Descriptor->Dispatch->Clock) {
                const KSCLOCK_DISPATCH* dispatch = 
                    pin->m_Ext.Public.Descriptor->Dispatch->Clock;
                //
                // If a resolution function was supplied, call it to get the
                // clock resolution.
                //
                KSRESOLUTION resolution;
                if (dispatch->Resolution) {
                    dispatch->Resolution(&pin->m_Ext.Public,&resolution);
                }
                status =
                    KsAllocateDefaultClockEx(
                        &pin->m_DefaultClock,
                        &pin->m_Ext.Public,
                        PFNKSSETTIMER(dispatch->SetTimer),
                        PFNKSCANCELTIMER(dispatch->CancelTimer),
                        PFNKSCORRELATEDTIME(dispatch->CorrelatedTime),
                        dispatch->Resolution ? &resolution : NULL,
                        0);
            } else {
                status =
                    KsAllocateDefaultClockEx(
                        &pin->m_DefaultClock,
                        &pin->m_Ext.Public,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        0);
            }
        } else {
            status = STATUS_SUCCESS;
        }

        //
        // Create the requested clock.
        //
        if (NT_SUCCESS(status)) {
            status = KsCreateDefaultClock(Irp,pin->m_DefaultClock);
        }
    } else {
        status = STATUS_INVALID_DEVICE_REQUEST;
    }

    pin->ReleaseControl();

    if (status != STATUS_PENDING) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp,IO_NO_INCREMENT);
    }

    return status;
}


NTSTATUS
CKsPin::
DispatchCreateNode(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine dispatches create IRPs to create nodes.

Arguments:

    DeviceObject -
        Contains a pointer to the device object.

    Irp -
        Contains a pointer to the create IRP.

Return Value:

    STATUS_SUCCESS or error status.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::DispatchCreateNode]"));

    PAGED_CODE();

    ASSERT(DeviceObject);
    ASSERT(Irp);

    //
    // Get a pointer to the target object.
    //
    CKsPin *pin = CKsPin::FromCreateIrp(Irp);

    //
    // Tell the filter to do the work.  This is done because the filter has
    // the node descriptors.
    //
    NTSTATUS status =
        pin->m_Parent->CreateNode(
            Irp,
            pin,
            pin->m_Ext.Public.Context,
            &pin->m_ChildNodeList);

    if (status != STATUS_PENDING) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp,IO_NO_INCREMENT);
    }

    return status;
}


NTSTATUS
CKsPin::
DispatchDeviceIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine dispatches IOCTL IRPs.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::DispatchDeviceIoControl]"));

    PAGED_CODE();

    ASSERT(DeviceObject);
    ASSERT(Irp);

    NTSTATUS status = STATUS_INVALID_DEVICE_REQUEST;

    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);
    ASSERT(irpSp);

    //
    // Get a pointer to the target object.
    //
    CKsPin *pin = CKsPin::FromIrp(Irp);

    //
    // log perf johnlee
    //
    KSPERFLOGS (
       	PKSSTREAM_HEADER pKsStreamHeader;
       	pKsStreamHeader = (PKSSTREAM_HEADER)Irp->AssociatedIrp.SystemBuffer;
       	ULONG	TimeStampMs;
       	ULONG	TotalSize;
       	ULONG	HeaderSize;
       	ULONG 	BufferSize;

        switch (irpSp->Parameters.DeviceIoControl.IoControlCode)
        {      
            case IOCTL_KS_READ_STREAM: {
				//
				// compute total size
				//
            	TotalSize = 0;
            	if ( pKsStreamHeader ) {
            		BufferSize = irpSp->Parameters.DeviceIoControl.OutputBufferLength;
	           		while ( BufferSize >= pKsStreamHeader->Size ) {
	           			BufferSize -= pKsStreamHeader->Size;
	           			TotalSize += pKsStreamHeader->FrameExtent;
	           		}
	           		ASSERT( 0 == BufferSize );
            	}
                //KdPrint(("PerfIsAnyGroupOn=%x\n", PerfIsAnyGroupOn()));
                KS2PERFLOG_PRECEIVE_READ( DeviceObject, Irp, TotalSize );
            } break;

            case IOCTL_KS_WRITE_STREAM: {
            	if ( pKsStreamHeader && 
            		 (pKsStreamHeader->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_TIMEVALID)){
            		TimeStampMs =(ULONG)
            			(pKsStreamHeader->PresentationTime.Time / (__int64)10000);
            	}
            	else {
            		TimeStampMs = 0;
            	}

				//
				// compute total size
				//
            	TotalSize = 0;
            	if ( pKsStreamHeader ) {
            		BufferSize = irpSp->Parameters.DeviceIoControl.OutputBufferLength;
	           		while ( BufferSize >= pKsStreamHeader->Size ) {
	           			BufferSize -= pKsStreamHeader->Size;
	           			TotalSize += pKsStreamHeader->DataUsed;
	           		}
	           		ASSERT( 0 == BufferSize );
            	}

                //KdPrint(("PerfIsAnyGroupOn=%x\n", PerfIsAnyGroupOn()));
                KS2PERFLOG_PRECEIVE_WRITE( DeviceObject, Irp, TimeStampMs, TotalSize );
            } break;
      
        }
    ) // KSPERFLOGS

    switch (irpSp->Parameters.DeviceIoControl.IoControlCode)
    {
    case IOCTL_KS_WRITE_STREAM:
    case IOCTL_KS_READ_STREAM:
        _DbgPrintF( DEBUGLVL_BLAB,("[CKsPin::DispatchDeviceIoControl] IOCTL_KS_XSTREAM"));

        if (pin->m_TransportSink &&
            (! pin->m_ConnectionFileObject) &&
            (((pin->m_Ext.Public.DataFlow == KSPIN_DATAFLOW_IN) &&
              (irpSp->Parameters.DeviceIoControl.IoControlCode ==
               IOCTL_KS_WRITE_STREAM)) ||
             ((pin->m_Ext.Public.DataFlow == KSPIN_DATAFLOW_OUT) &&
              (irpSp->Parameters.DeviceIoControl.IoControlCode ==
               IOCTL_KS_READ_STREAM)))) {
            if (!NT_SUCCESS (status = (pin->m_Ext.Device->
                CheckIoCapability()))) {
                //
                // Device incapable of performing I/O.  Fail the request.
                //
            } else if (pin->m_State == KSSTATE_STOP) {
                //
                // Stopped...reject.
                //
                status = STATUS_INVALID_DEVICE_STATE;
            } else if (pin->m_Flushing) {
                //
                // Flushing...reject.
                //
                status = STATUS_DEVICE_NOT_READY;
            } else {
                //
                // Send around the circuit.  We don't use KspTransferKsIrp
                // because we want to stop if we come back around to this pin.
                //
                // If we're in the circumstance where we increment to one, it
                // means that we're racing with the stop thread.  We're really
                // going to stop and should have rejected the request, so
                // throw it out.
                //
                if (InterlockedIncrement(PLONG(
                    &pin->m_ActiveFrameCountPlusOne)) == 1)
                    status = STATUS_INVALID_DEVICE_STATE;

                else {
                    Irp->IoStatus.Status = STATUS_SUCCESS;
                    pin->m_StreamingIrpsDispatched++;
                    KsLog(&pin->m_Log,KSLOGCODE_PIN_SEND,Irp,NULL);
                    PIKSTRANSPORT transport = pin->m_TransportSink;
                    while (transport) {
                        if (transport == PIKSTRANSPORT(pin)) {
                            //
                            // We have come back around to the pin.  
                            // Just complete the IRP.
                            //
                            if (status == STATUS_PENDING) {
                                status = STATUS_SUCCESS;
                            }

                            // 
                            // If the Irp status code has been adjusted
                            // because of failure and the transport was ok
                            // adjust status so we don't stomp on
                            // the status code when completing the Irp.
                            //
                            if (status == STATUS_SUCCESS &&
                                !NT_SUCCESS (Irp->IoStatus.Status)) {
                                status = Irp->IoStatus.Status;
                            }

                            Irp->IoStatus.Information = 
                                IoGetCurrentIrpStackLocation(Irp)->
                                    Parameters.DeviceIoControl.
                                    OutputBufferLength;
                            pin->m_StreamingIrpsRoutedSynchronously++;
    
                            break;
                        }
    
                        PIKSTRANSPORT nextTransport;
                        status = transport->TransferKsIrp(Irp,&nextTransport);
    
                        ASSERT(NT_SUCCESS(status) || ! nextTransport);
    
                        transport = nextTransport;
                    }
                }
    
                if (status != STATUS_PENDING) {
                    //
                    // There's three ways an IRP can get back to the sink.
                    // 1: it makes it back here, 2: via TransferKsIrp,
                    // 3: via DiscardKsIrp.  All three must check for
                    // the stop event and signal it.
                    //
                    // If something fails and we're going to complete the irp,
                    // we must also take into account the completion.  This
                    // lines up with the completion condition at the bottom
                    // of this function.
                    //
                    pin->DecrementIrpCirculation ();
                }
            } 
        }
        break;
        
    case IOCTL_KS_RESET_STATE:
        _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::DispatchDeviceIoControl] IOCTL_KS_RESET_STATE"));

        //
        // Get the reset value.
        //
        KSRESET resetState;
        status = KsAcquireResetValue(Irp,&resetState);
        
        if (NT_SUCCESS(status)) {
            //
            // Set the reset state.
            //
            pin->AcquireControl();

            //
            // Inform the pipe section that the reset state has changed.
            //
            if (pin->m_Process.PipeSection) {
                pin->m_Process.PipeSection->PipeSection->
                    SetResetState(pin,resetState);
            }

            pin->m_Ext.Public.ResetState = resetState;

            pin->ReleaseControl();
        }
        break;

    case IOCTL_KS_HANDSHAKE:
        _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::DispatchDeviceIoControl] IOCTL_KS_HANDSHAKE"));

        //
        // Only accepted from kernel mode, and the sizes must be exact.
        //
        if ((Irp->RequestorMode != KernelMode) || 
            (! irpSp->Parameters.DeviceIoControl.Type3InputBuffer) || 
            (! Irp->UserBuffer)) {
            status = STATUS_INVALID_DEVICE_REQUEST;
        } else if ((irpSp->Parameters.DeviceIoControl.InputBufferLength != 
                    sizeof(KSHANDSHAKE)) ||
                   (irpSp->Parameters.DeviceIoControl.OutputBufferLength != 
                    sizeof(KSHANDSHAKE))) {
            status = STATUS_INVALID_BUFFER_SIZE;
        } else {
            PKSHANDSHAKE in = (PKSHANDSHAKE)
                irpSp->Parameters.DeviceIoControl.Type3InputBuffer;
            PKSHANDSHAKE out = (PKSHANDSHAKE) Irp->UserBuffer;

            status = pin->FastHandshake(in,out);

            if (NT_SUCCESS(status)) {
                Irp->IoStatus.Information = sizeof(KSHANDSHAKE);
            }
        }
        break;
        
    default:
        #ifdef SUPPORT_DRM
        //
        // BUGBUG: HACKHACK:
        //
        // This is an ugly evil last minute hack for DRM.  AVStream currently
        // has no support for layering properties.  Unfortunately, DRM requires
        // that the content id property be handled both by the class and
        // minidriver.  It also requires a callback into DRM which means that
        // KS will have to link against the DRM lib.  This **MUST** be changed
        // for DX8 or Whistler to use a cleaner method.
        // 
        if (irpSp->Parameters.DeviceIoControl.IoControlCode ==
            IOCTL_KS_PROPERTY) {

            status = KspHandleAutomationIoControl (
                Irp,
                &DRMAutomationTable,
                NULL,
                NULL,
                NULL,
                0
            );

            //
            // The only thing in here should pertain to DRM.  We need to
            // propogate error back up if DrmAddContentHandlers errored out.
            //
            // On things like set support and set serialization, we do not
            // reveal the fact that there's a hack by saying that we support
            // the set.  (Otherwise, this gets exceedingly more complicated)
            // If buffer overflow is returned (the handler for DRM won't do
            // this), we need to pass it on to the client.  Otherwise,
            // we end up with set support handing off a 1 guid sized buffer
            // to the client.  Yes, this wastes resources, but I've said all
            // along that this needs to get changed for DX8 or Whistler.
            //
            if (status != STATUS_NOT_FOUND &&
                status != STATUS_PROPSET_NOT_FOUND &&
                status != STATUS_BUFFER_OVERFLOW &&
                !NT_SUCCESS (status))
                break;
        }
        #endif // SUPPORT_DRM

        status =
            KspHandleAutomationIoControl(
                Irp,
                pin->m_Ext.AutomationTable,
                &pin->m_Ext.EventList.ListEntry,
                &pin->m_Ext.EventList.SpinLock,
                pin->m_NodeAutomationTables,
                pin->m_NodesCount);
        break;
    }

    if (status != STATUS_PENDING) {
        ASSERT ((irpSp->Control & SL_PENDING_RETURNED) == 0);
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp,IO_NO_INCREMENT);
    }

    return status;
}


NTSTATUS
CKsPin::
DispatchClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine dispatches close IRPs.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::DispatchClose]"));

    PAGED_CODE();

    ASSERT(DeviceObject);
    ASSERT(Irp);

    //
    // Get a pointer to the target object.
    //
    CKsPin *pin = CKsPin::FromIrp(Irp);

    pin->m_Ext.Device->RemovePowerEntry(&pin->m_PowerEntry);

    if (pin->m_ProcessingWorker) {
        KsUnregisterWorker (pin->m_ProcessingWorker);
        _DbgPrintF(DEBUGLVL_VERBOSE,("#### pin%p.DispatchClose m_ProcessingWorker = NULL (%p) m_State(%d)",pin,pin->m_ProcessingWorker,pin->m_State));
        pin->m_ProcessingWorker = NULL;
    }

    if (pin->m_IrpsCompletedOutOfOrder) {
        _DbgPrintF(DEBUGLVL_TERSE,("[CKsPin::DispatchClose]  pin%p:  %d IRPs completed out of order",pin,pin->m_IrpsCompletedOutOfOrder));
    }

    //
    // Indicate we are closing by setting this to NULL.
    //
    pin->m_FileObject = NULL;

    //
    // Tell the filter the pin has gone away.
    //
    if (pin->m_AddedProcessPin) {
        pin->m_Parent->RemoveProcessPin(&pin->m_Process);
     }

    //
    // Flushes out any current work items queued up.
    //
    if (pin->m_Worker) {
        KsUnregisterWorker(pin->m_Worker);
        _DbgPrintF(DEBUGLVL_VERBOSE,("#### pin%p.DispatchClose m_Worker = NULL (%p) m_State(%d)",pin,pin->m_Worker,pin->m_State));
        pin->m_Worker = NULL;
    }

    //
    // Dereference the transfer sink.
    //
    if (pin->m_TransportSink) {
        _DbgPrintF(DEBUGLVL_TERSE,("[CKsPin::DispatchClose]  pin%p m_TransportSink is not NULL",pin));
        pin->m_TransportSink->Release();
        pin->m_TransportSink = NULL;
    }

    //
    // Dereference the transfer source.
    //
    if (pin->m_TransportSource) {
        _DbgPrintF(DEBUGLVL_TERSE,("[CKsPin::DispatchClose]  pin%p m_TransportSource is not NULL",pin));
        pin->m_TransportSource->Release();
        pin->m_TransportSource = NULL;
    }

    //
    // Dereference next pin if this is a source pin.
    //
    if (pin->m_ConnectionFileObject) {
        //
        // Disconnect the private interface.
        //
        if (pin->m_ConnectedPinInterface) {
            pin->m_ConnectedPinInterface->Disconnect();
            pin->m_ConnectedPinInterface->Release();
            pin->m_ConnectedPinInterface = NULL;
        }
        ObDereferenceObject(pin->m_ConnectionFileObject);
        //pin->m_ConnectionFileObject = NULL;
    }

    //
    // Dereference allocator if it was assigned.
    //
    if (pin->m_Process.AllocatorFileObject) {
        ObDereferenceObject(pin->m_Process.AllocatorFileObject);
        pin->m_Process.AllocatorFileObject = NULL;
    }

    //
    // Release the clock, if any.  If there are any references on the 
    // clock, we must wait for them to go away.
    //
    if (pin->m_MasterClockFileObject) {
        KeResetEvent(&pin->m_ClockEvent);
        if (InterlockedDecrement(&pin->m_ClockRef) > 0) {
            KeWaitForSingleObject(
                &pin->m_ClockEvent,
                Suspended,
                KernelMode,
                FALSE,
                NULL);
        }
        ObDereferenceObject(pin->m_MasterClockFileObject);
        pin->m_MasterClockFileObject = NULL;
    }

    //
    // Free the default clock if there is one.
    //
    if (pin->m_DefaultClock) {
        KsFreeDefaultClock(pin->m_DefaultClock);
        pin->m_DefaultClock = NULL;
    }

    //
    // Get a pointer to the parent object.
    //
    PFILE_OBJECT parentFileObject = 
        IoGetCurrentIrpStackLocation(Irp)->FileObject->RelatedFileObject;
    ASSERT(parentFileObject);

    //
    // Call the helper to do the rest.
    //
    NTSTATUS status = 
        KspClose(
            Irp,
            reinterpret_cast<PKSPX_EXT>(&pin->m_Ext),
            FALSE);

    //
    // Delete the target object if the request is not pending.
    //
    if (status != STATUS_PENDING) {
        //
        // Decrement instance count.
        //
        ASSERT(*pin->m_FilterPinCount);
        (*pin->m_FilterPinCount)--;

        //
        // STATUS_MORE_PROCESSING_REQUIRED indicates we are using the close
        // dispatch to synchronously fail a create.  In that case, no sync is
        // required, and the create dispatch will do the completion.
        //
        if (status == STATUS_MORE_PROCESSING_REQUIRED) {
            pin->Release();
        } else {
            //
            // Release the pin.  First we set up the synchronization event.  If
            // there are still outstanding references after the delete, we need
            // to wait on that event for the references to go away.
            //
            KEVENT closeEvent;
            KeInitializeEvent(&closeEvent,SynchronizationEvent,FALSE);
            pin->m_CloseEvent = &closeEvent;
            if (pin->Release()) {
                _DbgPrintF(DEBUGLVL_TERSE,("#### Pin%p.DispatchClose:  waiting for references to go away",pin));
                KeWaitForSingleObject(
                    &closeEvent,
                    Suspended,
                    KernelMode,
                    FALSE,
                    NULL);
                _DbgPrintF(DEBUGLVL_TERSE,("#### Pin%p.DispatchClose:  done waiting for references to go away",pin));
            }

            IoCompleteRequest(Irp,IO_NO_INCREMENT);
        }

        //
        // Dereference the parent file object.
        //
        ObDereferenceObject(parentFileObject);
    }

    return status;
}


BOOLEAN
CKsPin::
UseStandardTransport(
    void
    )

/*++

Routine Description:

    This routine determines if a pin uses the standard transport..

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::UseStandardTransport]"));

    PAGED_CODE();

    ASSERT(KspMutexIsAcquired(m_Ext.FilterControlMutex));

    //
    // The pin flag can override all other checks.
    //
    if (m_Ext.Public.Descriptor->Flags & 
        KSPIN_FLAG_USE_STANDARD_TRANSPORT) {
        return TRUE;
    }

    //
    // The pin flag can override all other checks.
    //
    if (m_Ext.Public.Descriptor->Flags & 
        KSPIN_FLAG_DO_NOT_USE_STANDARD_TRANSPORT) {
        return FALSE;
    }

    //
    // Must be source or sink.
    //
    if (!(m_Ext.Public.Descriptor->PinDescriptor.Communication & 
           KSPIN_COMMUNICATION_BOTH)) {
        return FALSE;
    }

    //
    // Must use the standard interface set.
    //
    if (! IsEqualGUIDAligned(
            m_Ext.Public.ConnectionInterface.Set,
            KSINTERFACESETID_Standard)) {
        return FALSE;
    }

    //
    // Must use the standard medium set.
    //
    if (! IsEqualGUIDAligned(
            m_Ext.Public.ConnectionMedium.Set,
            KSMEDIUMSETID_Standard)) {
        return FALSE;
    }

    return TRUE;
}


NTSTATUS
CKsPin::
Property_ConnectionState(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    IN OUT PKSSTATE State
    )

/*++

Routine Description:

    This routine handles device state property requests.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::Property_ConnectionState]"));

    PAGED_CODE();

    ASSERT(Irp);
    ASSERT(Property);
    ASSERT(State);

    //
    // Get a pointer to the target object.
    //
    CKsPin *pin = CKsPin::FromIrp(Irp);

    NTSTATUS status = STATUS_SUCCESS;

    if (Property->Flags & KSPROPERTY_TYPE_GET) {
        _DbgPrintF(DEBUGLVL_INTERROGATION,("#### Pin%p.Property_ConnectionState:  get",pin));

        //
        // Get state.
        //
        *State = pin->m_Ext.Public.DeviceState;
        //
        // If the pin captures data through an unregulated source that is
        // continously generating data, and thus any pre-rolled data immediately
        // becomes stale, then return the appropriate informational status.
        //
        if ((pin->m_Ext.Public.Descriptor->Flags & KSPIN_FLAG_PROCESS_IN_RUN_STATE_ONLY) &&
            (pin->m_Ext.Public.DataFlow == KSPIN_DATAFLOW_OUT) &&
            (*State == KSSTATE_PAUSE)) {
            status = STATUS_NO_DATA_DETECTED;
        }
    } else {
        _DbgPrintF(DEBUGLVL_DEVICESTATE,("#### Pin%p.Property_ConnectionState:  set from %d to %d",pin,pin->m_Ext.Public.DeviceState,*State));

        //
        // Tell the device about the state change.
        //
        status = 
            pin->m_Ext.Device->PinStateChange(
                &pin->m_Ext.Public,
                Irp,
                *State,
                pin->m_Ext.Public.DeviceState);
        if (status != STATUS_SUCCESS) {
            return status;
        }

        //
        // Set state.
        //
        pin->AcquireControl();

        //
        // Make sure required pins exist.
        //
        if ((*State != KSSTATE_STOP) && 
            (pin->m_Ext.Public.DeviceState == KSSTATE_STOP) &&
            ! pin->m_Parent->DoAllNecessaryPinsExist()) {
            _DbgPrintF(DEBUGLVL_DEVICESTATE,("#### Pin%p.Property_ConnectionState:  necessary pins not instantiated",pin));
            status = STATUS_DEVICE_NOT_CONNECTED;
        }

        if (NT_SUCCESS(status)) {
            if (pin->m_Process.PipeSection) {
                //
                // Let the pipe know the device state has changed.
                //
                status = 
                    pin->m_Process.PipeSection->PipeSection->
                        SetDeviceState(pin,*State);
            } else if (pin->UseStandardTransport()) {
                //
                // If leaving stop state and the pin has no pipe yet, create a 
                // pipe.
                //
                if ((pin->m_Ext.Public.DeviceState == KSSTATE_STOP) && 
                    (*State != KSSTATE_STOP)) {
                    status = 
                        KspCreatePipeSection(
                            pin->m_Process.PipeId,
                            pin,
                            pin->m_Parent,
                            pin->m_Ext.Device);
                }
            } else if (pin->m_DispatchSetDeviceState) {
                //
                // This pin does not use the standard transport.  Tell the
                // client the state has changed.
                //
                pin->m_Ext.Public.ClientState = *State;
                status =
                    pin->m_DispatchSetDeviceState(
                        &pin->m_Ext.Public,
                        *State,
                        pin->m_Ext.Public.DeviceState);
#if DBG
                if (status == STATUS_PENDING) {
                    _DbgPrintF(DEBUGLVL_ERROR,("CLIENT BUG:  connection state handler returned STATUS_PENDING"));
                }
#endif

                if (!NT_SUCCESS (status)) {
                    pin->m_Ext.Public.ClientState = 
                        pin->m_Ext.Public.DeviceState;
                }
            }
        }

        if (NT_SUCCESS(status)) {
            //
            // Save the state.
            //
            pin->m_Ext.Public.DeviceState = *State;

            //
            // Set the state of the clock.
            //
            if (pin->m_DefaultClock) {
                pin->SetPinClockState(*State);
            }
        }

        pin->ReleaseControl();

        //
        // If the attempt failed, let the device know.
        //
        if (! NT_SUCCESS(status)) {
            pin->m_Ext.Device->PinStateChange(
                &pin->m_Ext.Public,
                NULL,
                pin->m_Ext.Public.DeviceState,
                *State);
        }

        _DbgPrintF(DEBUGLVL_DEVICESTATE,("#### Pin%p.Property_ConnectionState:  status %08x",pin,status));
    }

    return status;
}

#ifdef SUPPORT_DRM
//
// HACKHACK: BUGBUG:
//
// Please read other comments pertaining to this specific property.
//

NTSTATUS
CKsPin::
Property_DRMAudioStreamContentId (
    IN PIRP Irp,
    IN PKSP_DRMAUDIOSTREAM_CONTENTID Property,
    IN PDRMCONTENTID_DATA DrmData
    )

/*++

Routine Description:

    This handles the DRM audio stream content id property for authentication
    purposes.  This is a complete hack and should be removed and rewritten
    in a future version of AVStream.

Arguments:

Return Value:

--*/

{

    PAGED_CODE();
    ASSERT (Irp);
    ASSERT (Property);
    ASSERT (DrmData);

    //
    // Since we're getting passed pointers to call into, ensure that the
    // client is absolutely trusted.
    //
    if (Irp->RequestorMode != KernelMode) {
        return STATUS_UNSUCCESSFUL;
    }

    const KSPROPERTY_SET *Set;
    const KSPROPERTY_ITEM *Item;
    ULONG SetCount;
    ULONG ItemCount;

    ULONG HandlerCount = 0;

    CKsPin *pin = CKsPin::FromIrp(Irp);

    const KSAUTOMATION_TABLE *AutomationTable = 
        pin->m_Ext.AutomationTable;

    PVOID *FunctionTable;
    PVOID *CurrentFunc;

    NTSTATUS status = STATUS_SUCCESS;

    //
    // We need to walk the automation table and determine how many handler
    // pointers we need to pass to DRM for authentication
    //
    Set = AutomationTable->PropertySets;
    for (SetCount = 0; SetCount < AutomationTable->PropertySetsCount;
        SetCount++) {

        Item = Set->PropertyItem;
        for (ItemCount = 0; ItemCount < Set->PropertiesCount; 
            ItemCount++) {

            if (Item->GetPropertyHandler)
                HandlerCount++;
            if (Item->SetPropertyHandler)
                HandlerCount++;
            if (Item->SupportHandler)
                HandlerCount++;

            Item++;

        }

        Set++;

    }

    CurrentFunc = FunctionTable = (PVOID *)
        ExAllocatePool (PagedPool, sizeof (PVOID) * (HandlerCount + 1));

    if ( NULL == FunctionTable ) {
    	ASSERT( FunctionTable && "No memory for FunctionTable" );
    	return STATUS_INSUFFICIENT_RESOURCES;
    }

    Set = AutomationTable->PropertySets;
    for (SetCount = 0; SetCount < AutomationTable->PropertySetsCount;
        SetCount++) {

        Item = Set -> PropertyItem;
        for (ItemCount = 0; ItemCount < Set->PropertiesCount;
            ItemCount++) {

            if (Item->GetPropertyHandler)
                *CurrentFunc++ = (PVOID)(Item->GetPropertyHandler);
            if (Item->SetPropertyHandler)
                *CurrentFunc++ = (PVOID)(Item->SetPropertyHandler);
            if (Item->SupportHandler)
                *CurrentFunc++ = (PVOID)(Item->SupportHandler);

            Item++;

        }

        Set++;

    }

    //
    // If the pin is pin-centric, toss the pin process function in the list
    //
    if (pin->m_DispatchProcess)
        *CurrentFunc++ = (PVOID)(pin->m_DispatchProcess);
    else {
        if (pin->m_Ext.Parent) 
            *CurrentFunc++ = (PVOID)pin->m_Ext.Parent->Interface->
                GetProcessDispatch ();
        else
            *CurrentFunc++ = NULL;
    }

    //status = DrmAddContentHandlers (DrmData->ContentId, FunctionTable, 
    //    HandlerCount + 1);
    ASSERT( Property->DrmAddContentHandlers );
    ASSERT( IoGetCurrentIrpStackLocation(Irp)->FileObject == Property->Context );
	status = Property->DrmAddContentHandlers( DrmData->ContentId, FunctionTable, 
    	HandlerCount + 1);

    ExFreePool (FunctionTable);

    return status;

}
#endif // SUPPORT_DRM


STDMETHODIMP 
CKsPin::
ClientSetDeviceState(
    IN KSSTATE NewState,
    IN KSSTATE OldState
    )

/*++

Routine Description:

    This routine informs the client of device state changes.

Arguments:

    NewState -
        Contains the new device state.

    OldState -
        Contains the old device state.

Return Value:

    Status.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::ClientSetDeviceState]"));

    PAGED_CODE();

    NTSTATUS status;

    //
    // Change the off input to the processing gate (created in Init) based
    // on the transition.  This is done to prevent erroneous processing
    // dispatches in the case that a queue on a pin centric pin is deleted.
    //
    if (OldState == KSSTATE_STOP && NewState == KSSTATE_ACQUIRE) {
        KsGateTurnInputOn (&m_AndGate);
        _DbgPrintF(DEBUGLVL_PROCESSINGCONTROL,("#### Pin%p.ClientSetDeviceState:  on%p-->%d",this,&m_AndGate,m_AndGate.Count));
    }
    if (OldState == KSSTATE_ACQUIRE && NewState == KSSTATE_STOP) {
        KsGateTurnInputOff (&m_AndGate);
        _DbgPrintF(DEBUGLVL_PROCESSINGCONTROL,("#### Pin%p.ClientSetDeviceState:  off%p-->%d",this,&m_AndGate,m_AndGate.Count));
    }

    m_Ext.Public.ClientState = NewState;

    if (m_DispatchSetDeviceState) {
        status =
            m_DispatchSetDeviceState(
                &m_Ext.Public,
                NewState,
                OldState);
#if DBG
        if (status == STATUS_PENDING) {
            _DbgPrintF(DEBUGLVL_ERROR,("CLIENT BUG:  connection state handler returned STATUS_PENDING"));
        }
#endif
    } else {
        status = STATUS_SUCCESS;
    }

    if (!NT_SUCCESS (status)) {
        m_Ext.Public.ClientState = OldState;
    }

    //
    // If we failed the transition from OldState->NewState, we will not
    // get a ClientSetDeviceState from NewState->OldState since we didn't
    // make it into NewState; therefore, we must turn off an input to the
    // gate or we'll get a processing dispatch called with a deleted queue
    // when OldState==KSSTATE_STOP and NewState==KSSTATE_ACQUIRE
    //
    if (!NT_SUCCESS (status) &&
        OldState == KSSTATE_STOP && NewState == KSSTATE_ACQUIRE) {
        KsGateTurnInputOff (&m_AndGate);
        _DbgPrintF(DEBUGLVL_PROCESSINGCONTROL,("#### Pin%p.ClientSetDeviceState: failure results in off%p-->%d", this, &m_AndGate, m_AndGate.Count));
    }

    return status;
}


NTSTATUS
CKsPin::
Property_ConnectionDataFormat(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    IN OUT PKSDATAFORMAT DataFormat
    )

/*++

Routine Description:

    This routine handles data format property requests.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::Property_ConnectionDataFormat]"));

    PAGED_CODE();

    ASSERT(Irp);
    ASSERT(Property);
    ASSERT(DataFormat);

    //
    // Get a pointer to the target object.
    //
    CKsPin *pin = CKsPin::FromIrp(Irp);

    NTSTATUS status = STATUS_SUCCESS;

    if (Property->Flags & KSPROPERTY_TYPE_BASICSUPPORT) {
        if (Irp->IoStatus.Information) {
            //
            // Default action has been taken.  Clear the 'set' access bit if
            // this pin is fixed-format.
            //
            pin->AcquireControl();
            if (pin->m_Ext.Public.Descriptor->Flags & KSPIN_FLAG_FIXED_FORMAT) {
                PKSPROPERTY_DESCRIPTION description = 
                    PKSPROPERTY_DESCRIPTION(DataFormat);

                description->AccessFlags &= ~KSPROPERTY_TYPE_SET;
            }
            pin->ReleaseControl();
        } else {
            //
            // Default action has not been taken.  Indicate it should.
            //
            status = STATUS_MORE_PROCESSING_REQUIRED;
        }
    } else if (Property->Flags & KSPROPERTY_TYPE_GET) {
        //
        // Get the data format.
        //
        pin->AcquireControl();

        ASSERT(pin->m_Ext.Public.ConnectionFormat);

        ULONG formatSize;
        //
        // If there are associated attributes for this data format,
        // then compensate the return size with them.
        //
        if (pin->m_Ext.Public.AttributeList) {
            formatSize =
                ((pin->m_Ext.Public.ConnectionFormat->FormatSize + FILE_QUAD_ALIGNMENT) & ~FILE_QUAD_ALIGNMENT) +
                pin->m_Ext.Public.AttributeList->Size;
        } else {
            formatSize = pin->m_Ext.Public.ConnectionFormat->FormatSize;
        }

        PIO_STACK_LOCATION irpSp = 
            IoGetCurrentIrpStackLocation(Irp);

        if (! irpSp->Parameters.DeviceIoControl.OutputBufferLength) {
            //
            // Zero buffer length, a size query.
            //
            Irp->IoStatus.Information = formatSize;
            status = STATUS_BUFFER_OVERFLOW;
        }
        else if (irpSp->Parameters.DeviceIoControl.OutputBufferLength >= formatSize) {
            //
            // Sufficient space...copy the format.
            //
            RtlCopyMemory(
                DataFormat,
                pin->m_Ext.Public.ConnectionFormat,
                formatSize);

            Irp->IoStatus.Information = formatSize;
        } else {
            //
            // Buffer is too small.
            //
            status = STATUS_BUFFER_TOO_SMALL;
        }

        pin->ReleaseControl();
    } else {
        //
        // Set the data format.
        //
        pin->AcquireControl();
        if (pin->m_Ext.Public.Descriptor->Flags & KSPIN_FLAG_FIXED_FORMAT) {
            status = STATUS_INVALID_DEVICE_REQUEST;
        } else {
            status =
                pin->SetDataFormat(
                    DataFormat,
                    IoGetCurrentIrpStackLocation(Irp)->Parameters.DeviceIoControl.OutputBufferLength);
        }
        pin->ReleaseControl();
    }

    return status;
}

typedef
struct {
    CKsPin* Pin;
    PKSDATAFORMAT oldDataFormat;
    PKSMULTIPLE_ITEM oldAttributeList;
} VALIDATION_CONTEXT;


NTSTATUS
CKsPin::
SetDataFormat(
    IN PKSDATAFORMAT DataFormat,
    IN ULONG RequestSize
    )

/*++

Routine Description:

    This routine sets the data format of the pin.  The control mutex must be
    acquired prior to calling this function.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::SetDataFormat]"));

    PAGED_CODE();
    ASSERT(DataFormat);
    ASSERT(KspMutexIsAcquired(m_Ext.FilterControlMutex));

    NTSTATUS status = STATUS_SUCCESS;

    //
    // Allocate and copy the new format.  This is done first so we can keep
    // the old one if the allocation fails.
    //
    PKSDATAFORMAT newDataFormat =
        PKSDATAFORMAT(
            ExAllocatePoolWithTag(
                PagedPool,
                RequestSize,
                POOLTAG_PINFORMAT));

    if (! newDataFormat) {
        //
        // Out of memory.
        //
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Copy the new format.
    //
    if (NT_SUCCESS(status)) {
        RtlCopyMemory(
            newDataFormat,
            DataFormat,
            RequestSize);

        PKSDATAFORMAT oldDataFormat = m_Ext.Public.ConnectionFormat;
        PKSMULTIPLE_ITEM oldAttributeList = m_Ext.Public.AttributeList;
        m_Ext.Public.ConnectionFormat = newDataFormat;
        if (newDataFormat->Flags & KSDATAFORMAT_ATTRIBUTES) {
            m_Ext.Public.AttributeList =
                (PKSMULTIPLE_ITEM)((PUCHAR)newDataFormat +
                ((newDataFormat->FormatSize + FILE_QUAD_ALIGNMENT) & ~FILE_QUAD_ALIGNMENT));
        } else {
            m_Ext.Public.AttributeList = NULL;
        }

        //
        // Let the client know.
        //
        if (m_Ext.Public.Descriptor->Dispatch && 
            m_Ext.Public.Descriptor->Dispatch->SetDataFormat) {
            VALIDATION_CONTEXT context;

            context.Pin = this;
            context.oldDataFormat = oldDataFormat;
            context.oldAttributeList = oldAttributeList;
            status =
                KspValidateDataFormat(
                    &m_Ext.Public.Descriptor->PinDescriptor,
                    DataFormat,
                    RequestSize,
                    CKsPin::ValidateDataFormat,
                    reinterpret_cast<PVOID>(&context));
        } else {
            status =
                KspValidateDataFormat(
                    &m_Ext.Public.Descriptor->PinDescriptor,
                    DataFormat,
                    RequestSize,
                    NULL,
                    NULL);
        }

        //
        // Free the old format or restore it.
        //
        if (NT_SUCCESS(status)) {
            if (oldDataFormat) {
                ExFreePool(oldDataFormat);
            }
        } else {
            ExFreePool(newDataFormat);
            m_Ext.Public.ConnectionFormat = oldDataFormat;
            m_Ext.Public.AttributeList = oldAttributeList;
        }
    }

    return status;
}


NTSTATUS
CKsPin::
ValidateDataFormat(
    IN PVOID Context,
    IN PKSDATAFORMAT DataFormat,
    IN PKSMULTIPLE_ITEM AttributeList OPTIONAL,
    IN const KSDATARANGE* DataRange,
    IN const KSATTRIBUTE_LIST* AttributeRange OPTIONAL
    )
/*++

Routine Description:

    This routine makes a callback to the pin's SetDataFormat function, returning
    any status. This method is not called unless such a pin function actually
    exists.  The control mutex must be acquired prior to calling this function.

Arguments:

Return Value:

--*/
{
    VALIDATION_CONTEXT* ValidationContext = reinterpret_cast<VALIDATION_CONTEXT*>(Context);
    ASSERT(KspMutexIsAcquired(ValidationContext->Pin->m_Ext.FilterControlMutex));

    return ValidationContext->Pin->m_Ext.Public.Descriptor->Dispatch->SetDataFormat(
        &ValidationContext->Pin->m_Ext.Public,
        ValidationContext->oldDataFormat,
        ValidationContext->oldAttributeList,
        DataRange,
        AttributeRange);
}


NTSTATUS
CKsPin::
Property_ConnectionAllocatorFramingEx(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    IN OUT PKSALLOCATOR_FRAMING_EX Framing
    )

/*++

Routine Description:

    This routine handles allocator framing property requests.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::Property_ConnectionAllocatorFramingEx]"));

    PAGED_CODE();

    ASSERT(Irp);
    ASSERT(Property);
    ASSERT(Framing);

    //
    // Get a pointer to the target object.
    //
    CKsPin *pin = CKsPin::FromIrp(Irp);

    pin->AcquireControl();

    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

    NTSTATUS status = STATUS_SUCCESS;

    const KSALLOCATOR_FRAMING_EX *framingGet = 
        pin->m_Ext.Public.Descriptor->AllocatorFraming;

    if (! framingGet) {
        _DbgPrintF(DEBUGLVL_INTERROGATION,("#### Pin%p.Property_ConnectionAllocatorFramingEx:  STATUS_NOT_FOUND",pin));
        //
        // Don't support this if no allocator is specified.
        //
        status = STATUS_NOT_FOUND;
    } else {
        _DbgPrintF(DEBUGLVL_INTERROGATION,("#### Pin%p.Property_ConnectionAllocatorFramingEx:  get",pin));
        //
        // Get the allocator framing for this pin.
        //
        ULONG ulSize = 
            ((framingGet->CountItems) * sizeof(KS_FRAMING_ITEM)) +
            sizeof(KSALLOCATOR_FRAMING_EX) - sizeof(KS_FRAMING_ITEM);

        if (! irpSp->Parameters.DeviceIoControl.OutputBufferLength) {
            //
            // Zero buffer length, a size query.
            //
            Irp->IoStatus.Information = ulSize;
            status = STATUS_BUFFER_OVERFLOW;
        } else if(irpSp->Parameters.DeviceIoControl.OutputBufferLength >= ulSize) {
            //
            // Sufficient space...copy the framing.
            //
            RtlCopyMemory(Framing,framingGet,ulSize);
            Irp->IoStatus.Information = ulSize;
        } else {
            //
            // Buffer is too small.
            //
            status = STATUS_BUFFER_TOO_SMALL;
        }
    }

    pin->ReleaseControl();

    return status;
}


NTSTATUS
CKsPin::
Property_ConnectionAcquireOrdering(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    IN OUT PBOOL Ordering
    )

/*++

Routine Description:

    This routine handles acquire ordering property requests.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::Property_ConnectionAcquireOrdering]"));

    PAGED_CODE();

    ASSERT(Irp);
    ASSERT(Property);
    ASSERT(Ordering);

    //
    // Get a pointer to the target object.
    //
    CKsPin *pin = CKsPin::FromIrp(Irp);

    NTSTATUS status = STATUS_SUCCESS;

    //
    // Only get is supported.
    //
    ASSERT(Property->Flags & KSPROPERTY_TYPE_GET);

    //
    // Return TRUE iff this is a source pin.
    //
    *Ordering = (pin->m_ConnectionFileObject != NULL);

    return status;
}


NTSTATUS
CKsPin::
Property_StreamAllocator(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    IN OUT PHANDLE Handle
    )

/*++

Routine Description:

    This routine handles allocator property requests.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::Property_StreamAllocator]"));

    PAGED_CODE();

    ASSERT(Irp);
    ASSERT(Property);
    ASSERT(Handle);

    //
    // Get a pointer to the target object.
    //
    CKsPin *pin = CKsPin::FromIrp(Irp);

    NTSTATUS status;

    if (Property->Flags & KSPROPERTY_TYPE_GET) {
        _DbgPrintF(DEBUGLVL_INTERROGATION,("#### Pin%p.Property_StreamAllocator:  get",pin));
        //
        // Return NULL and STATUS_SUCCESS to indicate we expose an allocator.
        //
        *Handle = NULL;
        status = STATUS_SUCCESS;
    } else {
        _DbgPrintF(DEBUGLVL_ALLOCATORS,("#### Pin%p.Property_StreamAllocator:  set 0x%08x",pin,*Handle));

        //
        // Set allocator.
        //
        pin->AcquireControl();

        if (pin->m_Ext.Public.DeviceState != KSSTATE_STOP) {
            //
            // Fail because we are not in stop state.
            //
            _DbgPrintF(DEBUGLVL_ALLOCATORS,("[CKsPin::Property_StreamAllocator] invalid device state %d",pin->m_Ext.Public.DeviceState));
            status = STATUS_INVALID_DEVICE_STATE;
        } else {
            //
            // Release the previous allocator, if any.
            //
            if (pin->m_Process.AllocatorFileObject) {
                ObDereferenceObject(pin->m_Process.AllocatorFileObject);
                pin->m_Process.AllocatorFileObject = NULL;
            }
        
            //
            // Reference the handle, if any.
            //
            if (*Handle != NULL) {
                status = 
                    ObReferenceObjectByHandle(
                        *Handle,
                        FILE_READ_DATA | SYNCHRONIZE,
                        *IoFileObjectType,
                        ExGetPreviousMode(),
                        (PVOID *) &pin->m_Process.AllocatorFileObject,
                        NULL);
            } else {
                status = STATUS_SUCCESS;
            }
        }

        pin->ReleaseControl();
    }

    return status;
}


NTSTATUS
CKsPin::
Property_StreamMasterClock(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    IN OUT PHANDLE Handle
    )

/*++

Routine Description:

    This routine handles clock property requests.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::Property_StreamMasterClock]"));

    PAGED_CODE();

    ASSERT(Irp);
    ASSERT(Property);
    ASSERT(Handle);

    //
    // Get a pointer to the target object.
    //
    CKsPin *pin = CKsPin::FromIrp(Irp);

    pin->AcquireControl();

    NTSTATUS status;

    if (Property->Flags & KSPROPERTY_TYPE_GET) {
        if ((pin->m_Ext.Public.Descriptor->Dispatch &&
             pin->m_Ext.Public.Descriptor->Dispatch->Clock) ||
            (pin->m_Ext.Public.Descriptor->Flags & KSPIN_FLAG_IMPLEMENT_CLOCK)) {
            //
            // Return NULL and STATUS_SUCCESS to indicate we expose a master clock.
            //
            *Handle = NULL;
            status = STATUS_SUCCESS;
        } else {
            //
            // Return STATUS_UNSUCCESSFUL to indicate we expose a no master clock.
            //
            status = STATUS_UNSUCCESSFUL;
        }
    } else {
        //
        // Set master clock.
        //
        if (pin->m_Ext.Public.DeviceState != KSSTATE_STOP) {
            //
            // Fail because we are not in stop state.
            //
            _DbgPrintF(DEBUGLVL_CLOCKS,("[CKsPin::Property_StreamMasterClock] invalid device state %d",pin->m_Ext.Public.DeviceState));
            status = STATUS_INVALID_DEVICE_STATE;
        } else {
            PFILE_OBJECT masterClockFileObject;
            KSCLOCK_FUNCTIONTABLE clockFunctionTable;

            //
            // Reference the handle, if any, and get the function table.
            //
            if (*Handle) {
                status = 
                    ObReferenceObjectByHandle(
                        *Handle,
                        FILE_READ_DATA | SYNCHRONIZE,
                        *IoFileObjectType,
                        ExGetPreviousMode(),
                        (PVOID *) &masterClockFileObject,
                        NULL);

                if (NT_SUCCESS(status)) {
                    KSPROPERTY property;
                    property.Set = KSPROPSETID_Clock;
                    property.Id = KSPROPERTY_CLOCK_FUNCTIONTABLE;
                    property.Flags = KSPROPERTY_TYPE_GET;

                    ULONG bytesReturned;
                    status =
                        KsSynchronousIoControlDevice(
                            masterClockFileObject,
                            KernelMode,
                            IOCTL_KS_PROPERTY,
                            PVOID(&property),
                            sizeof(property),
                            PVOID(&clockFunctionTable),
                            sizeof(clockFunctionTable),
                            &bytesReturned);

                    if (NT_SUCCESS(status) && 
                        (bytesReturned != sizeof(clockFunctionTable))) {
                        status = STATUS_INVALID_BUFFER_SIZE;
                    }

                    if (! NT_SUCCESS(status)) {
                        ObDereferenceObject(masterClockFileObject);
                    }
                }
            } else {
                status = STATUS_SUCCESS;
            }

            //
            // Replace the old file object pointer and function table.
            //
            if (NT_SUCCESS(status)) {
                //
                // Release the previous clock, if any.  If there are any references
                // on the clock, we must wait for them to go away.
                //
                if (pin->m_MasterClockFileObject) {
                    KeResetEvent(&pin->m_ClockEvent);
                    if (InterlockedDecrement(&pin->m_ClockRef) > 0) {
                        KeWaitForSingleObject(
                            &pin->m_ClockEvent,
                            Suspended,
                            KernelMode,
                            FALSE,
                            NULL);
                    }
                    ObDereferenceObject(pin->m_MasterClockFileObject);
                    pin->m_MasterClockFileObject = NULL;
                }
        
                //
                // Copy the new stuff.
                //
                if (*Handle) {
                    pin->m_MasterClockFileObject = masterClockFileObject;
                    RtlCopyMemory(
                        &pin->m_ClockFunctionTable,
                        &clockFunctionTable,
                        sizeof(clockFunctionTable));

                    //
                    // If we have a new clock, add a reference to tell the Get
                    // functions that it is available.
                    //
                    if (NT_SUCCESS(status)) {
                        InterlockedIncrement(&pin->m_ClockRef);
                    }
                } 
            }
        }
    }

    pin->ReleaseControl();

    return status;
}


NTSTATUS
CKsPin::
Property_StreamPipeId(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    IN OUT PHANDLE Handle
    )

/*++

Routine Description:

    This routine handles pipe ID property requests.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::Property_StreamPipeId]"));

    PAGED_CODE();

    ASSERT(Irp);
    ASSERT(Property);
    ASSERT(Handle);

    //
    // Get a pointer to the target object.
    //
    CKsPin *pin = CKsPin::FromIrp(Irp);

    NTSTATUS status = STATUS_SUCCESS;

    if (Property->Flags & KSPROPERTY_TYPE_GET) {
        //
        // Get the pipe ID.
        //
        *Handle = pin->m_Process.PipeId;
        _DbgPrintF(DEBUGLVL_PIPES,("#### Pin%p.Property_StreamPipeId:  get 0x%08x",pin,*Handle));
    } else {
        //
        // Set the pipe ID.
        //
        pin->AcquireControl();
        pin->m_Process.PipeId = *Handle;
        pin->ReleaseControl();
        _DbgPrintF(DEBUGLVL_PIPES,("#### Pin%p.Property_StreamPipeId:  set 0x%08x",pin,*Handle));
    }

    return status;
}


NTSTATUS
CKsPin::
Property_StreamInterfaceHeaderSize(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PULONG HeaderSize
    )

/*++

Routine Description:

    This routine handles header size property requests.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::Property_StreamInterfaceHeaderSize]"));

    PAGED_CODE();

    ASSERT(Irp);
    ASSERT(Property);
    ASSERT(HeaderSize);

    //
    // Get a pointer to the target object.
    //
    CKsPin *pin = CKsPin::FromIrp(Irp);

    if (pin->m_Ext.Public.StreamHeaderSize) {
#if DBG
        if (pin->m_Ext.Public.StreamHeaderSize < sizeof(KSSTREAM_HEADER)) {
            _DbgPrintF(DEBUGLVL_ERROR,("CLIENT BUG:  specified header size (%d) less than sizeof(KSSTREAM_HEADER) (%d)",pin->m_Ext.Public.StreamHeaderSize,sizeof(KSSTREAM_HEADER)));
        }
#endif
        *HeaderSize = 
            pin->m_Ext.Public.StreamHeaderSize - sizeof(KSSTREAM_HEADER);
    } else {
        *HeaderSize = 0;
    }

    return STATUS_SUCCESS;
}


NTSTATUS    
CKsPin::
Support_Connection(
    IN PIRP Irp,
    IN PKSEVENT Event,
    OUT PVOID Data
    )

/*++

Routine Description:

    This routine handles connection event support requests.  This is used only
    for end-of-stream at the moment.

Arguments:

Return Value:

    Status.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::Support_Connection]"));

    PAGED_CODE();

    ASSERT(Irp);
    ASSERT(Event);

    //
    // Get a pointer to the target object.
    //
    CKsPin *pin = CKsPin::FromIrp(Irp);

    NTSTATUS status;
    pin->AcquireControl();
    if (pin->m_Ext.Public.Descriptor->Flags & KSPIN_FLAG_GENERATE_EOS_EVENTS) {
        //
        // We support the event.  Tell the handler to proceed.
        //
        status = STATUS_SOME_NOT_MAPPED;
    } else {
        //
        // We don't support the event.  Fail.
        //
        status = STATUS_NOT_FOUND;
    }
    pin->ReleaseControl();

    return status;
}    


NTSTATUS    
CKsPin::
AddEvent_Connection(
    IN PIRP Irp,
    IN PKSEVENTDATA EventData,
    IN OUT PKSEVENT_ENTRY EventEntry
    )

/*++

Routine Description:

    This routine handles connection event 'add' requests.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::AddEvent_Connection]"));

    PAGED_CODE();

    ASSERT(Irp);
    ASSERT(EventData);
    ASSERT(EventEntry);

    //
    // Get a pointer to the target object.
    //
    CKsPin *pin = CKsPin::FromIrp(Irp);
    _DbgPrintF(DEBUGLVL_EVENTS,("#### Pin%p.AddEvent_Connection",pin));

    //
    // Add the entry to the list.
    //
    ExInterlockedInsertTailList(
        &pin->m_Ext.EventList.ListEntry,
        &EventEntry->ListEntry,
        &pin->m_Ext.EventList.SpinLock);

    return STATUS_SUCCESS;
}    


KSDDKAPI
NTSTATUS
NTAPI
KsPinHandshake(
    IN PKSPIN Pin,
    IN PKSHANDSHAKE In,
    OUT PKSHANDSHAKE Out
    )

/*++

Routine Description:

    This routine performs a protocol handshake with a connected pin.

Arguments:

    Pin -
        Points to the pin structure for which the protocol handshake is
        to occur.  The request can only succeed if the pin is connected
        as a source pin or the connected pin also uses the KS 
        connection protocol.

    In -
        Points to a structure containing the handshake information to
        be passed to the connected pin.

    Out -
        Points to a structure to be filled with the handshake information
        from the connected pin.

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsPinHandshake]"));

    PAGED_CODE();

    ASSERT(Pin);
    ASSERT(In);
    ASSERT(Out);

    return CKsPin::FromStruct(Pin)->InitiateHandshake(In,Out);
}


KSDDKAPI
NTSTATUS
NTAPI
KsPinGetConnectedPinInterface(
    IN PKSPIN Pin,
    IN const GUID* InterfaceId,
    OUT PVOID* Interface
    )

/*++

Routine Description:

    This routine gets a control interface for the connected pin.

Arguments:

    Pin -
        Contains a pointer to the public pin object.

    InterfaceId -
        Contains a pointer to a GUID identifying the desired interface.

    Interface -
        Contains a pointer to the location at which the requested interface
        is deposited.  This interface pointer has a corresponding reference
        count, and must be released by the caller.

Return Value:

    Status.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsPinGetConnectedPinInterface]"));

    PAGED_CODE();

    ASSERT(Pin);
    ASSERT(InterfaceId);
    ASSERT(Interface);

    CKsPin* pin = CKsPin::FromStruct(Pin);
    PUNKNOWN unknown = pin->GetConnectionInterface();

    NTSTATUS status;
    if (unknown) {
        status = STATUS_SUCCESS;
    } else {
        PFILE_OBJECT fileObject = pin->GetConnectionFileObject();
        if (fileObject) { 
            status = KspCreateFileObjectThunk(&unknown,fileObject);
        } else {
            status = STATUS_UNSUCCESSFUL;
        }
    }

    if (NT_SUCCESS(status)) {
        ASSERT(unknown);
        status = unknown->QueryInterface(*InterfaceId,Interface);
        unknown->Release();
    }

    return status;
}


KSDDKAPI
PFILE_OBJECT
NTAPI
KsPinGetConnectedPinFileObject(
    IN PKSPIN Pin
    )

/*++

Routine Description:

    This routine gets a file object for the connected pin.

Arguments:

    Pin -
        Contains a pointer to the public pin object.

Return Value:

    The file object for the connected pin or NULL if the pin is not
    a source pin.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsPinGetConnectedPinFileObject]"));

    PAGED_CODE();

    ASSERT(Pin);

    CKsPin* pin = CKsPin::FromStruct(Pin);
    return pin->GetConnectionFileObject();
}


KSDDKAPI
PDEVICE_OBJECT
NTAPI
KsPinGetConnectedPinDeviceObject (
    IN PKSPIN Pin
    )

/*++

Routine Description:

    This routine gets a device object for the connected pin.  Note that
    this is returning the device object we send irps to.  This is the top
    of the connected pin's device stack.

Arguments:

    Pin -
        Contains a pointer to the public pin object.

Return Value:

    The device object for the connected pin or NULL if the pin is not
    a source pin.

--*/

{

    _DbgPrintF(DEBUGLVL_BLAB,("[KsPinGetConnectedPinDeviceObject]"));

    PAGED_CODE();

    ASSERT(Pin);

    CKsPin *pin = CKsPin::FromStruct(Pin);
    return pin->GetConnectionDeviceObject();

}


KSDDKAPI
NTSTATUS
NTAPI
KsPinGetConnectedFilterInterface(
    IN PKSPIN Pin,
    IN const GUID* InterfaceId,
    OUT PVOID* Interface
    )

/*++

Routine Description:

    This routine gets a control interface for the connected filter.

Arguments:

    Pin -
        Contains a pointer to the public pin object.

    InterfaceId -
        Contains a pointer to a GUID identifying the desired interface.

    Interface -
        Contains a pointer to the location at which the requested interface
        is deposited.  This interface pointer has a corresponding reference
        count, and must be released by the caller.

Return Value:

    Status.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsPinGetConnectedFilterInterface]"));

    PAGED_CODE();

    ASSERT(Pin);
    ASSERT(InterfaceId);
    ASSERT(Interface);

    CKsPin* pin = CKsPin::FromStruct(Pin);
    PIKSCONNECTION connection = pin->GetConnectionInterface();

    NTSTATUS status;
    PUNKNOWN unknown;
    if (connection) {
        unknown = connection->GetFilter();
        connection->Release();
        status = STATUS_SUCCESS;
    } else {
        PFILE_OBJECT fileObject = pin->GetConnectionFileObject();
        if (fileObject && fileObject->RelatedFileObject) { 
            status = KspCreateFileObjectThunk(&unknown,fileObject->RelatedFileObject);
        } else {
            status = STATUS_UNSUCCESSFUL;
        }
    }

    if (NT_SUCCESS(status)) {
        ASSERT(unknown);
        status = unknown->QueryInterface(*InterfaceId,Interface);
        unknown->Release();
    }

    return status;
}


KSDDKAPI
NTSTATUS
NTAPI
KsPinGetReferenceClockInterface(
    IN PKSPIN Pin,
    OUT PIKSREFERENCECLOCK* Interface
    )

/*++

Routine Description:

    This routine gets an interface for the pin's reference clock.

Arguments:

    Pin -
        Contains a pointer to the public pin object.

    Interface -
        Contains a pointer to the location at which the requested interface
        is deposited.  This interface pointer has a corresponding reference
        count, and must be released by the caller.

Return Value:

    Status.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsPinGetReferenceClockInterface]"));

    PAGED_CODE();

    ASSERT(Pin);
    ASSERT(Interface);

    CKsPin* pin = CKsPin::FromStruct(Pin);

    if (pin->GetMasterClockFileObject()) {
        *Interface = pin;
        pin->AddRef();

        return STATUS_SUCCESS;
    } else {
        return STATUS_DEVICE_NOT_READY;
    }
}


KSDDKAPI
void
NTAPI
KsPinRegisterFrameReturnCallback(
    IN PKSPIN Pin,
    IN PFNKSPINFRAMERETURN FrameReturn
    )

/*++

Routine Description:

    This routine registers a frame return callback.

Arguments:

    Pin -
        Contains a pointer to the public pin object.

    FrameReturn -
        Contains a pointer to the frame return callback function.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsPinRegisterFrameReturnCallback]"));

    PAGED_CODE();

    ASSERT(Pin);
    ASSERT(FrameReturn);

    CKsPin* pin = CKsPin::FromStruct(Pin);

    pin->GetProcessPin()->RetireFrameCallback = FrameReturn;
}


KSDDKAPI
void
NTAPI
KsPinRegisterIrpCompletionCallback(
    IN PKSPIN Pin,
    IN PFNKSPINIRPCOMPLETION IrpCompletion
    )

/*++

Routine Description:

    This routine registers a frame completion callback.  This callback is
    made when the Irp has completed it's traversal of the circuit.  For an
    output source, it will be made when the Irp is completed back to the
    requestor (from an external IoCompleteRequest or from an AVStream
    driver moving the Irp through the transport circuit).  For an input source,
    it will be made when the Irp returns to the requestor after the data
    is processed through the input queue.  It will **NOT** be made when the
    Irp completes into the queue (that would be a processing dispatch).

Arguments:

    Pin -
        Contains a pointer to the public pin object.

    IrpCompletion -
        Contains a pointer to the Irp completion callback function.

Return Value:

    None

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsPinRegisterIrpCompletionCallback]"));

    PAGED_CODE();

    ASSERT(Pin);
    ASSERT(IrpCompletion);

    CKsPin *pin = CKsPin::FromStruct(Pin);

    pin->GetProcessPin()->IrpCompletionCallback = IrpCompletion;

}


KSDDKAPI
void
NTAPI
KsPinRegisterHandshakeCallback(
    IN PKSPIN Pin,
    IN PFNKSPINHANDSHAKE Handshake
    )

/*++

Routine Description:

    This routine registers a handshake callback.

Arguments:

    Pin -
        Contains a pointer to the public pin object.

    FrameReturn -
        Contains a pointer to the handshake callback function.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsPinRegisterFrameReturnCallback]"));

    PAGED_CODE();

    ASSERT(Pin);
    ASSERT(Handshake);

    CKsPin* pin = CKsPin::FromStruct(Pin);

    pin->SetHandshakeCallback(Handshake);
}

#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif // ALLOC_PRAGMA


NTSTATUS
CKsPin::
SubmitFrame(
    IN PVOID Data OPTIONAL,
    IN ULONG Size OPTIONAL,
    IN PMDL Mdl OPTIONAL,
    IN PKSSTREAM_HEADER StreamHeader OPTIONAL,
    IN PVOID Context OPTIONAL
    )

/*++

Routine Description:

    This routine submits a frame.

Arguments:

    Data -
        Contains an optional pointer to the frame buffer.  This pointer should
        be NULL if and only if the Size argument is zero.

    Size -
        Contains the size in bytes of the frame buffer.  This argument should
        be zero if and only if the Data argument is NULL.

    Mdl -
        Contains an optional pointer to the Mdl.  If this argument is not NULL,
        Data and Size cannot be NULL and zero respectively.

    StreamHeader -
        Contains an optional pointer to a stream header.  The stream header
        will be copied if it is supplied.

    Context -
        Contains an optional pointer which will be returned when the frame is
        returned.  This pointer is for the caller's use.

Return Value:

    Status.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::SubmitFrame]"));

    ASSERT((Data == NULL) == (Size == 0));
    ASSERT((! Mdl) || (Data && Size));
    ASSERT(m_Process.RetireFrameCallback);

    PIKSREQUESTOR requestor =
        m_Process.PipeSection ? m_Process.PipeSection->Requestor : NULL;

    NTSTATUS status = STATUS_UNSUCCESSFUL;
    if (requestor) {
        //
        // We have a requestor.  The frame can be injected directly into the
        // circuit.
        //
        KSPFRAME_HEADER frameHeader;
        RtlZeroMemory(&frameHeader,sizeof(frameHeader));

        if (StreamHeader) {
            ASSERT(StreamHeader->Size >= sizeof(KSSTREAM_HEADER));
            ASSERT((StreamHeader->Size & FILE_QUAD_ALIGNMENT) == 0);

            frameHeader.StreamHeaderSize = StreamHeader->Size;
        } else {
            frameHeader.StreamHeaderSize = sizeof(KSSTREAM_HEADER);
        }

        frameHeader.StreamHeader = StreamHeader;
        frameHeader.FrameBufferSize = Size;
        frameHeader.FrameBuffer = Data;
        frameHeader.Mdl = Mdl;
        frameHeader.Context = Context;

        status = requestor->SubmitFrame(&frameHeader);
    } else {
        //
        // No requestor.  We have to copy the data into a queue.
        // TODO:  Assumes byte alignment.
        //
        if (Size) {
            PKSSTREAM_POINTER streamPointer;
            if (m_Process.PipeSection && m_Process.PipeSection->Queue) {
                PKSPSTREAM_POINTER sp =
                    m_Process.PipeSection->Queue->
                        GetLeadingStreamPointer(KSSTREAM_POINTER_STATE_LOCKED);

                streamPointer = sp ? &sp->Public : NULL;
            } else {
                streamPointer = NULL;
            }

            ULONG remaining = Size;
            PUCHAR data = PUCHAR(Data);
            while (streamPointer) {
                ASSERT(remaining);
                ASSERT(streamPointer->OffsetOut.Remaining);
                ULONG bytesToCopy = 
                    min(remaining,streamPointer->OffsetOut.Remaining);
                ASSERT(bytesToCopy);

                RtlCopyMemory(streamPointer->OffsetOut.Data,data,bytesToCopy);
                remaining -= bytesToCopy;
                data += bytesToCopy;

                if (remaining) {
                    status = 
                        KsStreamPointerAdvanceOffsets(
                            streamPointer,
                            0,
                            bytesToCopy,
                            FALSE);
                    if (! NT_SUCCESS(status)) {
                        streamPointer = NULL;
                    }
                } else {
                    KsStreamPointerAdvanceOffsetsAndUnlock(
                        streamPointer,
                        0,
                        bytesToCopy,
                        FALSE);
                    streamPointer = NULL;
                }
            }

            if (remaining) {
                status = STATUS_DEVICE_NOT_READY;
            }
        }

        m_Process.RetireFrameCallback(
            &m_Ext.Public,
            Data,
            Size,
            Mdl,
            Context,
            status);
    }

    return status;
}


KSDDKAPI
NTSTATUS
NTAPI
KsPinSubmitFrame(
    IN PKSPIN Pin,
    IN PVOID Data OPTIONAL,
    IN ULONG Size OPTIONAL,
    IN PKSSTREAM_HEADER StreamHeader OPTIONAL,
    IN PVOID Context OPTIONAL
    )

/*++

Routine Description:

    This routine submits a frame.

Arguments:

    Pin -
        Contains a pointer to the public pin object.

    Data -
        Contains an optional pointer to the frame buffer.  This pointer should
        be NULL if and only if the Size argument is zero.

    Size -
        Contains the size in bytes of the frame buffer.  This argument should
        be zero if and only if the Data argument is NULL.

    StreamHeader -
        Contains an optional pointer to a stream header.  The stream header
        will be copied if it is supplied.

    Context -
        Contains an optional pointer which will be returned when the frame is
        returned.  This pointer is for the caller's use.

Return Value:

    Status.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsPinSubmitFrame]"));

    ASSERT(Pin);
    ASSERT((Data == NULL) == (Size == 0));

    CKsPin* pin = CKsPin::FromStruct(Pin);

    return pin->SubmitFrame(Data,Size,NULL,StreamHeader,Context);
}


KSDDKAPI
NTSTATUS
NTAPI
KsPinSubmitFrameMdl(
    IN PKSPIN Pin,
    IN PMDL Mdl OPTIONAL,
    IN PKSSTREAM_HEADER StreamHeader OPTIONAL,
    IN PVOID Context OPTIONAL
    )

/*++

Routine Description:

    This routine submits a frame.

Arguments:

    Pin -
        Contains a pointer to the public pin object.

    Mdl -
        Contains an optional pointer to an MDL for the frame buffer.

    StreamHeader -
        Contains an optional pointer to a stream header.  The stream header
        will be copied if it is supplied.

    Context -
        Contains an optional pointer which will be returned when the frame is
        returned.  This pointer is for the caller's use.

Return Value:

    Status.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsPinSubmitFrameMdl]"));

    ASSERT(Pin);

    CKsPin* pin = CKsPin::FromStruct(Pin);

    return 
        pin->SubmitFrame(
            Mdl ? MmGetSystemAddressForMdl(Mdl) : NULL,
            Mdl ? MmGetMdlByteCount(Mdl) : 0,
            Mdl,
            StreamHeader,
            Context);
}


STDMETHODIMP_(PKSGATE)
CKsPin::
GetAndGate(
    void
    )

/*++

Routine Description:

    This routine gets a pointer to the KSGATE used for processing control.

Arguments:

    None.

Return Value:

    A pointer to the KSGATE used for processing control.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::GetAndGate]"));

    return &m_AndGate;
}


STDMETHODIMP_(void)
CKsPin::
TriggerNotification(
    void
    )

/*++

Routine Description:

    A triggering event has happened on this processing object.  This is merely
    a notification.  All we do is increment the event counter.

Arguments:

    None

Return Value:

    None

--*/

{

    InterlockedIncrement (&m_TriggeringEvents);

}


STDMETHODIMP_(void)
CKsPin::
Process(
    IN BOOLEAN Asynchronous
    )

/*++

Routine Description:

    This routine invokes frame processing in an arbitrary context.

Arguments:

    Asynchronous -
        Contains an indication of whether processing should occur in an
        asynchronous context so the calling thread does not need to wait
        for processing to occur.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::Process]"));

    //
    // Do not process a pin which is a copy destination.  Originally,
    // the queues were going to be bound to prevent the call from even
    // happening, but that solution doesn't work...  Just ignore the
    // process message for copy destinations.
    //
    if (m_Process.CopySource)
        return;

    if (! m_DispatchProcess) {
        return;
    }

    if (Asynchronous ||
        (m_ProcessPassive && (KeGetCurrentIrql() > PASSIVE_LEVEL))) {
        KsQueueWorkItem(m_ProcessingWorker, &m_WorkItemProcessing);
    } else {
        ProcessingObjectWork();
    }
}


void
CKsPin::
GetCopyRelationships(
    OUT PKSPIN* CopySource,
    OUT PKSPIN* DelegateBranch
    )

/*++

Routine Description:

    Get the copy relationships of this pin.  This will be the same information
    contained in the process pins index.  The function is really only useful
    for pin-centric pins which are doing splitting.  Note that this information
    is only useful while appropriate mutex is held (filter processing or a 
    client mutex which guarantees exclusion with device state).

Arguments:

    CopySource -
        Contains a pointer to a PKSPIN into which will be deposited the copy
        source pin.  If there is no copy source for this pin, NULL will be
        placed here.

    DelegateBranch -
        Contains a pointer to a PKSPIN into which will be deposited the 
        delegate branch pin.  If there is no delegate branch pin, NULL will
        be placed here.

Return Value:

    None

--*/

{

    ASSERT (CopySource);
    ASSERT (DelegateBranch);

    if (m_Process.CopySource) {
        *CopySource = m_Process.CopySource -> Pin;
    } else {
        *CopySource = NULL;
    }

    if (m_Process.DelegateBranch) {
        *DelegateBranch = m_Process.DelegateBranch -> Pin;
    } else {
        *DelegateBranch = NULL;
    }

    //
    // Don't need inplace because pin centric filters do NOT do inplace
    // transforms!
    //

}


KSDDKAPI
void
NTAPI
KsPinGetCopyRelationships(
    IN PKSPIN Pin,
    OUT PKSPIN* CopySource,
    OUT PKSPIN* DelegateBranch 
    )

/*++

Routine Description:

    Get the copy relationships of this pin.  This will be the same information
    contained in the process pins index.  The function is really only useful
    for pin-centric pins which are doing splitting.  Note that this information
    is only useful while appropriate mutex is held (filter processing or a 
    client mutex which guarantees exclusion with device state).

Arguments:

    Pin -
        Points to the pin for which to get copy relationships.

    CopySource -
        Contains a pointer to a PKSPIN into which will be deposited the copy
        source pin.  If there is no copy source for this pin, NULL will be
        placed here.

    DelegateBranch -
        Contains a pointer to a PKSPIN into which will be deposited the 
        delegate branch pin.  If there is no delegate branch pin, NULL will
        be placed here.

Return Value:

    None

--*/

{

    _DbgPrintF(DEBUGLVL_BLAB,("[KsPinGetCopyRelationships]"));

    ASSERT(Pin);
    ASSERT(CopySource);
    ASSERT(DelegateBranch);

    return CKsPin::FromStruct(Pin)->GetCopyRelationships (CopySource,
        DelegateBranch);

}


#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA


STDMETHODIMP_(void)
CKsPin::
Reset(
    void
    )

/*++

Routine Description:

    This routine transmits a reset to the client when a flush occurs.

Arguments:

    None.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::Reset]"));

    PAGED_CODE();

    AcquireProcessSync();
    ReleaseProcessSync();

    if (m_DispatchReset) {
        m_DispatchReset(&m_Ext.Public);
    }
}


STDMETHODIMP_(void)
CKsPin::
Sleep(
    IN DEVICE_POWER_STATE State
    )

/*++

Routine Description:

    This routine handles notification that the device is going to sleep.

Arguments:

    State -
        Contains the device power state.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::Sleep]"));

    PAGED_CODE();

    KsGateAddOffInputToAnd(&m_AndGate);

    AcquireProcessSync();
    ReleaseProcessSync();

    if (m_DispatchSleep) {
        m_DispatchSleep(&m_Ext.Public,State);
    }
}


STDMETHODIMP_(void)
CKsPin::
Wake(
    void
    )

/*++

Routine Description:

    This routine handles notification that the device is waking.

Arguments:

    None.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::Wake]"));

    PAGED_CODE();

    KsGateRemoveOffInputFromAnd(&m_AndGate);

    if (m_DispatchWake) {
        m_DispatchWake(&m_Ext.Public,PowerDeviceD0);
    }

    if (KsGateCaptureThreshold(&m_AndGate)) {
        Process(TRUE);
    }
}

#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif // ALLOC_PRAGMA


STDMETHODIMP_(void)
CKsPin::
ProcessingObjectWork(
    void
    )

/*++

Routine Description:

    This routine processes frames.  Upon entering this function, reentry is
    prevented by a count on the semaphore.  The caller must obtain permission
    to call this function using an InterlockedCompareExchange, so we know
    there is a count on the semaphore preventing another call.  This count
    must be removed before this function returns.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::ProcessingObjectWork]"));

    //
    // We syncronize with KeWaitForSingleObject() so the code we synchronize with
    // may be paged even if processing is done at DISPATCH_LEVEL.  If we are
    // at DISPATCH_LEVEL, we can't wait here, so we arrange to be called again.
    //
    if (KeGetCurrentIrql() == PASSIVE_LEVEL) {
        //
        // Simple wait.
        //
        KeWaitForSingleObject(
            &m_Mutex,
            Executive,
            KernelMode,
            FALSE,
            NULL);
    } else {
        //
        // Wait with zero timeout and arrange to be called if we don't get
        // the mutex.
        //
	ASSERT( !m_ProcessOnRelease );
        m_ProcessOnRelease = 1;

        //
        // We have to synchronize with a thread that owns the mutex when we
        // start servicing this DISPATCH_LEVEL processing request.  We CANNOT
        // run if the current thread already owns the mutex.  Dispatch level
        // processing must treat an already owned mutex as a semaphore and
        // NOT reacquire it.
        //
        if (KeReadStateMutex(&m_Mutex) != 1) {
            m_ProcessOnRelease = 2;
            return;
        }

        LARGE_INTEGER timeout;
        timeout.QuadPart = 0;
        NTSTATUS status = 
            KeWaitForSingleObject(
                &m_Mutex,
                Executive,
                KernelMode,
                FALSE,
                &timeout);

        if (status == STATUS_TIMEOUT) {
            m_ProcessOnRelease = 2;
            return;
        }

        m_ProcessOnRelease = 0;
    }

    ASSERT(m_DispatchProcess);

    //
    // Loop until we are out of data.
    //
    NTSTATUS status;
    while (1) {
        BOOLEAN ProcessOnPend = FALSE; 

        ASSERT(m_AndGate.Count <= 0);
        if (m_AndGate.Count == 0) {

            InterlockedExchange (&m_TriggeringEvents, 0);

            //
            // Call the client function.
            //
            status = m_DispatchProcess(&m_Ext.Public);

            //
            // Quit if the client has not indicated continuation.
            //
            if ((status == STATUS_PENDING) || ! NT_SUCCESS(status)) {
                KsGateTurnInputOn(&m_AndGate);
                if (m_TriggeringEvents == 0)
                    break;

                ProcessOnPend = TRUE;
            }
        }

        //
        // Determine if we have enough data to continue.
        //
        if (m_AndGate.Count != 0) {
            if (!ProcessOnPend)
                KsGateTurnInputOn(&m_AndGate);

            if (! KsGateCaptureThreshold(&m_AndGate)) {
                break;
            }
        } else if (ProcessOnPend) {
            //
            // If we've gotten here, one of two things has happened. 
            //
            //     1: Another thread captured threshold and will process.
            //
            //     2: The client lowered the gate manually.
            //
            // There is no way to detect which case here.  We will break out
            // and release the mutex.  If processing was to recommence, this
            // will defer it to the waiting thread.
            //
            break;
        }
    }

    ReleaseProcessSync();
}


STDMETHODIMP_(void) 
CKsPin::
RetireFrame(
    IN PKSPFRAME_HEADER FrameHeader,
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This routine retires a frame back to the client.

Arguments:

    FrameHeader -
        Contains a pointer to the frame header describing the frame.

    Status -
        Contains the status associated with the frame submission.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::RetireFrame]"));

    ASSERT(FrameHeader);
    ASSERT(m_Process.RetireFrameCallback);

    m_Process.RetireFrameCallback(
        &m_Ext.Public,
        FrameHeader->FrameBuffer,
        FrameHeader->FrameBufferSize,
        FrameHeader->Mdl,
        FrameHeader->Context,
        Status
    );
}


STDMETHODIMP_(void)
CKsPin::
CompleteIrp(
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called when an Irp is completed back to the requestor.

Arguments:

    Irp -
        The Irp being completed

Return Value:

    None

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPin::CompleteIrp]"));

    ASSERT (Irp);

    m_Process.IrpCompletionCallback(
        &m_Ext.Public,
        Irp
        );

}


STDMETHODIMP
CKsPin::
Reevaluate (
    void
    )

/*++

Routine Description:

    Stub.

Arguments:

Return Value:

--*/

{

    //
    // What would this mean?  Changes to a single pin instance dynamically?
    //

    return STATUS_NOT_IMPLEMENTED;
}


STDMETHODIMP
CKsPin::
ReevaluateCalldown (
    IN ULONG ArgumentCount,
    ...
/* << THIS MAY NEED TO EXPAND!!!!! >>
        IN const KSPIN_DESCRIPTOR_EX* Descriptor,
        IN PULONG FilterPinCount,
        IN PLIST_ENTRY SiblingListHead

*/
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{

    va_list Arguments;

    KSPIN_DESCRIPTOR_EX* Descriptor;
    PULONG FilterPinCount;
    PLIST_ENTRY SiblingListHead;

    ASSERT (ArgumentCount == 3);

    va_start (Arguments, ArgumentCount);

    Descriptor = va_arg (Arguments, KSPIN_DESCRIPTOR_EX *);
    FilterPinCount = va_arg (Arguments, PULONG);
    SiblingListHead = va_arg (Arguments, PLIST_ENTRY);

    //
    // Recache information which has changed about our parent filter
    //

    m_Ext.Public.Descriptor = Descriptor;
    m_Ext.SiblingListHead = SiblingListHead;
    m_FilterPinCount = FilterPinCount;

    //
    // Do we have to pass anything down to our children?
    //

    return STATUS_SUCCESS;

}


KSDDKAPI
PKSGATE
NTAPI
KsPinGetAndGate(
    IN PKSPIN Pin
    )

/*++

Routine Description:

    This routine gets the KSGATE that controls processing for the pin.

Arguments:

    Pin -
        Contains a pointer to the public filter pin.

Return Value:

    A pointer to the KSGATE that controls processing for the pin.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsPinGetAndGate]"));

    ASSERT(Pin);

    return CKsPin::FromStruct(Pin)->GetAndGate();
}

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA


KSDDKAPI
void
NTAPI
KsPinAttachAndGate(
    IN PKSPIN Pin,
    IN PKSGATE AndGate OPTIONAL
    )

/*++

Routine Description:

    This routine attaches a KSGATE to a pin.  An input to the gate will
    be turned on when there is data queued at the pin and turned off when there
    is no data queued at the pin.  This function should only be called in
    stop state.  Gate attachments are sampled on the transition from stop to
    acquire.

Arguments:

    Pin -
        Contains a pointer to the public filter pin.

    AndGate -
        Contains an optional pointer to the KSGATE.  If this argument is
        NULL, any KSGATE currently attached to the pin is detached.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsPinAttachAndGate]"));

    ASSERT(Pin);

    PKSPPROCESSPIN processPin = CKsPin::FromStruct(Pin)->GetProcessPin();
    processPin->FrameGate = AndGate;
    processPin->FrameGateIsOr = FALSE;
}


KSDDKAPI
void
NTAPI
KsPinAttachOrGate(
    IN PKSPIN Pin,
    IN PKSGATE OrGate OPTIONAL
    )

/*++

Routine Description:

    This routine attaches a KSGATE to a pin.  An input to the gate will
    be turned on when there is data queued at the pin and turned off when there
    is no data queued at the pin.  This function should only be called in
    stop state.  Gate attachments are sampled on the transition from stop to
    acquire.

Arguments:

    Pin -
        Contains a pointer to the public filter pin.

    OrGate -
        Contains an optional pointer to the KSGATE.  If this argument is
        NULL, any KSGATE currently attached to the pin is detached.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsPinAttachOrGate]"));

    ASSERT(Pin);

    PKSPPROCESSPIN processPin = CKsPin::FromStruct(Pin)->GetProcessPin();
    processPin->FrameGate = OrGate;
    processPin->FrameGateIsOr = TRUE;
}


KSDDKAPI
void
NTAPI
KsPinAcquireProcessingMutex(
    IN PKSPIN Pin
    )

/*++

Routine Description:

    This routine acquires the processing mutex.

Arguments:

    Pin -
        Contains a pointer to the public pin object.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsPinAcquireProcessingMutex]"));

    PAGED_CODE();

    ASSERT(Pin);

    CKsPin *pin = CKsPin::FromStruct(Pin);

    pin->AcquireProcessSync();
}


KSDDKAPI
void
NTAPI
KsPinReleaseProcessingMutex(
    IN PKSPIN Pin
    )

/*++

Routine Description:

    This routine releases the processing mutex.

Arguments:

    Pin -
        Contains a pointer to the public pin object.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsPinReleaseProcessingMutex]"));

    PAGED_CODE();

    ASSERT(Pin);

    CKsPin *pin = CKsPin::FromStruct(Pin);

    pin->ReleaseProcessSync();
}

#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif // ALLOC_PRAGMA


KSDDKAPI
BOOLEAN
NTAPI
KsProcessPinUpdate(
    IN PKSPROCESSPIN ProcessPin
    )

/*++

Routine Description:

    This routine updates a process pin from inside a filter-centric filter's
    process dispatch.

Arguments:

    ProcessPin-
        Contains a pointer to the process pin to be updated.

Return Value:

    A boolean indicating whether or not if this was the original prepare, this
    pipe section would have allowed or denied processing.

--*/

{

    _DbgPrintF(DEBUGLVL_BLAB,("[KsProcessPinUpdate]"));

    return (CKsPin::FromStruct (ProcessPin -> Pin) -> UpdateProcessPin ());

}


KSDDKAPI
void
NTAPI
KsPinAttemptProcessing(
    IN PKSPIN Pin,
    IN BOOLEAN Asynchronous
    )

/*++

Routine Description:

    This routine attempts pin processing.

Arguments:

    Pin -
        Contains a pointer to the public pin object.

    Asynchronous - 
        Contains an indication of whether processing should occur
        asyncronously with respect to the calling thread.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsPinAttemptProcessing]"));

    ASSERT(Pin);

    CKsPin *pin = CKsPin::FromStruct(Pin);

    //
    // Manually attempting processing is a triggerable event.  If they
    // are currently processing and pend, we call them back due to this.
    //
    pin->TriggerNotification();

    if (KsGateCaptureThreshold(pin->GetAndGate())) {
        pin->Process(Asynchronous);
    }
}


VOID
CKsPin::
SetPinClockState(
    IN KSSTATE State
    )

/*++

Routine Description:

    Sets the current state of the clock exposed by this pin. Synchronizes
    with any time changes occuring.

    This may be called at DISPATCH_LEVEL.

Arguments:

    State - 
        Contains the new state to set the clock to.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[SetPinClockState]"));

    ASSERT(m_DefaultClock);
    //
    // Serialize access with any attempt to set the current
    // time on the pin's clock.
    //
    KIRQL oldIrql;
    KeAcquireSpinLock(&m_DefaultClockLock,&oldIrql);
    KsSetDefaultClockState(m_DefaultClock,State);
    KeReleaseSpinLock(&m_DefaultClockLock,oldIrql);
}


void
CKsPin::
SetPinClockTime(
    IN LONGLONG Time
    )

/*++

Routine Description:

    Sets the current time of the clock exposed by this pin. This modifies
    the current time returned by the clock. Synchronizes with any state
    changes occuring.

    If an external clock is used, this function can still be used to force a
    resetting of the current timer when an external timer is not being used.
    In this case the time provided is ignored and must be set to zero.

    This may be called at DISPATCH_LEVEL.

Arguments:

    Time - 
        Contains the new time to set the clock to.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[SetPinClockTime]"));

    ASSERT(m_DefaultClock);
    //
    // Serialize access with any attempt to set the state
    // on the pin's clock.
    //
    KIRQL oldIrql;
    KeAcquireSpinLock(&m_DefaultClockLock,&oldIrql);
    KsSetDefaultClockTime(m_DefaultClock, Time);
    KeReleaseSpinLock(&m_DefaultClockLock,oldIrql);
}


KSDDKAPI
VOID
NTAPI
KsPinSetPinClockTime(
    IN PKSPIN Pin,
    IN LONGLONG Time
    )

/*++

Routine Description:

    Sets the current time of the clock exposed by this pin. This modifies
    the current time returned by the clock.

    If an external clock is used, this function can still be used to force a
    resetting of the current timer when an external timer is not being used.
    In this case the time provided is ignored and must be set to zero.

    This may be called at DISPATCH_LEVEL.

Arguments:

    Pin -
        Contains a pointer to the public pin object.

    Time - 
        Contains the new time to set the clock to.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsPinSetPinClockTime]"));

    ASSERT(Pin);

    CKsPin::FromStruct(Pin)->SetPinClockTime(Time);
}


KSDDKAPI
PKSPIN
NTAPI
KsGetPinFromIrp(
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns the pin to which an IRP was submitted.

Arguments:

    Irp -
        Contains a pointer to an IRP which must have been sent to a file
        object corresponding to a pin or node.

Return Value:

    A pointer to the pin to which the IRP was submitted.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsGetPinFromIrp]"));

    ASSERT(Irp);

    //
    // Check for device level Irps...
    //
    if (IoGetCurrentIrpStackLocation (Irp)->FileObject == NULL)
        return NULL;

    PKSPX_EXT ext = KspExtFromIrp(Irp);

    if (ext->ObjectType == KsObjectTypePin) {
        return PKSPIN(&ext->Public);
    } else if (ext->ObjectType == KsObjectTypeFilter) {
        return NULL;
    } else {
        ASSERT(! "No support for node objects yet");
        return NULL;
    }
}

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA


KSDDKAPI
void
NTAPI
KsPinRegisterPowerCallbacks(
    IN PKSPIN Pin,
    IN PFNKSPINPOWER Sleep OPTIONAL,
    IN PFNKSPINPOWER Wake OPTIONAL
    )

/*++

Routine Description:

    This routine registers power managment callbacks.

Arguments:

    Pin -
        Contains a pointer to the pin for which callbacks are being registered.

    Sleep -
        Contains an optional pointer to the sleep callback.

    Wake -
        Contains an optional pointer to the wake callback.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsPinRegisterPowerCallbacks]"));

    PAGED_CODE();

    ASSERT(Pin);

    CKsPin::FromStruct(Pin)->SetPowerCallbacks(Sleep,Wake);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\ks\shqueue.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    shqueue.cpp

Abstract:

    This module contains the implementation of the kernel streaming 
    queue object.

Author:

    Dale Sather  (DaleSat) 31-Jul-1998

--*/

#ifndef __KDEXT_ONLY__
#include "ksp.h"
#include <kcom.h>
#endif // __KDEXT_ONLY__

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA

//
// CKsQueue is the implementation of the kernel  queue object.
//
class CKsQueue:
    public IKsQueue,
    public CBaseUnknown
{
#ifndef __KDEXT_ONLY__
private:
#else // __KDEXT_ONLY__
public:
#endif // __KDEXT_ONLY__
    PIKSPIPESECTION m_PipeSection;
    PIKSPROCESSINGOBJECT m_ProcessingObject;

    PIKSTRANSPORT m_TransportSink;
    PIKSTRANSPORT m_TransportSource;
    BOOLEAN m_Flushing;
    BOOLEAN m_EndOfStream;
    KSSTATE m_State;
    KSSTATE m_MinProcessingState;

    ULONG m_ProbeFlags; 
    BOOLEAN m_CancelOnFlush;
    BOOLEAN m_UseMdls;
    BOOLEAN m_InputData;
    BOOLEAN m_OutputData;
    BOOLEAN m_WriteOperation;
    BOOLEAN m_GenerateMappings; 
    BOOLEAN m_ZeroWindowSize;
    BOOLEAN m_ProcessPassive;
    BOOLEAN m_ProcessAsynchronously;
    BOOLEAN m_InitiateProcessing;
    BOOLEAN m_ProcessOnEveryArrival;
    BOOLEAN m_DepartInSequence;

    BOOLEAN m_FramesNotRequired;

    PKSPIN m_MasterPin;

    PIKSDEVICE m_Device;
    PDEVICE_OBJECT m_FunctionalDeviceObject;
    PADAPTER_OBJECT m_AdapterObject;
    ULONG m_MaxMappingByteCount;
    ULONG m_MappingTableStride;

    PKSGATE m_AndGate;
    PKSGATE m_FrameGate;
    BOOLEAN m_FrameGateIsOr;

    PKSGATE m_StateGate;
    BOOLEAN m_StateGateIsOr;

    LONG m_FramesReceived;
    LONG m_FramesWaiting;
    LONG m_FramesCancelled;
    LONG m_StreamPointersPlusOne;

    PFNKSFRAMEDISMISSALCALLBACK m_FrameDismissalCallback;
    PVOID m_FrameDismissalContext;

    LIST_ENTRY m_StreamPointers;
    INTERLOCKEDLIST_HEAD m_FrameQueue;
    INTERLOCKEDLIST_HEAD m_FrameHeadersAvailable;
    INTERLOCKEDLIST_HEAD m_FrameCopyList;
    LIST_ENTRY m_WaitingIrps;
    KEVENT m_DestructEvent;

    KDPC m_Dpc;
    KTIMER m_Timer;
    LIST_ENTRY m_TimeoutQueue;
    LONGLONG m_BaseTime;
    LONGLONG m_Interval;

#if DBG
    KDPC m_DbgDpc;
    KTIMER m_DbgTimer;
#endif

    PKSPSTREAM_POINTER m_Leading;
    PKSPSTREAM_POINTER m_Trailing;

    //
    // Statistics
    //
    LONG m_AvailableInputByteCount;
    LONG m_AvailableOutputByteCount;

    //
    // Synchronization
    //
    // Keeps track of the number of Irps flowing through the queue.  This
    // in effect synchronizes a stop with Irp arrival so that an Irp
    // doesn't find itself stuck in the queue and deadlock the stop.
    // 
    // >1 = Irps are flowing in the circuit CKsQueue::TransferKsIrp
    // 1 = no Irps are flowing through the circuit
    // 0 = stop is progressing.
    //
    LONG m_TransportIrpsPlusOne;
    KEVENT m_FlushEvent;

    LONG m_InternalReferenceCountPlusOne;
    KEVENT m_InternalReferenceEvent;

    NPAGED_LOOKASIDE_LIST m_ChannelContextLookaside;

    //
    // Flush Worker
    //
    WORK_QUEUE_ITEM m_FlushWorkItem;
    PKSWORKER m_FlushWorker;

    PRKTHREAD m_LockContext;

public:
    DEFINE_LOG_CONTEXT(m_Log);
    DEFINE_STD_UNKNOWN();
    IMP_IKsQueue;

    CKsQueue(PUNKNOWN OuterUnknown);
    ~CKsQueue();

    NTSTATUS
    Init(
        OUT PIKSQUEUE* Queue,
        IN ULONG Flags,
        IN PIKSPIPESECTION OwnerPipeSectionInterface,
        IN PIKSPROCESSINGOBJECT ProcessingObject,
        IN PKSPIN MasterPin,
        IN PKSGATE FrameGate OPTIONAL,
        IN BOOLEAN FrameGateIsOr,
        IN PKSGATE StateGate OPTIONAL,
        IN PIKSDEVICE Device,
        IN PDEVICE_OBJECT FunctionalDeviceObject,
        IN PADAPTER_OBJECT AdapterObject OPTIONAL,
        IN ULONG MaxMappingByteCount OPTIONAL,
        IN ULONG MappingTableStride OPTIONAL,
        IN BOOLEAN InputData,
        IN BOOLEAN OutputData
        );

private:
    NTSTATUS
    CreateStreamPointer(
        OUT PKSPSTREAM_POINTER* StreamPointer
        );
    void
    SetStreamPointer(
        IN PKSPSTREAM_POINTER StreamPointer,
        IN PKSPFRAME_HEADER FrameHeader OPTIONAL,
        IN PIRP* IrpToBeReleased OPTIONAL
        );
    FORCEINLINE
    PKSPFRAME_HEADER
    NextFrameHeader(
        IN PKSPFRAME_HEADER FrameHeader
        );
    PKSPFRAME_HEADER
    GetAvailableFrameHeader(
        IN ULONG StreamHeaderSize OPTIONAL
        );
    void
    PutAvailableFrameHeader(
        IN PKSPFRAME_HEADER FrameHeader
        );
    void
    CancelStreamPointers(
        IN PIRP Irp
        );
    void
    CancelAllIrps(
        void
        );
    void
    RemoveIrpFrameHeaders(
        IN PIRP Irp
        );
    void
    AddFrame(
        IN PKSPFRAME_HEADER FrameHeader
        );
    PKSPMAPPINGS_TABLE
    CreateMappingsTable(
        IN PKSPFRAME_HEADER FrameHeader
        );
    void
    DeleteMappingsTable(
        IN PKSPMAPPINGS_TABLE MappingsTable
        );
    void
    FreeMappings(
        IN PKSPMAPPINGS_TABLE MappingsTable
        );
    void
    PassiveFlush(
        void
        );
    void
    Flush(
        void
        );
    static
    void
    CancelRoutine(
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
        );
    void
    ReleaseIrp(
        IN PIRP Irp,
        IN PKSPIRP_FRAMING IrpFraming,
        OUT PIKSTRANSPORT* NextTransport OPTIONAL
        );
    void
    ForwardIrp(
        IN PIRP Irp,
        IN PKSPIRP_FRAMING IrpFraming,
        OUT PIKSTRANSPORT* NextTransport OPTIONAL
        );
    void
    ForwardWaitingIrps(
        void
        );
    static
    IO_ALLOCATION_ACTION
    CallbackFromIoAllocateAdapterChannel(
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Reserved,
        IN PVOID MapRegisterBase,
        IN PVOID Context
        );
    void
    ZeroIrp(
        IN PIRP Irp
        );
    static
    void
    DispatchTimer(
        IN PKDPC Dpc,
        IN PVOID DeferredContext,
        IN PVOID SystemArgument1,
        IN PVOID SystemArgument2
        );
    LONGLONG
    GetTime(
        IN BOOLEAN Reset
        );
    void
    SetTimerUnsafe(
        IN LONGLONG CurrentTime
        );
    void
    SetTimer(
        IN LONGLONG CurrentTime
        );
    void
    CancelTimeoutUnsafe(
        IN PKSPSTREAM_POINTER StreamPointer
        );
    void
    FreeStreamPointer(
        IN PKSPSTREAM_POINTER StreamPointer
        );
    static
    void
    FlushWorker (
        IN PVOID Context
        )
    {
        // Perform a deferred flush.
        ((CKsQueue *)Context)->PassiveFlush();
        KsDecrementCountedWorker (((CKsQueue *)Context)->m_FlushWorker);
    }
    static
    void
    ReleaseCopyReference (
        IN PKSSTREAM_POINTER streamPointer
        );
    BOOLEAN 
    CompleteWaitingFrames (
        void
        );
    void
    FrameToFrameCopy (
        IN PKSPSTREAM_POINTER ForeignSource,
        IN PKSPSTREAM_POINTER LocalDestination
        );

#if DBG
    STDMETHODIMP_(void)
    DbgPrintQueue(
        void
        );
    void
    CKsQueue::
    DbgPrintStreamPointer(
        IN PKSPSTREAM_POINTER StreamPointer OPTIONAL
        );
    void
    DbgPrintFrameHeader(
        IN PKSPFRAME_HEADER FrameHeader OPTIONAL
        );
    static
    void
    DispatchDbgTimer(
        IN PKDPC Dpc,
        IN PVOID DeferredContext,
        IN PVOID SystemArgument1,
        IN PVOID SystemArgument2
        );

#endif
};

#ifndef __KDEXT_ONLY__

#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif // ALLOC_PRAGMA


inline
PKSPFRAME_HEADER
CKsQueue::
NextFrameHeader (
    IN PKSPFRAME_HEADER FrameHeader
    )

/*++

Routine Description:

    Returns the next frame past FrameHeader in the frame queue.  Note that
    this was pulled out of line and specified as inline due to the fact that
    some builds were placing this out of line in a pageable code segment.
    This routine, if pulled out of line by the compiler, must be 
    non-pageable.

Arguments:

    FrameHeader -
        Points to the frame header of which to get the next frame header

Return Value:

    The next frame header in the frame queue to FrameHeader

--*/

{
    return
        (FrameHeader->ListEntry.Flink == &m_FrameQueue.ListEntry) ?
        NULL :
        CONTAINING_RECORD(
            FrameHeader->ListEntry.Flink,
            KSPFRAME_HEADER,
            ListEntry);
}


NTSTATUS
CKsQueue::
CreateStreamPointer(
    OUT PKSPSTREAM_POINTER* StreamPointer
    )

/*++

Routine Description:

    This routine creates a stream pointer.

Arguments:

    StreamPointer -
        Contains a pointer to the location at which a pointer to the created
        stream pointer should be deposited.

Return Value:

    Status.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsQueue::CreateStreamPointer]"));

    ASSERT(StreamPointer);

    PKSPSTREAM_POINTER streamPointer = (PKSPSTREAM_POINTER)
        ExAllocatePoolWithTag(
            NonPagedPool,
            sizeof(KSPSTREAM_POINTER),
            POOLTAG_STREAMPOINTER);

    NTSTATUS status;
    if (streamPointer) {
        //InterlockedIncrement(&m_StreamPointersPlusOne);

        RtlZeroMemory(streamPointer,sizeof(KSPSTREAM_POINTER));

        streamPointer->State = KSPSTREAM_POINTER_STATE_UNLOCKED;
        streamPointer->Type = KSPSTREAM_POINTER_TYPE_NORMAL;
        streamPointer->Stride = m_MappingTableStride;
        streamPointer->Queue = this;
        streamPointer->Public.Pin = m_MasterPin;
        if (m_InputData) {
            streamPointer->Public.Offset = &streamPointer->Public.OffsetIn;
        } else {
            streamPointer->Public.Offset = &streamPointer->Public.OffsetOut;
        }

        *StreamPointer = streamPointer;

        status = STATUS_SUCCESS;
    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return status;
}


STDMETHODIMP
CKsQueue::
CloneStreamPointer(
    OUT PKSPSTREAM_POINTER* StreamPointer,
    IN PFNKSSTREAMPOINTER CancelCallback OPTIONAL,
    IN ULONG ContextSize,
    IN PKSPSTREAM_POINTER StreamPointerToClone,
    IN KSPSTREAM_POINTER_TYPE StreamPointerType
    )

/*++

Routine Description:

    This routine creates a stream pointer.

Arguments:

Return Value:

    Status.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsQueue::CloneStreamPointer]"));

    ASSERT(StreamPointer);

    PKSPSTREAM_POINTER streamPointer = (PKSPSTREAM_POINTER)
        ExAllocatePoolWithTag(
            NonPagedPool,
            sizeof(KSPSTREAM_POINTER) + ContextSize,
            POOLTAG_STREAMPOINTER);

    NTSTATUS status;
    if (streamPointer) {
        if (StreamPointerType == KSPSTREAM_POINTER_TYPE_INTERNAL)
            InterlockedIncrement(&m_InternalReferenceCountPlusOne);

        InterlockedIncrement(&m_StreamPointersPlusOne);

        //
        // Copy and whatnot after taking the spinlock.  Need to make sure the
        // frame is stable while we are copying and incrementing references.
        //
        // Internal stream pointers are always cloned from a context where the
        // queue spinlock is ALREADY held.
        //
        KIRQL oldIrql;
        if (StreamPointerType != KSPSTREAM_POINTER_TYPE_INTERNAL)
            KeAcquireSpinLock(&m_FrameQueue.SpinLock,&oldIrql);

        RtlCopyMemory(
            streamPointer,
            StreamPointerToClone,
            sizeof(KSPSTREAM_POINTER));

        //
        // Set the type as internal or not
        //
        streamPointer->Type = StreamPointerType;

        //
        // Fix the offset pointer.
        //
        if (m_InputData) {
            streamPointer->Public.Offset = &streamPointer->Public.OffsetIn;
        } else {
            streamPointer->Public.Offset = &streamPointer->Public.OffsetOut;
        }

        streamPointer->TimeoutListEntry.Flink = NULL;

        //
        // Fix the context pointer if we are providing context.
        //
        if (ContextSize) {
            streamPointer->Public.Context = streamPointer + 1;
            RtlZeroMemory(streamPointer->Public.Context,ContextSize);
        }

        //
        // Increment frame and IRP references as required.
        //
        if (streamPointer->FrameHeader) {
            streamPointer->FrameHeader->RefCount++;
            if (streamPointer->State == KSPSTREAM_POINTER_STATE_LOCKED) {
                streamPointer->FrameHeader->IrpFraming->RefCount++;
            }
        }

        //
        // Add this stream pointer to the list.
        //
        InsertTailList(&m_StreamPointers,&streamPointer->ListEntry);

        streamPointer->CancelCallback = CancelCallback;

        if (StreamPointerType != KSPSTREAM_POINTER_TYPE_INTERNAL)
            KeReleaseSpinLock(&m_FrameQueue.SpinLock,oldIrql);

        *StreamPointer = streamPointer;

        status = STATUS_SUCCESS;
    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return status;
}


STDMETHODIMP_(void)
CKsQueue::
DeleteStreamPointer(
    IN PKSPSTREAM_POINTER StreamPointer
    )

/*++

Routine Description:

    This routine creates a stream pointer.

Arguments:

    StreamPointer -
        Contains a pointer to the stream pointer.

Return Value:

    Status.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsQueue::DeleteStreamPointer]"));

    ASSERT(StreamPointer);
    ASSERT(StreamPointer != m_Leading);
    ASSERT(StreamPointer != m_Trailing);

    //
    // Instead of trying to perform interlocked compare exchanges back and
    // forth to avoid this race, this will simply check what the ICX's would
    // be hacking to check.
    //
    if (KeGetCurrentThread () != m_LockContext) {
        //
        // Take the spinlock now because access to the state is not otherwise
        // synchronized.
        //
        KIRQL oldIrql;
        KeAcquireSpinLock(&m_FrameQueue.SpinLock,&oldIrql);

        CancelTimeoutUnsafe(StreamPointer);

        PIRP irpToComplete = NULL;
        if (StreamPointer->State == KSPSTREAM_POINTER_STATE_CANCEL_PENDING) {
            //
            // A cancel was prevously attempted on this stream pointer.
            //
            PKSPIRP_FRAMING irpFraming = StreamPointer->FrameHeader->IrpFraming;

            ASSERT (irpFraming->RefCount != 0);
            if (irpFraming->RefCount-- == 1) {
                //
                // The IRP is ready to go.  Throw away the frame headers.
                //
                irpToComplete = StreamPointer->FrameHeader->Irp;
                while (irpFraming->FrameHeaders) {
                    PKSPFRAME_HEADER frameHeader = irpFraming->FrameHeaders;
                    irpFraming->FrameHeaders = frameHeader->NextFrameHeaderInIrp;
                    PutAvailableFrameHeader(frameHeader);
                }
            }
        } else if (StreamPointer->State != KSPSTREAM_POINTER_STATE_DEAD) {
            //
            // The stream pointer is alive.  Make sure it's unlocked, and
            // remove it from the list.
            //
            if (StreamPointer->State == KSPSTREAM_POINTER_STATE_LOCKED) {
                //
                // Unlock the stream pointer.
                //
                KeReleaseSpinLock(&m_FrameQueue.SpinLock,oldIrql);
                UnlockStreamPointer(StreamPointer,KSPSTREAM_POINTER_MOTION_CLEAR);
                KeAcquireSpinLock(&m_FrameQueue.SpinLock,&oldIrql);
            } else if (StreamPointer->FrameHeader) {
                //
                // Clear the frame header.
                //
                SetStreamPointer(StreamPointer,NULL,NULL);
            }

            RemoveEntryList(&StreamPointer->ListEntry);
        }

        KeReleaseSpinLock(&m_FrameQueue.SpinLock,oldIrql);

        //
        // Free the stream pointer memory.
        //
        FreeStreamPointer(StreamPointer);

        //
        // Forward any IRPs released by SetStreamPointer.
        //
        ForwardWaitingIrps();

        //
        // Complete a cancelled IRP if there is one.
        //
        if (irpToComplete) {
            //
            // Cancelled Irps can no longer be completed in the queue.  They
            // must be sent around the circuit back to the sink pin where
            // they will be completed.  This is because the pin must wait
            // until Irps arrive back at the sink to prevent racing with
            // pipe teardown.
            //
            if (m_TransportSink)
                KspDiscardKsIrp (m_TransportSink, irpToComplete);
            else
                IoCompleteRequest(irpToComplete,IO_NO_INCREMENT);
        }
    } else {
        //
        // We know we're in the context of a cancel or timeout callback.  Just
        // mark the stream pointer deleted and let the callback handle it.
        //
        StreamPointer->State = KSPSTREAM_POINTER_STATE_DELETED;
    }
}


void
CKsQueue::
FreeStreamPointer(
    IN PKSPSTREAM_POINTER StreamPointer
    )

/*++

Routine Description:

    This routine frees a stream pointer.

Arguments:

    StreamPointer -
        Contains a pointer to the stream pointer.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsQueue::FreeStreamPointer]"));

    ASSERT(StreamPointer);

    //
    // If this is an iref stream pointer, release any iref event waiting
    // on it.
    //
    if (StreamPointer -> Type == KSPSTREAM_POINTER_TYPE_INTERNAL)
        if (! InterlockedDecrement (&m_InternalReferenceCountPlusOne))
            KeSetEvent (&m_InternalReferenceEvent, IO_NO_INCREMENT, FALSE);

    //
    // Free it.
    //
    ExFreePool(StreamPointer);

    //
    // Decrement the count.  Set the event if we are destructing.
    //
    if (! InterlockedDecrement(&m_StreamPointersPlusOne)) {
        KeSetEvent(&m_DestructEvent,IO_NO_INCREMENT,FALSE);
    }
}


void
CKsQueue::
SetStreamPointer(
    IN PKSPSTREAM_POINTER StreamPointer,
    IN PKSPFRAME_HEADER FrameHeader OPTIONAL,
    IN PIRP* IrpToBeReleased OPTIONAL
    )

/*++

Routine Description:

    This routine sets a stream pointer's current frame.

    THE QUEUE SPINLOCK MUST BE ACQUIRED PRIOR TO CALLING THIS FUNCTION.

    THIS FUNCTION MAY ADD IRPS TO m_IrpsToForward.

Arguments:

    StreamPointer -
        Contains a pointer to the stream pointer.

    FrameHeader -
        Contains an optional pointer to the frame header.

    IrpToBeReleased -
        Contains an optional pointer to a pointer to an IRP which
        is to be released.  If this function actually releases the
        IRP, *IrpToBeReleased is cleared.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsQueue::SetStreamPointer]"));

    ASSERT(StreamPointer);

    //
    // We cannot set any stream pointer to a ghosted frame header.  If
    // the frame header has new frame header is ghosted, move to the
    // first non-ghosted frame. 
    //
    // NOTE: Ghosted frames are used for internal reference.  Certain
    // times [pin-splitting], other queues need to hold references on frames
    // in a source queue to keep them around.  Instead of duplicating a whole
    // LOT of code for Irp queueing and reference counting, I'm simply using
    // the stream pointer idea itself internally.  Outside clients do not
    // see any of this mechanism; that's the idea of ghosted frames.  They
    // are intended for internal use ONLY.  No stream pointer can ever
    // be advanced to them.  
    //
    while (FrameHeader && FrameHeader->Type == KSPFRAME_HEADER_TYPE_GHOST) {
        //
        // This assert checks the ghosting mechanism.  Any ghosted frame
        // header which has no reference count is a leak somewhere 
        // internal to AVStream.
        //
        ASSERT (FrameHeader->RefCount > 0);
        FrameHeader = NextFrameHeader (FrameHeader);
    }

    //
    // Release the frame currently referenced, if any.
    //
    PKSPFRAME_HEADER oldFrameHeader = StreamPointer->FrameHeader;

    //
    // If this was the leading edge stream pointer and it was pointing
    // at a frame, we need to decrement the statistics counter.
    //
    // Unfortunately, InterlockedExchangeAdd is not implemented in 9x.  I do
    // not wish to spinlock, so instead we play games with
    // InterlockedCompareExchange
    //
    if (StreamPointer == m_Leading && oldFrameHeader) {
        //
        // If the frame header has been started, then the count is what
        // the stream pointer says is remaining; otherwise, it is what
        // the stream header says is available.
        //
        if (StreamPointer->FrameHeaderStarted == oldFrameHeader) {
            if (m_InputData)
                while (1) {
                    LONG curCount = m_AvailableInputByteCount;
                    LONG repCount = 
                        InterlockedCompareExchange(
                            &m_AvailableInputByteCount,
                            curCount - (LONG)(StreamPointer->Public.OffsetIn.
                                Remaining),
                            curCount
                        );
                    if (curCount == repCount) break;
                };
            if (m_OutputData)
                while (1) {
                    LONG curCount = m_AvailableOutputByteCount;
                    LONG repCount =
                        InterlockedCompareExchange(
                            &m_AvailableOutputByteCount,
                            curCount - (LONG)(StreamPointer->Public.OffsetOut.
                                Remaining),
                            curCount
                        );
                    if (curCount == repCount) break;
                };
        } else {
            if (m_InputData)
                while (1) { 
                    LONG curCount = m_AvailableInputByteCount;
                    LONG repCount = 
                        InterlockedCompareExchange(
                            &m_AvailableInputByteCount,
                            curCount - (LONG)(oldFrameHeader->
                                StreamHeader -> DataUsed),
                            curCount
                        );
                    if (curCount == repCount) break;
                };
            if (m_OutputData)
                while (1) {
                    LONG curCount = m_AvailableOutputByteCount;
                    LONG repCount =
                        InterlockedCompareExchange(
                            &m_AvailableOutputByteCount,
                            curCount - (LONG)(oldFrameHeader->
                                StreamHeader -> FrameExtent),
                            curCount
                        );
                    if (curCount == repCount) break;
                };
        }
    }

    //
    // If the stream pointer was pointing at a frame, that frame may need to be
    // dereferenced.  The exception is when this is the leading edge stream
    // pointer and there is a trailing edge.
    //
    if (oldFrameHeader && (! m_Trailing || (StreamPointer != m_Leading))) {
        //
        // Decrement the refcount on the frame header.  We know the frame header
        // is stable because it has a refcount, and we have the queue spinlock.
        // If we are enforcing in-sequence departure, the refcount gets to 1 and
        // the frame is at the end of the queue, we remove the final refcount.
        //
        ULONG refCount = --oldFrameHeader->RefCount;
        if (m_DepartInSequence &&
            (refCount == 1) && 
            (oldFrameHeader->ListEntry.Blink == &m_FrameQueue.ListEntry)) {
            refCount = --oldFrameHeader->RefCount;
        }
        if (refCount == 0) {
            while (1) {
                //
                // Here's where the fun occurs.  If there is a frame dismissal
                // callback, make it.  This allows a client to copy the frame
                // where need be (pin-centric splitting).  Unfortunately,
                // this can result in a need to hold the frame because of lack
                // of buffer availability. 
                //
                // Make the callback, and then recheck the frame refcount.  If
                // the frame is to be held in the queue, don't kick it.  Note
                // that this callback should either clone a locked or a 
                // unlocked with cancellation callback.
                //
                // NOTE: Do not make the callback for a frame which has
                // already gotten the callback!.
                //
                // Don't bother copying frames after end of stream!  But ensure
                // that the end of stream packet does get copied!  We also
                // do not bother copying frames during flush.
                //
                if (!oldFrameHeader->DismissalCall && 
                    (!m_EndOfStream || oldFrameHeader->StreamHeader->
                        OptionsFlags & KSSTREAM_HEADER_OPTIONSF_ENDOFSTREAM) &&
                    !m_Flushing) {

                    oldFrameHeader->DismissalCall = TRUE;

                    if (m_FrameDismissalCallback)
                        m_FrameDismissalCallback (
                            StreamPointer, oldFrameHeader, 
                            m_FrameDismissalContext
                            );
                    refCount = oldFrameHeader->RefCount;
    
                    //
                    // Again, this check is made for pin-centric splitting where
                    // the context adds refcount to the clone to keep the frame
                    // around.
                    //
                    if (refCount != 0) {
                        //
                        // If the frame is to be left around for an internal 
                        // client (AVStream itself), ghost it.  This will 
                        // prevent any other stream pointer from ever hitting 
                        // the frame and will prevent outside clients from 
                        // seeing it.
                        //
                        ASSERT (oldFrameHeader->Type !=
                            KSPFRAME_HEADER_TYPE_GHOST);

                        oldFrameHeader->Type = KSPFRAME_HEADER_TYPE_GHOST;

                        break;
                    }
                }

                //
                // Remove the frame header from the queue.  A NULL Flink is used to
                // indicate the frame header as been removed.  The count of queued
                // frame headers for the IRP must be decremented.  Someone else must
                // notice that the count has bottomed out and do something about it.
                //
                RemoveEntryList(&oldFrameHeader->ListEntry);
                oldFrameHeader->ListEntry.Flink = NULL;

                //
                // Update counters.
                //
                InterlockedDecrement(&m_FramesWaiting);

                //
                // Determine if the IRP is ready to leave.
                //
                if ((oldFrameHeader->IrpFraming) &&
                    (--oldFrameHeader->IrpFraming->QueuedFrameHeaderCount == 0)) {
                    //
                    // The IRP no longer has frames in the queue.  See if it is
                    // the IRP that is to be released.
                    //
                    if (IrpToBeReleased && 
                        (*IrpToBeReleased == oldFrameHeader->Irp)) {
                        //
                        // It is the IRP to be released.  It can't have any
                        // stream pointer references (locks) besides the one
                        // that needs to be released, but it may have a
                        // reference because TransferKsIrp is still underway.
                        // We will dereference it at see if that gets us to
                        // zero.  We also need to return TRUE so the caller
                        // knows we took care of the dereference.
                        //
                        *IrpToBeReleased = NULL;

                        ASSERT (oldFrameHeader->IrpFraming->RefCount != 0);
                        if (--oldFrameHeader->IrpFraming->RefCount == 0) {
                            //
                            // No more references.  Add it to the forwarding
                            // list.
                            //
                            InsertTailList(
                                &m_WaitingIrps,
                                &oldFrameHeader->Irp->Tail.Overlay.ListEntry);
                        }
                    } else {
                        //
                        // This was not the IRP to be released.  If it has no
                        // references, we can forward it.  It should have a
                        // cancel routine in that case.  We do an exchange to
                        // try to clear the cancel routine.
                        //
                        if ((oldFrameHeader->IrpFraming->RefCount == 0) &&
                            IoSetCancelRoutine(oldFrameHeader->Irp,NULL)) {
                            //
                            // No more references, and we got a non-NULL cancel
                            // routine.  If we had not gotten the cancel
                            // routine, that would have meant that the IRP was
                            // being cancelled.
                            //
                            InsertTailList(
                                &m_WaitingIrps,
                                &oldFrameHeader->Irp->Tail.Overlay.ListEntry);
                        }
                    }
                }

                //
                // All done if the list is empty.
                //
                if (IsListEmpty(&m_FrameQueue.ListEntry)) {
                    if (m_EndOfStream) {
                        m_PipeSection->GenerateConnectionEvents(
                            KSSTREAM_HEADER_OPTIONSF_ENDOFSTREAM);
                    }
                    break;
                }

                //
                // All done if we are not enforcing sequence.
                //
                if (! m_DepartInSequence) {
                    break;
                }

                //
                // See if the next frame needs removing also.
                //
                oldFrameHeader = 
                    CONTAINING_RECORD(
                        m_FrameQueue.ListEntry.Flink,
                        KSPFRAME_HEADER,
                        ListEntry);
            
                if (oldFrameHeader->RefCount == 1) {
                    oldFrameHeader->RefCount--;
                } else {
                    break;
                }
            }
        }
    }

    //
    // Acquire the new frame, if any.
    //
    if (FrameHeader && (StreamPointer != m_Trailing)) {
        FrameHeader->RefCount++;
        if (m_DepartInSequence && (StreamPointer == m_Leading)) {
            FrameHeader->RefCount++;
        }
    }

    //
    // Allow or prevent processing as required.
    //
    if (m_FrameGate && (StreamPointer == m_Leading)) {
        if (FrameHeader) {
            if (! StreamPointer->FrameHeader) {
                //
                // New data.  Allow processing.
                //
                KsGateTurnInputOn(m_FrameGate);
                _DbgPrintF(DEBUGLVL_PROCESSINGCONTROL_BLAB,("#### Queue%p.SetStreamPointer:  on%p-->%d",this,m_FrameGate,m_FrameGate->Count));
#if DBG
                if (m_FrameGateIsOr) {
                    ASSERT(m_FrameGate->Count >= 0);
                } else {
                    ASSERT(m_FrameGate->Count <= 1);
                }
#endif // DBG
            }
        } else {
            if (StreamPointer->FrameHeader) {
                //
                // No more data.  Prevent processing.
                //
                KsGateTurnInputOff(m_FrameGate);
                _DbgPrintF(DEBUGLVL_PROCESSINGCONTROL_BLAB,("#### Queue%p.SetStreamPointer:  off%p-->%d",this,m_FrameGate,m_FrameGate->Count));

#if DBG
                if (m_FrameGateIsOr) {
                    ASSERT(m_FrameGate->Count >= 0);
                } else {
                    ASSERT(m_FrameGate->Count <= 1);
                }
#endif // DBG

            }
        }
    }

    StreamPointer->FrameHeader = FrameHeader;

    //
    // Clear this pointer to indicate we have not started this frame header.
    //
    StreamPointer->FrameHeaderStarted = NULL;

}


STDMETHODIMP_(NTSTATUS)
CKsQueue::
SetStreamPointerStatusCode(
    IN PKSPSTREAM_POINTER StreamPointer,
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This routine sets the status code on a frame pointed to by StreamPointer.
    Any frame with non-successful status code will complete the associated
    Irp with the first failed frame's error code.

Arguments:

    StreamPointer -
        Points to the stream pointer to set status code for

    Status -
        The status code to set

Return Value:

    Success / Failure

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsQueue::SetStreamPointerStatusCode]"));

    KIRQL oldIrql;
    NTSTATUS status;

    //
    // Take the queue spinlock.
    //
    KeAcquireSpinLock(&m_FrameQueue.SpinLock,&oldIrql);

    if (StreamPointer->FrameHeader) {
        StreamPointer->FrameHeader->Status = Status;
        status = STATUS_SUCCESS;
    } else
        status = STATUS_UNSUCCESSFUL;

    KeReleaseSpinLock(&m_FrameQueue.SpinLock,oldIrql);

    return status;

}

STDMETHODIMP_(void)
CKsQueue::
RegisterFrameDismissalCallback (
    IN PFNKSFRAMEDISMISSALCALLBACK FrameDismissalCallback,
    IN PVOID FrameDismissalContext
    )

/*++

Routine Description:

    Register a callback with the queue.  This callback is made whenever a 
    frame is dismissed from the queue.  The callback function will receive
    the stream pointer causing the dismissal and the frame header of the
    dismissed frame.  The frame header is guaranteed to be stable as
    the refcount will have just dropped to zero and the queue's spinlock
    is still held.

Arguments:

    FrameDismissalCallback -
        The frame dismissal callback to register.  NULL indicates that
        a dismissal callback is being unregistered.  Note that the call
        is made with the queue's spinlock held!

    FrameDismissalContext -
        Callback context blob

Return Value:    

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsFilter::RegisterFrameDismissalCallback]"));

    KIRQL oldIrql;

    //
    // TODO:
    //
    // This is perhaps not the most ideal way to do this, but I only want
    // to register the callback for pin-centric queues right now.  This 
    // callback in particular is used for pin-splitting.  If used for something
    // else later, this will need to go away and be replaced with a different
    // mechanism of determining centricity.
    //
    //
    PIKSPIN Pin = NULL;
    if (NT_SUCCESS (m_ProcessingObject->QueryInterface (
        __uuidof(IKsPin), (PVOID *)&Pin))) {

        ASSERT (Pin);
    
        // 
        // Acquire the queue's spinlock to synchronize with the possibility
        // of changing callbacks during dismissal.
        //
        KeAcquireSpinLock(&m_FrameQueue.SpinLock,&oldIrql);
    
        ASSERT (!FrameDismissalCallback || m_FrameDismissalCallback == NULL ||
            m_FrameDismissalCallback == FrameDismissalCallback);
    
        m_FrameDismissalCallback = FrameDismissalCallback;
        m_FrameDismissalContext = FrameDismissalContext;
    
        KeReleaseSpinLock(&m_FrameQueue.SpinLock,oldIrql);

        Pin->Release();

    }

}


STDMETHODIMP_(BOOLEAN)
CKsQueue::
GeneratesMappings (
    )

/*++

Routine Description:

    Answer a simple question: does this queue generate mappings or not?  This
    is supported in order to have CopyToDestinations realize how to handle
    mapped pins.

Arguments:

    None

Return Value:

    Whether or not this queue generates mappings.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsFilter::GeneratesMappings]"));

    return m_GenerateMappings;

}

STDMETHODIMP_(PKSPFRAME_HEADER)
CKsQueue::
LockStreamPointer(
    IN PKSPSTREAM_POINTER StreamPointer
    )

/*++

Routine Description:

    This routine prevents cancellation of the IRP associated with the frame
    currently referenced by the stream pointer.

Arguments:

    StreamPointer -
        Contains a pointer to the stream pointer.

Return Value:

    A pointer to the frame header referenced by the stream pointer, or NULL if
    the stream pointer could not be acquired.  The latter only happens if no
    frame header was referenced.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsQueue::LockStreamPointer]"));

    if (StreamPointer->State == KSPSTREAM_POINTER_STATE_LOCKED) {
        return StreamPointer->FrameHeader;
    }

    KSPSTREAM_POINTER_STATE OldState = StreamPointer->State;

    //
    // Take the queue spinlock to keep the frame header stable.
    //
    KIRQL oldIrql;
    KeAcquireSpinLock(&m_FrameQueue.SpinLock,&oldIrql);

    //
    // This only makes sense if we are referencing a frame header and it
    // has an associated IRP.
    //
    // INTERIM:  For now, all frame headers have associated IRPs.
    //
    PKSPFRAME_HEADER frameHeader = StreamPointer->FrameHeader;
    while (frameHeader) {
        ASSERT(frameHeader->Irp);
        ASSERT(frameHeader->IrpFraming);

        //
        // Increment the refcount on the IRP.
        //
        if (frameHeader->IrpFraming->RefCount++ == 0) {
            //
            // The refcount was zero, so we are responsible for clearing the
            // cancel routine.
            //
            if (IoSetCancelRoutine(frameHeader->Irp,NULL)) {
                //
                // Successfully cleared it.  We are locked.
                //
                break;
            } else {
                ASSERT (frameHeader->IrpFraming->RefCount != 0);
                frameHeader->IrpFraming->RefCount--;
                //
                // There was no cancel routine.  This means the IRP is in the
                // process of being cancelled (no one else clears the cancel
                // routine because of the interlocked refcount).  We will take
                // the cancel spinlock to allow the cancellation to finish up.
                // Then we will try again to see if there is a frame header we
                // can acquire.  In order to take the cancel spinlock, we need
                // to release the queue spinlock.  This is to prevent deadlock
                // with the cancel routine, in which the queue spinlock is
                // taken after the cancel spinlock is taken.
                //
                KeReleaseSpinLock(&m_FrameQueue.SpinLock,oldIrql);

                //
                // Cancel routine gets to run here.
                //
                IoAcquireCancelSpinLock(&oldIrql);

                //
                // Cancel routine must be done 'cause we got the spinlock.
                //
                IoReleaseCancelSpinLock(oldIrql);

                //
                // Take the queue spinlock again because we need to be holding
                // it at the top of the loop.
                //
                KeAcquireSpinLock(&m_FrameQueue.SpinLock,&oldIrql);

                //
                // Get the frame header again, because it may have changed.
                //
                frameHeader = StreamPointer->FrameHeader;
            }
        } else {
            //
            // The IRP was already locked, so we are done.
            //
            break;
        }
    }

    if (frameHeader) {
        StreamPointer->State = KSPSTREAM_POINTER_STATE_LOCKED;

        //
        // Set up the stream pointer for this frame.
        //
        if (StreamPointer->FrameHeaderStarted != frameHeader) {
            if (m_GenerateMappings) {
                if (! frameHeader->MappingsTable) {
                    frameHeader->MappingsTable = 
                        CreateMappingsTable(frameHeader);
                    //
                    // Check for out of memory condition.
                    //
                    if (! frameHeader->MappingsTable) {
                        //
                        // Decrement the count on the IRP, and determine
                        // if cancelation should be checked.
                        //
                        ASSERT (frameHeader->IrpFraming->RefCount != 0);
                        if (frameHeader->IrpFraming->RefCount-- == 1) {
                            //
                            // No one has the IRP acquired.  Make it cancelable.
                            //
                            IoSetCancelRoutine(
                                frameHeader->Irp,
                                CKsQueue::CancelRoutine);
                            //
                            // Now check to see whether the IRP was
                            // cancelled.  If so, and we can clear
                            // the cancel routine, do the cancellation
                            // here and now.
                            //
                            if (frameHeader->Irp->Cancel && IoSetCancelRoutine(frameHeader->Irp,NULL)) {
                                //
                                // Call the cancel routine after
                                // releasing the queue spinlock
                                // and taking the cancel spinlock.
                                // The spinlock can be released because
                                // the cancel routine is NULL, so this
                                // won't be messed with.
                                //
                                KeReleaseSpinLock(&m_FrameQueue.SpinLock,oldIrql);
                                IoAcquireCancelSpinLock(&frameHeader->Irp->CancelIrql);
                                CKsQueue::CancelRoutine(
                                    IoGetCurrentIrpStackLocation(frameHeader->Irp)->DeviceObject,
                                    frameHeader->Irp);
                                StreamPointer->State = OldState;
                                return NULL;
                            }
                        }
                        KeReleaseSpinLock(&m_FrameQueue.SpinLock,oldIrql);
                        StreamPointer->State = OldState;
                        return NULL;
                    }
                }

                if (m_InputData) {
                    StreamPointer->Public.OffsetIn.Mappings =
                        frameHeader->MappingsTable->Mappings;

                    StreamPointer->Public.OffsetIn.Count = 
                    StreamPointer->Public.OffsetIn.Remaining = 
                        frameHeader->MappingsTable->MappingsFilled;
                }

                if (m_OutputData) {
                    StreamPointer->Public.OffsetOut.Mappings = 
                        frameHeader->MappingsTable->Mappings;

                    StreamPointer->Public.OffsetOut.Count = 
                    StreamPointer->Public.OffsetOut.Remaining = 
                        frameHeader->MappingsTable->MappingsFilled;
                }
            } else {
                if (m_InputData) {
                    StreamPointer->Public.OffsetIn.Data =
                        PUCHAR(frameHeader->FrameBuffer);

                    StreamPointer->Public.OffsetIn.Count = 
                    StreamPointer->Public.OffsetIn.Remaining = 
                        frameHeader->StreamHeader->DataUsed;
                }
                if (m_OutputData) {
                    StreamPointer->Public.OffsetOut.Data = 
                        PUCHAR(frameHeader->FrameBuffer);

                    StreamPointer->Public.OffsetOut.Count = 
                    StreamPointer->Public.OffsetOut.Remaining = 
                        frameHeader->StreamHeader->FrameExtent;
                }
            }
            StreamPointer->Public.StreamHeader = frameHeader->StreamHeader;
            StreamPointer->FrameHeaderStarted = frameHeader;
        }
    } else {
        //
        // Clear stuff so there is no confusion.
        //
        StreamPointer->Public.StreamHeader = NULL;
        RtlZeroMemory(
            &StreamPointer->Public.OffsetIn,
            sizeof(StreamPointer->Public.OffsetIn));
        RtlZeroMemory(
            &StreamPointer->Public.OffsetOut,
            sizeof(StreamPointer->Public.OffsetOut));
    }

    if (frameHeader) {
        ASSERT (frameHeader->IrpFraming->RefCount > 0);
    }

    KeReleaseSpinLock(&m_FrameQueue.SpinLock,oldIrql);

    return frameHeader;
}


STDMETHODIMP_(void)
CKsQueue::
UnlockStreamPointer(
    IN PKSPSTREAM_POINTER StreamPointer,
    IN KSPSTREAM_POINTER_MOTION Motion
    )

/*++

Routine Description:

    This routine releases its reference on the IRP associated with the
    referenced frame, allow the IRP to be cancelled if there are no other
    references.

Arguments:

    StreamPointer -
        Contains a pointer to the stream pointer.

    Motion -
        Contains an indication of whether to advance or clear the current
        frame for the stream pointer.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsQueue::UnlockStreamPointer]"));

    ASSERT(StreamPointer);

    if (StreamPointer->State != KSPSTREAM_POINTER_STATE_LOCKED) {
        return;
    }

    //
    // This only makes sense if we are referencing a frame header and it
    // has an associated IRP.
    //
    // INTERIM:  For now, all frame headers have associated IRPs.
    //
    PKSPFRAME_HEADER frameHeader = StreamPointer->FrameHeader;
    ASSERT(frameHeader);
    ASSERT(frameHeader->Irp);
    ASSERT(frameHeader->IrpFraming);

    //
    // Advance to the next frame if we are done with this one.
    //
    PIRP irpToBeReleased = frameHeader->Irp;
    PKSPIRP_FRAMING irpFraming = frameHeader->IrpFraming;
    if (Motion != KSPSTREAM_POINTER_MOTION_NONE) {
        //
        // If this queue generates output, see if we have hit end-of-stream
        // on the leading edge.
        //
        if (m_OutputData && 
            (StreamPointer == m_Leading) &&
            (StreamPointer->Public.StreamHeader->OptionsFlags & 
             KSSTREAM_HEADER_OPTIONSF_ENDOFSTREAM)) {
            m_EndOfStream = TRUE;
        }

        //
        // Update data used if this queue is doing output and remaining output
        // count has changed.
        //
        if (m_OutputData &&
            (! m_GenerateMappings) &&
            (StreamPointer->Public.OffsetOut.Remaining !=
             StreamPointer->Public.OffsetOut.Count)) {
            StreamPointer->Public.StreamHeader->DataUsed =
                StreamPointer->Public.OffsetOut.Count -
                StreamPointer->Public.OffsetOut.Remaining;
        }

        //
        // Advance the stream pointer.
        //
        KIRQL oldIrql;
        KeAcquireSpinLock(&m_FrameQueue.SpinLock,&oldIrql);
        if (StreamPointer->FrameHeader) {
            if (Motion == KSPSTREAM_POINTER_MOTION_CLEAR) {
                SetStreamPointer(StreamPointer,NULL,&irpToBeReleased);
            } else {
                SetStreamPointer(
                    StreamPointer,
                    NextFrameHeader(StreamPointer->FrameHeader),
                    &irpToBeReleased);
            }
        }

        KeReleaseSpinLock(&m_FrameQueue.SpinLock,oldIrql);
    }

    StreamPointer->State = KSPSTREAM_POINTER_STATE_UNLOCKED;

    //
    // Forward any IRPs released by SetStreamPointer.
    //
    ForwardWaitingIrps();

    //
    // Release the IRP if SetStreamPointer did not do it.
    //
    if (irpToBeReleased) {
        ReleaseIrp(irpToBeReleased,irpFraming,NULL);
    }

    //
    // Flush remaining frames if we hit end-of-stream.
    //
    // If we're advancing due to a flush, don't reflush!
    //
    if (m_EndOfStream && Motion != KSPSTREAM_POINTER_MOTION_FLUSH) {
        Flush();
    }
}


STDMETHODIMP_(void)
CKsQueue::
AdvanceUnlockedStreamPointer(
    IN PKSPSTREAM_POINTER StreamPointer
    )

/*++

Routine Description:

    This routine advances an unlocked stream pointer.

Arguments:

    StreamPointer -
        Contains a pointer to the stream pointer.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsQueue::AdvanceUnlockedStreamPointer]"));

    ASSERT(StreamPointer);
    ASSERT(StreamPointer->State == KSPSTREAM_POINTER_STATE_UNLOCKED);

    //
    // Take the spinlock because we are changing frame refcounts.
    //
    KIRQL oldIrql;
    KeAcquireSpinLock(&m_FrameQueue.SpinLock,&oldIrql);
    if (StreamPointer->FrameHeader) {
        SetStreamPointer(
            StreamPointer,
            NextFrameHeader(StreamPointer->FrameHeader),
            NULL);
    }
    KeReleaseSpinLock(&m_FrameQueue.SpinLock,oldIrql);

    //
    // Forward any IRPs released by SetStreamPointer.
    //
    ForwardWaitingIrps();
}


LONGLONG
CKsQueue::
GetTime(
    IN BOOLEAN Reset
    )

/*++

Routine Description:

    This routine gets the current time and adjusts the timeout queue if the
    time has been changed.

    THE QUEUE SPINLOCK MUST BE ACQUIRED PRIOR TO CALLING THIS FUNCTION.

Arguments:

    Reset -
        Contains an indication of whether the base time should be reset
        regardless of range.

Return Value:

    The current time.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsQueue::GetTime]"));

    //
    // Get the current time.
    //
    LARGE_INTEGER currentTime;
    KeQuerySystemTime(&currentTime);

    //
    // Validate the base time to see if a time change has occurred.
    //
    const ULONG TIMER_SLOP = 100000000L;
    if (m_BaseTime &&
        (Reset ||
         (m_BaseTime > currentTime.QuadPart) ||
         (m_BaseTime + m_Interval + TIMER_SLOP < currentTime.QuadPart))) {
        //
        // Current time is out-of-whack with respect to base time.  Reset
        // base time and schedule to match new current time.
        //
        LONGLONG adjustment = currentTime.QuadPart - m_BaseTime;
        m_BaseTime = currentTime.QuadPart;

        for (PLIST_ENTRY listEntry = m_TimeoutQueue.Flink;
             listEntry != &m_TimeoutQueue;
             listEntry = listEntry->Flink) {
            PKSPSTREAM_POINTER streamPointer =
                CONTAINING_RECORD(listEntry,KSPSTREAM_POINTER,TimeoutListEntry);

            streamPointer->TimeoutTime += adjustment;
        }
    }

    return currentTime.QuadPart;
}


void
CKsQueue::
SetTimer(
    IN LONGLONG CurrentTime
    )

/*++

Routine Description:

    This routine sets the timeout timer based on the time of the first stream
    pointer in the timeout queue.

Arguments:

    CurrentTime -
        Contains the current time as obtained from CKsQueue::GetTime().

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsQueue::SetTimer]"));

    KIRQL oldIrql;
    KeAcquireSpinLock(&m_FrameQueue.SpinLock,&oldIrql);
    SetTimerUnsafe(CurrentTime);
    KeReleaseSpinLock(&m_FrameQueue.SpinLock,oldIrql);
}


void
CKsQueue::
SetTimerUnsafe(
    IN LONGLONG CurrentTime
    )

/*++

Routine Description:

    This routine sets the timeout timer based on the time of the first stream
    pointer in the timeout queue.

    THE QUEUE SPINLOCK MUST BE ACQUIRED PRIOR TO CALLING THIS FUNCTION.

Arguments:

    CurrentTime -
        Contains the current time as obtained from CKsQueue::GetTime().

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsQueue::SetTimerUnsafe]"));

    if (IsListEmpty(&m_TimeoutQueue) || (m_State != KSSTATE_RUN)) {        
        //
        // Cancel the timer.
        //
        if (m_Interval) {
            m_Interval = 0;
            KeCancelTimer(&m_Timer);
        }
    } else {
        //
        // Get the first item in the list.
        //
        PKSPSTREAM_POINTER first =
             CONTAINING_RECORD(
                m_TimeoutQueue.Flink,
                KSPSTREAM_POINTER,
                TimeoutListEntry);

        //
        // If the timer is not currently set or it is set too late, set the
        // timer.
        //
        if ((m_Interval == 0) || 
            (first->TimeoutTime < m_BaseTime + m_Interval)) {
            //
            // Set the timer.  A negative value indicates an interval rather
            // than an absolute time.  We don't allow 0 because we are using
            // m_Interval to determine if the timer is set.
            //
            LARGE_INTEGER interval;
            interval.QuadPart = CurrentTime - first->TimeoutTime;
            if (interval.QuadPart == 0) {
                interval.QuadPart = -1;
            }
            KeSetTimer(&m_Timer,interval,&m_Dpc);
            m_BaseTime = CurrentTime;
            m_Interval = -interval.QuadPart;
        }
    }
}


STDMETHODIMP_(void)
CKsQueue::
ScheduleTimeout(
    IN PKSPSTREAM_POINTER StreamPointer,
    IN PFNKSSTREAMPOINTER Callback,
    IN LONGLONG Interval
    )

/*++

Routine Description:

    This routine schedules a timeout on a stream pointer.

Arguments:

    StreamPointer -
        Contains a pointer to the stream pointer.

    Callback -
        Contains a pointer to the function to be called when the timeout
        occurs.

    Interval -
        Contains the timeout interval in 100-nanosecond units.  Only
        positive relative values are allowed.

Return Value:

    Status.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsQueue::ScheduleTimeout]"));

    ASSERT(StreamPointer);
    ASSERT(Callback);
    ASSERT(Interval >= 0);

    //
    // Instead of trying to perform interlocked compare exchanges back and
    // forth to avoid this race, this will simply check what the ICX's would
    // be hacking to check.
    //
    if (KeGetCurrentThread () != m_LockContext) {

        //
        // Take the spinlock.
        //
        KIRQL oldIrql;
        KeAcquireSpinLock(&m_FrameQueue.SpinLock,&oldIrql);
    
        //
        // Remove the stream pointer from the timeout queue if it is there.
        //
        if (StreamPointer->TimeoutListEntry.Flink) {
            RemoveEntryList(&StreamPointer->TimeoutListEntry);
            StreamPointer->TimeoutListEntry.Flink = NULL;
        }
    
        //
        // Get the current time, doing adjustments if a time change has occurred.
        //
        LONGLONG currentTime = GetTime(FALSE);
    
        //
        // Set the time on the stream pointer and insert it in the queue.
        //
        StreamPointer->TimeoutCallback = Callback;
        StreamPointer->TimeoutTime = currentTime + Interval;
        PLIST_ENTRY listEntry = m_TimeoutQueue.Blink;
    
        //
        // Find the right spot in the timeout queue to insert the entry.  Walk
        // it in blink order since this will be the most likely order to add
        // the entry.
        //
        while (
            (listEntry != &m_TimeoutQueue) &&
            (CONTAINING_RECORD(
                listEntry,
                KSPSTREAM_POINTER,
                TimeoutListEntry) -> TimeoutTime > StreamPointer -> TimeoutTime)
            ) {
    
            listEntry = listEntry -> Blink;
        }
    
        InsertHeadList (listEntry, &(StreamPointer -> TimeoutListEntry));
    
        //
        // Set the timer, if necessary.
        //
        SetTimerUnsafe(currentTime);
    
        KeReleaseSpinLock(&m_FrameQueue.SpinLock,oldIrql);

    } else {
        //
        // We know we're in the context of a callback.  Pass back the parameters
        // overloaded in the stream pointer and mark the thing.
        //
        if (StreamPointer->State != KSPSTREAM_POINTER_STATE_CANCELLED) {
            StreamPointer->TimeoutTime = Interval;
            StreamPointer->TimeoutCallback = Callback;
            StreamPointer->State = KSPSTREAM_POINTER_STATE_TIMER_RESCHEDULE;
        }

    }
        
}


STDMETHODIMP_(void)
CKsQueue::
CancelTimeout(
    IN PKSPSTREAM_POINTER StreamPointer
    )

/*++

Routine Description:

    This routine cancels a timeout on a stream pointer.

Arguments:

    StreamPointer -
        Contains a pointer to the stream pointer.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsQueue::CancelTimeout]"));

    ASSERT(StreamPointer);

    //
    // Take the spinlock.
    //
    KIRQL oldIrql;
    KeAcquireSpinLock(&m_FrameQueue.SpinLock,&oldIrql);

    CancelTimeoutUnsafe(StreamPointer);

    KeReleaseSpinLock(&m_FrameQueue.SpinLock,oldIrql);
}


STDMETHODIMP_(PKSPSTREAM_POINTER)
CKsQueue::
GetFirstClone(
    void
    )

/*++

Routine Description:

    This routine gets the first clone stream pointer.

Arguments:

    None.

Return Value:

    The stream pointer, or NULL if there is none.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsQueue::GetFirstClone]"));

    //
    // Take the spinlock.
    //
    KIRQL oldIrql;
    KeAcquireSpinLock(&m_FrameQueue.SpinLock,&oldIrql);

    PKSPSTREAM_POINTER streamPointer;
    if (m_StreamPointers.Flink != &m_StreamPointers) {
        streamPointer = 
            CONTAINING_RECORD(
                m_StreamPointers.Flink,
                KSPSTREAM_POINTER,
                ListEntry);
    } else {
        streamPointer = NULL;
    }

    //
    // Don't return internal pointers on iteration.  This might want
    // to be a flag.
    //
    while (streamPointer &&
        streamPointer->Type == KSPSTREAM_POINTER_TYPE_INTERNAL)
        streamPointer = GetNextClone (streamPointer);

    KeReleaseSpinLock(&m_FrameQueue.SpinLock,oldIrql);

    return streamPointer;
}


STDMETHODIMP_(PKSPSTREAM_POINTER)
CKsQueue::
GetNextClone(
    IN PKSPSTREAM_POINTER StreamPointer
    )

/*++

Routine Description:

    This routine gets the next clone stream pointer.

Arguments:

    StreamPointer -
        Contains a pointer to the stream pointer.

Return Value:

    The stream pointer, or NULL if there is none.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsQueue::GetNextClone]"));

    ASSERT(StreamPointer);

    //
    // Take the spinlock.
    //
    KIRQL oldIrql;
    KeAcquireSpinLock(&m_FrameQueue.SpinLock,&oldIrql);

    //
    // Don't return internally held stream pointers on iteration.  This
    // may want to be a flag.
    //
    PKSPSTREAM_POINTER streamPointer = StreamPointer;
    do {
        if (streamPointer->ListEntry.Flink != &m_StreamPointers) {
            streamPointer = 
                CONTAINING_RECORD(
                    streamPointer->ListEntry.Flink,
                    KSPSTREAM_POINTER,
                    ListEntry);
        } else {
            streamPointer = NULL;
        }
    } while (streamPointer &&
        streamPointer->Type == KSPSTREAM_POINTER_TYPE_INTERNAL);

    KeReleaseSpinLock(&m_FrameQueue.SpinLock,oldIrql);

    return streamPointer;
}


void
CKsQueue::
CancelTimeoutUnsafe(
    IN PKSPSTREAM_POINTER StreamPointer
    )

/*++

Routine Description:

    This routine cancels a timeout on a stream pointer.

    THE QUEUE SPINLOCK MUST BE ACQUIRED PRIOR TO CALLING THIS FUNCTION.

Arguments:

    StreamPointer -
        Contains a pointer to the stream pointer.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsQueue::CancelTimeoutUnsafe]"));

    ASSERT(StreamPointer);

    //
    // Remove the stream pointer from the timeout queue if it is there.
    //
    if (StreamPointer->TimeoutListEntry.Flink) {
        RemoveEntryList(&StreamPointer->TimeoutListEntry);
        StreamPointer->TimeoutListEntry.Flink = NULL;

        //
        // Adjust the timer, if necessary.
        //
        SetTimerUnsafe(GetTime(FALSE));
    }
}


void
CKsQueue::
DispatchTimer(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This routine dispatches a stream pointer timeout.

Arguments:

    Dpc -
        Contains a pointer to the KDPC structure.

    DeferredContext -
        Contains a context pointer registered during the initialization of the
        DPC, in this case, the queue.

    SystemArgument1 -
        Not used.
        
    SystemArgument1 -
        Not used.       

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsQueue::DispatchTimer]"));

    ASSERT(Dpc);
    ASSERT(DeferredContext);

    CKsQueue* queue = (CKsQueue *) DeferredContext;

    //
    // Take the spinlock.
    //
    KeAcquireSpinLockAtDpcLevel(&queue->m_FrameQueue.SpinLock);

    //
    // If no interval is set, there was an unsuccessful attempt to cancel 
    // the timer.
    //
    if (queue->m_Interval == 0) {
        ExReleaseSpinLockFromDpcLevel(&queue->m_FrameQueue.SpinLock);
        return;
    }

    //
    // Get the current time, doing adjustments if a time change has occurred.
    //
    LONGLONG currentTime = queue->GetTime(FALSE);

    //
    // Clear the interval in case we don't schedule another DPC.
    //
    queue->m_Interval = 0;

    //
    // Timeout all stream pointers whose time has come.
    //
    while (! IsListEmpty(&queue->m_TimeoutQueue)) {
        PKSPSTREAM_POINTER first =
             CONTAINING_RECORD(
                queue->m_TimeoutQueue.Flink,
                KSPSTREAM_POINTER,
                TimeoutListEntry);

        if (first->TimeoutTime <= currentTime) {
            //
            // This stream pointer is ready to go.  Remove it from the timeout
            // list.
            //
            RemoveEntryList(&first->TimeoutListEntry);
            first->TimeoutListEntry.Flink = NULL;

            //
            // Set its state to timed out and call the timeout callback.  The
            // state prevents any illegal use of the pointer and tells
            // the deletion code to just mark it deleted.
            //
            KSPSTREAM_POINTER_STATE state = first->State;
            first->State = KSPSTREAM_POINTER_STATE_TIMED_OUT;
            queue->m_LockContext = KeGetCurrentThread ();
            first->TimeoutCallback(&first->Public);
            queue->m_LockContext = NULL;

            //
            // Now see if it got deleted.
            //
            if (first->State == KSPSTREAM_POINTER_STATE_DELETED) {
                first->State = state;

                //
                // The stream pointer needs to be removed and deleted.
                //
                if (state == KSPSTREAM_POINTER_STATE_LOCKED) {
                    //
                    // Unlock the stream pointer.
                    //
                    ExReleaseSpinLockFromDpcLevel(&queue->m_FrameQueue.SpinLock);
                    queue->UnlockStreamPointer(first,KSPSTREAM_POINTER_MOTION_CLEAR);
                    KeAcquireSpinLockAtDpcLevel(&queue->m_FrameQueue.SpinLock);
                } else if (first->FrameHeader) {
                    //
                    // Clear the frame header.
                    //
                    queue->SetStreamPointer(first,NULL,NULL);
                }

                RemoveEntryList(&first->ListEntry);
                queue->FreeStreamPointer(first);

            //
            // Now see if the timer was rescheduled.
            //
            } else if (first->State == 
                KSPSTREAM_POINTER_STATE_TIMER_RESCHEDULE) {

                first->State = state;
                first->TimeoutTime += currentTime;

                PLIST_ENTRY listEntry = queue->m_TimeoutQueue.Blink;
            
                //
                // Find the right spot in the timeout queue to insert 
                // the entry.  Walk it in blink order since this will be 
                // the most likely order to add the entry.
                //
                while (
                    (listEntry != &queue->m_TimeoutQueue) &&
                    (CONTAINING_RECORD(
                        listEntry,
                        KSPSTREAM_POINTER,
                        TimeoutListEntry) -> TimeoutTime > 
                        first -> TimeoutTime)
                    ) {
            
                    listEntry = listEntry -> Blink;
                }
            
                InsertHeadList (
                    listEntry, &(first -> TimeoutListEntry)
                    );

            } else {
                first->State = state;
            }
        } else {
            //
            // This stream pointer wants to wait.  Set the timer.
            //
            queue->SetTimerUnsafe(currentTime);
            break;
        }
    }

    ExReleaseSpinLockFromDpcLevel(&queue->m_FrameQueue.SpinLock);

    //
    // Forward any IRPs released by SetStreamPointer.
    //
    queue->ForwardWaitingIrps();
}


PKSPFRAME_HEADER
CKsQueue::
GetAvailableFrameHeader(
    IN ULONG StreamHeaderSize OPTIONAL
    )

/*++

Routine Description:

    This routine gets a frame header from the lookaside list or creates one,
    as required.

    INTERIM:  This routine will not need to be here for frame-based transport.

Arguments:

    StreamHeaderSize -
        Contains the minimum size for the stream header.

Return Value:

    The frame header or NULL if the lookaside list was empty.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsQueue::GetAvailableFrameHeader]"));

    //
    // Get a frame header from the lookaside list.
    //
    PLIST_ENTRY listEntry = 
        ExInterlockedRemoveHeadList(
            &m_FrameHeadersAvailable.ListEntry,
            &m_FrameHeadersAvailable.SpinLock);
    //
    // If we got one, be sure the stream header is the right size.  If not, we
    // free it.
    //
    PKSPFRAME_HEADER frameHeader;
    if (listEntry) {
        frameHeader = CONTAINING_RECORD(listEntry,KSPFRAME_HEADER,ListEntry);
        if (frameHeader->StreamHeaderSize < StreamHeaderSize) {
            ExFreePool(frameHeader);
            frameHeader = NULL;
        }
    } else {
        frameHeader = NULL;
    }

    //
    // Create a new frame header if we didn't get one already.
    //
    if (! frameHeader) {
        frameHeader = 
            reinterpret_cast<PKSPFRAME_HEADER>(
                ExAllocatePoolWithTag(
                    NonPagedPool,
                    sizeof(KSPFRAME_HEADER) + StreamHeaderSize,
                    'hFcP'));

        if (frameHeader) {
            //
            // If the stream header size is not 0, this is an 'attached' type
            // frame header, and we set the stream header pointer.  Otherwise,
            // the caller will provide the stream header later, and the size
            // field stays 0 to indicate the header is not attached.
            //
            // NOTE:  All frame headers will be attached type...for now.
            //
            RtlZeroMemory(frameHeader,sizeof(*frameHeader));
            if (StreamHeaderSize) {
                frameHeader->StreamHeader = 
                    reinterpret_cast<PKSSTREAM_HEADER>(frameHeader + 1);
                frameHeader->StreamHeaderSize = StreamHeaderSize;
            }
        }
    }

    return frameHeader;
}


void
CKsQueue::
PutAvailableFrameHeader(
    IN PKSPFRAME_HEADER FrameHeader
    )

/*++

Routine Description:

    This routine puts a frame header to the lookaside list.

    INTERIM:  This routine will not need to be here for frame-based transport.

Arguments:

    FrameHeader -
        Contains a pointer to the frame header to be put in the lookaside list.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsQueue::PutAvailableFrameHeader]"));

    ASSERT(FrameHeader);

    if (FrameHeader->MappingsTable) {
        DeleteMappingsTable(FrameHeader->MappingsTable);
        FrameHeader->MappingsTable = NULL;
    }
    //
    // Restore the original user mode buffer pointer if required.
    //
    if (FrameHeader->OriginalData) {
        ASSERT (FrameHeader->StreamHeader);
        if (FrameHeader->StreamHeader) {
            FrameHeader->StreamHeader->Data = FrameHeader->OriginalData;
        }
    }
    FrameHeader->OriginalData = NULL;
    FrameHeader->OriginalIrp = NULL;
    FrameHeader->Mdl = NULL;
    FrameHeader->Irp = NULL;
    FrameHeader->IrpFraming = NULL;
    FrameHeader->FrameBuffer = NULL;
    FrameHeader->Context = NULL;
    FrameHeader->RefCount = 0;
    FrameHeader->Status = STATUS_SUCCESS;
    FrameHeader->Type = KSPFRAME_HEADER_TYPE_NORMAL;
    FrameHeader->DismissalCall = FALSE;

    ExInterlockedInsertTailList(
        &m_FrameHeadersAvailable.ListEntry,
        &FrameHeader->ListEntry,
        &m_FrameHeadersAvailable.SpinLock);
}

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA

typedef struct {
    PKSPMAPPINGS_TABLE Table;
    LONG State;
    CKsQueue *Queue;
    KSPIN_LOCK Signaller;
} IOALLOCATEADAPTERCHANNELCONTEXT, *PIOALLOCATEADAPTERCHANNELCONTEXT;

IMPLEMENT_STD_UNKNOWN(CKsQueue)


NTSTATUS
KspCreateQueue(
    OUT PIKSQUEUE* Queue,
    IN ULONG Flags,
    IN PIKSPIPESECTION PipeSection,
    IN PIKSPROCESSINGOBJECT ProcessingObject,
    IN PKSPIN MasterPin,
    IN PKSGATE FrameGate OPTIONAL,
    IN BOOLEAN FrameGateIsOr,
    IN PKSGATE StateGate OPTIONAL,
    IN PIKSDEVICE Device,
    IN PDEVICE_OBJECT FunctionalDeviceObject,
    IN PADAPTER_OBJECT AdapterObject OPTIONAL,
    IN ULONG MaxMappingByteCount OPTIONAL,
    IN ULONG MappingTableStride OPTIONAL,
    IN BOOLEAN InputData,
    IN BOOLEAN OutputData
    )

/*++

Routine Description:

    This routine create a queue object.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KspCreateQueue]"));

    PAGED_CODE();

    ASSERT(Queue);
    ASSERT(PipeSection);
    ASSERT(ProcessingObject);
    ASSERT(MasterPin);
    ASSERT(FunctionalDeviceObject);

    CKsQueue *queue =
        new(NonPagedPool,POOLTAG_QUEUE) CKsQueue(NULL);

    NTSTATUS status;
    if (queue) {
        queue->AddRef();

        status = 
            queue->Init(
                Queue,
                Flags,
                PipeSection,
                ProcessingObject,
                MasterPin,
                FrameGate,
                FrameGateIsOr,
                StateGate,
                Device, 
                FunctionalDeviceObject,
                AdapterObject,
                MaxMappingByteCount,
                MappingTableStride,
                InputData,
                OutputData);

        queue->Release();
    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return status;
}


CKsQueue::
CKsQueue(PUNKNOWN OuterUnknown):
    CBaseUnknown(OuterUnknown)
{
}


CKsQueue::
~CKsQueue(
    void
    )

/*++

Routine Description:

    This routine destructs a queue object.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsQueue::~CKsQueue(0x%08x)]",this));
    _DbgPrintF(DEBUGLVL_LIFETIME,("#### Queue%p.~",this));

    PAGED_CODE();

    ASSERT(! m_TransportSink);
    ASSERT(! m_TransportSource);
    ASSERT(m_PipeSection);

    //
    // NOTE: README:
    //
    // Yes, I'm unbinding the pins in the queue's destructor.  It's been
    // argued that this might be a potential refcount issue in the future,
    // so I'm outlining why I'm doing it here:
    //
    // - It's the last place it can happen.  The pins must be unbound before
    //   the queue support goes away.
    //
    // - Placing at queue stop creates another problem.  Imagine the following:
    //
    //       ---------------- R
    //      /                 ^
    //      |                 |
    //      v                 |
    //      Q  --->  Q  --->  Q
    //     (a)      (b)      (c)
    //
    //   circuit is configured and complete.  R, a, b go to acquire.  c goes
    //   to acquire and fails because of minidriver failure on a bound pin.
    //   (b), (a), R now get stop messages.  If the pins are unbound, we
    //   mess up the circuit and any attempt to restart it by a reacquire
    //   on the pin that failed. **Any acquire failure should set the circuit
    //   state back to the point it was pre-acquire**
    // 
    if (m_PipeSection)
        m_PipeSection -> UnbindProcessPins ();

    if (m_FlushWorker) {
        KsUnregisterWorker (m_FlushWorker);
        m_FlushWorker = NULL;
    }

    if (m_Leading) {
        ExFreePool(m_Leading);
        m_Leading = NULL;
    }

    if (m_Trailing) {
        ExFreePool(m_Trailing);
        m_Trailing = NULL;
    }

    //
    // Make sure all stream pointers are gone now.
    //
#if 0
    if (InterlockedDecrement(&m_StreamPointersPlusOne)) {
        _DbgPrintF(DEBUGLVL_TERSE,("#### CKsQueue%p.~CKsQueue:  waiting for %d stream pointers to be deleted",this,m_StreamPointersPlusOne));
#if DBG
        DbgPrintQueue();
#endif
        KeWaitForSingleObject(
            &m_DestructEvent,
            Suspended,
            KernelMode,
            FALSE,
            NULL);
        _DbgPrintF(DEBUGLVL_TERSE,("#### CKsQueue%p.~CKsQueue:  done waiting",this));
    }
#endif

#if (DBG)
    if (! IsListEmpty(&m_FrameQueue.ListEntry)) {
        _DbgPrintF(DEBUGLVL_TERSE,("[CKsQueue::~CKsQueue] ERROR:  queue is not empty"));
        DbgPrintQueue();
        _DbgPrintF(DEBUGLVL_ERROR,("[CKsQueue::~CKsQueue] ERROR:  queue is not empty"));
    }
#endif

    //
    // No longer prevent processing due to state.
    //
    KsGateRemoveOffInputFromAnd(m_AndGate);
    if (m_StateGate) {
        if (m_StateGateIsOr) {
            KsGateRemoveOffInputFromOr(m_StateGate);
            ASSERT(m_StateGate->Count >= 0);
        } else {
            KsGateRemoveOffInputFromAnd(m_StateGate);
            ASSERT(m_StateGate->Count <= 1);
        }
    }
    _DbgPrintF(DEBUGLVL_PROCESSINGCONTROL,("#### Queue%p.~:  remove%p-->%d",this,m_AndGate,m_AndGate->Count));
    ASSERT(m_AndGate->Count <= 1);

    //
    // If the removal of this queue has unblocked processing on the filter,
    // then we must initiate it.
    //
    if (KsGateCaptureThreshold (m_AndGate)) {
        //
        // Processing needs to be initiated.  Process at the filter level.
        // For pin level processing, we should never get here....  because
        // the pin gate should be closed.
        //
        _DbgPrintF(DEBUGLVL_TERSE,("#### Queue%p.~:  Processing after queue deletion", this));
        m_ProcessingObject -> Process (m_ProcessAsynchronously);
    }

    //
    // Free all frame headers.
    //
    while (! IsListEmpty(&m_FrameHeadersAvailable.ListEntry)) {
        PLIST_ENTRY listEntry = RemoveHeadList(&m_FrameHeadersAvailable.ListEntry);
        PKSPFRAME_HEADER frameHeader = 
            CONTAINING_RECORD(listEntry,KSPFRAME_HEADER,ListEntry);
        ExFreePool(frameHeader);
    }

    //
    // Get rid of the contexts
    //
    ExDeleteNPagedLookasideList (&m_ChannelContextLookaside);

    if (m_PipeSection) {
        m_PipeSection->Release();
        m_PipeSection = NULL;
    }
    if (m_ProcessingObject) {
        m_ProcessingObject->Release();
        m_ProcessingObject = NULL;
    }

#if DBG
    KeCancelTimer(&m_DbgTimer);
#endif

    KsLog(&m_Log,KSLOGCODE_QUEUE_DESTROY,NULL,NULL);
}


STDMETHODIMP
CKsQueue::
NonDelegatedQueryInterface(
    IN REFIID InterfaceId,
    OUT PVOID * InterfacePointer
    )

/*++

Routine Description:

    This routine obtains an interface on a queue object.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsQueue::NonDelegatedQueryInterface]"));

    PAGED_CODE();

    ASSERT(InterfacePointer);

    NTSTATUS status = STATUS_SUCCESS;

    if (IsEqualGUIDAligned(InterfaceId,__uuidof(IKsTransport))) {
        *InterfacePointer = PVOID(PIKSTRANSPORT(this));
        AddRef();
    } else {
        status = 
            CBaseUnknown::NonDelegatedQueryInterface(
                InterfaceId,InterfacePointer);
    }

    return status;
}


NTSTATUS
CKsQueue::
Init(
    OUT PIKSQUEUE* Queue,
    IN ULONG Flags,
    IN PIKSPIPESECTION PipeSection,
    IN PIKSPROCESSINGOBJECT ProcessingObject,
    IN PKSPIN MasterPin,
    IN PKSGATE FrameGate OPTIONAL,
    IN BOOLEAN FrameGateIsOr,
    IN PKSGATE StateGate OPTIONAL,
    IN PIKSDEVICE Device,
    IN PDEVICE_OBJECT FunctionalDeviceObject,
    IN PADAPTER_OBJECT AdapterObject OPTIONAL,
    IN ULONG MaxMappingByteCount OPTIONAL,
    IN ULONG MappingTableStride OPTIONAL,
    IN BOOLEAN InputData,
    IN BOOLEAN OutputData
    )

/*++

Routine Description:

    This routine initializes a queue object.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsQueue::Init]"));

    PAGED_CODE();

    ASSERT(Queue);
    ASSERT(PipeSection);
    ASSERT(ProcessingObject);
    ASSERT(MasterPin);
    ASSERT(FunctionalDeviceObject);

    m_PipeSection = PipeSection;
    m_PipeSection->AddRef();
    m_ProcessingObject = ProcessingObject;
    m_ProcessingObject->AddRef();

    m_InputData = InputData;
    m_OutputData = OutputData;
    m_WriteOperation = InputData;

    m_ProcessPassive = ((Flags & KSPIN_FLAG_DISPATCH_LEVEL_PROCESSING) == 0);
    m_ProcessAsynchronously = ((Flags & KSPIN_FLAG_ASYNCHRONOUS_PROCESSING) != 0);
    m_InitiateProcessing = ((Flags & KSPIN_FLAG_DO_NOT_INITIATE_PROCESSING) == 0);
    m_ProcessOnEveryArrival = ((Flags & KSPIN_FLAG_INITIATE_PROCESSING_ON_EVERY_ARRIVAL) != 0);
    m_DepartInSequence = ((Flags & KSPIN_FLAG_ENFORCE_FIFO) != 0);
    
    m_GenerateMappings = ((Flags & KSPIN_FLAG_GENERATE_MAPPINGS) != 0);
    m_ZeroWindowSize = ((Flags & KSPIN_FLAG_DISTINCT_TRAILING_EDGE) == 0);

    m_FramesNotRequired = ((Flags & KSPIN_FLAG_FRAMES_NOT_REQUIRED_FOR_PROCESSING) != 0);

    m_MinProcessingState = ((Flags & KSPIN_FLAG_PROCESS_IN_RUN_STATE_ONLY) != 0) ? KSSTATE_RUN : KSSTATE_PAUSE;

    m_AndGate = m_ProcessingObject->GetAndGate();
    if (FrameGate) {
        m_FrameGate = FrameGate;
        m_FrameGateIsOr = FrameGateIsOr;
    } else if ((Flags & KSPIN_FLAG_FRAMES_NOT_REQUIRED_FOR_PROCESSING) == 0) {
        m_FrameGate = m_AndGate;
        m_FrameGateIsOr = FALSE;
    }

    if (StateGate && ((Flags & KSPIN_FLAG_PROCESS_IF_ANY_IN_RUN_STATE) != 0)) {
        m_StateGate = StateGate;
        m_StateGateIsOr = TRUE;
    } else {
        m_StateGate = NULL;
    }

    m_MasterPin = MasterPin;
    m_Device = Device;
    m_FunctionalDeviceObject = FunctionalDeviceObject;
    m_AdapterObject = AdapterObject;
    m_MaxMappingByteCount = MaxMappingByteCount;
    m_MappingTableStride = MappingTableStride;
    if (! m_MappingTableStride) {
        m_MappingTableStride = 1;
    }
    m_State = KSSTATE_STOP;
    m_StreamPointersPlusOne = 1;
    KeInitializeEvent(&m_DestructEvent,SynchronizationEvent,FALSE);

    m_TransportIrpsPlusOne = 1;
    KeInitializeEvent(&m_FlushEvent,SynchronizationEvent,FALSE);

    m_InternalReferenceCountPlusOne = 1;
    KeInitializeEvent(&m_InternalReferenceEvent,SynchronizationEvent,FALSE);

    ExInitializeNPagedLookasideList (
        &m_ChannelContextLookaside,
        NULL,
        NULL,
        0,
        sizeof (IOALLOCATEADAPTERCHANNELCONTEXT),
        'cAsK',
        5);

    InitializeListHead(&m_StreamPointers);
    InitializeInterlockedListHead(&m_FrameQueue);
    InitializeInterlockedListHead(&m_FrameHeadersAvailable);
    InitializeInterlockedListHead(&m_FrameCopyList);
    InitializeListHead(&m_WaitingIrps);

    InitializeListHead(&m_TimeoutQueue);
    KeInitializeDpc(&m_Dpc,DispatchTimer,this);
    KeInitializeTimer(&m_Timer);
#if DBG
    KeInitializeDpc(&m_DbgDpc,DispatchDbgTimer,this);
    KeInitializeTimer(&m_DbgTimer);
#endif

    //
    // Hold off processing until in pause or run state.
    //
    KsGateAddOffInputToAnd(m_AndGate);
    if (m_StateGate) {
        if (m_StateGateIsOr)  {
            KsGateAddOffInputToOr(m_StateGate);
            ASSERT (m_StateGate->Count >= 0);
        } else {
            KsGateAddOffInputToAnd(m_StateGate);
            ASSERT (m_StateGate->Count <= 1);
        }
    }
    _DbgPrintF(DEBUGLVL_PROCESSINGCONTROL,("#### Queue%p.Init:  add%p-->%d",this,m_AndGate,m_AndGate->Count));

    KsLogInitContext(&m_Log,MasterPin,this);

    ExInitializeWorkItem (&m_FlushWorkItem, CKsQueue::FlushWorker, 
        (PVOID)this);
    NTSTATUS status = KsRegisterCountedWorker(DelayedWorkQueue, 
        &m_FlushWorkItem, &m_FlushWorker);

    if (NT_SUCCESS(status)) {
        status = CreateStreamPointer(&m_Leading);
        if (NT_SUCCESS(status) && (Flags & KSPIN_FLAG_DISTINCT_TRAILING_EDGE)) {
            status = CreateStreamPointer(&m_Trailing);
        }
    }

    if (NT_SUCCESS(status)) {

        KsLog(&m_Log,KSLOGCODE_QUEUE_CREATE,NULL,NULL);

        //
        // Provide a transport interface.  This constitutes a reference.
        //
        *Queue = this;
        AddRef();
    } 

    return status;
}

#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif // ALLOC_PRAGMA

#if DBG


void
CKsQueue::
DispatchDbgTimer(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This routine dispatches a debug timeout.

Arguments:

    Dpc -
        Contains a pointer to the KDPC structure.

    DeferredContext -
        Contains a context pointer registered during the initialization of the
        DPC, in this case, the queue.

    SystemArgument1 -
        Not used.
        
    SystemArgument1 -
        Not used.       

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsQueue::DispatchDbgTimer]"));

    ASSERT(Dpc);
    ASSERT(DeferredContext);

    CKsQueue* queue = (CKsQueue *) DeferredContext;

    _DbgPrintF(DEBUGLVL_TERSE,("#### Queue%p.DispatchDbgTimer:  dumping queue on idle timeout",queue));
    if (DEBUG_VARIABLE >= DEBUGLVL_VERBOSE)
        queue->DbgPrintQueue();
}


STDMETHODIMP_(void)
CKsQueue::
DbgPrintQueue(
    void
    )

/*++

Routine Description:

    This routine prints the queue for debugging purposes.

Arguments:

    None.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsQueue::DbgPrintQueue]"));

    KIRQL oldIrql;
    KeAcquireSpinLock(&m_FrameQueue.SpinLock,&oldIrql);

    DbgPrint("\tAndGate%p = %d\n",m_AndGate,m_AndGate->Count);
    
    if ( m_FrameGate != NULL ) { // can be NULL, must check 1st.
	    DbgPrint("\tFrameGate%p = %d\n",m_FrameGate,m_FrameGate->Count);
	}

    //
    // Print all the frames.
    //
    for (PLIST_ENTRY listEntry = m_FrameQueue.ListEntry.Flink;
        listEntry != &m_FrameQueue.ListEntry;
        listEntry = listEntry->Flink) {
        PKSPFRAME_HEADER frameHeader = 
            CONTAINING_RECORD(listEntry,KSPFRAME_HEADER,ListEntry);

        DbgPrint("        ");
        DbgPrintFrameHeader(frameHeader);
    }

    //
    // Print all the stream headers.
    //
    DbgPrint("        Leading ");
    DbgPrintStreamPointer(m_Leading);

    DbgPrint("        Trailing ");
    DbgPrintStreamPointer(m_Trailing);

    for (listEntry = m_StreamPointers.Flink;
        listEntry != &m_StreamPointers;
        listEntry = listEntry->Flink) {
        PKSPSTREAM_POINTER streamPointer = 
            CONTAINING_RECORD(listEntry,KSPSTREAM_POINTER,ListEntry);

        DbgPrint("        ");
        DbgPrintStreamPointer(streamPointer);
    }

    for (listEntry = m_WaitingIrps.Flink;
        listEntry != &m_WaitingIrps;
        listEntry = listEntry->Flink) {
        PIRP irp = CONTAINING_RECORD(listEntry,IRP,Tail.Overlay.ListEntry);

        DbgPrint("        Waiting IRP %p\n",irp);
    }

    KeReleaseSpinLock(&m_FrameQueue.SpinLock,oldIrql);
}


void
CKsQueue::
DbgPrintStreamPointer(
    IN PKSPSTREAM_POINTER StreamPointer OPTIONAL
    )

/*++

Routine Description:

    This routine prints a stream pointer for debugging purposes.

Arguments:

    StreamPointer -
        Contains an optional pointer to the stream pointer to print.

Return Value:

    None.

--*/

{
    DbgPrint("StreamHeader %p\n",StreamPointer);
    if (StreamPointer && DEBUG_VARIABLE >= DEBUGLVL_BLAB) {
        switch (StreamPointer->State) {
        case KSPSTREAM_POINTER_STATE_UNLOCKED:
            DbgPrint("            State = KSPSTREAM_POINTER_STATE_UNLOCKED\n");
            break;
        case KSPSTREAM_POINTER_STATE_LOCKED:
            DbgPrint("            State = KSPSTREAM_POINTER_STATE_LOCKED\n");
            break;
        case KSPSTREAM_POINTER_STATE_CANCELLED:
            DbgPrint("            State = KSPSTREAM_POINTER_STATE_CANCELLED\n");
            break;
        case KSPSTREAM_POINTER_STATE_DELETED:
            DbgPrint("            State = KSPSTREAM_POINTER_STATE_DELETED\n");
            break;
        case KSPSTREAM_POINTER_STATE_CANCEL_PENDING:
            DbgPrint("            State = KSPSTREAM_POINTER_STATE_CANCEL_PENDING\n");
            break;
        case KSPSTREAM_POINTER_STATE_DEAD:
            DbgPrint("            State = KSPSTREAM_POINTER_STATE_DEAD\n");
            break;
        default:
            DbgPrint("            State = ILLEGAL(%d)\n",StreamPointer->State);
            break;
        }
        ASSERT(StreamPointer->Queue == this);
        DbgPrint("            FrameHeader = %p\n",StreamPointer->FrameHeader);
        DbgPrint("            FrameHeaderStarted = %p\n",StreamPointer->FrameHeaderStarted);
        DbgPrint("            Public.Context = %p\n",StreamPointer->Public.Context);
        DbgPrint("            Public.Pin = %p\n",StreamPointer->Public.Pin);
        DbgPrint("            Public.StreamHeader = %p\n",StreamPointer->Public.StreamHeader);
        DbgPrint("            Public.OffsetIn.Data = %p\n",StreamPointer->Public.OffsetIn.Data);
        DbgPrint("            Public.OffsetIn.Count = %d\n",StreamPointer->Public.OffsetIn.Count);
        DbgPrint("            Public.OffsetIn.Remaining = %d\n",StreamPointer->Public.OffsetIn.Remaining);
        DbgPrint("            Public.OffsetOut.Data = %p\n",StreamPointer->Public.OffsetIn.Data);
        DbgPrint("            Public.OffsetOut.Count = %d\n",StreamPointer->Public.OffsetIn.Count);
        DbgPrint("            Public.OffsetOut.Remaining = %d\n",StreamPointer->Public.OffsetIn.Remaining);
    }
}


void
CKsQueue::
DbgPrintFrameHeader(
    IN PKSPFRAME_HEADER FrameHeader OPTIONAL
    )

/*++

Routine Description:

    This routine prints a frame header for debugging purposes.

Arguments:

    StreamPointer -
        Contains an optional pointer to the frame header to print.

Return Value:

    None.

--*/

{
    DbgPrint("FrameHeader %p\n",FrameHeader);
    if (FrameHeader && DEBUG_VARIABLE >= DEBUGLVL_BLAB) {
        DbgPrint("            NextFrameHeaderInIrp = %p\n",FrameHeader->NextFrameHeaderInIrp);
        ASSERT(FrameHeader->Queue == this);
        DbgPrint("            OriginalIrp = %p\n",FrameHeader->OriginalIrp);
        DbgPrint("            Mdl = %p\n",FrameHeader->Mdl);
        DbgPrint("            Irp = %p\n",FrameHeader->Irp);
        DbgPrint("            IrpFraming = %p\n",FrameHeader->IrpFraming);
        if (FrameHeader->IrpFraming) {
            DbgPrint("                OutputBufferLength = %p\n",FrameHeader->IrpFraming->OutputBufferLength);
            DbgPrint("                RefCount = %d\n",FrameHeader->IrpFraming->RefCount);
            DbgPrint("                QueuedFrameHeaderCount = %d\n",FrameHeader->IrpFraming->QueuedFrameHeaderCount);
            DbgPrint("                FrameHeaders = %p\n",FrameHeader->IrpFraming->FrameHeaders);
        }
        DbgPrint("            StreamHeader = %p\n",FrameHeader->StreamHeader);
        if (FrameHeader->StreamHeader) {
            DbgPrint("                OptionsFlags = %p\n",FrameHeader->StreamHeader->OptionsFlags);
        }
        DbgPrint("            FrameBuffer = %p\n",FrameHeader->FrameBuffer);
        DbgPrint("            StreamHeaderSize = %d\n",FrameHeader->StreamHeaderSize);
        DbgPrint("            FrameBufferSize = %d\n",FrameHeader->FrameBufferSize);
        DbgPrint("            Context = %p\n",FrameHeader->Context);
        DbgPrint("            RefCount = %d\n",FrameHeader->RefCount);
    }
}

#endif // DBG


void
CKsQueue::
CancelRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine handles IRP cancellation.

Arguments:

    DeviceObject -
        Contains a pointer to the device object.

    Irp -
        Contains a pointer to the IRP to be cancelled.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsQueue::CancelRoutine]"));

    ASSERT(DeviceObject);
    ASSERT(Irp);

    //
    // Get our context from the IRP.  All the frame headers associated with
    // the IRP must point to the queue.
    //
    PKSPIRP_FRAMING irpFraming = IRP_FRAMING_IRP_STORAGE(Irp);

    ASSERT(irpFraming->FrameHeaders);
    ASSERT(irpFraming->FrameHeaders->Queue);

    CKsQueue *queue = (CKsQueue *) irpFraming->FrameHeaders->Queue;

    //
    // Take the queue spinlock and release the cancel spinlock.  This frees up
    // the system a bit, and we have free access to the queue's list of frame
    // headers.
    //
    KeAcquireSpinLockAtDpcLevel(&queue->m_FrameQueue.SpinLock);
    ASSERT(irpFraming->RefCount == 0);
    IoReleaseCancelSpinLock(DISPATCH_LEVEL);

    //
    // Cancel stream pointers and remove headers.
    //
    queue->CancelStreamPointers(Irp);
    queue->RemoveIrpFrameHeaders(Irp);

    //
    // The IRP refcount is incremented to reflect pending stream pointer
    // cancellations.  If it's zero, cancellation can be completed now.
    // Otherwise, we'll have to finish up when the last stream pointer
    // is deleted.
    //
    if (irpFraming->RefCount == 0) {
        //
        // The IRP is ready to go.  Throw away the frame headers.
        //
        while (irpFraming->FrameHeaders) {
            PKSPFRAME_HEADER frameHeader = irpFraming->FrameHeaders;
            irpFraming->FrameHeaders = frameHeader->NextFrameHeaderInIrp;
            queue->PutAvailableFrameHeader(frameHeader);
        }

        //
        // Release the queue spin lock.
        //
        KeReleaseSpinLock(&queue->m_FrameQueue.SpinLock,Irp->CancelIrql);

        //
        // Cancelled Irps can no longer be completed in the queue.  They
        // must be sent around the circuit back to the sink pin where
        // they will be completed.  This is because the pin must wait
        // until Irps arrive back at the sink to prevent racing with
        // pipe teardown.
        //
        if (queue->m_TransportSink)
            KspDiscardKsIrp (queue->m_TransportSink, Irp);
        else 
            IoCompleteRequest(Irp,IO_NO_INCREMENT);
    } else {
        //
        // Release the queue spin lock.
        //
        KeReleaseSpinLock(&queue->m_FrameQueue.SpinLock,Irp->CancelIrql);
    }
}


void
CKsQueue::
CancelStreamPointers(
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine cancels stream pointers.

    THE QUEUE SPINLOCK MUST BE ACQUIRED PRIOR TO CALLING THIS FUNCTION.

Arguments:

    Irp -
        Contains a pointer to the IRP associated with the stream pointers to 
        be cancelled.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsQueue::CancelStreamPointers]"));

    ASSERT(Irp);

    //
    // Cancel all timeouts.
    //
    while (! IsListEmpty(&m_TimeoutQueue)) {
        PLIST_ENTRY listEntry = RemoveHeadList(&m_TimeoutQueue);
        PKSPSTREAM_POINTER streamPointer =
            CONTAINING_RECORD(listEntry,KSPSTREAM_POINTER,TimeoutListEntry);
        streamPointer->TimeoutListEntry.Flink = NULL;
    }
    SetTimerUnsafe(GetTime(FALSE));

    //
    // Cancel all the stream pointers referencing frames we will be removing.
    //
    for (PLIST_ENTRY listEntry = m_StreamPointers.Flink;
        listEntry != &m_StreamPointers;) {
        PKSPSTREAM_POINTER streamPointer = 
            CONTAINING_RECORD(listEntry,KSPSTREAM_POINTER,ListEntry);
        PKSPFRAME_HEADER frameHeader = streamPointer->FrameHeader;

        listEntry = listEntry->Flink;

        if (frameHeader && (frameHeader->Irp == Irp)) {
            //
            // This stream pointer needs to get cancelled.  It should not be
            // locked, because that would have prevented cancellation.  Mark
            // it cancelled so deletion will do the right thing.
            //
            ASSERT(streamPointer->State == KSPSTREAM_POINTER_STATE_UNLOCKED);
            streamPointer->State = KSPSTREAM_POINTER_STATE_CANCELLED;

            //
            // Remove it from the list.
            //
            RemoveEntryList(&streamPointer->ListEntry);

            //
            // Decrement the count on the frame header.
            //
            frameHeader->RefCount--;

            //
            // Tell the client we are cancelling.
            //
            if (streamPointer->CancelCallback) {
                m_LockContext = KeGetCurrentThread ();
                streamPointer->CancelCallback(&streamPointer->Public);
                m_LockContext = NULL;
                if (streamPointer->State == KSPSTREAM_POINTER_STATE_DELETED) {
                    //
                    // The client has asked for it to be deleted.
                    //
                    FreeStreamPointer(streamPointer);
                } else {
                    //
                    // The client will delete it later.  We increment the IRP
                    // refcount to hold off completion.
                    //
                    streamPointer->State = KSPSTREAM_POINTER_STATE_CANCEL_PENDING;
                    IRP_FRAMING_IRP_STORAGE(frameHeader->Irp)->RefCount++;
                }
            } else {
                //
                // The client has no cancellation callback, so we hollow out
                // the stream pointer.
                //
                streamPointer->State = KSPSTREAM_POINTER_STATE_DEAD;
                streamPointer->FrameHeader = NULL;
                streamPointer->FrameHeaderStarted = NULL;
                streamPointer->Public.StreamHeader = NULL;
                RtlZeroMemory(
                    &streamPointer->Public.OffsetIn,
                    sizeof(streamPointer->Public.OffsetIn));
                RtlZeroMemory(
                    &streamPointer->Public.OffsetOut,
                    sizeof(streamPointer->Public.OffsetOut));
            }
        }
    }
}


void
CKsQueue::
CancelAllIrps(
    void
    )

/*++

Routine Description:

    This routine cancels all IRPs in the queue.

Arguments:

    None.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsQueue::CancelAllIrps]"));

    //
    // Start at the end of the list each time an IRP is cancelled.  Because we
    // must release the list spinlock to cancel, the list may change utterly
    // every time we cancel.
    //
    while (1) {
        //
        // Take the queue spinlock so we can look at the queue.
        //
        KIRQL oldIrql;
        KeAcquireSpinLock(&m_FrameQueue.SpinLock,&oldIrql);

        for (PLIST_ENTRY listEntry = m_FrameQueue.ListEntry.Blink;
             ;
             listEntry = listEntry->Blink) {

            //
            // Release the lock and return if the list is empty.
            //
            if (listEntry == &m_FrameQueue.ListEntry) {
                KeReleaseSpinLock(&m_FrameQueue.SpinLock,oldIrql);
                return;
            }

            //
            // Get the IRP associated with this frame header.
            //
            PKSPFRAME_HEADER frameHeader = 
                CONTAINING_RECORD(listEntry,KSPFRAME_HEADER,ListEntry);
            PIRP irp = frameHeader->Irp;
            ASSERT(irp);

            //
            // Mark the IRP cancelled.
            //
            irp->Cancel = TRUE;

            //
            // Now try to clear the cancel routine.  If it is already cleared,
            // we can't do the cancellation.  Presumeably, this will be done
            // when someone tries to make the IRP cancelable again.
            //
            PDRIVER_CANCEL driverCancel = IoSetCancelRoutine(irp,NULL);
            if (driverCancel) {
                //
                // The IRP cannot be cancelled, so it's OK to remove the lock.
                //
                KeReleaseSpinLock(&m_FrameQueue.SpinLock,oldIrql);

                //
                // Acquire the cancel spinlock because the cancel routine 
                // expects it.
                //
                IoAcquireCancelSpinLock(&irp->CancelIrql);
                driverCancel(IoGetCurrentIrpStackLocation(irp)->DeviceObject,irp);

                //
                // Leave the inner loop and start at the top of the list again.
                //
                break;
            }
        }
    }
}


void
CKsQueue::
RemoveIrpFrameHeaders(
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine removes frame headers associated with an IRP.

    THE QUEUE SPINLOCK MUST BE ACQUIRED PRIOR TO CALLING THIS FUNCTION.

Arguments:

    Irp -
        Contains a pointer to the IRP to be cancelled.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsQueue::RemoveIrpFrameHeaders]"));

    ASSERT(Irp);

    PKSPIRP_FRAMING irpFraming = IRP_FRAMING_IRP_STORAGE(Irp);

    //
    // Remove the frame headers from the queue.
    //
    for (PKSPFRAME_HEADER frameHeader = irpFraming->FrameHeaders; 
         frameHeader; 
         frameHeader = frameHeader->NextFrameHeaderInIrp) {
        //
        // The Flink will be NULL if the frame header is not on the queue.
        //
        if (frameHeader->ListEntry.Flink) {
            //
            // Any remaining refcounts are due to leading/trailing stream 
            // pointers.
            //

            //
            // Make sure the leading edge does not point to this frame.  If we
            // need to advance the stream pointer, we reference the frame
            // header first just to make sure it is not removed normally.  As
            // a result, it does not matter what IRQL we pass in to the advance
            // function.
            //
            if (m_Leading->FrameHeader == frameHeader) {
                frameHeader->RefCount++;
                SetStreamPointer(
                    m_Leading,
                    NextFrameHeader(m_Leading->FrameHeader),
                    NULL);
            }

            //
            // Make sure the trailing edge does not point to this frame.  If we
            // need to advance the stream pointer, we reference the frame
            // header first just to make sure it is not removed normally.  As
            // a result, it does not matter what IRQL we pass in to the advance
            // function.
            //
            if (m_Trailing && 
                m_Trailing->FrameHeader == frameHeader) {
                frameHeader->RefCount++;
                SetStreamPointer(
                    m_Trailing,
                    NextFrameHeader(m_Trailing->FrameHeader),
                    NULL);
            }

            //
            // Remove the frame header from the list.  Set the Flink to NULL
            // to indicate it is removed.  This is probably unnecessary, but
            // it is consistent.
            //
            RemoveEntryList(&frameHeader->ListEntry);
            frameHeader->ListEntry.Flink = NULL;

            //
            // Update counters.
            //
            InterlockedDecrement(&m_FramesWaiting);
            InterlockedIncrement(&m_FramesCancelled);
        } else {
            //
            // Frames not in the queue must not have a reference.
            //
            ASSERT(frameHeader->RefCount == 0);
        }
    }
}


void
CKsQueue::
FrameToFrameCopy (
    IN PKSPSTREAM_POINTER ForeignSource,
    IN PKSPSTREAM_POINTER LocalDestination
    )

/*++

Routine Description:

    Perform a frame to frame copy on two locked stream pointers.  This is
    a ** PREREQUISITE TO CALLING THIS FUNCTION ** [both stream pointers must
    be locked].  The first is a foreign pointer (it belongs to another
    queue).  The second is a local pointer (it belongs to this queue).

Arguments:

    ForeignSource -
        A foreign stream pointer in the LOCKED state which will serve
        as the source for the frame to frame copy

    LocalDestination -
        A local stream pointer in the LOCKED state which will serve
        as the destination for the frame to frame copy

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsQueue::FrameToFrameCopy]"));

    ASSERT (ForeignSource);
    ASSERT (LocalDestination);
    ASSERT (ForeignSource->State == KSPSTREAM_POINTER_STATE_LOCKED);
    ASSERT (LocalDestination->State == KSPSTREAM_POINTER_STATE_LOCKED);

    PIKSQUEUE ForeignQueue = ForeignSource->Queue;

    ULONG bytesToCopy;
    PUCHAR data;
    BOOLEAN Success = TRUE;

    if (!ForeignQueue->GeneratesMappings ()) {
        bytesToCopy = (ULONG)
            ForeignSource->Public.OffsetOut.Count -
            ForeignSource->Public.OffsetOut.Remaining;
        data = ForeignSource->Public.OffsetOut.Data - bytesToCopy;
    } else {
        bytesToCopy = ForeignSource->Public.StreamHeader->DataUsed;
        data = (PUCHAR)MmGetMdlVirtualAddress (ForeignSource->FrameHeader->Mdl);

    }

    //
    // Copy the data....  we must take mappings into account.  Note that as
    // an optimization, I do not bother adjusting mapping pointers after
    // the copy.  As now, it's unnecessary and would require determination of
    // the number of mappings we've copied into.
    //
    if (GeneratesMappings ()) {
        if (LocalDestination->Public.StreamHeader->FrameExtent >= bytesToCopy)
            RtlCopyMemory (
                MmGetMdlVirtualAddress (LocalDestination->FrameHeader->Mdl),
                data,
                bytesToCopy
                );
        else
            Success = FALSE;
    } else {
        if (LocalDestination->Public.OffsetOut.Remaining >= bytesToCopy) {
            RtlCopyMemory (
                LocalDestination->Public.OffsetOut.Data,
                data,
                bytesToCopy
                );

            LocalDestination->Public.OffsetOut.Remaining -= bytesToCopy;
            LocalDestination->Public.OffsetOut.Data += bytesToCopy;

        }
        else
            Success = FALSE;
    }

    if (Success) {
        LocalDestination->Public.StreamHeader->OptionsFlags =
            ForeignSource->Public.StreamHeader->OptionsFlags;

        LocalDestination->Public.StreamHeader->DataUsed = bytesToCopy;
    }

}


BOOLEAN 
CKsQueue::
CompleteWaitingFrames (
    )

/*++

Description:

    Complete any frames waiting for transit into frames in the queue.  These
    are frames which would have been copied into the queue, but there were
    no frames available at that time.  [queued for output in 
    CKsQueue::CopyFrame]

Arguments:

Return Value:

    An indication of whether or not we emptied the queue.  [Not the copy
    queue, but the CKsQueue of frames]

Notes:

    ** THE COPY LIST SPINLOCK MUST BE HELD PRIOR TO CALLING THIS FUNCTION **

--*/

{

    _DbgPrintF(DEBUGLVL_BLAB,("[CKsQueue::CompleteWaitingFrames]"));

    BOOLEAN EmptiedQueue = FALSE;

    if (!IsListEmpty (&m_FrameCopyList.ListEntry)) {
        //
        // The only time we should have frames sitting on a copy list is
        // if there weren't enough buffers to begin with!
        //
        NTSTATUS status = STATUS_SUCCESS;
        PLIST_ENTRY ListEntry = m_FrameCopyList.ListEntry.Flink;
        
        if (!LockStreamPointer(m_Leading))
            status = STATUS_DEVICE_NOT_READY;

        //
        // Copy all the frames we can until we either run out of space or
        // until the list is empty.
        //
        while (NT_SUCCESS (status) && 
            ListEntry != &(m_FrameCopyList.ListEntry)) {

            PLIST_ENTRY NextEntry = ListEntry->Flink;

            PKSPSTREAM_POINTER_COPY_CONTEXT CopyContext = 
                (PKSPSTREAM_POINTER_COPY_CONTEXT)CONTAINING_RECORD (
                    ListEntry, KSPSTREAM_POINTER_COPY_CONTEXT, ListEntry);

            PKSPSTREAM_POINTER SourcePointer =
                &(((PKSPSTREAM_POINTER_COPY)CONTAINING_RECORD (
                    CopyContext, KSPSTREAM_POINTER_COPY, CopyContext))->
                        StreamPointer);

            ASSERT (SourcePointer->Public.Context == CopyContext);

            if (SourcePointer->Queue->LockStreamPointer(SourcePointer)) {
                FrameToFrameCopy (SourcePointer, m_Leading);
            
                RemoveEntryList (&(CopyContext->ListEntry));
                CopyContext->ListEntry.Flink = NULL;

                SourcePointer->Queue->DeleteStreamPointer (SourcePointer);

                UnlockStreamPointer (m_Leading, 
                    KSPSTREAM_POINTER_MOTION_ADVANCE);
            }                        

            ListEntry = NextEntry;
            
            if (NextEntry != &(m_FrameCopyList.ListEntry)) 
                if (!LockStreamPointer (m_Leading))
                    status = STATUS_DEVICE_NOT_READY;

        }
        //
        // Make a quick check...  This checks whether or not we just emptied
        // the queue.
        //
        if (m_FrameQueue.ListEntry.Flink == &(m_FrameQueue.ListEntry))
            EmptiedQueue = TRUE;
    }

    return EmptiedQueue;

}


void
CKsQueue::
AddFrame(
    IN PKSPFRAME_HEADER FrameHeader
    )

/*++

Routine Description:

    This routine adds a frame to the queue.

Arguments:

    FrameHeader -
        Contains a pointer to the frame's header.

Return Value:

    STATUS_PENDING or some error status.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsQueue::AddFrame]"));

    ASSERT(FrameHeader);
    ASSERT(FrameHeader->RefCount == 0);

    BOOLEAN InitiatePotential = TRUE;

    KIRQL oldIrql;
    KeAcquireSpinLock(&m_FrameQueue.SpinLock,&oldIrql);

    ULONG DataSize = FrameHeader -> StreamHeader -> DataUsed;

    InsertTailList(&m_FrameQueue.ListEntry,&FrameHeader->ListEntry);

    //
    // Set the leading and trailing stream pointers if they were not pointing 
    // to anything.
    //
    BOOLEAN wasEmpty = ! m_Leading->FrameHeader;
    if (! m_Leading->FrameHeader) {
        SetStreamPointer(m_Leading,FrameHeader,NULL);
    }
    if (m_Trailing && ! m_Trailing->FrameHeader) {
        SetStreamPointer(m_Trailing,FrameHeader,NULL);
    }

    KeReleaseSpinLock(&m_FrameQueue.SpinLock,oldIrql);

    //
    // Count the frame.
    //
    InterlockedIncrement(&m_FramesReceived);
    InterlockedIncrement(&m_FramesWaiting);

    //
    // Keep track of the number of bytes available in the queue
    //
    if (m_InputData)
        while (1) {
            LONG curCount = m_AvailableInputByteCount;
            LONG repCount =
                InterlockedCompareExchange (
                    &m_AvailableInputByteCount,
                    curCount + DataSize,
                    curCount
                );
            if (curCount == repCount) break;
        };
    if (m_OutputData)
        while (1) {
            LONG curCount = m_AvailableOutputByteCount;
            LONG repCount =
                InterlockedCompareExchange (
                    &m_AvailableOutputByteCount,
                    curCount + FrameHeader -> FrameBufferSize,
                    curCount
                );
            if (curCount == repCount) break;
        };

    //
    // Before we attempt to initiate processing, we must check whether or not
    // this buffer already belongs to a frame which is supposed to be outgoing.
    // 
    // If the completion of waiting frames emptied the queue, don't bother
    // triggering processing
    //
    KeAcquireSpinLock (&m_FrameCopyList.SpinLock,&oldIrql);
    InitiatePotential = !CompleteWaitingFrames ();

    //
    // Determine if processing needs to be initiated.
    //
    if (m_InitiateProcessing && InitiatePotential && 
        (m_ProcessOnEveryArrival || wasEmpty)) {

        //
        // Send a triggering event notification to the processing object.
        //
        m_ProcessingObject->TriggerNotification();

        if (KsGateCaptureThreshold(m_AndGate)) {
            KeReleaseSpinLock(&m_FrameCopyList.SpinLock,oldIrql);
            //
            // Processing needs to be initiated.  Process locally or at the
            // filter level.
            //
            m_ProcessingObject->Process(m_ProcessAsynchronously);
        } else
            KeReleaseSpinLock(&m_FrameCopyList.SpinLock,oldIrql);
    } else
        KeReleaseSpinLock(&m_FrameCopyList.SpinLock,oldIrql);

}


void
CKsQueue::
ReleaseCopyReference (
    IN PKSSTREAM_POINTER streamPointer
    )

/*++

Routine Description:

    For some reason, whatever queue we're supposed to copy this data from
    is going and cancelling our stream pointer.  This may be due to Irp
    cancellation, stopping, etc...  We must remove it from the list in
    a synchronous manner so as not to rip the reference from a thread which
    already has it.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsQueue::ReleaseCopyReference]"));

    //
    // At first, we cannot even touch the stream pointer.  It's possible
    // that another thread is holding this and is about to delete it. 
    //
    KIRQL Irql;
    PKSPSTREAM_POINTER_COPY_CONTEXT CopyContext;
    PKSPSTREAM_POINTER pstreamPointer = (PKSPSTREAM_POINTER)
        CONTAINING_RECORD(streamPointer, KSPSTREAM_POINTER, Public);

    CKsQueue *Queue = (CKsQueue *)(
        ((PKSPSTREAM_POINTER_COPY_CONTEXT)streamPointer->Context)->Queue
        );

    KeAcquireSpinLock (&Queue->m_FrameCopyList.SpinLock, &Irql);

    CopyContext = (PKSPSTREAM_POINTER_COPY_CONTEXT)streamPointer->Context;

    //
    // If it wasn't on the list, it's already been removed by another
    // thread in contention with this one.
    //
    if (CopyContext->ListEntry.Flink != NULL &&
        !IsListEmpty (CopyContext->ListEntry.Flink)) {
        
        //
        // Otherwise, we remove the stream pointer from the list and 
        // delete it.
        //
        RemoveEntryList (&(CopyContext->ListEntry));
        CopyContext->ListEntry.Flink = NULL;

        pstreamPointer->Queue->DeleteStreamPointer (pstreamPointer);

    }

    KeReleaseSpinLock (&Queue->m_FrameCopyList.SpinLock, Irql);
}


void
CKsQueue::
CopyFrame (
    IN PKSPSTREAM_POINTER sourcePointer
    )

/*++

Routine Description:

    Copy the frame pointed to by sourcePointer into the queue when the next
    available frame arrives.  If there is a current frame, copy it 
    immediately.

Arguments:

    sourcePointer -
        The stream pointer source of the frame.

    sourceQueue -
        The queue out of which sourcePointer came.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsQueue::CopyFrame]"));

    KIRQL Irql;
    PKSPSTREAM_POINTER ClonePointer;
    NTSTATUS status = STATUS_SUCCESS;
    PKSPSTREAM_POINTER_COPY_CONTEXT CopyContext;

    //
    // First of all, determine whether we really care about this notification.
    // If the client has specified KSPIN_FLAG_FRAMES_NOT_REQUIRED_FOR_PROCESSING
    // then we just drop the frame on the floor.
    //
    if (m_FramesNotRequired) {
        //
        // The only thing we must be careful of is dropping an EOS frame on
        // the floor.  We can drop the data...  we cannot drop the EOS or
        // the potential exists for the graph NOT to stop.  Set m_EndOfStream
        // if we are going to perform a drop of the EOS frame.  This will
        // cause the next Irp arriving to be completed with EOS.  Hopefully,
        // this will be sufficient to trigger a stop condition.
        //
        if (sourcePointer->Public.StreamHeader->OptionsFlags &
            KSSTREAM_HEADER_OPTIONSF_ENDOFSTREAM) {
            m_EndOfStream = TRUE;
        }

        return;
    }

    KeAcquireSpinLock (&m_FrameCopyList.SpinLock, &Irql);

    //
    // The source pointer had better well be in an unlocked state about
    // to be removed!
    //
    status = 
        sourcePointer->Queue->CloneStreamPointer (
            &ClonePointer,
            CKsQueue::ReleaseCopyReference,
            sizeof (KSPSTREAM_POINTER_COPY_CONTEXT),
            sourcePointer,
            KSPSTREAM_POINTER_TYPE_INTERNAL
            );

    //
    // If the clone is locked, unlock it; we cannot hold non-cancellable
    // references into another queue for arbitrary periods.
    //
    if (ClonePointer->State == KSPSTREAM_POINTER_STATE_LOCKED)
        sourcePointer->Queue->UnlockStreamPointer (
            ClonePointer, KSPSTREAM_POINTER_MOTION_NONE
            );

    //
    // If we couldn't clone the frame, there wasn't enough memory or something
    // else bad happened and we can safely drop the frame.
    //
    // Otherwise, the frame will get put in a list of outgoing frames.  This
    // list has priority over client callbacks.
    //
    if (NT_SUCCESS (status)) {

        //
        // There's a guarantee that clone context information comes immediately
        // after the clone.
        //
        CopyContext = (PKSPSTREAM_POINTER_COPY_CONTEXT)(ClonePointer + 1);
        CopyContext->Queue = (PIKSQUEUE)this;

        InsertTailList (&m_FrameCopyList.ListEntry, &CopyContext->ListEntry);

    }

    //
    // It's possible that we AddFrame'd before taking the frame copy list 
    // spinlock...  or that we're about to AddFrame.  If it's the case that
    // we're ABOUT to AddFrame, there's no problem...  the AddFrame code will
    // pick up the frame as soon as we release this spinlock.  However,
    // if we did an AddFrame, it's possible that the buffer could be ready
    // to go right now.  The tricky part is preventing a conflict between a
    // thread trying to add a frame and this thread.  The way this is
    // prevented is via the gate threshold.  If we have a frame ready to
    // copy into, the gate will be open and WE capture the threshold.  If 
    // the processing attempt
    //
    if (KsGateCaptureThreshold (m_AndGate)) {
        CompleteWaitingFrames ();
        KsGateTurnInputOn (m_AndGate);
    }

    KeReleaseSpinLock (&m_FrameCopyList.SpinLock, Irql);

}


void
CKsQueue::
ReleaseIrp(
    IN PIRP Irp,
    IN PKSPIRP_FRAMING IrpFraming,
    OUT PIKSTRANSPORT* NextTransport OPTIONAL
    )

/*++

Routine Description:

    This routine releases a reference on an IRP.  This may involve forwarding
    or cancelling the IRP.

Arguments:

    Irp -
        Contains a pointer to the IRP to be released.

    IrpFraming -
        Contains a pointer to the framing overly for the IRP.

    NextTransport -
        Contains a pointer to the next transport component to recieve the IRP.
        If this pointer is NULL, and the IRP needs to be forwarded, the IRP
        will be transferred explicitly using KspTransferKsIrp().  If this
        pointer is not NULL, and the IRP needs to be forwarded, the interface
        pointer for the next transport component is deposited at this location.
        If the pointer is not NULL, and the IRP does not need to be forwarded,
        NULL will be deposited at this location.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsQueue::ReleaseIrp]"));

    ASSERT(Irp);
    ASSERT(IrpFraming);

    //
    // Acquire the queue spinlock.
    //
    KIRQL oldIrql;
    KeAcquireSpinLock(&m_FrameQueue.SpinLock,&oldIrql);

    //
    // Just double check for ref count errors.
    //
    ASSERT (IrpFraming->RefCount != 0); 

    BOOLEAN IrpForwardable = TRUE;

    //
    // Decrement the count on the IRP.
    //
    if (IrpFraming->RefCount-- == 1) {
        //
        // No one has the IRP acquired.  Forward it or make it cancelable.
        //
        if (IrpFraming->QueuedFrameHeaderCount) {
            //
            // There are still frames in the queue.  Make the IRP cancelable.
            //
            IoSetCancelRoutine(Irp,CKsQueue::CancelRoutine);

            //
            // Now check to see whether the IRP was cancelled.  If so, and we
            // can clear the cancel routine, do the cancellation here and now.
            //
            if (Irp->Cancel && IoSetCancelRoutine(Irp,NULL)) {
                //
                // Call the cancel routine after releasing the queue spinlock
                // and taking the cancel spinlock.
                //
                KeReleaseSpinLock(&m_FrameQueue.SpinLock,oldIrql);
                IoAcquireCancelSpinLock(&Irp->CancelIrql);
                CKsQueue::CancelRoutine(
                    IoGetCurrentIrpStackLocation(Irp)->DeviceObject,
                    Irp);
                return;
            } else {
                //
                // Either the IRP was not cancelled or someone else will call
                // the cancel routine.
                //
                IrpForwardable = FALSE;
            }
        }
    } else {
        //
        // There are other references to the IRP.  Do nothing more.
        //
        IrpForwardable = FALSE;
    }

    //
    // Mark the Irp pending before we release the frame queue spinlock if
    // we're called from a TransferKsIrp context (NextTransport != NULL)
    //
    // Note that the Irp could be cancelled, but not completed yet.  The 
    // cancellation routine blocks on the frame queue spinlock.
    //
    if (!IrpForwardable && NextTransport) {
        IoMarkIrpPending (Irp);
    }

    KeReleaseSpinLock(&m_FrameQueue.SpinLock,oldIrql);

    //
    // Forward the IRP if all frames have cleared the queue.
    //
    if (! IrpForwardable) {
        //
        // There are frames still in the queue.
        //
        if (NextTransport) {
            *NextTransport = NULL;
        }
    } else {
        //
        // Forward or discard the IRP.
        //
        ForwardIrp(Irp,IrpFraming,NextTransport);
    }
}


void
CKsQueue::
ForwardIrp(
    IN PIRP Irp,
    IN PKSPIRP_FRAMING IrpFraming,
    OUT PIKSTRANSPORT* NextTransport OPTIONAL
    )

/*++

Routine Description:

    This routine forwards or discards an IRP.

Arguments:

    Irp -
        Contains a pointer to the IRP to be forwarded.

    IrpFraming -
        Contains a pointer to the framing overly for the IRP.

    NextTransport -
        Contains a pointer to the next transport component to recieve the IRP.
        If this pointer is NULL, and the IRP needs to be forwarded, the IRP
        will be transferred explicitly using KspTransferKsIrp().  If this
        pointer is not NULL, and the IRP needs to be forwarded, the interface
        pointer for the next transport component is deposited at this location.
        If the pointer is not NULL, and the IRP does not need to be forwarded,
        NULL will be deposited at this location.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsQueue::ForwardIrp]"));

    ASSERT(Irp);
    ASSERT(IrpFraming);

#if DBG
    LARGE_INTEGER interval;
    interval.QuadPart = -100000000L;
    KeSetTimer(&m_DbgTimer,interval,&m_DbgDpc);
#endif

    KsLog(&m_Log,KSLOGCODE_QUEUE_SEND,Irp,NULL);

    if (Irp->IoStatus.Status == STATUS_END_OF_MEDIA) {
        //
        // We need to discard the IRP because we hit end-of-stream.
        //
        //
        // INTERIM:  Throw away the framing information.
        //
        while (IrpFraming->FrameHeaders) {
            PKSPFRAME_HEADER frameHeader = IrpFraming->FrameHeaders;
            frameHeader->StreamHeader->DataUsed = 0;
            frameHeader->StreamHeader->OptionsFlags |= 
                KSSTREAM_HEADER_OPTIONSF_ENDOFSTREAM;
            IrpFraming->FrameHeaders = frameHeader->NextFrameHeaderInIrp;
            PutAvailableFrameHeader(frameHeader);
        }
        Irp->IoStatus.Status = STATUS_SUCCESS;
        KspDiscardKsIrp(m_TransportSink,Irp);
        if (NextTransport) {
            *NextTransport = NULL;
        }
    } else {
        NTSTATUS Status = STATUS_SUCCESS;

        //
        // Forward the IRP.  
        //
        // Generate connection events on all pins if there are any relevant 
        // flags in the header.
        //
        // INTERIM:  Throw away the framing information.
        //
        while (IrpFraming->FrameHeaders) {
            PKSPFRAME_HEADER frameHeader = IrpFraming->FrameHeaders;

            //
            // The first error in any frame in the Irp indicates what status
            // the Irp will be completed with.  This behavior is not
            // clearly specified.
            //
            if (NT_SUCCESS (Status) && !NT_SUCCESS (frameHeader->Status)) {
                Status = frameHeader->Status;
            }

            //
            // Check for errors.  If a previous frame in the Irp has indicated
            // an error, ignore the rest of the frames in the Irp.
            //
            if (NT_SUCCESS (Status)) {
    
                //
                // Check for end-of-stream.
                //
                ASSERT(frameHeader);
                ASSERT(frameHeader->StreamHeader);
                ULONG optionsFlags = frameHeader->StreamHeader->OptionsFlags;
                if (optionsFlags & KSSTREAM_HEADER_OPTIONSF_ENDOFSTREAM) {
                    KIRQL oldIrql;
                    KeAcquireSpinLock(&m_FrameQueue.SpinLock,&oldIrql);
                    m_EndOfStream = TRUE;
                    if (! IsListEmpty(&m_FrameQueue.ListEntry)) {
                        optionsFlags &= ~KSSTREAM_HEADER_OPTIONSF_ENDOFSTREAM;
                    }
                    KeReleaseSpinLock(&m_FrameQueue.SpinLock,oldIrql);
                }
    
                //
                // Generate events.
                //
                if (optionsFlags & 
                    (KSSTREAM_HEADER_OPTIONSF_ENDOFSTREAM |
                     KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY | 
                     KSSTREAM_HEADER_OPTIONSF_TIMEDISCONTINUITY)) {
                    m_PipeSection->GenerateConnectionEvents(optionsFlags);
                }
            }
    
            IrpFraming->FrameHeaders = frameHeader->NextFrameHeaderInIrp;
            PutAvailableFrameHeader(frameHeader);
        }

        if (NT_SUCCESS (Status)) {
            Irp->IoStatus.Status = STATUS_SUCCESS;
        } else {
            Irp->IoStatus.Status = Status;
        }

        //
        // Forward the IRP implicitly or explicitly.
        //
        if (NextTransport) {
            *NextTransport = m_TransportSink;
        } else {
            KspTransferKsIrp(m_TransportSink,Irp);
        }

    }
}


void
CKsQueue::
ForwardWaitingIrps(
    void
    )

/*++

Routine Description:

    This routine forwards IRPs waiting to be forwarded.

Arguments:

    None.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsQueue::ForwardWaitingIrps]"));

    while (1) {
        PLIST_ENTRY listEntry = 
            ExInterlockedRemoveHeadList(
                &m_WaitingIrps,
                &m_FrameQueue.SpinLock);
        if (listEntry) {
            PIRP irp = CONTAINING_RECORD(listEntry,IRP,Tail.Overlay.ListEntry);
            ForwardIrp(irp,IRP_FRAMING_IRP_STORAGE(irp),NULL);
        } else {
            break;
        }
    }
}


STDMETHODIMP
CKsQueue::
TransferKsIrp(
    IN PIRP Irp,
    OUT PIKSTRANSPORT* NextTransport
    )

/*++

Routine Description:

    This routine handles the arrival of a streaming IRP via the  
    transport.

Arguments:

    Irp -
        Contains a pointer to the streaming IRP submitted to the queue.

    NextTransport -
        Contains a pointer to a location at which to deposit a pointer
        to the next transport interface to recieve the IRP.  May be set
        to NULL indicating the IRP should not be forwarded further.

Return Value:

    STATUS_PENDING or some error status.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsQueue::TransferKsIrp]"));

    ASSERT(Irp);
    ASSERT(NextTransport);
    ASSERT(m_TransportSink);
    ASSERT(m_TransportSource);

    KsLog(&m_Log,KSLOGCODE_QUEUE_RECV,Irp,NULL);

    //
    // Shunt IRPs to the next object if we are not ready.
    //
    if (InterlockedIncrement (&m_TransportIrpsPlusOne) <= 1 ||
        m_Flushing || 
        (m_State == KSSTATE_STOP) || 
        Irp->Cancel || 
        ! NT_SUCCESS(Irp->IoStatus.Status)) {
#if (DBG)
        if (m_Flushing) {
            _DbgPrintF(DEBUGLVL_FLOWEXCEPTIONS,("#### Queue%p.TransferKsIrp:  shunting IRP %p during flush",this,Irp));
        }
        if (m_State == KSSTATE_STOP) {
            _DbgPrintF(DEBUGLVL_FLOWEXCEPTIONS,("#### Queue%p.TransferKsIrp:  shunting IRP %p in state %d",this,Irp,m_State));
        }
        if (Irp->Cancel) {
            _DbgPrintF(DEBUGLVL_FLOWEXCEPTIONS,("#### Queue%p.TransferKsIrp:  shunting cancelled IRP %p",this,Irp));
        }
        if (! NT_SUCCESS(Irp->IoStatus.Status)) {
            _DbgPrintF(DEBUGLVL_FLOWEXCEPTIONS,("#### Queue%p.TransferKsIrp:  shunting failed IRP %p status 0x%08x",this,Irp,Irp->IoStatus.Status));
        }
#endif
        *NextTransport = m_TransportSink;
        KsLog(&m_Log,KSLOGCODE_QUEUE_SEND,Irp,NULL);

        //
        // We're fine to decrement the count and signal if there's a flush
        // waiting on us.
        //
        if (! InterlockedDecrement (&m_TransportIrpsPlusOne))
            KeSetEvent (&m_FlushEvent, IO_NO_INCREMENT, FALSE);

        return STATUS_SUCCESS;
    }

    NTSTATUS status;

    //
    // If the device is in a state that can't handle I/O, discard the irp
    // with an appropriate error code.  This is done here in addition
    // to the sink pin because it's possible that a pin is bypassed and Irps
    // arrive via this mechanism.
    //
    if (!NT_SUCCESS (status = (m_Device->CheckIoCapability()))) {

        Irp->IoStatus.Status = status;
        IoMarkIrpPending(Irp);
        KspDiscardKsIrp(m_TransportSink,Irp);
        *NextTransport = NULL;
        if (! InterlockedDecrement (&m_TransportIrpsPlusOne))
            KeSetEvent (&m_FlushEvent, IO_NO_INCREMENT, FALSE);

        return STATUS_PENDING;

    }

    //
    // If we saw end-of-stream and this is an input, the stream has
    // resumed, and we need to indicate that.
    //
    if (m_EndOfStream && m_InputData) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("#### Queue%p.TransferKsIrp:  resuming after end-of-stream (IRP %p)",this,Irp));
        m_EndOfStream = FALSE;
    }

    status = STATUS_PENDING;

    //
    // Prepare the IRP using KS's handiest function.  This is only done for
    // queues associated with sinks.
    //
    if (m_ProbeFlags)
    {
        ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

        status = KsProbeStreamIrp(Irp,m_ProbeFlags,0);
        if (! NT_SUCCESS(status)) {
            _DbgPrintF(DEBUGLVL_TERSE,("#### Queue%p.TransferKsIrp:  KsProbeStreamIrp(%p) failed, status=%p, probe=%p",this,Irp,status,m_ProbeFlags));
        }
    }

    //
    // If end-of-stream is indicated, this IRP needs to be sent along with
    // the end-of-stream flag and data used fields set to zero.
    //
    if (NT_SUCCESS(status) && m_EndOfStream) {
        _DbgPrintF(DEBUGLVL_FLOWEXCEPTIONS,("#### Queue%p.TransferKsIrp:  discarding IRP %p on arrival after end-of-stream",this,Irp));
        ZeroIrp(Irp);
        IoMarkIrpPending(Irp);
        KspDiscardKsIrp(m_TransportSink,Irp);
        *NextTransport = NULL;

        if (! InterlockedDecrement (&m_TransportIrpsPlusOne))
            KeSetEvent (&m_FlushEvent, IO_NO_INCREMENT, FALSE);

        return STATUS_PENDING;
    }

    if (NT_SUCCESS(status)) {
        //
        // Initialize the framing overlay on the stack location.  The refcount
        // is initially 1 because the IRP is not cancelable for now.
        //
        PKSPIRP_FRAMING irpFraming = IRP_FRAMING_IRP_STORAGE(Irp);
        irpFraming->RefCount = 1;
        irpFraming->QueuedFrameHeaderCount = 0;
        irpFraming->FrameHeaders = NULL;
        PKSPFRAME_HEADER* endOfList = &irpFraming->FrameHeaders;

        //
        // Get the size of all the stream headers combined.
        //
        ULONG outputBufferLength = irpFraming->OutputBufferLength;
        ASSERT(outputBufferLength);

        //
        // Get a pointer to the first stream header.
        //
        PKSSTREAM_HEADER streamHeader = 
            PKSSTREAM_HEADER(Irp->AssociatedIrp.SystemBuffer);
        ASSERT(streamHeader);

        //
        // Initialize and queue up a frame header for each frame.
        //
        PMDL mdl = Irp->MdlAddress;
        while (outputBufferLength && NT_SUCCESS(status)) {
            ASSERT(outputBufferLength >= sizeof(KSSTREAM_HEADER));
            ASSERT(outputBufferLength >= streamHeader->Size);
            ASSERT(streamHeader->Size >= sizeof(KSSTREAM_HEADER));

            //
            // Allocate and initialize a frame header.
            //
            PKSPFRAME_HEADER frameHeader = GetAvailableFrameHeader(0);
            if (frameHeader) {
                frameHeader->NextFrameHeaderInIrp = NULL;
                frameHeader->Queue = this;
                frameHeader->OriginalIrp = Irp;
                frameHeader->Irp = Irp;
                frameHeader->IrpFraming = irpFraming;
                frameHeader->Mdl = mdl;
                frameHeader->StreamHeader = streamHeader;
                frameHeader->FrameBuffer = 
                    mdl ? MmGetSystemAddressForMdl(mdl) : streamHeader->Data;
                frameHeader->FrameBufferSize = streamHeader->FrameExtent;

                //
                // For consistency's sake with other KS class drivers,
                // the stream header's data pointer will be mapped into
                // system space.
                //
                frameHeader->OriginalData = streamHeader->Data;
                streamHeader->Data = frameHeader->FrameBuffer;

                //
                // Add the frame to the IRP's list.
                //
                *endOfList = frameHeader;
                endOfList = &frameHeader->NextFrameHeaderInIrp;
                irpFraming->QueuedFrameHeaderCount++;
            } else {
                status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            //
            // Next stream header and mdl.
            //
            outputBufferLength -= streamHeader->Size;
            streamHeader = 
                PKSSTREAM_HEADER(PUCHAR(streamHeader) + streamHeader->Size);

            if (mdl) {
                mdl = mdl->Next;
            }
        }

        //
        // If all went well, add the frames to the queue.  The IRP will not
        // get forwarded because we are holding a refcount.
        //
        if (NT_SUCCESS(status)) {
            for (PKSPFRAME_HEADER frameHeader = irpFraming->FrameHeaders;
                frameHeader;
                frameHeader = frameHeader->NextFrameHeaderInIrp) {
                AddFrame(frameHeader);
            }

            //
            // Release our reference to the IRP.
            //
            ReleaseIrp(Irp,irpFraming,NextTransport);

            //
            // STATUS_PENDING is our successful return.
            //
            status = STATUS_PENDING;
        } else {
            //
            // Failed...throw away the frames we managed to allocate.
            //
            while (irpFraming->FrameHeaders) {
                PKSPFRAME_HEADER frameHeader = irpFraming->FrameHeaders;
                irpFraming->FrameHeaders = frameHeader->NextFrameHeaderInIrp;
                PutAvailableFrameHeader(frameHeader);
            }
        }
    } 

    if (! NT_SUCCESS(status)) {
        //
        // Discard if we failed.
        //
        *NextTransport = NULL;
        IoMarkIrpPending(Irp);
        KspDiscardKsIrp(m_TransportSink,Irp);
        status = STATUS_PENDING;
    }

    //
    // If there's a flush waiting to happen, signal it
    //
    if (! InterlockedDecrement (&m_TransportIrpsPlusOne))
        KeSetEvent (&m_FlushEvent, IO_NO_INCREMENT, FALSE);

    return status;
}


STDMETHODIMP_(void)
CKsQueue::
DiscardKsIrp(
    IN PIRP Irp,
    OUT PIKSTRANSPORT* NextTransport
    )

/*++

Routine Description:

    This routine discards a streaming IRP.

Arguments:

    Irp -
        Contains a pointer to the streaming IRP to be discarded.

    NextTransport -
        Contains a pointer to a location at which to deposit a pointer
        to the next transport interface to recieve the IRP.  May be set
        to NULL indicating the IRP should not be forwarded further.

Return Value:

    STATUS_PENDING or some error status.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsQueue::DiscardKsIrp]"));

    ASSERT(Irp);
    ASSERT(NextTransport);
    ASSERT(m_TransportSink);

    *NextTransport = m_TransportSink;
}


void
CKsQueue::
ZeroIrp(
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine processes an IRP received in an end-of-stream condition.
    Specifically, it sets DataUsed to zero and sets the end-of-stream flag
    on all packets.

Arguments:

    Irp -
        The IRP to zero.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsQueue::ZeroIrp]"));

    ASSERT(Irp);

    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

    ULONG outputBufferLength = 
        irpSp->Parameters.DeviceIoControl.OutputBufferLength;

    ASSERT(outputBufferLength);

    //
    // Zero each header.
    //
    PKSSTREAM_HEADER header = PKSSTREAM_HEADER(Irp->AssociatedIrp.SystemBuffer);
    while (outputBufferLength) {
        ASSERT(outputBufferLength >= sizeof(KSSTREAM_HEADER));
        ASSERT(outputBufferLength >= header->Size);
        ASSERT(header->Size >= sizeof(KSSTREAM_HEADER));

        outputBufferLength -= header->Size;

        header->DataUsed = 0;
        header->OptionsFlags |= KSSTREAM_HEADER_OPTIONSF_ENDOFSTREAM;

        header = PKSSTREAM_HEADER(PUCHAR(header) + header->Size);
    }
}


IO_ALLOCATION_ACTION
CKsQueue::
CallbackFromIoAllocateAdapterChannel(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Reserved,
    IN PVOID MapRegisterBase,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine initializes an edge with respect to a new packet.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsQueue::CallbackFromIoAllocateAdapterChannel]"));

    ASSERT(DeviceObject);
    ASSERT(Context);

    PIOALLOCATEADAPTERCHANNELCONTEXT context = 
        PIOALLOCATEADAPTERCHANNELCONTEXT(Context);

    KeAcquireSpinLockAtDpcLevel (&context->Signaller);

    //
    // If the State field is still set, the context is still valid, we can
    // generate mappings.  The caller will free the context information.
    //
    // If it's clear, the context will be freed by us; however, the buffers
    // and mappings are poison.
    //
    if (InterlockedCompareExchange (
        &context->State,
        0,
        1) == 1) {

        PUCHAR virtualAddress = PUCHAR(MmGetMdlVirtualAddress(context->Table->
            Mdl));
        // TODO:  Figure out if we also need system address.
        ULONG bytesRemaining = context->Table->ByteCount;
    
        ULONG mappingsCount = 0;
        PKSMAPPING mapping = context->Table->Mappings;
    
        while (bytesRemaining) {
            ULONG segmentLength = bytesRemaining;
    
            // Create one mapping.
            PHYSICAL_ADDRESS physicalAddress =
                IoMapTransfer(
                    context->Queue->m_AdapterObject,
                    context->Table->Mdl,
                    MapRegisterBase,
                    virtualAddress,
                    &segmentLength,
                    context->Queue->m_WriteOperation
                );
    
            bytesRemaining -= segmentLength;
            virtualAddress += segmentLength;
    
            //
            // Hack it up as required by the hardware and fill in the mapping.
            //
            while (segmentLength) {
                ULONG entryLength = segmentLength;
    
                if (entryLength > context->Queue->m_MaxMappingByteCount) {
                    entryLength = context->Queue->m_MaxMappingByteCount;
                }
    
                ASSERT(entryLength);
                ASSERT(entryLength <= segmentLength);
    
                mapping->PhysicalAddress = physicalAddress;
                mapping->ByteCount = entryLength;
    
                mapping = PKSMAPPING(PUCHAR(mapping) + context->Table->Stride);
                mappingsCount++;
                ASSERT(mappingsCount <= context->Table->MappingsAllocated);
    
                segmentLength -= entryLength;
                physicalAddress.LowPart += entryLength;
            }
        }
    
        context->Table->MappingsFilled = mappingsCount;
        context->Table->MapRegisterBase = MapRegisterBase;
    
        //
        // Flush I/O buffers if this is a write operation.
        //
        if (context->Queue->m_WriteOperation) {
            KeFlushIoBuffers(context->Table->Mdl,TRUE,TRUE);
        }
    
        //
        // Once the event is signalled, context is poison.
        //
        KeReleaseSpinLockFromDpcLevel(&context->Signaller);

    } else {

        KeReleaseSpinLockFromDpcLevel(&context->Signaller);

        //
        // Irp is poison.  Buffers are poison.  Mappings table is poison;
        // trash the map registers.
        //
        ExFreeToNPagedLookasideList (
            &context->Queue->m_ChannelContextLookaside,
            context
            );

        return DeallocateObject;

    }

    return DeallocateObjectKeepRegisters;
}


PKSPMAPPINGS_TABLE
CKsQueue::
CreateMappingsTable(
    IN PKSPFRAME_HEADER FrameHeader
    )

/*++

Routine Description:

    This routine creates a table containing mappings for a frame.

Arguments:

    FrameHeader -
        The frame header for which to create a mappings table.

Return Value:

    The new mappings table or NULL if it could not be created.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsQueue::CreateMappingsTable]"));

    ASSERT(FrameHeader);
    ASSERT(FrameHeader->Mdl);

    ULONG byteCount =
        m_OutputData ? 
            FrameHeader->StreamHeader->FrameExtent : 
            FrameHeader->StreamHeader->DataUsed;

    //
    // Determine how many mappings would be need in the worst case:  one page
    // per mapping.
    //
    ULONG mappingsCount =
        ADDRESS_AND_SIZE_TO_SPAN_PAGES(
            MmGetMdlVirtualAddress(FrameHeader->Mdl),
            byteCount);

    //
    // If the hardware can't handle whole pages, we assume each mapping will
    // will need to be split up PAGE_SIZE/max times, rounded up.
    //
    if (m_MaxMappingByteCount < PAGE_SIZE) {
        mappingsCount *= 
            (PAGE_SIZE + m_MaxMappingByteCount - 1) / m_MaxMappingByteCount;
    }

    ULONG size = sizeof(KSPMAPPINGS_TABLE) + mappingsCount * m_MappingTableStride;

    PKSPMAPPINGS_TABLE mappingsTable = (PKSPMAPPINGS_TABLE)
        ExAllocatePoolWithTag(NonPagedPool,size,POOLTAG_MAPPINGSTABLE);

    PIOALLOCATEADAPTERCHANNELCONTEXT callbackContext =
        (PIOALLOCATEADAPTERCHANNELCONTEXT)
        ExAllocateFromNPagedLookasideList (&m_ChannelContextLookaside);

    if (mappingsTable && callbackContext) {
        RtlZeroMemory(mappingsTable,size);

        mappingsTable->ByteCount = byteCount;
        mappingsTable->Stride = m_MappingTableStride;
        mappingsTable->MappingsAllocated = mappingsCount;
        mappingsTable->Mdl = FrameHeader->Mdl;
        mappingsTable->Mappings = (PKSMAPPING)(mappingsTable + 1);

        //
        // Set up the callback context for IoAllocateAdapterChannel.
        //
        callbackContext->Table = mappingsTable;
        callbackContext->Queue = this;
        callbackContext->State = 1;
        KeInitializeSpinLock(&callbackContext->Signaller);

        NTSTATUS status;

        //
        // Have the device arbitrate channel allocation (call at 
        // DISPATCH_LEVEL)
        //
        // BUGBUG: MUSTFIX:
        //
        // This is not a trivial problem right now.  Callers of
        // LockStreamPointer (KsStreamPointerLock, KsGet*EdgeStreamPointer)
        // expect mappings to be generated before AVStream returns from
        // this function.  The original design missed one critical issue:
        // thou can't wait at DISPATCH_LEVEL; unfortunately, it did.  If
        // the callback from IoAllocateAdapterChannel is **NOT** made
        // synchronously, we're in trouble. 
        //
        // In normal use right now (x86 non PAE) with scatter/gather 
        // busmaster hardware (we only support busmaster), this will return
        // synchronously (which is why no issues have been identified outside
        // of driver verifier).  On x86 PAE, Win64 >4gb of ram, or non-
        // scatter/gather hardware, it's possible that there aren't enough
        // map registers to allocate the adapter channel and the callback
        // isn't made synchronously.  In these cases, the original code would
        // completely deadlock the OS at DISPATCH_LEVEL.  Unfortunately,
        // there is not enough time to rearchitect this for release.
        // In order to get driver verifier to stop complaining and prevent
        // a blue screen in this circumstance, the lock fails if it cannot
        // be serviced synchronously (or very close to synchronously on
        // multiproc).  This is **NOT** a permanent fix.  The minidriver
        // must be aware that the locks can fail (they could before, but
        // not very often...  This makes it much more likely in certain
        // classes of DMA).
        //
        // It's also possible that if the minidriver isn't aware of the 
        // possibility of failure of the lock operation that the minidriver 
        // itself crashes.
        //
        KIRQL oldIrql;
        KeRaiseIrql(DISPATCH_LEVEL,&oldIrql);

        status =
            m_Device -> ArbitrateAdapterChannel (
                mappingsTable->MappingsAllocated,
                CallbackFromIoAllocateAdapterChannel,
                PVOID(callbackContext)
                );
    
        if (NT_SUCCESS (status)) {
            //
            // Is the callback being performed/has been performed?  If the State
            // field is clear, the callback cleared it.  This means that we're
            // responsible for freeing the context, but we must ensure that
            // the routine is complete and not merely executing.  Note that
            // on single-proc, if State is clear the routine is complete.  On
            // multi-proc, it only ensures that it's currently running on 
            // another proc (or it could indicate that it's complete).
            //
            if (InterlockedCompareExchange (
                &callbackContext->State,
                0,
                1) == 0) {

                //
                // This should nop on a single-proc and will be a 
                // DISPATCH_LEVEL event wait on multi-proc.  Note that this
                // is guaranteed to happen "soon" since we are guaranteed there
                // is a thread inside the callback right now.
                //
                KeAcquireSpinLockAtDpcLevel (&callbackContext->Signaller);
                KeReleaseSpinLockFromDpcLevel (&callbackContext->Signaller);

                //
                // If we got the spinlock, it means that the mappings are
                // completed.  We release the spinlock and destroy the context
                // information.
                //
                ExFreeToNPagedLookasideList (
                    &m_ChannelContextLookaside,
                    callbackContext
                    );

            } else {
                //
                // TODO:
                //
                // If we return non-synchronously, the Irp is cancelled.  This
                // is the incorrect behavior; fixing this is a work item.
                //
                // In this case, the callback when it does happen is
                // responsible for freeing the context information.
                //
                status = STATUS_DEVICE_BUSY;
            }
        } else {
            //
            // If this failed, currently there will be no callback.  Thus,
            // free the context.  We don't want to free in generic !success
            // because on non-synchronous return, we device busy the request
            // and the callback frees the context.
            //
            ExFreeToNPagedLookasideList (
                &m_ChannelContextLookaside,
                callbackContext
                );
        }

        KeLowerIrql(oldIrql);

        //
        // Delete the mappings on failure to allocate the
        // adapter channel. This does not allow for partial
        // mappings.
        //
        if (!NT_SUCCESS(status)) {
            DeleteMappingsTable(mappingsTable);
            mappingsTable = NULL;
        }

    } else {
        if (mappingsTable) {
            ExFreePool (mappingsTable);
            mappingsTable = NULL;
        }
        if (callbackContext) {
            ExFreeToNPagedLookasideList (
                &m_ChannelContextLookaside,
                callbackContext
                );
            callbackContext = NULL;
        }
    }

    return mappingsTable;
}


void
CKsQueue::
DeleteMappingsTable(
    IN PKSPMAPPINGS_TABLE MappingsTable
    )

/*++

Routine Description:

    This routine deletes a mappings table.

Arguments:

    MappingsTable -
        Contains a pointer to the mappings table to be deleted.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsQueue::DeleteMappingsTable]"));

    ASSERT(MappingsTable);

    //
    // Free the mappings if the table is filled.
    //
    if (MappingsTable->MappingsFilled) {
        FreeMappings(MappingsTable);
    }

    //
    // Free the table.
    //
    ExFreePool(MappingsTable);
}


void
CKsQueue::
FreeMappings(
    IN PKSPMAPPINGS_TABLE MappingsTable
    )

/*++

Routine Description:

    This routine frees map registers.

Arguments:

    MappingsTable -
        The table containing the mappings to be freed.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsQueue::FreeMappings]"));

    ASSERT(MappingsTable);

#ifndef USE_DMA_MACROS
    IoFlushAdapterBuffers(
        m_AdapterObject,
        MappingsTable->Mdl,
        MappingsTable->MapRegisterBase,
        MmGetMdlVirtualAddress(MappingsTable->Mdl),
        MappingsTable->ByteCount,
        m_WriteOperation
    );

    IoFreeMapRegisters(
        m_AdapterObject,
        MappingsTable->MapRegisterBase,
        MappingsTable->MappingsAllocated
    );
#else
    (*((PDMA_ADAPTER)m_AdapterObject)->DmaOperations->PutScatterGatherList)(
        (PDMA_ADAPTER)m_AdapterObject,
        (PSCATTER_GATHER_LIST)MappingsTable->MapRegisterBase,
        m_WriteOperation
    );
    
#endif // USE_DMA_MACROS

    MappingsTable->MappingsFilled = 0;
}

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA


STDMETHODIMP_(void)
CKsQueue::
Connect(
    IN PIKSTRANSPORT NewTransport OPTIONAL,
    OUT PIKSTRANSPORT *OldTransport OPTIONAL,
    OUT PIKSTRANSPORT *BranchTransport OPTIONAL,
    IN KSPIN_DATAFLOW DataFlow
    )

/*++

Routine Description:

    This routine establishes a  transport connect.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsQueue::Connect]"));

    PAGED_CODE();

    KspStandardConnect(
        NewTransport,
        OldTransport,
        BranchTransport,
        DataFlow,
        PIKSTRANSPORT(this),
        &m_TransportSource,
        &m_TransportSink);
}


STDMETHODIMP
CKsQueue::
SetDeviceState(
    IN KSSTATE NewState,
    IN KSSTATE OldState,
    OUT PIKSTRANSPORT* NextTransport
    )

/*++

Routine Description:

    This routine handles notification that the device state has changed.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsQueue::SetDeviceState(0x%08x)]",this));
    _DbgPrintF(DEBUGLVL_DEVICESTATE,("#### Queue%p.SetDeviceState:  set from %d to %d",this,OldState,NewState));

    PAGED_CODE();

    ASSERT(NextTransport);

    if (m_State != NewState) {
        NTSTATUS status = 
            m_PipeSection->DistributeStateChangeToPins(NewState,OldState);
        if (! NT_SUCCESS(status)) {
            return status;
        }

        //
        // On the transition from stop to acquire, frame availability may
        // become relevant to processing control.  This check is done before
        // m_State is set so we know there is no data in the queue.  We are,
        // in effect, adding an 'off' input pin to m_FrameGate, if it exists.
        //
        if (OldState == KSSTATE_STOP && m_FrameGate != NULL) {
            if (m_FrameGateIsOr) {
                KsGateAddOffInputToOr(m_FrameGate);
            } else {
                KsGateAddOffInputToAnd(m_FrameGate);
            }
            _DbgPrintF(DEBUGLVL_PROCESSINGCONTROL,("#### Queue%p.SetDeviceState:  add%p-->%d",this,m_FrameGate,m_FrameGate->Count));
        }

        m_State = NewState;

        if (NewState > OldState) {
            *NextTransport = m_TransportSink;
            if (NewState == KSSTATE_PAUSE) {
                m_EndOfStream = FALSE;
            }
            if (m_StateGate && NewState == KSSTATE_RUN) {
                KsGateTurnInputOn(m_StateGate);
                if (KsGateCaptureThreshold(m_AndGate)) {
                    //
                    // Processing needs to be initiated.  
                    //
                    m_ProcessingObject->Process(m_ProcessAsynchronously);
                }
            }
            if (NewState == m_MinProcessingState) {
                KIRQL oldIrql;
                SetTimer(GetTime(TRUE));
                KsGateTurnInputOn(m_AndGate);
                _DbgPrintF(DEBUGLVL_PROCESSINGCONTROL,("#### Queue%p.SetDeviceState:  on%p-->%d",this,m_AndGate,m_AndGate->Count));
                ASSERT(m_AndGate->Count <= 1);
                if (KsGateCaptureThreshold(m_AndGate)) {
                    //
                    // Processing needs to be initiated.  Process locally or at the
                    // filter level.
                    //
                    m_ProcessingObject->Process(m_ProcessAsynchronously);
                }
#if DBG
                LARGE_INTEGER interval;
                interval.QuadPart = -100000000L;
                KeSetTimer(&m_DbgTimer,interval,&m_DbgDpc);
#endif
            }
        } else {
            *NextTransport = m_TransportSource;
            if (m_StateGate && OldState == KSSTATE_RUN) {
                KsGateTurnInputOff(m_StateGate);
            }
            if (OldState == m_MinProcessingState) {
                KIRQL oldIrql;
                SetTimer(GetTime(FALSE));
                KsGateTurnInputOff(m_AndGate);
                _DbgPrintF(DEBUGLVL_PROCESSINGCONTROL,("#### Queue%p.SetDeviceState:  off%p-->%d",this,m_AndGate,m_AndGate->Count));
            } 
            if (NewState == KSSTATE_STOP) {

                //
                // Make sure there's no IRPs running around while we flush.
                // This can happen from a preemption of an arrival thread
                // with the stop thread.
                //
                if (InterlockedDecrement (&m_TransportIrpsPlusOne)) 
                    KeWaitForSingleObject (
                        &m_FlushEvent,
                        Suspended,
                        KernelMode,
                        FALSE,
                        NULL
                        );
                    
                //
                // Flush the queues.
                //
                Flush();

                //
                // At this point in time, it really doesn't matter.  The
                // queue has been flushed and our state is stop.  Any irps
                // arriving will get shunted.
                //
                InterlockedIncrement (&m_TransportIrpsPlusOne);

                //
                // Queue IRP arrival is no longer an issue for processing.
                // Because we have flushed, the inputs to the two gates are
                // off.  We want to disconnect those inputs.
                //
                if (m_FrameGate) {
                    if (m_FrameGateIsOr) {
                        KsGateRemoveOffInputFromOr(m_FrameGate);
                    } else {
                        KsGateRemoveOffInputFromAnd(m_FrameGate);
                    }
                    _DbgPrintF(DEBUGLVL_PROCESSINGCONTROL,("#### Queue%p.SetDeviceState:  remove%p-->%d",this,m_FrameGate,m_FrameGate->Count));
#if DBG                    
                    if (m_FrameGateIsOr) {
                        ASSERT(m_FrameGate->Count >= 0);
                    } else {
                        ASSERT(m_FrameGate->Count <= 1);
                    }
#endif // DBG
                }

                if (InterlockedDecrement(&m_StreamPointersPlusOne)) {
                    _DbgPrintF(DEBUGLVL_TERSE,("#### CKsQueue%p.SetDeviceState:  waiting for %d stream pointers to be deleted",this,m_StreamPointersPlusOne));
#if DBG
                    DbgPrintQueue();
#endif
                    KeWaitForSingleObject(
                        &m_DestructEvent,
                        Suspended,
                        KernelMode,
                        FALSE,
                        NULL);
                    _DbgPrintF(DEBUGLVL_TERSE,("#### CKsQueue%p.SetDeviceState:  done waiting",this));
                }
            }
        }
    } else {
        *NextTransport = NULL;
    }

    return STATUS_SUCCESS;
}


STDMETHODIMP_(void)
CKsQueue::
GetTransportConfig(
    OUT PKSPTRANSPORTCONFIG Config,
    OUT PIKSTRANSPORT* NextTransport,
    OUT PIKSTRANSPORT* PrevTransport
    )

/*++

Routine Description:

    This routine gets transport configuration information.

Arguments:

    Config -
        Contains a pointer to the location where configuration requirements
        for this object should be deposited.

    NextTransport -
        Contains a pointer to the location at which the next transport
        interface should be deposited.

    PrevTransport -
        Contains a pointer to the location at which the previous transport
        interfaction should be deposited.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsQueue::GetTransportConfig]"));

    PAGED_CODE();

    ASSERT(Config);
    ASSERT(NextTransport);
    ASSERT(PrevTransport);

    Config->TransportType = KSPTRANSPORTTYPE_QUEUE;
    if (m_GenerateMappings) {
        Config->IrpDisposition = KSPIRPDISPOSITION_NEEDMDLS;
    } else if (m_ProcessPassive) {
        Config->IrpDisposition = KSPIRPDISPOSITION_NONE;
    } else {
        Config->IrpDisposition = KSPIRPDISPOSITION_NEEDNONPAGED;
    }
    Config->StackDepth = 1;

    *NextTransport = m_TransportSink;
    *PrevTransport = m_TransportSource;
}


STDMETHODIMP_(void)
CKsQueue::
SetTransportConfig(
    IN const KSPTRANSPORTCONFIG* Config,
    OUT PIKSTRANSPORT* NextTransport,
    OUT PIKSTRANSPORT* PrevTransport
    )

/*++

Routine Description:

    This routine sets transport configuration information.

Arguments:

    Config -
        Contains a pointer to the new configuration settings for this object.

    NextTransport -
        Contains a pointer to the location at which the next transport
        interface should be deposited.

    PrevTransport -
        Contains a pointer to the location at which the previous transport
        interfaction should be deposited.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsQueue::SetTransportConfig]"));

    PAGED_CODE();

    ASSERT(Config);
    ASSERT(NextTransport);
    ASSERT(PrevTransport);

#if DBG
    if (Config->IrpDisposition == KSPIRPDISPOSITION_ROLLCALL) {
        ULONG references = AddRef() - 1; Release();
        DbgPrint("    Queue%p r/w/c=%d/%d/%d refs=%d\n",this,m_FramesReceived,m_FramesWaiting,m_FramesCancelled,references);
        if (Config->StackDepth) {
            DbgPrintQueue();
        }
    } else 
#endif
    {
        if (m_PipeSection) {
            m_PipeSection->ConfigurationSet(TRUE);
        }
        m_ProbeFlags = Config->IrpDisposition & KSPIRPDISPOSITION_PROBEFLAGMASK;
        m_CancelOnFlush = (Config->IrpDisposition & KSPIRPDISPOSITION_CANCEL) != 0;
        m_UseMdls = (Config->IrpDisposition & KSPIRPDISPOSITION_USEMDLADDRESS) != 0;
        _DbgPrintF(DEBUGLVL_VERBOSE,("#### Queue%p.SetTransportConfig:  m_ProbeFlags=%p m_CancelOnFlush=%s m_UseMdls=%s",this,m_ProbeFlags,m_CancelOnFlush ? "TRUE" : "FALSE",m_UseMdls ? "TRUE" : "FALSE"));
    }

    *NextTransport = m_TransportSink;
    *PrevTransport = m_TransportSource;
}


STDMETHODIMP_(void)
CKsQueue::
ResetTransportConfig (
    OUT PIKSTRANSPORT* NextTransport,
    OUT PIKSTRANSPORT* PrevTransport
    )

/*++

Routine Description:

    Reset the transport configuration of the queue.  This indicates that
    something is wrong with the pipe and the previously set configuration is
    no longer valid.

Arguments:

    NextTransport -
        Contains a pointer to the location at which the next transport
        interface should be depobranchd.

    PrevTransport -
        Contains a pointer to the location at which the previous transport
        interfaction should be depobranchd.

Return Value:

    None

--*/

{

    _DbgPrintF(DEBUGLVL_BLAB,("[CKsQueue::ResetTransportConfig]"));

    PAGED_CODE();

    ASSERT (NextTransport);
    ASSERT (PrevTransport);

    if (m_PipeSection) {
        m_PipeSection->ConfigurationSet(FALSE);
    }
    m_ProbeFlags = 0;
    m_CancelOnFlush = m_UseMdls = FALSE;

    *NextTransport = m_TransportSink;
    *PrevTransport = m_TransportSource;

}


STDMETHODIMP_(void)
CKsQueue::
SetResetState(
    IN KSRESET ksReset,
    OUT PIKSTRANSPORT* NextTransport
    )

/*++

Routine Description:

    This routine handles notification that the reset state has changed.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsQueue::SetResetState]"));

    PAGED_CODE();

    ASSERT(NextTransport);

    //
    // Take no action if we were already in this state.
    //
    if (m_Flushing != (ksReset == KSRESET_BEGIN)) {
        //
        // Tell the caller to forward the state change to our sink.
        //
        *NextTransport = m_TransportSink;

        //
        // Set our local copy of the state.
        //
        m_Flushing = (ksReset == KSRESET_BEGIN);

        //
        // Flush the queues if we are beginning a reset.
        //
        if (m_Flushing) {
            Flush();
        }

        //
        // If we've hit end of stream, we need to clear this.  Input queues
        // will continue to handle this in TransferKsIrp as they have.
        //
        if (m_OutputData && !m_InputData) {
            m_EndOfStream = FALSE;
        }

    } else {
        *NextTransport = NULL;
    }
}

#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif // ALLOC_PRAGMA


void
CKsQueue::
PassiveFlush(
    void
    )

/*++

Routine Description:

    This routine performs processing relating to the transition to the 'begin'
    reset state and to the transition from acquire to stop state.  In
    particular, it flushes the IRP queues.

    This performs the work of CKsQueue::Flush at passive level since the
    resets are designed to happen at PASSIVE_LEVEL.

    Note that this code cannot be pageable because it spinlocks.

--*/

{

    _DbgPrintF(DEBUGLVL_BLAB,("[CKsQueue::PassiveFlush]"));

    //
    // If we're streaming without an explicit stop and are relying upon EOS
    // notifications, we must wait for irefs to be deleted before we flush
    // the queue.  Otherwise, destinations will never get EOS notification
    //
    if (m_EndOfStream && m_State != KSSTATE_STOP) {
	LONG IRefCount;

        if (IRefCount = (InterlockedDecrement (
            &m_InternalReferenceCountPlusOne))) {

            //
            // Check for multiflush conditions.  This shouldn't happen now with
            // the flush motion, but I'm asserting it.
            //
            ASSERT (IRefCount > 0);

            KeWaitForSingleObject (
                &m_InternalReferenceEvent,
                Suspended,
                KernelMode,
                FALSE,
                NULL
                );
        }	

        //
        // If we dec'd this to wait for iref deletion, fix the counter.
        //
        InterlockedIncrement (&m_InternalReferenceCountPlusOne);
    
    }

    //
    // Reset the processing object.  This will happen at PASSIVE_LEVEL
    // now since this routine runs at PASSIVE_LEVEL.
    //
    m_ProcessingObject->Reset();

    //
    // Terminate the current packet with a flush motion.  Flush motion is 
    // the same as regular motion, but it doesn't reflush.
    //
    if (LockStreamPointer(m_Leading)) {
        UnlockStreamPointer(m_Leading,KSPSTREAM_POINTER_MOTION_FLUSH);
    }

    if (m_CancelOnFlush) {
        //
        // Sink mode:  cancel queued IRPs.
        //
        CancelAllIrps();
    } else {
        //
        // Take the queue spin lock.
        //
        NTSTATUS status = STATUS_SUCCESS;
        KIRQL oldIrql;
        KeAcquireSpinLock(&m_FrameQueue.SpinLock,&oldIrql);

        //
        // Move the leading edge past all frames.
        //
        ASSERT(m_Leading->State == KSSTREAM_POINTER_STATE_UNLOCKED);
        while (m_Leading->FrameHeader) {
            if (m_Leading->FrameHeader->IrpFraming->FrameHeaders == 
                m_Leading->FrameHeader) {
                status = STATUS_END_OF_MEDIA;
            }
            m_Leading->FrameHeader->Irp->IoStatus.Status = status;
            if (m_OutputData) {
                m_Leading->FrameHeader->StreamHeader->DataUsed = 0;
                m_Leading->FrameHeader->StreamHeader->OptionsFlags |= 
                    KSSTREAM_HEADER_OPTIONSF_ENDOFSTREAM;
            }
            SetStreamPointer(
                m_Leading,
                NextFrameHeader(m_Leading->FrameHeader),
                NULL);
        }

        //
        // Move the trailing edge past all frames.
        //
        if (m_Trailing) {
            ASSERT(m_Trailing->State == KSSTREAM_POINTER_STATE_UNLOCKED);
            while (m_Trailing->FrameHeader) {
                SetStreamPointer(
                    m_Trailing,
                    NextFrameHeader(m_Trailing->FrameHeader),
                    NULL);
            }
        }

        //
        // Release the queue spin lock.
        //
        KeReleaseSpinLock(&m_FrameQueue.SpinLock,oldIrql);

        //
        // Forward all IRPs that were queued up for forwarding by 
        // SetStreamPointer.
        //
        ForwardWaitingIrps();
    }

    KIRQL oldIrql;

    //
    // Since we're flushing, we release any references that we're currently
    // holding on frames in other queues.  Given that this is a flush, do
    // we really need to worry about copying it?  Don't think so...
    //
    KeAcquireSpinLock(&m_FrameCopyList.SpinLock,&oldIrql);
    if (!IsListEmpty (&m_FrameCopyList.ListEntry)) {
        PLIST_ENTRY ListEntry, NextEntry;

        NextEntry = NULL;
        ListEntry = m_FrameCopyList.ListEntry.Flink;
        while (ListEntry != &(m_FrameCopyList.ListEntry)) {

            NextEntry = ListEntry -> Flink;

            PKSPSTREAM_POINTER_COPY_CONTEXT CopyContext =
                (PKSPSTREAM_POINTER_COPY_CONTEXT)CONTAINING_RECORD (
                    ListEntry, KSPSTREAM_POINTER_COPY_CONTEXT, ListEntry);

            PKSPSTREAM_POINTER StreamPointer = 
                &(((PKSPSTREAM_POINTER_COPY)CONTAINING_RECORD (
                    CopyContext, KSPSTREAM_POINTER_COPY, CopyContext))->
                        StreamPointer);

            RemoveEntryList (&CopyContext->ListEntry);
            StreamPointer->Queue->DeleteStreamPointer (StreamPointer);
            
            ListEntry = NextEntry;
        }
    }
    KeReleaseSpinLock(&m_FrameCopyList.SpinLock,oldIrql);

    //
    // Processing should now be held off due to lack of data, so we can undo
    // the prevention.
    //
    KsGateRemoveOffInputFromAnd(m_AndGate);
    _DbgPrintF(DEBUGLVL_PROCESSINGCONTROL,("#### Queue%p.Flush:  remove%p-->%d",this,m_AndGate,m_AndGate->Count));
    ASSERT(m_AndGate->Count <= 1);

    //
    // Zero the frame counts.
    //
    _DbgPrintF(DEBUGLVL_VERBOSE,("#### Queue%p.Flush:  frames received=%d, cancelled=%d",this,m_FramesReceived,m_FramesCancelled));
    m_FramesReceived = 0;
    m_FramesCancelled = 0;

    //
    // Attempt processing again since something could have happened while
    // we held down the gate.
    //
    if (KsGateCaptureThreshold (m_AndGate)) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("#### Queue%p.PassiveFlush: Processing after queue flush", this));
        m_ProcessingObject -> Process (m_ProcessAsynchronously);
    }

}


void
CKsQueue::
Flush(
    void
    )

/*++

Routine Description:

    This routine performs processing relating to the transition to the 'begin'
    reset state and to the transition from acquire to stop state.  In
    particular, it flushes the IRP queues.

Arguments:

    None.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsQueue::Flush(0x%08x)]",this));

    //
    // The flush can happen at DISPATCH_LEVEL if the minidriver is processing
    // at DISPATCH_LEVEL.  The problem is that we want the reset to happen
    // at PASSIVE_LEVEL.  We can't completely defer the flush or else the
    // minidriver might set EOS on an output frame, return, and get called
    // back.
    //
    // We also can't simply wait at DPC.  Thus, place a hold on the gate
    // and queue a work item to perform the flush.
    //

    //
    // Make sure processing is not initiated because of data we intend to
    // throw away anyway.
    //
    KsGateAddOffInputToAnd(m_AndGate);
    _DbgPrintF(DEBUGLVL_PROCESSINGCONTROL,("#### Queue%p.Flush:  add%p-->%d",this,m_AndGate,m_AndGate->Count));

    //
    // If we're not at passive level, defer the actual flush with a work item.
    //
    if (KeGetCurrentIrql() != PASSIVE_LEVEL)
        KsIncrementCountedWorker (m_FlushWorker);
    else
        PassiveFlush();

}


STDMETHODIMP_(PKSPSTREAM_POINTER)
CKsQueue::
GetLeadingStreamPointer(
    IN KSSTREAM_POINTER_STATE State
    )

/*++

Routine Description:

    This routine gets the leading edge stream pointer of a queue.

Arguments:

    State -
        Cointains an indication of whether the stream pointer should be
        locked by this function.

Return Value:

    The leading edge stream pointer.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsQueue::GetLeadingStreamPointer]"));

    ASSERT(m_Leading);

    if ((State == KSSTREAM_POINTER_STATE_LOCKED) && 
        ! LockStreamPointer(m_Leading)) {
        return NULL;
    }

    return m_Leading;
}


STDMETHODIMP_(PKSPSTREAM_POINTER)
CKsQueue::
GetTrailingStreamPointer(
    IN KSSTREAM_POINTER_STATE State
    )

/*++

Routine Description:

    This routine gets the trailing edge stream pointer of a queue.

Arguments:

    State -
        Cointains an indication of whether the stream pointer should be
        locked by this function.

Return Value:

    The trailing edge stream pointer.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsQueue::GetTrailingStreamPointer]"));

    ASSERT(m_Trailing);

    if ((State == KSSTREAM_POINTER_STATE_LOCKED) && 
        ! LockStreamPointer(m_Trailing)) {
        return NULL;
    }

    return m_Trailing;
}

STDMETHODIMP_(void)
CKsQueue::
UpdateByteAvailability(
    IN PKSPSTREAM_POINTER streamPointer,
    IN ULONG InUsed,
    IN ULONG OutUsed
) 

/*++

Routine Description:

    This routine is called when stream pointer offsets are advanced in order
    to update the byte availability counts.

Arguments:

    streamPointer -
        The stream pointer being advanced

    InUsed -
        Number of bytes of input data used

    OutUsed -
        Number of bytes of output data used

Return Value:

    None

--*/

{

    _DbgPrintF(DEBUGLVL_BLAB,("[CKsQueue::UpdateByteAvailability]"));

    ASSERT(streamPointer);

    if (streamPointer == m_Leading) {
        if (m_InputData && InUsed != 0)
            while (1) {
                LONG curCount = m_AvailableInputByteCount;
                LONG repCount = 
                    InterlockedCompareExchange (
                        &m_AvailableInputByteCount,
                        curCount - InUsed,
                        curCount
                    );
                if (curCount == repCount) break;
            };
        if (m_OutputData && OutUsed != 0)
            while (1) {
                LONG curCount = m_AvailableOutputByteCount;
                LONG repCount =
                    InterlockedCompareExchange (
                        &m_AvailableOutputByteCount,
                        curCount - OutUsed,
                        curCount
                    );
                if (curCount == repCount) break;
            };
    }
}

STDMETHODIMP_(void)
CKsQueue::
GetAvailableByteCount(
    OUT PLONG InputDataBytes OPTIONAL,
    OUT PLONG OutputBufferBytes OPTIONAL
    )

/*++

Routine Description:

    This routine gets the statistics about the number of bytes of input
    data ahead of the leading edge and the number of bytes of output
    buffer ahead of the leading edge.

Arguments:

    InputDataBytes -
        The number of input data bytes ahead of the leading edge will be
        dropped here if the pointer is non-NULL.

    OutputDataBytes -
        The number of output buffer bytes ahead of the leading edge will be
        dropped here if the pointer is non-NULL.

Return Value:

    None

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsQueue::GetAvailableByteCount]"));

    if (InputDataBytes) 
        if (m_InputData) 
            *InputDataBytes = m_AvailableInputByteCount;
        else
            *InputDataBytes = 0;

    if (OutputBufferBytes)
        if (m_OutputData)
            *OutputBufferBytes = m_AvailableOutputByteCount;
        else
            *OutputBufferBytes = 0;

}


KSDDKAPI
NTSTATUS
NTAPI
KsPinGetAvailableByteCount(
    IN PKSPIN Pin,
    OUT PLONG InputDataBytes OPTIONAL,
    OUT PLONG OutputBufferBytes OPTIONAL
) 

/*++

Routine Description:

    This routine gets the statistics about the number of bytes of input
    data ahead of the leading edge and the number of bytes of output
    buffer ahead of the leading edge.

Arguments:

    InputDataBytes -
        The number of input data bytes ahead of the leading edge will be
        dropped here if the pointer is non-NULL.

    OutputDataBytes -
        The number of output buffer bytes ahead of the leading edge will be
        dropped here if the pointer is non-NULL.

Return Value:

    Success / failure of retrieval.  A non-successful status indicates that
    the pin does not have an associated queue.


-*/

{

    _DbgPrintF(DEBUGLVL_BLAB,("[KsPinGetLeadingEdgeStreamPointer]"));

    ASSERT(Pin);

    PKSPPROCESSPIPESECTION pipeSection =
        CONTAINING_RECORD(Pin,KSPIN_EXT,Public)->ProcessPin->PipeSection;

    NTSTATUS status = STATUS_SUCCESS;

    if (pipeSection && pipeSection->Queue) {
        pipeSection->Queue->GetAvailableByteCount( 
            InputDataBytes, OutputBufferBytes);
    } else 
        status = STATUS_UNSUCCESSFUL;

    return status;

}


KSDDKAPI
PKSSTREAM_POINTER
NTAPI
KsPinGetLeadingEdgeStreamPointer(
    IN PKSPIN Pin,
    IN KSSTREAM_POINTER_STATE State
    )

/*++

Routine Description:

    This routine gets the leading edge stream pointer.

Arguments:

    Pin -
        Contains a pointer to the KS pin.

    State -
        Cointains an indication of whether the stream pointer should be
        locked by this function.

Return Value:

    The requested stream pointer or NULL if no frame was referenced by the
    stream pointer.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsPinGetLeadingEdgeStreamPointer]"));

    ASSERT(Pin);

    PKSPPROCESSPIPESECTION pipeSection =
        CONTAINING_RECORD(Pin,KSPIN_EXT,Public)->ProcessPin->PipeSection;

    PKSPSTREAM_POINTER result;

    if (pipeSection && pipeSection->Queue) {
#if DBG
        if (State > KSSTREAM_POINTER_STATE_LOCKED) {
            pipeSection->Queue->DbgPrintQueue();
        }
#endif
        result = pipeSection->Queue->GetLeadingStreamPointer(State);
    } else {
        result = NULL;
    }

    return result ? &result->Public : NULL;
}


KSDDKAPI
PKSSTREAM_POINTER
NTAPI
KsPinGetTrailingEdgeStreamPointer(
    IN PKSPIN Pin,
    IN KSSTREAM_POINTER_STATE State
    )

/*++

Routine Description:

    This routine gets the trailing edge stream pointer.

Arguments:

    Pin -
        Contains a pointer to the KS pin.

    State -
        Cointains an indication of whether the stream pointer should be
        locked by this function.

Return Value:

    The requested stream pointer or NULL if no frame was referenced by the
    stream pointer.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsPinGetTrailingEdgeStreamPointer]"));

    ASSERT(Pin);

    PKSPPROCESSPIPESECTION pipeSection =
        CONTAINING_RECORD(Pin,KSPIN_EXT,Public)->ProcessPin->PipeSection;

    PKSPSTREAM_POINTER result;

    if (pipeSection && pipeSection->Queue) {
        result = pipeSection->Queue->GetTrailingStreamPointer(State);
    } else {
        result = NULL;
    }

    return result ? &result->Public : NULL;
}


KSDDKAPI
NTSTATUS
NTAPI
KsStreamPointerSetStatusCode(
    IN PKSSTREAM_POINTER StreamPointer,
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This routine sets the status code on the frame a stream pointer points
    to. 

Arguments:

    StreamPointer -
        Contains a pointer to the stream pointer to set status code for

    Status -
        The status code to set

Return Value:

    Success / Failure

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsStreamPointerSetStatusCode]"));

    NTSTATUS status = STATUS_SUCCESS;

    PKSPSTREAM_POINTER streamPointer =
        CONTAINING_RECORD(StreamPointer,KSPSTREAM_POINTER,Public);

    if (streamPointer->Queue) {
        streamPointer->Queue->SetStreamPointerStatusCode (streamPointer, 
            Status);
    } else {
        status = STATUS_CANCELLED;
    }

    return Status;

}


KSDDKAPI
NTSTATUS
NTAPI
KsStreamPointerLock(
    IN PKSSTREAM_POINTER StreamPointer
    )

/*++

Routine Description:

    This routine locks a stream pointer.

Arguments:

    StreamPointer -
        Contains a pointer to the stream pointer to be locked.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsStreamPointerLock]"));

    ASSERT(StreamPointer);

    PKSPSTREAM_POINTER streamPointer =
        CONTAINING_RECORD(StreamPointer,KSPSTREAM_POINTER,Public);

    ASSERT(streamPointer->State != KSPSTREAM_POINTER_STATE_LOCKED);
    if (streamPointer->State != KSPSTREAM_POINTER_STATE_UNLOCKED) {
        return STATUS_DEVICE_NOT_READY;
    }

    NTSTATUS status;
    if (streamPointer->Queue) {
        if (streamPointer->Queue->LockStreamPointer(streamPointer)) {
            status = STATUS_SUCCESS;
        } else {
            status = STATUS_DEVICE_NOT_READY;
        }
    } else {
        status = STATUS_CANCELLED;
    }
    // TODO status codes OK?

    return status;
}


KSDDKAPI
void
NTAPI
KsStreamPointerUnlock(
    IN PKSSTREAM_POINTER StreamPointer,
    IN BOOLEAN Eject
    )

/*++

Routine Description:

    This routine unlocks a stream pointer.

Arguments:

    StreamPointer -
        Contains a pointer to the stream pointer to be unlocked.

    Eject -
        Contains an indication of whether the stream pointer should be
        advanced to the next frame.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsStreamPointerUnlock]"));

    ASSERT(StreamPointer);

    PKSPSTREAM_POINTER streamPointer =
        CONTAINING_RECORD(StreamPointer,KSPSTREAM_POINTER,Public);

    ASSERT(streamPointer->State != KSPSTREAM_POINTER_STATE_UNLOCKED);
    if (streamPointer->State != KSPSTREAM_POINTER_STATE_LOCKED) {
        return;
    }

    //
    // Unlock the stream pointer, optionally advancing to the next frame if
    // necessary.
    //
    ASSERT(streamPointer->Queue);
    streamPointer->Queue->
        UnlockStreamPointer(
            streamPointer,
            Eject ? KSPSTREAM_POINTER_MOTION_ADVANCE : KSPSTREAM_POINTER_MOTION_NONE);
}


KSDDKAPI
void
NTAPI
KsStreamPointerAdvanceOffsetsAndUnlock(
    IN PKSSTREAM_POINTER StreamPointer,
    IN ULONG InUsed,
    IN ULONG OutUsed,
    IN BOOLEAN Eject
    )

/*++

Routine Description:

    This routine unlocks a stream pointer.

Arguments:

    StreamPointer -
        Contains a pointer to the stream pointer to be unlocked.

    InUsed -
        Contains the number of input bytes used.  The input offset is advanced
        this many bytes.

    OutUsed -
        Contains the number of output bytes used.  The output offset is 
        advanced this many bytes.

    Eject -
        Contains an indication of whether the frame should be ejected
        regardless of whether all input or output bytes have been used.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsStreamPointerAdvanceOffsetsAndUnlock]"));

    ASSERT(StreamPointer);

    PKSPSTREAM_POINTER streamPointer =
        CONTAINING_RECORD(StreamPointer,KSPSTREAM_POINTER,Public);
    BOOLEAN updateIn = FALSE, updateOut = FALSE;

    ASSERT(streamPointer->State != KSPSTREAM_POINTER_STATE_UNLOCKED);
    if (streamPointer->State != KSPSTREAM_POINTER_STATE_LOCKED) {
        return;
    }

    //
    // Update input offset.
    //
    if (StreamPointer->OffsetIn.Data && 
        (InUsed || (StreamPointer->OffsetIn.Count == 0))) {
        ASSERT(InUsed <= StreamPointer->OffsetIn.Remaining);
        StreamPointer->OffsetIn.Data += InUsed * streamPointer->Stride;
        StreamPointer->OffsetIn.Remaining -= InUsed;
        if (StreamPointer->OffsetIn.Remaining == 0) {
            Eject = TRUE;
        }

        updateIn = TRUE;

    }

    //
    // Update output offset.
    //
    if (StreamPointer->OffsetOut.Data &&
        (OutUsed || (StreamPointer->OffsetOut.Count == 0))) {
        ASSERT(OutUsed <= StreamPointer->OffsetOut.Remaining);
        StreamPointer->OffsetOut.Data += OutUsed * streamPointer->Stride;
        StreamPointer->OffsetOut.Remaining -= OutUsed;
        if (StreamPointer->OffsetOut.Remaining == 0) {
            Eject = TRUE;
        }

        updateOut = TRUE;

    }

    ASSERT(streamPointer->Queue);

    //
    // Update the byte availability statistics.
    //
    streamPointer->Queue->
        UpdateByteAvailability(streamPointer, updateIn ? InUsed : 0,
            updateOut ? OutUsed : 0);

    //
    // Unlock the stream pointer, optionally advancing to the next frame if
    // necessary.
    //
    streamPointer->Queue->
        UnlockStreamPointer(
            streamPointer,
            Eject ? KSPSTREAM_POINTER_MOTION_ADVANCE : KSPSTREAM_POINTER_MOTION_NONE);
}


KSDDKAPI
void
NTAPI
KsStreamPointerDelete(
    IN PKSSTREAM_POINTER StreamPointer
    )

/*++

Routine Description:

    This routine deletes a stream pointer.

Arguments:

    StreamPointer -
        Contains a pointer to the stream pointer to be deleted.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsStreamPointerDelete]"));

    ASSERT(StreamPointer);

    PKSPSTREAM_POINTER streamPointer =
        CONTAINING_RECORD(StreamPointer,KSPSTREAM_POINTER,Public);

    ASSERT(streamPointer->Queue);
    streamPointer->Queue->DeleteStreamPointer(streamPointer);
}


KSDDKAPI
NTSTATUS
NTAPI
KsStreamPointerClone(
    IN PKSSTREAM_POINTER StreamPointer,
    IN PFNKSSTREAMPOINTER CancelCallback OPTIONAL,
    IN ULONG ContextSize,
    OUT PKSSTREAM_POINTER* CloneStreamPointer
    )

/*++

Routine Description:

    This routine clones a stream pointer.

Arguments:

    StreamPointer -
        Contains a pointer to the stream pointer to be cloned.

    CancelCallback -
        Contains an optional pointer to a function to be called when the IRP
        associated with the stream pointer is cancelled.

    ContextSize -
        Contains the size of the additional context to add to the stream
        pointer.  If this argument is zero, no additional context is allocated
        and the context pointer is copied from the source.  Otherwise, the
        context pointer is set to point to the additional context.  The
        additional context, if any, is filled with zeros.

    CloneStreamPointer -
        Cointains a pointer to the location at which the pointer to the clone
        stream pointer should be deposited.

Return Value:

    Status.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsStreamPointerClone]"));

    ASSERT(StreamPointer);
    ASSERT(CloneStreamPointer);

    PKSPSTREAM_POINTER streamPointer =
        CONTAINING_RECORD(StreamPointer,KSPSTREAM_POINTER,Public);

    if ((streamPointer->State != KSPSTREAM_POINTER_STATE_UNLOCKED) &&
        (streamPointer->State != KSPSTREAM_POINTER_STATE_LOCKED)) {
        return STATUS_DEVICE_NOT_READY;
    }

    ASSERT(streamPointer->Queue);
    PKSPSTREAM_POINTER cloneStreamPointer;
    NTSTATUS status =
        streamPointer->Queue->
            CloneStreamPointer(
                &cloneStreamPointer,
                CancelCallback,
                ContextSize,
                streamPointer,
                KSPSTREAM_POINTER_TYPE_NORMAL
                );

    if (NT_SUCCESS(status)) {
        *CloneStreamPointer = &cloneStreamPointer->Public;
    }

    return status;
}


KSDDKAPI
NTSTATUS
NTAPI
KsStreamPointerAdvanceOffsets(
    IN PKSSTREAM_POINTER StreamPointer,
    IN ULONG InUsed,
    IN ULONG OutUsed,
    IN BOOLEAN Eject
    )

/*++

Routine Description:

    This routine advances stream pointer offsets.

Arguments:

    StreamPointer -
        Contains a pointer to the stream pointer.

    InUsed -
        Contains the number of input bytes used.  The input offset is advanced
        this many bytes.

    OutUsed -
        Contains the number of output bytes used.  The output offset is 
        advanced this many bytes.

    Eject -
        Contains an indication of whether the frame should be ejected
        regardless of whether all input or output bytes have been used.

Return Value:

    Status.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsStreamPointerAdvanceOffsets]"));

    ASSERT(StreamPointer);

    PKSPSTREAM_POINTER streamPointer =
        CONTAINING_RECORD(StreamPointer,KSPSTREAM_POINTER,Public);

    BOOLEAN updateIn = FALSE, updateOut = FALSE;

    ASSERT(streamPointer->State != KSPSTREAM_POINTER_STATE_UNLOCKED);
    if (streamPointer->State != KSPSTREAM_POINTER_STATE_LOCKED) {
        return STATUS_DEVICE_NOT_READY;
    }

    ASSERT(streamPointer->Queue);

    //
    // Update input offset.
    //
    if (StreamPointer->OffsetIn.Data &&
        (InUsed || (StreamPointer->OffsetIn.Count == 0))) {
        ASSERT(InUsed <= StreamPointer->OffsetIn.Remaining);
        StreamPointer->OffsetIn.Data += InUsed * streamPointer->Stride;
        StreamPointer->OffsetIn.Remaining -= InUsed;
        if (StreamPointer->OffsetIn.Remaining == 0) {
            Eject = TRUE;
        }

        updateIn = TRUE;
    }

    //
    // Update output offset.
    //
    if (StreamPointer->OffsetOut.Data &&
        (OutUsed || (StreamPointer->OffsetOut.Count == 0))) {
        ASSERT(OutUsed <= StreamPointer->OffsetOut.Remaining);
        StreamPointer->OffsetOut.Data += OutUsed * streamPointer->Stride;
        StreamPointer->OffsetOut.Remaining -= OutUsed;
        if (StreamPointer->OffsetOut.Remaining == 0) {
            Eject = TRUE;
        }

        updateOut = TRUE;

    }

    //
    // Update the byte availability count
    //
    streamPointer->Queue->
        UpdateByteAvailability(streamPointer, updateIn ? InUsed : 0,
            updateOut ? OutUsed : 0);

    NTSTATUS status;
    if (Eject) {
        //
        // Advancing a locked stream pointer involves unlocking it and then
        // locking it again.  If there is no frame to advance to, the pointer
        // ends up unlocked and we return an error.
        //
        streamPointer->Queue->
            UnlockStreamPointer(streamPointer,KSPSTREAM_POINTER_MOTION_ADVANCE);
        if (streamPointer->Queue->LockStreamPointer(streamPointer)) {
            status = STATUS_SUCCESS;
        } else {
            status = STATUS_DEVICE_NOT_READY;
        }
    } else {
        status = STATUS_SUCCESS;
    }

    return status;
}


KSDDKAPI
NTSTATUS
NTAPI
KsStreamPointerAdvance(
    IN PKSSTREAM_POINTER StreamPointer
    )

/*++

Routine Description:

    This routine advances a stream pointer.

Arguments:

    StreamPointer -
        Contains a pointer to the stream pointer.

Return Value:

    Status.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsStreamPointerAdvance]"));

    ASSERT(StreamPointer);

    PKSPSTREAM_POINTER streamPointer =
        CONTAINING_RECORD(StreamPointer,KSPSTREAM_POINTER,Public);
    ASSERT(streamPointer->Queue);

    NTSTATUS status;
    if (streamPointer->State == KSPSTREAM_POINTER_STATE_LOCKED) {
        //
        // Advancing a locked stream pointer involves unlocking it and then
        // locking it again.  If there is no frame to advance to, the pointer
        // ends up unlocked and we return an error.
        //
        streamPointer->Queue->
            UnlockStreamPointer(streamPointer,KSPSTREAM_POINTER_MOTION_ADVANCE);
        if (streamPointer->Queue->LockStreamPointer(streamPointer)) {
            status = STATUS_SUCCESS;
        } else {
            status = STATUS_DEVICE_NOT_READY;
        }
    } else if (streamPointer->State == KSPSTREAM_POINTER_STATE_UNLOCKED) {
        //
        // Advance the stream pointer without locking it.  This always
        // succeeds because there is no way to know whether an unlocked
        // stream pointer actually references a frame.
        //
        streamPointer->Queue->AdvanceUnlockedStreamPointer(streamPointer);
        status = STATUS_SUCCESS;
    } else {
        status = STATUS_DEVICE_NOT_READY;
    }

    return status;
}


KSDDKAPI
PMDL
NTAPI
KsStreamPointerGetMdl(
    IN PKSSTREAM_POINTER StreamPointer
    )

/*++

Routine Description:

    This routine gets the MDL associated with the frame referenced by a stream 
    pointer.

Arguments:

    StreamPointer -
        Contains a pointer to the stream pointer.  The stream pointer must be
        locked.

Return Value:

    The MDL or NULL if there is none.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsStreamPointerGetMdl]"));

    ASSERT(StreamPointer);

    PKSPSTREAM_POINTER streamPointer =
        CONTAINING_RECORD(StreamPointer,KSPSTREAM_POINTER,Public);

    if (streamPointer->State != KSPSTREAM_POINTER_STATE_LOCKED) {
        return NULL;
    }

    ASSERT(streamPointer->FrameHeader);

    return streamPointer->FrameHeader->Mdl;
}


KSDDKAPI
PIRP
NTAPI
KsStreamPointerGetIrp(
    IN PKSSTREAM_POINTER StreamPointer,
    OUT PBOOLEAN FirstFrameInIrp OPTIONAL,
    OUT PBOOLEAN LastFrameInIrp OPTIONAL
    )

/*++

Routine Description:

    This routine gets the IRP associated with the frame referenced by a stream 
    pointer.

Arguments:

    StreamPointer -
        Contains a pointer to the stream pointer.  The stream pointer must be
        locked.

Return Value:

    The IRP or NULL if there is none.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsStreamPointerGetIrp]"));

    ASSERT(StreamPointer);

    PKSPSTREAM_POINTER streamPointer =
        CONTAINING_RECORD(StreamPointer,KSPSTREAM_POINTER,Public);

    if (streamPointer->State != KSPSTREAM_POINTER_STATE_LOCKED) {
        return NULL;
    }

    ASSERT(streamPointer->FrameHeader);

    if (FirstFrameInIrp) {
        if (streamPointer->FrameHeader->IrpFraming) {
            *FirstFrameInIrp = 
                (streamPointer->FrameHeader->IrpFraming->FrameHeaders == 
                 streamPointer->FrameHeader);
        } else {
            *FirstFrameInIrp = FALSE;
        }
    }
    if (LastFrameInIrp) {
        if (streamPointer->FrameHeader->IrpFraming) {
            *LastFrameInIrp = 
                (streamPointer->FrameHeader->NextFrameHeaderInIrp == NULL);
        } else {
            *LastFrameInIrp = FALSE;
        }
    }

    return streamPointer->FrameHeader->Irp;
}


KSDDKAPI
void
NTAPI
KsStreamPointerScheduleTimeout(
    IN PKSSTREAM_POINTER StreamPointer,
    IN PFNKSSTREAMPOINTER Callback,
    IN ULONGLONG Interval
    )

/*++

Routine Description:

    This routine schedules a timeout for the stream pointer.  It is safe to
    call this function on a stream pointer that is already scheduled to time
    out.

Arguments:

    StreamPointer -
        Contains a pointer to the stream pointer.

    Callback -
        Contains a pointer to the function to be called when the timeout
        occurs.

    Interval -
        Contains the interval from the current time to the time at which
        timeout is to occur in 100-nanosecond units.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsStreamPointerScheduleTimeout]"));

    ASSERT(StreamPointer);
    ASSERT(Callback);

    PKSPSTREAM_POINTER streamPointer =
        CONTAINING_RECORD(StreamPointer,KSPSTREAM_POINTER,Public);

    streamPointer->Queue->
        ScheduleTimeout(streamPointer,Callback,LONGLONG(Interval));
}


KSDDKAPI
void
NTAPI
KsStreamPointerCancelTimeout(
    IN PKSSTREAM_POINTER StreamPointer
    )

/*++

Routine Description:

    This routine cancels a timeout for the stream pointer.  It is safe to call
    this function on a stream pointer that is not scheduled to time out.

Arguments:

    StreamPointer -
        Contains a pointer to the stream pointer.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsStreamPointerCancelTimeout]"));

    ASSERT(StreamPointer);

    PKSPSTREAM_POINTER streamPointer =
        CONTAINING_RECORD(StreamPointer,KSPSTREAM_POINTER,Public);

    streamPointer->Queue->CancelTimeout(streamPointer);
}


KSDDKAPI
PKSSTREAM_POINTER
NTAPI
KsPinGetFirstCloneStreamPointer(
    IN PKSPIN Pin
    )

/*++

Routine Description:

    This routine gets the first clone stream pointer for the purpose of
    enumeration.

Arguments:

    Pin -
        Contains a pointer to the KS pin.

Return Value:

    The requested stream pointer or NULL if there are no clone stream
    pointers.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsPinGetFirstCloneStreamPointer]"));

    ASSERT(Pin);

    PKSPPROCESSPIPESECTION pipeSection =
        CONTAINING_RECORD(Pin,KSPIN_EXT,Public)->ProcessPin->PipeSection;

    PKSPSTREAM_POINTER result;

    if (pipeSection && pipeSection->Queue) {
        result = pipeSection->Queue->GetFirstClone();
    } else {
        result = NULL;
    }

    return result ? &result->Public : NULL;
}


KSDDKAPI
PKSSTREAM_POINTER
NTAPI
KsStreamPointerGetNextClone(
    IN PKSSTREAM_POINTER StreamPointer
    )

/*++

Routine Description:

    This routine gets the next clone stream pointer for the purpose of
    enumeration.

Arguments:

    StreamPointer -
        Contains a pointer to the stream pointer.

Return Value:

    The requested stream pointer or NULL if there are no more clone stream
    pointers.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KsStreamPointerGetNextClone]"));

    ASSERT(StreamPointer);

    PKSPSTREAM_POINTER streamPointer =
        CONTAINING_RECORD(StreamPointer,KSPSTREAM_POINTER,Public);

    streamPointer = streamPointer->Queue->GetNextClone(streamPointer);

    return streamPointer ? &streamPointer->Public : NULL;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\ks\shpipe.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    shpipe.cpp

Abstract:

    This module contains the implementation of the kernel streaming 
    pipe section object.

Author:

    Dale Sather  (DaleSat) 31-Jul-1998

--*/

#ifndef __KDEXT_ONLY__
#include "ksp.h"
#include <kcom.h>
#endif // __KDEXT_ONLY__

#if (DBG)

#define _DbgPrintFail(status, lvl, strings) \
{ \
    if ((! NT_SUCCESS(status)) && ((lvl) <= DEBUG_VARIABLE)) {\
        DbgPrint(STR_MODULENAME);\
        DbgPrint##strings;\
        DbgPrint("\n");\
        if ((lvl) == DEBUGLVL_ERROR) {\
            DbgBreakPoint();\
        } \
    } \
}
#else // !DBG
   #define _DbgPrintFail(status, lvl, strings)
#endif // !DBG

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA

//
// CKsPipeSection is the implementation of the kernel  pipe section
// object.
//
class CKsPipeSection:
    public IKsPipeSection,
    public CBaseUnknown
{
#ifndef __KDEXT_ONLY__
private:
#else // __KDEXT_ONLY__
public:
#endif // __KDEXT_ONLY__
    PVOID m_Id;
    PIKSFILTER m_Filter;
    PIKSDEVICE m_Device;
    KSSTATE m_DeviceState;
    KSRESET m_ResetState;
    KSPPROCESSPIPESECTION m_ProcessPipeSection;
    PIKSPIN m_MasterPin;
    BOOLEAN m_ConfigurationSet;
    BOOLEAN m_EmergencyShutdown;

    NTSTATUS
    GetTransport(
        IN PKSPPROCESSPIN ProcessPin OPTIONAL,
        OUT PIKSTRANSPORT* Transport,
        IN OUT PFILE_OBJECT* Allocator,
        IN OUT PIKSRETIREFRAME* RetireFrame,
        IN OUT PIKSIRPCOMPLETION* IrpCompletion,
        IN const KSALLOCATOR_FRAMING_EX* AllocatorFramingIn OPTIONAL,
        IN const KSALLOCATOR_FRAMING_EX** AllocatorFramingOut OPTIONAL
        );
    BOOLEAN
    IsCircuitComplete(
        OUT PIKSTRANSPORT* Top
        );
    NTSTATUS
    ConfigureCompleteCircuit(
        IN PIKSTRANSPORT Top,
        IN PIKSTRANSPORT Next OPTIONAL
        );
    NTSTATUS
    UnconfigureCompleteCircuit(
        IN PIKSTRANSPORT Top
        );
    NTSTATUS
    DistributeDeviceStateChange(
        IN PIKSTRANSPORT Transport,
        IN KSSTATE NewState,
        IN KSSTATE OldState
        );

public:
    DEFINE_STD_UNKNOWN();
    IMP_IKsPipeSection;

    CKsPipeSection(PUNKNOWN OuterUnknown):
        CBaseUnknown(OuterUnknown)
    {
    }
    ~CKsPipeSection();

    NTSTATUS
    Init(
        IN PVOID PipeId,
        IN PIKSPIN Pin,
        IN PIKSFILTER Filter,
        IN PIKSDEVICE Device
        );
};

void
DisconnectCircuit(
    IN PIKSTRANSPORT Transport
    );

#ifndef __KDEXT_ONLY__

IMPLEMENT_STD_UNKNOWN(CKsPipeSection)


NTSTATUS
KspCreatePipeSection(
    IN PVOID PipeId,
    IN PIKSPIN Pin,
    IN PIKSFILTER Filter,
    IN PIKSDEVICE Device
    )

/*++

Routine Description:

    This routine creates a pipe section object.  This routine is called by the 
    first pin in a given filter in a given pipe section to make the transition 
    from stop state to acquire state.  When other pins in the pipe section make
    the transition, they refrain from calling this function upon determining 
    that they are already associated with a pipe section (the one we are
    creating here).  If the pin's PipeId is NULL, this indicates that the pin 
    was not assigned a pipe ID by the graph builder, and the pin has its own 
    pipe section.

    The filter's control mutex must be acquired before this function is called.

Arguments:

Return Value:

    Status.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KspCreatePipeSection]"));

    PAGED_CODE();

    ASSERT(Pin);
    ASSERT(Filter);
    ASSERT(Device);

    CKsPipeSection *pipeSection =
        new(NonPagedPool,POOLTAG_PIPESECTION) CKsPipeSection(NULL);

    NTSTATUS status;
    if (pipeSection) {
        pipeSection->AddRef();

        status = pipeSection->Init(PipeId,Pin,Filter,Device);

        pipeSection->Release();
    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return status;
}


STDMETHODIMP_(NTSTATUS)
CKsPipeSection::
NonDelegatedQueryInterface(
    IN REFIID InterfaceId,
    OUT PVOID * InterfacePointer
    )

/*++

Routine Description:

    This routine obtains an interface on a queue object.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPipeSection::NonDelegatedQueryInterface]"));

    PAGED_CODE();

    ASSERT(InterfacePointer);

    NTSTATUS status = STATUS_SUCCESS;

    if (IsEqualGUIDAligned(InterfaceId,__uuidof(IKsPipeSection))) {
        *InterfacePointer = reinterpret_cast<PVOID>(static_cast<PIKSPIPESECTION>(this));
        AddRef();
    } else {
        status = CBaseUnknown::NonDelegatedQueryInterface(InterfaceId,InterfacePointer);
    }

    return status;
}


void
AddTransport(
    IN PIKSTRANSPORT TransportToAdd OPTIONAL,
    IN OUT PIKSTRANSPORT *FirstTransport,
    IN OUT PIKSTRANSPORT *LastTransport
    )

/*++

Routine Description:

    This routine adds a transport to a list of transports.

Arguments:

    TransportToAdd -
        Contains a pointer to the transport to add to the list.  If this
        argument is NULL, no action should be taken.

    FirstTransport -
        Contains a pointer to the location at which the first transport is to
        be deposited.  If the the list is empty, *FirstTransport is NULL.  If
        a transport is added to an empty list, *FirstTransport points to the
        added transport.  Otherwise, *FirstTransport is unchanged.

    LastTransport -
        Contains a pointer to the location at which the last transport is to
        be deposited.  If the list is empty, *LastTransport is NULL.  When a
        transport is added to the list, *LastTransport points to the added
        transport.

Return Value:

    None.

--*/

{
    if (TransportToAdd) {
        if (*LastTransport) {
            (*LastTransport)->Connect(TransportToAdd,NULL,NULL,KSPIN_DATAFLOW_OUT);
        } else {
            *FirstTransport = TransportToAdd;
        }
        *LastTransport = TransportToAdd;
    }
}


NTSTATUS
CKsPipeSection::
Init(
    IN PVOID PipeId,
    IN PIKSPIN Pin,
    IN PIKSFILTER Filter,
    IN PIKSDEVICE Device
    )

/*++

Routine Description:

    This routine initializes a pipe section object.  This includes locating all
    the pins associated with the pipe section, setting the PipeSection and 
    NextPinInPipeSection pointers in the appropriate pin structures, setting
    all the fields in the pipe section structure and building the transport 
    circuit for the pipe section.  The pipe section and the associated 
    components are left in acquire state.
    
    The filter's control mutex must be acquired before this function is called.

Arguments:

Return Value:

    Status.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPipeSection::Init]"));
    _DbgPrintF(DEBUGLVL_LIFETIME,("#### Pipe%p.Init:  filter %p",this,Filter));

    PAGED_CODE();

    ASSERT(Pin);
    ASSERT(Filter);
    ASSERT(Device);

    m_Id = PipeId;
    m_Filter = Filter;
    m_Device = Device;
    m_DeviceState = KSSTATE_STOP;
    m_ProcessPipeSection.PipeSection = this;
    InitializeListHead(&m_ProcessPipeSection.CopyDestinations);
    m_ProcessPipeSection.CopyPinId = ULONG(-1);

    //
    // Look for pins in the pipe section.
    //
    PKSGATE andGate;
    NTSTATUS status = 
        m_Filter->BindProcessPinsToPipeSection(
            &m_ProcessPipeSection,
            m_Id,
            m_Id ? NULL : Pin->GetStruct(),
            &m_MasterPin,
            &andGate);

    //
    // Get transport interfaces for input and ouput.
    //
    PFILE_OBJECT allocator = NULL;
    PIKSRETIREFRAME retireFrame = NULL;
    PIKSIRPCOMPLETION irpCompletion = NULL;
    const KSALLOCATOR_FRAMING_EX* allocatorFraming = NULL;

    PIKSTRANSPORT outTransport = NULL;
    if (NT_SUCCESS(status)) {
        status = 
            GetTransport(
                m_ProcessPipeSection.Outputs,
                &outTransport,
                &allocator,
                &retireFrame,
                &irpCompletion,
                NULL,
                &allocatorFraming);
    } else {
        andGate = NULL;
    }

    PIKSTRANSPORT inTransport = NULL;
    if (NT_SUCCESS(status)) {
        status = 
            GetTransport(
                m_ProcessPipeSection.Inputs,
                &inTransport,
                &allocator,
                &retireFrame,
                &irpCompletion,
                allocatorFraming,
                NULL);
    }

    //
    // Create the queue if one is needed.
    //
    if (NT_SUCCESS(status) && ! (allocator && retireFrame)) {
        //
        // First figure out who will be processing.
        //
        const KSPIN_DESCRIPTOR_EX* pinDescriptor =
            m_MasterPin->GetStruct()->Descriptor;
        const KSFILTER_DESCRIPTOR* filterDescriptor =
            m_Filter->GetStruct()->Descriptor;

        //
        // NOTE:
        //
        // This used to be done per pipe section by having pin processing 
        // dispatches or retirement callbacks override filter processing.
        // Now, a filter is either filter centric or pin centric.  Placing
        // a filter process dispatch makes it filter centric.  If the pins
        // specify pin dispatches when the filter does, an assert will fire.
        // 
        PIKSPROCESSINGOBJECT processingObject;
        if (filterDescriptor->Dispatch && 
            filterDescriptor->Dispatch->Process) {

            //
            // Ensure that the pin isn't trying to override the filter.  It
            // will fail to do so, but we should put a debug message so that
            // clients know why the pin is getting overriden.
            //
            if (retireFrame ||
                (pinDescriptor->Dispatch && pinDescriptor->Dispatch->Process)) {
                _DbgPrintF(DEBUGLVL_ERROR,("#### Pipe%p.Init:  pin%p wants to process as does filter.  Pin processing ignored."));
            }

            //
            // The filter has a process function, so it will process.
            //
            m_Filter->QueryInterface(
                __uuidof(IKsProcessingObject),
                (PVOID*)&processingObject);
            _DbgPrintF(DEBUGLVL_PIPES,("#### Pipe%p.Init:  filter%p will process",this,m_Filter));
	    } else 
        if (retireFrame ||
            (pinDescriptor->Dispatch && pinDescriptor->Dispatch->Process)) {
            //
            // The pin has a process function, so it will process.
            //
            m_MasterPin->QueryInterface(
                __uuidof(IKsProcessingObject),
                (PVOID*)&processingObject);
            _DbgPrintF(DEBUGLVL_PIPES,("#### Pipe%p.Init:  pin%p will process",this,m_MasterPin));
        } else {
            //
            // No processing function was found, so no queue.
            //
            processingObject = NULL;
            _DbgPrintF(DEBUGLVL_PIPES,("#### Pipe%p.Init:  no processing object - no queue will be constructed",this));
        }

        if (processingObject) {
            PADAPTER_OBJECT adapterObject;
            ULONG maxMappingByteCount;
            ULONG mappingTableStride;
            m_Device->GetAdapterObject(
                &adapterObject,
                &maxMappingByteCount,
                &mappingTableStride);
            PKSPPROCESSPIN processPin = m_MasterPin->GetProcessPin();

            //
            // Make certain that minidrivers performing DMA have registered
            // a valid DMA adapter and settings with the device.  Otherwise,
            // the queue won't be happy
            //
            if ((processPin->Pin->Descriptor->Flags &
                KSPIN_FLAG_GENERATE_MAPPINGS) &&
                (adapterObject == NULL ||
                    maxMappingByteCount == 0 ||
                    mappingTableStride < sizeof (KSMAPPING))) {

                //
                // We can't build the pipe if the queue is performing DMA
                // and the adapter isn't registered yet.
                //
                status = STATUS_INVALID_DEVICE_REQUEST;

            } 
            else {

                //
                // GFX: 
                //
                // Enforce FIFO on any input pipe if we're frame holding and
                // that pipe is not involved in any inplace transform.
                //
                ULONG ForceFlags = 0;

                if (m_Filter->IsFrameHolding() &&
                    processPin->Pin->DataFlow == KSPIN_DATAFLOW_IN &&
                    m_ProcessPipeSection.Outputs == NULL) {
                    ForceFlags = KSPIN_FLAG_ENFORCE_FIFO;
                }

                status =
                    KspCreateQueue(
                        &m_ProcessPipeSection.Queue,
                        processPin->Pin->Descriptor->Flags | ForceFlags,
                        this,
                        processingObject,
                        processPin->Pin,
                        processPin->FrameGate,
                        processPin->FrameGateIsOr,
                        processPin->StateGate,
                        m_Device,
                        m_Device->GetStruct()->FunctionalDeviceObject,
                        adapterObject,
                        maxMappingByteCount,
                        mappingTableStride,
                        inTransport != NULL,
                        outTransport != NULL);
                _DbgPrintFail(status,DEBUGLVL_TERSE,("#### Pipe%p.Init:  KspCreateQueue failed (%p)",this,status));

                //
                // For pin-centric splitting, once we have finished creating
                // the copy source queue, have the filter register for
                // callbacks on it. 
                //
                // Only call this if this pipe section is the copy source
                // section.
                //
                if (NT_SUCCESS (status) &&
                    m_ProcessPipeSection.CopyPinId != ULONG(-1)) {
                    m_Filter -> RegisterForCopyCallbacks (
                        m_ProcessPipeSection.Queue,
                        TRUE
                        );

                }

            }

            processingObject->Release();

        }
    }

    //
    // SYSAUDIO HACK TO RUN WITHOUT AN ALLOCATOR.
    //
    if (NT_SUCCESS(status) && (! allocator) && (! retireFrame)) {
    //if (NT_SUCCESS(status) && (! retireFrame)) {
        allocator = PFILE_OBJECT(-1);
        for(PKSPPROCESSPIN processPin = m_ProcessPipeSection.Inputs; 
            processPin && allocator; 
            processPin = processPin->Next) {
            if (processPin->Pin->Communication == KSPIN_COMMUNICATION_SINK) {
                allocator = NULL;
            }
        }
        for(processPin = m_ProcessPipeSection.Outputs; 
            processPin && allocator; 
            processPin = processPin->Next) {
            if (processPin->Pin->Communication == KSPIN_COMMUNICATION_SINK) {
                allocator = NULL;
            }
        }
    }

    //
    // Create the requestor if one is needed.
    //
    if (NT_SUCCESS(status) && allocator) {
        status =
            KspCreateRequestor(
                &m_ProcessPipeSection.Requestor,
                this,
                m_MasterPin,
                retireFrame ? NULL : allocator,
                retireFrame,
                irpCompletion);
        _DbgPrintFail(status,DEBUGLVL_TERSE,("#### Pipe%p.Init:  KspCreateRequestor failed (%p)",this,status));
    }

    //
    // Connect the circuit for this pipe section.
    //
    if (NT_SUCCESS(status)) {
        ASSERT(m_ProcessPipeSection.Queue || m_ProcessPipeSection.Requestor);

        PIKSTRANSPORT firstTransport = NULL;
        PIKSTRANSPORT lastTransport = NULL;

        AddTransport(m_ProcessPipeSection.Queue,&firstTransport,&lastTransport);
        AddTransport(outTransport,&firstTransport,&lastTransport);
        AddTransport(m_ProcessPipeSection.Requestor,&firstTransport,&lastTransport);
        AddTransport(inTransport,&firstTransport,&lastTransport);
        AddTransport(firstTransport,&firstTransport,&lastTransport);
    }

#if (DBG)
    if (DEBUGLVL_PIPES <= DEBUG_VARIABLE) {
        _DbgPrintF(DEBUGLVL_TERSE,("TRANSPORT CIRCUIT FOR PIPE %p (%p) BEFORE BYPASS",m_Id,this));
        DbgPrintCircuit(m_ProcessPipeSection.Requestor ? PIKSTRANSPORT(m_ProcessPipeSection.Requestor) : PIKSTRANSPORT(m_ProcessPipeSection.Queue),0,0);
    }
#endif //DBG

    //
    // Tell all the pins to bypass.
    //
    _DbgPrintF(DEBUGLVL_PIPES,("#### Pipe%p.Init:  bypassing pins",this));
    BOOLEAN completeIntraPipe = TRUE;
    if (NT_SUCCESS(status)) {
        for(PKSPPROCESSPIN processPin = m_ProcessPipeSection.Inputs; 
            processPin; 
            processPin = processPin->Next) {
            if (! NT_SUCCESS(KspPinInterface(processPin->Pin)->AttemptBypass())) {
                completeIntraPipe = FALSE;
            }
        }
        for(processPin = m_ProcessPipeSection.Outputs; 
            processPin; 
            processPin = processPin->Next) {
            if (! NT_SUCCESS(KspPinInterface(processPin->Pin)->AttemptBypass())) {
                completeIntraPipe = FALSE;
            }
        }
    }

#if (DBG)
    if (DEBUGLVL_PIPES <= DEBUG_VARIABLE) {
        _DbgPrintF(DEBUGLVL_TERSE,("TRANSPORT CIRCUIT FOR PIPE %p (%p) AFTER BYPASS",m_Id,this));
        DbgPrintCircuit(m_ProcessPipeSection.Requestor ? PIKSTRANSPORT(m_ProcessPipeSection.Requestor) : PIKSTRANSPORT(m_ProcessPipeSection.Queue),0,0);
    }
#endif //DBG

    //
    // Allow processing now that we are done setting up.
    //
    if (andGate) {
        KsGateRemoveOffInputFromAnd(andGate);
        _DbgPrintF(DEBUGLVL_PROCESSINGCONTROL,("#### Pipe%p.Init:  on%p-->%d",this,andGate,andGate->Count));
    }

    //
    // Determine if we have a complete intra- pipe.
    //
    PIKSTRANSPORT top;
    if (NT_SUCCESS(status) && 
        completeIntraPipe && 
        IsCircuitComplete(&top)) {
        //
        // Make sure we have a top component.
        //
        if (! top) {
            status = STATUS_UNSUCCESSFUL;
            _DbgPrintFail(status,DEBUGLVL_TERSE,("#### Pipe%p.Init:  no top (%p)",this,status));
        } else {
            //
            // Configure and acquire the circuit if it is complete.
            //
            _DbgPrintF(DEBUGLVL_TERSE,("TRANSPORT CIRCUIT FOR PIPE %p (%p)",m_Id,this));
            DbgPrintCircuit(m_ProcessPipeSection.Requestor ? PIKSTRANSPORT(m_ProcessPipeSection.Requestor) : PIKSTRANSPORT(m_ProcessPipeSection.Queue),0,1);
            status = ConfigureCompleteCircuit(top,NULL);
            _DbgPrintFail(status,DEBUGLVL_TERSE,("#### Pipe%p.Init:  ConfigureCompleteCircuit failed (%p)",this,status));
            if (NT_SUCCESS(status)) {
                status = DistributeDeviceStateChange(top,KSSTATE_ACQUIRE,KSSTATE_STOP);
                _DbgPrintFail(status,DEBUGLVL_TERSE,("#### Pipe%p.Init:  DistributeDeviceStateChange failed (%p)",this,status));
            }
            if (NT_SUCCESS(status)) {
                m_DeviceState = KSSTATE_ACQUIRE;
            }
        }
    }

    if (! NT_SUCCESS(status)) {
        _DbgPrintF(DEBUGLVL_TERSE,("#### Pipe%p.Init failed (%p)",this,status));

        PIKSTRANSPORT Top;

        if (IsCircuitComplete (&Top)) {

            //
            // If the graph builder screws up, Top can be NULL when
            // IsCircuitComplete returns true.
            //
            if (Top) {

                ASSERT (Top == top);

                //
                // If the circuit is complete, we completed the circuit and
                // configured it.  We need to unset the configuration set
                // field of any other section in the circuit.  Otherwise, it's
                // possible that some in error builder can set the in charge
                // pin to pause and we'll succeed it.  The circuit is NO LONGER
                // CONFIGURED at this point.  Fix it up.
                //
                NTSTATUS UnconfigStatus = UnconfigureCompleteCircuit (Top);
                ASSERT (NT_SUCCESS (UnconfigStatus));
            }
        }

        //
        // Unbypass all the pins that were bypassed in this pipe section.
        // Otherwise, we tear down the entire circuit when one pin related to
        // the circuit fails to acquire.  Doing this would prevent us from
        // going to pause without stopping every pin in the circuit or
        // rebuilding the circuit later.
        //
        // Must do this before the unbind, otherwise the pins are already gone
        // out of the lists.
        //
        // NOTE: This is the the only guaranteed safe location to do the
        // unbypass because the pins keep unrefcounted pointers on the 
        // pre-bypass circuit elements.  Those are only guaranteed to be safe
        // to use while we're here.
        // 
        for(PKSPPROCESSPIN processPin = m_ProcessPipeSection.Inputs; 
            processPin; 
            processPin = processPin->Next) {

            KspPinInterface(processPin->Pin)->AttemptUnbypass();

        }
        for(processPin = m_ProcessPipeSection.Outputs; 
            processPin; 
            processPin = processPin->Next) {

            KspPinInterface(processPin->Pin)->AttemptUnbypass();

        }

        m_Filter->UnbindProcessPinsFromPipeSection(&m_ProcessPipeSection);

        //
        // Dereference the queue if there is one.
        //
        if (m_ProcessPipeSection.Queue) {
            DisconnectCircuit(m_ProcessPipeSection.Queue);
            m_ProcessPipeSection.Queue->Release();
            m_ProcessPipeSection.Queue = NULL;
        }

        //
        // Dereference the requestor if there is one.
        //
        if (m_ProcessPipeSection.Requestor) {
            DisconnectCircuit(m_ProcessPipeSection.Requestor);
            m_ProcessPipeSection.Requestor->Release();
            m_ProcessPipeSection.Requestor = NULL;
        }
    }

    //
    // GetTransport returns AddRef()ed transports, so release them here.  If
    // they are connected properly, they will not go away.
    //
    if (inTransport) {
        inTransport->Release();
    }
    if (outTransport) {
        outTransport->Release();
    }
    if (retireFrame) {
        retireFrame->Release();
    }

    return status;
}

NTSTATUS
CKsPipeSection::
GetTransport(
    IN PKSPPROCESSPIN ProcessPin OPTIONAL,
    OUT PIKSTRANSPORT *Transport,
    IN OUT PFILE_OBJECT *Allocator,
    IN OUT PIKSRETIREFRAME *RetireFrame,
    IN OUT PIKSIRPCOMPLETION *IrpCompletion,
    IN const KSALLOCATOR_FRAMING_EX* AllocatorFramingIn OPTIONAL,
    IN const KSALLOCATOR_FRAMING_EX ** AllocatorFramingOut OPTIONAL
    )

/*++

Routine Description:

    This routine gets a single transport interface for the input or output side
    of a pipe section.  The resulting transport may be NULL if there are no
    pins with the indicated data flow.  If there is one such pin, the resulting
    transport will be the transport interface for that pin.  If there are more
    than one such pin, the resulting transport will be the transport interface
    of a splitter that combines all the pins.

Arguments:

    ProcessPin -
        Contains a pointer to the first process pin in a list of input or
        output process pins for which a single transport is to be obtained.
        If this argument is NULL, the resulting transport will be NULL.

    Transport -
        Contains a pointer to the location at which the transport is to
        be deposited.  The transport is referenced on behalf of the caller,
        and a matching Release() must occur at some point.

    Allocator -
        Contains a pointer to the location at which to deposit an allocator
        file object if a qualifying pin has been assigned an allocator.
        *Allocator is not modified if no such pin is found.

    RetireFrame -
        Contains a pointer to the location at which to deposit a retire frame
        interface if a qualifying pin produces one.  *RetireFrame is not
        modified if no such pin is found.

    IrpCompletion -
        Contains a pointer to the location at which to deposit an Irp completion
        callback interface if a qualifying pin produces one.  *CompleteIrp is
        not modified if no such pin is found.

    AllocatorFramingIn -
        Contains an optional pointer to allocator framing information to be
        used in deciding how to set up the transport.  In particular, this
        information is used in setting up input transport to determine whether
        a splitter is required for expansion filters.

    AllocatorFramingOut -
        Contains an optional pointer to a location at which a pointer to 
        allocator framing information is to be deposited.  This information
        is provided during the construction of output transports to inform
        the construction of the corresponding input transport.

Return Value:

    STATUS_SUCCESS or an error code from KspCreateSplitter().

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPipeSection::GetTransport]"));

    PAGED_CODE();

    ASSERT(Transport);
    ASSERT(Allocator);
    ASSERT(RetireFrame);

    PIKSTRANSPORT transport = NULL;
    PIKSSPLITTER splitter = NULL;
    PKSPIN firstPin;

    NTSTATUS status = STATUS_SUCCESS;

    for (; ProcessPin; ProcessPin = ProcessPin->Next) {
        PKSPIN pin = ProcessPin->Pin;
        PIKSPIN pinInterface = KspPinInterface(pin);

        //
        // Check it to see if the pin wants to submit frames.
        //
        if (ProcessPin->RetireFrameCallback) {
            ASSERT(! *RetireFrame);
            _DbgPrintF(DEBUGLVL_PIPES,("#### Pipe%p.GetTransport:  pin%p will submit frames",this,pinInterface));
            pinInterface->QueryInterface(__uuidof(IKsRetireFrame),(PVOID *) RetireFrame);
        } else {
            //
            // Check it to see if the pin wants to be notified of Irps returning
            // to the requestor.
            //
            if (ProcessPin->IrpCompletionCallback) {
                _DbgPrintF(DEBUGLVL_PIPES,("#### Pipe%p.GetTransport:  pin%p wants to be notified of Irp completion to a requestor",this,pinInterface));
                pinInterface->QueryInterface(__uuidof(IKsIrpCompletion),(PVOID *) IrpCompletion);
            }

            //
            // Check it to see if the pin wants to allocate.
            //
            if (ProcessPin->AllocatorFileObject) {
                _DbgPrintF(DEBUGLVL_PIPES,("#### Pipe%p.GetTransport:  pin%p has allocator",this,pinInterface));
                *Allocator = ProcessPin->AllocatorFileObject;
            }
        }

        if (! transport) {
            _DbgPrintF(DEBUGLVL_PIPES,("#### Pipe%p.GetTransport:  first pin%p",this,pinInterface));
            //
            // This is the first pin.
            //
            firstPin = pin;
            transport = pinInterface;
            transport->AddRef();
            if (AllocatorFramingOut) {
                *AllocatorFramingOut = 
                    pin->Descriptor->AllocatorFraming;
            }

            //
            // For expansion, we will require a splitter.
            //
            if (AllocatorFramingIn && 
                (AllocatorFramingIn->OutputCompression.RatioNumerator > 
                 AllocatorFramingIn->OutputCompression.RatioDenominator)) {
                _DbgPrintF(DEBUGLVL_PIPES,("#### Pipe%p.GetTransport:  first pin%p expansion",this,pinInterface));
                status = KspCreateSplitter(&splitter,pin);
                transport->Release();
                if (NT_SUCCESS(status)) {
                    transport = splitter;
                    splitter->AddBranch(firstPin,AllocatorFramingIn);
                } else {
                    break;
                }
            }
        } else {
            if (! splitter) {
                _DbgPrintF(DEBUGLVL_PIPES,("#### Pipe%p.GetTransport:  second pin%p",this,pinInterface));
                //
                // This is the second pin, so we need to make a splitter.
                //
                status = KspCreateSplitter(&splitter,pin);
                transport->Release();
                if (NT_SUCCESS(status)) {
                    transport = splitter;
                    splitter->AddBranch(firstPin,AllocatorFramingIn);
                } else {
                    break;
                }
            } else {
                _DbgPrintF(DEBUGLVL_PIPES,("#### Pipe%p.GetTransport:  third+ pin%p",this,pinInterface));
            }

            splitter->AddBranch(pin,AllocatorFramingIn);
        }
    }

    if (NT_SUCCESS(status)) {
        *Transport = transport;
    }

    return status;
}

BOOLEAN
CKsPipeSection::
IsCircuitComplete(
    OUT PIKSTRANSPORT* Top
    )

/*++

Routine Description:

    This routine determines if the pipe circuit is complete.

Arguments:

    None.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPipeSection::IsCircuitComplete(%p)]"));

    PAGED_CODE();

    ASSERT(Top);

    PIKSTRANSPORT top = NULL;
    BOOLEAN completeIntraPipe = TRUE;
    PIKSTRANSPORT transportStart = 
        m_ProcessPipeSection.Requestor ? PIKSTRANSPORT(m_ProcessPipeSection.Requestor) : PIKSTRANSPORT(m_ProcessPipeSection.Queue);

    PIKSTRANSPORT transport = transportStart;
    while (1) {
        if (! transport) {
            completeIntraPipe = FALSE;
            top = NULL;
            break;
        }

        //
        // Get the configuration from this component.
        //
        KSPTRANSPORTCONFIG config;
        PIKSTRANSPORT nextTransport;
        PIKSTRANSPORT prevTransport;
        transport->GetTransportConfig(
            &config,
            &nextTransport,
            &prevTransport);

        //
        // If we find any intra-pins, the circuit is not complete. All intra-
        // pins will be bypassed when the circuit is complete.  We can pass 
        // this back as the top component anyway because this function is 
        // reused for emergency shutdown.  The FALSE return indicates this 
        // is may not really be the top.
        //
        if (config.TransportType & KSPTRANSPORTTYPE_PININTRA) {
            completeIntraPipe = FALSE;
            if (! top) {
                top = transport;
            }
            break;
        }

        //
        // Requestors and non-intra sink pins qualify as top components.  Both
        // are frame sources in the circuit.
        //
        if ((config.TransportType & KSPTRANSPORTTYPE_PINSINK) ||
            (config.TransportType == KSPTRANSPORTTYPE_REQUESTOR)) {
            if (top) {
                _DbgPrintF(DEBUGLVL_TERSE,("#### Pipe%p.IsCircuitComplete:  more than one 'top' component (%p and %p)",this,top,transport));
                _DbgPrintF(DEBUGLVL_TERSE,("#### There should be exactly one top component in a given pipe.  Top components"));
                _DbgPrintF(DEBUGLVL_TERSE,("#### correspond to pins with allocators assigned to them and sink pins which"));
                _DbgPrintF(DEBUGLVL_TERSE,("#### are not connected to a pin implemented by KS.  This error occurred because"));
                _DbgPrintF(DEBUGLVL_TERSE,("#### the graph builder put more than one of these in a single pipe."));
                DbgPrintCircuit(transportStart,0,0);
                *Top = NULL;
                return TRUE;
            }
            top = transport;
        }

        transport = nextTransport;

        //
        // Stop when we've returned to our starting point.
        //
        if (transport == transportStart) {
            break;
        }
    }

    *Top = top;

    //
    // Make sure we have a top component.
    //
    if (completeIntraPipe && ! top) {
        _DbgPrintF(DEBUGLVL_TERSE,("#### Pipe%p.IsCircuitComplete:  no 'top' component",this));
        _DbgPrintF(DEBUGLVL_TERSE,("#### There should be exactly one top component in a given pipe.  Top components"));
        _DbgPrintF(DEBUGLVL_TERSE,("#### correspond to pins with allocators assigned to them and sink pins which"));
        _DbgPrintF(DEBUGLVL_TERSE,("#### are not connected to a pin implemented by KS.  This error occurred because"));
        _DbgPrintF(DEBUGLVL_TERSE,("#### the graph builder did not put one of these in a pipe."));
        DbgPrintCircuit(transportStart,0,0);
    }

    return completeIntraPipe;
}

void
DbgPrintConfig(
    IN PKSPTRANSPORTCONFIG Config,
    IN BOOLEAN Set
    )
{
#if DBG
    if (DEBUGLVL_CONFIG > DEBUG_VARIABLE) {
        return;
    }

    switch (Config->TransportType) {
    case KSPTRANSPORTTYPE_QUEUE:
        DbgPrint("    TransportType: QUEUE\n");
        break;
    case KSPTRANSPORTTYPE_REQUESTOR:
        DbgPrint("    TransportType: REQUESTOR\n");
        break;
    case KSPTRANSPORTTYPE_SPLITTER:
        DbgPrint("    TransportType: SPLITTER\n");
        break;
    case KSPTRANSPORTTYPE_SPLITTERBRANCH:
        DbgPrint("    TransportType: SPLITTERBRANCH\n");
        break;

    default:
        if (Config->TransportType & KSPTRANSPORTTYPE_PINEXTRA) {
            DbgPrint("    TransportType: EXTRA ");
        } else {
            DbgPrint("    TransportType: INTRA ");
        }
        if (Config->TransportType & KSPTRANSPORTTYPE_PININPUT) {
            DbgPrint("INPUT ");
        } else {
            DbgPrint("OUTPUT ");
        }
        if (Config->TransportType & KSPTRANSPORTTYPE_PINSOURCE) {
            DbgPrint("SOURCE PIN\n");
        } else {
            DbgPrint("SINK PIN\n");
        }
        break;
    }

    DbgPrint("    IrpDisposition:");
    if (Config->IrpDisposition == KSPIRPDISPOSITION_NONE) {
        DbgPrint(" NONE");
    } else {
        if (Config->IrpDisposition & KSPIRPDISPOSITION_UNKNOWN) {
            DbgPrint(" UNKNOWN");
        }
        if (Config->IrpDisposition & KSPIRPDISPOSITION_ISKERNELMODE) {
            DbgPrint(" ISKERNELMODE");
        }

        if (Set) {
            if (Config->IrpDisposition & KSPIRPDISPOSITION_USEMDLADDRESS) {
                DbgPrint(" USEMDLADDRESS");
            }
            if (Config->IrpDisposition & KSPIRPDISPOSITION_CANCEL) {
                DbgPrint(" CANCEL");
            }
        } else {
            if (Config->TransportType == KSPTRANSPORTTYPE_QUEUE) {
                if (Config->IrpDisposition & KSPIRPDISPOSITION_NEEDNONPAGED) {
                    DbgPrint(" NEEDNONPAGED");
                }
                if (Config->IrpDisposition & KSPIRPDISPOSITION_NEEDMDLS) {
                    DbgPrint(" NEEDMDLS");
                }
            } else {
                if (Config->IrpDisposition & KSPIRPDISPOSITION_ISPAGED) {
                    DbgPrint(" ISPAGED");
                }
                if (Config->IrpDisposition & KSPIRPDISPOSITION_ISNONPAGED) {
                    DbgPrint(" ISNONPAGED");
                }
            }
        }

        if ((Config->IrpDisposition & KSPIRPDISPOSITION_PROBEFLAGMASK) == KSPIRPDISPOSITION_PROBEFORREAD) {
            DbgPrint(" PROBEFORREAD");
        } else
        if ((Config->IrpDisposition & KSPIRPDISPOSITION_PROBEFLAGMASK) == KSPIRPDISPOSITION_PROBEFORWRITE) {
            DbgPrint(" PROBEFORWRITE");
        } else
        if ((Config->IrpDisposition & KSPIRPDISPOSITION_PROBEFLAGMASK) == KSPIRPDISPOSITION_PROBEFORMODIFY) {
            DbgPrint(" PROBEFORMODIFY");
        } else {
            if (Config->IrpDisposition & KSPROBE_STREAMWRITE) {
                DbgPrint(" KSPROBE_STREAMWRITE");
            }
            if (Config->IrpDisposition & KSPROBE_ALLOCATEMDL) {
                DbgPrint(" KSPROBE_ALLOCATEMDL");
            }
            if (Config->IrpDisposition & KSPROBE_PROBEANDLOCK) {
                DbgPrint(" KSPROBE_PROBEANDLOCK");
            }
            if (Config->IrpDisposition & KSPROBE_SYSTEMADDRESS) {
                DbgPrint(" KSPROBE_SYSTEMADDRESS");
            }
            if (Config->IrpDisposition & KSPROBE_MODIFY) {
                DbgPrint(" KSPROBE_MODIFY");
            }
            if (Config->IrpDisposition & KSPROBE_ALLOWFORMATCHANGE) {
                DbgPrint(" KSPROBE_ALLOWFORMATCHANGE");
            }
        }
    }

    DbgPrint("\n");
    DbgPrint("    StackDepth: %d\n",Config->StackDepth);
#endif
}


NTSTATUS
CKsPipeSection::
UnconfigureCompleteCircuit(
    IN PIKSTRANSPORT Top
    )

/*++

Routine Description:

    This routine unconfigures a completed circuit due to a failure in the 
    last stages of circuit acquisition.

Arguments:

    Top -
        Contains a pointer to the sink pin, requestor or splitter branch at 
        which unconfiguration will begin.

Return Value:

    STATUS_SUCCESS.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPipeSection::UnconfigureCompleteCircuit]"));
    _DbgPrintF(DEBUGLVL_CONFIG,("#### Pipe%p.UnconfigureCompleteCircuit",this));

    PAGED_CODE();

    ASSERT(Top);

    //
    // NOTE: MUSTCHECK:
    // 
    // This should be sufficient to hit everything in the circuit.  This
    // should be checked against a splitter with more than one branch to make
    // sure I'm reading this correctly.
    //
    NTSTATUS status = STATUS_SUCCESS;
    PIKSTRANSPORT transport = Top;
    do {

        PIKSTRANSPORT nextTransport;
        PIKSTRANSPORT prevTransport;

        transport -> ResetTransportConfig (
            &nextTransport,
            &prevTransport
            );

        transport = nextTransport;

    } while (transport != Top);

    return STATUS_SUCCESS;

}


NTSTATUS
CKsPipeSection::
ConfigureCompleteCircuit(
    IN PIKSTRANSPORT Top,
    IN PIKSTRANSPORT Next OPTIONAL
    )

/*++

Routine Description:

    This routine configures a complete transport circuit.

Arguments:

    Top -
        Contains a pointer to the sink pin, requestor or splitter branch at 
        which configuration will begin.

    Next -
        Contains a pointer to the component immediately following the top
        component.  If this argument is NULL, the pointer is obtained in
        a GetTransportConfig() call to the Top component.  This argument
        should be supplied if and only if Top is a splitter branch.

Return Value:

    STATUS_SUCCESS.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPipeSection::ConfigureCompleteCircuit]"));
    _DbgPrintF(DEBUGLVL_CONFIG,("#### Pipe%p.ConfigureCompleteCircuit",this));

    PAGED_CODE();

    ASSERT(Top);

    class CActivation 
    {
    public:
        CActivation* m_NextActivation;
        PIKSTRANSPORT m_Top;
        PIKSTRANSPORT m_Next;
        CActivation(
            IN CActivation* NextActivation,
            IN PIKSTRANSPORT Top,
            IN PIKSTRANSPORT Next
            ) :
            m_NextActivation(NextActivation),
            m_Top(Top),
            m_Next(Next)
        {
        }
    };
    CActivation* activations = NULL;

    NTSTATUS status = STATUS_SUCCESS;
    while (NT_SUCCESS(status)) {
        //
        // Get the configuration of the top component.
        // 
        KSPTRANSPORTCONFIG topConfig;
        PIKSTRANSPORT nextTransport;
        PIKSTRANSPORT prevTransport;
        Top->GetTransportConfig(
            &topConfig,
            &nextTransport,
            &prevTransport);

        _DbgPrintF(DEBUGLVL_CONFIG,("#### get config from top %p",Top));
        DbgPrintConfig(&topConfig,FALSE);

        KSPIRPDISPOSITION disposition;
        KSPIRPDISPOSITION topDisposition = topConfig.IrpDisposition;
        if (topConfig.TransportType == KSPTRANSPORTTYPE_REQUESTOR) {
            ASSERT(! Next);
            //
            // The top is a requestor.  Frames are allocated in kernel mode and
            // are either paged or non-paged.  Later, the requestor will need the
            // max stack depth and probe flags.  For now, we indicate the requestor
            // will not need to probe.  This may change as we look at the queues.
            //
            _DbgPrintF(DEBUGLVL_CONFIG,("#### top component is req%p",Top));
            disposition = KSPIRPDISPOSITION_NONE;
            topConfig.IrpDisposition = KSPIRPDISPOSITION_NONE;
        } else if (topConfig.TransportType & KSPTRANSPORTTYPE_PINSINK) {
            ASSERT(topConfig.TransportType & KSPTRANSPORTTYPE_PINEXTRA);
            ASSERT(! Next);
            //
            // The top is an external sink pin.  Because the frames are coming from
            // a foreign source (not the ), we need to probe the IRP using
            // KsProbeStreamIrp.  Exactly how we will do that is based on data
            // flow.  In any case, we need to use the MDL's system address rather
            // than the pointer in the header, and the IRP should be cancelled on
            // a flush.
            //
            _DbgPrintF(DEBUGLVL_CONFIG,("#### top component is pin%p",Top));
            disposition = 
                KSPIRPDISPOSITION_USEMDLADDRESS |
                KSPIRPDISPOSITION_CANCEL;

            if (topConfig.TransportType & KSPTRANSPORTTYPE_PINOUTPUT) {
                //
                // The top pin is an output.  This means we will treat this like
                // a read operation:  we will want to write to (and possibly read
                // from) the frame, and the header needs to get copied back.
                //
                disposition |= KSPIRPDISPOSITION_PROBEFORREAD;
            } else if (nextTransport == prevTransport) {
                //
                // The top pin is an input, and there is just one queue.  This 
                // means we will treat this like a write operation:  we will want
                // to read from the frame, and the header does not need to get
                // copied back.
                //
                disposition |= KSPIRPDISPOSITION_PROBEFORWRITE;
            } else {
                //
                // The top pin is an input, and there is more than just one queue.
                // This means we will treat this like a modify operation:  we will
                // want to read from and write to the frame, and the header does
                // not need to get copied back.
                //
                disposition |= KSPIRPDISPOSITION_PROBEFORMODIFY;
            }
        } else {
            ASSERT(topConfig.TransportType == KSPTRANSPORTTYPE_SPLITTERBRANCH);
            ASSERT(Next);
            //
            // The top is a splitter branch.  We are configuring a branch of the
            // pipe.
            //
            _DbgPrintF(DEBUGLVL_CONFIG,("#### top component is branch%p",Top));
            disposition = KSPIRPDISPOSITION_NONE;
        }

        for(PIKSTRANSPORT transport = Next ? Next : nextTransport; 
            NT_SUCCESS(status) && (transport != Top); 
            transport = nextTransport) {
            //
            // Get the configuration from this component.
            //
            KSPTRANSPORTCONFIG config;
            transport->GetTransportConfig(
                &config,
                &nextTransport,
                &prevTransport);

            _DbgPrintF(DEBUGLVL_CONFIG,("#### get config from component %p",transport));
            DbgPrintConfig(&config,FALSE);

            if (topConfig.StackDepth < config.StackDepth) {
                topConfig.StackDepth = config.StackDepth;
            }

            switch (config.TransportType) {
            case KSPTRANSPORTTYPE_PINSOURCE | KSPTRANSPORTTYPE_PINEXTRA | KSPTRANSPORTTYPE_PININPUT:
            case KSPTRANSPORTTYPE_PINSOURCE | KSPTRANSPORTTYPE_PINEXTRA | KSPTRANSPORTTYPE_PINOUTPUT:
                //
                // This is an external source pin.  We have its stack depth
                // already.
                //
                break;

            case KSPTRANSPORTTYPE_QUEUE:
                //
                // Queues may need to probe, and they need to be told whether to
                // cancel and whether to use the MDL address.
                //
                if (topConfig.TransportType == KSPTRANSPORTTYPE_REQUESTOR) {
                    //
                    // The top component is a requestor.  The queue will not need
                    // to probe, but the requestor may if the frames are paged or
                    // mdls are required.
                    //
                    if ((config.IrpDisposition & KSPIRPDISPOSITION_NEEDMDLS) ||
                        ((config.IrpDisposition & KSPIRPDISPOSITION_NEEDNONPAGED) &&
                         (topDisposition & KSPIRPDISPOSITION_ISPAGED))) {
                        topConfig.IrpDisposition = KSPIRPDISPOSITION_PROBEFORMODIFY;
                    }
                }

                //
                // Set the disposition on the queue.
                //
                config.IrpDisposition = disposition;
                transport->SetTransportConfig(
                    &config,
                    &nextTransport,
                    &prevTransport);

                _DbgPrintF(DEBUGLVL_CONFIG,("     set config to"));
                DbgPrintConfig(&config,TRUE);

                //
                // Once the IRPs are probed, they don't need to be probed again.
                //
                disposition &= ~KSPIRPDISPOSITION_PROBEFLAGMASK;
                break;

            case KSPTRANSPORTTYPE_SPLITTER:
            {
                //
                // Splitters may need to probe, and they need to be told whether to
                // cancel and whether to use the MDL address.  In addition, each
                // branch of the splitter needs to be programmed as if it were its
                // own circuit.
                //
                // Next and previous reporting through GetTransportConfig is a
                // little complex in the splitter case.  The intent is to traverse
                // the perimeter of the pipe, whether in the Next or Prev direction.
                // In a complete traversal of a circuit, a splitter is encountered
                // N+1 times where N is the number of branches.  Each time the
                // splitter is encountered, the actual interface obtained is
                // different.  Working from the trunk, the _SPLITTER is encountered
                // first, then the components on the first branch, then the
                // _SPLITTER_BRANCH corresponding to the first branch, then the
                // components on the second branch and so forth.  After encountering
                // the _SPLITTER_BRANCH for the last branch, traversal returns to
                // the trunk.
                //
                // For a 2-branch splitter, the Next and Prev reporting is as
                // follows:
                //
                // _SPLITTER:
                //      Next = _SPLITTER_BRANCH_1->Sink
                //      Prev = _SPLITTER_BRANCH_2->Source
                // _SPLITTER_BRANCH1:
                //      Next = _SPLITTER_BRANCH_2->Sink
                //      Prev = _SPLITTER->Source
                // _SPLITTER_BRANCH2:
                //      Next = _SPLITTER->Sink
                //      Prev = _SPLITTER_BRANCH_1->Source
                //
                // This is great if we want to walk the perimeter.  This 
                // function wants to iteratively address the branches instead.
                // When we hit a _SPLITTER, we want to enumerate the 
                // _SPLITTER_BRANCHes, using each one in turn as the Top of a
                // new circuit.  Because a branch's Next is not the first 
                // component in that branch, we specify Next as an argument
                // rather than using _SPLITTER_BRANCH->Next.
                //
                // We iterate using the nextTransport pointer obtained from the 
                // _SPLITTER.  This is not the _SPLITTER_BRANCH, but rather the 
                // first component in the branch.  To get the _SPLITTER_BRANCH
                // (the Top argument for the recursive call), we just get 
                // nextTransport->Prev.  nextTransport is updated for the next 
                // iteration by obtaining top->Next,  We stop after processing 
                // the last branch.
                //
                // TODO:  Surely the _SPLITTER requires some IrpDisposition stuff.
                while (1) {
                    //
                    // nextTransport points to the _SPLITTER_BRANCH's sink.  Get
                    // nextTransport->Prev to obtain the _SPLITTER_BRANCH.  This
                    // will be the Top argument for the recursive call.
                    //
                    PIKSTRANSPORT dontCare;
                    PIKSTRANSPORT top;
                    nextTransport->GetTransportConfig(
                        &config,
                        &dontCare,
                        &top);

                    //
                    // Save the 'recursive' call.  We pass nextTransport because
                    // the _SPLITTER_BRANCH does not report this as its Next.
                    //
                    CActivation* activation = 
                        new(PagedPool,POOLTAG_ACTIVATION) 
                            CActivation(activations,top,nextTransport);
                    if (! activation) {
                        status = STATUS_INSUFFICIENT_RESOURCES;
                        break;
                    }
                    activations = activation;

                    //
                    // If there are more branches, top->Next is the first component
                    // in the next branch.  If not, top->Next will be the next
                    // component on the trunk (_SPLITTER->Sink).  In either case,
                    // nextTransport is the place to put it.
                    //
                    top->GetTransportConfig(
                        &config,
                        &nextTransport,
                        &dontCare);

                    _DbgPrintF(DEBUGLVL_CONFIG,("     get branch%p config",top));
                    DbgPrintConfig(&config,FALSE);
                    ASSERT(config.TransportType == KSPTRANSPORTTYPE_SPLITTERBRANCH);

                    //
                    // If the branch we processed last time is the last branch,
                    // it's time to stop iterating.  nextTransport will be set
                    // to the first component on the trunk after the _SPLITTER.
                    // This is correct for the next iteration of the outer loop.
                    //
                    if (config.StackDepth == KSPSTACKDEPTH_LASTBRANCH) {
                        break;
                    }
                }
                break;
            }

            default:
                _DbgPrintF(DEBUGLVL_ERROR,("#### Pipe%p.ConfigureCompleteCircuit:  illegal component type %p",this,config.TransportType));
                status = STATUS_UNSUCCESSFUL;
                break;
            }
        }

        if (NT_SUCCESS(status)) {
            //
            // The top component needs stack depth and, if it's a requestor, the
            // IRP disposition.
            // 
            Top->SetTransportConfig(
                &topConfig,
                &nextTransport,
                &prevTransport);

            _DbgPrintF(DEBUGLVL_CONFIG,("     set top component config to"));
            DbgPrintConfig(&topConfig,TRUE);
        } else {
            //
            // Error.  Trash any pending activations.
            //
            while (activations) {
                CActivation* activation = activations;
                activations = activations->m_NextActivation;
                delete activation;
            }
        }

        if (! activations) {
            break;
        }

        CActivation* activation = activations;
        activations = activations->m_NextActivation;
        Top = activation->m_Top;
        Next = activation->m_Next;
        delete activation;
    } // while

    return status;
}


CKsPipeSection::
~CKsPipeSection(
    void
    )

/*++

Routine Description:

    This routine destructs a pipe object.

Arguments:

    None.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPipeSection::~CKsPipeSection(%p)]"));
    _DbgPrintF(DEBUGLVL_LIFETIME,("#### Pipe%p.~",this));

    PAGED_CODE();
}

void
DisconnectCircuit(
    IN PIKSTRANSPORT Transport
    )

/*++

Routine Description:

    This routine disconnects a circuit.

Arguments:

    Transport -
        Contains a pointer to a component in the circuit to disconnect.

Return Value:

    None.

--*/

{
    //
    // We are going to use Connect() to set the transport sink for each
    // component in turn to NULL.  Because Connect() takes care of the
    // back links, transport source pointers for each component will
    // also get set to NULL.  Connect() gives us a referenced pointer
    // to the previous transport sink for the component in question, so
    // we will need to do a release for each pointer obtained in this
    // way.  For consistency's sake, we will release the pointer we
    // start with (distribution) as well, so we need to AddRef it first.
    //
    Transport->AddRef();
    while (Transport) {
        PIKSTRANSPORT nextTransport;
        PIKSTRANSPORT branchTransport;
        Transport->Connect(NULL,&nextTransport,&branchTransport,KSPIN_DATAFLOW_OUT);
        if (branchTransport) {
            if (nextTransport) {
                DisconnectCircuit(branchTransport);
            } else {
                nextTransport = branchTransport;
            }
        }
        Transport->Release();
        Transport = nextTransport;
    }
}


void
CKsPipeSection::
UnbindProcessPins (
    )

/*++

Routine Description:

    Tells the pipe section to have the filter unbind any pins belonging 
    to this pipe section.

Arguments:

    None

Return Value:

    None

--*/

{

    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPipeSection::UnbindProcessPins(%p)]", this));

    PAGED_CODE ();

    m_Filter -> UnbindProcessPinsFromPipeSection (&m_ProcessPipeSection);

}


NTSTATUS 
CKsPipeSection::
SetDeviceState(
    IN PIKSPIN Pin OPTIONAL,
    IN KSSTATE NewState
    )

/*++

Routine Description:

    This routine sets the state of the pipe, informing all components in the
    pipe of the new state.  A transition to stop state destroys the pipe.

Arguments:

    Pin -
        Contains a pointer to the pin supplying the state change request.  The
        request is ignored if this pin does not control the pipe state.  If
        this argument is NULL, the state change is distributed in any case.
        This option is used for catastrophic shutdown of the circuit.

    NewState -
        The new state.

Return Value:

    Status.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPipeSection::SetDeviceState(%p)]",this));
    _DbgPrintF(DEBUGLVL_DEVICESTATE,("#### Pipe%p.SetDeviceState:  from %d to %d",this,m_DeviceState,NewState));

    PAGED_CODE();

    //
    // Ignore requests from any pin but the master.
    //
    if (Pin && (Pin != m_MasterPin)) {
        _DbgPrintF(DEBUGLVL_DEVICESTATE,("#### Pipe%p.SetDeviceState:  ignoring because pin%p is not master pin%p",this,Pin,m_MasterPin));
        return STATUS_SUCCESS;
    }

    KSSTATE state = m_DeviceState;
    KSSTATE targetState = NewState;

    NTSTATUS status = STATUS_SUCCESS;

    //
    // Determine if this pipe section controls the entire pipe.
    //
    PIKSTRANSPORT distribution;
    if (! Pin) {
        //
        // No pin was supplied, so we are shutting down under emergency 
        // conditions.  Find a requestor by hook or by crook.
        //
        IsCircuitComplete(&distribution);
        _DbgPrintF(DEBUGLVL_DEVICESTATE,("#### Pipe%p.SetDeviceState:  got distribution from IsCircuitComplete:  %p",this,distribution));
        m_EmergencyShutdown = TRUE;
    } else if (! m_ConfigurationSet) {
        //
        // The circuit is not complete.
        //
        _DbgPrintF(DEBUGLVL_DEVICESTATE,("#### Pipe%p.SetDeviceState:  circuit is not complete",this));
        return STATUS_DEVICE_NOT_READY;
    } else if (m_ProcessPipeSection.Requestor) {
        //
        // This section owns the requestor, so it does own the pipe, and the
        // requestor is the starting point for any distribution.
        //
        distribution = m_ProcessPipeSection.Requestor;
        _DbgPrintF(DEBUGLVL_DEVICESTATE,("#### Pipe%p.SetDeviceState:  req%p is distribution point",this,distribution));
    } else if (ProcessPinIsFrameSource(m_MasterPin->GetProcessPin())) {
        //
        // This section is at the top of an open circuit, so it does own the
        // pipe and the pin is the starting point for any distribution.
        //
        distribution = m_MasterPin;
        _DbgPrintF(DEBUGLVL_DEVICESTATE,("#### Pipe%p.SetDeviceState:  queue%p is distribution point",this,distribution));
    } else {
        //
        // This section does not own the pipe.
        //
        distribution = NULL;
        _DbgPrintF(DEBUGLVL_DEVICESTATE,("#### Pipe%p.SetDeviceState:  no distribution point",this));
    }

    //
    // Proceed sequentially through states.
    //
    while (state != targetState) {
        KSSTATE oldState = state;

        if (ULONG(state) < ULONG(targetState)) {
            state = KSSTATE(ULONG(state) + 1);
        } else {
            state = KSSTATE(ULONG(state) - 1);
        }

        //
        // If there is no queue, distribution to pin client callbacks will not
        // be handled automatically for this pipe section.  We do that part of
        // the distribution here instead.
        //
        NTSTATUS statusThisPass;
        if (m_ProcessPipeSection.Requestor && ! m_ProcessPipeSection.Queue) {
            statusThisPass = DistributeStateChangeToPins(state,oldState);
        } else {
            statusThisPass = STATUS_SUCCESS;
        }

        //
        // Distribute state changes if this section is in charge.
        //
        if (NT_SUCCESS(statusThisPass) && distribution) {
            statusThisPass = DistributeDeviceStateChange(distribution,state,oldState);
        }

        if (NT_SUCCESS(status) && ! NT_SUCCESS(statusThisPass)) {
            //
            // First failure:  go back to original state.
            //
            state = oldState;
            targetState = m_DeviceState;
            status = statusThisPass;
        }
    }

    m_DeviceState = state;

    //
    // Clear the emergency shutdown flag just for safety.
    //
    m_EmergencyShutdown = FALSE;

    if (state == KSSTATE_STOP) {
        //
        // Must disconnect the entire circuit.  We'll start at the pin if the
        // pin is not in charge.
        //
        if (! distribution) {
            distribution = Pin;
        }
        if (distribution) {
            _DbgPrintF(DEBUGLVL_VERBOSE,("#### Pipe%p.SetDeviceState:  disconnecting",this));
            DisconnectCircuit(distribution);
        }

        //
        // If there's no queue, unbind now; otherwise, the queue will be
        // responsible for unbinding when it chooses.
        //
        if (!m_ProcessPipeSection.Queue) 
            m_Filter->UnbindProcessPinsFromPipeSection(&m_ProcessPipeSection);

        //
        // Take a reference around these released because these two objects
        // may hold our only references.
        //
        AddRef();

        //
        // Dereference the queue if there is one.
        //
        if (m_ProcessPipeSection.Queue) {
            m_ProcessPipeSection.Queue->Release();
            m_ProcessPipeSection.Queue = NULL;
        }

        //
        // Dereference the requestor if there is one.
        //
        if (m_ProcessPipeSection.Requestor) {
            m_ProcessPipeSection.Requestor->Release();
            m_ProcessPipeSection.Requestor = NULL;
        }

        Release();
    }

    return status;
}

NTSTATUS
CKsPipeSection::
DistributeDeviceStateChange(
    IN PIKSTRANSPORT Transport,
    IN KSSTATE NewState,
    IN KSSTATE OldState
    )

/*++

Routine Description:

    This routine distributes a state change around the circuit.

Arguments:

    Transport -
        Contains a pointer to the first component to distribute the state
        change to.

    NewState -
        The new device state.

    OldState -
        The old device state.

Return Value:

    STATUS_SUCCESS or an error code from one of the components.

--*/

{
    //
    // Tell everyone about the state change.
    //
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPipeSection::DistributeDeviceStateChange(%p)] distributing transition from %d to %d",this,OldState,NewState));
    _DbgPrintF(DEBUGLVL_DEVICESTATE,("#### Pipe%p.DistributeDeviceStateChange:  from %d to %d",this,OldState,NewState));

    PAGED_CODE();

    ASSERT(Transport);

    //
    // Distribute the state change around the circuit.
    //
    NTSTATUS status = STATUS_SUCCESS;
    PIKSTRANSPORT previousTransport = NULL;
    while (Transport) {
        PIKSTRANSPORT nextTransport;
        status = 
            Transport->SetDeviceState(
                NewState,
                OldState,
                &nextTransport);

        if (NT_SUCCESS(status)) {
            previousTransport = Transport;
            Transport = nextTransport;
        } else {

            NTSTATUS backoutStatus;	

            //
            // Back out on failure.
            //
            _DbgPrintF(DEBUGLVL_DEVICESTATE,("#### Pipe%p.DistributeDeviceStateChange:  failed transition from %d to %d",this,OldState,NewState));
            while (previousTransport) {
                Transport = previousTransport;
                backoutStatus = 
                    Transport->SetDeviceState(
                        OldState,
                        NewState,
                        &previousTransport);

                ASSERT(NT_SUCCESS(backoutStatus) || ! previousTransport);
            }
            break;
        }
    }

    return status;
}


void 
CKsPipeSection::
SetResetState(
    IN PIKSPIN Pin,
    IN KSRESET NewState
    )

/*++

Routine Description:

    This routine informs transport components that the reset state has 
    changed.

Arguments:

    Pin -
        Contains a pointer to the pin supplying the state change request.  The
        request is ignored if this pin does not control the pipe state.

    NewState -
        The new reset state.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPipeSection::SetResetState]"));

    PAGED_CODE();

    ASSERT(Pin);

    //
    // Ignore requests from any pin but the master.
    //
    if (Pin != m_MasterPin) {
        return;
    }

    //
    // If this section of the pipe owns the requestor, or there is a 
    // non- pin up the pipe (so there's no bypass), this pipe is
    // in charge of telling all the components about state changes.
    //
    if (m_ProcessPipeSection.Requestor || m_MasterPin->GetStruct()->ConnectionIsExternal) {
        //
        // Set the state change around the circuit.
        //
        PIKSTRANSPORT transport = 
            m_ProcessPipeSection.Requestor ? PIKSTRANSPORT(m_ProcessPipeSection.Requestor) : PIKSTRANSPORT(m_ProcessPipeSection.Queue);

        while (transport) {
            transport->SetResetState(NewState,&transport);
        }

    }

    //
    // Forward the notification to all topologically related output pins.
    // It's a requirement that if we flush after EOS, we be able to
    // accept more data.  This means that the output queues have to 
    // stop shunting data all over the place.
    //
    // If we deliver to a section which isn't in charge, the section will 
    // simply (as always) ignore the message.
    //
    m_Filter->DeliverResetState(&m_ProcessPipeSection, NewState);

    m_ResetState = NewState;
}

#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif // ALLOC_PRAGMA


STDMETHODIMP_(void) 
CKsPipeSection::
GenerateConnectionEvents(
    IN ULONG OptionsFlags
    )

/*++

Routine Description:

    This routine tells pins associated with the pipe section to generate
    connection events.

Arguments:

    OptionsFlags -
        Contains the options flags from the stream header which is causing
        events to fire.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPipeSection::GenerateConnectionEvents]"));

    for(PKSPPROCESSPIN processPin = m_ProcessPipeSection.Inputs; 
        processPin; 
        processPin = processPin->Next) {
        KspPinInterface(processPin->Pin)->
            GenerateConnectionEvents(OptionsFlags);
    }
    for(processPin = m_ProcessPipeSection.Outputs; 
        processPin; 
        processPin = processPin->Next) {
        KspPinInterface(processPin->Pin)->
            GenerateConnectionEvents(OptionsFlags);
    }
}

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA


STDMETHODIMP_(NTSTATUS)
CKsPipeSection::
DistributeStateChangeToPins(
    IN KSSTATE NewState,
    IN KSSTATE OldState
    )

/*++

Routine Description:

    This routine tells pins associated with the pipe that the device state
    has changed.  This information is passed on to the client via the pin
    dispatch function.

Arguments:

    NewState -
        Contains the new device state.

    OldState -
        Contains the previous device state.

Return Value:

    Status.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPipeSection::DistributeStateChangeToPins]"));

    PAGED_CODE();

    NTSTATUS status = STATUS_SUCCESS;

    for(PKSPPROCESSPIN processPin = m_ProcessPipeSection.Inputs; 
        processPin; 
        processPin = processPin->Next) {
        status = KspPinInterface(processPin->Pin)->
            ClientSetDeviceState(NewState,OldState);
        if (! NT_SUCCESS(status)) {
#if DBG
            if (NewState < OldState) {
                _DbgPrintF(DEBUGLVL_TERSE,("#### Pipe%p.DistributeStateChangeToPins: Pin %p failed transition from %ld to %ld",this,KspPinInterface(processPin->Pin),OldState,NewState));
            }
#endif // DBG
                
            //
            // Only back out the changes if we're not stopping under emergency
            // conditions.  If we are, we ignore pin failure; otherwise,
            // we can indefinitely block a stop.
            //
            if (!m_EmergencyShutdown) {
                //
                // Failed!  Undo all the previous state changes.
                //
                for(PKSPPROCESSPIN processPinBack = 
                        m_ProcessPipeSection.Inputs; 
                    processPinBack != processPin; 
                    processPinBack = processPinBack->Next) {
                    KspPinInterface(processPinBack->Pin)->
                        ClientSetDeviceState(OldState,NewState);
                }
                break;
            } else {
                //
                // If we're running under emergency shutdown conditions,
                // we ignore any error the client returns.  We must attempt
                // to stop regardless of what happens.  Lie and say the client
                // succeeded, then keep going.
                //
                status = STATUS_SUCCESS;
            }

        }
    }
    if (NT_SUCCESS(status)) {
        for(processPin = m_ProcessPipeSection.Outputs; 
            processPin; 
            processPin = processPin->Next) {
            status = KspPinInterface(processPin->Pin)->
                ClientSetDeviceState(NewState,OldState);
            if (! NT_SUCCESS(status)) {
#if DBG
                if (NewState < OldState) {
                    _DbgPrintF(DEBUGLVL_TERSE,("#### Pipe%p.DistributeStateChangeToPins: Pin %p failed transition from %ld to %ld",this,KspPinInterface(processPin->Pin),OldState,NewState));
                }
#endif // DBG

                //
                // Only back out changes in non-emergency conditions.  See
                // above for comments.
                //
                if (!m_EmergencyShutdown) {
                    //
                    // Failed!  Undo all the previous state changes.
                    //
                    for(PKSPPROCESSPIN processPinBack = 
                            m_ProcessPipeSection.Inputs; 
                        processPinBack; 
                        processPinBack = processPinBack->Next) {
                        KspPinInterface(processPinBack->Pin)->
                            ClientSetDeviceState(OldState,NewState);
                    }
                    for(processPinBack = m_ProcessPipeSection.Outputs; 
                        processPinBack != processPin; 
                        processPinBack = processPinBack->Next) {
                        KspPinInterface(processPinBack->Pin)->
                            ClientSetDeviceState(OldState,NewState);
                    }
                    break;
                } else {
                    //
                    // Proceed even if the client fails when emergency stop
                    // happens.  See above for comments.
                    //
                    status = STATUS_SUCCESS;
                }
            }
        }
    }

    return status;
}

STDMETHODIMP_(void) 
CKsPipeSection::
ConfigurationSet(
    IN BOOLEAN Configured
    )

/*++

Routine Description:

    This routine indicates to the pipe that the configuration for associated
    transport components has been set or for some reason has been reset.

Arguments:

    Configured -
        Indicates whether the configuration for the associated transport
        components has been set.  If this is false, the pipe section is
        to consider itself no longer configured correctly.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsPipeSection::ConfigurationSet]"));

    PAGED_CODE();

    m_ConfigurationSet = Configured;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\ks\shreq.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    shreq.cpp

Abstract:

    This module contains the implementation of the kernel streaming 
    requestor object.

Author:

    Dale Sather  (DaleSat) 31-Jul-1998

--*/

#ifndef __KDEXT_ONLY__
#include "ksp.h"
#include <kcom.h>
#endif // __KDEXT_ONLY__

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA

//
// CKsRequestor is the implementation of the kernel requestor object.
//
class CKsRequestor:
    public IKsRequestor,
    public IKsWorkSink,
    public CBaseUnknown
{
#ifndef __KDEXT_ONLY__
private:
#else // __KDEXT_ONLY__
public:
#endif // __KDEXT_ONLY__
    PIKSTRANSPORT m_TransportSource;
    PIKSTRANSPORT m_TransportSink;
    PIKSPIPESECTION m_PipeSection;
    PIKSPIN m_Pin;
    PFILE_OBJECT m_AllocatorFileObject;
    KSSTREAMALLOCATOR_FUNCTIONTABLE m_AllocatorFunctionTable;
    KSSTREAMALLOCATOR_STATUS m_AllocatorStatus;
    ULONG m_StackSize;
    ULONG m_ProbeFlags;
    ULONG m_FrameSize;
    ULONG m_FrameCount;
    ULONG m_ActiveFrameCountPlusOne;
    BOOLEAN m_CloneFrameHeader;
    BOOLEAN m_Flushing;
    BOOLEAN m_EndOfStream;
    BOOLEAN m_PassiveLevelRetire;
    KSSTATE m_State;
    KEVENT m_StopEvent;

    INTERLOCKEDLIST_HEAD m_IrpsAvailable;
    INTERLOCKEDLIST_HEAD m_FrameHeadersAvailable;
    INTERLOCKEDLIST_HEAD m_FrameHeadersToRetire;

    WORK_QUEUE_ITEM m_WorkItem;
    PKSWORKER m_Worker;

    PIKSRETIREFRAME m_RetireFrame;
    PIKSIRPCOMPLETION m_IrpCompletion;

public:
    DEFINE_STD_UNKNOWN();

    CKsRequestor(PUNKNOWN OuterUnknown):
        CBaseUnknown(OuterUnknown) {
    }
    ~CKsRequestor();

    IMP_IKsRequestor;
    IMP_IKsWorkSink;

    NTSTATUS
    Init(
        IN PIKSPIPESECTION PipeSection,
        IN PIKSPIN Pin,
        IN PFILE_OBJECT AllocatorFileObject OPTIONAL,
        IN PIKSRETIREFRAME RetireFrame OPTIONAL,
        IN PIKSIRPCOMPLETION IrpCompletion OPTIONAL
        );

private:
    NTSTATUS
    Prime(
        void
        );
    PKSPFRAME_HEADER
    CloneFrameHeader(
        IN PKSPFRAME_HEADER FrameHeader
        );
    void
    RetireFrame(
        IN PKSPFRAME_HEADER FrameHeader,
        IN NTSTATUS Status
        );
    PKSPFRAME_HEADER
    GetAvailableFrameHeader(
        IN ULONG StreamHeaderSize OPTIONAL
        );
    void
    PutAvailableFrameHeader(
        IN PKSPFRAME_HEADER FrameHeader
        );
    PIRP
    GetAvailableIrp(
        void
        );
    void
    PutAvailableIrp(
        IN PIRP Irp
        );
    PIRP
    AllocateIrp(
        void
        );
    void
    FreeIrp(
        IN PIRP Irp
        )
    {
        IoFreeIrp(Irp);
    }
    PVOID
    AllocateFrameBuffer(
        void
        );
    void
    FreeFrameBuffer(
        IN PVOID Frame
        );
};

#ifndef __KDEXT_ONLY__

IMPLEMENT_STD_UNKNOWN(CKsRequestor)


NTSTATUS
KspCreateRequestor(
    OUT PIKSREQUESTOR* Requestor,
    IN PIKSPIPESECTION PipeSection,
    IN PIKSPIN Pin,
    IN PFILE_OBJECT AllocatorFileObject OPTIONAL,
    IN PIKSRETIREFRAME RetireFrame OPTIONAL,
    IN PIKSIRPCOMPLETION IrpCompletion OPTIONAL
    )

/*++

Routine Description:

    This routine creates a new requestor.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KspCreateRequestor]"));

    PAGED_CODE();

    ASSERT(Requestor);
    ASSERT(PipeSection);
    ASSERT(Pin);
    ASSERT((AllocatorFileObject == NULL) != (RetireFrame == NULL));

    NTSTATUS status;

    CKsRequestor *requestor =
        new(NonPagedPool,POOLTAG_REQUESTOR) CKsRequestor(NULL);

    if (requestor) {
        requestor->AddRef();

        status = 
            requestor->Init(
                PipeSection,
                Pin,
                AllocatorFileObject,
                RetireFrame,
                IrpCompletion);

        if (NT_SUCCESS(status)) {
            *Requestor = PIKSREQUESTOR(requestor);
        } else {
            requestor->Release();
        }
    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return status;
}


NTSTATUS
CKsRequestor::
Init(
    IN PIKSPIPESECTION PipeSection,
    IN PIKSPIN Pin,
    IN PFILE_OBJECT AllocatorFileObject OPTIONAL,
    IN PIKSRETIREFRAME RetireFrame OPTIONAL,
    IN PIKSIRPCOMPLETION IrpCompletion OPTIONAL
    )

/*++

Routine Description:

    This routine initializes a requestor object.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsRequestor::Init]"));

    PAGED_CODE();

    ASSERT(Pin);
    ASSERT((AllocatorFileObject == NULL) != (RetireFrame == NULL));

    m_PipeSection = PipeSection;
    m_PipeSection->AddRef();
    m_Pin = Pin;

    //
    // CHECK FOR SYSAUDIO ALLOCATOR HACK.
    //
    if (AllocatorFileObject == PFILE_OBJECT(-1)) {
        AllocatorFileObject = NULL;
        PKSPIN pin = Pin->GetStruct();
        if (pin->Descriptor->AllocatorFraming) {
            m_FrameSize = 
                pin->Descriptor->AllocatorFraming->
                    FramingItem[0].FramingRange.Range.MaxFrameSize;
            m_FrameCount = 
                pin->Descriptor->AllocatorFraming->
                    FramingItem[0].Frames;
            _DbgPrintF(DEBUGLVL_TERSE,("#### Req%p.Init:  using fake allocator:  frame size %d, count %d",this,m_FrameSize,m_FrameCount));
        }
    }

    m_AllocatorFileObject = AllocatorFileObject;

    m_IrpCompletion = IrpCompletion;

    m_CloneFrameHeader = TRUE;

    m_State = KSSTATE_STOP;
    m_Flushing = FALSE;
    m_EndOfStream = FALSE;

    //
    // This is a one-based count of IRPs in circulation.  We decrement it when
    // we go to stop state and block until it hits zero.
    //
    m_ActiveFrameCountPlusOne = 1;
    KeInitializeEvent(&m_StopEvent,SynchronizationEvent,FALSE);

    //
    // Initialize workers a look-asides.
    //
    InitializeInterlockedListHead(&m_IrpsAvailable);
    InitializeInterlockedListHead(&m_FrameHeadersAvailable);
    InitializeInterlockedListHead(&m_FrameHeadersToRetire);

    KsInitializeWorkSinkItem(&m_WorkItem,this);
    NTSTATUS status = KsRegisterCountedWorker(DelayedWorkQueue,&m_WorkItem,&m_Worker);

    //
    // Get the function table and status from the allocator if there is an 
    // allocator.
    //
    if (! NT_SUCCESS(status)) {
        //
        // Failed...do nothing.
        //
    } else if (m_AllocatorFileObject) {
        KSPROPERTY property;
        property.Set = KSPROPSETID_StreamAllocator;
        property.Id = KSPROPERTY_STREAMALLOCATOR_FUNCTIONTABLE;
        property.Flags = KSPROPERTY_TYPE_GET;

        ULONG bytesReturned;
        status =
            KsSynchronousIoControlDevice(
                m_AllocatorFileObject,
                KernelMode,
                IOCTL_KS_PROPERTY,
                PVOID(&property),
                sizeof(property),
                PVOID(&m_AllocatorFunctionTable),
                sizeof(m_AllocatorFunctionTable),
                &bytesReturned);

        if (NT_SUCCESS(status) && 
            (bytesReturned != sizeof(m_AllocatorFunctionTable))) {
            status = STATUS_INVALID_BUFFER_SIZE;
        }

        if (NT_SUCCESS(status)) {
            property.Id = KSPROPERTY_STREAMALLOCATOR_STATUS;

            status =
                KsSynchronousIoControlDevice(
                    m_AllocatorFileObject,
                    KernelMode,
                    IOCTL_KS_PROPERTY,
                    PVOID(&property),
                    sizeof(property),
                    PVOID(&m_AllocatorStatus),
                    sizeof(m_AllocatorStatus),
                    &bytesReturned);

            if (NT_SUCCESS(status) && 
                (bytesReturned != sizeof(m_AllocatorStatus))) {
                status = STATUS_INVALID_BUFFER_SIZE;
            }

            if (NT_SUCCESS(status)) {
                m_FrameSize = m_AllocatorStatus.Framing.FrameSize;
                m_FrameCount = m_AllocatorStatus.Framing.Frames;
                m_PassiveLevelRetire =
                    (m_AllocatorStatus.Framing.PoolType == PagedPool);

                _DbgPrintF(DEBUGLVL_VERBOSE,("#### Req%p.Init:  using allocator 0x%08x, size %d, count %d, pooltype=%d",this,m_AllocatorFileObject,m_FrameSize,m_FrameCount,m_AllocatorStatus.Framing.PoolType));

                ObReferenceObject(m_AllocatorFileObject);
            } else {
                _DbgPrintF(DEBUGLVL_TERSE,("#### Req%p.Init:  allocator failed status query: 0x%08x",this,status));
            }
        } else {
            _DbgPrintF(DEBUGLVL_TERSE,("#### Req%p.Init:  allocator failed function table query: 0x%08x",this,status));
        }

        if (! NT_SUCCESS(status)) {
            m_AllocatorFileObject = NULL;
        }
    } else if (RetireFrame) {
        //
        // Save a pointer to the frame retirement sink.
        //
        ASSERT(RetireFrame);

        m_RetireFrame = RetireFrame;
        m_RetireFrame->AddRef();
    }

    return status;
}


CKsRequestor::
~CKsRequestor(
    void
    )

/*++

Routine Description:

    This routine destructs a requestor object.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsRequestor::~CKsRequestor(0x%08x)]",this));
    _DbgPrintF(DEBUGLVL_VERBOSE,("#### Req%p.~",this));

    PAGED_CODE();

    ASSERT(! m_TransportSink);
    ASSERT(! m_TransportSource);

    //
    // Free all IRPs.
    //
    while (! IsListEmpty(&m_IrpsAvailable.ListEntry)) {
        PLIST_ENTRY listEntry = RemoveHeadList(&m_IrpsAvailable.ListEntry);
        PIRP irp = CONTAINING_RECORD(listEntry,IRP,Tail.Overlay.ListEntry);
        IoFreeIrp(irp);
    }

    //
    // Free all frame headers.
    //
    while (! IsListEmpty(&m_FrameHeadersAvailable.ListEntry)) {
        PLIST_ENTRY listEntry = RemoveHeadList(&m_FrameHeadersAvailable.ListEntry);
        PKSPFRAME_HEADER frameHeader = 
            CONTAINING_RECORD(listEntry,KSPFRAME_HEADER,ListEntry);
        ExFreePool(frameHeader);
    }

    //
    // Release the frame retirement sink.
    //
    if (m_RetireFrame) {
        m_RetireFrame->Release();
    }

    //
    // Release the Irp completion sink.
    //
    if (m_IrpCompletion) {
        m_IrpCompletion->Release();
    }

    //
    // Release the allocator.
    //
    if (m_AllocatorFileObject) {
        ObDereferenceObject(m_AllocatorFileObject);
        m_AllocatorFileObject = NULL;
    }

    //
    // Release the pipe.
    //
    if (m_PipeSection) {
        m_PipeSection->Release();
        m_PipeSection = NULL;
    }

    if (m_Worker) {
        KsUnregisterWorker (m_Worker);
    }

}


STDMETHODIMP_(NTSTATUS)
CKsRequestor::
NonDelegatedQueryInterface(
    IN REFIID InterfaceId,
    OUT PVOID* InterfacePointer
    )

/*++

Routine Description:

    This routine obtains an interface to a requestor object.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsRequestor::NonDelegatedQueryInterface]"));

    PAGED_CODE();

    ASSERT(InterfacePointer);

    NTSTATUS status = STATUS_SUCCESS;

    if (IsEqualGUIDAligned(InterfaceId,__uuidof(IKsTransport))) {
        *InterfacePointer = reinterpret_cast<PVOID>(static_cast<PIKSTRANSPORT>(this));
        AddRef();
    } else {
        status = CBaseUnknown::NonDelegatedQueryInterface(
            InterfaceId,InterfacePointer);
    }

    return status;
}

#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif // ALLOC_PRAGMA


STDMETHODIMP_(NTSTATUS)
CKsRequestor::
TransferKsIrp(
    IN PIRP Irp,
    IN PIKSTRANSPORT* NextTransport
    )

/*++

Routine Description:

    This routine handles the arrival of a streaming IRP.

Arguments:

    Irp -
        Contains a pointer to the streaming IRP to be transferred.

    NextTransport -
        Contains a pointer to a location at which to deposit a pointer
        to the next transport interface to recieve the IRP.  May be set
        to NULL indicating the IRP should not be forwarded further.

Return Value:

    Status.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsRequestor::TransferKsIrp]"));

    ASSERT(Irp);
    ASSERT(NextTransport);

    ASSERT(m_TransportSink);

    if (m_State != KSSTATE_RUN) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("#### Req%p.TransferKsIrp:  got IRP %p in state %d",this,Irp,m_State));
    }

    PKSSTREAM_HEADER streamHeader = PKSSTREAM_HEADER(Irp->UserBuffer);
    PKSPFRAME_HEADER frameHeader = 
        &CONTAINING_RECORD(
            streamHeader,
            KSPFRAME_HEADER_ATTACHED,
            StreamHeader)->FrameHeader;

    //
    // Check for end of stream.
    //
    if (streamHeader->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_ENDOFSTREAM) {
        m_EndOfStream = TRUE;
        _DbgPrintF(DEBUGLVL_VERBOSE,("#### Req%p.TransferKsIrp:  IRP %p is marked end-of-stream",this,Irp));
    }

    //
    // GFX:
    //
    // If the frame header has an associated stream pointer, delete the stream
    // pointer.  This will allow a blocked frame to be completed.
    //
    if (frameHeader->FrameHolder) {
        frameHeader->FrameHolder->Queue->DeleteStreamPointer (
            frameHeader->FrameHolder
            );
        frameHeader->FrameHolder = NULL;
    }

    //
    // Make the Irp transport completion callback for the Irp if one
    // exists.
    //
    if (m_IrpCompletion) {
        m_IrpCompletion->CompleteIrp (Irp);
    }

    NTSTATUS status;
    if (m_Flushing || 
        m_EndOfStream || 
        (m_State == KSSTATE_STOP) || 
        (m_State == KSSTATE_ACQUIRE) ||
        m_RetireFrame) {
        //
        // Stopping or retiring every frame...retire the frame.
        //
        RetireFrame(frameHeader,Irp->IoStatus.Status);

        *NextTransport = NULL;
        status = STATUS_PENDING;
    } else {
        //
        // Recondition and forward it.
        //
        ULONG streamHeaderSize = 
            IoGetCurrentIrpStackLocation(Irp)->
                Parameters.DeviceIoControl.OutputBufferLength;

        PVOID frame = streamHeader->Data;

        RtlZeroMemory(streamHeader,streamHeaderSize);
        streamHeader->Size = streamHeaderSize;
        streamHeader->Data = frame;
        streamHeader->FrameExtent = m_FrameSize;

        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = 0;
        Irp->PendingReturned = 0;
        Irp->Cancel = 0;

        *NextTransport = m_TransportSink;
        status = STATUS_SUCCESS;
    }

    return status;
}


STDMETHODIMP_(void)
CKsRequestor::
DiscardKsIrp(
    IN PIRP Irp,
    IN PIKSTRANSPORT* NextTransport
    )

/*++

Routine Description:

    This routine discards a streaming IRP.

Arguments:

    Irp -
        Contains a pointer to the streaming IRP to be discarded.

    NextTransport -
        Contains a pointer to a location at which to deposit a pointer
        to the next transport interface to recieve the IRP.  May be set
        to NULL indicating the IRP should not be forwarded further.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsRequestor::DiscardKsIrp]"));

    ASSERT(Irp);

    PKSPFRAME_HEADER frameHeader = 
        &CONTAINING_RECORD(
            Irp->UserBuffer,
            KSPFRAME_HEADER_ATTACHED,
            StreamHeader)->FrameHeader;

    //
    // GFX:
    //
    // If the frame header has an associated stream pointer, delete the stream
    // pointer.  This will allow a blocked frame to be completed.
    //
    if (frameHeader->FrameHolder) {
        frameHeader->FrameHolder->Queue->DeleteStreamPointer (
            frameHeader->FrameHolder
            );
        frameHeader->FrameHolder = NULL;
    }

    //
    // Make the Irp transport completion callback for the Irp if one
    // exists.
    //
    if (m_IrpCompletion) {
        m_IrpCompletion->CompleteIrp (Irp);
    }

    // TODO:  Do we really want to retire this?
    RetireFrame(frameHeader,Irp->IoStatus.Status);

    *NextTransport = NULL;
}

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA


STDMETHODIMP_(void)
CKsRequestor::
Connect(
    IN PIKSTRANSPORT NewTransport OPTIONAL,
    OUT PIKSTRANSPORT *OldTransport OPTIONAL,
    OUT PIKSTRANSPORT *BranchTransport OPTIONAL,
    IN KSPIN_DATAFLOW DataFlow
    )

/*++

Routine Description:

    This routine establishes a transport connection.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsRequestor::Connect]"));

    PAGED_CODE();

    KspStandardConnect(
        NewTransport,
        OldTransport,
        BranchTransport,
        DataFlow,
        PIKSTRANSPORT(this),
        &m_TransportSource,
        &m_TransportSink);
}


STDMETHODIMP_(NTSTATUS)
CKsRequestor::
SetDeviceState(
    IN KSSTATE NewState,
    IN KSSTATE OldState,
    IN PIKSTRANSPORT* NextTransport
    ) 

/*++

Routine Description:

    This routine handles notification that the device state has changed.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_DEVICESTATE,("#### Req%p.SetDeviceState:  set from %d to %d",this,OldState,NewState));

    PAGED_CODE();

    ASSERT(NextTransport);

    NTSTATUS status;

    //
    // If this is a change of state, note the new state and indicate the next
    // recipient.
    //
    if (m_State != NewState) {
        //
        // The state has changed.  Just note the new state, indicate the next
        // recipient, and get out.  We will get the same state change again
        // when it has gone all the way around the circuit.
        //
        m_State = NewState;

        if (NewState > OldState) {
            *NextTransport = m_TransportSink;
        } else {
            *NextTransport = m_TransportSource;
        }

        status = STATUS_SUCCESS;
    } else {
        //
        // The state change has gone all the way around the circuit and come
        // back.  All the other components are in the new state now.  For
        // transitions out of acquire state, there is work to be done.
        //
        *NextTransport = NULL;

        if (OldState == KSSTATE_ACQUIRE) {
            if (NewState == KSSTATE_PAUSE) {
                //
                // Acquire-to-pause requires us to prime.
                // HACK:  CALL PRIME WITH NO ALLOCATOR IF WE HAVE A FRAME SIZE.
                //
                if (m_AllocatorFileObject || m_FrameSize) {
                    status = Prime();
                } else {
                    status = STATUS_SUCCESS;
                }
            } else {
                //
                // Acquire-to-stop requires us to wait until all IRPs are home to 
                // roost.
                //
                if (InterlockedDecrement(PLONG(&m_ActiveFrameCountPlusOne))) {
#if DBG
                    _DbgPrintF(DEBUGLVL_TERSE,("#### Req%p.SetDeviceState:  waiting for %d active IRPs to return",this,m_ActiveFrameCountPlusOne));
                    LARGE_INTEGER timeout;
                    timeout.QuadPart = -150000000L;
                    status = 
                        KeWaitForSingleObject(
                            &m_StopEvent,
                            Suspended,
                            KernelMode,
                            FALSE,
                            &timeout);
                    if (status == STATUS_TIMEOUT) {
                    _DbgPrintF(DEBUGLVL_TERSE,("#### Req%p.SetDeviceState:  WAITED 15 SECONDS",this));
                    _DbgPrintF(DEBUGLVL_TERSE,("#### Req%p.SetDeviceState:  waiting for %d active IRPs to return",this,m_ActiveFrameCountPlusOne));
                    DbgPrintCircuit(this,1,0);
#endif
                    status = 
                        KeWaitForSingleObject(
                            &m_StopEvent,
                            Suspended,
                            KernelMode,
                            FALSE,
                            NULL);
#if DBG
                    }
                    _DbgPrintF(DEBUGLVL_TERSE,("#### Req%p.SetDeviceState:  done waiting",this));
#endif
                }
                status = STATUS_SUCCESS;
            }
        } else {
            //
            // Nothing to do.
            //
            status = STATUS_SUCCESS;
        }
    }

    return status;
}


NTSTATUS
CKsRequestor::
Prime(
    void
    ) 

/*++

Routine Description:

    This routine primes the requestor.

Arguments:

    None.

Return Value:

    Status.

--*/

{
    PAGED_CODE();

    ASSERT(m_Pin);
    ASSERT(m_FrameCount);
    ASSERT(m_FrameSize);

    //
    // Reset the end of stream indicator.
    //
    m_EndOfStream = FALSE;

    //
    // Perform one-time initialization of the frame header.
    //
    KSPFRAME_HEADER frameHeader;
    RtlZeroMemory(&frameHeader,sizeof(frameHeader));

    frameHeader.StreamHeaderSize = m_Pin->GetStruct()->StreamHeaderSize;
    if (frameHeader.StreamHeaderSize == 0) {
        frameHeader.StreamHeaderSize = sizeof(KSSTREAM_HEADER);
#if DBG
    } else {
        if (frameHeader.StreamHeaderSize < sizeof(KSSTREAM_HEADER)) {
            _DbgPrintF(DEBUGLVL_ERROR,("CLIENT BUG:  specified stream header size less than sizeof(KSSTREAM_HEADER)"));
        }
        if (frameHeader.StreamHeaderSize & FILE_QUAD_ALIGNMENT) {
            _DbgPrintF(DEBUGLVL_ERROR,("CLIENT BUG:  specified unaligned stream header size"));
        }
#endif
    }
    frameHeader.FrameBufferSize = m_FrameSize;

    //
    // Allocate and submit the right number of frames.  Since this can be
    // used to reprime the circuit after flushing, we only allocate enough
    // frames to bring us up to m_FrameCount.
    //
    NTSTATUS status = STATUS_SUCCESS;
    for (ULONG count = m_FrameCount - (m_ActiveFrameCountPlusOne - 1); 
        count--;) {

        frameHeader.FrameBuffer = AllocateFrameBuffer();

        if (! frameHeader.FrameBuffer) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            _DbgPrintF(DEBUGLVL_TERSE,("#### Req%p.Prime:  failed to allocate frame",this));
            break;
        }

        status = SubmitFrame(&frameHeader);

        if (! NT_SUCCESS(status)) {
            _DbgPrintF(DEBUGLVL_TERSE,("#### Req%p.Prime:  SubmitFrame failed",this));
            FreeFrameBuffer(frameHeader.FrameBuffer);
            break;
        }
    }

    return status;
}


STDMETHODIMP_(void)
CKsRequestor::
SetResetState(
    IN KSRESET ksReset,
    IN PIKSTRANSPORT* NextTransport
    )

/*++

Routine Description:

    This routine handles notification that the reset state has changed.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_VERBOSE,("[CKsRequestor::SetResetState] to %d",ksReset));

    PAGED_CODE();

    ASSERT(NextTransport);

    if (m_Flushing != (ksReset == KSRESET_BEGIN)) {
        *NextTransport = m_TransportSink;
        m_Flushing = (ksReset == KSRESET_BEGIN);
    } else {
        //
        // If an end reset comes back around to the requestor, it has completed
        // its distribution across the circuit.  Because we retired frames due
        // to either the flush / eos / etc..., we must reprime the circuit
        // as long as we are in an acceptable state to do so.
        //
        if (!m_Flushing) {
            if (m_State >= KSSTATE_PAUSE && 
                (m_AllocatorFileObject || m_FrameSize)) {

                //
                // Simply reprime the circuit.  We're safe from control
                // messages like stop happening because the owning pipe 
                // section's associated control mutex will be taken.  The
                // only thing we need to concern ourselves with is data flow.
                //
                // It's possible that an Irp somehow comes back during 
                // the reprime.  If that's the case, so what, we're sourcing
                // empty buffers.  The objects we're sending to should be
                // thread safe (queued).  
                //
                // Further, we should not be able to fail the prime due to
                // low memory at least in the requestor.  The Irps / Frame
                // Headers should have been tossed to a lookaside when the 
                // frame was retired.  The only way this is failing is 
                // if the Transfer fails.  That may happen, but there's not much
                // we can do about it.
                //
                Prime();

            }
        }
        *NextTransport = NULL;
    }
}


STDMETHODIMP_(void)
CKsRequestor::
GetTransportConfig(
    OUT PKSPTRANSPORTCONFIG Config,
    OUT PIKSTRANSPORT* NextTransport,
    OUT PIKSTRANSPORT* PrevTransport
    )

/*++

Routine Description:

    This routine gets transport configuration information.

Arguments:

    Config -
        Contains a pointer to the location where configuration requirements
        for this object should be deposited.

    NextTransport -
        Contains a pointer to the location at which the next transport
        interface should be deposited.

    PrevTransport -
        Contains a pointer to the location at which the previous transport
        interfaction should be deposited.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsRequestor::GetTransportConfig]"));

    PAGED_CODE();

    ASSERT(Config);
    ASSERT(NextTransport);
    ASSERT(PrevTransport);

    Config->TransportType = KSPTRANSPORTTYPE_REQUESTOR;

    Config->IrpDisposition = KSPIRPDISPOSITION_ISKERNELMODE;
    if (m_AllocatorFileObject && 
        (m_AllocatorStatus.Framing.PoolType == PagedPool)) {
        Config->IrpDisposition |= KSPIRPDISPOSITION_ISPAGED;
    } else {
        Config->IrpDisposition |= KSPIRPDISPOSITION_ISNONPAGED;
    }

    Config->StackDepth = 1;

    *NextTransport = m_TransportSink;
    *PrevTransport = m_TransportSource;
}


STDMETHODIMP_(void)
CKsRequestor::
SetTransportConfig(
    IN const KSPTRANSPORTCONFIG* Config,
    OUT PIKSTRANSPORT* NextTransport,
    OUT PIKSTRANSPORT* PrevTransport
    )

/*++

Routine Description:

    This routine sets transport configuration information.

Arguments:

    Config -
        Contains a pointer to the new configuration settings for this object.

    NextTransport -
        Contains a pointer to the location at which the next transport
        interface should be deposited.

    PrevTransport -
        Contains a pointer to the location at which the previous transport
        interfaction should be deposited.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsRequestor::SetTransportConfig]"));

    PAGED_CODE();

    ASSERT(Config);
    ASSERT(NextTransport);
    ASSERT(PrevTransport);

#if DBG
    if (Config->IrpDisposition == KSPIRPDISPOSITION_ROLLCALL) {
        ULONG references = AddRef() - 1; Release();
        DbgPrint("    Req%p refs=%d alloc=%p size=%d count=%d\n",this,references,m_AllocatorFileObject,m_FrameSize,m_FrameCount);
        if (Config->StackDepth) {
            DbgPrint("        active frame count = %d\n",m_ActiveFrameCountPlusOne);
            if (! IsListEmpty(&m_FrameHeadersToRetire.ListEntry)) {
                DbgPrint("        frame(s) ready to retire\n");
            }
        }
    } else 
#endif
    {
        if (m_PipeSection) {
            m_PipeSection->ConfigurationSet(TRUE);
        }
        if (! m_RetireFrame) {
            m_ProbeFlags = Config->IrpDisposition & KSPIRPDISPOSITION_PROBEFLAGMASK;
        }
        m_StackSize = Config->StackDepth;
        ASSERT(m_StackSize);
    }

    *NextTransport = m_TransportSink;
    *PrevTransport = m_TransportSource;
}


STDMETHODIMP_(void)
CKsRequestor::
ResetTransportConfig (
    OUT PIKSTRANSPORT* NextTransport,
    OUT PIKSTRANSPORT* PrevTransport
    )

/*++

Routine Description:

    Reset the transport configuration for the requestor.  This indicates that
    something is wrong with the pipe and that any previously set configuration
    is now invalid.

Arguments:

    NextTransport -
        Contains a pointer to the location at which the next transport
        interface should be depobranchd.

    PrevTransport -
        Contains a pointer to the location at which the previous transport
        interfaction should be depobranchd.

Return Value:

    None

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsRequestor::ResetTransportConfig]"));

    PAGED_CODE();

    ASSERT (NextTransport);
    ASSERT (PrevTransport);

    if (m_PipeSection) {
        m_PipeSection->ConfigurationSet(FALSE);
    }
    m_ProbeFlags = 0;
    m_StackSize = 0;

    *NextTransport = m_TransportSink;
    *PrevTransport = m_TransportSource;
}


STDMETHODIMP_(void)
CKsRequestor::
Work(
    void
    )

/*++

Routine Description:

    This routine performs work in a worker thread.  In particular, it retires
    frames.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsRequestor::Work]"));

    PAGED_CODE();

    //
    // Retire all frames in the queue.
    //
    do {
        PLIST_ENTRY listEntry = 
            ExInterlockedRemoveHeadList(
                &m_FrameHeadersToRetire.ListEntry,
                &m_FrameHeadersToRetire.SpinLock);

        ASSERT(listEntry);

        PKSPFRAME_HEADER frameHeader = 
            CONTAINING_RECORD(listEntry,KSPFRAME_HEADER,ListEntry);

        RetireFrame(frameHeader,STATUS_SUCCESS);
    } while (KsDecrementCountedWorker(m_Worker));
}

#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif // ALLOC_PRAGMA


PKSPFRAME_HEADER 
CKsRequestor::
CloneFrameHeader(
    IN PKSPFRAME_HEADER FrameHeader
    )

/*++

Routine Description:

    This routine makes a copy of a frame header.  If the StreamHeaderSize
    field of the submitted frame header is zero, the StreamHeader field must
    not be NULL, and the stream header pointer is copied to the new frame
    header.  If StreamHeaderSize is not zero, the new frame header will have
    an appended stream header.  In this case, if the StreamHeader field is
    not NULL, the supplied stream header is copied to the appended storage
    area.

Arguments:

    FrameHeader -
        Contains a pointer to the frame header to be copied.

Return Value:

    The clone, or NULL if memory could not be allocated for it.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsRequestor::CloneFrameHeader]"));

    ASSERT(FrameHeader->StreamHeader || FrameHeader->StreamHeaderSize);
    ASSERT((FrameHeader->FrameBuffer == NULL) == (FrameHeader->FrameBufferSize == 0));

    //
    // Allocate and initialize the frame header.
    //
    PKSPFRAME_HEADER frameHeader = GetAvailableFrameHeader(FrameHeader->StreamHeaderSize);
    if (frameHeader) {
        //
        // Initialize the stream header.
        //
        ASSERT(frameHeader->Irp == NULL);
        ASSERT(frameHeader->StreamHeader);
        ASSERT(frameHeader->StreamHeaderSize >= FrameHeader->StreamHeaderSize);

        PKSSTREAM_HEADER streamHeader = frameHeader->StreamHeader;
        ULONG streamHeaderSize = frameHeader->StreamHeaderSize;
        RtlCopyMemory(frameHeader,FrameHeader,sizeof(*frameHeader));
        frameHeader->StreamHeader = streamHeader;
        frameHeader->StreamHeaderSize = streamHeaderSize;
        frameHeader->ListEntry.Flink = NULL;
        frameHeader->ListEntry.Blink = NULL;
        frameHeader->RefCount = 0;

        if (FrameHeader->StreamHeader == NULL) {
            //
            // No stream header supplied - make one up.
            //
            RtlZeroMemory(frameHeader->StreamHeader,FrameHeader->StreamHeaderSize);
            frameHeader->StreamHeader->Size = FrameHeader->StreamHeaderSize;
            frameHeader->StreamHeader->Data = FrameHeader->FrameBuffer;
            frameHeader->StreamHeader->FrameExtent = FrameHeader->FrameBufferSize;
        } else if (FrameHeader->StreamHeaderSize) {
            //
            // Make a copy of the supplied stream header.
            //
            ASSERT(FrameHeader->StreamHeader->Size <= FrameHeader->StreamHeaderSize);
            RtlCopyMemory(
                frameHeader->StreamHeader,
                FrameHeader->StreamHeader,
                FrameHeader->StreamHeader->Size);
            frameHeader->StreamHeader->Data = FrameHeader->FrameBuffer;
        } else {
            //
            // Just reference the supplied stream header.
            //
            ASSERT(frameHeader->StreamHeaderSize == 0);
            frameHeader->StreamHeader = FrameHeader->StreamHeader;
        }
    }

    return frameHeader;
}


NTSTATUS 
CKsRequestor::
SubmitFrame(
    IN PKSPFRAME_HEADER FrameHeader
    )

/*++

Routine Description:

    This routine transfers a frame.

Arguments:

    FrameHeader -
        Contains a pointer to the frame header to transfer.

Return Value:

    Status.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsRequestor::SubmitFrame]"));

    ASSERT(FrameHeader);

    PKSPFRAME_HEADER frameHeader;

    //
    // Make a copy of the frame header, if required.
    //
    if (m_CloneFrameHeader) {
        frameHeader = CloneFrameHeader(FrameHeader);
        if (! frameHeader) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    } else {
        frameHeader = FrameHeader;
    }

    ASSERT(frameHeader->StreamHeader);
    ASSERT(frameHeader->StreamHeader->Size >= sizeof(KSSTREAM_HEADER));
    ASSERT((frameHeader->StreamHeader->Size & FILE_QUAD_ALIGNMENT) == 0);

    NTSTATUS status;

    //
    // Create an IRP, if required.
    //
    if (frameHeader->OriginalIrp) {
        frameHeader->Irp = frameHeader->OriginalIrp;
        status = STATUS_SUCCESS;
    } else {
        frameHeader->Irp = GetAvailableIrp();

        //
        // Initialize the IRP.
        //
        if (frameHeader->Irp) {
            frameHeader->Irp->MdlAddress = frameHeader->Mdl;

            frameHeader->Irp->AssociatedIrp.SystemBuffer = 
                frameHeader->Irp->UserBuffer = 
                    frameHeader->StreamHeader;

            IoGetCurrentIrpStackLocation(frameHeader->Irp)->
                Parameters.DeviceIoControl.OutputBufferLength = 
                    frameHeader->StreamHeader->Size;

            status = STATUS_SUCCESS;
        } else {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    //
    // Let KsProbeStreamIrp() prepare the IRP if necessary.
    //
    if (NT_SUCCESS(status) && m_ProbeFlags) {
        ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);
        status = KsProbeStreamIrp(frameHeader->Irp,m_ProbeFlags,0);
#if DBG
        if (! NT_SUCCESS(status)) {
            _DbgPrintF(DEBUGLVL_TERSE,("#### Req%p.SubmitFrame:  KsProbeStreamIrp failed:  %p",this,status));
        }
#endif
    }

    //
    // Send the IRP to the next component.
    //
    if (NT_SUCCESS(status)) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("#### Req%p.SubmitFrame:  transferring new IRP %p",this,frameHeader->Irp));

        status = KspTransferKsIrp(m_TransportSink,frameHeader->Irp);
#if DBG
        if (! NT_SUCCESS(status)) {
            _DbgPrintF(DEBUGLVL_TERSE,("#### Req%p.SubmitFrame:  reciever failed transfer call:  0x%08x",this,status));
        }
#endif
    }

    if (NT_SUCCESS(status) || (status == STATUS_MORE_PROCESSING_REQUIRED)) {
        //
        // Count the active IRPs.
        //
        InterlockedIncrement(PLONG(&m_ActiveFrameCountPlusOne));
        status = STATUS_SUCCESS;
    } else {
        //
        // Clean up on failure.
        //
        if (frameHeader->Irp && (frameHeader->Irp != frameHeader->OriginalIrp)) {
            PutAvailableIrp(frameHeader->Irp);
            frameHeader->Irp = NULL;
        }
        if (frameHeader != FrameHeader) {
            PutAvailableFrameHeader(frameHeader);
        }
    }

    return status;
}


void 
CKsRequestor::
RetireFrame(
    IN PKSPFRAME_HEADER FrameHeader,
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This routine retires a frame.

Arguments:

    FrameHeader -
        Contains a pointer to the frame header to be retired.

    Status -
        Contains the status of the preceding transfer for the benefit of
        a return callback.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsRequestor::RetireFrame]"));

    ASSERT(FrameHeader);

    //
    // Do this in a worker if that's required.
    //
    if (m_PassiveLevelRetire && (KeGetCurrentIrql() > PASSIVE_LEVEL)) {
        ExInterlockedInsertTailList(
            &m_FrameHeadersToRetire.ListEntry,
            &FrameHeader->ListEntry,
            &m_FrameHeadersToRetire.SpinLock);
        KsIncrementCountedWorker(m_Worker);
        return;
    }

    //
    // Get rid of the IRP.
    //
    if (FrameHeader->Irp && (FrameHeader->Irp != FrameHeader->OriginalIrp)) {
        //
        // Free MDLs.
        //
        if (FrameHeader->Irp->MdlAddress != FrameHeader->Mdl) {
            PMDL nextMdl;
            for(PMDL mdl = FrameHeader->Irp->MdlAddress; 
                mdl != NULL; 
                mdl = nextMdl) {
                nextMdl = mdl->Next;

                if (mdl->MdlFlags & MDL_PAGES_LOCKED) {
                    MmUnlockPages(mdl);
                }
                IoFreeMdl(mdl);
            }
        }

        FrameHeader->Irp->MdlAddress = NULL;

        //
        // Recycle the IRP.
        //
        _DbgPrintF(DEBUGLVL_VERBOSE,("#### Req%p.RetireFrame:  freeing IRP %p",this,FrameHeader->Irp));
        PutAvailableIrp(FrameHeader->Irp);
        FrameHeader->Irp = NULL;
    }

    //
    // If there is a sink for the frame header, use it.
    //
    if (m_RetireFrame) {
        m_RetireFrame->RetireFrame(FrameHeader,Status);
    } else {
        ASSERT(FrameHeader->OriginalIrp == NULL);
        ASSERT(FrameHeader->Mdl == NULL);
        ASSERT(m_CloneFrameHeader);

        if (FrameHeader->FrameBuffer) {
            FreeFrameBuffer(FrameHeader->FrameBuffer);
        }
    }

    //
    // Recycle the frame header.
    //
    if (m_CloneFrameHeader) {
        PutAvailableFrameHeader(FrameHeader);
    }

    //
    // Count the active frames.  If we have hit zero, this means that
    // another thread is waiting to finish a transition to stop state.
    //
    if (! InterlockedDecrement(PLONG(&m_ActiveFrameCountPlusOne))) {
        KeSetEvent(&m_StopEvent,IO_NO_INCREMENT,FALSE);
    }
}


PKSPFRAME_HEADER
CKsRequestor::
GetAvailableFrameHeader(
    IN ULONG StreamHeaderSize OPTIONAL
    )

/*++

Routine Description:

    This routine gets a frame header from the lookaside list or creates one,
    as required.

Arguments:

    StreamHeaderSize -
        Contains the minimum size for the stream header.

Return Value:

    The frame header or NULL if the lookaside list was empty.

--*/
{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsRequestor::GetAvailableFrameHeader]"));

    //
    // Get a frame header from the lookaside list.
    //
    PLIST_ENTRY listEntry =
        ExInterlockedRemoveHeadList(
            &m_FrameHeadersAvailable.ListEntry,
            &m_FrameHeadersAvailable.SpinLock);
    //
    // If we got one, be sure the stream header is the right size.  If not, we
    // free it.
    //
    PKSPFRAME_HEADER frameHeader;
    if (listEntry) {
        frameHeader = CONTAINING_RECORD(listEntry,KSPFRAME_HEADER,ListEntry);
        if (frameHeader->StreamHeaderSize < StreamHeaderSize) {
            ExFreePool(frameHeader);
            frameHeader = NULL;
        }
    } else {
        frameHeader = NULL;
    }

    //
    // Create a new frame header if we didn't get one already.
    //
    if (! frameHeader) {
        frameHeader = 
            reinterpret_cast<PKSPFRAME_HEADER>(
                ExAllocatePoolWithTag(
                    NonPagedPool,
                    sizeof(KSPFRAME_HEADER) + StreamHeaderSize,
                    'hFcP'));

        if (frameHeader) {
            //
            // If the stream header size is not 0, this is an 'attached' type
            // frame header, and we set the stream header pointer.  Otherwise,
            // the caller will provide the stream header later, and the size
            // field stays 0 to indicate the header is not attached.
            //
            // NOTE:  All frame headers will be attached type...for now.
            //
            RtlZeroMemory(frameHeader,sizeof(*frameHeader));
            if (StreamHeaderSize) {
                frameHeader->StreamHeader = 
                    reinterpret_cast<PKSSTREAM_HEADER>(frameHeader + 1);
                frameHeader->StreamHeaderSize = StreamHeaderSize;
            }
        }
    }

    return frameHeader;
}


void
CKsRequestor::
PutAvailableFrameHeader(
    IN PKSPFRAME_HEADER FrameHeader
    )

/*++

Routine Description:

    This routine puts a frame header to the lookaside list.

Arguments:

    FrameHeader -
        Contains a pointer to the frame header to be put in the lookaside list.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsRequestor::PutAvailableFrameHeader]"));

    ASSERT(FrameHeader);

    FrameHeader->OriginalIrp = NULL;
    FrameHeader->Mdl = NULL;
    FrameHeader->Irp = NULL;
    FrameHeader->FrameBuffer = NULL;

    ExInterlockedInsertTailList(
        &m_FrameHeadersAvailable.ListEntry,
        &FrameHeader->ListEntry,
        &m_FrameHeadersAvailable.SpinLock);
}


PIRP
CKsRequestor::
GetAvailableIrp(
    void
    )

/*++

Routine Description:

    This routine gets an IRP from the lookaside list or creates one, as
    required.

Arguments:

    None.

Return Value:

    The IRP or NULL if the lookaside list was empty.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsRequestor::GetAvailableIrp]"));

    PLIST_ENTRY listEntry =
        ExInterlockedRemoveHeadList(
            &m_IrpsAvailable.ListEntry,
            &m_IrpsAvailable.SpinLock);
    PIRP irp;
    if (listEntry) {
        irp = CONTAINING_RECORD(listEntry,IRP,Tail.Overlay.ListEntry);
    } else {
        irp = AllocateIrp();
    }

    return irp;
}


void
CKsRequestor::
PutAvailableIrp(
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine puts an IRP to the lookaside list.

Arguments:

    Irp -
        Contains a pointer to the IRP to be put in the lookaside list.

Return Value:

    None.

--*/
{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsRequestor::PutAvailableIrp]"));

    ASSERT(Irp);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    Irp->PendingReturned = 0;
    Irp->Cancel = 0;

    ExInterlockedInsertTailList(
        &m_IrpsAvailable.ListEntry,
        &Irp->Tail.Overlay.ListEntry,
        &m_IrpsAvailable.SpinLock);
}


PIRP
CKsRequestor::
AllocateIrp(
    void
    )

/*++

Routine Description:

    This routine allocates a new IRP for subframe transfer.

Arguments:

    None.

Return Value:

    The allocated IRP or NULL if an IRP could not be allocated.

--*/
{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsRequestor::AllocateIrp]"));

    ASSERT(m_StackSize);
    PIRP irp = IoAllocateIrp(CCHAR(m_StackSize),FALSE);

    if (irp) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("#### Req%p.AllocateIrp:  %p",this,irp));
        irp->RequestorMode = KernelMode;
        irp->Flags = IRP_NOCACHE;

        //
        // Set the stack pointer to the first location and fill it in.
        //
        IoSetNextIrpStackLocation(irp);

        PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(irp);
        irpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
        irpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_KS_READ_STREAM;
    } else {
        _DbgPrintF(DEBUGLVL_TERSE,("#### Req%p.AllocateIrp:  failed to allocate IRP",this));
    }

    return irp;
}


PVOID
CKsRequestor::
AllocateFrameBuffer(
    void
    ) 

/*++

Routine Description:

    This routine allocates a frame buffer.

Arguments:

    None.

Return Value:

    The allocated frame or NULL if no frame could be allocated.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsRequestor::AllocateFrameBuffer]"));

    //
    // HACK:  Just allocate a frame if there is no allocator.
    //
    if (! m_AllocatorFileObject) {
        return ExAllocatePoolWithTag(NonPagedPool,m_FrameSize,'kHsK');
    }

    ASSERT(m_AllocatorFileObject);

    PVOID frameBuffer;
    m_AllocatorFunctionTable.AllocateFrame(m_AllocatorFileObject,&frameBuffer);

    return frameBuffer;
}


void
CKsRequestor::
FreeFrameBuffer(
    IN PVOID FrameBuffer
    ) 

/*++

Routine Description:

    This routine frees a frame buffer.

Arguments:

    FrameBuffer -
        The frame buffer to free.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_VERBOSE,("[CKsRequestor::FreeFrameBuffer]"));

    //
    // HACK:  Just free the frame if there is no allocator.
    //
    if (! m_AllocatorFileObject) {
        ExFreePool(FrameBuffer);
        return;
    }

    ASSERT(m_AllocatorFileObject);

    m_AllocatorFunctionTable.FreeFrame(m_AllocatorFileObject,FrameBuffer);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\ks\shsplit.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    shsplit.cpp

Abstract:

    This module contains the implementation of the kernel streaming 
    splitter object.

Author:

    Dale Sather  (DaleSat) 31-Jul-1998

--*/

// Child IRP list for cancellation:  pin
// Sync/Async transfer:  queue
// Allocate IRPs/headers:  requestor

#ifndef __KDEXT_ONLY__
#include "ksp.h"
#include <kcom.h>
#endif // __KDEXT_ONLY__

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA

#define FRAME_HEADER_IRP_STORAGE(Irp)\
    *((PKSPPARENTFRAME_HEADER*)&Irp->Tail.Overlay.DriverContext[0])

typedef struct _KSSPLITPIN
{
    PKSPIN Pin;
    PKSSTREAM_HEADER StreamHeader;
} KSSPLITPIN, *PKSSPLITPIN;

typedef struct _KSPPARENTFRAME_HEADER
{
    LIST_ENTRY ListEntry;
    PIRP Irp;
    PKSSTREAM_HEADER StreamHeader;
    PVOID Data;
    PKSSPLITPIN SplitPins;
    ULONG StreamHeaderSize;
    ULONG ChildrenOut;
} KSPPARENTFRAME_HEADER, *PKSPPARENTFRAME_HEADER;

typedef struct _KSPSUBFRAME_HEADER
{
    LIST_ENTRY ListEntry;
    PIRP Irp;
    PKSPPARENTFRAME_HEADER ParentFrameHeader;
    KSSTREAM_HEADER StreamHeader;
} KSPSUBFRAME_HEADER, *PKSPSUBFRAME_HEADER;

/*

A list of child IRPs must be maintained for cancellation.  This is only needed
when the parent IRP is cancelled, because other pins in the circuit will handle
cancellation due to resets and stops.  The argument overlay used in the pin is
not used here because this would conflict with source pins that forward the
child IRPs.  The LIST_ENTRY and PIRP required for the child IRP resides in an
extension to the stream header.

The splitter 'branches' maintain lookaside lists of child IRPs with stream headers
to avoid allocation per arrival.  This will require prior knowledge of the 
number of IRPs required or PASSIVE_LEVEL execution to allocate new IRPs as 
required.  The lookaside list is freed when the circuit is destroyed.

*/

//
// CKsSplitter is the implementation of the kernel splitter object.
//
class CKsSplitter:
    public IKsSplitter,
    public CBaseUnknown
{
#ifndef __KDEXT_ONLY__
private:
#else  // __KDEXT_ONLY__
public:
#endif // __KDEXT_ONLY__
    PIKSTRANSPORT m_TransportSource;
    PIKSTRANSPORT m_TransportSink;
    BOOLEAN m_Flushing;
    KSSTATE m_State;
    BOOLEAN m_UseMdls;
    ULONG m_BranchCount;
    LIST_ENTRY m_BranchList;
    INTERLOCKEDLIST_HEAD m_FrameHeadersAvailable;
    INTERLOCKEDLIST_HEAD m_IrpsOutstanding;
    LONG m_IrpsWaitingToTransfer;
    LONG m_FailedRemoveCount;

public:
    DEFINE_LOG_CONTEXT(m_Log);
    DEFINE_STD_UNKNOWN();

    CKsSplitter(PUNKNOWN OuterUnknown):
        CBaseUnknown(OuterUnknown) {
    }
    ~CKsSplitter();

    IMP_IKsSplitter;

    NTSTATUS
    Init(
        IN PKSPIN Pin
        );
    PIKSTRANSPORT
    GetTransportSource(
        void
        )
    {
        return m_TransportSource;
    };
    PIKSTRANSPORT
    GetTransportSink(
        void
        )
    {
        return m_TransportSink;
    };
    void
    TransferParentIrp(
        void
        );
    static
    void
    CancelRoutine(
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp
        );

private:
    PKSPPARENTFRAME_HEADER
    NewFrameHeader(
        IN ULONG HeaderSize
        );
    void
    DeleteFrameHeader(
        IN PKSPPARENTFRAME_HEADER FrameHeader
        );
};

//
// CKsSplitterBranch is the implementation of the kernel splitter 
// branch object.
//
class CKsSplitterBranch:
    public IKsTransport,
    public CBaseUnknown
{
#ifndef __KDEXT_ONLY__
private:
#else // __KDEXT_ONLY__
public:
#endif // __KDEXT_ONLY__
    PIKSTRANSPORT m_TransportSource;
    PIKSTRANSPORT m_TransportSink;
    CKsSplitter* m_Splitter;
    PKSPIN m_Pin;
    ULONG m_Offset;
    ULONG m_Size;
    KS_COMPRESSION m_Compression;
    LIST_ENTRY m_ListEntry;
    PLIST_ENTRY m_ListHead;
    INTERLOCKEDLIST_HEAD m_IrpsAvailable;
    ULONG m_IoControlCode;
    ULONG m_StackSize;
    ULONG m_OutstandingIrpCount;

    ULONG m_DataUsed;
    ULONG m_FrameExtent;
    ULONG m_Irps;

public:
    DEFINE_LOG_CONTEXT(m_Log);
    DEFINE_STD_UNKNOWN();

    CKsSplitterBranch(PUNKNOWN OuterUnknown):
        CBaseUnknown(OuterUnknown) {
    }
    ~CKsSplitterBranch();

    IMP_IKsTransport;

    NTSTATUS
    Init(
        IN CKsSplitter* Splitter,
        IN PLIST_ENTRY ListHead,
        IN PKSPIN Pin,
        IN const KSALLOCATOR_FRAMING_EX* AllocatorFraming OPTIONAL
        );
    PIKSTRANSPORT
    GetTransportSource(
        void
        )
    {
        return m_TransportSource;
    };
    PIKSTRANSPORT
    GetTransportSink(
        void
        )
    {
        return m_TransportSink;
    };
    void
    Orphan(
        void
        )
    {
        if (m_Splitter) {
            m_Splitter = NULL;
            RemoveEntryList(&m_ListEntry);
        }
    }
    NTSTATUS
    TransferSubframe(
        IN PKSPSUBFRAME_HEADER SubframeHeader
        );

private:
    PIRP
    AllocateIrp(
        void
        );
    void
    FreeIrp(
        IN PIRP Irp
        )
    {
        IoFreeIrp(Irp);
    }

    friend CKsSplitter;
};

NTSTATUS
KspCreateSplitterBranch(
    OUT CKsSplitterBranch** SplitterBranch,
    IN CKsSplitter* Splitter,
    IN PLIST_ENTRY ListHead,
    IN PKSPIN Pin,
    IN const KSALLOCATOR_FRAMING_EX* AllocatorFraming OPTIONAL
    );

#ifndef __KDEXT_ONLY__

IMPLEMENT_STD_UNKNOWN(CKsSplitter)


NTSTATUS
KspCreateSplitter(
    OUT PIKSSPLITTER* Splitter,
    IN PKSPIN Pin
    )

/*++

Routine Description:

    This routine creates a new splitter.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KspCreateSplitter]"));

    PAGED_CODE();

    ASSERT(Splitter);
    ASSERT(Pin);

    NTSTATUS status;

    CKsSplitter *splitter =
        new(NonPagedPool,POOLTAG_SPLITTER) CKsSplitter(NULL);

    if (splitter) {
        splitter->AddRef();

        status = splitter->Init(Pin);

        if (NT_SUCCESS(status)) {
            *Splitter = splitter;
        } else {
            splitter->Release();
        }
    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return status;
}


NTSTATUS
CKsSplitter::
Init(
    IN PKSPIN Pin
    )

/*++

Routine Description:

    This routine initializes a splitter object.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsSplitter::Init]"));

    PAGED_CODE();

    ASSERT(Pin);

    m_State = KSSTATE_STOP;
    m_Flushing = FALSE;

    InitializeListHead(&m_BranchList);
    InitializeInterlockedListHead(&m_FrameHeadersAvailable);
    InitializeInterlockedListHead(&m_IrpsOutstanding);

    KsLogInitContext(&m_Log,Pin,this);
    KsLog(&m_Log,KSLOGCODE_SPLITTER_CREATE,NULL,NULL);

    return STATUS_SUCCESS;
}


CKsSplitter::
~CKsSplitter(
    void
    )

/*++

Routine Description:

    This routine destructs a splitter object.

Arguments:

    None.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsSplitter::~CKsSplitter(0x%08x)]",this));
    _DbgPrintF(DEBUGLVL_VERBOSE,("#### Split%p.~",this));

    PAGED_CODE();

    ASSERT(! m_TransportSink);
    ASSERT(! m_TransportSource);

    //
    // Release all the branches.
    //
    CKsSplitterBranch *prevBranch = NULL;
    while (! IsListEmpty(&m_BranchList)) {
        CKsSplitterBranch *branch =
            CONTAINING_RECORD(m_BranchList.Flink,CKsSplitterBranch,m_ListEntry);

        branch->Orphan();
        branch->Release();

        ASSERT(branch != prevBranch);
        prevBranch = branch;
    }

    KsLog(&m_Log,KSLOGCODE_SPLITTER_DESTROY,NULL,NULL);
}


STDMETHODIMP_(NTSTATUS)
CKsSplitter::
NonDelegatedQueryInterface(
    IN REFIID InterfaceId,
    OUT PVOID* InterfacePointer
    )

/*++

Routine Description:

    This routine obtains an interface to a splitter object.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsSplitter::NonDelegatedQueryInterface]"));

    PAGED_CODE();

    ASSERT(InterfacePointer);

    NTSTATUS status = STATUS_SUCCESS;

    if (IsEqualGUIDAligned(InterfaceId,__uuidof(IKsTransport)) ||
        IsEqualGUIDAligned(InterfaceId,__uuidof(IKsSplitter))) {
        *InterfacePointer = 
            reinterpret_cast<PVOID>(static_cast<PIKSSPLITTER>(this));
        AddRef();
    } else {
        status = 
            CBaseUnknown::NonDelegatedQueryInterface(
                InterfaceId,InterfacePointer);
    }

    return status;
}

#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif // ALLOC_PRAGMA


STDMETHODIMP_(NTSTATUS)
CKsSplitter::
TransferKsIrp(
    IN PIRP Irp,
    IN PIKSTRANSPORT* NextTransport
    )

/*++

Routine Description:

    This routine handles the arrival of a streaming IRP.

Arguments:

    Irp -
        Contains a pointer to the streaming IRP to be transferred.

    NextTransport -
        Contains a pointer to a location at which to deposit a pointer
        to the next transport interface to recieve the IRP.  May be set
        to NULL indicating the IRP should not be forwarded further.

Return Value:

    STATUS_PENDING or some error status.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsSplitter::TransferKsIrp]"));

    ASSERT(Irp);
    ASSERT(NextTransport);

    ASSERT(m_TransportSink);

    KsLog(&m_Log,KSLOGCODE_SPLITTER_RECV,Irp,NULL);

    if (m_State != KSSTATE_RUN) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("#### Split%p.TransferKsIrp:  got IRP %p in state %d",this,Irp,m_State));
    }

    //
    // Shunt non-successful Irps.
    //
    if (!NT_SUCCESS (Irp->IoStatus.Status)) {
        _DbgPrintF(DEBUGLVL_FLOWEXCEPTIONS,("#### Splitter%p.TransferKsIrp:  shunting irp%p",this,Irp));
        KsLog(&m_Log,KSLOGCODE_SPLITTER_SEND,Irp,NULL);
        *NextTransport = m_TransportSink;

        return STATUS_SUCCESS;
    }

    //
    // Get a pointer to the stream header.
    //
    PKSSTREAM_HEADER streamHeader = 
        reinterpret_cast<PKSSTREAM_HEADER>(Irp->AssociatedIrp.SystemBuffer);

    //
    // Get a frame header.
    //
    PKSPPARENTFRAME_HEADER frameHeader = NewFrameHeader(streamHeader->Size);
    if (! frameHeader) {
        _DbgPrintF(DEBUGLVL_TERSE,("#### Split%p.TransferKsIrp:  failed to allocate frame header for IRP %p",this,Irp));
        Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        KsLog(&m_Log,KSLOGCODE_SPLITTER_SEND,Irp,NULL);
        KspDiscardKsIrp(m_TransportSink,Irp);
        *NextTransport = NULL;
        return STATUS_PENDING;
    }

    //
    // Attach the frame header to the IRP.
    //
    FRAME_HEADER_IRP_STORAGE(Irp) = frameHeader;

    //
    // Initialize the frame header.
    //
    frameHeader->Irp = Irp;
    frameHeader->StreamHeader = streamHeader;
    frameHeader->Data = 
        m_UseMdls ? 
            MmGetSystemAddressForMdl(Irp->MdlAddress) : streamHeader->Data;

    //
    // Initialize the subframe headers.
    //
    PKSSPLITPIN splitPin = frameHeader->SplitPins;
    for(PLIST_ENTRY listEntry = m_BranchList.Flink; 
        listEntry != &m_BranchList; 
        listEntry = listEntry->Flink, splitPin++) {
        CKsSplitterBranch *branch =
            CONTAINING_RECORD(listEntry,CKsSplitterBranch,m_ListEntry);

        RtlCopyMemory(splitPin->StreamHeader,streamHeader,streamHeader->Size);
        splitPin->StreamHeader->Data = frameHeader->Data;

        if (branch->m_Compression.RatioNumerator) {
            splitPin->StreamHeader->FrameExtent = 
                ULONG((ULONGLONG(splitPin->StreamHeader->FrameExtent - 
                                 branch->m_Compression.RatioConstantMargin) * 
                       ULONGLONG(branch->m_Compression.RatioDenominator)) / 
                      ULONGLONG(branch->m_Compression.RatioNumerator));
        }
    }

    //
    // TODO non-trivial subframe
    // TODO multiple frames per IRP
    //
    frameHeader->ChildrenOut = m_BranchCount + 2;

    //
    // Transfer subframes to each branch.
    //
    splitPin = frameHeader->SplitPins;
    for(listEntry = m_BranchList.Flink; 
        listEntry != &m_BranchList; 
        listEntry = listEntry->Flink, splitPin++) {
        CKsSplitterBranch *branch =
            CONTAINING_RECORD(listEntry,CKsSplitterBranch,m_ListEntry);

        branch->TransferSubframe(
            CONTAINING_RECORD(
                splitPin->StreamHeader,
                KSPSUBFRAME_HEADER,
                StreamHeader));
    }

    //
    // Remove the count which prevents parent IRP transfer during setup.  If
    // the result is one, all children have come back.
    //
    if (InterlockedDecrement(PLONG(&frameHeader->ChildrenOut)) == 1) {
        KsLog(&m_Log,KSLOGCODE_SPLITTER_SEND,Irp,NULL);
        DeleteFrameHeader(frameHeader);
        *NextTransport = m_TransportSink;
    } else {
        *NextTransport = NULL;

        //
        // Add the IRP to the list of oustanding parent IRPs.  After this call
        // the IRP is cancelable, but we still have one count on it.  The
        // cancel routine will not complete the IRP until the count is gone.
        //
        IoMarkIrpPending(Irp);
        KsAddIrpToCancelableQueue(
            &m_IrpsOutstanding.ListEntry,
            &m_IrpsOutstanding.SpinLock,
            Irp,
            KsListEntryTail,
            CKsSplitter::CancelRoutine);

        if (InterlockedDecrement(PLONG(&frameHeader->ChildrenOut)) == 0) {
            TransferParentIrp();
        }
    }
    
    return STATUS_PENDING;
}


PKSPPARENTFRAME_HEADER
CKsSplitter::
NewFrameHeader(
    IN ULONG HeaderSize
    )

/*++

Routine Description:

    This routine obtains a new frame header.

Arguments:

    HeaderSize -
        Contains the size in bytes of the KSSTREAM_HEADERs to be allocated
        for subframes.

Return Value:

    A new frame header or NULL if memory could not be allocated.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsSplitter::NewFrameHeader]"));

    ASSERT(HeaderSize >= sizeof(KSSTREAM_HEADER));
    ASSERT((HeaderSize & FILE_QUAD_ALIGNMENT) == 0);
    ASSERT((sizeof(KSPPARENTFRAME_HEADER) & FILE_QUAD_ALIGNMENT) == 0);
    ASSERT((sizeof(KSPSUBFRAME_HEADER) & FILE_QUAD_ALIGNMENT) == 0);

    //
    // See if there is a frame header already available.
    //
    PLIST_ENTRY listEntry = 
        ExInterlockedRemoveHeadList(
            &m_FrameHeadersAvailable.ListEntry,
            &m_FrameHeadersAvailable.SpinLock);
    //
    // Make sure the stream headers are large enough.
    //
    PKSPPARENTFRAME_HEADER frameHeader;
    if (listEntry) {
        frameHeader = CONTAINING_RECORD(listEntry,KSPPARENTFRAME_HEADER,ListEntry);
        if (frameHeader->StreamHeaderSize >= HeaderSize) {
            return frameHeader;
        }
        ExFreePool(frameHeader);
    }

    //
    // Calculate size of frame/subframes/index
    //
    ULONG subframeHeaderSize =
        sizeof(KSPSUBFRAME_HEADER) + 
        HeaderSize - 
        sizeof(KSSTREAM_HEADER);
    ULONG size =
        sizeof(KSPPARENTFRAME_HEADER) + 
        m_BranchCount * (subframeHeaderSize + sizeof(KSSPLITPIN));

    frameHeader = reinterpret_cast<PKSPPARENTFRAME_HEADER>(
        ExAllocatePoolWithTag(NonPagedPool,size,POOLTAG_FRAMEHEADER));

    if (! frameHeader) {
        return NULL;
    }

    //
    // Zero the whole thing.
    //
    RtlZeroMemory(frameHeader,size);

    //
    // Locate the first subframe header.
    //
    PKSPSUBFRAME_HEADER subframeHeader = 
        reinterpret_cast<PKSPSUBFRAME_HEADER>(frameHeader + 1);

    //
    // Initialize the frame header.
    //
    frameHeader->SplitPins =
        reinterpret_cast<PKSSPLITPIN>(
            reinterpret_cast<PUCHAR>(subframeHeader) + 
                subframeHeaderSize * m_BranchCount);
    frameHeader->StreamHeaderSize = HeaderSize;

    //
    // Initialize the subframe headers and the index.
    //
    PKSSPLITPIN splitPin = frameHeader->SplitPins;
    for(listEntry = m_BranchList.Flink; 
        listEntry != &m_BranchList; 
        listEntry = listEntry->Flink, splitPin++) {
        CKsSplitterBranch *branch =
            CONTAINING_RECORD(listEntry,CKsSplitterBranch,m_ListEntry);
        splitPin->Pin = branch->m_Pin;
        splitPin->StreamHeader = &subframeHeader->StreamHeader;
        subframeHeader->ParentFrameHeader = frameHeader;

        subframeHeader = 
            reinterpret_cast<PKSPSUBFRAME_HEADER>(
                reinterpret_cast<PUCHAR>(subframeHeader) + 
                    subframeHeaderSize);
    }

    return frameHeader;
}


void
CKsSplitter::
DeleteFrameHeader(
    IN PKSPPARENTFRAME_HEADER FrameHeader
    )

/*++

Routine Description:

    This routine releases a frame header.

Arguments:

    FrameHeader -
        Contains a pointer to the frame header to be deleted.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsSplitter::NewFrameDeleteFrameHeaderHeader]"));

    ExInterlockedInsertTailList(
        &m_FrameHeadersAvailable.ListEntry,
        &FrameHeader->ListEntry,
        &m_FrameHeadersAvailable.SpinLock);
}


STDMETHODIMP_(void)
CKsSplitter::
DiscardKsIrp(
    IN PIRP Irp,
    IN PIKSTRANSPORT* NextTransport
    )

/*++

Routine Description:

    This routine handles the arrival of a streaming IRP.

Arguments:

    Irp -
        Contains a pointer to the streaming IRP to be discarded.

    NextTransport -
        Contains a pointer to a location at which to deposit a pointer
        to the next transport interface to recieve the IRP.  May be set
        to NULL indicating the IRP should not be forwarded further.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsSplitter::DiscardKsIrp]"));

    ASSERT(Irp);
    ASSERT(NextTransport);

    ASSERT(m_TransportSink);

    *NextTransport = m_TransportSink;
}

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA


STDMETHODIMP_(void)
CKsSplitter::
Connect(
    IN PIKSTRANSPORT NewTransport OPTIONAL,
    OUT PIKSTRANSPORT *OldTransport OPTIONAL,
    OUT PIKSTRANSPORT *BranchTransport OPTIONAL,
    IN KSPIN_DATAFLOW DataFlow
    )

/*++

Routine Description:

    This routine establishes a transport connection.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsSplitter::Connect]"));

    PAGED_CODE();

    if (BranchTransport) {
        if (IsListEmpty(&m_BranchList)) {
            *BranchTransport = NULL;
        } else if (DataFlow == KSPIN_DATAFLOW_OUT) {
            *BranchTransport =
                CONTAINING_RECORD(
                    m_BranchList.Flink,
                    CKsSplitterBranch,
                    m_ListEntry);
        } else {
            *BranchTransport =
                CONTAINING_RECORD(
                    m_BranchList.Blink,
                    CKsSplitterBranch,
                    m_ListEntry);
        }
    }

    KspStandardConnect(
        NewTransport,
        OldTransport,
        NULL,
        DataFlow,
        PIKSTRANSPORT(this),
        &m_TransportSource,
        &m_TransportSink);
}


STDMETHODIMP_(NTSTATUS)
CKsSplitter::
SetDeviceState(
    IN KSSTATE NewState,
    IN KSSTATE OldState,
    IN PIKSTRANSPORT* NextTransport
    ) 

/*++

Routine Description:

    This routine handles notification that the device state has changed.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_DEVICESTATE,("#### Split%p.SetDeviceState:  set from %d to %d",this,OldState,NewState));

    PAGED_CODE();

    ASSERT(NextTransport);

    NTSTATUS status;

    //
    // If this is a change of state, note the new state and indicate the next
    // recipient.
    //
    if (m_State != NewState) {
        //
        // The state has changed.
        //
        m_State = NewState;

        if (IsListEmpty(&m_BranchList)) {
            if (NewState > OldState) {
                *NextTransport = m_TransportSink;
            } else {
                *NextTransport = m_TransportSource;
            }
        } else {
            if (NewState > OldState) {
                *NextTransport =
                    CONTAINING_RECORD(
                        m_BranchList.Flink,
                        CKsSplitterBranch,
                        m_ListEntry)->GetTransportSink();
            } else {
                *NextTransport =
                    CONTAINING_RECORD(
                        m_BranchList.Blink,
                        CKsSplitterBranch,
                        m_ListEntry)->GetTransportSource();
            }
        }

        status = STATUS_SUCCESS;
    } else {
        status = STATUS_SUCCESS;
    }

    return status;
}


STDMETHODIMP_(void)
CKsSplitter::
GetTransportConfig(
    OUT PKSPTRANSPORTCONFIG Config,
    OUT PIKSTRANSPORT* NextTransport,
    OUT PIKSTRANSPORT* PrevTransport
    )

/*++

Routine Description:

    This routine gets transport configuration information.

Arguments:

    Config -
        Contains a pointer to the location where configuration requirements
        for this object should be depobranchd.

    NextTransport -
        Contains a pointer to the location at which the next transport
        interface should be depobranchd.

    PrevTransport -
        Contains a pointer to the location at which the previous transport
        interfaction should be depobranchd.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsSplitter::GetTransportConfig]"));

    PAGED_CODE();

    ASSERT(Config);
    ASSERT(NextTransport);
    ASSERT(PrevTransport);

    Config->TransportType = KSPTRANSPORTTYPE_SPLITTER;
    Config->IrpDisposition = KSPIRPDISPOSITION_NONE;
    Config->StackDepth = 1;

    if (IsListEmpty(&m_BranchList)) {
        *PrevTransport = m_TransportSource;
        *NextTransport = m_TransportSink;
    } else {
        *PrevTransport =
            CONTAINING_RECORD(
                m_BranchList.Blink,
                CKsSplitterBranch,
                m_ListEntry)->GetTransportSource();
        *NextTransport =
            CONTAINING_RECORD(
                m_BranchList.Flink,
                CKsSplitterBranch,
                m_ListEntry)->GetTransportSink();
    }
}


STDMETHODIMP_(void)
CKsSplitter::
SetTransportConfig(
    IN const KSPTRANSPORTCONFIG* Config,
    OUT PIKSTRANSPORT* NextTransport,
    OUT PIKSTRANSPORT* PrevTransport
    )

/*++

Routine Description:

    This routine sets transport configuration information.

Arguments:

    Config -
        Contains a pointer to the new configuration settings for this object.

    NextTransport -
        Contains a pointer to the location at which the next transport
        interface should be depobranchd.

    PrevTransport -
        Contains a pointer to the location at which the previous transport
        interfaction should be depobranchd.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsSplitter::SetTransportConfig]"));

    PAGED_CODE();

    ASSERT(Config);
    ASSERT(NextTransport);
    ASSERT(PrevTransport);

#if DBG
    if (Config->IrpDisposition == KSPIRPDISPOSITION_ROLLCALL) {
        ULONG references = AddRef() - 1; Release();
        DbgPrint("    Split%p refs=%d\n",this,references);
        if (Config->StackDepth) {
            DbgPrint("        IRPs waiting to transfer = %d\n",m_IrpsWaitingToTransfer);
            DbgPrint("        failed removes = %d\n",m_FailedRemoveCount);
            DbgPrint("        IRPs outstanding\n");
            KIRQL oldIrql;
            KeAcquireSpinLock(&m_IrpsOutstanding.SpinLock,&oldIrql);
            for(PLIST_ENTRY listEntry = m_IrpsOutstanding.ListEntry.Flink;
                listEntry != &m_IrpsOutstanding.ListEntry;
                listEntry = listEntry->Flink) {
                    PIRP irp = 
                        CONTAINING_RECORD(listEntry,IRP,Tail.Overlay.ListEntry);
                    PKSPPARENTFRAME_HEADER frameHeader = 
                        FRAME_HEADER_IRP_STORAGE(irp);
                    DbgPrint("            IRP %p, %d branches outstanding\n",irp,frameHeader->ChildrenOut);
                    PKSSPLITPIN splitPin = frameHeader->SplitPins;
                    for (ULONG count = m_BranchCount; count--; splitPin++) {
                        PKSPSUBFRAME_HEADER subframeHeader =
                            CONTAINING_RECORD(splitPin->StreamHeader,KSPSUBFRAME_HEADER,StreamHeader);
                        if (subframeHeader->Irp) {
                            DbgPrint("                branch IRP %p, pin%p\n",subframeHeader->Irp,splitPin->Pin);
                        }
                    }
            }
            KeReleaseSpinLock(&m_IrpsOutstanding.SpinLock,oldIrql);
        }
    } else 
#endif
    {
        m_UseMdls = (Config->IrpDisposition & KSPIRPDISPOSITION_USEMDLADDRESS) != 0;
    }

    if (IsListEmpty(&m_BranchList)) {
        *PrevTransport = m_TransportSource;
        *NextTransport = m_TransportSink;
    } else {
        *PrevTransport =
            CONTAINING_RECORD(
                m_BranchList.Blink,
                CKsSplitterBranch,
                m_ListEntry)->GetTransportSource();
        *NextTransport =
            CONTAINING_RECORD(
                m_BranchList.Flink,
                CKsSplitterBranch,
                m_ListEntry)->GetTransportSink();
    }
}



STDMETHODIMP_(void)
CKsSplitter::
ResetTransportConfig (
    OUT PIKSTRANSPORT* NextTransport,
    OUT PIKSTRANSPORT* PrevTransport
    )

/*++

Routine Description:

    Reset the transport configuration of the splitter.  This indicates that
    something is wrong with the pipe and the previously set configuration is
    no longer valid.

Arguments:

    None

Return Value:

    None

--*/

{

    _DbgPrintF(DEBUGLVL_BLAB,("[CKsSplitter::ResetTransportConfig]"));

    PAGED_CODE ();

    ASSERT (NextTransport);
    ASSERT (PrevTransport);

    m_UseMdls = 0;

    if (IsListEmpty(&m_BranchList)) {
        *PrevTransport = m_TransportSource;
        *NextTransport = m_TransportSink;
    } else {
        *PrevTransport =
            CONTAINING_RECORD(
                m_BranchList.Blink,
                CKsSplitterBranch,
                m_ListEntry)->GetTransportSource();
        *NextTransport =
            CONTAINING_RECORD(
                m_BranchList.Flink,
                CKsSplitterBranch,
                m_ListEntry)->GetTransportSink();
    }
}


STDMETHODIMP_(void)
CKsSplitter::
SetResetState(
    IN KSRESET ksReset,
    IN PIKSTRANSPORT* NextTransport
    )

/*++

Routine Description:

    This routine handles notification that the reset state has changed.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_VERBOSE,("[CKsSplitter::SetResetState] to %d",ksReset));

    PAGED_CODE();

    ASSERT(NextTransport);

    if (m_Flushing != (ksReset == KSRESET_BEGIN)) {
        if (IsListEmpty(&m_BranchList)) {
            *NextTransport = m_TransportSink;
        } else {
            *NextTransport =
                CONTAINING_RECORD(
                    m_BranchList.Flink,
                    CKsSplitterBranch,
                    m_ListEntry)->GetTransportSink();
        }
        m_Flushing = (ksReset == KSRESET_BEGIN);
    } else {
        *NextTransport = NULL;
    }
}

STDMETHODIMP_(NTSTATUS)
CKsSplitter::
AddBranch(
    IN PKSPIN Pin,
    IN const KSALLOCATOR_FRAMING_EX* AllocatorFraming OPTIONAL
    )

/*++

Routine Description:

    This routine adds a new branch (branch) to a splitter.

Arguments:

    Pin -
        Contains a pointer to the pin to be associated with the new branch.

    AllocatorFraming -
        Contains an optional pointer to allocator framing information for
        use in establishing default subframe allocation.

Return Value:

    STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsSplitter::AddBranch]"));

    ASSERT(Pin);

    CKsSplitterBranch* branch;
    NTSTATUS status = 
        KspCreateSplitterBranch(
            &branch,
            this,
            &m_BranchList,
            Pin,
            AllocatorFraming);

    //
    // The branch is still referenced by the splitter.
    //
    if (NT_SUCCESS(status)) {
        branch->Release();
        m_BranchCount++;
    }

    return status;
}

#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif // ALLOC_PRAGMA


void
CKsSplitter::
TransferParentIrp(
    void
    )

/*++

Routine Description:

    This routine transfers parent IRPs whose children have all returned.  It
    starts at the head of the m_IrpsOutstanding queue and stops when it runs
    out of IRPs or returns as many IRPs as are waiting to transfer.

Arguments:

    None.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsSplitter::TransferParentIrp]"));

    ASSERT(m_TransportSink);
    InterlockedIncrement(&m_IrpsWaitingToTransfer);

    while (m_IrpsWaitingToTransfer) {
        //
        // Get an IRP from the head of the queue.
        //
        PIRP irp =
            KsRemoveIrpFromCancelableQueue(
                &m_IrpsOutstanding.ListEntry,
                &m_IrpsOutstanding.SpinLock,
                KsListEntryHead,
                KsAcquireOnly);

        //
        // If none were available, quit.
        //
        if (! irp) {
            InterlockedIncrement(&m_FailedRemoveCount);
            break;
        }

        //
        // Determine if the IRP is ready to be transferred.
        //
        PKSPPARENTFRAME_HEADER frameHeader = FRAME_HEADER_IRP_STORAGE(irp);
        if (InterlockedCompareExchange(PLONG(&frameHeader->ChildrenOut),1,0) == 0) {
            //
            // This IRP is ready to be transferred.  Remove it, delete its header,
            // transfer it, and decrement the waiting count.
            //
            KsRemoveSpecificIrpFromCancelableQueue(irp);
            DeleteFrameHeader(frameHeader);
            KsLog(&m_Log,KSLOGCODE_SPLITTER_SEND,irp,NULL);
            KspTransferKsIrp(m_TransportSink,irp);
            InterlockedDecrement(&m_IrpsWaitingToTransfer);
        } else {
            //
            // This IRP has children out.
            //
            KsReleaseIrpOnCancelableQueue(irp,CKsSplitter::CancelRoutine);
            break;
        }
    }
}


void
CKsSplitter::
CancelRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    ASSERT(DeviceObject);
    ASSERT(Irp);

    //
    // Mark the IRP cancelled and call the standard routine.  Doing the
    // marking first has the effect of not completing the IRP in the standard
    // routine.  The standard routine removes the IRP from the queue and
    // releases the cancel spin lock.
    //
    Irp->IoStatus.Status = STATUS_CANCELLED;
    KsCancelRoutine(DeviceObject,Irp);

    //
    // TODO:  Cancel child IRPs
    //

    IoCompleteRequest(Irp,IO_NO_INCREMENT);
}

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA

IMPLEMENT_STD_UNKNOWN(CKsSplitterBranch)


NTSTATUS
KspCreateSplitterBranch(
    OUT CKsSplitterBranch** SplitterBranch,
    IN CKsSplitter* Splitter,
    IN PLIST_ENTRY ListHead,
    IN PKSPIN Pin,
    IN const KSALLOCATOR_FRAMING_EX* AllocatorFraming OPTIONAL
    )

/*++

Routine Description:

    This routine creates a new splitter branch.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[KspCreateSplitterBranch]"));

    PAGED_CODE();

    ASSERT(SplitterBranch);
    ASSERT(Splitter);
    ASSERT(ListHead);
    ASSERT(Pin);

    NTSTATUS status;

    CKsSplitterBranch *branch =
        new(NonPagedPool,POOLTAG_SPLITTERBRANCH) CKsSplitterBranch(NULL);

    if (branch) {
        branch->AddRef();

        status = branch->Init(Splitter,ListHead,Pin,AllocatorFraming);

        if (NT_SUCCESS(status)) {
            *SplitterBranch = branch;
        } else {
            branch->Release();
        }
    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return status;
}


NTSTATUS
CKsSplitterBranch::
Init(
    IN CKsSplitter* Splitter,
    IN PLIST_ENTRY ListHead,
    IN PKSPIN Pin,
    IN const KSALLOCATOR_FRAMING_EX* AllocatorFraming OPTIONAL
    )

/*++

Routine Description:

    This routine initializes a splitter branch object.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsSplitterBranch::Init]"));

    PAGED_CODE();

    ASSERT(Splitter);
    ASSERT(ListHead);
    ASSERT(Pin);

    m_Splitter = Splitter;
    m_ListHead = ListHead;
    m_Pin = Pin;
    m_IoControlCode = 
        (Pin->DataFlow == KSPIN_DATAFLOW_IN) ? 
            IOCTL_KS_READ_STREAM : 
            IOCTL_KS_WRITE_STREAM;

    if (AllocatorFraming &&
        (AllocatorFraming->OutputCompression.RatioNumerator > 
         AllocatorFraming->OutputCompression.RatioDenominator)) {
        m_Compression = AllocatorFraming->OutputCompression;
    }

    InitializeInterlockedListHead(&m_IrpsAvailable);

    //
    // Add this branch to the list and add the resulting reference.
    //
    InsertTailList(ListHead,&m_ListEntry);
    AddRef();

    //
    // Connect to the pin in both directions.
    //
    PIKSTRANSPORT pinTransport =
        CONTAINING_RECORD(Pin,KSPIN_EXT,Public)->Interface;

    Connect(pinTransport,NULL,NULL,KSPIN_DATAFLOW_IN);
    Connect(pinTransport,NULL,NULL,KSPIN_DATAFLOW_OUT);

    KsLogInitContext(&m_Log,Pin,this);
    KsLog(&m_Log,KSLOGCODE_BRANCH_CREATE,NULL,NULL);

    return STATUS_SUCCESS;
}


CKsSplitterBranch::
~CKsSplitterBranch(
    void
    )

/*++

Routine Description:

    This routine destructs a splitter branch object.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsSplitterBranch::~CKsSplitterBranch(0x%08x)]",this));
    _DbgPrintF(DEBUGLVL_VERBOSE,("#### Branch%p.~",this));
    if (m_DataUsed) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("#### Branch%p.~:  m_DataUsed=%d",this,m_DataUsed));
    }
    if (m_FrameExtent) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("#### Branch%p.~:  m_FrameExtent=%d",this,m_FrameExtent));
    }
    if (m_Irps) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("#### Branch%p.~:  m_Irps=%d",this,m_Irps));
    }

    PAGED_CODE();

    ASSERT(! m_TransportSink);
    ASSERT(! m_TransportSource);

    Orphan();

    //
    // Free all IRPs.
    //
    while (! IsListEmpty(&m_IrpsAvailable.ListEntry)) {
        PLIST_ENTRY listEntry = RemoveHeadList(&m_IrpsAvailable.ListEntry);
        PIRP irp = CONTAINING_RECORD(listEntry,IRP,Tail.Overlay.ListEntry);
        FreeIrp(irp);
        _DbgPrintF(DEBUGLVL_VERBOSE,("#### Branch%p.~:  freeing IRP %p",this,irp));
    }

    KsLog(&m_Log,KSLOGCODE_BRANCH_DESTROY,NULL,NULL);
}


STDMETHODIMP_(NTSTATUS)
CKsSplitterBranch::
NonDelegatedQueryInterface(
    IN REFIID InterfaceId,
    OUT PVOID* InterfacePointer
    )

/*++

Routine Description:

    This routine obtains an interface to a splitter branch object.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsSplitterBranch::NonDelegatedQueryInterface]"));

    PAGED_CODE();

    ASSERT(InterfacePointer);

    NTSTATUS status = STATUS_SUCCESS;

    if (IsEqualGUIDAligned(InterfaceId,__uuidof(IKsTransport))) {
        *InterfacePointer = 
            reinterpret_cast<PVOID>(static_cast<PIKSTRANSPORT>(this));
        AddRef();
    } else {
        status = 
            CBaseUnknown::NonDelegatedQueryInterface(
                InterfaceId,InterfacePointer);
    }

    return status;
}

#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif // ALLOC_PRAGMA


STDMETHODIMP_(NTSTATUS)
CKsSplitterBranch::
TransferKsIrp(
    IN PIRP Irp,
    IN PIKSTRANSPORT* NextTransport
    )

/*++

Routine Description:

    This routine handles the arrival of a streaming IRP.

Arguments:

    Irp -
        Contains a pointer to the streaming IRP to be transferred.

    NextTransport -
        Contains a pointer to a location at which to deposit a pointer
        to the next transport interface to recieve the IRP.  May be set
        to NULL indicating the IRP should not be forwarded further.

Return Value:

    STATUS_PENDING or some error status.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsSplitterBranch::TransferKsIrp]"));

    ASSERT(Irp);
    ASSERT(NextTransport);

    ASSERT(m_TransportSink);

    KsLog(&m_Log,KSLOGCODE_BRANCH_RECV,Irp,NULL);

    InterlockedDecrement(PLONG(&m_OutstandingIrpCount));

    //
    // Get the subframe header from the imbedded stream header.
    //
    PKSPSUBFRAME_HEADER subframeHeader = 
        CONTAINING_RECORD(
            Irp->AssociatedIrp.SystemBuffer,KSPSUBFRAME_HEADER,StreamHeader);

    //
    // Make sure the parent header's DataUsed is no smaller than the offset of
    // this subframe plus its DataUsed.
    //
    // TODO:  The client should be able to do this.  The default would be
    // cheaper to calculate if the subframe with the largest offset was
    // tagged in advance.
    //
    ULONG dataUsed =
        subframeHeader->StreamHeader.DataUsed +
        ULONG(
            PUCHAR(subframeHeader->StreamHeader.Data) - 
            PUCHAR(subframeHeader->ParentFrameHeader->Data));

    PKSSTREAM_HEADER parentHeader =
        subframeHeader->ParentFrameHeader->StreamHeader;
    if (parentHeader->DataUsed < dataUsed) {
        parentHeader->DataUsed = dataUsed;
    }

    parentHeader->OptionsFlags |= 
        subframeHeader->StreamHeader.OptionsFlags & 
            KSSTREAM_HEADER_OPTIONSF_ENDOFSTREAM;

    //
    // Free MDL(s).
    //
    PMDL nextMdl;
    for (PMDL mdl = Irp->MdlAddress; mdl != NULL; mdl = nextMdl) {
        nextMdl = mdl->Next;

        if (mdl->MdlFlags & MDL_PAGES_LOCKED) {
            MmUnlockPages(mdl);
        }
        IoFreeMdl(mdl);
    }

    Irp->MdlAddress = NULL;

    //
    // Put the IRP on the list of available IRPs.  Do this before transferring
    // the parent in case the transfer results in the arrival of another
    // parent.
    //
    ExInterlockedInsertTailList(
        &m_IrpsAvailable.ListEntry,
        &Irp->Tail.Overlay.ListEntry,
        &m_IrpsAvailable.SpinLock);

    subframeHeader->Irp = NULL;

    //
    // If this was the last subframe, the parent IRP must be transferred.
    //
    if (InterlockedDecrement(PLONG(&subframeHeader->ParentFrameHeader->ChildrenOut)) == 0) {
        m_Splitter->TransferParentIrp();
    }

    //
    // The child IRP is not going anywhere right now.
    //
    *NextTransport = NULL;

    return STATUS_PENDING;
}


STDMETHODIMP_(void)
CKsSplitterBranch::
DiscardKsIrp(
    IN PIRP Irp,
    IN PIKSTRANSPORT* NextTransport
    )

/*++

Routine Description:

    This routine handles the arrival of a streaming IRP.

Arguments:

    Irp -
        Contains a pointer to the streaming IRP to be discarded.

    NextTransport -
        Contains a pointer to a location at which to deposit a pointer
        to the next transport interface to recieve the IRP.  May be set
        to NULL indicating the IRP should not be forwarded further.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsSplitterBranch::DiscardKsIrp]"));
    _DbgPrintF(DEBUGLVL_VERBOSE,("#### Branch%p.DiscardKsIrp:  %p",this,Irp));

    ASSERT(Irp);
    ASSERT(NextTransport);

    TransferKsIrp(Irp,NextTransport);
}

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA


STDMETHODIMP_(void)
CKsSplitterBranch::
Connect(
    IN PIKSTRANSPORT NewTransport OPTIONAL,
    OUT PIKSTRANSPORT *OldTransport OPTIONAL,
    OUT PIKSTRANSPORT *BranchTransport OPTIONAL,
    IN KSPIN_DATAFLOW DataFlow
    )

/*++

Routine Description:

    This routine establishes a transport connection.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsSplitterBranch::Connect]"));

    PAGED_CODE();

    if (BranchTransport) {
        if (! m_Splitter) {
            *BranchTransport = NULL;
        } else if (DataFlow == KSPIN_DATAFLOW_OUT) {
            if (m_ListEntry.Flink != m_ListHead) {
                *BranchTransport =
                    CONTAINING_RECORD(
                        m_ListEntry.Flink,
                        CKsSplitterBranch,
                        m_ListEntry);
            } else {
                *BranchTransport = NULL;
            }
        } else {
            if (m_ListEntry.Blink != m_ListHead) {
                *BranchTransport =
                    CONTAINING_RECORD(
                        m_ListEntry.Blink,
                        CKsSplitterBranch,
                        m_ListEntry);
            } else {
                *BranchTransport = NULL;
            }
        }
    }

    KspStandardConnect(
        NewTransport,
        OldTransport,
        NULL,
        DataFlow,
        PIKSTRANSPORT(this),
        &m_TransportSource,
        &m_TransportSink);
}


STDMETHODIMP_(NTSTATUS)
CKsSplitterBranch::
SetDeviceState(
    IN KSSTATE NewState,
    IN KSSTATE OldState,
    IN PIKSTRANSPORT* NextTransport
    ) 

/*++

Routine Description:

    This routine handles notification that the device state has changed.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_DEVICESTATE,("#### SplitBranch%p.SetDeviceState:  set from %d to %d",this,OldState,NewState));

    PAGED_CODE();

    ASSERT(NextTransport);

    //
    // Direction is based on sign of the state delta.
    //
    if (NewState > OldState) {
        //
        // If there is a next branch, go to its sink, otherwise go to the
        // splitter's sink.
        //
        if (m_ListEntry.Flink != m_ListHead) {
            *NextTransport =
                CONTAINING_RECORD(
                    m_ListEntry.Flink,
                    CKsSplitterBranch,
                    m_ListEntry)->GetTransportSink();
        } else {
            *NextTransport = m_Splitter->GetTransportSink();
        }
    } else {
        //
        // If there is a next branch, go to its source, otherwise go to the
        // splitter's source.
        //
        if (m_ListEntry.Blink != m_ListHead) {
            *NextTransport =
                CONTAINING_RECORD(
                    m_ListEntry.Blink,
                    CKsSplitterBranch,
                    m_ListEntry)->GetTransportSource();
        } else {
            *NextTransport = m_Splitter->GetTransportSource();
        }
    }

    return STATUS_SUCCESS;
}


STDMETHODIMP_(void)
CKsSplitterBranch::
GetTransportConfig(
    OUT PKSPTRANSPORTCONFIG Config,
    OUT PIKSTRANSPORT* NextTransport,
    OUT PIKSTRANSPORT* PrevTransport
    )

/*++

Routine Description:

    This routine gets transport configuration information.

Arguments:

    Config -
        Contains a pointer to the location where configuration requirements
        for this object should be depobranchd.

    NextTransport -
        Contains a pointer to the location at which the next transport
        interface should be depobranchd.

    PrevTransport -
        Contains a pointer to the location at which the previous transport
        interfaction should be depobranchd.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsSplitterBranch::GetTransportConfig]"));

    PAGED_CODE();

    ASSERT(Config);
    ASSERT(NextTransport);
    ASSERT(PrevTransport);

    Config->TransportType = KSPTRANSPORTTYPE_SPLITTERBRANCH;
    Config->IrpDisposition = KSPIRPDISPOSITION_NONE;
    Config->StackDepth = 1;

    if (m_ListEntry.Blink != m_ListHead) {
        *PrevTransport =
            CONTAINING_RECORD(
                m_ListEntry.Blink,
                CKsSplitterBranch,
                m_ListEntry)->GetTransportSource();
    } else {
        Config->StackDepth = KSPSTACKDEPTH_FIRSTBRANCH;
        *PrevTransport = m_Splitter->GetTransportSource();
    }

    if (m_ListEntry.Flink != m_ListHead) {
        *NextTransport =
            CONTAINING_RECORD(
                m_ListEntry.Flink,
                CKsSplitterBranch,
                m_ListEntry)->GetTransportSink();
    } else {
        Config->StackDepth = KSPSTACKDEPTH_LASTBRANCH;
        *NextTransport = m_Splitter->GetTransportSink();
    }
}


STDMETHODIMP_(void)
CKsSplitterBranch::
SetTransportConfig(
    IN const KSPTRANSPORTCONFIG* Config,
    OUT PIKSTRANSPORT* NextTransport,
    OUT PIKSTRANSPORT* PrevTransport
    )

/*++

Routine Description:

    This routine sets transport configuration information.

Arguments:

    Config -
        Contains a pointer to the new configuration settings for this object.

    NextTransport -
        Contains a pointer to the location at which the next transport
        interface should be depobranchd.

    PrevTransport -
        Contains a pointer to the location at which the previous transport
        interfaction should be depobranchd.

Return Value:

    None.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsSplitterBranch::SetTransportConfig]"));

    PAGED_CODE();

    ASSERT(Config);
    ASSERT(NextTransport);
    ASSERT(PrevTransport);

#if DBG
    if (Config->IrpDisposition == KSPIRPDISPOSITION_ROLLCALL) {
        ULONG references = AddRef() - 1; Release();
        DbgPrint("    Branch%p refs=%d\n",this,references);
    } else 
#endif
    {
        m_StackSize = Config->StackDepth;
        ASSERT(m_StackSize);
    }

    if (m_ListEntry.Blink != m_ListHead) {
        *PrevTransport =
            CONTAINING_RECORD(
                m_ListEntry.Blink,
                CKsSplitterBranch,
                m_ListEntry)->GetTransportSource();
    } else {
        *PrevTransport = m_Splitter->GetTransportSource();
    }

    if (m_ListEntry.Flink != m_ListHead) {
        *NextTransport =
            CONTAINING_RECORD(
                m_ListEntry.Flink,
                CKsSplitterBranch,
                m_ListEntry)->GetTransportSink();
    } else {
        *NextTransport = m_Splitter->GetTransportSink();
    }
}


STDMETHODIMP_(void)
CKsSplitterBranch::
ResetTransportConfig(
    OUT PIKSTRANSPORT* NextTransport,
    OUT PIKSTRANSPORT* PrevTransport
    )

/*++

Routine Description:

    Reset the transport configuration of the branch.  This indicates that
    something is wrong with the pipe and the previously set configuration is
    no longer valid.

Arguments:

    NextTransport -
        Contains a pointer to the location at which the next transport
        interface should be depobranchd.

    PrevTransport -
        Contains a pointer to the location at which the previous transport
        interfaction should be depobranchd.

Return Value:

    None

--*/

{

    _DbgPrintF(DEBUGLVL_BLAB,("[CKsSplitterBranch::ResetTransportConfig]"));

    PAGED_CODE ();

    ASSERT (NextTransport);
    ASSERT (PrevTransport);
    
    m_StackSize = 0;

    if (m_ListEntry.Blink != m_ListHead) {
        *PrevTransport =
            CONTAINING_RECORD(
                m_ListEntry.Blink,
                CKsSplitterBranch,
                m_ListEntry)->GetTransportSource();
    } else {
        *PrevTransport = m_Splitter->GetTransportSource();
    }

    if (m_ListEntry.Flink != m_ListHead) {
        *NextTransport =
            CONTAINING_RECORD(
                m_ListEntry.Flink,
                CKsSplitterBranch,
                m_ListEntry)->GetTransportSink();
    } else {
        *NextTransport = m_Splitter->GetTransportSink();
    }

}


STDMETHODIMP_(void)
CKsSplitterBranch::
SetResetState(
    IN KSRESET ksReset,
    IN PIKSTRANSPORT* NextTransport
    )

/*++

Routine Description:

    This routine handles notification that the reset state has changed.

Arguments:

Return Value:

--*/

{
    _DbgPrintF(DEBUGLVL_VERBOSE,("[CKsSplitterBranch::SetResetState] to %d",ksReset));

    PAGED_CODE();

    ASSERT(NextTransport);

    //
    // If there is a next branch, go to its sink, otherwise go to the
    // splitter's sink.
    //
    if (m_ListEntry.Flink != m_ListHead) {
        *NextTransport =
            CONTAINING_RECORD(
                m_ListEntry.Flink,
                CKsSplitterBranch,
                m_ListEntry)->GetTransportSink();
    } else {
        *NextTransport = m_Splitter->GetTransportSink();
    }
}

#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif // ALLOC_PRAGMA


NTSTATUS
CKsSplitterBranch::
TransferSubframe(
    IN PKSPSUBFRAME_HEADER SubframeHeader
    )

/*++

Routine Description:

    This routine transfers a subframe from a splitter branch.

Arguments:

    SubframeHeader -
        Contains a pointer to the header of the subframe to transfer.

Return Value:

    STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES.

--*/

{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsSplitterBranch::TransferSubframe]"));

    ASSERT(SubframeHeader);

    //
    // Count stuff.
    //
    m_DataUsed += SubframeHeader->StreamHeader.DataUsed;
    m_FrameExtent += SubframeHeader->StreamHeader.FrameExtent;
    m_Irps++;

    //
    // Get an IRP from the branch's lookaside list.
    //
    PLIST_ENTRY listEntry = 
        ExInterlockedRemoveHeadList(
            &m_IrpsAvailable.ListEntry,
            &m_IrpsAvailable.SpinLock);
    PIRP irp;
    if (listEntry) {
        irp = CONTAINING_RECORD(listEntry,IRP,Tail.Overlay.ListEntry);
    } else {
        //
        // Create the IRP now.
        //
        irp = AllocateIrp();

        if (! irp) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        _DbgPrintF(DEBUGLVL_VERBOSE,("#### Branch%p.TransferSubframe:  allocated IRP %p",this,irp));
    }

    irp->IoStatus.Status = STATUS_SUCCESS;
    irp->IoStatus.Information = 0;
    irp->PendingReturned = 0;
    irp->Cancel = 0;

    //
    // Transfer the IRP to the next component.
    //
    SubframeHeader->Irp = irp;
    irp->AssociatedIrp.SystemBuffer =
        irp->UserBuffer = 
            &SubframeHeader->StreamHeader;
    IoGetCurrentIrpStackLocation(irp)->
        Parameters.DeviceIoControl.OutputBufferLength = 
            SubframeHeader->StreamHeader.Size;
    InterlockedIncrement(PLONG(&m_OutstandingIrpCount));

    KsLog(&m_Log,KSLOGCODE_BRANCH_SEND,irp,NULL);

    return KspTransferKsIrp(m_TransportSink,irp);
}


PIRP
CKsSplitterBranch::
AllocateIrp(
    void
    )

/*++

Routine Description:

    This routine allocates a new IRP for subframe transfer.

Arguments:

    None.

Return Value:

    The allocated IRP or NULL if an IRP could not be allocated.

--*/
{
    _DbgPrintF(DEBUGLVL_BLAB,("[CKsSplitterBranch::AllocateIrp]"));

    ASSERT(m_StackSize);
    PIRP irp = IoAllocateIrp(CCHAR(m_StackSize),FALSE);

    if (irp) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("#### Branch%p.AllocateIrp:  %p",this,irp));
        irp->RequestorMode = KernelMode;
        irp->Flags = IRP_NOCACHE;

        //
        // Set the stack pointer to the first location and fill it in.
        //
        IoSetNextIrpStackLocation(irp);

        PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(irp);
        irpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
        irpSp->Parameters.DeviceIoControl.IoControlCode = m_IoControlCode;
    }

    return irp;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\ks\thread.c ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    thread.c

Abstract:

    This module contains the helper functions for worker threads. This
    allows clients to make a serialized work queue, and wait for the
    queue to be completed.
--*/

#include "ksp.h"

typedef struct {
    WORK_QUEUE_ITEM     WorkItem;
    KEVENT              CompletionEvent;
    LIST_ENTRY          WorkItemList;
    KSPIN_LOCK          WorkItemListLock;
    WORK_QUEUE_TYPE     WorkQueueType;
    LONG                ReferenceCount;
    BOOLEAN             UnregisteringWorker;
    ULONG               WorkCounter;
    PWORK_QUEUE_ITEM    CountedWorkItem;
#if (DBG)
    PETHREAD            WorkerThread;
#endif
} KSIWORKER, *PKSIWORKER;

#define KSSIGNATURE_LOCAL_WORKER 'wlSK'

#ifdef ALLOC_PRAGMA
VOID
WorkerThread(
    IN PVOID Context
    );
#pragma alloc_text(PAGE, WorkerThread)
#pragma alloc_text(PAGE, KsRegisterWorker)
#pragma alloc_text(PAGE, KsRegisterCountedWorker)
#pragma alloc_text(PAGE, KsUnregisterWorker)
#pragma alloc_text(PAGE, KsiQueryWorkQueueType)
#endif // ALLOC_PRAGMA


VOID
WorkerThread(
    IN PKSIWORKER Worker
    )
/*++

Routine Description:

    This is the thread routine for all worker threads.

Arguments:

    Worker -
        The worker which was queued.

Return Values:

    Nothing.

--*/
{
    for (;;) {
        PLIST_ENTRY         Entry;
        PWORK_QUEUE_ITEM    WorkItem;

        //
        // Get the first work item on this worker from off the list.
        // Only one work item at a time on this worker will be run.
        //
        Entry = ExInterlockedRemoveHeadList(
            &Worker->WorkItemList,
            &Worker->WorkItemListLock);
        ASSERT(Entry);
        WorkItem = CONTAINING_RECORD(Entry, WORK_QUEUE_ITEM, List);
#if (DBG)
        //
        // Clear for debug ASSERT()
        //
        WorkItem->List.Flink = NULL;
        Worker->WorkerThread = PsGetCurrentThread();
#endif
        WorkItem->WorkerRoutine(WorkItem->Parameter);
        if (KeGetCurrentIrql() != PASSIVE_LEVEL) {
            KeBugCheckEx(
                IRQL_NOT_LESS_OR_EQUAL,
                (ULONG_PTR)WorkItem->WorkerRoutine,
                (ULONG_PTR)KeGetCurrentIrql(),
                (ULONG_PTR)WorkItem->WorkerRoutine,
                (ULONG_PTR)WorkItem);
        }
#if (DBG)
        Worker->WorkerThread = NULL;
#endif
        //
        // Remove the reference count on the worker, noting that it has
        // now been completed.
        //
        // If this is the last reference count, then there are no more
        // items to process, and possibly a KsUnregisterWorker is waiting
        // to be signalled.
        //
        if (!InterlockedDecrement(&Worker->ReferenceCount)) {
            if (Worker->UnregisteringWorker) {
                KeSetEvent(&Worker->CompletionEvent, IO_NO_INCREMENT, FALSE);
            }
            break;
        }
    }
}


KSDDKAPI
NTSTATUS
NTAPI
KsRegisterWorker(
    IN WORK_QUEUE_TYPE WorkQueueType,
    OUT PKSWORKER* Worker
    )
/*++

Routine Description:

    Handles clients registering for use of a thread. This must be matched
    by a corresponding KsUnregisterWorker when thread use is completed.
    This may only be called at PASSIVE_LEVEL.

Arguments:

    WorkQueueType -
        Contains the priority of the work thread. This is normally one
        of CriticalWorkQueue, DelayedWorkQueue, or HyperCriticalWorkQueue.

    Worker -
        The place in which to put the opaque context which must be used
        when scheduling a work item. This contains the queue type, and
        is used to synchronize completion of work items.

Return Value:

    Returns STATUS_SUCCESS if a worker was initialized.

--*/
{
    PKSIWORKER  LocalWorker;
    NTSTATUS    Status;

    PAGED_CODE();
    if (WorkQueueType >= MaximumWorkQueue) {
        return STATUS_INVALID_PARAMETER;
    }
    LocalWorker = ExAllocatePoolWithTag(
        NonPagedPool, 
        sizeof(*LocalWorker), 
        KSSIGNATURE_LOCAL_WORKER);
    if (LocalWorker) {
        //
        // This contains the work item used to queue the worker
        // when items are queued to this object.
        //
        ExInitializeWorkItem(&LocalWorker->WorkItem, WorkerThread, LocalWorker);
        //
        // This event will be used when unregistering the worker. If the
        // item is in use, the call can wait for the event to be signalled.
        // It is only signalled if the work queue notices that the reference
        // count dropped to zero.
        //
        KeInitializeEvent(&LocalWorker->CompletionEvent, NotificationEvent, FALSE);
        //
        // This contains the list of worker items to serialize.
        //
        InitializeListHead(&LocalWorker->WorkItemList);
        //
        // This is used to serialize multiple threads queueing independent
        // work items to this worker. Each work item is placed on the
        // WorkItemList.
        //
        KeInitializeSpinLock(&LocalWorker->WorkItemListLock);
        //
        // This contains the queue type to use.
        //
        LocalWorker->WorkQueueType = WorkQueueType;
        //
        // The reference count starts at zero, and is incremented by scheduling
        // a work item, or decremented by completing it. On unregistering, this
        // is checked after setting UnregisteringWorker. This allows waiting for
        // outstanding work items, since the queue knows that the item is being
        // unregistered if it drops to zero and the flag is set.
        //
        LocalWorker->ReferenceCount = 0;
        LocalWorker->UnregisteringWorker = FALSE;
        //
        // This is the optional counter than can be used to control when a work
        // item is actually queued. It starts at zero, and is modified when a
        // work item is added, or when one is completed. A work item is distinct
        // from a worker.
        //
        LocalWorker->WorkCounter = 0;
        //
        // This is initialized by KsRegisterCountedWorker only, and is not
        // used in the uncounted worker situation.
        //
        LocalWorker->CountedWorkItem = NULL;
#if (DBG)
        LocalWorker->WorkerThread = NULL;
#endif
        *Worker = (PKSWORKER)LocalWorker;
        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
    return Status;
}


KSDDKAPI
NTSTATUS
NTAPI
KsRegisterCountedWorker(
    IN WORK_QUEUE_TYPE WorkQueueType,
    IN PWORK_QUEUE_ITEM CountedWorkItem,
    OUT PKSWORKER* Worker
    )
/*++

Routine Description:

    Handles clients registering for use of a thread. This must be matched
    by a corresponding KsUnregisterWorker when thread use is completed.
    This function resembles KsRegisterWorker, with the addition of passing
    the work item that will always be queued. This is to be used with
    KsIncrementCountedWorker and KsDecrementCountedWorker in order to
    minimize the number of work items queued, and reduce mutual exclusion
    code necessary in a work item needed to serialize access against multiple
    work item threads. The worker queue can still be used to queue other
    work items. This may only be called at PASSIVE_LEVEL.

Arguments:

    WorkQueueType -
        Contains the priority of the work thread. This is normally one
        of CriticalWorkQueue, DelayedWorkQueue, or HyperCriticalWorkQueue.

    CountedWorkItem -
        Contains a pointer to the work queue item which will be queued
        as needed based on the current count value.

    Worker -
        The place in which to put the opaque context which must be used
        when scheduling a work item. This contains the queue type, and
        is used to synchronize completion of work items.

Return Value:

    Returns STATUS_SUCCESS if a worker was initialized.

--*/
{
    NTSTATUS    Status;

    PAGED_CODE();
    Status = KsRegisterWorker(WorkQueueType, Worker);
    if (NT_SUCCESS(Status)) {
        //
        // This assigns the work queue item which will always be used
        // in the case of KsIncrementCountedWorker.
        //
        ((PKSIWORKER)*Worker)->CountedWorkItem = CountedWorkItem;
    }
    return Status;
}


KSDDKAPI
VOID
NTAPI
KsUnregisterWorker(
    IN PKSWORKER Worker
    )
/*++

Routine Description:

    Handles clients unregistering a worker. This must only be used
    on a successful return from KsRegisterWorker or KsRegisterCountedWorker.
    The client must ensure that outstanding I/O initiated on any worker
    thread has been completed before unregistering the worker has been
    completed. This means cancelling or completing outstanding I/O either
    before unregistering the worker, or before the worker item returns from
    its callback for the last time and is unregistered. Unregistering
    of a worker will wait on any currently queued work items to complete
    before returning. This may only be called at PASSIVE_LEVEL.

Arguments:

    Worker -
        Contains the previously allocated worker which is to be unregistered.
        This will wait until any outstanding work item is completed.

Return Value:

    Nothing.

--*/
{
    PKSIWORKER  LocalWorker;

    PAGED_CODE();
    LocalWorker = (PKSIWORKER)Worker;
    ASSERT(LocalWorker->WorkerThread != PsGetCurrentThread());
    LocalWorker->UnregisteringWorker = TRUE;
    //
    // If no work item has been queued, then the item can just be deleted,
    // else this call must wait until it is no longer in use.
    //
    if (LocalWorker->ReferenceCount) {
        //
        // If a work item has been queued, then wait for it to complete.
        // On completion it will decrement the reference count and notice
        // that it must signal the event.
        //
        KeWaitForSingleObject(&LocalWorker->CompletionEvent, Executive, KernelMode, FALSE, NULL);
    }
    ASSERT(IsListEmpty(&LocalWorker->WorkItemList));
    ExFreePool(LocalWorker);
}


KSDDKAPI
NTSTATUS
NTAPI
KsQueueWorkItem(
    IN PKSWORKER Worker,
    IN PWORK_QUEUE_ITEM WorkItem
    )
/*++

Routine Description:

    Queues the specified work item with the worker previous created by
    KsRegisterWorker. The worker may only be on a queue in one place,
    so subsequent queuing of this worker must wait until the work item
    has completed executing. This means that all work items queued through
    a single registered worker are serialized. This may be called at
    DISPATCH_LEVEL.

Arguments:

    Worker -
        Contains the previously allocated worker.

    WorkItem -
        The initialized work item to queue. This work item is only
        associated with the worker as long as the worker is on a queue.
        The work item must have been initialized by ExInitializeWorkItem.

Return Value:

    Returns STATUS_SUCCESS if the work item was queued.

--*/
{
    PKSIWORKER  LocalWorker;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    ASSERT(WorkItem->List.Flink == NULL);
    LocalWorker = (PKSIWORKER)Worker;
    ASSERT(!LocalWorker->UnregisteringWorker);
    ExInterlockedInsertTailList(
        &LocalWorker->WorkItemList,
        &WorkItem->List,
        &LocalWorker->WorkItemListLock);
    //
    // The initial reference count is zero, so a value of one would
    // indicate that this is the only item on the list now, or that
    // it is the first item to be put back on the list.
    //
    if (InterlockedIncrement(&LocalWorker->ReferenceCount) == 1) {
        //
        // Since there were no entries on this list, then it is OK
        // to queue the worker.
        //
        ExQueueWorkItem(&LocalWorker->WorkItem, LocalWorker->WorkQueueType);
    }
    return STATUS_SUCCESS;
}


KSDDKAPI
ULONG
NTAPI
KsIncrementCountedWorker(
    IN PKSWORKER Worker
    )
/*++

Routine Description:

    Increments the current worker count, and optionally queues the counted
    work item with the worker previous created by KsRegisterCountedWorker.
    This should be called after any list of tasks to perform by the worker
    has been added to. A corresponding KsDecrementCountedWorker should be
    called within the work item after each task has been completed. This
    may be called at DISPATCH_LEVEL.

Arguments:

    Worker -
        Contains the previously allocated worker.

Return Value:

    Returns the current counter. A count of one implies that a worker was
    actually scheduled.

--*/
{
    PKSIWORKER  LocalWorker;
    ULONG       WorkCounter;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    LocalWorker = (PKSIWORKER)Worker;
    ASSERT(LocalWorker->CountedWorkItem);
    if ((WorkCounter = InterlockedIncrement(&LocalWorker->WorkCounter)) == 1) {
        KsQueueWorkItem(Worker, LocalWorker->CountedWorkItem);
    }
    return WorkCounter;
}


KSDDKAPI
ULONG
NTAPI
KsDecrementCountedWorker(
    IN PKSWORKER Worker
    )
/*++

Routine Description:

    Decrements the current worker count of a worker previous created by
    KsRegisterCountedWorker. This should be called after each task within
    a worker has been completed. A corresponding KsIncrementCountedWorker
    would have been previously called in order to increment the count. This
    may be called at DISPATCH_LEVEL.

Arguments:

    Worker -
        Contains the previously allocated worker.

Return Value:

    Returns the current counter. A count of zero implies that the task list
    has been completed.

--*/
{
    PKSIWORKER  LocalWorker;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    LocalWorker = (PKSIWORKER)Worker;
    ASSERT(LocalWorker->CountedWorkItem);
    return InterlockedDecrement(&LocalWorker->WorkCounter);
}


WORK_QUEUE_TYPE
KsiQueryWorkQueueType(
    IN PKSWORKER Worker
    )
/*++

Routine Description:

    Returns the WORK_QUEUE_TYPE assigned to the worker when it was created.

Arguments:

    Worker -
        Contains the previously allocated worker.

Return Value:

    Returns the WORK_QUEUE_TYPE.

--*/
{
    return ((PKSIWORKER)Worker)->WorkQueueType;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\ks\guids\sources.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    sources.inc.

!ENDIF

TARGETPATH=obj
TARGETNAME=ksguid
TARGETTYPE=DRIVER_LIBRARY

SOURCES= \
    ..\$(TARGETNAME).c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\ks\guids\ksguid.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ksguid.c
//
//--------------------------------------------------------------------------

#include <wdm.h>
#include <windef.h>
#define NOBITMAP
#include <ksguid.h>
#include <mmreg.h>

//
// Create a separate library for the SDK which does not separate the
// guids out from the .text section.
//
#ifdef DDK_KS
#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_PRAGMA
#endif // SDK_KS

// include swenum.h first so that a separate guid entry is made for the BUSID.
#include <swenum.h>
#include <ks.h>
#include <ksi.h>
#include <ksmediap.h>
#include <ksproxy.h>
// remove this, since basetyps.h defines it again.
#undef DEFINE_GUID
#include <unknown.h>
// set the version to less than 1100 so that guids are defined for the library.
#ifdef _MSC_VER
#undef _MSC_VER
#endif // _MSC_VER
#define _MSC_VER 0
#include <kcom.h>
#include <stdarg.h>

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif // ALLOC_DATA_PRAGMA
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\ks\topology.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    topology.c

Abstract:

    This module contains the helper functions for topology nodes.

--*/

#include "ksp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, KsCreateTopologyNode)
#pragma alloc_text(PAGE, KspValidateTopologyNodeCreateRequest)
#pragma alloc_text(PAGE, KsValidateTopologyNodeCreateRequest)
#endif // ALLOC_PRAGMA

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA
static const WCHAR NodeString[] = KSSTRING_TopologyNode;
#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif // ALLOC_DATA_PRAGMA


KSDDKAPI
NTSTATUS
NTAPI
KsCreateTopologyNode(
    IN HANDLE ParentHandle,
    IN PKSNODE_CREATE NodeCreate,
    IN ACCESS_MASK DesiredAccess,
    OUT PHANDLE NodeHandle
    )
/*++

Routine Description:

    Creates a handle to a topology node instance. This may only be called at
    PASSIVE_LEVEL.

Arguments:

    ParentHandle -
        Contains the handle to the parent on which the node is created.

    NodeCreate -
        Specifies topology node create parameters.

    DesiredAccess -
        Specifies the desired access to the object. This is normally GENERIC_READ
        and/or GENERIC_WRITE.

    NodeHandle -
        Place in which to put the topology node handle.

Return Value:

    Returns STATUS_SUCCESS, else an error on node creation failure.

--*/
{
    PAGED_CODE();
    return KsiCreateObjectType(
        ParentHandle,
        (PWCHAR)NodeString,
        NodeCreate,
        sizeof(*NodeCreate),
        DesiredAccess,
        NodeHandle);
}


KSDDKAPI
NTSTATUS
NTAPI
KspValidateTopologyNodeCreateRequest(
    IN PIRP Irp,
    IN ULONG TopologyNodesCount,
    OUT PKSNODE_CREATE* NodeCreate
    )
/*++

Routine Description:

    Validates the topology node creation request and returns the create
    structure associated with the request.

    This may only be called at PASSIVE_LEVEL.

Arguments:

    Irp -
        Contains the IRP with the node create request being handled.

    TopologyNodesCount -
        The number of topology nodes for the filter in question.
        This is used to validate the create request.

    NodeCreate -
        Place in which to put the node create structure pointer passed to
        the create request.

Return Value:

    Returns STATUS_SUCCESS, else an error.

--*/
{
    NTSTATUS Status;
    ULONG CreateParameterLength;

    PAGED_CODE();
    CreateParameterLength = sizeof(**NodeCreate);
    Status = KsiCopyCreateParameter(
        Irp,
        &CreateParameterLength,
        NodeCreate);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    //
    // No flags have been defined yet. Also verify that the node
    // specified is within range.
    //
    if ((*NodeCreate)->CreateFlags ||
        (((*NodeCreate)->Node >= TopologyNodesCount) && ((*NodeCreate)->Node != (ULONG)-1))) {
        return STATUS_INVALID_PARAMETER;
    }
    return STATUS_SUCCESS;
}


KSDDKAPI
NTSTATUS
NTAPI
KsValidateTopologyNodeCreateRequest(
    IN PIRP Irp,
    IN PKSTOPOLOGY Topology,
    OUT PKSNODE_CREATE* NodeCreate
    )
/*++

Routine Description:

    Validates the topology node creation request and returns the create
    structure associated with the request.

    This may only be called at PASSIVE_LEVEL.

Arguments:

    Irp -
        Contains the IRP with the node create request being handled.

    Topology -
        Contains the topology structure associated with the parent object.
        This is used to validate the create request.

    NodeCreate -
        Place in which to put the node create structure pointer passed to
        the create request.

Return Value:

    Returns STATUS_SUCCESS, else an error.

--*/
{
    PAGED_CODE();
    return KspValidateTopologyNodeCreateRequest(
        Irp,
        Topology->TopologyNodesCount,
        NodeCreate);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\ks\kdexts\avsutil.h ===
/**************************************************************************

    AVStream extension utilities

**************************************************************************/

/*************************************************

    CMemoryBlock

    This is basically a smart pointer wrapper.  It allocates
    and deallocates memory to store the type as necessary.  The
    dereference operator is overloaded. 

*************************************************/

template <class TYPE> 
class CMemoryBlock {

private:
    
    TYPE *m_Memory;

public:

    CMemoryBlock () {
        m_Memory = (TYPE *)malloc (sizeof (TYPE));
    }

    CMemoryBlock (ULONG Quantity) {

        if (Quantity > 0)
            m_Memory = (TYPE *)malloc (Quantity * sizeof (TYPE));
        else
            m_Memory = NULL;
    }

    ~CMemoryBlock () {
        free (m_Memory);
        m_Memory = NULL;
    }

    TYPE *operator->() {
        return m_Memory;
    }

    TYPE *Get () {
        return m_Memory;
    }

};

/*************************************************

    CMemory

    This is an allocator / cleanup class for chunks of memory. 
    It is used as CMemoryBlock except that it only provides a
    chunk of memory.  It does not overload dereferences.  When
    it falls out of scope, the memory is deallocated.


*************************************************/

class CMemory {

private:

    void *m_Memory;

public:

    CMemory (ULONG Size) {

        if (Size > 0)
            m_Memory = (void *)malloc (Size);
        else
            m_Memory = NULL;
    }

    ~CMemory () {
        free (m_Memory);
        m_Memory = NULL;
    }

    void *Get () {
        return m_Memory;
    }

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\ks\kdexts\avsapi.cpp ===
/**************************************************************************

    avsapi.cpp

    --------------------------------------------------

    AVStream debugger extension API

    --------------------------------------------------

    Toss questions at wmessmer

    ==================================================

    Notes to future maintainers:

    1)

        This extension is designed to be usable and supportable under both
        Win9x (RTERM's KD-style extension support) and KD-style debuggers for
        NT.  Because of the differences in debugging information between 9x
        and the various flavors and versions of NT debuggers, I have made
        an attempt to minimize the amount of debug information required from
        the extension.  This has, however, created an interesting situation:

        Most of AVStream relies on C++; this means abstract base classes,
        COM style QI, etc...  Some of the lists maintained (circuits, etc...)
        are maintained through lists of abstract base class pointers.  Due
        to this and my desire to minimize bang (!) interface commands, I have
        written code to identify a class object from an interface pointer.
        This works differently between 9x and NT.  For 9x, it resolves the
        name (to the compiler's mangled name), demangles the name, and
        determines the base class and derived class; there is then an
        enormous switch and type cast from base classes to derived classes.
        KD on the other hand does not return the compiler's mangled name; it
        returns something like class__`vftable'.  Because of the way the
        AVStream classes are organized in that they derive multiply from
        all abstract classes until the last base which is non-abstract, I
        simply walk backwards resolving symbols until they do not resolve
        to a v-table for the current class type.  This works because and ONLY
        because of the layout of AVStream classes.

        If there is ever a time where we have RTTI available, someone should
        modify the code to use this type of information.  The old methodology
        should be kept intact for backwards compatability with previous
        debuggers.

    2)

        I have modified the routines to use a generic tabbing mechanism
        so that things can be printed with more readability.  If you add
        functions or features, please maintain this.

    3)

        Alright, I'm confused.  For one period of time, I had NT debuggers
        returning compiler mangled names instead of __`vftable'.  I guess
        this depends on the class of PDB?  In any case, if you define

            NT_USES_MANGLED_NAMES: use the fully mangled name as opposed 
                to backtracing the __`vftable' method

            NT_MAY_USE_MANGLED_NAMES: try the __`vftable' method first
                If this fails, try the fully mangled name.

**************************************************************************/

#include "kskdx.h"
#include "avsutil.h"

#include "..\shqueue.cpp"
#include "..\shfilt.cpp"
#include "..\shpin.cpp"
#include "..\shdevice.cpp"
#include "..\shreq.cpp"
#include "..\shsplit.cpp"
#include "..\shpipe.cpp"
#include "..\shffact.cpp"

/*************************************************

    UTILITY ROUTINES

        Function:

            HexDump

        Description:

            Hex dump a section of memory.

        Arguments:

            HostAddress -
                Address of the block on the host

            TargetAddress -
                Address of the block on the target

            BufferSize -
                Size of the block

*************************************************/

void
HexDump (
    IN PVOID HostAddress,
    IN ULONG TargetAddress,
    IN ULONG BufferSize
) {

    ULONG Psn;
    PULONG BufUL;

    char StringBuffer[17];

    BufUL = (PULONG)HostAddress;

    dprintf ("Dumping memory %08lx length %ld\n", TargetAddress, BufferSize);

    BufferSize = (BufferSize / 4) + (!!(BufferSize & 0x3));

    Psn = 0;
    while (Psn < BufferSize && !CheckControlC ()) {

        ULONG NPos;

        dprintf ("    0x%08lx : ", (Psn << 2) + (ULONG)TargetAddress);

        for (NPos = 0; NPos < 4 && Psn + NPos < BufferSize; NPos++) 
            dprintf ("0x%08lx ", *(BufUL + Psn + NPos));

        {
            PCHAR ch = (PCHAR)(BufUL + Psn);
            CHAR c;
            ULONG i = 0;

            for (i = 0; i < 16 && Psn + (i >> 2) < BufferSize; i++) {
                c = *(ch + i);
                if (isprint (c))
                    StringBuffer[i] = c;
                else
                    StringBuffer[i] = '.';
            }
            StringBuffer [i] = 0;

            dprintf ("%s", StringBuffer);

        }

        dprintf ("\n");

        Psn += NPos;

    }
}

/*************************************************

    Function:

        is_kernel_address

    Description:

        Check whether or not a specific address is a kernel address.  I
        place this here instead of a literal check to ease moving this
        to 64-bit.

    Arguments:

        Address -
            The address to check

    Return Value:

        TRUE / FALSE as to whether the address is a kernel address

*************************************************/

BOOLEAN
is_kernel_address (
    IN DWORD Address
    )

{

    if (Address >= 0x80000000)
        return TRUE;

    return FALSE;

}

/*************************************************

    Function:

        signature_check

    Description:

        Check for a specific signature in a location.  IE: check
        to see whether a given pointer points to an Irp.

    Arguments:

        Address -
            The address to check (on the target)

        Signature -
            The signature to check for

    Return Value:

        TRUE / FALSE as to whether the object matches the signature

*************************************************/

BOOLEAN
signature_check (
    IN DWORD Address,
    IN SIGNATURE_TYPE Signature
    )

{

    ULONG Result;

    switch (Signature) {

        case SignatureIrp:
        {

            CSHORT IrpSign;
            DWORD KAValidation;

            if (!ReadMemory (
                Address + FIELDOFFSET (IRP, Type),
                &IrpSign,
                sizeof (CSHORT),
                &Result)) return FALSE;

            if (IrpSign != IO_TYPE_IRP)
                return FALSE;

            //
            // Because of the context in which this is called, I'm going
            // to verify that the value at address isn't a kernel address.
            // This will hopefully eliminate false positives from 
            // identification.
            //
            if (!ReadMemory (
                Address,
                &KAValidation,
                sizeof (DWORD),
                &Result)) return FALSE;


            if (is_kernel_address (KAValidation))
                return FALSE;

            return TRUE;

            break;
        }

        case SignatureFile:
        {

            CSHORT FileSign;
            DWORD KAValidation;

            if (!ReadMemory (
                Address + FIELDOFFSET (FILE_OBJECT, Type),
                &FileSign,
                sizeof (CSHORT),
                &Result)) return FALSE;

            if (FileSign != IO_TYPE_FILE)
                return FALSE;

            //
            // See comments in SignatureIrp pertaining to this check
            //
            if (!ReadMemory (
                Address,
                &KAValidation,
                sizeof (DWORD),
                &Result)) return FALSE;

            if (is_kernel_address (KAValidation))
                return FALSE;

            return TRUE;

            break;
        }

        default:

            return FALSE;

    }

    return FALSE;

}

/*************************************************

    Function:

        irp_stack_match

    Description:

        Match the current irp stack location major/minor of the
        specified target irp against Major and Minor parameters.

    Arguments:

        Address -
            The address of the irp to match on the target

        Major -
            The major to check for
            (UCHAR)-1 == wildcard

        Minor -
            The minor to check for
            (UCHAR)-1 == wildcard
        

*************************************************/

BOOLEAN irp_stack_match (
    IN DWORD Address,
    IN UCHAR Major,
    IN UCHAR Minor
    )

{

    PIO_STACK_LOCATION IoStackAddr;
    IO_STACK_LOCATION IoStack;
    ULONG Result;
    
    if (!ReadMemory (
        Address + FIELDOFFSET (IRP, Tail.Overlay.CurrentStackLocation),
        &IoStackAddr,
        sizeof (PIO_STACK_LOCATION),
        &Result)) {

        dprintf ("%08lx: unable to read Irp's current stack location!\n",
            Address);
        return FALSE;
    }

    if (!ReadMemory (
        (DWORD)IoStackAddr,
        &IoStack,
        sizeof (IO_STACK_LOCATION),
        &Result)) {

        dprintf ("%08lx: unable to read Irp's current stack!\n", IoStackAddr);
        return FALSE;
    }

    //
    // Check to see whether io stack matches or the caller doesn't care.
    //
    if (
        (Major == IoStack.MajorFunction || Major == (UCHAR)-1) &&
        (Minor == IoStack.MinorFunction || Minor == (UCHAR)-1)
       )
        return TRUE;

    else
        return FALSE;

}

/*************************************************

    STUBS

    The following are stubs to make things work correctly.
    AVStream was not designed with the KD extension in mind.  The
    classes are stored in .CPP files; I need to include the .CPP files
    and because of the base classes, I need kcom.h which means there
    better be ExAllocatePool* and ExFreePool* functions linked somewhere.
    These stubs are specifically to make things work for class stubs to
    access variables from the extension.

*************************************************/

extern "C"
{
PVOID ExAllocatePool (
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes
) {

    //
    // This is a stub only to allow kcom.h to be included for a stub
    // of CBaseUnknown to make class variable access possible from the 
    // extension.  If anyone calls it, they are broken.
    //
    ASSERT (0);

    return NULL;

}

void ExFreePool (
    IN PVOID Address
) {

    //
    // This is a stub only to allow kcom.h to be included for a stub
    // of CBaseUnknown to make class variable access possible from the 
    // extension.  If anyone calls it, they are broken.
    //
    ASSERT (0);

}
}

/*************************************************

    HACKS ...  err make that INTERESTING WAYS TO GET AROUND
    THINGS WITHOUT MODIFYING PUBLIC HEADERS

*************************************************/

// 
// CFriendlyBaseUnknown is a CBaseUnknown (to the byte) that
// hacks access to m_RefCount.  I will not modify the public ks headers
// with #ifdef KDEXT_ONLY.  The privates is a different story.  The publics,
// well, I just won't.
//
// Note: this must align exactly (and I do mean exactly) with
// CBaseUnknown.  There can be no virtuals...  no data members...
// nothing...  In order to ensure that, every function will be
// static, non-virtual
//
class CFriendlyBaseUnknown : public CBaseUnknown {

public:

    static LONG GetRefCount (CFriendlyBaseUnknown *FriendlyUnknown) {
        return FriendlyUnknown -> m_RefCount;
    };

};

/*************************************************

    Function:

        GetObjectReferenceCount

    Description:

        Returns the reference count on a given CBaseUnknown on
        the target.  This is a hack since I can't change the public
        ks headers with KDEXT_ONLY.  

    Arguments:

        BaseUnknown -
            A base unknown on the target

    Return Value:

        The reference count of the base unknown


*************************************************/

LONG GetObjectReferenceCount (
    IN CBaseUnknown *BaseUnknown
) {

    ULONG Result;
    CMemory FriendlyUnknownMem (sizeof (CFriendlyBaseUnknown));
    CFriendlyBaseUnknown *FriendlyUnknown = 
        (CFriendlyBaseUnknown *)FriendlyUnknownMem.Get ();

    if (sizeof (CFriendlyBaseUnknown) !=
        sizeof (CBaseUnknown)) {
        dprintf ("FATAL: hacked base unknown doesn't align with non-hacked\n");
        return 0;
    }

    if (!ReadMemory (
        (DWORD)BaseUnknown,
        FriendlyUnknown,
        sizeof (CBaseUnknown),
        &Result)) {

        dprintf ("%08lX: cannot read base unknown!\n", BaseUnknown);
        return 0;
    }

    //
    // Use the hack to get the reference count and return.  The friendly
    // unknown's memory will be deallocated since it falls out of scope.
    //
    return CFriendlyBaseUnknown::GetRefCount (FriendlyUnknown);

}

/*************************************************

    Function:

        GetNodeAutomationTablePointer

    Description:

        Given a public address and a node id, find the automation table
        for the topology node.

    Arguments:

        Public -
            The target address of a public

        NodeId -
            The id of a node

    Return Value:

        A target pointer which points to the automation table for the
        given topology node.

*************************************************/

PKSAUTOMATION_TABLE 
GetNodeAutomationTablePointer (
    IN DWORD Public,
    IN ULONG NodeId
    )

{

    ULONG Result;

    PKSPX_EXT ExtAddr = (PKSPX_EXT)CONTAINING_RECORD (Public, KSPX_EXT, Public);
    KSPX_EXT Ext;

    ULONG NodesCount;
    PKSAUTOMATION_TABLE *NodeTables;

    if (!ReadMemory (
        (DWORD)ExtAddr,
        &Ext,
        sizeof (KSPX_EXT),
        &Result)) {

        dprintf ("%08lx: unable to read public's ext!\n", Public);
        return NULL;
    }

    switch (Ext.ObjectType) {

        case KsObjectTypeDevice:
            //
            // Devices don't have nodes!
            //
            return NULL;

        case KsObjectTypeFilterFactory:
        {

            CKsFilterFactory *Factory = (CKsFilterFactory *)
                CONTAINING_RECORD (ExtAddr, CKsFilterFactory, m_Ext);

            if (!ReadMemory (
                (DWORD)Factory + FIELDOFFSET(CKsFilterFactory, m_NodesCount),
                &NodesCount,
                sizeof (ULONG),
                &Result))
                return NULL;

            if (!ReadMemory (
                (DWORD)Factory + FIELDOFFSET(CKsFilterFactory, 
                    m_NodeAutomationTables),
                &NodeTables,
                sizeof (PKSAUTOMATION_TABLE *),
                &Result))
                return NULL;

            break;

        }

        case KsObjectTypeFilter:
        {

            CKsFilter *Filter = (CKsFilter *)
                CONTAINING_RECORD (ExtAddr, CKsFilter, m_Ext);

            if (!ReadMemory (
                (DWORD)Filter + FIELDOFFSET(CKsFilter, m_NodesCount),
                &NodesCount,
                sizeof (ULONG),
                &Result))
                return NULL;

            if (!ReadMemory (
                (DWORD)Filter + FIELDOFFSET(CKsFilter, 
                    m_NodeAutomationTables),
                &NodeTables,
                sizeof (PKSAUTOMATION_TABLE *),
                &Result))
                return NULL;

            break;

        }

        case KsObjectTypePin:
        {

            CKsPin *Pin = (CKsPin *)
                CONTAINING_RECORD (ExtAddr, CKsPin, m_Ext);

            if (!ReadMemory (
                (DWORD)Pin + FIELDOFFSET(CKsPin, m_NodesCount),
                &NodesCount,
                sizeof (ULONG),
                &Result))
                return NULL;

            if (!ReadMemory (
                (DWORD)Pin + FIELDOFFSET(CKsPin, 
                    m_NodeAutomationTables),
                &NodeTables,
                sizeof (PKSAUTOMATION_TABLE *),
                &Result))
                return NULL;

            break;

        }

        default:

            // ?
            return NULL;

    }

    if (NodeId >= NodesCount)
        return NULL;

    PKSAUTOMATION_TABLE AutomationTable;

    if (!ReadMemory (
        (DWORD)NodeTables + NodeId * sizeof (PKSAUTOMATION_TABLE),
        &AutomationTable,
        sizeof (PKSAUTOMATION_TABLE),
        &Result))
        return FALSE;

    return AutomationTable;

}

/*************************************************

    Function:

        DumpFrameHeader

    Description:

        Given an already read from the target frame header,
        dump it.

    Arguments:

        FrameHeader -
            The frame header to dump [on the host]

        FrameAddress-
            The address of the frame header on the target

        TabDepth -
            The tab depth at which to print the frame header


    Return Value:
        
        None

    Notes:

*************************************************/

void
DumpFrameHeader (
    IN PKSPFRAME_HEADER FrameHeader,
    IN DWORD FrameAddress,
    IN ULONG TabDepth
) 
{

    dprintf ("%sFrame Header %08lx:\n",  Tab (TabDepth), FrameAddress);
    TabDepth++;
    dprintf ("%sNextFrameHeaderInIrp = %08lx\n", 
        Tab (TabDepth),
        FrameHeader -> NextFrameHeaderInIrp);
    dprintf ("%sOriginalIrp = %08lx\n",
        Tab (TabDepth),
        FrameHeader -> OriginalIrp);
    dprintf ("%sMdl = %08lx\n", Tab (TabDepth), FrameHeader -> Mdl);
    dprintf ("%sIrp = %08lx\n", Tab (TabDepth), FrameHeader -> Irp);
    dprintf ("%sIrpFraming = %08lx\n", 
        Tab (TabDepth),
        FrameHeader -> IrpFraming);
    dprintf ("%sStreamHeader = %08lx\n", 
        Tab (TabDepth),
        FrameHeader -> StreamHeader);
    dprintf ("%sFrameBuffer = %08lx\n", 
        Tab (TabDepth),
        FrameHeader -> FrameBuffer);
    dprintf ("%sStreamHeaderSize = %08lx\n",
        Tab (TabDepth), 
        FrameHeader -> StreamHeaderSize);
    dprintf ("%sFrameBufferSize = %08lx\n", 
        Tab (TabDepth),
        FrameHeader -> FrameBufferSize);
    dprintf ("%sContext = %08lx\n", 
        Tab (TabDepth), 
        FrameHeader -> Context);
    dprintf ("%sRefcount = %ld\n", 
        Tab (TabDepth),
        FrameHeader -> RefCount);

}

/*************************************************

    Function:

        DumpStreamPointer

    Description:

        Dump an internal stream pointer structure

    Arguments:

        StreamPointer -
            Points to the stream pointer to dump

        StreamPointerAddress -
            The address of the structure on the target

        Level -
            The level to dump at

        TabDepth -
            The tab depth at which to print this

    Return Value:

        None

    Notes:

*************************************************/

char *StreamPointerStates [] = {
    "unlocked",
    "locked",
    "cancelled",
    "deleted",
    "cancel pending",
    "dead"
};

void
DumpStreamPointer (
    IN PKSPSTREAM_POINTER StreamPointer,
    IN DWORD StreamPointerAddress,
    IN ULONG Level,
    IN ULONG TabDepth
) {

    dprintf ("%sStream Pointer %08lx [Public %08lx]:\n",
        Tab (TabDepth),
        StreamPointerAddress, StreamPointerAddress + 
            FIELDOFFSET(KSPSTREAM_POINTER, Public));
    TabDepth++;
    dprintf ("%sState = %s\n", 
        Tab (TabDepth), 
        StreamPointerStates [StreamPointer -> State]);
    dprintf ("%sStride = %ld\n", Tab (TabDepth), StreamPointer -> Stride);
    dprintf ("%sFrame Header = %08lx\n", 
        Tab (TabDepth),
        StreamPointer -> FrameHeader);
    dprintf ("%sFrame Header Started = %08lx\n",
        Tab (TabDepth),
        StreamPointer -> FrameHeaderStarted);
    dprintf ("%sStream Header = %08lx\n",
        Tab (TabDepth),
        StreamPointer -> Public.StreamHeader);

    //
    // Determine whether or not the queue generates mappings...
    //
    BOOLEAN Mappings = FALSE;
    ULONG Result;
    PKSSTREAM_POINTER_OFFSET Offset;

    if (!ReadMemory (
        (DWORD)((CKsQueue *)StreamPointer -> Queue) +
            FIELDOFFSET (CKsQueue, m_GenerateMappings),
        &Mappings,
        sizeof (BOOLEAN),
        &Result)) {
        dprintf ("%08lx: unable to read queue mappings flag!\n",
            (CKsQueue *)StreamPointer -> Queue);
        return;
    }
    

    if ((DWORD)StreamPointer -> Public.Offset == StreamPointerAddress +
        FIELDOFFSET(KSPSTREAM_POINTER, Public) +
        FIELDOFFSET(KSSTREAM_POINTER, OffsetIn)) {

        Offset = &(StreamPointer -> Public.OffsetIn);

        dprintf ("%s%s = %08lx\n", 
            Tab (TabDepth),
            Mappings ? "Mappings" : "Data",
            StreamPointer -> Public.OffsetIn.Data);
        dprintf ("%sCount = %08lx\n",
            Tab (TabDepth),
            StreamPointer -> Public.OffsetIn.Count);
        dprintf ("%sRemaining = %08lx\n",
            Tab (TabDepth),
            StreamPointer -> Public.OffsetIn.Remaining);

    } else {

        Offset = &(StreamPointer -> Public.OffsetOut);

        dprintf ("%s%s = %08lx\n", 
            Tab (TabDepth),
            Mappings ? "Mappings" : "Data",
            StreamPointer -> Public.OffsetOut.Data);
        dprintf ("%sCount = %08lx\n",
            Tab (TabDepth),
            StreamPointer -> Public.OffsetOut.Count);
        dprintf ("%sRemaining = %08lx\n",
            Tab (TabDepth),
            StreamPointer -> Public.OffsetOut.Remaining);

    }

    //
    // If the dump level is high enough and the queue is a mapped queue,
    // dump out the physical address, byte counts, and alignment of all
    // mappings specified.
    //
    // NOTE: Always advance by the stream pointer's stride because the client
    // could have additional information with each mapping.
    //
    if (Level >= DUMPLVL_HIGHDETAIL && Mappings) {

        dprintf ("%sMappings Remaining:\n", Tab (TabDepth));
        TabDepth++;

        PKSMAPPING MappingAddr = Offset -> Mappings;
        KSMAPPING Mapping;
        ULONG i;

        for (i = 0; i < Offset -> Remaining; i++) {

            if (!ReadMemory (
                (DWORD)MappingAddr,
                &Mapping,
                sizeof (KSMAPPING),
                &Result)) {
                dprintf ("%08lx: could not read mapping!\n",
                    MappingAddr);
                return;
            }
            
            dprintf ("%sPhysical = %08lx, Count = %08lx, Alignment = %08lx\n",
                Tab (TabDepth),
                Mapping.PhysicalAddress.LowPart,
                Mapping.ByteCount,
                Mapping.Alignment
                );

            MappingAddr = (PKSMAPPING)(
                (PUCHAR)MappingAddr + StreamPointer -> Stride
                );

        }

        if (!Offset -> Remaining)
            dprintf ("%sNo mappings remain!\n", Tab (TabDepth));

    }

}

/*************************************************

    Function:

        DumpQueueContents

    Description:
        
        Given the address of a queue object on the target
        machine (QueueObject), dump out the key queue fields
        and the queue's contents.

    Arguments:

        QueueObject -
            The address of the queue object on the target machine

        Level -
            The 0-7 level to dump at

        TabDepth -
            The tab depth at which to print this

    Return Value:

        None

    Notes:

*************************************************/

void
DumpQueueContents (
    IN CKsQueue *QueueObject,
    IN ULONG Level,
    IN ULONG TabDepth
) {

    //
    // The template will do all necessary cleanup when the block falls
    // out of scope.
    //
    CMemoryBlock <CKsQueue> HostQueue;
    
    KSGATE Gate;
    ULONG Result;

    if (!ReadMemory (
        (DWORD)QueueObject,
        HostQueue.Get (),
        sizeof (CKsQueue),
        &Result
    )) {
        dprintf ("FATAL: unable to read queue!\n");
        return;
    }

    dprintf ("Queue %08lx:\n", QueueObject);

    //
    // Dump statistics
    //
    dprintf ("%sFrames Received  : %ld\n"
             "%sFrames Waiting   : %ld\n"
             "%sFrames Cancelled : %ld\n",
             Tab (TabDepth), HostQueue -> m_FramesReceived,
             Tab (TabDepth), HostQueue -> m_FramesWaiting,
             Tab (TabDepth), HostQueue -> m_FramesCancelled);

    if (Level >= DUMPLVL_BEYONDGENERAL)
        dprintf ("%sMaster Pin       : %08lx\n",
            Tab (TabDepth),
            HostQueue -> m_MasterPin);

    //
    // First dump each gate...
    //
    if (HostQueue -> m_AndGate) {
    
        if (!ReadMemory (
            (DWORD)HostQueue -> m_AndGate,
            &Gate,
            sizeof (KSGATE),
            &Result
        )) {
            dprintf ("FATAL: unable to read and gate!\n");
            return;
        }

        dprintf ("%sAnd Gate %08lx : count = %ld, next = %08lx\n",
            Tab (TabDepth),
            HostQueue -> m_AndGate, Gate.Count, Gate.NextGate);
    }
    else {
        dprintf ("%sAnd Gate NULL\n", Tab (TabDepth));
    }

    if (HostQueue -> m_FrameGate) {
        
        if (!ReadMemory (
            (DWORD)HostQueue -> m_FrameGate,
            &Gate,
            sizeof (KSGATE),
            &Result
        )) {
            dprintf ("FATAL: unable to read frame gate!\n");
            return;
        }

        if (HostQueue -> m_FrameGateIsOr) 
            dprintf ("%sFrame Gate [OR] %08lx : count = %ld, next = %08lx\n",
                Tab (TabDepth),
                HostQueue -> m_FrameGate, Gate.Count, Gate.NextGate);
        else
            dprintf ("%sFrame Gate [AND] %08lx : count = %ld, next = %08lx\n",
                Tab (TabDepth),
                HostQueue -> m_FrameGate, Gate.Count, Gate.NextGate);

    } 
    else {
        dprintf ("    Frame Gate NULL\n");
    }

    //
    // Iterate through each frame in the queue and print each frame.
    //
    if (Level >= DUMPLVL_GENERAL)
    {
        KSPFRAME_HEADER FrameHeader;
        DWORD FrameQueueAddress;
        DWORD FrameHeaderAddress;

        FrameQueueAddress = FIELDOFFSET (CKsQueue, m_FrameQueue) +
            (DWORD)QueueObject;

        if ((DWORD)(HostQueue -> m_FrameQueue.ListEntry.Flink) != 
            FrameQueueAddress) {

            FrameHeader.ListEntry.Flink = 
                HostQueue -> m_FrameQueue.ListEntry.Flink;
            do {

                if (!ReadMemory (
                    (FrameHeaderAddress = ((DWORD)FrameHeader.ListEntry.Flink)),
                    &FrameHeader,
                    sizeof (KSPFRAME_HEADER),
                    &Result
                )) {
                    dprintf ("FATAL: Unable to follow frame chain!\n");
                    return;
                }

                DumpFrameHeader (&FrameHeader, FrameHeaderAddress, TabDepth);

            } while ((DWORD)(FrameHeader.ListEntry.Flink) != FrameQueueAddress
                && !CheckControlC ());
        }
    }

    //
    // Iterate through all stream pointers on the queue and print each one.
    //
    if (Level >= DUMPLVL_INTERNAL) 
    {
        KSPSTREAM_POINTER StreamPointer;
        DWORD StreamPointersAddress;
        DWORD StreamPointerAddress;

        dprintf ("\n");

        if (HostQueue -> m_Leading) {
            if (!ReadMemory (
                (DWORD)HostQueue -> m_Leading,
                &StreamPointer,
                sizeof (KSPSTREAM_POINTER),
                &Result
            )) {
                dprintf ("%lx: cannot read leading edge!\n",
                    HostQueue -> m_Leading);
                return;
            }

            dprintf ("%sLeading Edge:\n", Tab (TabDepth));
            DumpStreamPointer (&StreamPointer, (DWORD)HostQueue -> m_Leading,
                Level, TabDepth);
        }
        if (HostQueue -> m_Trailing) {
            if (!ReadMemory (
                (DWORD)HostQueue -> m_Trailing,
                &StreamPointer,
                sizeof (KSPSTREAM_POINTER),
                &Result
            )) {
                dprintf ("%lx: cannot read trailing edge!\n",
                    HostQueue -> m_Trailing);
                return;
            }

            dprintf ("%sTrailing Edge:\n", Tab (TabDepth));
            DumpStreamPointer (&StreamPointer, (DWORD)HostQueue -> m_Trailing,
                Level, TabDepth);
        }

        StreamPointersAddress = FIELDOFFSET (CKsQueue, m_StreamPointers) +
            (DWORD)QueueObject;

        if ((DWORD)(HostQueue -> m_StreamPointers.Flink) !=
            StreamPointersAddress) {

            StreamPointer.ListEntry.Flink =
                HostQueue -> m_StreamPointers.Flink;
            do {

                StreamPointerAddress = (DWORD)CONTAINING_RECORD (
                    StreamPointer.ListEntry.Flink,
                    KSPSTREAM_POINTER,
                    ListEntry);

                if (!ReadMemory (
                    StreamPointerAddress,
                    &StreamPointer,
                    sizeof (KSPSTREAM_POINTER),
                    &Result
                )) {
                    dprintf ("FATAL: Unable to follow stream pointer chain!\n");
                    return;
                }

                DumpStreamPointer (&StreamPointer, StreamPointerAddress,
                    Level, TabDepth);

            } while ((DWORD)(StreamPointer.ListEntry.Flink) !=
                StreamPointersAddress && !CheckControlC ());
        }
    }

}

/*************************************************

    Function:

        DemangleAndAttemptIdentification

    Arguments:

        Address -
            The address of the unknown to attempt identification of

        ObjectAddress -
            The base address of the object adjusted to the descendent class
            ie: if we have an IFoo interface to a CGoo, this will return the
            base address of CGoo which may or not be the same as the base
            address of the IFoo part of CGoo depending on the inheritence
            tree.

        InterfaceType -
            What base class pointer type Address is, if detectable.  If
            it is not an abstract base class pointer, this will
            be InterfaceTypeUnknown

    Return Value:

        The type of Address if identifiable

    Notes:

        We even do it without the PDB....  how nice....

*************************************************/

//
// Just a note....  This is a **HUGE** hack...  The only reason I'm
// doing this is because it's extraordinarilly difficult to access things
// through interfaces from an NT debugger extension. 
//
// Should new object types be added to AVStream objects or new interfaces
// be added, these tables will need to be updated.  Such is the magic
// of trying to write an NT-style debugger extension that will also work
// with RTERM.  (Kick out that PDB info).
// 
typedef struct _OBJECT_MAPPING {

    char *Name;
    INTERNAL_OBJECT_TYPE ObjectType;

} OBJECT_MAPPING, *POBJECT_MAPPING;

OBJECT_MAPPING TypeNamesToIdTypes [] = {
    {"CKsQueue", ObjectTypeCKsQueue},
    {"CKsDevice", ObjectTypeCKsDevice},
    {"CKsFilterFactory", ObjectTypeCKsFilterFactory},
    {"CKsFilter", ObjectTypeCKsFilter},
    {"CKsPin", ObjectTypeCKsPin},
    {"CKsRequestor", ObjectTypeCKsRequestor},
    {"CKsSplitterBranch", ObjectTypeCKsSplitterBranch},
    {"CKsSplitter", ObjectTypeCKsSplitter},
    {"CKsPipeSection", ObjectTypeCKsPipeSection}
};

typedef struct _INTERFACE_MAPPING {
    
    char *Name;
    INTERNAL_INTERFACE_TYPE InterfaceType;

} INTERFACE_MAPPING, *PINTERFACE_MAPPING;

INTERFACE_MAPPING InterfaceNamesToIdTypes [] = {
    {"IKsTransport", InterfaceTypeIKsTransport},
    {"IKsRetireFrame", InterfaceTypeIKsRetireFrame},
    {"IKsPowerNotify", InterfaceTypeIKsPowerNotify},
    {"IKsProcessingObject", InterfaceTypeIKsProcessingObject},
    {"IKsConnection", InterfaceTypeIKsConnection},
    {"IKsDevice", InterfaceTypeIKsDevice},
    {"IKsFilterFactory", InterfaceTypeIKsFilterFactory},
    {"IKsFilter", InterfaceTypeIKsFilter},
    {"IKsPin", InterfaceTypeIKsPin},
    {"IKsPipeSection", InterfaceTypeIKsPipeSection},
    {"IKsRequestor", InterfaceTypeIKsRequestor},
    {"IKsQueue", InterfaceTypeIKsQueue},
    {"IKsSplitter", InterfaceTypeIKsSplitter},
    {"IKsControl", InterfaceTypeIKsControl},
    {"IKsWorkSink", InterfaceTypeIKsWorkSink},
    {"IKsReferenceClock", InterfaceTypeIKsReferenceClock},
    {"INonDelegatedUnknown", InterfaceTypeINonDelegatedUnknown},
    {"IIndirectedUnknown", InterfaceTypeIIndirectedUnknown}
};

char *ObjectNames [] = {
    "Unknown",
    "struct KSPIN",
    "struct KSFILTER",
    "struct KSDEVICE",
    "struct KSFILTERFACTORY",
    "class CKsQueue",
    "class CKsDevice",
    "class CKsFilterFactory",
    "class CKsFilter",
    "class CKsPin",
    "class CKsRequestor",
    "class CKsSplitter",
    "class CKsSplitterBranch",
    "class CKsPipeSection"
};

INTERNAL_OBJECT_TYPE
DemangleAndAttemptIdentification (
    IN DWORD Address,
    OUT PDWORD ObjectAddress,
    OUT PINTERNAL_INTERFACE_TYPE InterfaceType OPTIONAL
) {

    PVOID Vtbl;
    ULONG Result;
    CHAR Buffer[256];
    ULONG Displacement;
    PCHAR StrLoc, BufTrav;
    INTERNAL_OBJECT_TYPE BestGuess;
    INTERNAL_INTERFACE_TYPE IFGuess;
    ULONG i, ID, iID;
    DWORD AddressTrav;

    if (InterfaceType)
        *InterfaceType = InterfaceTypeUnknown;

    //
    // Assume we're looking at a C++ class.  There's gotta be a vtbl pointer
    // here.  Grab it.
    //
    if (!ReadMemory (
        Address,
        &Vtbl,
        sizeof (PVOID),
        &Result
    )) {
        dprintf ("%08lx: unable to read identifying marks!\n", Address);
        return ObjectTypeUnknown;
    }

    #ifdef DEBUG_EXTENSION
        dprintf ("Vtbl = %08lx\n", Vtbl);
    #endif // DEBUG_EXTENSION

    //
    // Here's the tricky part.  First, we resolve the symbol.  If it doesn't
    // resolve, we're done....
    //
    GetSymbol ((LPVOID)Vtbl, Buffer, &Displacement);

    #ifdef DEBUG_EXTENSION
        dprintf ("GetSymbol....  Buffer = [%s], Displacement = %ld\n",
            Buffer, Displacement);
        HexDump (Buffer, 0, 256);
    #endif // DEBUG_EXTENSION

    if (!Buffer [0] || Displacement != 0) {
        // dprintf ("%08lx: unable to identify object!\n", Address);
        return ObjectTypeUnknown;
    }

    //
    // So the symbol resolves...  this is absolutely key.
    //
    
    //
    // First, let's take a quick guess as to what we think this might be.
    //

    #ifdef DEBUG_EXTENSION
        dprintf ("DemangleAndAttemptIdentification: Mangled = [%s]\n", Buffer);
    #endif // DEBUG_EXTENSION

    BestGuess = ObjectTypeUnknown;
    for (i = 0; i < SIZEOF_ARRAY (TypeNamesToIdTypes); i++) 
        if (StrLoc = (strstr (Buffer, TypeNamesToIdTypes [i].Name))) {
            //
            // A key field has been detected.
            //
            BestGuess = TypeNamesToIdTypes [i].ObjectType;
            break;
        }

    //
    // If we didn't even find a key, we're out of luck in identifying this
    // object.
    //
    if (BestGuess == ObjectTypeUnknown) {
        // dprintf ("%08lx: unable to guess object type!\n", Address);
        return ObjectTypeUnknown;
    }

    ID = i;

    //
    // Check the NT methodology for resolution first.  It NT_USES_MANGLED_NAMES
    // is defined, do not make this check.  If NT_MAY_USE_MANGLED_NAMES
    // is defined, make the check.  These defines should be mutually
    // exclusive.
    //
    #if !defined(WIN9X_KS) && !defined(NT_USES_MANGLED_NAMES)

        //
        // Unfortunately, under NT, things work slightly differently.  Whereas
        // RTERM returns the compiler's mangled name, KD returns
        // module!Class__`vftable' for every v-table.  We cannot determine
        // what interface we're pointing at.  So we can't guess on the
        // interface, but we can play games to find the base address of
        // the class...  We're going to scan backwards from the current
        // address resolving names until we find something which isn't a
        // v-table.  The last successfully resolved v-table pointer will be
        // the base class: let's remember this is true because of the fact
        // that all the base classes except for CBaseUnknown are abstract;
        // they have no member data.  If we ever derive an AVStream class
        // from multiple non-abstract bases or derive from a non-abstract
        // base which isn't the last class in the base classes list, this
        // method of finding the base address will fail.  I'd love to know
        // if there's a way to get at the compiler's mangled name from KD.
        // Until then, this is the best I've got.  Yes -- it's chewing gum
        // and duct tape...  but it works....  and that's more than I can say
        // for any other debugging facility for AVStream.
        //

        //
        // ks!Class__`vftable'.  StrLoc points to the C in class.
        //

        //
        // For recent builds of Whistler, this is no longer necessary as the
        // debugger returns the fully mangled name as resolution.
        //

        if (!strstr (StrLoc, "__`vftable'")) {
            BestGuess = ObjectTypeUnknown;

            #ifdef DEBUG_EXTENSION
                dprintf ("%08lx: unable to scan for NT __`vftable' key!\n",
                    Address);
            #endif // DEBUG_EXTENSION

            //
            // Alright, I admit it...  I'm using one of those evil goto 
            // statements.  This happens to facilitate a quick "allow both
            // checks for __`vftable' and mangled resolution".
            //
            #if !defined(NT_MAY_USE_MANGLED_NAMES)
                return ObjectTypeUnknown;
            #else
                goto NTCheckMangledName;
            #endif // NT_MAY_USE_MANGLED_NAMES

        }

        AddressTrav = Address;
        do {

            //
            // Walk backwards....
            //
            AddressTrav -= sizeof (PVOID);

            //
            // If we couldn't successfully read, it's possible that we've gone
            // out of bounds of something and that AddressTrav + sizeof (PVOID)
            // is the base address
            //
            if (!ReadMemory (
                AddressTrav,
                &Vtbl,
                sizeof (PVOID),
                &Result
            )) 
                break;

            //
            // Now we need to check if this is still a v-table pointer.
            //
            GetSymbol ((LPVOID)Vtbl, Buffer, &Displacement);

            //
            // If it didn't resolve, it's not one of our v-table pointers.
            //
            if (!Buffer [0] || Displacement != 0)
                break;

            if (StrLoc = (strstr (Buffer, TypeNamesToIdTypes [ID].Name))) {

                //
                // If we aren't a v-table, we've walked backwards too far.
                //
                if (!strstr (StrLoc, "__`vftable'")) 
                    break;

            } else
                //
                // We couldn't resolve the type we think we are.  We've walked
                // backwards too far.
                //
                break;

            //
            // Continue the loop until something causes us to break out.  At 
            // the point we break, AddressTrav + sizeof (PVOID) should hold
            // the base address of the object we seek.
            //
        } while (1);

        *ObjectAddress = (DWORD)(AddressTrav + sizeof (PVOID));

        if (InterfaceType) {
            //
            // Until I can think of a way to extract this information without
            // being hideous about it, we cannot return IF type under NT
            //
            *InterfaceType = InterfaceTypeUnknown;
        }

        //
        // If we've already identified the class, we don't want to make the
        // attempt below.  
        //
        if (BestGuess != ObjectTypeUnknown)
            return BestGuess;

    #endif // WIN9X_KS etc...

NTCheckMangledName:

    // 
    // Hrmm...  On some machines I've been getting fully mangled names returned
    // and others the classic __`vftable' style of symbols.  See my comments
    // at the top.
    //
    #if defined(WIN9X_KS) || (!defined (WIN9X_KS) && (defined(NT_MAY_USE_MANGLED_NAMES) || defined(NT_USES_MANGLED_NAMES)))
    
        //
        // Ok, so we found a key in the name.  Now we need to ensure for C++
        // objects that this is some v-table and not some function pointer
        // inside the class.
        //
        // Scan backwards and make sure this is really a v-table pointer
        // Mangle syntax ... ??somethingKEY
        //
        i = StrLoc - Buffer;
        if (!i || i == 1) {
            //
            // This isn't really what we thought it was.  I have no clue why;
            // this is more of a sanity check.
            //
            // dprintf ("%08lx: object might have something to do with %s, "
            //    "but I am unsure!\n", Address, TypeNamesToIdTypes [ID].Name);
            return ObjectTypeUnknown;
        }
        do {
            if (Buffer [i] == '?' && Buffer [i - 1] == '?')
                break;
        } while (--i);
        if (i <= 1) {
            //
            // Same as above.  We didn't find the ?? key
            //
            //dprintf ("%08lx: object might have something to do with %s, "
            //    "but I am unsure!\n", Address, TypeNamesToIdTypes [ID].Name);
            return ObjectTypeUnknown;
        }
    
        // 
        // Next, make sure this is really a v-table pointer again by searching
        // for @@ after the CKs* key name
        //
        BufTrav = StrLoc + strlen (TypeNamesToIdTypes [ID].Name);
        if (*BufTrav == 0 || *(BufTrav + 1) == 0 || *(BufTrav + 2) == 0 || 
            *BufTrav != '@' || *(BufTrav + 1) != '@') {
            // dprintf ("%08lx: object might have something to do with %s, "
            //    "but I am unsure!\n", Address, TypeNamesToIdTypes [ID].Name);
            return ObjectTypeUnknown;
        }
    
        //
        // Ok ... we're relatively sure that we now have a **ONE** of the 
        // v-table pointers into a CKs* identified by BestGuess.  The key now 
        // is to determine whether we have the root pointer to CKs* or a 
        // pointer to a v-table of a base class of CKs*.  This is yet another 
        // layer of demangling.  Don't you love NT-style debugger extensions?
        //
        BufTrav++; BufTrav++;
    
        #ifdef DEBUG_EXTENSION
            dprintf ("Attempting interface identification : BufTrav = [%s]\n",
                BufTrav);
        #endif // DEBUG_EXTENSION
    
        IFGuess = InterfaceTypeUnknown;
        for (i = 0; i < SIZEOF_ARRAY (InterfaceNamesToIdTypes); i++) 
            if (StrLoc = (strstr (BufTrav, InterfaceNamesToIdTypes [i].Name))) {
                //
                // A key field has been detected.
                //
                IFGuess = InterfaceNamesToIdTypes [i].InterfaceType;
                break;
            }
    
        #ifdef DEBUG_EXTENSION
            dprintf ("IFGuess = %ld\n", IFGuess);
        #endif // DEBUG_EXTENSION
    
        if (IFGuess == InterfaceTypeUnknown) {
            //
            // If we didn't find an interface field, we're reasonably sure that
            // BestGuess is the object and that Address is truly the base 
            // pointer.
            //
            *ObjectAddress = Address;
            return BestGuess;
        }
    
        iID = i;
    
        //
        // Otherwise, we likely have found an interface pointer to some derived
        // class.  Let's pray I get this right....
        //
        i = StrLoc - BufTrav;
        while (i) {
            if (BufTrav [i] == '@') {
                // dprintf ("%08lx: object might have something to do with %s "
                // "and %s, but I am unsure", Address,
                //    TypeNamesToIdTypes [ID].Name,
                //    InterfaceNamesToIdTypes [iID].Name);
                return ObjectTypeUnknown;
            }
            i--;
        }
    
        //
        // At this point, we're reasonably sure that we have an IFGuess 
        // interface pointer to a BestGuess object.  Now here comes the 
        // switch statement: upcast the interface.
        //
        // MUSTCHECK: is there an issue with unknown pointers?  If we inherit
        // from two base interfaces which both inherit from the unknowns non
        // virtually...  will this work?
        // 
        switch (BestGuess) {
    
            //
            // Cast the appropriate interface to the base for
            // CKsQueue
            //
            case ObjectTypeCKsQueue:
    
                switch (IFGuess) {
    
                    case InterfaceTypeIKsQueue:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsQueue *)(
                                    (IKsQueue *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeIKsTransport:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsQueue *)(
                                    (IKsTransport *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeINonDelegatedUnknown:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsQueue *)(
                                    (INonDelegatedUnknown *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeIIndirectedUnknown:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsQueue *)(
                                    (IIndirectedUnknown *)Address
                                )
                            );
    
                        break;
    
                    
                    default:
    
                        BestGuess = ObjectTypeUnknown;
                        break;
    
                }
    
                break;
    
            //
            // Cast the appropriate interface to the base for
            // CKsDevice
            //
            case ObjectTypeCKsDevice:
    
                switch (IFGuess) {
    
                    case InterfaceTypeIKsDevice:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsDevice *)(
                                    (IKsDevice *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeINonDelegatedUnknown:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsDevice *)(
                                    (INonDelegatedUnknown *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeIIndirectedUnknown:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsDevice *)(
                                    (IIndirectedUnknown *)Address
                                )
                            );
    
                        break;
    
    
                    default:
    
                        BestGuess = ObjectTypeUnknown;
                        break;
    
                }
    
                break;
    
            case ObjectTypeCKsFilterFactory:
    
                switch (IFGuess) {
    
                    case InterfaceTypeIKsFilterFactory:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsFilterFactory *)(
                                    (IKsFilterFactory *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeIKsPowerNotify:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsFilterFactory *)(
                                    (IKsPowerNotify *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeINonDelegatedUnknown:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsFilterFactory *)(
                                    (INonDelegatedUnknown *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeIIndirectedUnknown:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsFilterFactory *)(
                                    (IIndirectedUnknown *)Address
                                )
                            );
    
                        break;
    
                    default:
    
                        BestGuess = ObjectTypeUnknown;
                        break;
                }
    
                break;
    
            case ObjectTypeCKsFilter:
    
                switch (IFGuess) {
    
                    case InterfaceTypeIKsFilter:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsFilter *)(
                                    (IKsFilter *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeIKsTransport:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsFilter *)(
                                    (IKsTransport *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeIKsProcessingObject:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsFilter *)(
                                    (IKsProcessingObject *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeIKsPowerNotify:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsFilter *)(
                                    (IKsPowerNotify *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeIKsControl:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsFilter *)(
                                    (IKsControl *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeINonDelegatedUnknown:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsFilter *)(
                                    (INonDelegatedUnknown *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeIIndirectedUnknown:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsFilter *)(
                                    (IIndirectedUnknown *)Address
                                )
                            );
    
                        break;
    
                    default:
    
                        BestGuess = ObjectTypeUnknown;
                        break;
    
                }
    
                break;
    
            case ObjectTypeCKsPin:
    
                switch (IFGuess) {
                    
                    case InterfaceTypeIKsPin:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsPin *)(
                                    (IKsPin *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeIKsTransport:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsPin *)(
                                    (IKsTransport *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeIKsProcessingObject:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsPin *)(
                                    (IKsProcessingObject *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeIKsWorkSink:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsPin *)(
                                    (IKsWorkSink *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeIKsConnection:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsPin *)(
                                    (IKsConnection *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeIKsControl:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsPin *)(
                                    (IKsControl *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeIKsReferenceClock:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsPin *)(
                                    (IKsReferenceClock *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeIKsRetireFrame:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsPin *)(
                                    (IKsRetireFrame *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeINonDelegatedUnknown:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsPin *)(
                                    (INonDelegatedUnknown *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeIIndirectedUnknown:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsPin *)(
                                    (IIndirectedUnknown *)Address
                                )
                            );
    
                        break;
    
    
                    default:
    
                        BestGuess = ObjectTypeUnknown;
                        break;
    
                }
    
                break;
    
            case ObjectTypeCKsRequestor:
    
                switch (IFGuess) {
    
                    case InterfaceTypeIKsRequestor:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsRequestor *)(
                                    (IKsRequestor *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeIKsTransport:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsRequestor *)(
                                    (IKsTransport *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeIKsWorkSink:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsRequestor *)(
                                    (IKsWorkSink *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeINonDelegatedUnknown:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsRequestor *)(
                                    (IKsRequestor *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeIIndirectedUnknown:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsRequestor *)(
                                    (IIndirectedUnknown *)Address
                                )
                            );
    
                        break;
    
    
                    default:
    
                        BestGuess = ObjectTypeUnknown;
                        break;
    
                }
    
                break;
    
            case ObjectTypeCKsSplitter:
    
                switch (IFGuess) {
    
                    case InterfaceTypeIKsSplitter:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsSplitter *)(
                                    (IKsSplitter *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeIKsTransport:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsSplitter *)(
                                    (IKsTransport *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeINonDelegatedUnknown:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsSplitter *)(
                                    (INonDelegatedUnknown *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeIIndirectedUnknown:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsSplitter *)(
                                    (IIndirectedUnknown *)Address
                                )
                            );
    
                        break;
    
    
                    default:
    
                        BestGuess = ObjectTypeUnknown;
                        break;
    
                }
    
                break;
    
            case ObjectTypeCKsSplitterBranch:
    
                switch (IFGuess) {
    
                    case InterfaceTypeIKsTransport:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsSplitterBranch *)(
                                    (IKsTransport *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeINonDelegatedUnknown:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsSplitterBranch *)(
                                    (INonDelegatedUnknown *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeIIndirectedUnknown:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsSplitterBranch *)(
                                    (IIndirectedUnknown *)Address
                                )
                            );
    
                        break;
    
                    default:
    
                        BestGuess = ObjectTypeUnknown;
                        break;
    
                }
    
                break;
    
            case ObjectTypeCKsPipeSection:
    
                switch (IFGuess) {
    
                    case InterfaceTypeIKsPipeSection:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsPipeSection *)(
                                    (IKsPipeSection *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeINonDelegatedUnknown:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsPipeSection *)(
                                    (INonDelegatedUnknown *)Address
                                )
                            );
    
                        break;
    
                    case InterfaceTypeIIndirectedUnknown:
    
                        *ObjectAddress =
                            (DWORD)(
                                (CKsPipeSection *)(
                                    (IIndirectedUnknown *)Address
                                )
                            );
    
                        break;
    
                    default:
    
                        BestGuess = ObjectTypeUnknown;
    
                }
    
                break;
    
            default:
    
                BestGuess = ObjectTypeUnknown;
                break;
        }
    
        //
        // Give them what they asked for.
        //
        if (BestGuess != ObjectTypeUnknown && InterfaceType) 
            *InterfaceType = IFGuess;

    #endif // WIN9X_KS etc...
    
    return BestGuess;

}

/*************************************************

    Function:

        IdentifyStructure

    Description:

        Attempt to identify a pointer to an object as a structure.  This
        does not identify class objects.  DemangleAndAttemptIdentification
        is required for that because of the potential of VTBL pointers
        that aren't the base pointer.  This identifies a structure
        via key fields.

    Arguments:

        Pointer -
            The pointer to identify

        BaseAddr -
            The base address of the object identified will be placed here.
            (For instance, sometimes we identify a private version, but
            adjust to the public for return -- this would contain the public
            address).

    Return Value:

        Structure Type

    NOTES:

        There are MANY helper functions below this comment

*************************************************/

BOOLEAN
IsStreamPointer (
    IN DWORD Pointer
    )

{

    CMemoryBlock <KSPSTREAM_POINTER> StreamPointer;
    ULONG Result;

    // 
    // This is a high-confidence identification.  We attempt to identify
    // whether pointer is a stream pointer by running tests against it.
    // If any one of the tests fails, it is not.  If all tests pass,
    // it is **LIKELY** a stream pointer.  This is not definite proof.
    //
    if (!ReadMemory (
        (DWORD)CONTAINING_RECORD (Pointer,
            KSPSTREAM_POINTER, Public),
        StreamPointer.Get (),
        sizeof (KSPSTREAM_POINTER),
        &Result)) 
        return FALSE;

    //
    // Supposedly, there's a pin structure where this is.  We're going
    // to read the complete EXT structure and guarantee that we've found a pin.
    //
    CMemoryBlock <KSPIN_EXT> PinExt;

    if (!ReadMemory (
        (DWORD)CONTAINING_RECORD (StreamPointer -> Public.Pin, 
            KSPIN_EXT, Public),
        PinExt.Get (),
        sizeof (KSPIN_EXT),
        &Result))
        return FALSE;

    //
    // Ensure that the EXT says it's a pin.
    //
    if (PinExt -> ObjectType != KsObjectTypePin)
        return FALSE;

    //
    // Ensure that the EXT has an interface pointer to a pin
    //
    DWORD Base;
    if (DemangleAndAttemptIdentification (
        (DWORD)PinExt -> Interface,
        &Base,
        NULL) != ObjectTypeCKsPin)
        return FALSE;

    //
    // At this point, we're fairly confident that *(Pointer + sizeof (*))
    // is a PKSPIN.  This does not guarantee that we're a stream pointer.
    //
    // Ensure that what we think is the private part of the stream pointer
    // really has a pointer to a queue.
    //
    if (DemangleAndAttemptIdentification (
        (DWORD)StreamPointer -> Queue,
        &Base,
        NULL) != ObjectTypeCKsQueue)
        return FALSE;

    //
    // Ensure that the stream pointer is in a valid state.
    //
    if (!(
        StreamPointer -> State >= KSPSTREAM_POINTER_STATE_UNLOCKED &&
        StreamPointer -> State <= KSPSTREAM_POINTER_STATE_DEAD
        ))
        return FALSE;

    //
    // If the stream pointer is locked or unlocked, validate that it points
    // to an Irp.
    //
    if (StreamPointer -> State == KSPSTREAM_POINTER_STATE_UNLOCKED ||
        StreamPointer -> State == KSPSTREAM_POINTER_STATE_LOCKED) {

        //
        // Validate that the frame header points to an Irp
        //
        CMemoryBlock <KSPFRAME_HEADER> FrameHeader;

        if (!ReadMemory (
            (DWORD)StreamPointer -> FrameHeader,
            FrameHeader.Get (),
            sizeof (KSPFRAME_HEADER),
            &Result))
            return FALSE;

        if (!signature_check (
            (DWORD)FrameHeader -> Irp, SignatureIrp
            )) 
            return FALSE;

    }

    //
    // At this point, we've made enough checks to say with a fair degree
    // of confidence that this IS a stream pointer
    //
    return TRUE;

}

INTERNAL_STRUCTURE_TYPE
IdentifyStructure (
    IN DWORD Pointer,
    OU