_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_ILicense,0xB93F97E9,0x782F,0x11d3,0x99,0x51,0x00,0x00,0xF8,0x05,0xBF,0xB0);


MIDL_DEFINE_GUID(IID, LIBID_LicenseLib,0xB1923C49,0x8D9F,0x11d3,0x99,0x5F,0x00,0x00,0xF8,0x05,0xBF,0xB0);


MIDL_DEFINE_GUID(CLSID, CLSID_License,0xB1923C48,0x8D9F,0x11d3,0x99,0x5F,0x00,0x00,0xF8,0x05,0xBF,0xB0);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\ivehandler_p.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Thu Feb 20 18:27:16 2003
 */
/* Compiler settings for ivehandler.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)
#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 440
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "ivehandler.h"

#define TYPE_FORMAT_STRING_SIZE   1197                              
#define PROC_FORMAT_STRING_SIZE   69                                
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   1            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IVEHandler_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IVEHandler_ProxyInfo;


extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ];

#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT40_OR_LATER)
#error You need a Windows NT 4.0 or later to run this stub because it uses these features:
#error   -Oif or -Oicf, [wire_marshal] or [user_marshal] attribute.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure VEHandler */

			0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x3 ),	/* 3 */
/*  8 */	NdrFcShort( 0x30 ),	/* x86 Stack size/offset = 48 */
/* 10 */	NdrFcShort( 0x68 ),	/* 104 */
/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
/* 14 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter VECode */

/* 16 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 18 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 20 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter Context */

/* 22 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 24 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 26 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter psa */

/* 28 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 30 */	NdrFcShort( 0x28 ),	/* x86 Stack size/offset = 40 */
/* 32 */	NdrFcShort( 0x4a2 ),	/* Type Offset=1186 */

	/* Return value */

/* 34 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 36 */	NdrFcShort( 0x2c ),	/* x86 Stack size/offset = 44 */
/* 38 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetReporterFtn */

/* 40 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 42 */	NdrFcLong( 0x0 ),	/* 0 */
/* 46 */	NdrFcShort( 0x4 ),	/* 4 */
/* 48 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 50 */	NdrFcShort( 0x10 ),	/* 16 */
/* 52 */	NdrFcShort( 0x8 ),	/* 8 */
/* 54 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter lFnPtr */

/* 56 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 58 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 60 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Return value */

/* 62 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 64 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 66 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/*  4 */	NdrFcShort( 0x20 ),	/* 32 */
/*  6 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/*  8 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 10 */	NdrFcShort( 0x14 ),	/* 20 */
/* 12 */	NdrFcShort( 0x14 ),	/* 20 */
/* 14 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 16 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 18 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 20 */	NdrFcShort( 0x1c ),	/* 28 */
/* 22 */	NdrFcShort( 0x1c ),	/* 28 */
/* 24 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 26 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 28 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 30 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 32 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 34 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 36 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 38 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 40 */	NdrFcShort( 0x2 ),	/* Offset= 2 (42) */
/* 42 */	
			0x12, 0x0,	/* FC_UP */
/* 44 */	NdrFcShort( 0x464 ),	/* Offset= 1124 (1168) */
/* 46 */	
			0x2a,		/* FC_ENCAPSULATED_UNION */
			0x49,		/* 73 */
/* 48 */	NdrFcShort( 0x18 ),	/* 24 */
/* 50 */	NdrFcShort( 0xa ),	/* 10 */
/* 52 */	NdrFcLong( 0x8 ),	/* 8 */
/* 56 */	NdrFcShort( 0x6c ),	/* Offset= 108 (164) */
/* 58 */	NdrFcLong( 0xd ),	/* 13 */
/* 62 */	NdrFcShort( 0x9e ),	/* Offset= 158 (220) */
/* 64 */	NdrFcLong( 0x9 ),	/* 9 */
/* 68 */	NdrFcShort( 0xcc ),	/* Offset= 204 (272) */
/* 70 */	NdrFcLong( 0xc ),	/* 12 */
/* 74 */	NdrFcShort( 0x330 ),	/* Offset= 816 (890) */
/* 76 */	NdrFcLong( 0x24 ),	/* 36 */
/* 80 */	NdrFcShort( 0x358 ),	/* Offset= 856 (936) */
/* 82 */	NdrFcLong( 0x800d ),	/* 32781 */
/* 86 */	NdrFcShort( 0x398 ),	/* Offset= 920 (1006) */
/* 88 */	NdrFcLong( 0x10 ),	/* 16 */
/* 92 */	NdrFcShort( 0x3b0 ),	/* Offset= 944 (1036) */
/* 94 */	NdrFcLong( 0x2 ),	/* 2 */
/* 98 */	NdrFcShort( 0x3c8 ),	/* Offset= 968 (1066) */
/* 100 */	NdrFcLong( 0x3 ),	/* 3 */
/* 104 */	NdrFcShort( 0x3e0 ),	/* Offset= 992 (1096) */
/* 106 */	NdrFcLong( 0x14 ),	/* 20 */
/* 110 */	NdrFcShort( 0x3f8 ),	/* Offset= 1016 (1126) */
/* 112 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (111) */
/* 114 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 116 */	NdrFcShort( 0x2 ),	/* 2 */
/* 118 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 120 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 122 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 124 */	
			0x17,		/* FC_CSTRUCT */
			0x3,		/* 3 */
/* 126 */	NdrFcShort( 0x8 ),	/* 8 */
/* 128 */	NdrFcShort( 0xfffffff2 ),	/* Offset= -14 (114) */
/* 130 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 132 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 134 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 136 */	NdrFcShort( 0x4 ),	/* 4 */
/* 138 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 140 */	NdrFcShort( 0x0 ),	/* 0 */
/* 142 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 144 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 146 */	NdrFcShort( 0x4 ),	/* 4 */
/* 148 */	NdrFcShort( 0x0 ),	/* 0 */
/* 150 */	NdrFcShort( 0x1 ),	/* 1 */
/* 152 */	NdrFcShort( 0x0 ),	/* 0 */
/* 154 */	NdrFcShort( 0x0 ),	/* 0 */
/* 156 */	0x12, 0x0,	/* FC_UP */
/* 158 */	NdrFcShort( 0xffffffde ),	/* Offset= -34 (124) */
/* 160 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 162 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 164 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 166 */	NdrFcShort( 0x8 ),	/* 8 */
/* 168 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 170 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 172 */	NdrFcShort( 0x4 ),	/* 4 */
/* 174 */	NdrFcShort( 0x4 ),	/* 4 */
/* 176 */	0x11, 0x0,	/* FC_RP */
/* 178 */	NdrFcShort( 0xffffffd4 ),	/* Offset= -44 (134) */
/* 180 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 182 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 184 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 186 */	NdrFcLong( 0x0 ),	/* 0 */
/* 190 */	NdrFcShort( 0x0 ),	/* 0 */
/* 192 */	NdrFcShort( 0x0 ),	/* 0 */
/* 194 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 196 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 198 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 200 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 202 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 204 */	NdrFcShort( 0x0 ),	/* 0 */
/* 206 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 208 */	NdrFcShort( 0x0 ),	/* 0 */
/* 210 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 214 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 216 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (184) */
/* 218 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 220 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 222 */	NdrFcShort( 0x8 ),	/* 8 */
/* 224 */	NdrFcShort( 0x0 ),	/* 0 */
/* 226 */	NdrFcShort( 0x6 ),	/* Offset= 6 (232) */
/* 228 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 230 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 232 */	
			0x11, 0x0,	/* FC_RP */
/* 234 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (202) */
/* 236 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 238 */	NdrFcLong( 0x20400 ),	/* 132096 */
/* 242 */	NdrFcShort( 0x0 ),	/* 0 */
/* 244 */	NdrFcShort( 0x0 ),	/* 0 */
/* 246 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 248 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 250 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 252 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 254 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 256 */	NdrFcShort( 0x0 ),	/* 0 */
/* 258 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 260 */	NdrFcShort( 0x0 ),	/* 0 */
/* 262 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 266 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 268 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (236) */
/* 270 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 272 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 274 */	NdrFcShort( 0x8 ),	/* 8 */
/* 276 */	NdrFcShort( 0x0 ),	/* 0 */
/* 278 */	NdrFcShort( 0x6 ),	/* Offset= 6 (284) */
/* 280 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 282 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 284 */	
			0x11, 0x0,	/* FC_RP */
/* 286 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (254) */
/* 288 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x9,		/* FC_ULONG */
/* 290 */	0x7,		/* Corr desc: FC_USHORT */
			0x0,		/*  */
/* 292 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 294 */	NdrFcShort( 0x2 ),	/* Offset= 2 (296) */
/* 296 */	NdrFcShort( 0x10 ),	/* 16 */
/* 298 */	NdrFcShort( 0x2f ),	/* 47 */
/* 300 */	NdrFcLong( 0x14 ),	/* 20 */
/* 304 */	NdrFcShort( 0x800b ),	/* Simple arm type: FC_HYPER */
/* 306 */	NdrFcLong( 0x3 ),	/* 3 */
/* 310 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 312 */	NdrFcLong( 0x11 ),	/* 17 */
/* 316 */	NdrFcShort( 0x8001 ),	/* Simple arm type: FC_BYTE */
/* 318 */	NdrFcLong( 0x2 ),	/* 2 */
/* 322 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 324 */	NdrFcLong( 0x4 ),	/* 4 */
/* 328 */	NdrFcShort( 0x800a ),	/* Simple arm type: FC_FLOAT */
/* 330 */	NdrFcLong( 0x5 ),	/* 5 */
/* 334 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 336 */	NdrFcLong( 0xb ),	/* 11 */
/* 340 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 342 */	NdrFcLong( 0xa ),	/* 10 */
/* 346 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 348 */	NdrFcLong( 0x6 ),	/* 6 */
/* 352 */	NdrFcShort( 0xe8 ),	/* Offset= 232 (584) */
/* 354 */	NdrFcLong( 0x7 ),	/* 7 */
/* 358 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 360 */	NdrFcLong( 0x8 ),	/* 8 */
/* 364 */	NdrFcShort( 0xe2 ),	/* Offset= 226 (590) */
/* 366 */	NdrFcLong( 0xd ),	/* 13 */
/* 370 */	NdrFcShort( 0xe0 ),	/* Offset= 224 (594) */
/* 372 */	NdrFcLong( 0x9 ),	/* 9 */
/* 376 */	NdrFcShort( 0xec ),	/* Offset= 236 (612) */
/* 378 */	NdrFcLong( 0x2000 ),	/* 8192 */
/* 382 */	NdrFcShort( 0xf8 ),	/* Offset= 248 (630) */
/* 384 */	NdrFcLong( 0x24 ),	/* 36 */
/* 388 */	NdrFcShort( 0xfa ),	/* Offset= 250 (638) */
/* 390 */	NdrFcLong( 0x4024 ),	/* 16420 */
/* 394 */	NdrFcShort( 0xf4 ),	/* Offset= 244 (638) */
/* 396 */	NdrFcLong( 0x4011 ),	/* 16401 */
/* 400 */	NdrFcShort( 0x122 ),	/* Offset= 290 (690) */
/* 402 */	NdrFcLong( 0x4002 ),	/* 16386 */
/* 406 */	NdrFcShort( 0x120 ),	/* Offset= 288 (694) */
/* 408 */	NdrFcLong( 0x4003 ),	/* 16387 */
/* 412 */	NdrFcShort( 0x11e ),	/* Offset= 286 (698) */
/* 414 */	NdrFcLong( 0x4014 ),	/* 16404 */
/* 418 */	NdrFcShort( 0x11c ),	/* Offset= 284 (702) */
/* 420 */	NdrFcLong( 0x4004 ),	/* 16388 */
/* 424 */	NdrFcShort( 0x11a ),	/* Offset= 282 (706) */
/* 426 */	NdrFcLong( 0x4005 ),	/* 16389 */
/* 430 */	NdrFcShort( 0x118 ),	/* Offset= 280 (710) */
/* 432 */	NdrFcLong( 0x400b ),	/* 16395 */
/* 436 */	NdrFcShort( 0x116 ),	/* Offset= 278 (714) */
/* 438 */	NdrFcLong( 0x400a ),	/* 16394 */
/* 442 */	NdrFcShort( 0x114 ),	/* Offset= 276 (718) */
/* 444 */	NdrFcLong( 0x4006 ),	/* 16390 */
/* 448 */	NdrFcShort( 0x112 ),	/* Offset= 274 (722) */
/* 450 */	NdrFcLong( 0x4007 ),	/* 16391 */
/* 454 */	NdrFcShort( 0x110 ),	/* Offset= 272 (726) */
/* 456 */	NdrFcLong( 0x4008 ),	/* 16392 */
/* 460 */	NdrFcShort( 0x10e ),	/* Offset= 270 (730) */
/* 462 */	NdrFcLong( 0x400d ),	/* 16397 */
/* 466 */	NdrFcShort( 0x110 ),	/* Offset= 272 (738) */
/* 468 */	NdrFcLong( 0x4009 ),	/* 16393 */
/* 472 */	NdrFcShort( 0x120 ),	/* Offset= 288 (760) */
/* 474 */	NdrFcLong( 0x6000 ),	/* 24576 */
/* 478 */	NdrFcShort( 0x130 ),	/* Offset= 304 (782) */
/* 480 */	NdrFcLong( 0x400c ),	/* 16396 */
/* 484 */	NdrFcShort( 0x136 ),	/* Offset= 310 (794) */
/* 486 */	NdrFcLong( 0x10 ),	/* 16 */
/* 490 */	NdrFcShort( 0x8002 ),	/* Simple arm type: FC_CHAR */
/* 492 */	NdrFcLong( 0x12 ),	/* 18 */
/* 496 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 498 */	NdrFcLong( 0x13 ),	/* 19 */
/* 502 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 504 */	NdrFcLong( 0x15 ),	/* 21 */
/* 508 */	NdrFcShort( 0x800b ),	/* Simple arm type: FC_HYPER */
/* 510 */	NdrFcLong( 0x16 ),	/* 22 */
/* 514 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 516 */	NdrFcLong( 0x17 ),	/* 23 */
/* 520 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 522 */	NdrFcLong( 0xe ),	/* 14 */
/* 526 */	NdrFcShort( 0x114 ),	/* Offset= 276 (802) */
/* 528 */	NdrFcLong( 0x400e ),	/* 16398 */
/* 532 */	NdrFcShort( 0x118 ),	/* Offset= 280 (812) */
/* 534 */	NdrFcLong( 0x4010 ),	/* 16400 */
/* 538 */	NdrFcShort( 0x116 ),	/* Offset= 278 (816) */
/* 540 */	NdrFcLong( 0x4012 ),	/* 16402 */
/* 544 */	NdrFcShort( 0x114 ),	/* Offset= 276 (820) */
/* 546 */	NdrFcLong( 0x4013 ),	/* 16403 */
/* 550 */	NdrFcShort( 0x112 ),	/* Offset= 274 (824) */
/* 552 */	NdrFcLong( 0x4015 ),	/* 16405 */
/* 556 */	NdrFcShort( 0x110 ),	/* Offset= 272 (828) */
/* 558 */	NdrFcLong( 0x4016 ),	/* 16406 */
/* 562 */	NdrFcShort( 0x10e ),	/* Offset= 270 (832) */
/* 564 */	NdrFcLong( 0x4017 ),	/* 16407 */
/* 568 */	NdrFcShort( 0x10c ),	/* Offset= 268 (836) */
/* 570 */	NdrFcLong( 0x0 ),	/* 0 */
/* 574 */	NdrFcShort( 0x0 ),	/* Offset= 0 (574) */
/* 576 */	NdrFcLong( 0x1 ),	/* 1 */
/* 580 */	NdrFcShort( 0x0 ),	/* Offset= 0 (580) */
/* 582 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (581) */
/* 584 */	
			0x15,		/* FC_STRUCT */
			0x7,		/* 7 */
/* 586 */	NdrFcShort( 0x8 ),	/* 8 */
/* 588 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 590 */	
			0x12, 0x0,	/* FC_UP */
/* 592 */	NdrFcShort( 0xfffffe2c ),	/* Offset= -468 (124) */
/* 594 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 596 */	NdrFcLong( 0x0 ),	/* 0 */
/* 600 */	NdrFcShort( 0x0 ),	/* 0 */
/* 602 */	NdrFcShort( 0x0 ),	/* 0 */
/* 604 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 606 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 608 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 610 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 612 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 614 */	NdrFcLong( 0x20400 ),	/* 132096 */
/* 618 */	NdrFcShort( 0x0 ),	/* 0 */
/* 620 */	NdrFcShort( 0x0 ),	/* 0 */
/* 622 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 624 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 626 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 628 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 630 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 632 */	NdrFcShort( 0x2 ),	/* Offset= 2 (634) */
/* 634 */	
			0x12, 0x0,	/* FC_UP */
/* 636 */	NdrFcShort( 0x214 ),	/* Offset= 532 (1168) */
/* 638 */	
			0x12, 0x0,	/* FC_UP */
/* 640 */	NdrFcShort( 0x1e ),	/* Offset= 30 (670) */
/* 642 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 644 */	NdrFcLong( 0x2f ),	/* 47 */
/* 648 */	NdrFcShort( 0x0 ),	/* 0 */
/* 650 */	NdrFcShort( 0x0 ),	/* 0 */
/* 652 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 654 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 656 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 658 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 660 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 662 */	NdrFcShort( 0x1 ),	/* 1 */
/* 664 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 666 */	NdrFcShort( 0x4 ),	/* 4 */
/* 668 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 670 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 672 */	NdrFcShort( 0x10 ),	/* 16 */
/* 674 */	NdrFcShort( 0x0 ),	/* 0 */
/* 676 */	NdrFcShort( 0xa ),	/* Offset= 10 (686) */
/* 678 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 680 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 682 */	NdrFcShort( 0xffffffd8 ),	/* Offset= -40 (642) */
/* 684 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 686 */	
			0x12, 0x0,	/* FC_UP */
/* 688 */	NdrFcShort( 0xffffffe4 ),	/* Offset= -28 (660) */
/* 690 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 692 */	0x1,		/* FC_BYTE */
			0x5c,		/* FC_PAD */
/* 694 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 696 */	0x6,		/* FC_SHORT */
			0x5c,		/* FC_PAD */
/* 698 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 700 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 702 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 704 */	0xb,		/* FC_HYPER */
			0x5c,		/* FC_PAD */
/* 706 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 708 */	0xa,		/* FC_FLOAT */
			0x5c,		/* FC_PAD */
/* 710 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 712 */	0xc,		/* FC_DOUBLE */
			0x5c,		/* FC_PAD */
/* 714 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 716 */	0x6,		/* FC_SHORT */
			0x5c,		/* FC_PAD */
/* 718 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 720 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 722 */	
			0x12, 0x0,	/* FC_UP */
/* 724 */	NdrFcShort( 0xffffff74 ),	/* Offset= -140 (584) */
/* 726 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 728 */	0xc,		/* FC_DOUBLE */
			0x5c,		/* FC_PAD */
/* 730 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 732 */	NdrFcShort( 0x2 ),	/* Offset= 2 (734) */
/* 734 */	
			0x12, 0x0,	/* FC_UP */
/* 736 */	NdrFcShort( 0xfffffd9c ),	/* Offset= -612 (124) */
/* 738 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 740 */	NdrFcShort( 0x2 ),	/* Offset= 2 (742) */
/* 742 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 744 */	NdrFcLong( 0x0 ),	/* 0 */
/* 748 */	NdrFcShort( 0x0 ),	/* 0 */
/* 750 */	NdrFcShort( 0x0 ),	/* 0 */
/* 752 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 754 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 756 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 758 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 760 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 762 */	NdrFcShort( 0x2 ),	/* Offset= 2 (764) */
/* 764 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 766 */	NdrFcLong( 0x20400 ),	/* 132096 */
/* 770 */	NdrFcShort( 0x0 ),	/* 0 */
/* 772 */	NdrFcShort( 0x0 ),	/* 0 */
/* 774 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 776 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 778 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 780 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 782 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 784 */	NdrFcShort( 0x2 ),	/* Offset= 2 (786) */
/* 786 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 788 */	NdrFcShort( 0x2 ),	/* Offset= 2 (790) */
/* 790 */	
			0x12, 0x0,	/* FC_UP */
/* 792 */	NdrFcShort( 0x178 ),	/* Offset= 376 (1168) */
/* 794 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 796 */	NdrFcShort( 0x2 ),	/* Offset= 2 (798) */
/* 798 */	
			0x12, 0x0,	/* FC_UP */
/* 800 */	NdrFcShort( 0x28 ),	/* Offset= 40 (840) */
/* 802 */	
			0x15,		/* FC_STRUCT */
			0x7,		/* 7 */
/* 804 */	NdrFcShort( 0x10 ),	/* 16 */
/* 806 */	0x6,		/* FC_SHORT */
			0x1,		/* FC_BYTE */
/* 808 */	0x1,		/* FC_BYTE */
			0x8,		/* FC_LONG */
/* 810 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 812 */	
			0x12, 0x0,	/* FC_UP */
/* 814 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (802) */
/* 816 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 818 */	0x2,		/* FC_CHAR */
			0x5c,		/* FC_PAD */
/* 820 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 822 */	0x6,		/* FC_SHORT */
			0x5c,		/* FC_PAD */
/* 824 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 826 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 828 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 830 */	0xb,		/* FC_HYPER */
			0x5c,		/* FC_PAD */
/* 832 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 834 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 836 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 838 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 840 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x7,		/* 7 */
/* 842 */	NdrFcShort( 0x20 ),	/* 32 */
/* 844 */	NdrFcShort( 0x0 ),	/* 0 */
/* 846 */	NdrFcShort( 0x0 ),	/* Offset= 0 (846) */
/* 848 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 850 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 852 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 854 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 856 */	NdrFcShort( 0xfffffdc8 ),	/* Offset= -568 (288) */
/* 858 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 860 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 862 */	NdrFcShort( 0x4 ),	/* 4 */
/* 864 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 866 */	NdrFcShort( 0x0 ),	/* 0 */
/* 868 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 870 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 872 */	NdrFcShort( 0x4 ),	/* 4 */
/* 874 */	NdrFcShort( 0x0 ),	/* 0 */
/* 876 */	NdrFcShort( 0x1 ),	/* 1 */
/* 878 */	NdrFcShort( 0x0 ),	/* 0 */
/* 880 */	NdrFcShort( 0x0 ),	/* 0 */
/* 882 */	0x12, 0x0,	/* FC_UP */
/* 884 */	NdrFcShort( 0xffffffd4 ),	/* Offset= -44 (840) */
/* 886 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 888 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 890 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 892 */	NdrFcShort( 0x8 ),	/* 8 */
/* 894 */	NdrFcShort( 0x0 ),	/* 0 */
/* 896 */	NdrFcShort( 0x6 ),	/* Offset= 6 (902) */
/* 898 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 900 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 902 */	
			0x11, 0x0,	/* FC_RP */
/* 904 */	NdrFcShort( 0xffffffd4 ),	/* Offset= -44 (860) */
/* 906 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 908 */	NdrFcShort( 0x4 ),	/* 4 */
/* 910 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 912 */	NdrFcShort( 0x0 ),	/* 0 */
/* 914 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 916 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 918 */	NdrFcShort( 0x4 ),	/* 4 */
/* 920 */	NdrFcShort( 0x0 ),	/* 0 */
/* 922 */	NdrFcShort( 0x1 ),	/* 1 */
/* 924 */	NdrFcShort( 0x0 ),	/* 0 */
/* 926 */	NdrFcShort( 0x0 ),	/* 0 */
/* 928 */	0x12, 0x0,	/* FC_UP */
/* 930 */	NdrFcShort( 0xfffffefc ),	/* Offset= -260 (670) */
/* 932 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 934 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 936 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 938 */	NdrFcShort( 0x8 ),	/* 8 */
/* 940 */	NdrFcShort( 0x0 ),	/* 0 */
/* 942 */	NdrFcShort( 0x6 ),	/* Offset= 6 (948) */
/* 944 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 946 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 948 */	
			0x11, 0x0,	/* FC_RP */
/* 950 */	NdrFcShort( 0xffffffd4 ),	/* Offset= -44 (906) */
/* 952 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 954 */	NdrFcShort( 0x8 ),	/* 8 */
/* 956 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 958 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 960 */	NdrFcShort( 0x10 ),	/* 16 */
/* 962 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 964 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 966 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffff1 ),	/* Offset= -15 (952) */
			0x5b,		/* FC_END */
/* 970 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 972 */	NdrFcLong( 0x0 ),	/* 0 */
/* 976 */	NdrFcShort( 0x0 ),	/* 0 */
/* 978 */	NdrFcShort( 0x0 ),	/* 0 */
/* 980 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 982 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 984 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 986 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 988 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 990 */	NdrFcShort( 0x0 ),	/* 0 */
/* 992 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 994 */	NdrFcShort( 0x0 ),	/* 0 */
/* 996 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1000 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1002 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (970) */
/* 1004 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1006 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1008 */	NdrFcShort( 0x18 ),	/* 24 */
/* 1010 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1012 */	NdrFcShort( 0xa ),	/* Offset= 10 (1022) */
/* 1014 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 1016 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1018 */	NdrFcShort( 0xffffffc4 ),	/* Offset= -60 (958) */
/* 1020 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1022 */	
			0x11, 0x0,	/* FC_RP */
/* 1024 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (988) */
/* 1026 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 1028 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1030 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1032 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1034 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 1036 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1038 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1040 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1042 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1044 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1046 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1048 */	0x12, 0x0,	/* FC_UP */
/* 1050 */	NdrFcShort( 0xffffffe8 ),	/* Offset= -24 (1026) */
/* 1052 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1054 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1056 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 1058 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1060 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1062 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1064 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 1066 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1068 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1070 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1072 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1074 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1076 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1078 */	0x12, 0x0,	/* FC_UP */
/* 1080 */	NdrFcShort( 0xffffffe8 ),	/* Offset= -24 (1056) */
/* 1082 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1084 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1086 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1088 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1090 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1092 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1094 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1096 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1098 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1100 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1102 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1104 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1106 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1108 */	0x12, 0x0,	/* FC_UP */
/* 1110 */	NdrFcShort( 0xffffffe8 ),	/* Offset= -24 (1086) */
/* 1112 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1114 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1116 */	
			0x1b,		/* FC_CARRAY */
			0x7,		/* 7 */
/* 1118 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1120 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1122 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1124 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 1126 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1128 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1130 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1132 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1134 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1136 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1138 */	0x12, 0x0,	/* FC_UP */
/* 1140 */	NdrFcShort( 0xffffffe8 ),	/* Offset= -24 (1116) */
/* 1142 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1144 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1146 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 1148 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1150 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1152 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1154 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1156 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1158 */	0x7,		/* Corr desc: FC_USHORT */
			0x0,		/*  */
/* 1160 */	NdrFcShort( 0xffd8 ),	/* -40 */
/* 1162 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1164 */	NdrFcShort( 0xffffffee ),	/* Offset= -18 (1146) */
/* 1166 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1168 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1170 */	NdrFcShort( 0x28 ),	/* 40 */
/* 1172 */	NdrFcShort( 0xffffffee ),	/* Offset= -18 (1154) */
/* 1174 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1174) */
/* 1176 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 1178 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1180 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1182 */	NdrFcShort( 0xfffffb90 ),	/* Offset= -1136 (46) */
/* 1184 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1186 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 1188 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1190 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1192 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1194 */	NdrFcShort( 0xfffffb7c ),	/* Offset= -1156 (38) */

			0x0
        }
    };

static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ] = 
        {
            
            {
            LPSAFEARRAY_UserSize
            ,LPSAFEARRAY_UserMarshal
            ,LPSAFEARRAY_UserUnmarshal
            ,LPSAFEARRAY_UserFree
            }

        };



/* Standard interface: __MIDL_itf_ivehandler_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IVEHandler, ver. 0.0,
   GUID={0x856CA1B2,0x7DAB,0x11d3,{0xAC,0xEC,0x00,0xC0,0x4F,0x86,0xC3,0x09}} */

#pragma code_seg(".orpc")
static const unsigned short IVEHandler_FormatStringOffsetTable[] =
    {
    0,
    40
    };

static const MIDL_STUBLESS_PROXY_INFO IVEHandler_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IVEHandler_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IVEHandler_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IVEHandler_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(5) _IVEHandlerProxyVtbl = 
{
    &IVEHandler_ProxyInfo,
    &IID_IVEHandler,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IVEHandler::VEHandler */ ,
    (void *) (INT_PTR) -1 /* IVEHandler::SetReporterFtn */
};

const CInterfaceStubVtbl _IVEHandlerStubVtbl =
{
    &IID_IVEHandler,
    &IVEHandler_ServerInfo,
    5,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x20000, /* Ndr library version */
    0,
    0x600015b, /* MIDL Version 6.0.347 */
    0,
    UserMarshalRoutines,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

const CInterfaceProxyVtbl * _ivehandler_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_IVEHandlerProxyVtbl,
    0
};

const CInterfaceStubVtbl * _ivehandler_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_IVEHandlerStubVtbl,
    0
};

PCInterfaceName const _ivehandler_InterfaceNamesList[] = 
{
    "IVEHandler",
    0
};


#define _ivehandler_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _ivehandler, pIID, n)

int __stdcall _ivehandler_IID_Lookup( const IID * pIID, int * pIndex )
{
    
    if(!_ivehandler_CHECK_IID(0))
        {
        *pIndex = 0;
        return 1;
        }

    return 0;
}

const ExtendedProxyFileInfo ivehandler_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _ivehandler_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _ivehandler_StubVtblList,
    (const PCInterfaceName * ) & _ivehandler_InterfaceNamesList,
    0, // no delegation
    & _ivehandler_IID_Lookup, 
    1,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};


#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\jitperf.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//-----------------------------------------------------------------------------
// JitPerf.h
// Internal interface for gathering JIT perfmormance stats. These stats are
// logged (or displayed) in two ways. If PERF_COUNTERS are enabled the 
// perfmon etc. would display the jit stats. If ENABLE_PERF_LOG is enabled
// and PERF_OUTPUT env var is defined then the jit stats are displayed on the 
// stdout. (The jit stats are outputted in a specific format to a file for 
// automated perf tests.)
//-----------------------------------------------------------------------------

#ifndef __JITPERF_H__
#define __JITPERF_H__


#if !defined(GOLDEN) 
// ENABLE_JIT_PERF tag used to activate JIT specific profiling.
#define ENABLE_JIT_PERF

// Currently, Jit perf piggeybacks some of perf counter code, so make sure
// perf counters are enabled. This can be easily changed. (search for
// ENABLE_PERF_COUNTERS and modify accordingly
//#if !defined (ENABLE_PERF_COUNTERS)
//#error "Can't use JitPerf without having PerfCounters"
//#endif // ENABLE_PERF_COUNTERS

#endif // !defined(GOLDEN) 

#if defined(ENABLE_JIT_PERF)

extern __int64 g_JitCycles;
extern size_t g_NonJitCycles;
extern CRITICAL_SECTION g_csJit;
extern __int64 g_tlsJitCycles;
extern DWORD g_dwTlsPerfIndex;
extern int g_fJitPerfOn;

extern size_t g_dwTlsx86CodeSize;
extern DWORD g_dwTlsx86CodeIndex;
extern size_t g_TotalILCodeSize;
extern size_t g_Totalx86CodeSize;
extern size_t g_TotalMethodsJitted;

// Public interface to initialize jit stats data structs
void InitJitPerf(void);
// Public interface to deallocate datastruct and output the stats.
void DoneJitPerfStats(void);

// Use the callee's stack frame (so START & STOP functions can share variables)
#define START_JIT_PERF()                                                \
    if (g_fJitPerfOn) {                                                 \
        TlsSetValue (g_dwTlsPerfIndex, (LPVOID)0);                      \
        g_dwTlsx86CodeSize = 0;                                         \
        TlsSetValue (g_dwTlsx86CodeIndex, (LPVOID)g_dwTlsx86CodeSize);  \
    } 


#define STOP_JIT_PERF()                                                 \
    if (g_fJitPerfOn) {                                                 \
        size_t dwTlsNonJitCycles = (size_t)TlsGetValue (g_dwTlsPerfIndex); \
        size_t dwx86CodeSize = (size_t)TlsGetValue (g_dwTlsx86CodeIndex); \
		LOCKCOUNTINCL("STOP_JIT_PERF in jitperf.h");						\
        EnterCriticalSection (&g_csJit);                                \
        g_JitCycles += (CycleStop.QuadPart - CycleStart.QuadPart);      \
        g_NonJitCycles += dwTlsNonJitCycles;                            \
        g_TotalILCodeSize += methodInfo.ILCodeSize;                     \
        g_Totalx86CodeSize += dwx86CodeSize;                            \
        g_TotalMethodsJitted ++;                                        \
        LeaveCriticalSection (&g_csJit);                                \
		LOCKCOUNTDECL("STOP_JIT_PERF in jitperf.h");					\
    }

#define START_NON_JIT_PERF()                                            \
    LARGE_INTEGER CycleStart = {0};                                           \
    if(g_fJitPerfOn) {                                                  \
        QueryPerformanceCounter (&CycleStart);                          \
    }

#define STOP_NON_JIT_PERF()                                             \
    LARGE_INTEGER CycleStop;                                            \
    if(g_fJitPerfOn) {                                                  \
        QueryPerformanceCounter(&CycleStop);                            \
        size_t pTlsNonJitCycles = (size_t)TlsGetValue (g_dwTlsPerfIndex); \
        TlsSetValue(g_dwTlsPerfIndex, (LPVOID)(pTlsNonJitCycles + CycleStop.QuadPart - CycleStart.QuadPart));   \
    }

#define JIT_PERF_UPDATE_X86_CODE_SIZE(size)                                 \
    if(g_fJitPerfOn) {                                                      \
        size_t dwx86CodeSize = (size_t)TlsGetValue (g_dwTlsx86CodeIndex);     \
        dwx86CodeSize += (size);                                            \
        TlsSetValue (g_dwTlsx86CodeIndex, (LPVOID)dwx86CodeSize);           \
    }


#else //ENABLE_JIT_PERF
#define START_JIT_PERF()
#define STOP_JIT_PERF()
#define START_NON_JIT_PERF()
#define STOP_NON_JIT_PERF()
#define JIT_PERF_UPDATE_X86_CODE_SIZE(size)                 
#endif //ENABLE_JIT_PERF

#endif //__JITPERF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\license_p.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Thu Feb 20 18:27:19 2003
 */
/* Compiler settings for license.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)
#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 440
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "license.h"

#define TYPE_FORMAT_STRING_SIZE   49                                
#define PROC_FORMAT_STRING_SIZE   85                                
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   1            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ILicense_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ILicense_ProxyInfo;


extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ];

#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT40_OR_LATER)
#error You need a Windows NT 4.0 or later to run this stub because it uses these features:
#error   -Oif or -Oicf, [wire_marshal] or [user_marshal] attribute.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure GetRuntimeKey */

			0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x3 ),	/* 3 */
/*  8 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 10 */	NdrFcShort( 0x0 ),	/* 0 */
/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
/* 14 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter pbKey */

/* 16 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 18 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 20 */	NdrFcShort( 0x1e ),	/* Type Offset=30 */

	/* Return value */

/* 22 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 24 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 26 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure IsLicenseVerified */

/* 28 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 30 */	NdrFcLong( 0x0 ),	/* 0 */
/* 34 */	NdrFcShort( 0x4 ),	/* 4 */
/* 36 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 38 */	NdrFcShort( 0x0 ),	/* 0 */
/* 40 */	NdrFcShort( 0x24 ),	/* 36 */
/* 42 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pLicenseVerified */

/* 44 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 46 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 48 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 50 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 52 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 54 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure IsRuntimeKeyAvailable */

/* 56 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 58 */	NdrFcLong( 0x0 ),	/* 0 */
/* 62 */	NdrFcShort( 0x5 ),	/* 5 */
/* 64 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 66 */	NdrFcShort( 0x0 ),	/* 0 */
/* 68 */	NdrFcShort( 0x24 ),	/* 36 */
/* 70 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pKeyAvailable */

/* 72 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 74 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 76 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 78 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 80 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 82 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/*  4 */	NdrFcShort( 0x1a ),	/* Offset= 26 (30) */
/*  6 */	
			0x13, 0x0,	/* FC_OP */
/*  8 */	NdrFcShort( 0xc ),	/* Offset= 12 (20) */
/* 10 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 12 */	NdrFcShort( 0x2 ),	/* 2 */
/* 14 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 16 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 18 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 20 */	
			0x17,		/* FC_CSTRUCT */
			0x3,		/* 3 */
/* 22 */	NdrFcShort( 0x8 ),	/* 8 */
/* 24 */	NdrFcShort( 0xfffffff2 ),	/* Offset= -14 (10) */
/* 26 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 28 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 30 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 32 */	NdrFcShort( 0x0 ),	/* 0 */
/* 34 */	NdrFcShort( 0x4 ),	/* 4 */
/* 36 */	NdrFcShort( 0x0 ),	/* 0 */
/* 38 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (6) */
/* 40 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 42 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 44 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 46 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */

			0x0
        }
    };

static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ] = 
        {
            
            {
            BSTR_UserSize
            ,BSTR_UserMarshal
            ,BSTR_UserUnmarshal
            ,BSTR_UserFree
            }

        };



/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: ILicense, ver. 0.0,
   GUID={0xB93F97E9,0x782F,0x11d3,{0x99,0x51,0x00,0x00,0xF8,0x05,0xBF,0xB0}} */

#pragma code_seg(".orpc")
static const unsigned short ILicense_FormatStringOffsetTable[] =
    {
    0,
    28,
    56
    };

static const MIDL_STUBLESS_PROXY_INFO ILicense_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ILicense_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ILicense_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ILicense_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(6) _ILicenseProxyVtbl = 
{
    &ILicense_ProxyInfo,
    &IID_ILicense,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ILicense::GetRuntimeKey */ ,
    (void *) (INT_PTR) -1 /* ILicense::IsLicenseVerified */ ,
    (void *) (INT_PTR) -1 /* ILicense::IsRuntimeKeyAvailable */
};

const CInterfaceStubVtbl _ILicenseStubVtbl =
{
    &IID_ILicense,
    &ILicense_ServerInfo,
    6,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x20000, /* Ndr library version */
    0,
    0x600015b, /* MIDL Version 6.0.347 */
    0,
    UserMarshalRoutines,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

const CInterfaceProxyVtbl * _license_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_ILicenseProxyVtbl,
    0
};

const CInterfaceStubVtbl * _license_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_ILicenseStubVtbl,
    0
};

PCInterfaceName const _license_InterfaceNamesList[] = 
{
    "ILicense",
    0
};


#define _license_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _license, pIID, n)

int __stdcall _license_IID_Lookup( const IID * pIID, int * pIndex )
{
    
    if(!_license_CHECK_IID(0))
        {
        *pIndex = 0;
        return 1;
        }

    return 0;
}

const ExtendedProxyFileInfo license_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _license_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _license_StubVtblList,
    (const PCInterfaceName * ) & _license_InterfaceNamesList,
    0, // no delegation
    & _license_IID_Lookup, 
    1,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};


#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\machine.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ===========================================================================
// File: Machine.h
// 
// ===========================================================================
#ifndef _MACHINE_H_
#define _MACHINE_H_
#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifdef WIN32

#define INC_OLE2
#include <windows.h>
#ifdef INIT_GUIDS
#include <initguid.h>
#endif

#else

#include <varargs.h>

#ifndef DWORD
#define	DWORD	unsigned long
#endif

#endif // !WIN32


typedef unsigned __int64    QWORD;

#endif // ifndef _MACHINE_H_
// EOF =======================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\log.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// Logging Facility
//


// Logging Subsystems

#ifndef __LOG_H__
#define __LOG_H__


#define DEFINE_LOG_FACILITY(logname, value)  logname = value,

enum {
#include "loglf.h"
	LF_ALWAYS		= 0x80000000,
    LF_ALL          = 0xFFFFFFFF
};


#define LL_EVERYTHING  10   
#define LL_INFO1000000  9       // can be expected to generate 1,000,000 logs per small but not trival run
#define LL_INFO100000   8       // can be expected to generate 100,000 logs per small but not trival run
#define LL_INFO10000    7       // can be expected to generate 10,000 logs per small but not trival run
#define LL_INFO1000     6       // can be expected to generate 1,000 logs per small but not trival run
#define LL_INFO100      5       // can be expected to generate 100 logs per small but not trival run
#define LL_INFO10       4       // can be expected to generate 10 logs per small but not trival run
#define LL_WARNING      3
#define LL_ERROR        2
#define LL_FATALERROR   1
#define LL_ALWAYS   	0		// impossible to turn off (log level never negative)


#define INFO5       LL_INFO10
#define INFO4       LL_INFO100
#define INFO3       LL_INFO1000
#define INFO2       LL_INFO10000
#define INFO1       LL_INFO100000
#define WARNING     0
#define ERROR       0
#define FATALERROR  0

#ifndef LOGGING

#define LOG(x)

#define InitializeLogging()
#define InitLogging()
#define ShutdownLogging()
#define FlushLogging()
#define LoggingOn(facility, level) 0

#else

extern VOID InitializeLogging();
extern VOID InitLogging();
extern VOID ShutdownLogging();
extern VOID FlushLogging();
extern VOID LogSpew(DWORD facility, DWORD level, char *fmt, ... );
extern VOID LogSpewValist(DWORD facility, DWORD level, char* fmt, va_list args);
extern VOID LogSpewAlways (char *fmt, ... );

VOID AddLoggingFacility( DWORD facility );
VOID SetLoggingLevel( DWORD level );
bool LoggingEnabled();
bool LoggingOn(DWORD facility, DWORD level);

#define LOG(x)      do { if (LoggingEnabled()) LogSpew x; } while (0)
#endif

#ifdef __cplusplus
#include "stresslog.h"		// special logging for retail code
#endif

#endif //__LOG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\makefile.inc ===
MKTYPLIBLINK = $(LINKER) -Incremental:NO
TLBLINKFLAGS = \
	-dll \
	-nodefaultlib \
	-debug:none \
	-noentry \
	-heap:0,0 \
	-stack:0,0 \

C_DEFINES = $(C_DEFINES) -DREAL_TLB_FILE=mscoree.tlb


opcode.refops: opcode.def genrops.pl
	perl genrops.pl < opcode.def > opcode.refops

$(O)\mscoree.tlb: $(O)\mscoree_mktlb.res
    $(MKTYPLIBLINK) $(TLBLINKFLAGS) -out:$@ $(O)\mscoree_mktlb.res

extra_copy: $(O)\mscoree.tlb CPImporterItf.tlb
!if "$(TARGETCOMPLUS)" != ""
    echo y|xcopy /D $(O)\mscoree.tlb .
    echo y|xcopy /D $(O)\mscoree.tlb $(TARGETCOMPLUS)
    echo y|xcopy /D CPImporterItf.tlb $(TARGETCOMPLUS)
    echo y|xcopy /D $(TARGETPATHLIB)\$(TARGET_DIRECTORY)\$(DDKBUILDENV)\corguids.pdb $(TARGETCOMPLUS)\Symbols.Pri
    
    echo y|xcopy /D CPImporterItf.tlb $(TARGETCORBIN)\$(TARGET_DIRECTORY)\$(DDKBUILDENV)
!endif

doscript: 
!if "$(TARGETCOMPLUS)" != ""
	binplace -e -r $(TARGETCOMPLUS) -p $(BINPLACE_PLACEFILE) *.h *.idl *.cpp opcode.def $(TARGETPATHLIB)\$(TARGET_DIRECTORY)\$(DDKBUILDENV)\corguids.lib
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\mdcommon.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// MDCommon.h
//
// Common header file for both MD and COMPLIB subdirectories
//
//*****************************************************************************
#ifndef __MDCommon_h__
#define __MDCommon_h__

// File types for the database.
enum FILETYPE
{	
	FILETYPE_UNKNOWN,					// Unknown or undefined type.
	FILETYPE_CLB,						// Native .clb file format.
	FILETYPE_CLX, 					    // An obsolete file format.
	FILETYPE_NTPE,						// Windows PE executable.
	FILETYPE_NTOBJ, 					// .obj file format (with .clb embedded).
	FILETYPE_TLB						// Typelib format.
};


#define SCHEMA_STREAM_A				"#Schema"
#define STRING_POOL_STREAM_A		"#Strings"
#define BLOB_POOL_STREAM_A			"#Blob"
#define US_BLOB_POOL_STREAM_A		"#US"
#define VARIANT_POOL_STREAM_A 		"#Variants"
#define GUID_POOL_STREAM_A			"#GUID"
#define COMPRESSED_MODEL_STREAM_A	"#~"
#define ENC_MODEL_STREAM_A			"#-"

#define SCHEMA_STREAM				L"#Schema"
#define STRING_POOL_STREAM			L"#Strings"
#define BLOB_POOL_STREAM			L"#Blob"
#define US_BLOB_POOL_STREAM			L"#US"
#define VARIANT_POOL_STREAM			L"#Variants"
#define GUID_POOL_STREAM			L"#GUID"
#define COMPRESSED_MODEL_STREAM		L"#~"
#define ENC_MODEL_STREAM			L"#-"

#endif // __MDCommon_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\member-offset-info.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

#ifndef MEMBER_OFFSET_INFO
#define MEMBER_OFFSET_INFO(klass) klass ## _member_offset_info
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\md5.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// md5.h
//
// A pretty-darned fast implementation of MD5
//

#ifndef __MD5_H__
#define __MD5_H__

/////////////////////////////////////////////////////////////////////////////////////
//
// Declaration of the central transform function
//
void __stdcall MD5Transform(ULONG state[4], const ULONG* data);
        
/////////////////////////////////////////////////////////////////////////////////////

#pragma pack(push, 1)


// This structure is used to return the final resulting hash.
// 
struct MD5HASHDATA
    {
    union
        {
        BYTE rgb[16];
        struct
            {
            ULONGLONG ullLow;
            ULONGLONG ullHigh;
            };
        struct
            {
            ULONG     u0;
            ULONG     u1;
            ULONG     u2;
            ULONG     u3;
            };
        };
    };

inline BOOL operator==(const MD5HASHDATA& me, const MD5HASHDATA& him)
    {
    return memcmp(&me, &him, sizeof(MD5HASHDATA)) == 0;
    }

inline BOOL operator!=(const MD5HASHDATA& me, const MD5HASHDATA& him)
    {
    return memcmp(&me, &him, sizeof(MD5HASHDATA)) != 0;
    }


// The engine that carries out the hash
//
class MD5
    {
    // These four values must be contiguous, and in this order
    union
        {
        ULONG       m_state[4];
        struct
            {
            ULONG       m_a;              // state 
            ULONG       m_b;              //     ... variables
            ULONG       m_c;              //            ... as found in
            ULONG       m_d;              //                    ... RFC1321
            };
        };
    
    BYTE        m_data[64];       // where to accumulate the data as we are passed it
    ULONGLONG   m_cbitHashed;     // amount of data that we've hashed
    ULONG       m_cbData;         // number of bytes presently in data
    
    BYTE        m_padding[64];    // padding data, used if length data not = 0 mod 64

public:

    /////////////////////////////////////////////////////////////////////////////////////

    void Hash(const BYTE* pbData, ULONG cbData, MD5HASHDATA* phash, BOOL fConstructed = FALSE)
        {
        Init(fConstructed);
        HashMore(pbData, cbData);
        GetHashValue(phash);
        }

    /////////////////////////////////////////////////////////////////////////////////////

    void Hash(const BYTE* pbData, ULONGLONG cbData, MD5HASHDATA* phash, BOOL fConstructed = FALSE)
        {
        Init(fConstructed);

        ULARGE_INTEGER ul;
        ul.QuadPart = cbData;

        while (ul.HighPart)
            {
            ULONG cbHash = 0xFFFFFFFF;                      // Hash as much as we can at once
            HashMore(pbData, cbHash);
            pbData      += cbHash;
            ul.QuadPart -= cbHash;
            }
        
        HashMore(pbData, ul.LowPart);                       // Hash whatever is left

        GetHashValue(phash);
        }

    /////////////////////////////////////////////////////////////////////////////////////

    void Init(BOOL fConstructed = FALSE);

    /////////////////////////////////////////////////////////////////////////////////////

    void HashMore(const void* pvInput, ULONG cbInput);

    /////////////////////////////////////////////////////////////////////////////////////

    void GetHashValue(MD5HASHDATA* phash);

    /////////////////////////////////////////////////////////////////////////////////////

    };

#pragma pack(pop)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\metadata.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//****************************************************************************
//  File: metadata.h
//  Notes:
//   Common includes for EE & metadata internal. This file contains
//   definition of CorMetaDataScope
//****************************************************************************
#ifndef _METADATA_H_
#define _METADATA_H_

#include "..\md\inc\MetaModelRO.h"
#include "..\md\inc\LiteWeightStgdb.h"

class UTSemReadWrite;

inline int IsGlobalMethodParentTk(mdTypeDef td)
{
    return (td == mdTypeDefNil || td == mdTokenNil);
}

typedef enum CorInternalStates
{
    tdNoTypes               = 0x00000000,
    tdAllAssemblies         = 0x00000001,
    tdAllTypes              = 0xffffffff,
} CorInternalStates;

//
// MetaData custom value names.
//
enum CorIfaceAttr
{
    ifDual      = 0,            // Interface derives from IDispatch.
    ifVtable    = 1,            // Interface derives from IUnknown.
    ifDispatch  = 2,            // Interface is a dispinterface.
    ifLast      = 3,            // The last member of the enum.
};


enum CorClassIfaceAttr
{
    clsIfNone      = 0,                 // No class interface is generated.
    clsIfAutoDisp  = 1,                 // A dispatch only class interface is generated.
    clsIfAutoDual  = 2,                 // A dual class interface is generated.
    clsIfLast      = 3,                 // The last member of the enum.
};

//
// The default values for the COM interface and class interface types.
//
#define DEFAULT_COM_INTERFACE_TYPE ifDual
#define DEFAULT_CLASS_INTERFACE_TYPE clsIfAutoDisp

#define HANDLE_UNCOMPRESSED(func) (E_FAIL)
#define HANDLE_UNCOMPRESSED_BOOL(func) (false)

class TOKENLIST : public CDynArray<mdToken> 
{
};


typedef enum tagEnumType
{
    MDSimpleEnum        = 0x0,                  // simple enumerator that doesn't allocate memory 

    // You could get this kind of enum if you perform a non-simple query (such as EnumMethodWithName).
    // 
    MDDynamicArrayEnum = 0x2,                   // dynamic array that holds tokens
} EnumType;

//*****************************************
// Enumerator used by MetaDataInternal
//***************************************** 
struct HENUMInternal
{
    DWORD       m_tkKind;                   // kind of tables that the enum is holding the result
    ULONG       m_ulCount;                  // count of total entries holding by the enumerator
    EnumType    m_EnumType;

    // m_cursor will go away when we no longer support running EE with uncompressed
    // format.
    //
    char        m_cursor[32];               // cursor holding query result for read/write mode
    // TOKENLIST    daTKList;               // dynamic arrays of token list
    struct {
        ULONG   m_ulStart;
        ULONG   m_ulEnd;
        ULONG   m_ulCur;
    };
    HENUMInternal() : m_EnumType(MDSimpleEnum) {}

    // in-place initialization
    static void InitDynamicArrayEnum(
        HENUMInternal   *pEnum);            // HENUMInternal to be initialized

    static void InitSimpleEnum(
        DWORD           tkKind,             // kind of token that we are iterating
        ULONG           ridStart,           // starting rid
        ULONG           ridEnd,             // end rid
        HENUMInternal   *pEnum);            // HENUMInternal to be initialized

    // This will only clear the content of enum and will not free the memory of enum
    static void ClearEnum(
        HENUMInternal   *pmdEnum);

    // create a HENUMInternal. This will allocate the memory
    static HRESULT CreateSimpleEnum(
        DWORD           tkKind,             // kind of token that we are iterating
        ULONG           ridStart,           // starting rid
        ULONG           ridEnd,             // end rid
        HENUMInternal   **ppEnum);          // return the created HENUMInternal

    static HRESULT CreateDynamicArrayEnum(
        DWORD           tkKind,             // kind of token that we are iterating
        HENUMInternal   **ppEnum);          // return the created HENUMInternal

    // Destory Enum. This will free the memory
    static void DestroyEnum(
        HENUMInternal   *pmdEnum);

    static void DestroyEnumIfEmpty(
        HENUMInternal   **ppEnum);          // reset the enumerator pointer to NULL if empty
        
    static HRESULT EnumWithCount(
        HENUMInternal   *pEnum,             // enumerator
        ULONG           cMax,               // max tokens that caller wants
        mdToken         rTokens[],          // output buffer to fill the tokens
        ULONG           *pcTokens);         // number of tokens fill to the buffer upon return

    static HRESULT EnumWithCount(
        HENUMInternal   *pEnum,             // enumerator
        ULONG           cMax,               // max tokens that caller wants
        mdToken         rTokens1[],         // first output buffer to fill the tokens
        mdToken         rTokens2[],         // second output buffer to fill the tokens
        ULONG           *pcTokens);         // number of tokens fill to the buffer upon return

    static HRESULT AddElementToEnum(
        HENUMInternal   *pEnum,             // return the created HENUMInternal
        mdToken         tk);                // token value to be stored

    //*****************************************
    // Get next value contained in the enumerator
    //***************************************** 
    static bool EnumNext(
        HENUMInternal *phEnum,              // [IN] the enumerator to retrieve information  
        mdToken     *ptk);                  // [OUT] token to scope the search

};



//*****************************************
// Default Value for field, param or property. Returned by GetDefaultValue
//***************************************** 
typedef struct _MDDefaultValue
{
    // type of default value 
    BYTE            m_bType;                // CorElementType for the default value

    // the default value
    union
    {
        BOOL        m_bValue;               // ELEMENT_TYPE_BOOLEAN
        CHAR        m_cValue;               // ELEMENT_TYPE_I1
        BYTE        m_byteValue;            // ELEMENT_TYPE_UI1
        SHORT       m_sValue;               // ELEMENT_TYPE_I2
        USHORT      m_usValue;              // ELEMENT_TYPE_UI2
        LONG        m_lValue;               // ELEMENT_TYPE_I4
        ULONG       m_ulValue;              // ELEMENT_TYPE_UI4
        LONGLONG    m_llValue;              // ELEMENT_TYPE_I8
        ULONGLONG   m_ullValue;             // ELEMENT_TYPE_UI8
        FLOAT       m_fltValue;             // ELEMENT_TYPE_R4
        DOUBLE      m_dblValue;             // ELEMENT_TYPE_R8
        LPCWSTR     m_wzValue;              // ELEMENT_TYPE_STRING
        IUnknown    *m_unkValue;            // ELEMENT_TYPE_CLASS       
    };
    ULONG   m_cbSize;   // default value size (for blob)
    
} MDDefaultValue;



//*****************************************
// structure use to in GetAllEventAssociates and GetAllPropertyAssociates
//*****************************************
typedef struct
{
    mdMethodDef m_memberdef;
    DWORD       m_dwSemantics;
} ASSOCIATE_RECORD;
 

//
// structure use to retrieve class layout informaiton
//
typedef struct
{
    RID         m_ridFieldCur;          // indexing to the field table
    RID         m_ridFieldEnd;          // end index to field table
} MD_CLASS_LAYOUT;


// Structure for describing the Assembly MetaData.
typedef struct
{
    USHORT      usMajorVersion;         // Major Version.   
    USHORT      usMinorVersion;         // Minor Version.
    USHORT      usBuildNumber;          // Build Number.
    USHORT      usRevisionNumber;       // Revision Number.
    LPCSTR      szLocale;               // Locale.
    DWORD       *rProcessor;            // Processor array.
    ULONG       ulProcessor;            // [IN/OUT] Size of the processor array/Actual # of entries filled in.
    OSINFO      *rOS;                   // OSINFO array.
    ULONG       ulOS;                   // [IN/OUT]Size of the OSINFO array/Actual # of entries filled in.
} AssemblyMetaDataInternal;


HRESULT STDMETHODCALLTYPE CoGetMDInternalDisp(
    REFIID riid,
    void** ppv);


// Callback definition for comparing signatures.
// (*PSIGCOMPARE) (BYTE ScopeSignature[], DWORD ScopeSignatureLength, 
//                 BYTE ExternalSignature[], DWORD ExternalSignatureLength, 
//                 void* SignatureData);
typedef BOOL (*PSIGCOMPARE)(PCCOR_SIGNATURE, DWORD, PCCOR_SIGNATURE, DWORD, void*);


// {CE0F34EE-BBC6-11d2-941E-0000F8083460}
extern const GUID DECLSPEC_SELECT_ANY IID_IMDInternalDispenser =
{ 0xce0f34ee, 0xbbc6, 0x11d2, { 0x94, 0x1e, 0x0, 0x0, 0xf8, 0x8, 0x34, 0x60 } };


#undef  INTERFACE
#define INTERFACE IMDInternalDispenser
DECLARE_INTERFACE_(IMDInternalDispenser, IUnknown)
{
    // *** IMetaDataInternal methods ***
    STDMETHOD(OpenScopeOnMemory)(     
        LPVOID      pData, 
        ULONG       cbData, 
        REFIID      riid, 
        IUnknown    **ppIUnk) PURE;
};



// {CE0F34ED-BBC6-11d2-941E-0000F8083460}
extern const GUID DECLSPEC_SELECT_ANY IID_IMDInternalImport =
{ 0xce0f34ed, 0xbbc6, 0x11d2, { 0x94, 0x1e, 0x0, 0x0, 0xf8, 0x8, 0x34, 0x60 } };

#undef  INTERFACE
#define INTERFACE IMDInternalImport
DECLARE_INTERFACE_(IMDInternalImport, IUnknown)
{

    //*****************************************************************************
    // return the count of entries of a given kind in a scope 
    // For example, pass in mdtMethodDef will tell you how many MethodDef 
    // contained in a scope
    //*****************************************************************************
    STDMETHOD_(ULONG, GetCountWithTokenKind)(// return hresult
        DWORD       tkKind) PURE;           // [IN] pass in the kind of token. 

    //*****************************************************************************
    // enumerator for typedef
    //*****************************************************************************
    STDMETHOD(EnumTypeDefInit)(             // return hresult
        HENUMInternal *phEnum) PURE;        // [OUT] buffer to fill for enumerator data

    STDMETHOD_(ULONG, EnumTypeDefGetCount)(
        HENUMInternal *phEnum) PURE;        // [IN] the enumerator to retrieve information  

    STDMETHOD_(void, EnumTypeDefReset)(
        HENUMInternal *phEnum) PURE;        // [IN] the enumerator to retrieve information  

    STDMETHOD_(bool, EnumTypeDefNext)(      // return hresult
        HENUMInternal *phEnum,              // [IN] input enum
        mdTypeDef   *ptd) PURE;             // [OUT] return token

    STDMETHOD_(void, EnumTypeDefClose)(
        HENUMInternal *phEnum) PURE;        // [IN] the enumerator to retrieve information  

    //*****************************************************************************
    // enumerator for MethodImpl
    //*****************************************************************************
    STDMETHOD(EnumMethodImplInit)(          // return hresult
        mdTypeDef       td,                 // [IN] TypeDef over which to scope the enumeration.
        HENUMInternal   *phEnumBody,        // [OUT] buffer to fill for enumerator data for MethodBody tokens.
        HENUMInternal   *phEnumDecl) PURE;  // [OUT] buffer to fill for enumerator data for MethodDecl tokens.

    STDMETHOD_(ULONG, EnumMethodImplGetCount)(
        HENUMInternal   *phEnumBody,        // [IN] MethodBody enumerator.  
        HENUMInternal   *phEnumDecl) PURE;  // [IN] MethodDecl enumerator.

    STDMETHOD_(void, EnumMethodImplReset)(
        HENUMInternal   *phEnumBody,        // [IN] MethodBody enumerator.
        HENUMInternal   *phEnumDecl) PURE;  // [IN] MethodDecl enumerator.

    STDMETHOD_(bool, EnumMethodImplNext)(   // return hresult
        HENUMInternal   *phEnumBody,        // [IN] input enum for MethodBody
        HENUMInternal   *phEnumDecl,        // [IN] input enum for MethodDecl
        mdToken         *ptkBody,           // [OUT] return token for MethodBody
        mdToken         *ptkDecl) PURE;     // [OUT] return token for MethodDecl

    STDMETHOD_(void, EnumMethodImplClose)(
        HENUMInternal   *phEnumBody,        // [IN] MethodBody enumerator.
        HENUMInternal   *phEnumDecl) PURE;  // [IN] MethodDecl enumerator.

    //*****************************************
    // Enumerator helpers for memberdef, memberref, interfaceimp,
    // event, property, exception, param
    //***************************************** 

    STDMETHOD(EnumGlobalFunctionsInit)(     // return hresult
        HENUMInternal   *phEnum) PURE;      // [OUT] buffer to fill for enumerator data

    STDMETHOD(EnumGlobalFieldsInit)(        // return hresult
        HENUMInternal   *phEnum) PURE;      // [OUT] buffer to fill for enumerator data

    STDMETHOD(EnumInit)(                    // return S_FALSE if record not found
        DWORD       tkKind,                 // [IN] which table to work on
        mdToken     tkParent,               // [IN] token to scope the search
        HENUMInternal *phEnum) PURE;        // [OUT] the enumerator to fill 

    STDMETHOD(EnumAllInit)(                 // return S_FALSE if record not found
        DWORD       tkKind,                 // [IN] which table to work on
        HENUMInternal *phEnum) PURE;        // [OUT] the enumerator to fill 

    STDMETHOD_(bool, EnumNext)(
        HENUMInternal *phEnum,              // [IN] the enumerator to retrieve information  
        mdToken     *ptk) PURE;             // [OUT] token to scope the search

    STDMETHOD_(ULONG, EnumGetCount)(
        HENUMInternal *phEnum) PURE;        // [IN] the enumerator to retrieve information  

    STDMETHOD_(void, EnumReset)(
        HENUMInternal *phEnum) PURE;        // [IN] the enumerator to be reset  

    STDMETHOD_(void, EnumClose)(
        HENUMInternal *phEnum) PURE;        // [IN] the enumerator to be closed

    //*****************************************
    // Enumerator helpers for declsecurity.
    //*****************************************
    STDMETHOD(EnumPermissionSetsInit)(      // return S_FALSE if record not found
        mdToken     tkParent,               // [IN] token to scope the search
        CorDeclSecurity Action,             // [IN] Action to scope the search
        HENUMInternal *phEnum) PURE;        // [OUT] the enumerator to fill 

    //*****************************************
    // Enumerator helpers for CustomAttribute
    //*****************************************
    STDMETHOD(EnumCustomAttributeByNameInit)(// return S_FALSE if record not found
        mdToken     tkParent,               // [IN] token to scope the search
        LPCSTR      szName,                 // [IN] CustomAttribute's name to scope the search
        HENUMInternal *phEnum) PURE;        // [OUT] the enumerator to fill 

    //*****************************************
    // Nagivator helper to navigate back to the parent token given a token.
    // For example, given a memberdef token, it will return the containing typedef.
    //
    // the mapping is as following:
    //  ---given child type---------parent type
    //  mdMethodDef                 mdTypeDef
    //  mdFieldDef                  mdTypeDef
    //  mdInterfaceImpl             mdTypeDef
    //  mdParam                     mdMethodDef
    //  mdProperty                  mdTypeDef
    //  mdEvent                     mdTypeDef
    //
    //***************************************** 
    STDMETHOD(GetParentToken)(
        mdToken     tkChild,                // [IN] given child token
        mdToken     *ptkParent) PURE;       // [OUT] returning parent

    //*****************************************
    // Custom value helpers
    //***************************************** 
    STDMETHOD_(void, GetCustomAttributeProps)(  // S_OK or error.
        mdCustomAttribute at,               // [IN] The attribute.
        mdToken     *ptkType) PURE;         // [OUT] Put attribute type here.

    STDMETHOD_(void, GetCustomAttributeAsBlob)(
        mdCustomAttribute cv,               // [IN] given custom value token
        void const  **ppBlob,               // [OUT] return the pointer to internal blob
        ULONG       *pcbSize) PURE;         // [OUT] return the size of the blob

    STDMETHOD_(void, GetScopeProps)(
        LPCSTR      *pszName,               // [OUT] scope name
        GUID        *pmvid) PURE;           // [OUT] version id

    // finding a particular method 
    STDMETHOD(FindMethodDef)(
        mdTypeDef   classdef,               // [IN] given typedef
        LPCSTR      szName,                 // [IN] member name
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of CLR signature
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob
        mdMethodDef *pmd) PURE;             // [OUT] matching memberdef

    // return a iSeq's param given a MethodDef
    STDMETHOD(FindParamOfMethod)(           // S_OK or error.
        mdMethodDef md,                     // [IN] The owning method of the param.
        ULONG       iSeq,                   // [IN] The sequence # of the param.
        mdParamDef  *pparamdef) PURE;       // [OUT] Put ParamDef token here.

    //*****************************************
    //
    // GetName* functions
    //
    //*****************************************

    // return the name and namespace of typedef
    STDMETHOD_(void, GetNameOfTypeDef)(
        mdTypeDef   classdef,               // given classdef
        LPCSTR      *pszname,               // return class name(unqualified)
        LPCSTR      *psznamespace) PURE;    // return the name space name

    STDMETHOD(GetIsDualOfTypeDef)(
        mdTypeDef   classdef,               // [IN] given classdef.
        ULONG       *pDual) PURE;           // [OUT] return dual flag here.

    STDMETHOD(GetIfaceTypeOfTypeDef)(
        mdTypeDef   classdef,               // [IN] given classdef.
        ULONG       *pIface) PURE;          // [OUT] 0=dual, 1=vtable, 2=dispinterface

    // get the name of either methoddef
    STDMETHOD_(LPCSTR, GetNameOfMethodDef)( // return the name of the memberdef in UTF8
        mdMethodDef md) PURE;               // given memberdef

    STDMETHOD_(LPCSTR, GetNameAndSigOfMethodDef)(
        mdMethodDef methoddef,              // [IN] given memberdef
        PCCOR_SIGNATURE *ppvSigBlob,        // [OUT] point to a blob value of CLR signature
        ULONG       *pcbSigBlob) PURE;      // [OUT] count of bytes in the signature blob
    
    // return the name of a FieldDef
    STDMETHOD_(LPCSTR, GetNameOfFieldDef)(
        mdFieldDef  fd) PURE;               // given memberdef

    // return the name of typeref
    STDMETHOD_(void, GetNameOfTypeRef)(
        mdTypeRef   classref,               // [IN] given typeref
        LPCSTR      *psznamespace,          // [OUT] return typeref name
        LPCSTR      *pszname) PURE;         // [OUT] return typeref namespace

    // return the resolutionscope of typeref
    STDMETHOD_(mdToken, GetResolutionScopeOfTypeRef)(
        mdTypeRef   classref) PURE;         // given classref

    // Find the type token given the name.
    STDMETHOD(FindTypeRefByName)(
        LPCSTR      szNamespace,            // [IN] Namespace for the TypeRef.
        LPCSTR      szName,                 // [IN] Name of the TypeRef.
        mdToken     tkResolutionScope,      // [IN] Resolution Scope fo the TypeRef.
        mdTypeRef   *ptk) PURE;             // [OUT] TypeRef token returned.

    // return the TypeDef properties
    STDMETHOD_(void, GetTypeDefProps)(  
        mdTypeDef   classdef,               // given classdef
        DWORD       *pdwAttr,               // return flags on class, tdPublic, tdAbstract
        mdToken     *ptkExtends) PURE;      // [OUT] Put base class TypeDef/TypeRef here

    // return the item's guid
    STDMETHOD(GetItemGuid)(     
        mdToken     tkObj,                  // [IN] given item.
        CLSID       *pGuid) PURE;           // [out[ put guid here.

    // Get enclosing class of the NestedClass.
    STDMETHOD(GetNestedClassProps)(         // S_OK or error
        mdTypeDef   tkNestedClass,          // [IN] NestedClass token.
        mdTypeDef   *ptkEnclosingClass) PURE; // [OUT] EnclosingClass token.

    // Get count of Nested classes given the enclosing class.
    STDMETHOD_(ULONG, GetCountNestedClasses)(   // return count of Nested classes.
        mdTypeDef   tkEnclosingClass) PURE; // Enclosing class.

    // Return array of Nested classes given the enclosing class.
    STDMETHOD_(ULONG, GetNestedClasses)(        // Return actual count.
        mdTypeDef   tkEnclosingClass,       // [IN] Enclosing class.
        mdTypeDef   *rNestedClasses,        // [OUT] Array of nested class tokens.
        ULONG       ulNestedClasses) PURE;  // [IN] Size of array.

    // return the ModuleRef properties
    STDMETHOD_(void, GetModuleRefProps)(
        mdModuleRef mur,                    // [IN] moduleref token
        LPCSTR      *pszName) PURE;         // [OUT] buffer to fill with the moduleref name

    //*****************************************
    //
    // GetSig* functions
    //
    //*****************************************
    STDMETHOD_(PCCOR_SIGNATURE, GetSigOfMethodDef)(
        mdMethodDef methoddef,              // [IN] given memberdef
        ULONG       *pcbSigBlob) PURE;      // [OUT] count of bytes in the signature blob

    STDMETHOD_(PCCOR_SIGNATURE, GetSigOfFieldDef)(
        mdMethodDef methoddef,              // [IN] given memberdef
        ULONG       *pcbSigBlob) PURE;      // [OUT] count of bytes in the signature blob

    STDMETHOD_(PCCOR_SIGNATURE, GetSigFromToken)(// return the signature
        mdSignature mdSig,                  // [IN] Signature token.
        ULONG       *pcbSig) PURE;          // [OUT] return size of signature.



    //*****************************************
    // get method property
    //*****************************************
    STDMETHOD_(DWORD, GetMethodDefProps)(
        mdMethodDef md) PURE;               // The method for which to get props.

    //*****************************************
    // return method implementation informaiton, like RVA and implflags
    //*****************************************
    STDMETHOD_(void, GetMethodImplProps)(
        mdToken     tk,                     // [IN] MethodDef
        ULONG       *pulCodeRVA,            // [OUT] CodeRVA
        DWORD       *pdwImplFlags) PURE;    // [OUT] Impl. Flags

    //*****************************************
    // return method implementation informaiton, like RVA and implflags
    //*****************************************
    STDMETHOD(GetFieldRVA)(
        mdFieldDef  fd,                     // [IN] fielddef 
        ULONG       *pulCodeRVA) PURE;      // [OUT] CodeRVA

    //*****************************************
    // get field property
    //*****************************************
    STDMETHOD_(DWORD, GetFieldDefProps)(    // return fdPublic, fdPrive, etc flags
        mdFieldDef  fd) PURE;               // [IN] given fielddef

    //*****************************************************************************
    // return default value of a token(could be paramdef, fielddef, or property
    //*****************************************************************************
    STDMETHOD(GetDefaultValue)(  
        mdToken     tk,                     // [IN] given FieldDef, ParamDef, or Property
        MDDefaultValue *pDefaultValue) PURE;// [OUT] default value to fill

    
    //*****************************************
    // get dispid of a MethodDef or a FieldDef
    //*****************************************
    STDMETHOD(GetDispIdOfMemberDef)(        // return hresult
        mdToken     tk,                     // [IN] given methoddef or fielddef
        ULONG       *pDispid) PURE;         // [OUT] Put the dispid here.

    //*****************************************
    // return TypeRef/TypeDef given an InterfaceImpl token
    //*****************************************
    STDMETHOD_(mdToken, GetTypeOfInterfaceImpl)( // return the TypeRef/typedef token for the interfaceimpl
        mdInterfaceImpl iiImpl) PURE;       // given a interfaceimpl

    //*****************************************
    // look up function for TypeDef
    //*****************************************
    STDMETHOD(FindTypeDef)(
        LPCSTR      szNamespace,            // [IN] Namespace for the TypeDef.
        LPCSTR      szName,                 // [IN] Name of the TypeDef.
        mdToken     tkEnclosingClass,       // [IN] TypeRef/TypeDef Token for the enclosing class.
        mdTypeDef   *ptypedef) PURE;        // [IN] return typedef

    //*****************************************
    // return name and sig of a memberref
    //*****************************************
    STDMETHOD_(LPCSTR, GetNameAndSigOfMemberRef)(   // return name here
        mdMemberRef memberref,              // given memberref
        PCCOR_SIGNATURE *ppvSigBlob,        // [OUT] point to a blob value of CLR signature
        ULONG       *pcbSigBlob) PURE;      // [OUT] count of bytes in the signature blob

    //*****************************************************************************
    // Given memberref, return the parent. It can be TypeRef, ModuleRef, MethodDef
    //*****************************************************************************
    STDMETHOD_(mdToken, GetParentOfMemberRef)( // return the parent token
        mdMemberRef memberref) PURE;        // given memberref

    STDMETHOD_(LPCSTR, GetParamDefProps)(   // return the name of the parameter
        mdParamDef  paramdef,               // given a paramdef
        USHORT      *pusSequence,           // [OUT] slot number for this parameter
        DWORD       *pdwAttr) PURE;         // [OUT] flags

    STDMETHOD(GetPropertyInfoForMethodDef)( // Result.
        mdMethodDef md,                     // [IN] memberdef
        mdProperty  *ppd,                   // [OUT] put property token here
        LPCSTR      *pName,                 // [OUT] put pointer to name here
        ULONG       *pSemantic) PURE;       // [OUT] put semantic here

    //*****************************************
    // class layout/sequence information
    //*****************************************
    STDMETHOD(GetClassPackSize)(            // return error if class doesn't have packsize
        mdTypeDef   td,                     // [IN] give typedef
        ULONG       *pdwPackSize) PURE;     // [OUT] 1, 2, 4, 8, or 16

    STDMETHOD(GetClassTotalSize)(           // return error if class doesn't have total size info
        mdTypeDef   td,                     // [IN] give typedef
        ULONG       *pdwClassSize) PURE;    // [OUT] return the total size of the class

    STDMETHOD(GetClassLayoutInit)(
        mdTypeDef   td,                     // [IN] give typedef
        MD_CLASS_LAYOUT *pLayout) PURE;     // [OUT] set up the status of query here

    STDMETHOD(GetClassLayoutNext)(
        MD_CLASS_LAYOUT *pLayout,           // [IN|OUT] set up the status of query here
        mdFieldDef  *pfd,                   // [OUT] return the fielddef
        ULONG       *pulOffset) PURE;       // [OUT] return the offset/ulSequence associate with it

    //*****************************************
    // marshal information of a field
    //*****************************************
    STDMETHOD(GetFieldMarshal)(             // return error if no native type associate with the token
        mdFieldDef  fd,                     // [IN] given fielddef
        PCCOR_SIGNATURE *pSigNativeType,    // [OUT] the native type signature
        ULONG       *pcbNativeType) PURE;   // [OUT] the count of bytes of *ppvNativeType


    //*****************************************
    // property APIs
    //*****************************************
    // find a property by name
    STDMETHOD(FindProperty)(
        mdTypeDef   td,                     // [IN] given a typdef
        LPCSTR      szPropName,             // [IN] property name
        mdProperty  *pProp) PURE;           // [OUT] return property token

    STDMETHOD_(void, GetPropertyProps)(
        mdProperty  prop,                   // [IN] property token
        LPCSTR      *szProperty,            // [OUT] property name
        DWORD       *pdwPropFlags,          // [OUT] property flags.
        PCCOR_SIGNATURE *ppvSig,            // [OUT] property type. pointing to meta data internal blob
        ULONG       *pcbSig) PURE;          // [OUT] count of bytes in *ppvSig

    //**********************************
    // Event APIs
    //**********************************
    STDMETHOD(FindEvent)(
        mdTypeDef   td,                     // [IN] given a typdef
        LPCSTR      szEventName,            // [IN] event name
        mdEvent     *pEvent) PURE;          // [OUT] return event token

    STDMETHOD_(void, GetEventProps)(
        mdEvent     ev,                     // [IN] event token
        LPCSTR      *pszEvent,              // [OUT] Event name
        DWORD       *pdwEventFlags,         // [OUT] Event flags.
        mdToken     *ptkEventType) PURE;    // [OUT] EventType class


    //**********************************
    // find a particular associate of a property or an event
    //**********************************
    STDMETHOD(FindAssociate)(
        mdToken     evprop,                 // [IN] given a property or event token
        DWORD       associate,              // [IN] given a associate semantics(setter, getter, testdefault, reset, AddOn, RemoveOn, Fire)
        mdMethodDef *pmd) PURE;             // [OUT] return method def token 

    STDMETHOD_(void, EnumAssociateInit)(
        mdToken     evprop,                 // [IN] given a property or an event token
        HENUMInternal *phEnum) PURE;        // [OUT] cursor to hold the query result

    STDMETHOD_(void, GetAllAssociates)(
        HENUMInternal *phEnum,              // [IN] query result form GetPropertyAssociateCounts
        ASSOCIATE_RECORD *pAssociateRec,    // [OUT] struct to fill for output
        ULONG       cAssociateRec) PURE;    // [IN] size of the buffer


    //**********************************
    // Get info about a PermissionSet.
    //**********************************
    STDMETHOD_(void, GetPermissionSetProps)(
        mdPermission pm,                    // [IN] the permission token.
        DWORD       *pdwAction,             // [OUT] CorDeclSecurity.
        void const  **ppvPermission,        // [OUT] permission blob.
        ULONG       *pcbPermission) PURE;   // [OUT] count of bytes of pvPermission.

    //****************************************
    // Get the String given the String token.
    //****************************************
    STDMETHOD_(LPCWSTR, GetUserString)(
        mdString    stk,                    // [IN] the string token.
        ULONG       *pchString,             // [OUT] count of characters in the string.
        BOOL        *pbIs80Plus) PURE;      // [OUT] specifies where there are extended characters >= 0x80.

    //*****************************************************************************
    // p-invoke APIs.
    //*****************************************************************************
    STDMETHOD(GetPinvokeMap)(
        mdToken     tk,                     // [IN] FieldDef, MethodDef.
        DWORD       *pdwMappingFlags,       // [OUT] Flags used for mapping.
        LPCSTR      *pszImportName,         // [OUT] Import name.
        mdModuleRef *pmrImportDLL) PURE;    // [OUT] ModuleRef token for the target DLL.

    //*****************************************************************************
    // helpers to convert a text signature to a com format
    //*****************************************************************************
    STDMETHOD(ConvertTextSigToComSig)(      // Return hresult.
        BOOL        fCreateTrIfNotFound,    // [IN] create typeref if not found
        LPCSTR      pSignature,             // [IN] class file format signature
        CQuickBytes *pqbNewSig,             // [OUT] place holder for CLR signature
        ULONG       *pcbCount) PURE;        // [OUT] the result size of signature

    //*****************************************************************************
    // Assembly MetaData APIs.
    //*****************************************************************************
    STDMETHOD_(void, GetAssemblyProps)(
        mdAssembly  mda,                    // [IN] The Assembly for which to get the properties.
        const void  **ppbPublicKey,         // [OUT] Pointer to the public key.
        ULONG       *pcbPublicKey,          // [OUT] Count of bytes in the public key.
        ULONG       *pulHashAlgId,          // [OUT] Hash Algorithm.
        LPCSTR      *pszName,               // [OUT] Buffer to fill with name.
        AssemblyMetaDataInternal *pMetaData,// [OUT] Assembly MetaData.
        DWORD       *pdwAssemblyFlags) PURE;// [OUT] Flags.

    STDMETHOD_(void, GetAssemblyRefProps)(
        mdAssemblyRef mdar,                 // [IN] The AssemblyRef for which to get the properties.
        const void  **ppbPublicKeyOrToken,  // [OUT] Pointer to the public key or token.
        ULONG       *pcbPublicKeyOrToken,   // [OUT] Count of bytes in the public key or token.
        LPCSTR      *pszName,               // [OUT] Buffer to fill with name.
        AssemblyMetaDataInternal *pMetaData,// [OUT] Assembly MetaData.
        const void  **ppbHashValue,         // [OUT] Hash blob.
        ULONG       *pcbHashValue,          // [OUT] Count of bytes in the hash blob.
        DWORD       *pdwAssemblyRefFlags) PURE; // [OUT] Flags.

    STDMETHOD_(void, GetFileProps)(
        mdFile      mdf,                    // [IN] The File for which to get the properties.
        LPCSTR      *pszName,               // [OUT] Buffer to fill with name.
        const void  **ppbHashValue,         // [OUT] Pointer to the Hash Value Blob.
        ULONG       *pcbHashValue,          // [OUT] Count of bytes in the Hash Value Blob.
        DWORD       *pdwFileFlags) PURE;    // [OUT] Flags.

    STDMETHOD_(void, GetExportedTypeProps)(
        mdExportedType   mdct,              // [IN] The ExportedType for which to get the properties.
        LPCSTR      *pszNamespace,          // [OUT] Namespace.
        LPCSTR      *pszName,               // [OUT] Name.
        mdToken     *ptkImplementation,     // [OUT] mdFile or mdAssemblyRef that provides the ExportedType.
        mdTypeDef   *ptkTypeDef,            // [OUT] TypeDef token within the file.
        DWORD       *pdwExportedTypeFlags) PURE; // [OUT] Flags.

    STDMETHOD_(void, GetManifestResourceProps)(
        mdManifestResource  mdmr,           // [IN] The ManifestResource for which to get the properties.
        LPCSTR      *pszName,               // [OUT] Buffer to fill with name.
        mdToken     *ptkImplementation,     // [OUT] mdFile or mdAssemblyRef that provides the ExportedType.
        DWORD       *pdwOffset,             // [OUT] Offset to the beginning of the resource within the file.
        DWORD       *pdwResourceFlags) PURE;// [OUT] Flags.

    STDMETHOD(FindExportedTypeByName)(      // S_OK or error
        LPCSTR      szNamespace,            // [IN] Namespace of the ExportedType.   
        LPCSTR      szName,                 // [IN] Name of the ExportedType.   
        mdExportedType   tkEnclosingType,   // [IN] ExportedType for the enclosing class.
        mdExportedType   *pmct) PURE;       // [OUT] Put ExportedType token here.

    STDMETHOD(FindManifestResourceByName)(  // S_OK or error
        LPCSTR      szName,                 // [IN] Name of the ManifestResource.   
        mdManifestResource *pmmr) PURE;     // [OUT] Put ManifestResource token here.

    STDMETHOD(GetAssemblyFromScope)(        // S_OK or error
        mdAssembly  *ptkAssembly) PURE;     // [OUT] Put token here.

    STDMETHOD(GetCustomAttributeByName)(    // S_OK or error
        mdToken     tkObj,                  // [IN] Object with Custom Attribute.
        LPCUTF8     szName,                 // [IN] Name of desired Custom Attribute.
        const void  **ppData,               // [OUT] Put pointer to data here.
        ULONG       *pcbData) PURE;         // [OUT] Put size of data here.

    STDMETHOD_(void, GetTypeSpecFromToken)( // S_OK or error.
        mdTypeSpec  typespec,               // [IN] Signature token.
        PCCOR_SIGNATURE *ppvSig,            // [OUT] return pointer to token.
        ULONG       *pcbSig) PURE;          // [OUT] return size of signature.

    STDMETHOD(SetUserContextData)(          // S_OK or E_NOTIMPL
        IUnknown    *pIUnk) PURE;           // The user context.

    STDMETHOD_(BOOL, IsValidToken)(         // True or False.
        mdToken     tk) PURE;               // [IN] Given token.

    STDMETHOD(TranslateSigWithScope)(
        IMDInternalImport *pAssemImport,    // [IN] import assembly scope.
        const void  *pbHashValue,           // [IN] hash value for the import assembly.
        ULONG       cbHashValue,            // [IN] count of bytes in the hash value.
        PCCOR_SIGNATURE pbSigBlob,          // [IN] signature in the importing scope
        ULONG       cbSigBlob,              // [IN] count of bytes of signature
        IMetaDataAssemblyEmit *pAssemEmit,  // [IN] assembly emit scope.
        IMetaDataEmit *emit,                // [IN] emit interface
        CQuickBytes *pqkSigEmit,            // [OUT] buffer to hold translated signature
        ULONG       *pcbSig) PURE;          // [OUT] count of bytes in the translated signature

    STDMETHOD_(IMetaModelCommon*, GetMetaModelCommon)(  // Return MetaModelCommon interface.
        ) PURE;

    STDMETHOD_(IUnknown *, GetCachedPublicInterface)(BOOL fWithLock) PURE;   // return the cached public interface
    STDMETHOD(SetCachedPublicInterface)(IUnknown *pUnk) PURE;  // no return value
    STDMETHOD_(UTSemReadWrite*, GetReaderWriterLock)() PURE;   // return the reader writer lock
    STDMETHOD(SetReaderWriterLock)(UTSemReadWrite * pSem) PURE; 

    STDMETHOD_(mdModule, GetModuleFromScope)() PURE;             // [OUT] Put mdModule token here.


    //-----------------------------------------------------------------
    // Additional custom methods

    // finding a particular method 
    STDMETHOD(FindMethodDefUsingCompare)(
        mdTypeDef   classdef,               // [IN] given typedef
        LPCSTR      szName,                 // [IN] member name
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of CLR signature
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob
        PSIGCOMPARE pSignatureCompare,      // [IN] Routine to compare signatures
        void*       pSignatureArgs,         // [IN] Additional info to supply the compare function
        mdMethodDef *pmd) PURE;             // [OUT] matching memberdef
};  // IMDInternalImport


// {E03D7730-D7E3-11d2-8C0D-00C04FF7431A}
extern const GUID DECLSPEC_SELECT_ANY IID_IMDInternalImportENC =
{ 0xe03d7730, 0xd7e3, 0x11d2, { 0x8c, 0xd, 0x0, 0xc0, 0x4f, 0xf7, 0x43, 0x1a } };

#undef  INTERFACE
#define INTERFACE IMDInternalImportENC
DECLARE_INTERFACE_(IMDInternalImportENC, IMDInternalImport)
{
    // ENC only methods here.
    STDMETHOD(ApplyEditAndContinue)(        // S_OK or error.
        MDInternalRW *pDelta) PURE;         // Interface to MD with the ENC delta.

    STDMETHOD(EnumDeltaTokensInit)(         // return hresult
        HENUMInternal *phEnum) PURE;        // [OUT] buffer to fill for enumerator data

}; // IMDInternalImportENC



#endif // _METADATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\loglf.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
DEFINE_LOG_FACILITY(LF_GC           ,0x00000001)
DEFINE_LOG_FACILITY(LF_LIVEPTRS     ,0x00000002)
DEFINE_LOG_FACILITY(LF_STUBS        ,0x00000004)
DEFINE_LOG_FACILITY(LF_JIT          ,0x00000008)
DEFINE_LOG_FACILITY(LF_LOADER       ,0x00000010)
DEFINE_LOG_FACILITY(LF_METADATA     ,0x00000020)
DEFINE_LOG_FACILITY(LF_SYNC         ,0x00000040)
DEFINE_LOG_FACILITY(LF_EEMEM        ,0x00000080)
DEFINE_LOG_FACILITY(LF_GCALLOC      ,0x00000100)
DEFINE_LOG_FACILITY(LF_CORDB        ,0x00000200)
DEFINE_LOG_FACILITY(LF_CLASSLOADER  ,0x00000400)
DEFINE_LOG_FACILITY(LF_CORPROF      ,0x00000800)
DEFINE_LOG_FACILITY(LF_REMOTING     ,0x00001000)
DEFINE_LOG_FACILITY(LF_DBGALLOC     ,0x00002000)
DEFINE_LOG_FACILITY(LF_EH           ,0x00004000)
DEFINE_LOG_FACILITY(LF_ENC          ,0x00008000)
DEFINE_LOG_FACILITY(LF_ASSERT       ,0x00010000)
DEFINE_LOG_FACILITY(LF_VERIFIER     ,0x00020000)
DEFINE_LOG_FACILITY(LF_THREADPOOL   ,0x00040000)
DEFINE_LOG_FACILITY(LF_GCROOTS      ,0x00080000)
DEFINE_LOG_FACILITY(LF_INTEROP      ,0x00100000)
DEFINE_LOG_FACILITY(LF_MARSHALER    ,0x00200000)
DEFINE_LOG_FACILITY(LF_IJW          ,0x00400000)
DEFINE_LOG_FACILITY(LF_ZAP          ,0x00800000)
DEFINE_LOG_FACILITY(LF_SLOP         ,0x01000000)
DEFINE_LOG_FACILITY(LF_APPDOMAIN    ,0x02000000)
DEFINE_LOG_FACILITY(LF_CODESHARING  ,0x04000000)
DEFINE_LOG_FACILITY(LF_STORE        ,0x08000000)
DEFINE_LOG_FACILITY(LF_SECURITY     ,0x10000000)
DEFINE_LOG_FACILITY(LF_LOCKS		,0x20000000)
DEFINE_LOG_FACILITY(LF_BCL   		,0x40000000)
#undef DEFINE_LOG_FACILITY
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\metamodelpub.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// MetaModelPub.h -- header file for Common Language Runtime metadata.
//
//*****************************************************************************
#ifndef _METAMODELPUB_H_
#define _METAMODELPUB_H_

#if _MSC_VER >= 1100
 # pragma once
#endif

#include <cor.h>
#include <stgpool.h>

// Version numbers for metadata format.
#define METAMODEL_MAJOR_VER 1
#define METAMODEL_MINOR_VER 0

#ifndef lengthof
 # define lengthof(x) (sizeof(x)/sizeof((x)[0]))
#endif

template<class T> inline T Align4(T p) 
{
	INT_PTR i = (INT_PTR)p;
	i = (i+(3)) & ~3;
	return (T)i;
}

typedef unsigned long RID;

// check if a rid is valid or not
#define		InvalidRid(rid) ((rid) == 0)


//*****************************************************************************
// Record definitions.  Records have some combination of fixed size fields and
//  variable sized fields (actually, constant across a database, but variable
//  between databases).
//
// In this section we define record definitions which include the fixed size
//  fields and an enumeration of the variable sized fields.
//
// Naming is as follows:
//  Given some table "Xyz":
//  class XyzRec { public:
//    SOMETYPE	m_SomeField; 
//        // rest of the fixed fields.
//    enum { COL_Xyz_SomeOtherField, 
//        // rest of the fields, enumerated.
//        COL_Xyz_COUNT };
//   };
//
// The important features are the class name (XyzRec), the enumerations
//  (COL_Xyz_FieldName), and the enumeration count (COL_Xyz_COUNT).
// 
// THESE NAMING CONVENTIONS ARE CARVED IN STONE!  DON'T TRY TO BE CREATIVE!
//
//*****************************************************************************
// Have the compiler generate two byte alignment.  Be careful to manually lay
//  out the fields for proper alignment.  The alignment for variable-sized
//  fields will be computed at save time.
#pragma pack(push,2)

// Non-sparse tables.
class ModuleRec
{
public:
    USHORT  m_Generation;               // ENC generation.
	enum {
        COL_Generation,
        
		COL_Name,
		COL_Mvid,
        COL_EncId,
        COL_EncBaseId,
		COL_COUNT,
		COL_KEY
	};
};

class TypeRefRec
{
public:
	enum {
        COL_ResolutionScope,            // mdModuleRef or mdAssemblyRef.
        COL_Name,
        COL_Namespace,
		COL_COUNT,
		COL_KEY
	};
};

class TypeDefRec
{
public:
	ULONG		m_Flags;				// Flags for this TypeDef
	enum {
		COL_Flags,

		COL_Name,						// offset into string pool.
		COL_Namespace,
		COL_Extends,					// coded token to typedef/typeref.
		COL_FieldList,					// rid of first field.
		COL_MethodList,					// rid of first method.
		COL_COUNT,
		COL_KEY
	};
};

class FieldPtrRec
{
public:
	enum {
		COL_Field,
		COL_COUNT,
		COL_KEY
	};
};

class FieldRec
{
public:
	USHORT		m_Flags;				// Flags for the field.
	enum {
		COL_Flags,

		COL_Name,
		COL_Signature,
		COL_COUNT,
		COL_KEY
	};
};

class MethodPtrRec
{
public:
	enum {
		COL_Method,
		COL_COUNT,
		COL_KEY
	};
};

class MethodRec
{
public:
	ULONG		m_RVA;					// RVA of the Method.
	USHORT		m_ImplFlags	;			// Descr flags of the Method.
	USHORT		m_Flags;				// Flags for the Method.
	enum {
		COL_RVA,
		COL_ImplFlags,
		COL_Flags,

		COL_Name,
		COL_Signature,
		COL_ParamList,					// Rid of first param.
		COL_COUNT,
		COL_KEY
	};
};

class ParamPtrRec
{
public:
	enum {
		COL_Param,
		COL_COUNT,
		COL_KEY
	};
};

class ParamRec
{
public:
	USHORT		m_Flags;				// Flags for this Param.
	USHORT		m_Sequence;				// Sequence # of param.  0 - return value.
	enum {
		COL_Flags,
		COL_Sequence,

		COL_Name,						// Name of the param.
		COL_COUNT,
		COL_KEY
	};
};

class InterfaceImplRec
{
public:
	enum {
		COL_Class,						// Rid of class' TypeDef.
		COL_Interface,					// Coded rid of implemented interface.
		COL_COUNT,
		COL_KEY = COL_Class
	};
};

class MemberRefRec
{
public:
	enum {
		COL_Class,						// Rid of TypeDef.
		COL_Name,
		COL_Signature,
		COL_COUNT,
		COL_KEY
	};
};

class StandAloneSigRec
{
public:
	enum {
		COL_Signature,
		COL_COUNT,
		COL_KEY
	};
};

// Sparse tables.  These contain modifiers for tables above.
class ConstantRec
{
public:																
	BYTE		m_Type;					// Type of the constant.
	BYTE		m_PAD1;
	enum {
		COL_Type,

		COL_Parent,						// Coded rid of object (param, field).
		COL_Value,						// Index into blob pool.
		COL_COUNT,
		COL_KEY = COL_Parent
	};
};

class CustomAttributeRec
{
public:
	enum {
		COL_Parent,						// Coded rid of any object.
		COL_Type,						// TypeDef or TypeRef.
		COL_Value,						// Blob.
		COL_COUNT,
		COL_KEY = COL_Parent
	};
};

class FieldMarshalRec													
{
public:
	enum {
		COL_Parent,						// Coded rid of field or param.
		COL_NativeType,
		COL_COUNT,
		COL_KEY = COL_Parent
	};
};

class DeclSecurityRec
{
public:
	short	m_Action;
	enum {
		COL_Action,

		COL_Parent,
		COL_PermissionSet,
		COL_COUNT,
		COL_KEY = COL_Parent
	};
};


class ClassLayoutRec
{
public:
	USHORT	m_PackingSize;
	ULONG	m_ClassSize;
	enum {
		COL_PackingSize,
		COL_ClassSize,

		COL_Parent,						// Rid of TypeDef.
		COL_COUNT,
		COL_KEY = COL_Parent
	};
};

class FieldLayoutRec
{
public:
	ULONG		m_OffSet;
	enum {
		COL_OffSet,

		COL_Field,
		COL_COUNT,
		COL_KEY = COL_Field
	};
};

class EventMapRec
{
public:
	enum {
		COL_Parent,
		COL_EventList,					// rid of first event.
		COL_COUNT,
		COL_KEY
	};
};

class EventPtrRec
{
public:
	enum {
		COL_Event,
		COL_COUNT,
		COL_KEY
	};
};

class EventRec
{
public:
	USHORT		m_EventFlags;
	enum {
		COL_EventFlags,

		COL_Name,
		COL_EventType,
		COL_COUNT,
		COL_KEY
	};
};

class PropertyMapRec
{
public:
	enum {
		COL_Parent,
		COL_PropertyList,				// rid of first property.
		COL_COUNT,
		COL_KEY
	};
};

class PropertyPtrRec
{
public:
	enum {
		COL_Property,
		COL_COUNT,
		COL_KEY
	};
};

class PropertyRec
{
public:
	USHORT		m_PropFlags;
	enum {
		COL_PropFlags,

		COL_Name,
		COL_Type,
		COL_COUNT,
		COL_KEY
	};
};

class MethodSemanticsRec
{
public:
	USHORT		m_Semantic;
	enum {
		COL_Semantic,

		COL_Method,
		COL_Association,
		COL_COUNT,
		COL_KEY = COL_Method
	};
};

class MethodImplRec
{
public:
	enum {
        COL_Class,                  // TypeDef where the MethodBody lives.
		COL_MethodBody,             // MethodDef or MemberRef.
		COL_MethodDeclaration,	    // MethodDef or MemberRef.
		COL_COUNT,
		COL_KEY = COL_Class
	};
};

class ModuleRefRec
{
public:
	enum {
		COL_Name,
		COL_COUNT,
		COL_KEY
	};
};

class TypeSpecRec
{
public:
	enum {
		COL_Signature,
		COL_COUNT,
		COL_KEY
	};
};

class ImplMapRec
{
public:
	USHORT		m_MappingFlags;
	enum {
		COL_MappingFlags,

		COL_MemberForwarded,		// mdField or mdMethod.
		COL_ImportName,
		COL_ImportScope,			// mdModuleRef.
		COL_COUNT,
		COL_KEY = COL_MemberForwarded
	};
};

class FieldRVARec
{
public:
	ULONG		m_RVA;
	enum{
		COL_RVA,

		COL_Field,
		COL_COUNT,
		COL_KEY = COL_Field
	};
};

class ENCLogRec
{
public:
	ULONG		m_Token;			// Token, or like a token, but with (ixTbl|0x80) instead of token type.
	ULONG		m_FuncCode;			// Function code describing the nature of ENC change.
	enum {
		COL_Token,
		COL_FuncCode,
		COL_COUNT,
		COL_KEY
	};
};

class ENCMapRec
{
public:
	ULONG		m_Token;			// Token, or like a token, but with (ixTbl|0x80) instead of token type.
	enum {
		COL_Token,
		COL_COUNT,
		COL_KEY
	};
};

// Assembly tables.

class AssemblyRec
{
public:
	ULONG		m_HashAlgId;
	USHORT		m_MajorVersion;
	USHORT		m_MinorVersion;
	USHORT		m_BuildNumber;
    USHORT      m_RevisionNumber;
	ULONG		m_Flags;
	enum {
        COL_HashAlgId,
		COL_MajorVersion,
		COL_MinorVersion,
        COL_BuildNumber,
		COL_RevisionNumber,
		COL_Flags,

		COL_PublicKey,			// Public key identifying the publisher
		COL_Name,
        COL_Locale,
		COL_COUNT,
		COL_KEY
	};
};

class AssemblyProcessorRec
{
public:
	ULONG		m_Processor;
	enum {
		COL_Processor,

		COL_COUNT,
		COL_KEY
	};
};

class AssemblyOSRec
{
public:
	ULONG		m_OSPlatformId;
	ULONG		m_OSMajorVersion;
	ULONG		m_OSMinorVersion;
	enum {
		COL_OSPlatformId,
		COL_OSMajorVersion,
		COL_OSMinorVersion,

		COL_COUNT,
		COL_KEY
	};
};

class AssemblyRefRec
{
public:
	USHORT		m_MajorVersion;
	USHORT		m_MinorVersion;
	USHORT		m_BuildNumber;
    USHORT      m_RevisionNumber;
	ULONG		m_Flags;
	enum {
		COL_MajorVersion,
		COL_MinorVersion,
        COL_BuildNumber,
		COL_RevisionNumber,
		COL_Flags,

		COL_PublicKeyOrToken,				// The public key or token identifying the publisher of the Assembly.
		COL_Name,
        COL_Locale,
		COL_HashValue,
		COL_COUNT,
		COL_KEY
	};
};

class AssemblyRefProcessorRec
{
public:
	ULONG		m_Processor;
	enum {
		COL_Processor,

		COL_AssemblyRef,				// mdtAssemblyRef
		COL_COUNT,
		COL_KEY
	};
};

class AssemblyRefOSRec
{
public:
	ULONG		m_OSPlatformId;
	ULONG		m_OSMajorVersion;
	ULONG		m_OSMinorVersion;
	enum {
		COL_OSPlatformId,
		COL_OSMajorVersion,
		COL_OSMinorVersion,

		COL_AssemblyRef,				// mdtAssemblyRef.
		COL_COUNT,
		COL_KEY
	};
};

class FileRec
{
public:
	ULONG		m_Flags;
	enum {
		COL_Flags,

		COL_Name,
		COL_HashValue,
		COL_COUNT,
		COL_KEY
	};
};

class ExportedTypeRec
{
public:
	ULONG		m_Flags;
    ULONG       m_TypeDefId;
	enum {
		COL_Flags,
		COL_TypeDefId,

        COL_TypeName,
        COL_TypeNamespace,
		COL_Implementation,			// mdFile or mdAssemblyRef.
		COL_COUNT,
		COL_KEY
	};
};

class ManifestResourceRec
{
public:
	ULONG		m_Offset;
	ULONG		m_Flags;
	enum {
		COL_Offset,
		COL_Flags,

		COL_Name,
		COL_Implementation,			// mdFile or mdAssemblyRef.
		COL_COUNT,
		COL_KEY
	};
};

// End Assembly Tables.

class NestedClassRec
{
public:
    enum {
        COL_NestedClass,
        COL_EnclosingClass,
        COL_COUNT,
        COL_KEY = COL_NestedClass
    };
};

#pragma pack(pop)

// List of MiniMd tables.

#define MiniMdTables()			\
	MiniMdTable(Module)			\
	MiniMdTable(TypeRef)		\
	MiniMdTable(TypeDef)		\
	MiniMdTable(FieldPtr)		\
	MiniMdTable(Field)			\
	MiniMdTable(MethodPtr)		\
	MiniMdTable(Method)			\
	MiniMdTable(ParamPtr)		\
	MiniMdTable(Param)			\
	MiniMdTable(InterfaceImpl)	\
	MiniMdTable(MemberRef)		\
	MiniMdTable(Constant)		\
	MiniMdTable(CustomAttribute)	\
	MiniMdTable(FieldMarshal)	\
	MiniMdTable(DeclSecurity)	\
	MiniMdTable(ClassLayout)	\
	MiniMdTable(FieldLayout) 	\
	MiniMdTable(StandAloneSig)  \
	MiniMdTable(EventMap)		\
	MiniMdTable(EventPtr)		\
	MiniMdTable(Event)			\
	MiniMdTable(PropertyMap)	\
	MiniMdTable(PropertyPtr)	\
	MiniMdTable(Property)		\
	MiniMdTable(MethodSemantics)\
	MiniMdTable(MethodImpl)		\
	MiniMdTable(ModuleRef)		\
	MiniMdTable(TypeSpec)		\
	MiniMdTable(ImplMap)		\
	MiniMdTable(FieldRVA)		\
	MiniMdTable(ENCLog)			\
	MiniMdTable(ENCMap)			\
	MiniMdTable(Assembly)		\
	MiniMdTable(AssemblyProcessor)		\
	MiniMdTable(AssemblyOS)		\
	MiniMdTable(AssemblyRef)	\
	MiniMdTable(AssemblyRefProcessor)	\
	MiniMdTable(AssemblyRefOS)	\
	MiniMdTable(File)			\
	MiniMdTable(ExportedType)	\
	MiniMdTable(ManifestResource)		\
    MiniMdTable(NestedClass)    \

#undef MiniMdTable
#define MiniMdTable(x) TBL_##x##,
enum {
	MiniMdTables()
	TBL_COUNT
};
#undef MiniMdTable

// List of MiniMd coded token types.
#define MiniMdCodedTokens()					\
	MiniMdCodedToken(TypeDefOrRef)			\
	MiniMdCodedToken(HasConstant)			\
	MiniMdCodedToken(HasCustomAttribute)		\
	MiniMdCodedToken(HasFieldMarshal)		\
	MiniMdCodedToken(HasDeclSecurity)		\
	MiniMdCodedToken(MemberRefParent)		\
	MiniMdCodedToken(HasSemantic)			\
	MiniMdCodedToken(MethodDefOrRef)		\
	MiniMdCodedToken(MemberForwarded)		\
	MiniMdCodedToken(Implementation)		\
	MiniMdCodedToken(CustomAttributeType)		\
    MiniMdCodedToken(ResolutionScope)       \

#undef MiniMdCodedToken
#define MiniMdCodedToken(x) CDTKN_##x##,
enum {
	MiniMdCodedTokens()
	CDTKN_COUNT
};
#undef MiniMdCodedToken

//*****************************************************************************
// Meta-meta data.  Constant across all MiniMds.
//*****************************************************************************
#ifndef _META_DATA_META_CONSTANTS_DEFINED
#define _META_DATA_META_CONSTANTS_DEFINED
const unsigned int iRidMax			= 63;
const unsigned int iCodedToken		= 64;	// base of coded tokens.
const unsigned int iCodedTokenMax	= 95;
const unsigned int iSHORT			= 96;	// fixed types.
const unsigned int iUSHORT			= 97;
const unsigned int iLONG			= 98;
const unsigned int iULONG			= 99;
const unsigned int iBYTE			= 100;
const unsigned int iSTRING			= 101;	// pool types.
const unsigned int iGUID			= 102;
const unsigned int iBLOB			= 103;

inline int IsRidType(ULONG ix) { return ix <= iRidMax; }
inline int IsCodedTokenType(ULONG ix) { return (ix >= iCodedToken) && (ix <= iCodedTokenMax); }
inline int IsRidOrToken(ULONG ix) { return ix <= iCodedTokenMax; }
inline int IsHeapType(ULONG ix) { return ix >= iSTRING; }
inline int IsFixedType(ULONG ix) { return (ix < iSTRING) && (ix > iCodedTokenMax); }
#endif

struct CCodedTokenDef
{
	ULONG		m_cTokens;				// Count of tokens.
	const mdToken *m_pTokens;			// Array of tokens.
	const char	*m_pName;				// Name of the coded-token type.
};

struct CMiniColDef
{
	BYTE		m_Type;					// Type of the column.
	BYTE		m_oColumn;				// Offset of the column.
	BYTE		m_cbColumn;				// Size of the column.
};

struct CMiniTableDef
{
	CMiniColDef	*m_pColDefs;		// Array of field defs.
	BYTE		m_cCols;				// Count of columns in the table.
	BYTE		m_iKey;					// Column which is the key, if any.
	USHORT		m_cbRec;				// Size of the records.
};
struct CMiniTableDefEx 
{
	CMiniTableDef	m_Def;				// Table definition.
	const char	**m_pColNames;			// Array of column names.
	const char	*m_pName;				// Name of the table.
};

#endif // _METAMODELPUB_H_
// eof ------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\minidumppriv.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ===========================================================================
// File: MINIDUMPPRIV.CPP
//
// This file contains code to create a minidump-style memory dump that is
// designed to complement the existing unmanaged minidump that has already
// been defined here: 
// http://office10/teams/Fundamentals/dev_spec/Reliability/Crash%20Tracking%20-%20MiniDump%20Format.htm
// 
// ===========================================================================

#pragma once

#include <windef.h>

// Forward declaration
struct MiniDumpInternalData;

//
// This structure is contained in the shared memory block and defines all
// that's needed to perform a minidump.
//
struct MiniDumpBlock
{
    // This is a pointer to a data block within the process that contains
    // pointers to key runtime data structures
    MiniDumpInternalData *pInternalData;
    DWORD                 dwInternalDataSize;

    //**************************************************************
    // ***NOTE*** This must always be the last entry in this struct
    //**************************************************************
    WCHAR szCorPath[MAX_PATH];
};

//
// This defines an extra memory range to store.  An array of these are
// defined in the internal data block
//
struct ExtraStoreBlock
{
    PBYTE  pbStart;
    SIZE_T cbLen;
};

//
// This structure contains data about the internal data structures of the
// runtime that are used during a minidump
//
struct MiniDumpInternalData
{
    // @TODO: Things to put in here:
    // 1. Pointer to list of managed threads
    // 2. Pointer to list of ring logs
    // 3. Pointers to global state flags:
    //      g_fEEStarted
    //      g_fEEInit
    //      g_SystemInfo
    //      g_StartupFailure
    //      g_fEEShutDown
    //      g_fProcessDetach
    //      g_pThreadStore
    //      g_TrapReturningThreads
    //      etc.

    // Information on the global ThreadStore object
    PBYTE* ppb_g_pThreadStore;
    SIZE_T cbThreadStoreObjectSize;

    // Information on Thread objects
    PBYTE *ppbThreadListHead;
    SIZE_T cbThreadObjectSize;
    SIZE_T cbThreadNextOffset;
    SIZE_T cbThreadHandleOffset;
    SIZE_T cbThreadStackBaseOffset;
    SIZE_T cbThreadContextOffset;
    SIZE_T cbThreadDomainOffset;
    SIZE_T cbThreadLastThrownObjectHandleOffset;
    SIZE_T cbThreadTEBOffset;

    // Information on the EEManager range tree
    PBYTE* ppbEEManagerRangeTree;

    // Information on JIT manager vTables
    PBYTE* ppbEEJitManagerVtable;
    PBYTE* ppbEconoJitManagerVtable;
    PBYTE* ppbMNativeJitManagerVtable;

    // MethodDesc information
    SIZE_T cbMethodDescSize;
    SIZE_T cbOffsetOf_m_wFlags;
    SIZE_T cbOffsetOf_m_dwCodeOrIL;
    SIZE_T cbOffsetOf_m_pDebugEEClass;
    SIZE_T cbOffsetOf_m_pszDebugMethodName;
    SIZE_T cbOffsetOf_m_pszDebugMethodSignature;
    SIZE_T cbMD_IndexOffset;
    SIZE_T cbMD_SkewOffset;

    // MethodDescChunk information
    SIZE_T cbMethodDescChunkSize;
    SIZE_T cbOffsetOf_m_tokrange;

    // MethodTable offsets
    SIZE_T cbSizeOfMethodTable;
    SIZE_T cbOffsetOf_MT_m_pEEClass;
    SIZE_T cbOffsetOf_MT_m_pModule;
    SIZE_T cbOffsetOf_MT_m_wFlags;
    SIZE_T cbOffsetOf_MT_m_BaseSize;
    SIZE_T cbOffsetOf_MT_m_ComponentSize;
    SIZE_T cbOffsetOf_MT_m_wNumInterface;
    SIZE_T cbOffsetOf_MT_m_pIMap;
    SIZE_T cbOffsetOf_MT_m_cbSlots;
    SIZE_T cbOffsetOf_MT_m_Vtable;

    // EEClass information
    SIZE_T cbSizeOfEEClass;
    SIZE_T cbOffsetOf_CLS_m_szDebugClassName;
    SIZE_T cbOffsetOf_CLS_m_cl;
    SIZE_T cbOffsetOf_CLS_m_pParentClass;
    SIZE_T cbOffsetOf_CLS_m_pLoader;
    SIZE_T cbOffsetOf_CLS_m_pMethodTable;
    SIZE_T cbOffsetOf_CLS_m_wNumVtableSlots;
    SIZE_T cbOffsetOf_CLS_m_wNumMethodSlots;
    SIZE_T cbOffsetOf_CLS_m_dwAttrClass;
    SIZE_T cbOffsetOf_CLS_m_VMFlags;
    SIZE_T cbOffsetOf_CLS_m_wNumInstanceFields;
    SIZE_T cbOffsetOf_CLS_m_wNumStaticFields;
    SIZE_T cbOffsetOf_CLS_m_wThreadStaticOffset;
    SIZE_T cbOffsetOf_CLS_m_wContextStaticOffset;
    SIZE_T cbOffsetOf_CLS_m_wThreadStaticsSize;
    SIZE_T cbOffsetOf_CLS_m_wContextStaticsSize;
    SIZE_T cbOffsetOf_CLS_m_pFieldDescList;
    SIZE_T cbOffsetOf_CLS_m_SiblingsChain;
    SIZE_T cbOffsetOf_CLS_m_ChildrenChain;

    // Information on context objects
    SIZE_T cbSizeOfContext;
    SIZE_T cbOffsetOf_CTX_m_pDomain;

    // Information on StubCallInstrs
    SIZE_T cbSizeOfStubCallInstrs;
    SIZE_T cbOffsetOf_SCI_m_wTokenRemainder;

    // Information on Module objects
    SIZE_T cbSizeOfModule;
    SIZE_T cbOffsetOf_MOD_m_dwFlags;
    SIZE_T cbOffsetOf_MOD_m_pAssembly;
    SIZE_T cbOffsetOf_MOD_m_file;
    SIZE_T cbOffsetOf_MOD_m_zapFile;
    SIZE_T cbOffsetOf_MOD_m_pLookupTableHeap;
    SIZE_T cbOffsetOf_MOD_m_TypeDefToMethodTableMap;
    SIZE_T cbOffsetOf_MOD_m_TypeRefToMethodTableMap;
    SIZE_T cbOffsetOf_MOD_m_MethodDefToDescMap;
    SIZE_T cbOffsetOf_MOD_m_FieldDefToDescMap;
    SIZE_T cbOffsetOf_MOD_m_MemberRefToDescMap;
    SIZE_T cbOffsetOf_MOD_m_FileReferencesMap;
    SIZE_T cbOffsetOf_MOD_m_AssemblyReferencesMap;
    SIZE_T cbOffsetOf_MOD_m_pNextModule;
    SIZE_T cbOffsetOf_MOD_m_dwBaseClassIndex;

    // Information about PEFile objects
    SIZE_T cbSizeOfPEFile;
    SIZE_T cbOffsetOf_PEF_m_wszSourceFile;
    SIZE_T cbOffsetOf_PEF_m_hModule;
    SIZE_T cbOffsetOf_PEF_m_base;
    SIZE_T cbOffsetOf_PEF_m_pNT;

    // Information about CORCOMPILE_METHOD_HEADER
    SIZE_T cbSizeOfCORCOMPILE_METHOD_HEADER;
    SIZE_T cbOffsetOf_CCMH_gcInfo;
    SIZE_T cbOffsetOf_CCMH_methodDesc;

    // Information on build type
    BOOL   fIsDebugBuild;

    // Extra memory to store
    SIZE_T          cExtraBlocks;
    ExtraStoreBlock rgExtraBlocks[16];
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\metadatatracker.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef _METADATATRACKER_H_
#define _METADATATRACKER_H_

#ifdef GOLDEN

// Don't enable this in release
#undef METADATATRACKER_ENABLED
#define METADATATRACKER_ONLY(s)

#else

#define METADATATRACKER_ENABLED 1

#if METADATATRACKER_ENABLED

#define METADATATRACKER_ONLY(s) (s)

#include "winbase.h"
#include "winwrap.h"
#include "MetamodelPub.h"
#include <imagehlp.h>
#include "StackTrace.h"

#define OS_PAGE_SIZE 4096
#define NUM_MD_SECTIONS 48
// TBL_COUNT + 4
#define SIZE_OF_TRACKED_BLOCK 4
#define NUM_TRACKED_BLOCKS (OS_PAGE_SIZE/SIZE_OF_TRACKED_BLOCK)
#define NUM_TRACKING_DWORDS OS_PAGE_SIZE/(SIZE_OF_TRACKED_BLOCK*32)
#define NUM_TRACKED_BLOCKS_PER_DWORD 32
#define NUM_CONTENT_KINDS_ON_A_PAGE 35

#define MAX_ORPHANED_HEAP_ACCESSES_STORED 8192

#define STRING_POOL     (TBL_COUNT + 0)
#define USERSTRING_POOL (TBL_COUNT + 1)
#define GUID_POOL       (TBL_COUNT + 2)
#define BLOB_POOL       (TBL_COUNT + 3)

#define MDLOG(disp_type,s) {if (s_trackerOptions >= (disp_type)) {printf s;}}

// {00000000-0000-0000-0000-000000000000}
static const GUID NULL_GUID = {0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}};

#ifdef _X86_
static __declspec(naked) void *GetCallerEIP()
{
#pragma warning(push)
#pragma warning(disable:4035)
    __asm {
        mov     eax, [esp]
        ret
};
#pragma warning(pop)
#else
static void *GetCallerEIP()
{
    return NULL;
#endif
}

#define HEAP_ACCESS_ENTRY_EMPTY -2
typedef struct 
{
    void * address;
    int length;
    BOOL IsOccupied ()
    {
        if (length == HEAP_ACCESS_ENTRY_EMPTY)
            return FALSE;
        return TRUE;
    }
    void SetNotOccupied ()
    {
        length = HEAP_ACCESS_ENTRY_EMPTY;
    }
    BOOL TryToOccupy (void *address, int length)
    {
        int origLength = InterlockedCompareExchange ((LPLONG)address, length, HEAP_ACCESS_ENTRY_EMPTY);
        if (origLength == HEAP_ACCESS_ENTRY_EMPTY)
            return TRUE;
        return FALSE;
    }

} heapAccess;

// ref counts the number of Metadatatrackers who are using this file handle. 
typedef struct
{
    HANDLE          hnd;
    DWORD           refCount;
    GUID            mvid; // Stored here for the lifetime of the handle and written out into the header in the end
} MDHintFileHandle;

static const char *MDHintFileSig = "MDH";

class MetaDataTracker
{
    typedef struct 
    {
        char sig[sizeof(MDHintFileSig)];
        DWORD version;
    } MDHHeader;

    struct Page
    {
        SIZE_T          base;
        BOOL            touched;

        DWORD           contentsKind[NUM_CONTENT_KINDS_ON_A_PAGE];
        DWORD           numContentKinds;

        DWORD           numAccesses;
        DWORD           numBytesHit;

        DWORD           rangeTouched [NUM_TRACKING_DWORDS];
    };
    
    LPWSTR          m_ModuleName;
    BYTE           *m_MetadataBase;
    BYTE           *m_MetadataPageBase;
    SIZE_T          m_MetadataSize;
    Page           *m_pages;
    SIZE_T           m_numPages;
    MetaDataTracker *m_next;
    MDHintFileHandle *m_MDHintFileHandle;

    BYTE           *m_mdSections[NUM_MD_SECTIONS];
    SIZE_T          m_mdSectionSize[NUM_MD_SECTIONS];
    BOOL            m_bActivated;

#define DONT_BREAK_ON_METADATA_ACCESS -1
#define BREAK_ON_METADATA_ACCESS 0
    DWORD m_dwBreakOnMDAccess;

    static CRITICAL_SECTION MetadataTrackerCriticalSection;
    static DWORD    s_MDTrackerCriticalSectionInited;
    static BOOL     s_MDTrackerCriticalSectionInitedDone;
    static HANDLE   s_MDErrFile;
    static BOOL     s_bMetaDataTrackerInited;
    static MDHintFileHandle *s_EmptyMDHintFileHandle;
    //
    // We don't want to link with imagehlp, so load stuff dynamically.
    //

    static HMODULE  m_imagehlp;
    static BOOL     (*m_pStackWalk)(DWORD MachineType,
                                    HANDLE hProcess,
                                    HANDLE hThread,
                                    LPSTACKFRAME StackFrame,
                                    PVOID ContextRecord,
                                    PREAD_PROCESS_MEMORY_ROUTINE ReadMemoryRoutine,
                                    PFUNCTION_TABLE_ACCESS_ROUTINE FunctionTableAccessRoutine,
                                    PGET_MODULE_BASE_ROUTINE GetModuleBaseRoutine,
                                    PTRANSLATE_ADDRESS_ROUTINE TranslateAddress);

    static DWORD    (*m_pUnDecorateSymbolName)(PCSTR DecoratedName,  
                                               PSTR UnDecoratedName,  
                                               DWORD UndecoratedLength,  
                                               DWORD Flags);           

    static BOOL     (*m_pSymInitialize)(HANDLE hProcess,     
                                        PSTR UserSearchPath,  
                                        BOOL fInvadeProcess);  
    static DWORD    (*m_pSymSetOptions)(DWORD SymOptions);  
    static BOOL     (*m_pSymCleanup)(HANDLE hProcess);
    static BOOL     (*m_pSymGetLineFromAddr)(HANDLE hProcess,
                                             DWORD dwAddr,
                                             PDWORD pdwDisplacement,
                                             PIMAGEHLP_LINE Line);
    static BOOL     (*m_pSymGetSymFromAddr)(HANDLE hProcess,
                                            DWORD dwAddr,
                                            PDWORD pdwDisplacement,
                                            PIMAGEHLP_SYMBOL Symbol);
    static PVOID    (*m_pSymFunctionTableAccess)(HANDLE hProcess,
                                                 DWORD AddrBase);
    static DWORD    (*m_pSymGetModuleBase)(HANDLE hProcess,
                                           DWORD Address);
    static BOOL     m_symInit;

    static wchar_t* contents[];

    static heapAccess *orphanedHeapAccess;

    static DWORD CalcTouchedBytes (DWORD dw)
    {
        DWORD count = 0;
        while (dw)
        {
            dw = dw & (dw-1);
            count++;
        }
        return count * SIZE_OF_TRACKED_BLOCK;
    }

    static DWORD CalcPercentTouchedDensity (Page p)
    {
        DWORD touchedBytes = 0;
        for (int i=0; i<NUM_TRACKING_DWORDS; i++)
            touchedBytes += CalcTouchedBytes (p.rangeTouched[i]);
        return (touchedBytes*100)/(OS_PAGE_SIZE);
    }

    static BOOL TryLogHeapAccess(void *address, ULONG length, BOOL bOrphanedAccess = FALSE)
    {
        if (!s_trackerOptions)
            return TRUE;

        MetaDataTracker *mdMod = m_MDTrackers;
        while(mdMod)
        {
            if (mdMod->LogHeapAccessInModule(address, length, bOrphanedAccess))
                return TRUE;

            mdMod = mdMod->m_next;
        }
        return FALSE;
    }

    static void LogErrorInfo (LPCVOID lpBuffer, DWORD dwNumBytesToLog)
    {
        if (s_MDErrFile == INVALID_HANDLE_VALUE)
            return;

        DWORD written = 0;
        BOOL result = WriteFile(s_MDErrFile, lpBuffer, dwNumBytesToLog, &written, NULL);
        if ((result == 0) || (written != dwNumBytesToLog))
        {
            // If things look bad enough that even error loggin is failing then just punt
            CloseHandle (s_MDErrFile);
            s_MDErrFile = INVALID_HANDLE_VALUE;
        }
    }

    static DWORD MetadataTrackerExceptionFilter (struct _EXCEPTION_POINTERS *pExceptionInfo)
    {
        if ((pExceptionInfo->ExceptionRecord->ExceptionCode == EXCEPTION_ACCESS_VIOLATION) ||  
            (pExceptionInfo->ExceptionRecord->ExceptionCode == EXCEPTION_ARRAY_BOUNDS_EXCEEDED) ||
            (pExceptionInfo->ExceptionRecord->ExceptionCode == EXCEPTION_IN_PAGE_ERROR))
            return EXCEPTION_EXECUTE_HANDLER;
        else 
            return EXCEPTION_CONTINUE_SEARCH;
    }

    static LPCWSTR GetLeafFileName(LPWSTR path)
    {
        WCHAR *pStart = path;
        WCHAR *pEnd = pStart + wcslen(path);
        WCHAR *p = pEnd;
    
        while (p > pStart)
        {
            if (*--p == '\\')
            {
                p++;
                break;
            }
        }
    
        return p;
    }   

	void ZapMetadataTrackerMVID (MDHintFileHandle *hintFileHandle)
	{
		// Assumes that the file pointer is not being used. So no need to synchromnize.
		if (hintFileHandle->hnd == NULL)
			return;
		
		DWORD filePtr = SetFilePointer (hintFileHandle->hnd, sizeof(MDHHeader), 0, FILE_BEGIN);
		if (filePtr == INVALID_SET_FILE_POINTER)
			goto ErrExit;

        DWORD written = 0;
        BOOL result = WriteFile(hintFileHandle->hnd, &(hintFileHandle->mvid), 
                                sizeof(GUID), &written, NULL);
        _ASSERTE(result && written == sizeof(GUID));

ErrExit:
		SetFilePointer (hintFileHandle->hnd, 0, 0, FILE_END);
		return;
	}

    void ReleaseFileHandle (MDHintFileHandle *hintFileHandle)
    {
        if (hintFileHandle == s_EmptyMDHintFileHandle)
            return;

        InterlockedDecrement((LONG*)&hintFileHandle->refCount);
        if (hintFileHandle->refCount == 0)
        {
            //
            // Write a sentinel null at the end of the file
            //
            DWORD written = 0;
            struct offsets
            {
                DWORD sec;
                ULONG offs;
            } s;
            s.sec = 0xFFFFFFFF;
            s.offs = 0xFFFFFFFF;
            BOOL result = WriteFile(hintFileHandle->hnd, &s, 
                                    sizeof(s), &written, NULL);
            _ASSERTE(result && written == sizeof(s));

            FlushFileBuffers(hintFileHandle->hnd);
		    // Before closing the file, write out the mvid;
            ZapMetadataTrackerMVID(hintFileHandle);
            FlushFileBuffers(hintFileHandle->hnd);
            CloseHandle(hintFileHandle->hnd);
            delete hintFileHandle;
        }
    }

    MDHintFileHandle *GetFileHandleFromName (LPCWSTR modName)
    {
        MetaDataTracker *mdMod = m_MDTrackers;
        while( mdMod)
        {
           if (wcscmp (modName, mdMod->m_ModuleName) == 0)
           {
               _ASSERTE (mdMod->m_MDHintFileHandle);
               _ASSERTE (mdMod->m_MDHintFileHandle->refCount > 0);
               _ASSERTE (mdMod->m_MDHintFileHandle->hnd != INVALID_HANDLE_VALUE);
               return mdMod->m_MDHintFileHandle;
           }

            mdMod = mdMod->m_next;
        }
        return NULL;
    }

public:
#define METADATA_TRACKER_NONE 0
#define METADATA_TRACKER_GEN_MDH_FILE 1
#define METADATA_TRACKER_STATS 2
#define METADATA_TRACKER_VERBOSE 3
#define METADATA_TRACKER_STACKTRACE 4
#define METADATA_TRACKER_VERY_VERBOSE 5
    static DWORD            s_trackerOptions; 

    static MetaDataTracker *m_MDTrackers;

    MetaDataTracker(BYTE *baseAddress, DWORD mdSize, LPCWSTR modName)
    {
        HRESULT hr = S_OK;
        MetaDataTracker::MetaDataTrackerInit ();

        m_ModuleName = NULL;
        m_MDHintFileHandle = NULL;

        DWORD len = (DWORD)wcslen(modName);

        // Metadata heap access hint file
        WCHAR path[MAX_PATH];
    
        wcscpy(path, modName);
        WCHAR *ext = wcsrchr(path, '.');

        if (ext == NULL)
        {
            ext = path + wcslen(path);
            _ASSERTE(*ext == 0);
        }
        wcscpy(ext, L".mdh");
        HANDLE hnd = WszCreateFile(path, GENERIC_WRITE, 0, NULL, 
                                     CREATE_ALWAYS, 
                                     FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                                     NULL);
        if (hnd == INVALID_HANDLE_VALUE)
        {
            // If this failed because one of the trackers is holding onto this file then share that handle.
            MDHintFileHandle *hSharedHandle = GetFileHandleFromName (modName);
            if (hSharedHandle != NULL)
            {
                m_MDHintFileHandle = hSharedHandle;
                InterlockedIncrement((LONG*)&m_MDHintFileHandle->refCount);
            }
            else
            {
                // We really failed to get the handle.
                MDLOG(METADATA_TRACKER_VERY_VERBOSE,("Mdh file not created: GetLastError %d\n", GetLastError()));
                // Point to the  empty one.
                m_MDHintFileHandle = s_EmptyMDHintFileHandle;
            }
        }
        else
        {
            m_MDHintFileHandle = new MDHintFileHandle();
            if (m_MDHintFileHandle)
            {
                m_MDHintFileHandle->hnd = hnd;
                m_MDHintFileHandle->refCount = 1; // not thread safe; but do we care? @TODO make thread safe
                m_MDHintFileHandle->mvid = NULL_GUID;

                if (m_MDHintFileHandle->hnd != NULL)
                {
                    MDHHeader header;
                    BYTE fullheader [sizeof(MDHHeader)+sizeof(GUID)];
                    GUID mvid = NULL_GUID;
        
                    strcpy (header.sig, MDHintFileSig); 
                    header.version = 2;
        
                    memcpy (fullheader, (LPVOID)&header, sizeof(MDHHeader));
                    memcpy (fullheader+sizeof(MDHHeader), &mvid, sizeof(GUID));
        
                    DWORD written = 0;
                        BOOL result = WriteFile(m_MDHintFileHandle->hnd, &fullheader, 
                                            sizeof(fullheader), &written, NULL);
                    _ASSERTE(result && written == sizeof(fullheader));
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
                MDLOG(METADATA_TRACKER_VERBOSE,("Metadata tracker out of mem."));
                goto ErrExit;
            }
        }

        // in either case after this point we should be pointing to a valid handle object.
        _ASSERTE (m_MDHintFileHandle); 

		#ifdef BREAK_META_ACCESS
        wchar_t *wszbreakOnMDAccessFile = REGUTIL::GetConfigString (L"BreakOnMetadataAccessFile");
        if (wszbreakOnMDAccessFile && wcscmp (wszbreakOnMDAccessFile, GetLeafFileName((LPWSTR)modName)) == 0)
        {
            // If the module is specifed then by default break at first page. 
            m_dwBreakOnMDAccess = REGUTIL::GetConfigDWORD (L"BreakOnMetadataAccess", BREAK_ON_METADATA_ACCESS);
        }
        else
        #endif
        {
            m_dwBreakOnMDAccess = DONT_BREAK_ON_METADATA_ACCESS;
        }

        m_ModuleName = new wchar_t[len + 1];
        if (m_ModuleName != NULL)
        {
            wcscpy((wchar_t *)m_ModuleName, (wchar_t *)modName);
            MDLOG(METADATA_TRACKER_VERBOSE,("Created Metadata tracker for %s\n", m_ModuleName));
        }
        else
        {
            hr = E_OUTOFMEMORY;
            goto ErrExit;
        }

        m_MetadataBase = baseAddress;
        m_MetadataPageBase = (BYTE*) (((SIZE_T)(m_MetadataBase))&~(OS_PAGE_SIZE-1));
        m_MetadataSize = mdSize; 
        
        m_numPages =  ((m_MetadataSize+(OS_PAGE_SIZE-1))&~(OS_PAGE_SIZE-1)) / OS_PAGE_SIZE + 1;
        m_pages = new Page [ m_numPages ];
        if (!m_pages)
        {
            hr = E_OUTOFMEMORY;
            goto ErrExit;
        }
        MDLOG(METADATA_TRACKER_VERBOSE,("Created Metadata tracker for %s\n", m_ModuleName));
		memset (m_pages, 0, sizeof(Page)*m_numPages);

        Page *p = m_pages;
        Page *pEnd = p + m_numPages;
        BYTE *base = m_MetadataPageBase;

        while (p < pEnd)
        {
            p->base = (SIZE_T)base;
            p++;
            base += OS_PAGE_SIZE;
        }

        m_next = m_MDTrackers;
        m_MDTrackers = this;

        memset (m_mdSections, 0, NUM_MD_SECTIONS*sizeof(BYTE*));
        memset (m_mdSectionSize, 0, NUM_MD_SECTIONS*sizeof(SIZE_T));

        MDLOG(METADATA_TRACKER_VERBOSE,("Created Metadata tracker with Base: 0x%0x, Size: %d, Num Pages: %d\n", (size_t)m_MetadataBase, (size_t)m_MetadataSize, m_numPages));

        Activate();
    
    ErrExit:
        if (FAILED(hr))
        {
            if (m_pages)
                delete [] m_pages;
            m_pages = NULL;

            if (m_ModuleName)
                delete m_ModuleName;
            m_ModuleName = NULL;

            if (m_MDHintFileHandle)
                delete m_MDHintFileHandle;
            m_MDHintFileHandle = NULL;
        }
    }

    ~MetaDataTracker()
    {
        // Surely if we are dying, we are being deactivated as well
        Deactivate();

        DWORD written = 0;
        if (m_MDHintFileHandle)
        {
            ReleaseFileHandle (m_MDHintFileHandle);
            m_MDHintFileHandle = NULL;
        }

        MDLOG(METADATA_TRACKER_VERBOSE,("Deleted Metadata tracker for %s", m_ModuleName));
        if (m_pages)
            delete m_pages;
        if (m_ModuleName)
            delete m_ModuleName;

        // Remove this tracker from the global list of trackers

        MetaDataTracker *mdMod = m_MDTrackers;

        _ASSERTE (mdMod && "Trying to delete metadata tracker where none exist");

        // If ours is the first tracker
        if (mdMod == this)
        {
            m_MDTrackers = mdMod->m_next;
            mdMod->m_next = NULL;
        }
        else
        {
            // Now traverse thru the list and maintain the prev ptr.
            MetaDataTracker *mdModPrev = mdMod;
            mdMod = mdMod->m_next;
            while(mdMod)
            {
                if (mdMod == this)
                {
                    mdModPrev->m_next = mdMod->m_next;
                    mdMod->m_next = NULL;
                    break;
                }
                mdModPrev = mdMod;
                mdMod = mdMod->m_next;
            }
        }
    }

    // One time initialization
    static void MetaDataTrackerInit()
    {
        if (s_bMetaDataTrackerInited)
            return;

        Enable (REGUTIL::GetConfigDWORD (L"ShowMetaDataAccess", METADATA_TRACKER_NONE));

        if (s_trackerOptions == METADATA_TRACKER_NONE)
            return;
        
        s_EmptyMDHintFileHandle = new MDHintFileHandle();
        if (!s_EmptyMDHintFileHandle)
            return;
        
        EnsureMDTrackerCriticalSectionInitialized ();

        EnterCriticalSection (&MetadataTrackerCriticalSection);
        
        s_EmptyMDHintFileHandle->hnd = NULL;
        s_EmptyMDHintFileHandle->refCount = -1;
        s_EmptyMDHintFileHandle->mvid = NULL_GUID;

        // Even if one metadatatracker wants stack trace we load this dll.
        if (s_trackerOptions >= METADATA_TRACKER_STACKTRACE)
            m_imagehlp = WszLoadLibrary(L"imagehlp.dll");

        if (m_imagehlp)
        {
            m_pStackWalk = (BOOL(*)(DWORD MachineType,
                                            HANDLE hProcess,
                                            HANDLE hThread,
                                            LPSTACKFRAME StackFrame,
                                            PVOID ContextRecord,
                                            PREAD_PROCESS_MEMORY_ROUTINE ReadMemoryRoutine,
                                            PFUNCTION_TABLE_ACCESS_ROUTINE FunctionTableAccessRoutine,
                                            PGET_MODULE_BASE_ROUTINE GetModuleBaseRoutine,
                                            PTRANSLATE_ADDRESS_ROUTINE TranslateAddress))
              GetProcAddress(m_imagehlp, "StackWalk");
            m_pUnDecorateSymbolName = (DWORD (*)(PCSTR DecoratedName,    
                                                 PSTR UnDecoratedName,  
                                                 DWORD UndecoratedLength,    
                                                 DWORD Flags))
              GetProcAddress(m_imagehlp, "UnDecorateSymbolName");
            m_pSymInitialize = (BOOL(*)(HANDLE hProcess,     
                                        PSTR UserSearchPath,  
                                        BOOL fInvadeProcess)) 
              GetProcAddress(m_imagehlp, "SymInitialize");
            m_pSymSetOptions = (DWORD(*)(DWORD SymOptions))
              GetProcAddress(m_imagehlp, "SymSetOptions");
            m_pSymCleanup = (BOOL(*)(HANDLE hProcess))
              GetProcAddress(m_imagehlp, "SymCleanup");
            m_pSymGetLineFromAddr = (BOOL(*)(HANDLE hProcess,
                                             DWORD dwAddr,
                                             PDWORD pdwDisplacement,
                                             PIMAGEHLP_LINE Line))
              GetProcAddress(m_imagehlp, "SymGetLineFromAddr");
            m_pSymGetSymFromAddr = (BOOL(*)(HANDLE hProcess,
                                            DWORD dwAddr,
                                            PDWORD pdwDisplacement,
                                            PIMAGEHLP_SYMBOL Symbol))
              GetProcAddress(m_imagehlp, "SymGetSymFromAddr");
            m_pSymFunctionTableAccess = (PVOID(*)(HANDLE hProcess,
                                                  DWORD AddrBase))
              GetProcAddress(m_imagehlp, "SymFunctionTableAccess");
            m_pSymGetModuleBase = (DWORD(*)(HANDLE hProcess,
                                            DWORD Address))
              GetProcAddress(m_imagehlp, "SymGetModuleBase");

        }

        orphanedHeapAccess = new heapAccess[MAX_ORPHANED_HEAP_ACCESSES_STORED];
        if (orphanedHeapAccess)
        {
            for (int i=0; i<MAX_ORPHANED_HEAP_ACCESSES_STORED; i++)
            {
                orphanedHeapAccess[i].address = 0;
                orphanedHeapAccess[i].SetNotOccupied();
            }

            s_MDErrFile = WszCreateFile(L"mdh.err", GENERIC_WRITE, 0, NULL, 
                                           CREATE_ALWAYS, 
                                           FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                                           NULL);
            if (s_MDErrFile == INVALID_HANDLE_VALUE)
            {
                MDLOG(METADATA_TRACKER_VERY_VERBOSE,("Mdh.err file not created: GetLastError %d\n", GetLastError()));
                s_MDErrFile = INVALID_HANDLE_VALUE;
            }

            s_bMetaDataTrackerInited = TRUE;
        }
        else
        {
            MDLOG(METADATA_TRACKER_VERY_VERBOSE,("Out of memory error in metadata tracker.\n"));
        }

        LeaveCriticalSection (&MetadataTrackerCriticalSection);
    }

    static void MetaDataTrackerUninit ()
    {
        if (s_trackerOptions == METADATA_TRACKER_NONE)
            return;
        
        _ASSERTE (s_MDTrackerCriticalSectionInitedDone);

        EnterCriticalSection (&MetadataTrackerCriticalSection);

        if (s_EmptyMDHintFileHandle)
            delete s_EmptyMDHintFileHandle;

        if (orphanedHeapAccess)
        {
            // Log all orphaned heap access. 
            for (int i=0; i<MAX_ORPHANED_HEAP_ACCESSES_STORED; i++)
            {
                if (orphanedHeapAccess[i].IsOccupied())
                {
                    LogErrorInfo ((void*)&orphanedHeapAccess[i], sizeof (orphanedHeapAccess[i]));
                }
            }
            
            delete [] orphanedHeapAccess;
        }
        if (s_MDErrFile != INVALID_HANDLE_VALUE)
        {
            FlushFileBuffers(s_MDErrFile);
            CloseHandle (s_MDErrFile);
            s_MDErrFile = INVALID_HANDLE_VALUE;
        }
        s_bMetaDataTrackerInited = FALSE;

        LeaveCriticalSection (&MetadataTrackerCriticalSection);
    }

    static void Enable(DWORD state=1) 
    { 
        s_trackerOptions = state;
    }

    static void Disable() { s_trackerOptions = 0; }

    static void ReportAndDie()
    {
        if (s_trackerOptions == METADATA_TRACKER_NONE)
            return;

        HANDLE hOutFile = WszCreateFile(L"MetaDataTracker.log", GENERIC_WRITE, 0, NULL, 
                                       CREATE_ALWAYS, 
                                       FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                                       NULL);

        if (hOutFile != INVALID_HANDLE_VALUE)
        {
            SetFilePointer (hOutFile, 0, 0, FILE_END);
            MetaDataTracker *mdMod = m_MDTrackers;
            while( mdMod)
            {
                mdMod->ReportModule(hOutFile);
    
                MetaDataTracker *temp = mdMod;
    
                mdMod = mdMod->m_next;
    
                delete temp;
            }

            SetFilePointer (hOutFile, 0, 0, FILE_END);
            FlushFileBuffers(hOutFile);
            CloseHandle(hOutFile);
        }

        MetaDataTrackerUninit();
        s_trackerOptions = 0;
    }

    static void NoteSection(DWORD secNum, void *address, size_t size)
    {
        if (!s_trackerOptions)
            return;
        
        MetaDataTracker *mdMod = m_MDTrackers;
        while( mdMod)
        {
            if (mdMod->NoteSectionInModule(secNum, address, size))
                return;

            mdMod = mdMod->m_next;
        }
    }

    static void NoteAccess(void *address, int length = -1, BOOL bOrphanedAccess = FALSE)
    {
        __try
        {
            if (!s_trackerOptions)
                return;

            MetaDataTracker *mdMod = m_MDTrackers;
            while( mdMod)
            {
                if (mdMod->NoteAccessInModule(address, length, bOrphanedAccess))
                    return;

                mdMod = mdMod->m_next;
            }
        }
        __except(MetadataTrackerExceptionFilter (GetExceptionInformation()))
        {
            _ASSERTE (!"Caught an AV in metadata tracker logging. ");
            heapAccess _ha;
            _ha.address = address;
            _ha.length = length;
            LogErrorInfo (&_ha, sizeof (heapAccess));     
            MDLOG(METADATA_TRACKER_VERY_VERBOSE,("METADATA_TRACKER: Heap Access Access Violated at addr 0x%0x length %d", (size_t)address, length));
        }
    }

    static void LogHeapAccess(void *address, ULONG length)
    {
        __try 
        {
            if (!s_trackerOptions)
                return;

            MDLOG(METADATA_TRACKER_VERY_VERBOSE,("METADATA_TRACKER: Trying to log  Heap Access 0x%0x %d", (size_t)address, length));
            if (TryLogHeapAccess(address, length))
            {
                MDLOG(METADATA_TRACKER_VERY_VERBOSE,("METADATA_TRACKER:  Succeded\n"));
                return;
            }

            MDLOG(METADATA_TRACKER_VERY_VERBOSE,("METADATA_TRACKER:  Failed\n"));

            // Orphaned heap access. 
            for (int i=0; i<MAX_ORPHANED_HEAP_ACCESSES_STORED; i++)
            {
                // indicates that this entry has been placed
                // in its module and is now free.
                if (!orphanedHeapAccess[i].IsOccupied())
                {
                    if (orphanedHeapAccess[i].TryToOccupy(&(orphanedHeapAccess[i].length), length)) 
                    {
                        orphanedHeapAccess[i].address = address;
                        _ASSERTE (orphanedHeapAccess[i].length == (int)length);
                        MDLOG(METADATA_TRACKER_VERY_VERBOSE,("METADATA_TRACKER: Logged Orphan Heap Access 0x%0x %d", (size_t)address, length));
                        return;
                    }
                }
                else
                {
                    if ((orphanedHeapAccess[i].address == address) && (orphanedHeapAccess[i].length == (int)length))
                    {
                        // we already have this noted.
                        MDLOG(METADATA_TRACKER_VERY_VERBOSE,("METADATA_TRACKER: Discarding duplicate Orphaned Heap Access 0x%0x %d", (size_t)address, length));
                        return;
                    }
                }
            }

            // reached here implies that we are out of entries. 
            // For now we leak but later we should try and increase the array
            _ASSERTE(!"No more orphaned accesses can be stored...");
        }
        __except(MetadataTrackerExceptionFilter (GetExceptionInformation()))
        {
            _ASSERTE (!"Caught an AV in metadata tracker logging. ");
            heapAccess _ha;
            _ha.address = address;
            _ha.length = length;
            LogErrorInfo (&_ha, sizeof (heapAccess));     
            MDLOG(METADATA_TRACKER_VERY_VERBOSE,("METADATA_TRACKER: Heap Access Access Violated at addr 0x%0x length %d", (size_t)address, length));
        }
    }

    static MetaDataTracker * FindTracker(BYTE *_MDBaseAddress)
    {
        if (!s_trackerOptions)
            return NULL;
        
        MetaDataTracker *mdMod = m_MDTrackers;
        while( mdMod)
        {
            if (mdMod->m_MetadataBase == _MDBaseAddress)
                return mdMod;

            mdMod = mdMod->m_next;
        }

        return NULL;
    }

    void MetaDataTracker::Activate()
    {
        m_bActivated = TRUE;
        //PlaceOrphanedHeapAccesses();
    }

    void MetaDataTracker::Deactivate()
    {
        //RemoveOrphanedHeapAccesses ();
        m_bActivated = FALSE;
    }

    BOOL IsActivated()
    {
        return m_bActivated;
    }

    void MetaDataTracker::NoteMVID (GUID *_mvid)
	{
		memcpy (&(m_MDHintFileHandle->mvid), _mvid, sizeof(GUID));
        //PlaceOrphanedHeapAccesses();
	}

    static MetaDataTracker *GetOrCreateMetaDataTracker (BYTE *baseAddress, DWORD mdSize, LPWSTR modName)
    {
        // If a tracker has not been created for this module, create one
        MetaDataTracker *pTracker = NULL;
        if (0 == REGUTIL::GetConfigDWORD (L"ShowMetaDataAccess", 0))
            MetaDataTracker::Disable();
        else 
        {
            pTracker = MetaDataTracker::FindTracker(baseAddress);
            if (!pTracker)
                pTracker = new MetaDataTracker(baseAddress, mdSize, modName);
            else
            {
                pTracker->Activate();
            }
        }
        return pTracker;
    }

private:
    
    // ***************************************************************************
    // Helper functions
    // ***************************************************************************

    static DWORD GET_PAGE_OFFSET(size_t addr) { return ((DWORD)(addr & 0x00000fff)); }
    static DWORD GET_BLOCK_POSITION(size_t addr) { return (DWORD)(GET_PAGE_OFFSET(addr) / SIZE_OF_TRACKED_BLOCK); }
    static DWORD BLOCK_INDEX(size_t addr) { return (DWORD)(GET_BLOCK_POSITION(addr) / NUM_TRACKED_BLOCKS_PER_DWORD); }
    static DWORD BLOCK_BIT_POSITION(size_t addr) { return (DWORD)(GET_BLOCK_POSITION(addr) % NUM_TRACKED_BLOCKS_PER_DWORD); }

    DWORD FindPool(BYTE *address)
    {
        _ASSERTE (IsActivated() && "Trying to access metadata from unloaded assembly");

        for (DWORD secNum=STRING_POOL; secNum<NUM_MD_SECTIONS; secNum++)
        {
            if ((address >= m_mdSections[secNum]) && (address < m_mdSections[secNum] + m_mdSectionSize[secNum]))
                break;
        }
        return secNum;
    }
/*
    void PlaceOrphanedHeapAccesses ()
    {
        if (!s_trackerOptions)
            return;

        BYTE *startAddr = m_MetadataBase;
        BYTE *endAddr = m_MetadataBase + m_MetadataSize;

        for (DWORD i=0; i<MAX_ORPHANED_HEAP_ACCESSES_STORED; i++)
        {
            if (orphanedHeapAccess[i].IsOccupied())
            {
                // Make sure that the heap access that we are trying to rcord is withint our range.
                if ((orphanedHeapAccess[i].address >= startAddr) && 
                    (orphanedHeapAccess[i].address < endAddr)    &&
                    (TryLogHeapAccess(orphanedHeapAccess[i].address, orphanedHeapAccess[i].length, TRUE )))
                {
                    NoteAccess(orphanedHeapAccess[i].address, orphanedHeapAccess[i].length, TRUE );
                    orphanedHeapAccess[i].SetNotOccupied();
                    MDLOG(METADATA_TRACKER_VERY_VERBOSE,("METADATA_TRACKER: Placed Orphan Heap Access 0x%0x %d", (size_t)orphanedHeapAccess[i].address, orphanedHeapAccess[i].length));
                }
            }
        }
    }

    void RemoveOrphanedHeapAccesses ()
    {
        if (!s_trackerOptions)
            return;

        BYTE *startAddr = m_MetadataBase;
        BYTE *endAddr = m_MetadataBase + m_MetadataSize;

        for (DWORD i=0; i<MAX_ORPHANED_HEAP_ACCESSES_STORED; i++)
        {
            if (orphanedHeapAccess[i].IsOccupied())
            {
                if ((orphanedHeapAccess[i].address >= startAddr) && (orphanedHeapAccess[i].address < endAddr))
                {
                    orphanedHeapAccess[i].SetNotOccupied();
                    MDLOG(METADATA_TRACKER_VERY_VERBOSE,("METADATA_TRACKER: Removed Orphan Heap Access 0x%0x %d", (size_t)orphanedHeapAccess[i].address, orphanedHeapAccess[i].length));
                }
            }
        }

    }
*/
    void UnmanagedStackTrace ()
    {
        _ASSERTE (IsActivated() && "Trying to access metadata from unloaded assembly");

        HANDLE hThread;
        hThread = GetCurrentThread();

        CONTEXT context;
        CONTEXT *pContext = &context;

		// TODO: WIN64  casting to (DWORD) is not right for WIN64.
        pContext->Eip = (DWORD)(size_t) GetCallerEIP();

        if (m_imagehlp != NULL && pContext != NULL)
        {
            if (!m_symInit)
            {
                UINT last = SetErrorMode(SEM_NOOPENFILEERRORBOX|SEM_FAILCRITICALERRORS);
                m_pSymInitialize(GetCurrentProcess(), NULL, TRUE);
                m_pSymSetOptions(SYMOPT_LOAD_LINES);
                SetErrorMode(last);

                m_symInit = TRUE;
            }

            STACKFRAME frame;
            DWORD frameCount = 0;

            ZeroMemory(&frame, sizeof(frame));
            frame.AddrPC.Offset       = pContext->Eip;
            frame.AddrPC.Mode         = AddrModeFlat;
            frame.AddrStack.Offset    = pContext->Esp;
            frame.AddrStack.Mode      = AddrModeFlat;
            frame.AddrFrame.Offset    = pContext->Ebp;
            frame.AddrFrame.Mode      = AddrModeFlat;   

#define FRAME_MAX 10

            while (frameCount < FRAME_MAX
                   && m_pStackWalk(IMAGE_FILE_MACHINE_I386, 
                                   GetCurrentProcess(), GetCurrentThread(),
                                   &frame, 
                                   NULL, NULL,
                                   m_pSymFunctionTableAccess,
                                   m_pSymGetModuleBase,
                                   NULL))
            {
                if (frame.AddrFrame.Offset == 0)
                    break;
                frameCount++;
            }

            IMAGEHLP_LINE line;
            line.SizeOfStruct = sizeof(IMAGEHLP_LINE);
            struct {
                IMAGEHLP_SYMBOL symbol; 
                CHAR            space[255];
            } symbol;
            symbol.symbol.SizeOfStruct = sizeof(IMAGEHLP_SYMBOL);
            symbol.symbol.MaxNameLength = sizeof(symbol.space) + 1;

            DWORD frameIndex = 0;

            ZeroMemory(&frame, sizeof(frame));
            frame.AddrPC.Offset       = pContext->Eip;
            frame.AddrPC.Mode         = AddrModeFlat;
            frame.AddrStack.Offset    = pContext->Esp;
            frame.AddrStack.Mode      = AddrModeFlat;
            frame.AddrFrame.Offset    = pContext->Ebp;
            frame.AddrFrame.Mode      = AddrModeFlat;   

            while (frameIndex < FRAME_MAX
                   && m_pStackWalk(IMAGE_FILE_MACHINE_I386, 
                                   GetCurrentProcess(), GetCurrentThread(),
                                   &frame, 
                                   NULL, NULL,
                                   m_pSymFunctionTableAccess,
                                   m_pSymGetModuleBase,
                                   NULL))
            {
                if (frame.AddrFrame.Offset == 0)
                    break;

                DWORD displacement;

                if (m_pSymGetSymFromAddr(GetCurrentProcess(), 
                                         frame.AddrPC.Offset, &displacement,
                                         &symbol.symbol))
                {
                    char name[215];
                    name[NumItems(name) - 1] = 0;
                    m_pUnDecorateSymbolName(symbol.symbol.Name, 
                                            name, NumItems(name) - 2, 
                                            UNDNAME_NAME_ONLY);
                    printf ("%s ", name);
                }
                else
                    printf ("%s ", "<Unknown>");

                if (m_pSymGetLineFromAddr(GetCurrentProcess(), 
                                          frame.AddrPC.Offset, &displacement,
                                          &line))
                {
                    printf ("[%s]\n", line.FileName);
                }
                else
                {
                    printf ("[%s]\n", "<Unknown>");
                }

            }
            printf ("************************\n\n");
        }
    }
    
    BOOL AddRangeInModule(void *address, size_t length)
    {
        if (address < m_MetadataBase || address > (m_MetadataBase + m_MetadataSize - 1))
            return FALSE;

        _ASSERTE (IsActivated() && "Trying to access metadata from unloaded assembly");

        Page *p = 0;
        BYTE *start = (BYTE *)address;
        BYTE *end   = (BYTE *)address + length;

        while (start < end)
        {
            p = m_pages + (((BYTE *)start - m_MetadataPageBase)/OS_PAGE_SIZE);
            p->rangeTouched[BLOCK_INDEX((size_t)start)] |= (DWORD)(1 << BLOCK_BIT_POSITION((size_t)start));
            start += SIZE_OF_TRACKED_BLOCK;
        }
        
        return TRUE;
    }

    int GetLengthOfBlob (void *address, DWORD *pdwPool)
    {
        _ASSERTE (IsActivated() && "Trying to access metadata from unloaded assembly");

        int length = -1;
        *pdwPool = FindPool((BYTE *)address);
        
        switch(*pdwPool)
        {
        case STRING_POOL:
            {
                length = (int)strlen((char *)address);
                break;
            }
        case GUID_POOL:
            {
                length = sizeof(GUID);
                break;
            }
        case BLOB_POOL: //fallthru
        case USERSTRING_POOL:
            {
                int sizeOfLength;
                length = CPackedLen::GetLength(address, &sizeOfLength);
                length += sizeOfLength;
                break;
            }
        default:
            length = -1;
        }
            // printf ("Addr: 0x%0x\t0x%0x\t%d\ttouched\theap\t%d\n", (unsigned int*)address, (unsigned int*)address+length-1, length, *pdwPool);
        return length;
    }

    void MetaDataTrackerLogHeapAccess(DWORD section, unsigned int length, void *strAddress)
    {
    
        _ASSERTE (IsActivated() && "Trying to access metadata from unloaded assembly");

        // Sanity check the length, should be less than a Meg
        if (length > 0x100000)
        {
            _ASSERTE (!"MetadataTracker: Try to log an invalid metadata access");
            return;
        }

        if (m_MDHintFileHandle->hnd != NULL)
        {
            struct offsets
            {
                DWORD sec;
                ULONG offs;
            } s;

            _ASSERTE((section >= STRING_POOL) && (section <= BLOB_POOL));

            s.sec = section;
            s.offs = length;
            BYTE *tempBuffer = new BYTE[sizeof(s) + length];
            if (tempBuffer == NULL)
                return;

            memcpy (tempBuffer, &s, sizeof(s));
            memcpy (tempBuffer+sizeof(s), strAddress, length);
            
            DWORD written = 0;
            BOOL result = WriteFile(m_MDHintFileHandle->hnd, tempBuffer, 
                                    sizeof(s)+length, &written, NULL);
            _ASSERTE(result && written == (sizeof(s)+length));

            delete [] tempBuffer;
        }
    }

    static void EnsureMDTrackerCriticalSectionInitialized ()
    {
        if (!s_trackerOptions)
            return;
        
        if (InterlockedExchange ((LPLONG)&s_MDTrackerCriticalSectionInited, 1) == 0)
        {
            // we are the first ones here. Initialize the CS.
            InitializeCriticalSection (&MetadataTrackerCriticalSection);
            s_MDTrackerCriticalSectionInitedDone = TRUE;
        }
        else
        {
            // Someone beat us to it. 
            while (!s_MDTrackerCriticalSectionInitedDone) 
            {
                // Not available in the inc dir... Spin ...
                //__SwitchToThread(0);
            }
        }
    }

#define PRINT_LOG(s) \
    { \
        swprintf s; \
        WszWideCharToMultiByte (CP_UTF8, 0, wszOutBuffer, -1, szPrintStr, FMT_STR_SIZE-1, 0, 0); \
        WriteFile(hOutFile, szPrintStr, (DWORD)strlen(szPrintStr), &written, NULL); \
    }

    // ***************************************************************************
    // Functions invoked by their static counterparts.
    // ***************************************************************************

    void ReportModule(HANDLE hOutFile)
    {
        if (s_trackerOptions < METADATA_TRACKER_STATS)
            return;

        DWORD written = 0;
        static const FMT_STR_SIZE = 2048;
        wchar_t wszOutBuffer[FMT_STR_SIZE];
        char szPrintStr[FMT_STR_SIZE];

        PRINT_LOG((wszOutBuffer, L"***********************************************\n"));
    
        PRINT_LOG((wszOutBuffer, L" Module - %s\n", m_ModuleName));
        PRINT_LOG((wszOutBuffer, L" Total pages - %d\n", m_numPages));
        PRINT_LOG((wszOutBuffer, L" Pages accessed : \n"));
        PRINT_LOG((wszOutBuffer, L"\tPage#   #Access %% Density Table/Heap\n"));

        DWORD numDirtyPages = 0;
        DWORD thisPercent = 0;
        DWORD totalPercent = 0;

        for(DWORD i = 0; i < m_numPages; i++)
        {
            if (m_pages[i].numAccesses > 0)
            {
                PRINT_LOG((wszOutBuffer, L"\t%-8d%-8d", i, m_pages[i].numAccesses));
                PRINT_LOG((wszOutBuffer, L"%-10d", (thisPercent = CalcPercentTouchedDensity (m_pages[i]))));
                for (DWORD j = 0; j < m_pages[i].numContentKinds; j++)
                {
                    PRINT_LOG((wszOutBuffer, L"%s, ", contents[m_pages[i].contentsKind[j]]));
                }
                
                PRINT_LOG((wszOutBuffer, L"\n"));
                numDirtyPages++;
                totalPercent += thisPercent;
            }
        }

        if (s_trackerOptions >= METADATA_TRACKER_VERBOSE)
        {
            PRINT_LOG((wszOutBuffer, L"\n\tPage#\tUsage map\t\t\t\t%% Density\n"));
            for(DWORD i = 0; i < m_numPages; i++)
            {
                if (m_pages[i].numAccesses > 0)
                {
                    PRINT_LOG((wszOutBuffer, L"\t%d\t%d\t", i, m_pages[i].numAccesses));
                    for (DWORD j = 0; j < NUM_TRACKING_DWORDS; j++)
                    {
                        PRINT_LOG((wszOutBuffer, L"%08x ", m_pages[i].rangeTouched[j]));
                    }
                    
                    PRINT_LOG((wszOutBuffer, L"%d\t", (thisPercent = CalcPercentTouchedDensity (m_pages[i]))));
                    PRINT_LOG((wszOutBuffer, L"\n"));
                    numDirtyPages++;
                    totalPercent += thisPercent;
                }
            }
        }
        PRINT_LOG((wszOutBuffer, L"SUMMARY - %d metadata pages touched; %d%% used \n\n", numDirtyPages, (numDirtyPages) ? (totalPercent/numDirtyPages) : 0));
    }

    BOOL NoteSectionInModule(DWORD secNum, void *address, size_t size)
    {
        _ASSERTE(secNum < NUM_MD_SECTIONS);

        if (address < m_MetadataBase || address > (m_MetadataBase + m_MetadataSize - 1))
            return FALSE;

        // This address range belongs to us but the tracker is not activated. 
        if (!IsActivated())
        {
            // _ASSERTE (!"Metadata Tracker not active but trying to access metadata");
            return TRUE;
        }

        DWORD pageIndex = (((BYTE *)address - m_MetadataPageBase)/OS_PAGE_SIZE);
        if (size > 0)
        {
            // Its possible that the section has already been noted since the NoteSection
            // for a module is called from InitMD which can be called multiple times for each
            // module.
            BOOL fSectionNoted = FALSE;
            for (DWORD tmp=0; tmp<m_pages[pageIndex].numContentKinds; tmp++)
            {
                if (m_pages[pageIndex].contentsKind[tmp] == secNum)
                {
                    fSectionNoted = TRUE;
                    break;
                }
            }
            if (!fSectionNoted)
            {
                m_pages[pageIndex].contentsKind[m_pages[pageIndex].numContentKinds++] = secNum;
                MDLOG(METADATA_TRACKER_VERBOSE,("Section Noted for %s Sec Num %d Address range 0x%0x 0x%0x\n", m_ModuleName, secNum, (size_t)address, (size_t)(address)+size));
            }
            
            _ASSERTE(m_pages[pageIndex].numContentKinds < NUM_CONTENT_KINDS_ON_A_PAGE);

            while (++pageIndex < m_numPages && m_pages[pageIndex].base <= (SIZE_T)((BYTE *)address + size - 1))
            {
                fSectionNoted = FALSE;
                for (DWORD tmp=0; tmp<m_pages[pageIndex].numContentKinds; tmp++)
                {
                        if (m_pages[pageIndex].contentsKind[tmp] == secNum)
                        {
                            fSectionNoted = TRUE;
                            break;
                        }
                }
                if (!fSectionNoted)
                {
                    m_pages[pageIndex].contentsKind[m_pages[pageIndex].numContentKinds++] = secNum;
                    MDLOG(METADATA_TRACKER_VERBOSE,("Section Noted for %s Sec Num %d Address range 0x%0x 0x%0x\n", m_ModuleName, secNum, (size_t)address, (size_t)(address)+size));
                }
                _ASSERTE(m_pages[pageIndex].numContentKinds < NUM_CONTENT_KINDS_ON_A_PAGE);
            }
        }

        m_mdSections[secNum] = (BYTE *)address;
        m_mdSectionSize[secNum] = size;
        return TRUE;
    }

    BOOL NoteAccessInModule(void *address, int length = -1, BOOL bOrphanedAccess = FALSE)
    {

        if (address < m_MetadataBase || address > (m_MetadataBase + m_MetadataSize - 1))
            return FALSE;

        if (!IsActivated())
        {
            // If its an orphaned heap access its possible that we have left over records 
            // for assemblies that were unloaded before we could note them. Ignore these for now.
            if (!bOrphanedAccess)
            {
                // _ASSERTE (!"Metadata Tracker not active but trying to access metadata");

            }

            return TRUE;
        }

        Page *p = m_pages + (((BYTE *)address - m_MetadataPageBase)/OS_PAGE_SIZE);
        _ASSERTE((SIZE_T)address >= p->base && (SIZE_T)address < p->base + OS_PAGE_SIZE);

        p->numAccesses++;

        DWORD pool;
        if (length == -1)
            length = GetLengthOfBlob (address, &pool);

        // If the length is still -1 then we have a case where the 
        // corresponding address is no longer a valid metadata heap
        // In such cases let the entry remain orphaned and we will 
        // spit out all such entries during shutdown.
        if (length == -1)
            return FALSE;
        
        AddRangeInModule (address, length);

        DWORD pageIndex = (((BYTE *)address - m_MetadataPageBase)/OS_PAGE_SIZE);

        if (m_dwBreakOnMDAccess != DONT_BREAK_ON_METADATA_ACCESS)
        {
            if (pageIndex == m_dwBreakOnMDAccess)
            {
				if (REGUTIL::GetConfigDWORD(L"BreakOnRetailAssert", 0))
				{
					DebugBreak();
				}
            }
        }

        // Dump stack on first access
        if ((p->numAccesses == 1) && (s_trackerOptions >= METADATA_TRACKER_STACKTRACE))
        {
            DWORD i = pageIndex;
            printf("Module - %S\n", m_ModuleName);
            printf("Addr: 0x%0x, PageIndex: %d, Access #: %d, Page Contents: ", (size_t)address, pageIndex, p->numAccesses);
            for (DWORD j = 0; j < m_pages[i].numContentKinds; j++)
                printf("%s, ", contents[m_pages[i].contentsKind[j]]);
            printf("\n");
            UnmanagedStackTrace();
        }
        
        return TRUE;
    }

    BOOL LogHeapAccessInModule(void *address, int length, BOOL bOrphanedAccess = FALSE)
    {
        if (address < m_MetadataBase || address > (m_MetadataBase + m_MetadataSize - 1))
            return FALSE;

        if (!IsActivated())
        {
            // If its an orphaned heap access then we cannot assert this
            if (!bOrphanedAccess)
            {
                // _ASSERTE (!"Metadata Tracker not active but trying to access metadata");
            }
            return TRUE;
        }

        DWORD pool=0;
        if (length == -1)
            length = GetLengthOfBlob (address, &pool);

        // If the length is still -1 then we have a case where the 
        // corresponding address is no longer a valid metadata heap
        // In such cases let the entry remain orphaned and we will 
        // spit out all such entries during shutdown.
        if (length == -1)
            return FALSE;

        MetaDataTrackerLogHeapAccess (pool, (unsigned int)length, address);
        return TRUE;
    }
};

#else // METADATATRACKER_ENABLED

#define METADATATRACKER_ONLY(s)

#endif // METADATATRACKER_ENABLED

#endif // GOLDEN

#endif // _METADATATRACKER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\miniio.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef _MINIFILE_H
#define _MINIFILE_H

/* --------------------------------------------------------------------------- *<
 * MiniFile - simple buffered byte I/O, plus some extra features
 * --------------------------------------------------------------------------- */

class MiniFile
{
 public:
    MiniFile(LPCWSTR pPath);
    ~MiniFile();

    // File routines

    BOOL IsEOF();
    DWORD GetOffset();
    DWORD GetSize(); 
    void Seek(LONG offset);
    void SeekTo(DWORD offset = 0);
    void SeekFromEnd(DWORD offset = 0);
    void Truncate();
    void Flush();

    // Basic I/O routines

    BOOL ReadOne(BYTE *pByte);
    BOOL Read(BYTE *buffer, DWORD length, DWORD *read);
    BOOL ReadToOne(BYTE *buffer, DWORD maxLength, DWORD *read, BYTE terminator);
    
    BOOL SkipToOne(DWORD *read, BYTE terminator);
    BOOL SkipToOneOf(DWORD *read, LPCSTR terminators);

    BOOL MatchOne(BYTE byte);
    BOOL Match(DWORD *read, const BYTE *buffer, DWORD length);

    void WriteOne(BYTE byte);
    void Write(BYTE *buffer, DWORD length, DWORD *written);

    // Basic data types

    void WriteQuotedString(LPCSTR string);
    LPSTR ReadQuotedString();

    void WriteNumber(int number);
    int ReadNumber();

    void WriteHexNumber(int number);
    int ReadHexNumber();

    // simple XML-like constructs
    // NOTE: XML stuff is really just pseudo-XML - 
    // this isn't a real parser or anything

    LPSTR ReadAnyStartTag();

    BOOL CheckStartTag(LPCSTR tag);
    void ReadStartTag(LPCSTR tag);

    BOOL CheckEndTag(LPCSTR tag);
    void ReadEndTag(LPCSTR tag);

    LPSTR CheckTag(LPCSTR tag);
    LPSTR ReadTag(LPCSTR tag);

    BOOL CheckEmptyTag(LPCSTR tag);
    void ReadEmptyTag(LPCSTR tag);

    void WriteStartTag(LPCSTR tag);
    void WriteEndTag(LPCSTR tag);
    void WriteTag(LPCSTR tag, LPCSTR string);
    void WriteEmptyTag(LPCSTR tag);

    // more complex XML-like constructs (NOT TESTED)
    
    void WriteStartTagOpen(LPCSTR tag);
    void WriteTagParameter(LPCSTR name, LPCSTR string);
    void WriteStartTagClose(LPCSTR tag);

    LPSTR ReadAnyStartTagOpen();
    BOOL CheckStartTagOpen(LPCSTR tag);
    void ReadStartTagOpen(LPCSTR tag);

    LPCSTR CheckStringParameter(LPCSTR tag);

    // end more complex XML-like constructs

    // Indentation support
    
    void PushIndent() { m_indentLevel++; }
    void PopIndent() { m_indentLevel--; }
    void SetIndentLevel(int level) { m_indentLevel = level; }
    void StartNewLine();

 protected:

    // Exception helpers

    void ThrowLastError()
      { ThrowError(GetLastError()); }

    void ThrowError(DWORD error)
      { ThrowHR(HRESULT_FROM_WIN32(error)); }

    // Override these to use different exception mechanisms

    virtual void ThrowHR(HRESULT hr);
    
    enum SyntaxError
    {
        MISMATCHED_QUOTES,
        MISMATCHED_TAG_BRACKETS,
        MISMATCHED_TAG,
        EXPECTED_TAG_OPEN,
    };

    virtual void ThrowSyntaxError(SyntaxError error) 
      { ThrowError(ERROR_BAD_FORMAT); }

    virtual void ThrowExpectedTag(LPCSTR tag)
      { ThrowError(ERROR_BAD_FORMAT); }

 private:
    void EmptyBuffer();
    void SyncBuffer();

    enum { BUFFER_SIZE = 1024 };

    HANDLE  m_file;
    BYTE    m_buffer[BUFFER_SIZE];      // R/W buffer
    BYTE    *m_pos;                     // Current exposed file position in buffer
    BYTE    *m_filePos;                 // Current real (OS) file position in buffer
    BYTE    *m_end;                     // End of valid data in buffer

    BOOL    m_dirty;                    // Have we written to the buffer?
    BOOL    m_eof;                      // Is m_end known to be the EOF?

    int     m_indentLevel;
};

#endif _MINIFILE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\mscoree.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Thu Feb 20 18:27:05 2003
 */
/* Compiler settings for mscoree.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __mscoree_h__
#define __mscoree_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IObjectHandle_FWD_DEFINED__
#define __IObjectHandle_FWD_DEFINED__
typedef interface IObjectHandle IObjectHandle;
#endif 	/* __IObjectHandle_FWD_DEFINED__ */


#ifndef __IAppDomainBinding_FWD_DEFINED__
#define __IAppDomainBinding_FWD_DEFINED__
typedef interface IAppDomainBinding IAppDomainBinding;
#endif 	/* __IAppDomainBinding_FWD_DEFINED__ */


#ifndef __IGCThreadControl_FWD_DEFINED__
#define __IGCThreadControl_FWD_DEFINED__
typedef interface IGCThreadControl IGCThreadControl;
#endif 	/* __IGCThreadControl_FWD_DEFINED__ */


#ifndef __IGCHostControl_FWD_DEFINED__
#define __IGCHostControl_FWD_DEFINED__
typedef interface IGCHostControl IGCHostControl;
#endif 	/* __IGCHostControl_FWD_DEFINED__ */


#ifndef __ICorThreadpool_FWD_DEFINED__
#define __ICorThreadpool_FWD_DEFINED__
typedef interface ICorThreadpool ICorThreadpool;
#endif 	/* __ICorThreadpool_FWD_DEFINED__ */


#ifndef __IDebuggerThreadControl_FWD_DEFINED__
#define __IDebuggerThreadControl_FWD_DEFINED__
typedef interface IDebuggerThreadControl IDebuggerThreadControl;
#endif 	/* __IDebuggerThreadControl_FWD_DEFINED__ */


#ifndef __IDebuggerInfo_FWD_DEFINED__
#define __IDebuggerInfo_FWD_DEFINED__
typedef interface IDebuggerInfo IDebuggerInfo;
#endif 	/* __IDebuggerInfo_FWD_DEFINED__ */


#ifndef __ICorConfiguration_FWD_DEFINED__
#define __ICorConfiguration_FWD_DEFINED__
typedef interface ICorConfiguration ICorConfiguration;
#endif 	/* __ICorConfiguration_FWD_DEFINED__ */


#ifndef __ICorRuntimeHost_FWD_DEFINED__
#define __ICorRuntimeHost_FWD_DEFINED__
typedef interface ICorRuntimeHost ICorRuntimeHost;
#endif 	/* __ICorRuntimeHost_FWD_DEFINED__ */


#ifndef __IApartmentCallback_FWD_DEFINED__
#define __IApartmentCallback_FWD_DEFINED__
typedef interface IApartmentCallback IApartmentCallback;
#endif 	/* __IApartmentCallback_FWD_DEFINED__ */


#ifndef __IManagedObject_FWD_DEFINED__
#define __IManagedObject_FWD_DEFINED__
typedef interface IManagedObject IManagedObject;
#endif 	/* __IManagedObject_FWD_DEFINED__ */


#ifndef __ICatalogServices_FWD_DEFINED__
#define __ICatalogServices_FWD_DEFINED__
typedef interface ICatalogServices ICatalogServices;
#endif 	/* __ICatalogServices_FWD_DEFINED__ */


#ifndef __ComCallUnmarshal_FWD_DEFINED__
#define __ComCallUnmarshal_FWD_DEFINED__

#ifdef __cplusplus
typedef class ComCallUnmarshal ComCallUnmarshal;
#else
typedef struct ComCallUnmarshal ComCallUnmarshal;
#endif /* __cplusplus */

#endif 	/* __ComCallUnmarshal_FWD_DEFINED__ */


#ifndef __CorRuntimeHost_FWD_DEFINED__
#define __CorRuntimeHost_FWD_DEFINED__

#ifdef __cplusplus
typedef class CorRuntimeHost CorRuntimeHost;
#else
typedef struct CorRuntimeHost CorRuntimeHost;
#endif /* __cplusplus */

#endif 	/* __CorRuntimeHost_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "gchost.h"
#include "ivalidator.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_mscoree_0000 */
/* [local] */ 

#define	CLR_MAJOR_VERSION	( 1 )

#define	CLR_MINOR_VERSION	( 1 )

#define	CLR_BUILD_VERSION	( 4322 )

#define	CLR_ASSEMBLY_MAJOR_VERSION	( 1 )

#define	CLR_ASSEMBLY_MINOR_VERSION	( 0 )

#define	CLR_ASSEMBLY_BUILD_VERSION	( 5000 )

extern const GUID __declspec(selectany) LIBID_mscoree = {0x5477469e,0x83b1,0x11d2,{0x8b,0x49,0x00,0xa0,0xc9,0xb7,0xc9,0xc4}};
extern const GUID  __declspec(selectany) CLSID_CorRuntimeHost = { 0xcb2f6723, 0xab3a, 0x11d2, { 0x9c, 0x40, 0x00, 0xc0, 0x4f, 0xa3, 0x0a, 0x3e } };
extern const GUID __declspec(selectany) CLSID_ComCallUnmarshal = {0x3F281000,0xE95A,0x11d2,{0x88,0x6B,0x00,0xC0,0x4F,0x86,0x9F,0x04}};
extern const GUID __declspec(selectany) IID_IObjectHandle = { 0xc460e2b4, 0xe199, 0x412a, { 0x84, 0x56, 0x84, 0xdc, 0x3e, 0x48, 0x38, 0xc3 } };
extern const GUID  __declspec(selectany) IID_IManagedObject = { 0xc3fcc19e, 0xa970, 0x11d2, { 0x8b, 0x5a, 0x00, 0xa0, 0xc9, 0xb7, 0xc9, 0xc4 } };
extern const GUID  __declspec(selectany) IID_IApartmentCallback = { 0x178e5337, 0x1528, 0x4591, { 0xb1, 0xc9, 0x1c, 0x6e, 0x48, 0x46, 0x86, 0xd8 } };
extern const GUID  __declspec(selectany) IID_ICatalogServices =  { 0x04c6be1e, 0x1db1, 0x4058, { 0xab, 0x7a, 0x70, 0x0c, 0xcc, 0xfb, 0xf2, 0x54} };
extern const GUID  __declspec(selectany) IID_ICorRuntimeHost = { 0xcb2f6722, 0xab3a, 0x11d2, { 0x9c, 0x40, 0x00, 0xc0, 0x4f, 0xa3, 0x0a, 0x3e } };
extern const GUID  __declspec(selectany) IID_ICorThreadpool = { 0x84680D3A, 0xB2C1, 0x46e8, {0xAC, 0xC2, 0xDB, 0xC0, 0xA3, 0x59, 0x15, 0x9A } };
STDAPI GetCORSystemDirectory(LPWSTR pbuffer, DWORD  cchBuffer, DWORD* dwLength);
STDAPI GetCORVersion(LPWSTR pbBuffer, DWORD cchBuffer, DWORD* dwLength);
STDAPI GetFileVersion(LPCWSTR szFilename, LPWSTR szBuffer, DWORD cchBuffer, DWORD* dwLength);
STDAPI GetCORRequiredVersion(LPWSTR pbuffer, DWORD cchBuffer, DWORD* dwLength);
STDAPI GetRequestedRuntimeInfo(LPCWSTR pExe, LPCWSTR pwszVersion, LPCWSTR pConfigurationFile, DWORD startupFlags, DWORD reserved, LPWSTR pDirectory, DWORD dwDirectory, DWORD *dwDirectoryLength, LPWSTR pVersion, DWORD cchBuffer, DWORD* dwLength);
STDAPI GetRequestedRuntimeVersion(LPWSTR pExe, LPWSTR pVersion, DWORD cchBuffer, DWORD* dwLength);
STDAPI CorBindToRuntimeHost(LPCWSTR pwszVersion, LPCWSTR pwszBuildFlavor, LPCWSTR pwszHostConfigFile, VOID* pReserved, DWORD startupFlags, REFCLSID rclsid, REFIID riid, LPVOID FAR *ppv);
STDAPI CorBindToRuntimeEx(LPCWSTR pwszVersion, LPCWSTR pwszBuildFlavor, DWORD startupFlags, REFCLSID rclsid, REFIID riid, LPVOID FAR *ppv);
STDAPI CorBindToRuntimeByCfg(IStream* pCfgStream, DWORD reserved, DWORD startupFlags, REFCLSID rclsid,REFIID riid, LPVOID FAR* ppv);
STDAPI CorBindToRuntime(LPCWSTR pwszVersion, LPCWSTR pwszBuildFlavor, REFCLSID rclsid, REFIID riid, LPVOID FAR *ppv);
STDAPI CorBindToCurrentRuntime(LPCWSTR pwszFileName, REFCLSID rclsid, REFIID riid, LPVOID FAR *ppv);
STDAPI ClrCreateManagedInstance(LPCWSTR pTypeName, REFIID riid, void **ppObject);
void STDMETHODCALLTYPE CorMarkThreadInThreadPool();
STDAPI RunDll32ShimW(HWND hwnd, HINSTANCE hinst, LPCWSTR lpszCmdLine, int nCmdShow);
STDAPI LoadLibraryShim(LPCWSTR szDllName, LPCWSTR szVersion, LPVOID pvReserved, HMODULE *phModDll);
STDAPI CallFunctionShim(LPCWSTR szDllName, LPCSTR szFunctionName, LPVOID lpvArgument1, LPVOID lpvArgument2, LPCWSTR szVersion, LPVOID pvReserved);
STDAPI GetRealProcAddress(LPCSTR pwszProcName, VOID** ppv);
void STDMETHODCALLTYPE CorExitProcess(int exitCode);
typedef /* [public] */ 
enum __MIDL___MIDL_itf_mscoree_0000_0001
    {	STARTUP_CONCURRENT_GC	= 0x1,
	STARTUP_LOADER_OPTIMIZATION_MASK	= 0x3 << 1,
	STARTUP_LOADER_OPTIMIZATION_SINGLE_DOMAIN	= 0x1 << 1,
	STARTUP_LOADER_OPTIMIZATION_MULTI_DOMAIN	= 0x2 << 1,
	STARTUP_LOADER_OPTIMIZATION_MULTI_DOMAIN_HOST	= 0x3 << 1,
	STARTUP_LOADER_SAFEMODE	= 0x10,
	STARTUP_LOADER_SETPREFERENCE	= 0x100
    } 	STARTUP_FLAGS;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_mscoree_0000_0002
    {	CLSID_RESOLUTION_DEFAULT	= 0,
	CLSID_RESOLUTION_REGISTERED	= 0x1
    } 	CLSID_RESOLUTION_FLAGS;

STDAPI GetRequestedRuntimeVersionForCLSID(REFCLSID rclsid, LPWSTR pVersion, DWORD cchBuffer, DWORD* dwLength, CLSID_RESOLUTION_FLAGS dwResolutionFlags);


extern RPC_IF_HANDLE __MIDL_itf_mscoree_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mscoree_0000_v0_0_s_ifspec;

#ifndef __IObjectHandle_INTERFACE_DEFINED__
#define __IObjectHandle_INTERFACE_DEFINED__

/* interface IObjectHandle */
/* [unique][helpstring][uuid][oleautomation][object] */ 


EXTERN_C const IID IID_IObjectHandle;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C460E2B4-E199-412a-8456-84DC3E4838C3")
    IObjectHandle : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Unwrap( 
            /* [retval][out] */ VARIANT *ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObjectHandleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IObjectHandle * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IObjectHandle * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IObjectHandle * This);
        
        HRESULT ( STDMETHODCALLTYPE *Unwrap )( 
            IObjectHandle * This,
            /* [retval][out] */ VARIANT *ppv);
        
        END_INTERFACE
    } IObjectHandleVtbl;

    interface IObjectHandle
    {
        CONST_VTBL struct IObjectHandleVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObjectHandle_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IObjectHandle_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IObjectHandle_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IObjectHandle_Unwrap(This,ppv)	\
    (This)->lpVtbl -> Unwrap(This,ppv)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IObjectHandle_Unwrap_Proxy( 
    IObjectHandle * This,
    /* [retval][out] */ VARIANT *ppv);


void __RPC_STUB IObjectHandle_Unwrap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IObjectHandle_INTERFACE_DEFINED__ */


#ifndef __IAppDomainBinding_INTERFACE_DEFINED__
#define __IAppDomainBinding_INTERFACE_DEFINED__

/* interface IAppDomainBinding */
/* [object][local][unique][helpstring][version][uuid] */ 


EXTERN_C const IID IID_IAppDomainBinding;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5C2B07A7-1E98-11d3-872F-00C04F79ED0D")
    IAppDomainBinding : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnAppDomain( 
            /* [in] */ IUnknown *pAppdomain) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAppDomainBindingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAppDomainBinding * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAppDomainBinding * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAppDomainBinding * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnAppDomain )( 
            IAppDomainBinding * This,
            /* [in] */ IUnknown *pAppdomain);
        
        END_INTERFACE
    } IAppDomainBindingVtbl;

    interface IAppDomainBinding
    {
        CONST_VTBL struct IAppDomainBindingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAppDomainBinding_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAppDomainBinding_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAppDomainBinding_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAppDomainBinding_OnAppDomain(This,pAppdomain)	\
    (This)->lpVtbl -> OnAppDomain(This,pAppdomain)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAppDomainBinding_OnAppDomain_Proxy( 
    IAppDomainBinding * This,
    /* [in] */ IUnknown *pAppdomain);


void __RPC_STUB IAppDomainBinding_OnAppDomain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAppDomainBinding_INTERFACE_DEFINED__ */


#ifndef __IGCThreadControl_INTERFACE_DEFINED__
#define __IGCThreadControl_INTERFACE_DEFINED__

/* interface IGCThreadControl */
/* [object][local][unique][helpstring][version][uuid] */ 


EXTERN_C const IID IID_IGCThreadControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F31D1788-C397-4725-87A5-6AF3472C2791")
    IGCThreadControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ThreadIsBlockingForSuspension( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SuspensionStarting( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SuspensionEnding( 
            DWORD Generation) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGCThreadControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGCThreadControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGCThreadControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGCThreadControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *ThreadIsBlockingForSuspension )( 
            IGCThreadControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *SuspensionStarting )( 
            IGCThreadControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *SuspensionEnding )( 
            IGCThreadControl * This,
            DWORD Generation);
        
        END_INTERFACE
    } IGCThreadControlVtbl;

    interface IGCThreadControl
    {
        CONST_VTBL struct IGCThreadControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGCThreadControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGCThreadControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGCThreadControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGCThreadControl_ThreadIsBlockingForSuspension(This)	\
    (This)->lpVtbl -> ThreadIsBlockingForSuspension(This)

#define IGCThreadControl_SuspensionStarting(This)	\
    (This)->lpVtbl -> SuspensionStarting(This)

#define IGCThreadControl_SuspensionEnding(This,Generation)	\
    (This)->lpVtbl -> SuspensionEnding(This,Generation)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IGCThreadControl_ThreadIsBlockingForSuspension_Proxy( 
    IGCThreadControl * This);


void __RPC_STUB IGCThreadControl_ThreadIsBlockingForSuspension_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IGCThreadControl_SuspensionStarting_Proxy( 
    IGCThreadControl * This);


void __RPC_STUB IGCThreadControl_SuspensionStarting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IGCThreadControl_SuspensionEnding_Proxy( 
    IGCThreadControl * This,
    DWORD Generation);


void __RPC_STUB IGCThreadControl_SuspensionEnding_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGCThreadControl_INTERFACE_DEFINED__ */


#ifndef __IGCHostControl_INTERFACE_DEFINED__
#define __IGCHostControl_INTERFACE_DEFINED__

/* interface IGCHostControl */
/* [object][local][unique][helpstring][version][uuid] */ 


EXTERN_C const IID IID_IGCHostControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5513D564-8374-4cb9-AED9-0083F4160A1D")
    IGCHostControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RequestVirtualMemLimit( 
            /* [in] */ SIZE_T sztMaxVirtualMemMB,
            /* [out][in] */ SIZE_T *psztNewMaxVirtualMemMB) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGCHostControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGCHostControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGCHostControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGCHostControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *RequestVirtualMemLimit )( 
            IGCHostControl * This,
            /* [in] */ SIZE_T sztMaxVirtualMemMB,
            /* [out][in] */ SIZE_T *psztNewMaxVirtualMemMB);
        
        END_INTERFACE
    } IGCHostControlVtbl;

    interface IGCHostControl
    {
        CONST_VTBL struct IGCHostControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGCHostControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGCHostControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGCHostControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGCHostControl_RequestVirtualMemLimit(This,sztMaxVirtualMemMB,psztNewMaxVirtualMemMB)	\
    (This)->lpVtbl -> RequestVirtualMemLimit(This,sztMaxVirtualMemMB,psztNewMaxVirtualMemMB)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IGCHostControl_RequestVirtualMemLimit_Proxy( 
    IGCHostControl * This,
    /* [in] */ SIZE_T sztMaxVirtualMemMB,
    /* [out][in] */ SIZE_T *psztNewMaxVirtualMemMB);


void __RPC_STUB IGCHostControl_RequestVirtualMemLimit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGCHostControl_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mscoree_0122 */
/* [local] */ 

#if (_MSC_VER < 1300 || _WIN32_WINNT < 0x0500)
typedef VOID ( __stdcall *WAITORTIMERCALLBACK )( 
    PVOID __MIDL_0010,
    BOOL __MIDL_0011);

#endif // (_MSC_VER < 1300 || _WIN32_WINNT < 0x0500)
#ifdef __midl
typedef DWORD ( __stdcall *LPTHREAD_START_ROUTINE )( 
    LPVOID lpThreadParameter);

typedef VOID ( *LPOVERLAPPED_COMPLETION_ROUTINE )( 
    DWORD dwErrorCode,
    DWORD dwNumberOfBytesTransfered,
    LPVOID lpOverlapped);

#endif // __midl


extern RPC_IF_HANDLE __MIDL_itf_mscoree_0122_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mscoree_0122_v0_0_s_ifspec;

#ifndef __ICorThreadpool_INTERFACE_DEFINED__
#define __ICorThreadpool_INTERFACE_DEFINED__

/* interface ICorThreadpool */
/* [object][local][unique][helpstring][version][uuid] */ 


EXTERN_C const IID IID_ICorThreadpool;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("84680D3A-B2C1-46e8-ACC2-DBC0A359159A")
    ICorThreadpool : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CorRegisterWaitForSingleObject( 
            /* [in] */ HANDLE *phNewWaitObject,
            /* [in] */ HANDLE hWaitObject,
            /* [in] */ WAITORTIMERCALLBACK Callback,
            /* [in] */ PVOID Context,
            /* [in] */ ULONG timeout,
            /* [in] */ BOOL executeOnlyOnce,
            /* [out] */ BOOL *result) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CorUnregisterWait( 
            /* [in] */ HANDLE hWaitObject,
            /* [in] */ HANDLE CompletionEvent,
            /* [out] */ BOOL *result) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CorQueueUserWorkItem( 
            /* [in] */ LPTHREAD_START_ROUTINE Function,
            /* [in] */ PVOID Context,
            /* [in] */ BOOL executeOnlyOnce,
            /* [out] */ BOOL *result) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CorCreateTimer( 
            /* [in] */ HANDLE *phNewTimer,
            /* [in] */ WAITORTIMERCALLBACK Callback,
            /* [in] */ PVOID Parameter,
            /* [in] */ DWORD DueTime,
            /* [in] */ DWORD Period,
            /* [out] */ BOOL *result) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CorChangeTimer( 
            /* [in] */ HANDLE Timer,
            /* [in] */ ULONG DueTime,
            /* [in] */ ULONG Period,
            /* [out] */ BOOL *result) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CorDeleteTimer( 
            /* [in] */ HANDLE Timer,
            /* [in] */ HANDLE CompletionEvent,
            /* [out] */ BOOL *result) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CorBindIoCompletionCallback( 
            /* [in] */ HANDLE fileHandle,
            /* [in] */ LPOVERLAPPED_COMPLETION_ROUTINE callback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CorCallOrQueueUserWorkItem( 
            /* [in] */ LPTHREAD_START_ROUTINE Function,
            /* [in] */ PVOID Context,
            /* [out] */ BOOL *result) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CorSetMaxThreads( 
            /* [in] */ DWORD MaxWorkerThreads,
            /* [in] */ DWORD MaxIOCompletionThreads) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CorGetMaxThreads( 
            /* [out] */ DWORD *MaxWorkerThreads,
            /* [out] */ DWORD *MaxIOCompletionThreads) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CorGetAvailableThreads( 
            /* [out] */ DWORD *AvailableWorkerThreads,
            /* [out] */ DWORD *AvailableIOCompletionThreads) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorThreadpoolVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorThreadpool * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorThreadpool * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorThreadpool * This);
        
        HRESULT ( STDMETHODCALLTYPE *CorRegisterWaitForSingleObject )( 
            ICorThreadpool * This,
            /* [in] */ HANDLE *phNewWaitObject,
            /* [in] */ HANDLE hWaitObject,
            /* [in] */ WAITORTIMERCALLBACK Callback,
            /* [in] */ PVOID Context,
            /* [in] */ ULONG timeout,
            /* [in] */ BOOL executeOnlyOnce,
            /* [out] */ BOOL *result);
        
        HRESULT ( STDMETHODCALLTYPE *CorUnregisterWait )( 
            ICorThreadpool * This,
            /* [in] */ HANDLE hWaitObject,
            /* [in] */ HANDLE CompletionEvent,
            /* [out] */ BOOL *result);
        
        HRESULT ( STDMETHODCALLTYPE *CorQueueUserWorkItem )( 
            ICorThreadpool * This,
            /* [in] */ LPTHREAD_START_ROUTINE Function,
            /* [in] */ PVOID Context,
            /* [in] */ BOOL executeOnlyOnce,
            /* [out] */ BOOL *result);
        
        HRESULT ( STDMETHODCALLTYPE *CorCreateTimer )( 
            ICorThreadpool * This,
            /* [in] */ HANDLE *phNewTimer,
            /* [in] */ WAITORTIMERCALLBACK Callback,
            /* [in] */ PVOID Parameter,
            /* [in] */ DWORD DueTime,
            /* [in] */ DWORD Period,
            /* [out] */ BOOL *result);
        
        HRESULT ( STDMETHODCALLTYPE *CorChangeTimer )( 
            ICorThreadpool * This,
            /* [in] */ HANDLE Timer,
            /* [in] */ ULONG DueTime,
            /* [in] */ ULONG Period,
            /* [out] */ BOOL *result);
        
        HRESULT ( STDMETHODCALLTYPE *CorDeleteTimer )( 
            ICorThreadpool * This,
            /* [in] */ HANDLE Timer,
            /* [in] */ HANDLE CompletionEvent,
            /* [out] */ BOOL *result);
        
        HRESULT ( STDMETHODCALLTYPE *CorBindIoCompletionCallback )( 
            ICorThreadpool * This,
            /* [in] */ HANDLE fileHandle,
            /* [in] */ LPOVERLAPPED_COMPLETION_ROUTINE callback);
        
        HRESULT ( STDMETHODCALLTYPE *CorCallOrQueueUserWorkItem )( 
            ICorThreadpool * This,
            /* [in] */ LPTHREAD_START_ROUTINE Function,
            /* [in] */ PVOID Context,
            /* [out] */ BOOL *result);
        
        HRESULT ( STDMETHODCALLTYPE *CorSetMaxThreads )( 
            ICorThreadpool * This,
            /* [in] */ DWORD MaxWorkerThreads,
            /* [in] */ DWORD MaxIOCompletionThreads);
        
        HRESULT ( STDMETHODCALLTYPE *CorGetMaxThreads )( 
            ICorThreadpool * This,
            /* [out] */ DWORD *MaxWorkerThreads,
            /* [out] */ DWORD *MaxIOCompletionThreads);
        
        HRESULT ( STDMETHODCALLTYPE *CorGetAvailableThreads )( 
            ICorThreadpool * This,
            /* [out] */ DWORD *AvailableWorkerThreads,
            /* [out] */ DWORD *AvailableIOCompletionThreads);
        
        END_INTERFACE
    } ICorThreadpoolVtbl;

    interface ICorThreadpool
    {
        CONST_VTBL struct ICorThreadpoolVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorThreadpool_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorThreadpool_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorThreadpool_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorThreadpool_CorRegisterWaitForSingleObject(This,phNewWaitObject,hWaitObject,Callback,Context,timeout,executeOnlyOnce,result)	\
    (This)->lpVtbl -> CorRegisterWaitForSingleObject(This,phNewWaitObject,hWaitObject,Callback,Context,timeout,executeOnlyOnce,result)

#define ICorThreadpool_CorUnregisterWait(This,hWaitObject,CompletionEvent,result)	\
    (This)->lpVtbl -> CorUnregisterWait(This,hWaitObject,CompletionEvent,result)

#define ICorThreadpool_CorQueueUserWorkItem(This,Function,Context,executeOnlyOnce,result)	\
    (This)->lpVtbl -> CorQueueUserWorkItem(This,Function,Context,executeOnlyOnce,result)

#define ICorThreadpool_CorCreateTimer(This,phNewTimer,Callback,Parameter,DueTime,Period,result)	\
    (This)->lpVtbl -> CorCreateTimer(This,phNewTimer,Callback,Parameter,DueTime,Period,result)

#define ICorThreadpool_CorChangeTimer(This,Timer,DueTime,Period,result)	\
    (This)->lpVtbl -> CorChangeTimer(This,Timer,DueTime,Period,result)

#define ICorThreadpool_CorDeleteTimer(This,Timer,CompletionEvent,result)	\
    (This)->lpVtbl -> CorDeleteTimer(This,Timer,CompletionEvent,result)

#define ICorThreadpool_CorBindIoCompletionCallback(This,fileHandle,callback)	\
    (This)->lpVtbl -> CorBindIoCompletionCallback(This,fileHandle,callback)

#define ICorThreadpool_CorCallOrQueueUserWorkItem(This,Function,Context,result)	\
    (This)->lpVtbl -> CorCallOrQueueUserWorkItem(This,Function,Context,result)

#define ICorThreadpool_CorSetMaxThreads(This,MaxWorkerThreads,MaxIOCompletionThreads)	\
    (This)->lpVtbl -> CorSetMaxThreads(This,MaxWorkerThreads,MaxIOCompletionThreads)

#define ICorThreadpool_CorGetMaxThreads(This,MaxWorkerThreads,MaxIOCompletionThreads)	\
    (This)->lpVtbl -> CorGetMaxThreads(This,MaxWorkerThreads,MaxIOCompletionThreads)

#define ICorThreadpool_CorGetAvailableThreads(This,AvailableWorkerThreads,AvailableIOCompletionThreads)	\
    (This)->lpVtbl -> CorGetAvailableThreads(This,AvailableWorkerThreads,AvailableIOCompletionThreads)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorThreadpool_CorRegisterWaitForSingleObject_Proxy( 
    ICorThreadpool * This,
    /* [in] */ HANDLE *phNewWaitObject,
    /* [in] */ HANDLE hWaitObject,
    /* [in] */ WAITORTIMERCALLBACK Callback,
    /* [in] */ PVOID Context,
    /* [in] */ ULONG timeout,
    /* [in] */ BOOL executeOnlyOnce,
    /* [out] */ BOOL *result);


void __RPC_STUB ICorThreadpool_CorRegisterWaitForSingleObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorThreadpool_CorUnregisterWait_Proxy( 
    ICorThreadpool * This,
    /* [in] */ HANDLE hWaitObject,
    /* [in] */ HANDLE CompletionEvent,
    /* [out] */ BOOL *result);


void __RPC_STUB ICorThreadpool_CorUnregisterWait_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorThreadpool_CorQueueUserWorkItem_Proxy( 
    ICorThreadpool * This,
    /* [in] */ LPTHREAD_START_ROUTINE Function,
    /* [in] */ PVOID Context,
    /* [in] */ BOOL executeOnlyOnce,
    /* [out] */ BOOL *result);


void __RPC_STUB ICorThreadpool_CorQueueUserWorkItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorThreadpool_CorCreateTimer_Proxy( 
    ICorThreadpool * This,
    /* [in] */ HANDLE *phNewTimer,
    /* [in] */ WAITORTIMERCALLBACK Callback,
    /* [in] */ PVOID Parameter,
    /* [in] */ DWORD DueTime,
    /* [in] */ DWORD Period,
    /* [out] */ BOOL *result);


void __RPC_STUB ICorThreadpool_CorCreateTimer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorThreadpool_CorChangeTimer_Proxy( 
    ICorThreadpool * This,
    /* [in] */ HANDLE Timer,
    /* [in] */ ULONG DueTime,
    /* [in] */ ULONG Period,
    /* [out] */ BOOL *result);


void __RPC_STUB ICorThreadpool_CorChangeTimer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorThreadpool_CorDeleteTimer_Proxy( 
    ICorThreadpool * This,
    /* [in] */ HANDLE Timer,
    /* [in] */ HANDLE CompletionEvent,
    /* [out] */ BOOL *result);


void __RPC_STUB ICorThreadpool_CorDeleteTimer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorThreadpool_CorBindIoCompletionCallback_Proxy( 
    ICorThreadpool * This,
    /* [in] */ HANDLE fileHandle,
    /* [in] */ LPOVERLAPPED_COMPLETION_ROUTINE callback);


void __RPC_STUB ICorThreadpool_CorBindIoCompletionCallback_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorThreadpool_CorCallOrQueueUserWorkItem_Proxy( 
    ICorThreadpool * This,
    /* [in] */ LPTHREAD_START_ROUTINE Function,
    /* [in] */ PVOID Context,
    /* [out] */ BOOL *result);


void __RPC_STUB ICorThreadpool_CorCallOrQueueUserWorkItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorThreadpool_CorSetMaxThreads_Proxy( 
    ICorThreadpool * This,
    /* [in] */ DWORD MaxWorkerThreads,
    /* [in] */ DWORD MaxIOCompletionThreads);


void __RPC_STUB ICorThreadpool_CorSetMaxThreads_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorThreadpool_CorGetMaxThreads_Proxy( 
    ICorThreadpool * This,
    /* [out] */ DWORD *MaxWorkerThreads,
    /* [out] */ DWORD *MaxIOCompletionThreads);


void __RPC_STUB ICorThreadpool_CorGetMaxThreads_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorThreadpool_CorGetAvailableThreads_Proxy( 
    ICorThreadpool * This,
    /* [out] */ DWORD *AvailableWorkerThreads,
    /* [out] */ DWORD *AvailableIOCompletionThreads);


void __RPC_STUB ICorThreadpool_CorGetAvailableThreads_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorThreadpool_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mscoree_0123 */
/* [local] */ 

extern const GUID __declspec(selectany) IID_IDebuggerThreadControl = { 0x23d86786, 0x0bb5, 0x4774, { 0x8f, 0xb5, 0xe3, 0x52, 0x2a, 0xdd, 0x62, 0x46 } };


extern RPC_IF_HANDLE __MIDL_itf_mscoree_0123_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mscoree_0123_v0_0_s_ifspec;

#ifndef __IDebuggerThreadControl_INTERFACE_DEFINED__
#define __IDebuggerThreadControl_INTERFACE_DEFINED__

/* interface IDebuggerThreadControl */
/* [object][local][unique][helpstring][version][uuid] */ 


EXTERN_C const IID IID_IDebuggerThreadControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("23D86786-0BB5-4774-8FB5-E3522ADD6246")
    IDebuggerThreadControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ThreadIsBlockingForDebugger( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseAllRuntimeThreads( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StartBlockingForDebugger( 
            DWORD dwUnused) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebuggerThreadControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebuggerThreadControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebuggerThreadControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebuggerThreadControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *ThreadIsBlockingForDebugger )( 
            IDebuggerThreadControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *ReleaseAllRuntimeThreads )( 
            IDebuggerThreadControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *StartBlockingForDebugger )( 
            IDebuggerThreadControl * This,
            DWORD dwUnused);
        
        END_INTERFACE
    } IDebuggerThreadControlVtbl;

    interface IDebuggerThreadControl
    {
        CONST_VTBL struct IDebuggerThreadControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebuggerThreadControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebuggerThreadControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebuggerThreadControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebuggerThreadControl_ThreadIsBlockingForDebugger(This)	\
    (This)->lpVtbl -> ThreadIsBlockingForDebugger(This)

#define IDebuggerThreadControl_ReleaseAllRuntimeThreads(This)	\
    (This)->lpVtbl -> ReleaseAllRuntimeThreads(This)

#define IDebuggerThreadControl_StartBlockingForDebugger(This,dwUnused)	\
    (This)->lpVtbl -> StartBlockingForDebugger(This,dwUnused)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebuggerThreadControl_ThreadIsBlockingForDebugger_Proxy( 
    IDebuggerThreadControl * This);


void __RPC_STUB IDebuggerThreadControl_ThreadIsBlockingForDebugger_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebuggerThreadControl_ReleaseAllRuntimeThreads_Proxy( 
    IDebuggerThreadControl * This);


void __RPC_STUB IDebuggerThreadControl_ReleaseAllRuntimeThreads_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebuggerThreadControl_StartBlockingForDebugger_Proxy( 
    IDebuggerThreadControl * This,
    DWORD dwUnused);


void __RPC_STUB IDebuggerThreadControl_StartBlockingForDebugger_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebuggerThreadControl_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mscoree_0124 */
/* [local] */ 

extern const GUID __declspec(selectany) IID_IDebuggerInfo = { 0xbf24142d, 0xa47d, 0x4d24, { 0xa6, 0x6d, 0x8c, 0x21, 0x41, 0x94, 0x4e, 0x44 }};


extern RPC_IF_HANDLE __MIDL_itf_mscoree_0124_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mscoree_0124_v0_0_s_ifspec;

#ifndef __IDebuggerInfo_INTERFACE_DEFINED__
#define __IDebuggerInfo_INTERFACE_DEFINED__

/* interface IDebuggerInfo */
/* [object][local][unique][helpstring][version][uuid] */ 


EXTERN_C const IID IID_IDebuggerInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BF24142D-A47D-4d24-A66D-8C2141944E44")
    IDebuggerInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsDebuggerAttached( 
            /* [out] */ BOOL *pbAttached) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebuggerInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebuggerInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebuggerInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebuggerInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsDebuggerAttached )( 
            IDebuggerInfo * This,
            /* [out] */ BOOL *pbAttached);
        
        END_INTERFACE
    } IDebuggerInfoVtbl;

    interface IDebuggerInfo
    {
        CONST_VTBL struct IDebuggerInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebuggerInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebuggerInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebuggerInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebuggerInfo_IsDebuggerAttached(This,pbAttached)	\
    (This)->lpVtbl -> IsDebuggerAttached(This,pbAttached)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebuggerInfo_IsDebuggerAttached_Proxy( 
    IDebuggerInfo * This,
    /* [out] */ BOOL *pbAttached);


void __RPC_STUB IDebuggerInfo_IsDebuggerAttached_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebuggerInfo_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mscoree_0125 */
/* [local] */ 

extern const GUID    __declspec(selectany) IID_ICorConfiguration = { 0x5c2b07a5, 0x1e98, 0x11d3, { 0x87, 0x2f, 0x00, 0xc0, 0x4f, 0x79, 0xed, 0x0d } };


extern RPC_IF_HANDLE __MIDL_itf_mscoree_0125_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mscoree_0125_v0_0_s_ifspec;

#ifndef __ICorConfiguration_INTERFACE_DEFINED__
#define __ICorConfiguration_INTERFACE_DEFINED__

/* interface ICorConfiguration */
/* [object][local][unique][helpstring][version][uuid] */ 


EXTERN_C const IID IID_ICorConfiguration;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5C2B07A5-1E98-11d3-872F-00C04F79ED0D")
    ICorConfiguration : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetGCThreadControl( 
            /* [in] */ IGCThreadControl *pGCThreadControl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetGCHostControl( 
            /* [in] */ IGCHostControl *pGCHostControl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDebuggerThreadControl( 
            /* [in] */ IDebuggerThreadControl *pDebuggerThreadControl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddDebuggerSpecialThread( 
            /* [in] */ DWORD dwSpecialThreadId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorConfigurationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorConfiguration * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorConfiguration * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorConfiguration * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetGCThreadControl )( 
            ICorConfiguration * This,
            /* [in] */ IGCThreadControl *pGCThreadControl);
        
        HRESULT ( STDMETHODCALLTYPE *SetGCHostControl )( 
            ICorConfiguration * This,
            /* [in] */ IGCHostControl *pGCHostControl);
        
        HRESULT ( STDMETHODCALLTYPE *SetDebuggerThreadControl )( 
            ICorConfiguration * This,
            /* [in] */ IDebuggerThreadControl *pDebuggerThreadControl);
        
        HRESULT ( STDMETHODCALLTYPE *AddDebuggerSpecialThread )( 
            ICorConfiguration * This,
            /* [in] */ DWORD dwSpecialThreadId);
        
        END_INTERFACE
    } ICorConfigurationVtbl;

    interface ICorConfiguration
    {
        CONST_VTBL struct ICorConfigurationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorConfiguration_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorConfiguration_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorConfiguration_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorConfiguration_SetGCThreadControl(This,pGCThreadControl)	\
    (This)->lpVtbl -> SetGCThreadControl(This,pGCThreadControl)

#define ICorConfiguration_SetGCHostControl(This,pGCHostControl)	\
    (This)->lpVtbl -> SetGCHostControl(This,pGCHostControl)

#define ICorConfiguration_SetDebuggerThreadControl(This,pDebuggerThreadControl)	\
    (This)->lpVtbl -> SetDebuggerThreadControl(This,pDebuggerThreadControl)

#define ICorConfiguration_AddDebuggerSpecialThread(This,dwSpecialThreadId)	\
    (This)->lpVtbl -> AddDebuggerSpecialThread(This,dwSpecialThreadId)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorConfiguration_SetGCThreadControl_Proxy( 
    ICorConfiguration * This,
    /* [in] */ IGCThreadControl *pGCThreadControl);


void __RPC_STUB ICorConfiguration_SetGCThreadControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorConfiguration_SetGCHostControl_Proxy( 
    ICorConfiguration * This,
    /* [in] */ IGCHostControl *pGCHostControl);


void __RPC_STUB ICorConfiguration_SetGCHostControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorConfiguration_SetDebuggerThreadControl_Proxy( 
    ICorConfiguration * This,
    /* [in] */ IDebuggerThreadControl *pDebuggerThreadControl);


void __RPC_STUB ICorConfiguration_SetDebuggerThreadControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorConfiguration_AddDebuggerSpecialThread_Proxy( 
    ICorConfiguration * This,
    /* [in] */ DWORD dwSpecialThreadId);


void __RPC_STUB ICorConfiguration_AddDebuggerSpecialThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorConfiguration_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mscoree_0126 */
/* [local] */ 

typedef void *HDOMAINENUM;



extern RPC_IF_HANDLE __MIDL_itf_mscoree_0126_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mscoree_0126_v0_0_s_ifspec;

#ifndef __ICorRuntimeHost_INTERFACE_DEFINED__
#define __ICorRuntimeHost_INTERFACE_DEFINED__

/* interface ICorRuntimeHost */
/* [object][local][unique][helpstring][version][uuid] */ 


EXTERN_C const IID IID_ICorRuntimeHost;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CB2F6722-AB3A-11d2-9C40-00C04FA30A3E")
    ICorRuntimeHost : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateLogicalThreadState( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteLogicalThreadState( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SwitchInLogicalThreadState( 
            /* [in] */ DWORD *pFiberCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SwitchOutLogicalThreadState( 
            /* [out] */ DWORD **pFiberCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LocksHeldByLogicalThread( 
            /* [out] */ DWORD *pCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MapFile( 
            /* [in] */ HANDLE hFile,
            /* [out] */ HMODULE *hMapAddress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConfiguration( 
            /* [out] */ ICorConfiguration **pConfiguration) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Start( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateDomain( 
            /* [in] */ LPCWSTR pwzFriendlyName,
            /* [in] */ IUnknown *pIdentityArray,
            /* [out] */ IUnknown **pAppDomain) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultDomain( 
            /* [out] */ IUnknown **pAppDomain) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumDomains( 
            /* [out] */ HDOMAINENUM *hEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NextDomain( 
            /* [in] */ HDOMAINENUM hEnum,
            /* [out] */ IUnknown **pAppDomain) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CloseEnum( 
            /* [in] */ HDOMAINENUM hEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateDomainEx( 
            /* [in] */ LPCWSTR pwzFriendlyName,
            /* [in] */ IUnknown *pSetup,
            /* [in] */ IUnknown *pEvidence,
            /* [out] */ IUnknown **pAppDomain) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateDomainSetup( 
            /* [out] */ IUnknown **pAppDomainSetup) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateEvidence( 
            /* [out] */ IUnknown **pEvidence) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnloadDomain( 
            /* [in] */ IUnknown *pAppDomain) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CurrentDomain( 
            /* [out] */ IUnknown **pAppDomain) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorRuntimeHostVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorRuntimeHost * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorRuntimeHost * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorRuntimeHost * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateLogicalThreadState )( 
            ICorRuntimeHost * This);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteLogicalThreadState )( 
            ICorRuntimeHost * This);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchInLogicalThreadState )( 
            ICorRuntimeHost * This,
            /* [in] */ DWORD *pFiberCookie);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchOutLogicalThreadState )( 
            ICorRuntimeHost * This,
            /* [out] */ DWORD **pFiberCookie);
        
        HRESULT ( STDMETHODCALLTYPE *LocksHeldByLogicalThread )( 
            ICorRuntimeHost * This,
            /* [out] */ DWORD *pCount);
        
        HRESULT ( STDMETHODCALLTYPE *MapFile )( 
            ICorRuntimeHost * This,
            /* [in] */ HANDLE hFile,
            /* [out] */ HMODULE *hMapAddress);
        
        HRESULT ( STDMETHODCALLTYPE *GetConfiguration )( 
            ICorRuntimeHost * This,
            /* [out] */ ICorConfiguration **pConfiguration);
        
        HRESULT ( STDMETHODCALLTYPE *Start )( 
            ICorRuntimeHost * This);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            ICorRuntimeHost * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateDomain )( 
            ICorRuntimeHost * This,
            /* [in] */ LPCWSTR pwzFriendlyName,
            /* [in] */ IUnknown *pIdentityArray,
            /* [out] */ IUnknown **pAppDomain);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultDomain )( 
            ICorRuntimeHost * This,
            /* [out] */ IUnknown **pAppDomain);
        
        HRESULT ( STDMETHODCALLTYPE *EnumDomains )( 
            ICorRuntimeHost * This,
            /* [out] */ HDOMAINENUM *hEnum);
        
        HRESULT ( STDMETHODCALLTYPE *NextDomain )( 
            ICorRuntimeHost * This,
            /* [in] */ HDOMAINENUM hEnum,
            /* [out] */ IUnknown **pAppDomain);
        
        HRESULT ( STDMETHODCALLTYPE *CloseEnum )( 
            ICorRuntimeHost * This,
            /* [in] */ HDOMAINENUM hEnum);
        
        HRESULT ( STDMETHODCALLTYPE *CreateDomainEx )( 
            ICorRuntimeHost * This,
            /* [in] */ LPCWSTR pwzFriendlyName,
            /* [in] */ IUnknown *pSetup,
            /* [in] */ IUnknown *pEvidence,
            /* [out] */ IUnknown **pAppDomain);
        
        HRESULT ( STDMETHODCALLTYPE *CreateDomainSetup )( 
            ICorRuntimeHost * This,
            /* [out] */ IUnknown **pAppDomainSetup);
        
        HRESULT ( STDMETHODCALLTYPE *CreateEvidence )( 
            ICorRuntimeHost * This,
            /* [out] */ IUnknown **pEvidence);
        
        HRESULT ( STDMETHODCALLTYPE *UnloadDomain )( 
            ICorRuntimeHost * This,
            /* [in] */ IUnknown *pAppDomain);
        
        HRESULT ( STDMETHODCALLTYPE *CurrentDomain )( 
            ICorRuntimeHost * This,
            /* [out] */ IUnknown **pAppDomain);
        
        END_INTERFACE
    } ICorRuntimeHostVtbl;

    interface ICorRuntimeHost
    {
        CONST_VTBL struct ICorRuntimeHostVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorRuntimeHost_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorRuntimeHost_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorRuntimeHost_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorRuntimeHost_CreateLogicalThreadState(This)	\
    (This)->lpVtbl -> CreateLogicalThreadState(This)

#define ICorRuntimeHost_DeleteLogicalThreadState(This)	\
    (This)->lpVtbl -> DeleteLogicalThreadState(This)

#define ICorRuntimeHost_SwitchInLogicalThreadState(This,pFiberCookie)	\
    (This)->lpVtbl -> SwitchInLogicalThreadState(This,pFiberCookie)

#define ICorRuntimeHost_SwitchOutLogicalThreadState(This,pFiberCookie)	\
    (This)->lpVtbl -> SwitchOutLogicalThreadState(This,pFiberCookie)

#define ICorRuntimeHost_LocksHeldByLogicalThread(This,pCount)	\
    (This)->lpVtbl -> LocksHeldByLogicalThread(This,pCount)

#define ICorRuntimeHost_MapFile(This,hFile,hMapAddress)	\
    (This)->lpVtbl -> MapFile(This,hFile,hMapAddress)

#define ICorRuntimeHost_GetConfiguration(This,pConfiguration)	\
    (This)->lpVtbl -> GetConfiguration(This,pConfiguration)

#define ICorRuntimeHost_Start(This)	\
    (This)->lpVtbl -> Start(This)

#define ICorRuntimeHost_Stop(This)	\
    (This)->lpVtbl -> Stop(This)

#define ICorRuntimeHost_CreateDomain(This,pwzFriendlyName,pIdentityArray,pAppDomain)	\
    (This)->lpVtbl -> CreateDomain(This,pwzFriendlyName,pIdentityArray,pAppDomain)

#define ICorRuntimeHost_GetDefaultDomain(This,pAppDomain)	\
    (This)->lpVtbl -> GetDefaultDomain(This,pAppDomain)

#define ICorRuntimeHost_EnumDomains(This,hEnum)	\
    (This)->lpVtbl -> EnumDomains(This,hEnum)

#define ICorRuntimeHost_NextDomain(This,hEnum,pAppDomain)	\
    (This)->lpVtbl -> NextDomain(This,hEnum,pAppDomain)

#define ICorRuntimeHost_CloseEnum(This,hEnum)	\
    (This)->lpVtbl -> CloseEnum(This,hEnum)

#define ICorRuntimeHost_CreateDomainEx(This,pwzFriendlyName,pSetup,pEvidence,pAppDomain)	\
    (This)->lpVtbl -> CreateDomainEx(This,pwzFriendlyName,pSetup,pEvidence,pAppDomain)

#define ICorRuntimeHost_CreateDomainSetup(This,pAppDomainSetup)	\
    (This)->lpVtbl -> CreateDomainSetup(This,pAppDomainSetup)

#define ICorRuntimeHost_CreateEvidence(This,pEvidence)	\
    (This)->lpVtbl -> CreateEvidence(This,pEvidence)

#define ICorRuntimeHost_UnloadDomain(This,pAppDomain)	\
    (This)->lpVtbl -> UnloadDomain(This,pAppDomain)

#define ICorRuntimeHost_CurrentDomain(This,pAppDomain)	\
    (This)->lpVtbl -> CurrentDomain(This,pAppDomain)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorRuntimeHost_CreateLogicalThreadState_Proxy( 
    ICorRuntimeHost * This);


void __RPC_STUB ICorRuntimeHost_CreateLogicalThreadState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorRuntimeHost_DeleteLogicalThreadState_Proxy( 
    ICorRuntimeHost * This);


void __RPC_STUB ICorRuntimeHost_DeleteLogicalThreadState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorRuntimeHost_SwitchInLogicalThreadState_Proxy( 
    ICorRuntimeHost * This,
    /* [in] */ DWORD *pFiberCookie);


void __RPC_STUB ICorRuntimeHost_SwitchInLogicalThreadState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorRuntimeHost_SwitchOutLogicalThreadState_Proxy( 
    ICorRuntimeHost * This,
    /* [out] */ DWORD **pFiberCookie);


void __RPC_STUB ICorRuntimeHost_SwitchOutLogicalThreadState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorRuntimeHost_LocksHeldByLogicalThread_Proxy( 
    ICorRuntimeHost * This,
    /* [out] */ DWORD *pCount);


void __RPC_STUB ICorRuntimeHost_LocksHeldByLogicalThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorRuntimeHost_MapFile_Proxy( 
    ICorRuntimeHost * This,
    /* [in] */ HANDLE hFile,
    /* [out] */ HMODULE *hMapAddress);


void __RPC_STUB ICorRuntimeHost_MapFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorRuntimeHost_GetConfiguration_Proxy( 
    ICorRuntimeHost * This,
    /* [out] */ ICorConfiguration **pConfiguration);


void __RPC_STUB ICorRuntimeHost_GetConfiguration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorRuntimeHost_Start_Proxy( 
    ICorRuntimeHost * This);


void __RPC_STUB ICorRuntimeHost_Start_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorRuntimeHost_Stop_Proxy( 
    ICorRuntimeHost * This);


void __RPC_STUB ICorRuntimeHost_Stop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorRuntimeHost_CreateDomain_Proxy( 
    ICorRuntimeHost * This,
    /* [in] */ LPCWSTR pwzFriendlyName,
    /* [in] */ IUnknown *pIdentityArray,
    /* [out] */ IUnknown **pAppDomain);


void __RPC_STUB ICorRuntimeHost_CreateDomain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorRuntimeHost_GetDefaultDomain_Proxy( 
    ICorRuntimeHost * This,
    /* [out] */ IUnknown **pAppDomain);


void __RPC_STUB ICorRuntimeHost_GetDefaultDomain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorRuntimeHost_EnumDomains_Proxy( 
    ICorRuntimeHost * This,
    /* [out] */ HDOMAINENUM *hEnum);


void __RPC_STUB ICorRuntimeHost_EnumDomains_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorRuntimeHost_NextDomain_Proxy( 
    ICorRuntimeHost * This,
    /* [in] */ HDOMAINENUM hEnum,
    /* [out] */ IUnknown **pAppDomain);


void __RPC_STUB ICorRuntimeHost_NextDomain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorRuntimeHost_CloseEnum_Proxy( 
    ICorRuntimeHost * This,
    /* [in] */ HDOMAINENUM hEnum);


void __RPC_STUB ICorRuntimeHost_CloseEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorRuntimeHost_CreateDomainEx_Proxy( 
    ICorRuntimeHost * This,
    /* [in] */ LPCWSTR pwzFriendlyName,
    /* [in] */ IUnknown *pSetup,
    /* [in] */ IUnknown *pEvidence,
    /* [out] */ IUnknown **pAppDomain);


void __RPC_STUB ICorRuntimeHost_CreateDomainEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorRuntimeHost_CreateDomainSetup_Proxy( 
    ICorRuntimeHost * This,
    /* [out] */ IUnknown **pAppDomainSetup);


void __RPC_STUB ICorRuntimeHost_CreateDomainSetup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorRuntimeHost_CreateEvidence_Proxy( 
    ICorRuntimeHost * This,
    /* [out] */ IUnknown **pEvidence);


void __RPC_STUB ICorRuntimeHost_CreateEvidence_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorRuntimeHost_UnloadDomain_Proxy( 
    ICorRuntimeHost * This,
    /* [in] */ IUnknown *pAppDomain);


void __RPC_STUB ICorRuntimeHost_UnloadDomain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorRuntimeHost_CurrentDomain_Proxy( 
    ICorRuntimeHost * This,
    /* [out] */ IUnknown **pAppDomain);


void __RPC_STUB ICorRuntimeHost_CurrentDomain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorRuntimeHost_INTERFACE_DEFINED__ */



#ifndef __mscoree_LIBRARY_DEFINED__
#define __mscoree_LIBRARY_DEFINED__

/* library mscoree */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_mscoree;

#ifndef __IApartmentCallback_INTERFACE_DEFINED__
#define __IApartmentCallback_INTERFACE_DEFINED__

/* interface IApartmentCallback */
/* [unique][helpstring][uuid][oleautomation][object] */ 


EXTERN_C const IID IID_IApartmentCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("178E5337-1528-4591-B1C9-1C6E484686D8")
    IApartmentCallback : public IUnknown
    {
    public:
        virtual HRESULT __stdcall DoCallback( 
            /* [in] */ SIZE_T pFunc,
            /* [in] */ SIZE_T pData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IApartmentCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IApartmentCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IApartmentCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IApartmentCallback * This);
        
        HRESULT ( __stdcall *DoCallback )( 
            IApartmentCallback * This,
            /* [in] */ SIZE_T pFunc,
            /* [in] */ SIZE_T pData);
        
        END_INTERFACE
    } IApartmentCallbackVtbl;

    interface IApartmentCallback
    {
        CONST_VTBL struct IApartmentCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IApartmentCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IApartmentCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IApartmentCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IApartmentCallback_DoCallback(This,pFunc,pData)	\
    (This)->lpVtbl -> DoCallback(This,pFunc,pData)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IApartmentCallback_DoCallback_Proxy( 
    IApartmentCallback * This,
    /* [in] */ SIZE_T pFunc,
    /* [in] */ SIZE_T pData);


void __RPC_STUB IApartmentCallback_DoCallback_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IApartmentCallback_INTERFACE_DEFINED__ */


#ifndef __IManagedObject_INTERFACE_DEFINED__
#define __IManagedObject_INTERFACE_DEFINED__

/* interface IManagedObject */
/* [unique][helpstring][uuid][oleautomation][object] */ 


EXTERN_C const IID IID_IManagedObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C3FCC19E-A970-11d2-8B5A-00A0C9B7C9C4")
    IManagedObject : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSerializedBuffer( 
            /* [out] */ BSTR *pBSTR) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObjectIdentity( 
            /* [out] */ BSTR *pBSTRGUID,
            /* [out] */ int *AppDomainID,
            /* [out] */ int *pCCW) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IManagedObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IManagedObject * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IManagedObject * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IManagedObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSerializedBuffer )( 
            IManagedObject * This,
            /* [out] */ BSTR *pBSTR);
        
        HRESULT ( STDMETHODCALLTYPE *GetObjectIdentity )( 
            IManagedObject * This,
            /* [out] */ BSTR *pBSTRGUID,
            /* [out] */ int *AppDomainID,
            /* [out] */ int *pCCW);
        
        END_INTERFACE
    } IManagedObjectVtbl;

    interface IManagedObject
    {
        CONST_VTBL struct IManagedObjectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IManagedObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IManagedObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IManagedObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IManagedObject_GetSerializedBuffer(This,pBSTR)	\
    (This)->lpVtbl -> GetSerializedBuffer(This,pBSTR)

#define IManagedObject_GetObjectIdentity(This,pBSTRGUID,AppDomainID,pCCW)	\
    (This)->lpVtbl -> GetObjectIdentity(This,pBSTRGUID,AppDomainID,pCCW)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IManagedObject_GetSerializedBuffer_Proxy( 
    IManagedObject * This,
    /* [out] */ BSTR *pBSTR);


void __RPC_STUB IManagedObject_GetSerializedBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IManagedObject_GetObjectIdentity_Proxy( 
    IManagedObject * This,
    /* [out] */ BSTR *pBSTRGUID,
    /* [out] */ int *AppDomainID,
    /* [out] */ int *pCCW);


void __RPC_STUB IManagedObject_GetObjectIdentity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IManagedObject_INTERFACE_DEFINED__ */


#ifndef __ICatalogServices_INTERFACE_DEFINED__
#define __ICatalogServices_INTERFACE_DEFINED__

/* interface ICatalogServices */
/* [unique][helpstring][uuid][oleautomation][object] */ 


EXTERN_C const IID IID_ICatalogServices;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("04C6BE1E-1DB1-4058-AB7A-700CCCFBF254")
    ICatalogServices : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Autodone( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotAutodone( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICatalogServicesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICatalogServices * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICatalogServices * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICatalogServices * This);
        
        HRESULT ( STDMETHODCALLTYPE *Autodone )( 
            ICatalogServices * This);
        
        HRESULT ( STDMETHODCALLTYPE *NotAutodone )( 
            ICatalogServices * This);
        
        END_INTERFACE
    } ICatalogServicesVtbl;

    interface ICatalogServices
    {
        CONST_VTBL struct ICatalogServicesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICatalogServices_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICatalogServices_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICatalogServices_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICatalogServices_Autodone(This)	\
    (This)->lpVtbl -> Autodone(This)

#define ICatalogServices_NotAutodone(This)	\
    (This)->lpVtbl -> NotAutodone(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICatalogServices_Autodone_Proxy( 
    ICatalogServices * This);


void __RPC_STUB ICatalogServices_Autodone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICatalogServices_NotAutodone_Proxy( 
    ICatalogServices * This);


void __RPC_STUB ICatalogServices_NotAutodone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICatalogServices_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_ComCallUnmarshal;

#ifdef __cplusplus

class DECLSPEC_UUID("3F281000-E95A-11d2-886B-00C04F869F04")
ComCallUnmarshal;
#endif

EXTERN_C const CLSID CLSID_CorRuntimeHost;

#ifdef __cplusplus

class DECLSPEC_UUID("CB2F6723-AB3A-11d2-9C40-00C04FA30A3E")
CorRuntimeHost;
#endif
#endif /* __mscoree_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\mscorcfg.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************
 **                                                                         **
 ** Cor.h - general header for the Runtime.                                 **
 **                                                                         **
 *****************************************************************************/


#ifndef _MSCORCFG_H_
#define _MSCORCFG_H_
#include <ole2.h>                       // Definitions of OLE types.    
#include <xmlparser.h>

#ifdef __cplusplus
extern "C" {
#endif

// -----------------------------------------------------------------------
// Retruns an XMLParsr object. This can be used to parse any XML file.
STDAPI GetXMLElementAttribute(LPCWSTR pwszAttributeName, LPWSTR pbuffer, DWORD cchBuffer, DWORD* dwLen);
STDAPI GetXMLElement(LPCWSTR wszFileName, LPCWSTR pwszTag);

STDAPI GetXMLObject(IXMLParser **ppv);
STDAPI CreateConfigStream(LPCWSTR pszFileName, IStream** ppStream);

// -----------------------------------------------------------------------
// To reuse parsed configuration files a in memory representation can be
// stored. Elements are accessed using the same mechanism used by the 
// XML parser. A Node Factory is used to obtain call backs.

// {4F7429C2-7848-468d-B602-0B49AA95B359}
extern const GUID DECLSPEC_SELECT_ANY IID_IClrElement = 
{ 0x4f7429c2, 0x7848, 0x468d, { 0xb6, 0x2, 0xb, 0x49, 0xaa, 0x95, 0xb3, 0x59 } };

#undef  INTERFACE   
#define INTERFACE IClrElement
DECLARE_INTERFACE_(IClrElement, IUnknown)
{
};

STDAPI OpenXMLConfig(LPCWSTR pwszFileName, IClrElement **ppv);
STDAPI GetXMLFindElement(IClrElement* pElement, LPCWSTR pwszElement, IClrElement** ppChild);
STDAPI GetXMLParseElement(IXMLNodeFactory* pNode, IClrElement *pElement);
STDAPI GetXMLGetValue(IClrElement *pElement, LPCWSTR* ppv);

#ifdef __cplusplus
}
#endif  // __cplusplus

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\mscormmc_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Thu Feb 20 18:27:18 2003
 */
/* Compiler settings for mscormmc.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_SnapinAboutLib,0x0e2e2bfc,0x6d07,0x4970,0xa6,0x5b,0xc1,0xbc,0xfb,0xa3,0xa4,0xe5);


MIDL_DEFINE_GUID(IID, IID_ISnapinAbout,0x1245208C,0xA151,0x11D0,0xA7,0xD7,0x00,0xC0,0x4F,0xD9,0x09,0xDD);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\mscormmc.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Thu Feb 20 18:27:18 2003
 */
/* Compiler settings for mscormmc.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __mscormmc_h__
#define __mscormmc_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ISnapinAbout_FWD_DEFINED__
#define __ISnapinAbout_FWD_DEFINED__
typedef interface ISnapinAbout ISnapinAbout;
#endif 	/* __ISnapinAbout_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_mscormmc_0000 */
/* [local] */ 




extern RPC_IF_HANDLE __MIDL_itf_mscormmc_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mscormmc_0000_v0_0_s_ifspec;


#ifndef __SnapinAboutLib_LIBRARY_DEFINED__
#define __SnapinAboutLib_LIBRARY_DEFINED__

/* library SnapinAboutLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_SnapinAboutLib;
#endif /* __SnapinAboutLib_LIBRARY_DEFINED__ */

#ifndef __ISnapinAbout_INTERFACE_DEFINED__
#define __ISnapinAbout_INTERFACE_DEFINED__

/* interface ISnapinAbout */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISnapinAbout;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1245208C-A151-11D0-A7D7-00C04FD909DD")
    ISnapinAbout : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSnapinDescription( 
            /* [out] */ LPOLESTR *lpDescription) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProvider( 
            /* [out] */ LPOLESTR *lpName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSnapinVersion( 
            /* [out] */ LPOLESTR *lpVersion) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSnapinImage( 
            /* [out] */ HICON *hAppIcon) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetStaticFolderImage( 
            /* [out] */ HBITMAP *hSmallImage,
            /* [out] */ HBITMAP *hSmallImageOpen,
            /* [out] */ HBITMAP *hLargeImage,
            /* [out] */ COLORREF *cMask) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISnapinAboutVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISnapinAbout * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISnapinAbout * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISnapinAbout * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSnapinDescription )( 
            ISnapinAbout * This,
            /* [out] */ LPOLESTR *lpDescription);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProvider )( 
            ISnapinAbout * This,
            /* [out] */ LPOLESTR *lpName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSnapinVersion )( 
            ISnapinAbout * This,
            /* [out] */ LPOLESTR *lpVersion);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSnapinImage )( 
            ISnapinAbout * This,
            /* [out] */ HICON *hAppIcon);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetStaticFolderImage )( 
            ISnapinAbout * This,
            /* [out] */ HBITMAP *hSmallImage,
            /* [out] */ HBITMAP *hSmallImageOpen,
            /* [out] */ HBITMAP *hLargeImage,
            /* [out] */ COLORREF *cMask);
        
        END_INTERFACE
    } ISnapinAboutVtbl;

    interface ISnapinAbout
    {
        CONST_VTBL struct ISnapinAboutVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISnapinAbout_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISnapinAbout_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISnapinAbout_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISnapinAbout_GetSnapinDescription(This,lpDescription)	\
    (This)->lpVtbl -> GetSnapinDescription(This,lpDescription)

#define ISnapinAbout_GetProvider(This,lpName)	\
    (This)->lpVtbl -> GetProvider(This,lpName)

#define ISnapinAbout_GetSnapinVersion(This,lpVersion)	\
    (This)->lpVtbl -> GetSnapinVersion(This,lpVersion)

#define ISnapinAbout_GetSnapinImage(This,hAppIcon)	\
    (This)->lpVtbl -> GetSnapinImage(This,hAppIcon)

#define ISnapinAbout_GetStaticFolderImage(This,hSmallImage,hSmallImageOpen,hLargeImage,cMask)	\
    (This)->lpVtbl -> GetStaticFolderImage(This,hSmallImage,hSmallImageOpen,hLargeImage,cMask)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISnapinAbout_GetSnapinDescription_Proxy( 
    ISnapinAbout * This,
    /* [out] */ LPOLESTR *lpDescription);


void __RPC_STUB ISnapinAbout_GetSnapinDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISnapinAbout_GetProvider_Proxy( 
    ISnapinAbout * This,
    /* [out] */ LPOLESTR *lpName);


void __RPC_STUB ISnapinAbout_GetProvider_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISnapinAbout_GetSnapinVersion_Proxy( 
    ISnapinAbout * This,
    /* [out] */ LPOLESTR *lpVersion);


void __RPC_STUB ISnapinAbout_GetSnapinVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISnapinAbout_GetSnapinImage_Proxy( 
    ISnapinAbout * This,
    /* [out] */ HICON *hAppIcon);


void __RPC_STUB ISnapinAbout_GetSnapinImage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISnapinAbout_GetStaticFolderImage_Proxy( 
    ISnapinAbout * This,
    /* [out] */ HBITMAP *hSmallImage,
    /* [out] */ HBITMAP *hSmallImageOpen,
    /* [out] */ HBITMAP *hLargeImage,
    /* [out] */ COLORREF *cMask);


void __RPC_STUB ISnapinAbout_GetStaticFolderImage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISnapinAbout_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  HBITMAP_UserSize(     unsigned long *, unsigned long            , HBITMAP * ); 
unsigned char * __RPC_USER  HBITMAP_UserMarshal(  unsigned long *, unsigned char *, HBITMAP * ); 
unsigned char * __RPC_USER  HBITMAP_UserUnmarshal(unsigned long *, unsigned char *, HBITMAP * ); 
void                      __RPC_USER  HBITMAP_UserFree(     unsigned long *, HBITMAP * ); 

unsigned long             __RPC_USER  HICON_UserSize(     unsigned long *, unsigned long            , HICON * ); 
unsigned char * __RPC_USER  HICON_UserMarshal(  unsigned long *, unsigned char *, HICON * ); 
unsigned char * __RPC_USER  HICON_UserUnmarshal(unsigned long *, unsigned char *, HICON * ); 
void                      __RPC_USER  HICON_UserFree(     unsigned long *, HICON * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\mscoree_p.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Thu Feb 20 18:27:05 2003
 */
/* Compiler settings for mscoree.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)
#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 440
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "mscoree.h"

#define TYPE_FORMAT_STRING_SIZE   1165                              
#define PROC_FORMAT_STRING_SIZE   29                                
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   1            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IObjectHandle_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IObjectHandle_ProxyInfo;


extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ];

#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT40_OR_LATER)
#error You need a Windows NT 4.0 or later to run this stub because it uses these features:
#error   -Oif or -Oicf, [wire_marshal] or [user_marshal] attribute.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure Unwrap */

			0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x3 ),	/* 3 */
/*  8 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 10 */	NdrFcShort( 0x0 ),	/* 0 */
/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
/* 14 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppv */

/* 16 */	NdrFcShort( 0x4113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=16 */
/* 18 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 20 */	NdrFcShort( 0x482 ),	/* Type Offset=1154 */

	/* Return value */

/* 22 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 24 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 26 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/*  4 */	NdrFcShort( 0x47e ),	/* Offset= 1150 (1154) */
/*  6 */	
			0x13, 0x0,	/* FC_OP */
/*  8 */	NdrFcShort( 0x466 ),	/* Offset= 1126 (1134) */
/* 10 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x9,		/* FC_ULONG */
/* 12 */	0x7,		/* Corr desc: FC_USHORT */
			0x0,		/*  */
/* 14 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 16 */	NdrFcShort( 0x2 ),	/* Offset= 2 (18) */
/* 18 */	NdrFcShort( 0x10 ),	/* 16 */
/* 20 */	NdrFcShort( 0x2f ),	/* 47 */
/* 22 */	NdrFcLong( 0x14 ),	/* 20 */
/* 26 */	NdrFcShort( 0x800b ),	/* Simple arm type: FC_HYPER */
/* 28 */	NdrFcLong( 0x3 ),	/* 3 */
/* 32 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 34 */	NdrFcLong( 0x11 ),	/* 17 */
/* 38 */	NdrFcShort( 0x8001 ),	/* Simple arm type: FC_BYTE */
/* 40 */	NdrFcLong( 0x2 ),	/* 2 */
/* 44 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 46 */	NdrFcLong( 0x4 ),	/* 4 */
/* 50 */	NdrFcShort( 0x800a ),	/* Simple arm type: FC_FLOAT */
/* 52 */	NdrFcLong( 0x5 ),	/* 5 */
/* 56 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 58 */	NdrFcLong( 0xb ),	/* 11 */
/* 62 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 64 */	NdrFcLong( 0xa ),	/* 10 */
/* 68 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 70 */	NdrFcLong( 0x6 ),	/* 6 */
/* 74 */	NdrFcShort( 0xe8 ),	/* Offset= 232 (306) */
/* 76 */	NdrFcLong( 0x7 ),	/* 7 */
/* 80 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 82 */	NdrFcLong( 0x8 ),	/* 8 */
/* 86 */	NdrFcShort( 0xe2 ),	/* Offset= 226 (312) */
/* 88 */	NdrFcLong( 0xd ),	/* 13 */
/* 92 */	NdrFcShort( 0xf4 ),	/* Offset= 244 (336) */
/* 94 */	NdrFcLong( 0x9 ),	/* 9 */
/* 98 */	NdrFcShort( 0x100 ),	/* Offset= 256 (354) */
/* 100 */	NdrFcLong( 0x2000 ),	/* 8192 */
/* 104 */	NdrFcShort( 0x10c ),	/* Offset= 268 (372) */
/* 106 */	NdrFcLong( 0x24 ),	/* 36 */
/* 110 */	NdrFcShort( 0x366 ),	/* Offset= 870 (980) */
/* 112 */	NdrFcLong( 0x4024 ),	/* 16420 */
/* 116 */	NdrFcShort( 0x360 ),	/* Offset= 864 (980) */
/* 118 */	NdrFcLong( 0x4011 ),	/* 16401 */
/* 122 */	NdrFcShort( 0x35e ),	/* Offset= 862 (984) */
/* 124 */	NdrFcLong( 0x4002 ),	/* 16386 */
/* 128 */	NdrFcShort( 0x35c ),	/* Offset= 860 (988) */
/* 130 */	NdrFcLong( 0x4003 ),	/* 16387 */
/* 134 */	NdrFcShort( 0x35a ),	/* Offset= 858 (992) */
/* 136 */	NdrFcLong( 0x4014 ),	/* 16404 */
/* 140 */	NdrFcShort( 0x358 ),	/* Offset= 856 (996) */
/* 142 */	NdrFcLong( 0x4004 ),	/* 16388 */
/* 146 */	NdrFcShort( 0x356 ),	/* Offset= 854 (1000) */
/* 148 */	NdrFcLong( 0x4005 ),	/* 16389 */
/* 152 */	NdrFcShort( 0x354 ),	/* Offset= 852 (1004) */
/* 154 */	NdrFcLong( 0x400b ),	/* 16395 */
/* 158 */	NdrFcShort( 0x352 ),	/* Offset= 850 (1008) */
/* 160 */	NdrFcLong( 0x400a ),	/* 16394 */
/* 164 */	NdrFcShort( 0x350 ),	/* Offset= 848 (1012) */
/* 166 */	NdrFcLong( 0x4006 ),	/* 16390 */
/* 170 */	NdrFcShort( 0x34e ),	/* Offset= 846 (1016) */
/* 172 */	NdrFcLong( 0x4007 ),	/* 16391 */
/* 176 */	NdrFcShort( 0x34c ),	/* Offset= 844 (1020) */
/* 178 */	NdrFcLong( 0x4008 ),	/* 16392 */
/* 182 */	NdrFcShort( 0x34a ),	/* Offset= 842 (1024) */
/* 184 */	NdrFcLong( 0x400d ),	/* 16397 */
/* 188 */	NdrFcShort( 0x34c ),	/* Offset= 844 (1032) */
/* 190 */	NdrFcLong( 0x4009 ),	/* 16393 */
/* 194 */	NdrFcShort( 0x35c ),	/* Offset= 860 (1054) */
/* 196 */	NdrFcLong( 0x6000 ),	/* 24576 */
/* 200 */	NdrFcShort( 0x36c ),	/* Offset= 876 (1076) */
/* 202 */	NdrFcLong( 0x400c ),	/* 16396 */
/* 206 */	NdrFcShort( 0x372 ),	/* Offset= 882 (1088) */
/* 208 */	NdrFcLong( 0x10 ),	/* 16 */
/* 212 */	NdrFcShort( 0x8002 ),	/* Simple arm type: FC_CHAR */
/* 214 */	NdrFcLong( 0x12 ),	/* 18 */
/* 218 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 220 */	NdrFcLong( 0x13 ),	/* 19 */
/* 224 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 226 */	NdrFcLong( 0x15 ),	/* 21 */
/* 230 */	NdrFcShort( 0x800b ),	/* Simple arm type: FC_HYPER */
/* 232 */	NdrFcLong( 0x16 ),	/* 22 */
/* 236 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 238 */	NdrFcLong( 0x17 ),	/* 23 */
/* 242 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 244 */	NdrFcLong( 0xe ),	/* 14 */
/* 248 */	NdrFcShort( 0x350 ),	/* Offset= 848 (1096) */
/* 250 */	NdrFcLong( 0x400e ),	/* 16398 */
/* 254 */	NdrFcShort( 0x354 ),	/* Offset= 852 (1106) */
/* 256 */	NdrFcLong( 0x4010 ),	/* 16400 */
/* 260 */	NdrFcShort( 0x352 ),	/* Offset= 850 (1110) */
/* 262 */	NdrFcLong( 0x4012 ),	/* 16402 */
/* 266 */	NdrFcShort( 0x350 ),	/* Offset= 848 (1114) */
/* 268 */	NdrFcLong( 0x4013 ),	/* 16403 */
/* 272 */	NdrFcShort( 0x34e ),	/* Offset= 846 (1118) */
/* 274 */	NdrFcLong( 0x4015 ),	/* 16405 */
/* 278 */	NdrFcShort( 0x34c ),	/* Offset= 844 (1122) */
/* 280 */	NdrFcLong( 0x4016 ),	/* 16406 */
/* 284 */	NdrFcShort( 0x34a ),	/* Offset= 842 (1126) */
/* 286 */	NdrFcLong( 0x4017 ),	/* 16407 */
/* 290 */	NdrFcShort( 0x348 ),	/* Offset= 840 (1130) */
/* 292 */	NdrFcLong( 0x0 ),	/* 0 */
/* 296 */	NdrFcShort( 0x0 ),	/* Offset= 0 (296) */
/* 298 */	NdrFcLong( 0x1 ),	/* 1 */
/* 302 */	NdrFcShort( 0x0 ),	/* Offset= 0 (302) */
/* 304 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (303) */
/* 306 */	
			0x15,		/* FC_STRUCT */
			0x7,		/* 7 */
/* 308 */	NdrFcShort( 0x8 ),	/* 8 */
/* 310 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 312 */	
			0x13, 0x0,	/* FC_OP */
/* 314 */	NdrFcShort( 0xc ),	/* Offset= 12 (326) */
/* 316 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 318 */	NdrFcShort( 0x2 ),	/* 2 */
/* 320 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 322 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 324 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 326 */	
			0x17,		/* FC_CSTRUCT */
			0x3,		/* 3 */
/* 328 */	NdrFcShort( 0x8 ),	/* 8 */
/* 330 */	NdrFcShort( 0xfffffff2 ),	/* Offset= -14 (316) */
/* 332 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 334 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 336 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 338 */	NdrFcLong( 0x0 ),	/* 0 */
/* 342 */	NdrFcShort( 0x0 ),	/* 0 */
/* 344 */	NdrFcShort( 0x0 ),	/* 0 */
/* 346 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 348 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 350 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 352 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 354 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 356 */	NdrFcLong( 0x20400 ),	/* 132096 */
/* 360 */	NdrFcShort( 0x0 ),	/* 0 */
/* 362 */	NdrFcShort( 0x0 ),	/* 0 */
/* 364 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 366 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 368 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 370 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 372 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 374 */	NdrFcShort( 0x2 ),	/* Offset= 2 (376) */
/* 376 */	
			0x13, 0x0,	/* FC_OP */
/* 378 */	NdrFcShort( 0x248 ),	/* Offset= 584 (962) */
/* 380 */	
			0x2a,		/* FC_ENCAPSULATED_UNION */
			0x49,		/* 73 */
/* 382 */	NdrFcShort( 0x18 ),	/* 24 */
/* 384 */	NdrFcShort( 0xa ),	/* 10 */
/* 386 */	NdrFcLong( 0x8 ),	/* 8 */
/* 390 */	NdrFcShort( 0x58 ),	/* Offset= 88 (478) */
/* 392 */	NdrFcLong( 0xd ),	/* 13 */
/* 396 */	NdrFcShort( 0x8a ),	/* Offset= 138 (534) */
/* 398 */	NdrFcLong( 0x9 ),	/* 9 */
/* 402 */	NdrFcShort( 0xb8 ),	/* Offset= 184 (586) */
/* 404 */	NdrFcLong( 0xc ),	/* 12 */
/* 408 */	NdrFcShort( 0xe0 ),	/* Offset= 224 (632) */
/* 410 */	NdrFcLong( 0x24 ),	/* 36 */
/* 414 */	NdrFcShort( 0x13c ),	/* Offset= 316 (730) */
/* 416 */	NdrFcLong( 0x800d ),	/* 32781 */
/* 420 */	NdrFcShort( 0x17c ),	/* Offset= 380 (800) */
/* 422 */	NdrFcLong( 0x10 ),	/* 16 */
/* 426 */	NdrFcShort( 0x194 ),	/* Offset= 404 (830) */
/* 428 */	NdrFcLong( 0x2 ),	/* 2 */
/* 432 */	NdrFcShort( 0x1ac ),	/* Offset= 428 (860) */
/* 434 */	NdrFcLong( 0x3 ),	/* 3 */
/* 438 */	NdrFcShort( 0x1c4 ),	/* Offset= 452 (890) */
/* 440 */	NdrFcLong( 0x14 ),	/* 20 */
/* 444 */	NdrFcShort( 0x1dc ),	/* Offset= 476 (920) */
/* 446 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (445) */
/* 448 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 450 */	NdrFcShort( 0x4 ),	/* 4 */
/* 452 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 454 */	NdrFcShort( 0x0 ),	/* 0 */
/* 456 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 458 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 460 */	NdrFcShort( 0x4 ),	/* 4 */
/* 462 */	NdrFcShort( 0x0 ),	/* 0 */
/* 464 */	NdrFcShort( 0x1 ),	/* 1 */
/* 466 */	NdrFcShort( 0x0 ),	/* 0 */
/* 468 */	NdrFcShort( 0x0 ),	/* 0 */
/* 470 */	0x13, 0x0,	/* FC_OP */
/* 472 */	NdrFcShort( 0xffffff6e ),	/* Offset= -146 (326) */
/* 474 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 476 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 478 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 480 */	NdrFcShort( 0x8 ),	/* 8 */
/* 482 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 484 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 486 */	NdrFcShort( 0x4 ),	/* 4 */
/* 488 */	NdrFcShort( 0x4 ),	/* 4 */
/* 490 */	0x11, 0x0,	/* FC_RP */
/* 492 */	NdrFcShort( 0xffffffd4 ),	/* Offset= -44 (448) */
/* 494 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 496 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 498 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 500 */	NdrFcLong( 0x0 ),	/* 0 */
/* 504 */	NdrFcShort( 0x0 ),	/* 0 */
/* 506 */	NdrFcShort( 0x0 ),	/* 0 */
/* 508 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 510 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 512 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 514 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 516 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 518 */	NdrFcShort( 0x0 ),	/* 0 */
/* 520 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 522 */	NdrFcShort( 0x0 ),	/* 0 */
/* 524 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 528 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 530 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (498) */
/* 532 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 534 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 536 */	NdrFcShort( 0x8 ),	/* 8 */
/* 538 */	NdrFcShort( 0x0 ),	/* 0 */
/* 540 */	NdrFcShort( 0x6 ),	/* Offset= 6 (546) */
/* 542 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 544 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 546 */	
			0x11, 0x0,	/* FC_RP */
/* 548 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (516) */
/* 550 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 552 */	NdrFcLong( 0x20400 ),	/* 132096 */
/* 556 */	NdrFcShort( 0x0 ),	/* 0 */
/* 558 */	NdrFcShort( 0x0 ),	/* 0 */
/* 560 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 562 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 564 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 566 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 568 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 570 */	NdrFcShort( 0x0 ),	/* 0 */
/* 572 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 574 */	NdrFcShort( 0x0 ),	/* 0 */
/* 576 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 580 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 582 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (550) */
/* 584 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 586 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 588 */	NdrFcShort( 0x8 ),	/* 8 */
/* 590 */	NdrFcShort( 0x0 ),	/* 0 */
/* 592 */	NdrFcShort( 0x6 ),	/* Offset= 6 (598) */
/* 594 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 596 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 598 */	
			0x11, 0x0,	/* FC_RP */
/* 600 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (568) */
/* 602 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 604 */	NdrFcShort( 0x4 ),	/* 4 */
/* 606 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 608 */	NdrFcShort( 0x0 ),	/* 0 */
/* 610 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 612 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 614 */	NdrFcShort( 0x4 ),	/* 4 */
/* 616 */	NdrFcShort( 0x0 ),	/* 0 */
/* 618 */	NdrFcShort( 0x1 ),	/* 1 */
/* 620 */	NdrFcShort( 0x0 ),	/* 0 */
/* 622 */	NdrFcShort( 0x0 ),	/* 0 */
/* 624 */	0x13, 0x0,	/* FC_OP */
/* 626 */	NdrFcShort( 0x1fc ),	/* Offset= 508 (1134) */
/* 628 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 630 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 632 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 634 */	NdrFcShort( 0x8 ),	/* 8 */
/* 636 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 638 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 640 */	NdrFcShort( 0x4 ),	/* 4 */
/* 642 */	NdrFcShort( 0x4 ),	/* 4 */
/* 644 */	0x11, 0x0,	/* FC_RP */
/* 646 */	NdrFcShort( 0xffffffd4 ),	/* Offset= -44 (602) */
/* 648 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 650 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 652 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 654 */	NdrFcLong( 0x2f ),	/* 47 */
/* 658 */	NdrFcShort( 0x0 ),	/* 0 */
/* 660 */	NdrFcShort( 0x0 ),	/* 0 */
/* 662 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 664 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 666 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 668 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 670 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 672 */	NdrFcShort( 0x1 ),	/* 1 */
/* 674 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 676 */	NdrFcShort( 0x4 ),	/* 4 */
/* 678 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 680 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 682 */	NdrFcShort( 0x10 ),	/* 16 */
/* 684 */	NdrFcShort( 0x0 ),	/* 0 */
/* 686 */	NdrFcShort( 0xa ),	/* Offset= 10 (696) */
/* 688 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 690 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 692 */	NdrFcShort( 0xffffffd8 ),	/* Offset= -40 (652) */
/* 694 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 696 */	
			0x13, 0x0,	/* FC_OP */
/* 698 */	NdrFcShort( 0xffffffe4 ),	/* Offset= -28 (670) */
/* 700 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 702 */	NdrFcShort( 0x4 ),	/* 4 */
/* 704 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 706 */	NdrFcShort( 0x0 ),	/* 0 */
/* 708 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 710 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 712 */	NdrFcShort( 0x4 ),	/* 4 */
/* 714 */	NdrFcShort( 0x0 ),	/* 0 */
/* 716 */	NdrFcShort( 0x1 ),	/* 1 */
/* 718 */	NdrFcShort( 0x0 ),	/* 0 */
/* 720 */	NdrFcShort( 0x0 ),	/* 0 */
/* 722 */	0x13, 0x0,	/* FC_OP */
/* 724 */	NdrFcShort( 0xffffffd4 ),	/* Offset= -44 (680) */
/* 726 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 728 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 730 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 732 */	NdrFcShort( 0x8 ),	/* 8 */
/* 734 */	NdrFcShort( 0x0 ),	/* 0 */
/* 736 */	NdrFcShort( 0x6 ),	/* Offset= 6 (742) */
/* 738 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 740 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 742 */	
			0x11, 0x0,	/* FC_RP */
/* 744 */	NdrFcShort( 0xffffffd4 ),	/* Offset= -44 (700) */
/* 746 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 748 */	NdrFcShort( 0x8 ),	/* 8 */
/* 750 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 752 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 754 */	NdrFcShort( 0x10 ),	/* 16 */
/* 756 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 758 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 760 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffff1 ),	/* Offset= -15 (746) */
			0x5b,		/* FC_END */
/* 764 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 766 */	NdrFcLong( 0x0 ),	/* 0 */
/* 770 */	NdrFcShort( 0x0 ),	/* 0 */
/* 772 */	NdrFcShort( 0x0 ),	/* 0 */
/* 774 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 776 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 778 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 780 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 782 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 784 */	NdrFcShort( 0x0 ),	/* 0 */
/* 786 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 788 */	NdrFcShort( 0x0 ),	/* 0 */
/* 790 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 794 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 796 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (764) */
/* 798 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 800 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 802 */	NdrFcShort( 0x18 ),	/* 24 */
/* 804 */	NdrFcShort( 0x0 ),	/* 0 */
/* 806 */	NdrFcShort( 0xa ),	/* Offset= 10 (816) */
/* 808 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 810 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 812 */	NdrFcShort( 0xffffffc4 ),	/* Offset= -60 (752) */
/* 814 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 816 */	
			0x11, 0x0,	/* FC_RP */
/* 818 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (782) */
/* 820 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 822 */	NdrFcShort( 0x1 ),	/* 1 */
/* 824 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 826 */	NdrFcShort( 0x0 ),	/* 0 */
/* 828 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 830 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 832 */	NdrFcShort( 0x8 ),	/* 8 */
/* 834 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 836 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 838 */	NdrFcShort( 0x4 ),	/* 4 */
/* 840 */	NdrFcShort( 0x4 ),	/* 4 */
/* 842 */	0x13, 0x0,	/* FC_OP */
/* 844 */	NdrFcShort( 0xffffffe8 ),	/* Offset= -24 (820) */
/* 846 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 848 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 850 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 852 */	NdrFcShort( 0x2 ),	/* 2 */
/* 854 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 856 */	NdrFcShort( 0x0 ),	/* 0 */
/* 858 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 860 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 862 */	NdrFcShort( 0x8 ),	/* 8 */
/* 864 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 866 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 868 */	NdrFcShort( 0x4 ),	/* 4 */
/* 870 */	NdrFcShort( 0x4 ),	/* 4 */
/* 872 */	0x13, 0x0,	/* FC_OP */
/* 874 */	NdrFcShort( 0xffffffe8 ),	/* Offset= -24 (850) */
/* 876 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 878 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 880 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 882 */	NdrFcShort( 0x4 ),	/* 4 */
/* 884 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 886 */	NdrFcShort( 0x0 ),	/* 0 */
/* 888 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 890 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 892 */	NdrFcShort( 0x8 ),	/* 8 */
/* 894 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 896 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 898 */	NdrFcShort( 0x4 ),	/* 4 */
/* 900 */	NdrFcShort( 0x4 ),	/* 4 */
/* 902 */	0x13, 0x0,	/* FC_OP */
/* 904 */	NdrFcShort( 0xffffffe8 ),	/* Offset= -24 (880) */
/* 906 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 908 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 910 */	
			0x1b,		/* FC_CARRAY */
			0x7,		/* 7 */
/* 912 */	NdrFcShort( 0x8 ),	/* 8 */
/* 914 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 916 */	NdrFcShort( 0x0 ),	/* 0 */
/* 918 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 920 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 922 */	NdrFcShort( 0x8 ),	/* 8 */
/* 924 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 926 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 928 */	NdrFcShort( 0x4 ),	/* 4 */
/* 930 */	NdrFcShort( 0x4 ),	/* 4 */
/* 932 */	0x13, 0x0,	/* FC_OP */
/* 934 */	NdrFcShort( 0xffffffe8 ),	/* Offset= -24 (910) */
/* 936 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 938 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 940 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 942 */	NdrFcShort( 0x8 ),	/* 8 */
/* 944 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 946 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 948 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 950 */	NdrFcShort( 0x8 ),	/* 8 */
/* 952 */	0x7,		/* Corr desc: FC_USHORT */
			0x0,		/*  */
/* 954 */	NdrFcShort( 0xffd8 ),	/* -40 */
/* 956 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 958 */	NdrFcShort( 0xffffffee ),	/* Offset= -18 (940) */
/* 960 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 962 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 964 */	NdrFcShort( 0x28 ),	/* 40 */
/* 966 */	NdrFcShort( 0xffffffee ),	/* Offset= -18 (948) */
/* 968 */	NdrFcShort( 0x0 ),	/* Offset= 0 (968) */
/* 970 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 972 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 974 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 976 */	NdrFcShort( 0xfffffdac ),	/* Offset= -596 (380) */
/* 978 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 980 */	
			0x13, 0x0,	/* FC_OP */
/* 982 */	NdrFcShort( 0xfffffed2 ),	/* Offset= -302 (680) */
/* 984 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 986 */	0x1,		/* FC_BYTE */
			0x5c,		/* FC_PAD */
/* 988 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 990 */	0x6,		/* FC_SHORT */
			0x5c,		/* FC_PAD */
/* 992 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 994 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 996 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 998 */	0xb,		/* FC_HYPER */
			0x5c,		/* FC_PAD */
/* 1000 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 1002 */	0xa,		/* FC_FLOAT */
			0x5c,		/* FC_PAD */
/* 1004 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 1006 */	0xc,		/* FC_DOUBLE */
			0x5c,		/* FC_PAD */
/* 1008 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 1010 */	0x6,		/* FC_SHORT */
			0x5c,		/* FC_PAD */
/* 1012 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 1014 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 1016 */	
			0x13, 0x0,	/* FC_OP */
/* 1018 */	NdrFcShort( 0xfffffd38 ),	/* Offset= -712 (306) */
/* 1020 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 1022 */	0xc,		/* FC_DOUBLE */
			0x5c,		/* FC_PAD */
/* 1024 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 1026 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1028) */
/* 1028 */	
			0x13, 0x0,	/* FC_OP */
/* 1030 */	NdrFcShort( 0xfffffd40 ),	/* Offset= -704 (326) */
/* 1032 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 1034 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1036) */
/* 1036 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1038 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1042 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1044 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1046 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 1048 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1050 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1052 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 1054 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 1056 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1058) */
/* 1058 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1060 */	NdrFcLong( 0x20400 ),	/* 132096 */
/* 1064 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1066 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1068 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 1070 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1072 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1074 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 1076 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 1078 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1080) */
/* 1080 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 1082 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1084) */
/* 1084 */	
			0x13, 0x0,	/* FC_OP */
/* 1086 */	NdrFcShort( 0xffffff84 ),	/* Offset= -124 (962) */
/* 1088 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 1090 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1092) */
/* 1092 */	
			0x13, 0x0,	/* FC_OP */
/* 1094 */	NdrFcShort( 0x28 ),	/* Offset= 40 (1134) */
/* 1096 */	
			0x15,		/* FC_STRUCT */
			0x7,		/* 7 */
/* 1098 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1100 */	0x6,		/* FC_SHORT */
			0x1,		/* FC_BYTE */
/* 1102 */	0x1,		/* FC_BYTE */
			0x8,		/* FC_LONG */
/* 1104 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 1106 */	
			0x13, 0x0,	/* FC_OP */
/* 1108 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (1096) */
/* 1110 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 1112 */	0x2,		/* FC_CHAR */
			0x5c,		/* FC_PAD */
/* 1114 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 1116 */	0x6,		/* FC_SHORT */
			0x5c,		/* FC_PAD */
/* 1118 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 1120 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 1122 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 1124 */	0xb,		/* FC_HYPER */
			0x5c,		/* FC_PAD */
/* 1126 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 1128 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 1130 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 1132 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 1134 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x7,		/* 7 */
/* 1136 */	NdrFcShort( 0x20 ),	/* 32 */
/* 1138 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1140 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1140) */
/* 1142 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1144 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 1146 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 1148 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1150 */	NdrFcShort( 0xfffffb8c ),	/* Offset= -1140 (10) */
/* 1152 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1154 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 1156 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1158 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1160 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1162 */	NdrFcShort( 0xfffffb7c ),	/* Offset= -1156 (6) */

			0x0
        }
    };

static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ] = 
        {
            
            {
            VARIANT_UserSize
            ,VARIANT_UserMarshal
            ,VARIANT_UserUnmarshal
            ,VARIANT_UserFree
            }

        };



/* Standard interface: __MIDL_itf_mscoree_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IObjectHandle, ver. 0.0,
   GUID={0xC460E2B4,0xE199,0x412a,{0x84,0x56,0x84,0xDC,0x3E,0x48,0x38,0xC3}} */

#pragma code_seg(".orpc")
static const unsigned short IObjectHandle_FormatStringOffsetTable[] =
    {
    0
    };

static const MIDL_STUBLESS_PROXY_INFO IObjectHandle_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IObjectHandle_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IObjectHandle_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IObjectHandle_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(4) _IObjectHandleProxyVtbl = 
{
    &IObjectHandle_ProxyInfo,
    &IID_IObjectHandle,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IObjectHandle::Unwrap */
};

const CInterfaceStubVtbl _IObjectHandleStubVtbl =
{
    &IID_IObjectHandle,
    &IObjectHandle_ServerInfo,
    4,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IAppDomainBinding, ver. 1.0,
   GUID={0x5C2B07A7,0x1E98,0x11d3,{0x87,0x2F,0x00,0xC0,0x4F,0x79,0xED,0x0D}} */


/* Object interface: IGCThreadControl, ver. 1.0,
   GUID={0xF31D1788,0xC397,0x4725,{0x87,0xA5,0x6A,0xF3,0x47,0x2C,0x27,0x91}} */


/* Object interface: IGCHostControl, ver. 1.1,
   GUID={0x5513D564,0x8374,0x4cb9,{0xAE,0xD9,0x00,0x83,0xF4,0x16,0x0A,0x1D}} */


/* Standard interface: __MIDL_itf_mscoree_0122, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: ICorThreadpool, ver. 1.0,
   GUID={0x84680D3A,0xB2C1,0x46e8,{0xAC,0xC2,0xDB,0xC0,0xA3,0x59,0x15,0x9A}} */


/* Standard interface: __MIDL_itf_mscoree_0123, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IDebuggerThreadControl, ver. 1.0,
   GUID={0x23D86786,0x0BB5,0x4774,{0x8F,0xB5,0xE3,0x52,0x2A,0xDD,0x62,0x46}} */


/* Standard interface: __MIDL_itf_mscoree_0124, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IDebuggerInfo, ver. 1.0,
   GUID={0xBF24142D,0xA47D,0x4d24,{0xA6,0x6D,0x8C,0x21,0x41,0x94,0x4E,0x44}} */


/* Standard interface: __MIDL_itf_mscoree_0125, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: ICorConfiguration, ver. 1.0,
   GUID={0x5C2B07A5,0x1E98,0x11d3,{0x87,0x2F,0x00,0xC0,0x4F,0x79,0xED,0x0D}} */


/* Standard interface: __MIDL_itf_mscoree_0126, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: ICorRuntimeHost, ver. 1.0,
   GUID={0xCB2F6722,0xAB3A,0x11d2,{0x9C,0x40,0x00,0xC0,0x4F,0xA3,0x0A,0x3E}} */

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x20000, /* Ndr library version */
    0,
    0x600015b, /* MIDL Version 6.0.347 */
    0,
    UserMarshalRoutines,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

const CInterfaceProxyVtbl * _mscoree_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_IObjectHandleProxyVtbl,
    0
};

const CInterfaceStubVtbl * _mscoree_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_IObjectHandleStubVtbl,
    0
};

PCInterfaceName const _mscoree_InterfaceNamesList[] = 
{
    "IObjectHandle",
    0
};


#define _mscoree_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _mscoree, pIID, n)

int __stdcall _mscoree_IID_Lookup( const IID * pIID, int * pIndex )
{
    
    if(!_mscoree_CHECK_IID(0))
        {
        *pIndex = 0;
        return 1;
        }

    return 0;
}

const ExtendedProxyFileInfo mscoree_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _mscoree_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _mscoree_StubVtblList,
    (const PCInterfaceName * ) & _mscoree_InterfaceNamesList,
    0, // no delegation
    & _mscoree_IID_Lookup, 
    1,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};


#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\nativevaraccessors.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// The following are used to read and write data given NativeVarInfo
// for primitive types. Don't use these for VALUECLASSes.
//*****************************************************************************

#include "corjit.h"

bool operator ==(const ICorDebugInfo::VarLoc &varLoc1,
                 const ICorDebugInfo::VarLoc &varLoc2);

SIZE_T  NativeVarSize(const ICorDebugInfo::VarLoc & varLoc);

DWORD *NativeVarStackAddr(const ICorDebugInfo::VarLoc &   varLoc, 
                        PCONTEXT                        pCtx);
                        
bool    GetNativeVarVal(const ICorDebugInfo::VarLoc &   varLoc, 
                        PCONTEXT                        pCtx,
                        DWORD                       *   pVal1, 
                        DWORD                       *   pVal2);
                        
bool    SetNativeVarVal(const ICorDebugInfo::VarLoc &   varLoc, 
                        PCONTEXT                        pCtx,
                        DWORD                           val1, 
                        DWORD                           val2);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\mscormmc_p.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Thu Feb 20 18:27:18 2003
 */
/* Compiler settings for mscormmc.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)
#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 440
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "mscormmc.h"

#define TYPE_FORMAT_STRING_SIZE   177                               
#define PROC_FORMAT_STRING_SIZE   159                               
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   2            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ISnapinAbout_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ISnapinAbout_ProxyInfo;


extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ];

#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT40_OR_LATER)
#error You need a Windows NT 4.0 or later to run this stub because it uses these features:
#error   -Oif or -Oicf, [wire_marshal] or [user_marshal] attribute.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure GetSnapinDescription */

			0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x3 ),	/* 3 */
/*  8 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 10 */	NdrFcShort( 0x0 ),	/* 0 */
/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
/* 14 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter lpDescription */

/* 16 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 18 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 20 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Return value */

/* 22 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 24 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 26 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetProvider */

/* 28 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 30 */	NdrFcLong( 0x0 ),	/* 0 */
/* 34 */	NdrFcShort( 0x4 ),	/* 4 */
/* 36 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 38 */	NdrFcShort( 0x0 ),	/* 0 */
/* 40 */	NdrFcShort( 0x8 ),	/* 8 */
/* 42 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter lpName */

/* 44 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 46 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 48 */	NdrFcShort( 0xa ),	/* Type Offset=10 */

	/* Return value */

/* 50 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 52 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 54 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetSnapinVersion */

/* 56 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 58 */	NdrFcLong( 0x0 ),	/* 0 */
/* 62 */	NdrFcShort( 0x5 ),	/* 5 */
/* 64 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 66 */	NdrFcShort( 0x0 ),	/* 0 */
/* 68 */	NdrFcShort( 0x8 ),	/* 8 */
/* 70 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter lpVersion */

/* 72 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 74 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 76 */	NdrFcShort( 0x12 ),	/* Type Offset=18 */

	/* Return value */

/* 78 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 80 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 82 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetSnapinImage */

/* 84 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 86 */	NdrFcLong( 0x0 ),	/* 0 */
/* 90 */	NdrFcShort( 0x6 ),	/* 6 */
/* 92 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 94 */	NdrFcShort( 0x0 ),	/* 0 */
/* 96 */	NdrFcShort( 0x8 ),	/* 8 */
/* 98 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter hAppIcon */

/* 100 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 102 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 104 */	NdrFcShort( 0x36 ),	/* Type Offset=54 */

	/* Return value */

/* 106 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 108 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 110 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetStaticFolderImage */

/* 112 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 114 */	NdrFcLong( 0x0 ),	/* 0 */
/* 118 */	NdrFcShort( 0x7 ),	/* 7 */
/* 120 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 122 */	NdrFcShort( 0x0 ),	/* 0 */
/* 124 */	NdrFcShort( 0x24 ),	/* 36 */
/* 126 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x5,		/* 5 */

	/* Parameter hSmallImage */

/* 128 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 130 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 132 */	NdrFcShort( 0x7e ),	/* Type Offset=126 */

	/* Parameter hSmallImageOpen */

/* 134 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 136 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 138 */	NdrFcShort( 0x90 ),	/* Type Offset=144 */

	/* Parameter hLargeImage */

/* 140 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 142 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 144 */	NdrFcShort( 0xa2 ),	/* Type Offset=162 */

	/* Parameter cMask */

/* 146 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 148 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 150 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 152 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 154 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 156 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/*  4 */	NdrFcShort( 0x2 ),	/* Offset= 2 (6) */
/*  6 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/*  8 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 10 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 12 */	NdrFcShort( 0x2 ),	/* Offset= 2 (14) */
/* 14 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 16 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 18 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 20 */	NdrFcShort( 0x2 ),	/* Offset= 2 (22) */
/* 22 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 24 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 26 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 28 */	NdrFcShort( 0x1a ),	/* Offset= 26 (54) */
/* 30 */	
			0x13, 0x0,	/* FC_OP */
/* 32 */	NdrFcShort( 0x2 ),	/* Offset= 2 (34) */
/* 34 */	
			0x2a,		/* FC_ENCAPSULATED_UNION */
			0x48,		/* 72 */
/* 36 */	NdrFcShort( 0x4 ),	/* 4 */
/* 38 */	NdrFcShort( 0x2 ),	/* 2 */
/* 40 */	NdrFcLong( 0x48746457 ),	/* 1215587415 */
/* 44 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 46 */	NdrFcLong( 0x52746457 ),	/* 1383359575 */
/* 50 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 52 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (51) */
/* 54 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 56 */	NdrFcShort( 0x0 ),	/* 0 */
/* 58 */	NdrFcShort( 0x4 ),	/* 4 */
/* 60 */	NdrFcShort( 0x0 ),	/* 0 */
/* 62 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (30) */
/* 64 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 66 */	NdrFcShort( 0x3c ),	/* Offset= 60 (126) */
/* 68 */	
			0x13, 0x0,	/* FC_OP */
/* 70 */	NdrFcShort( 0x2 ),	/* Offset= 2 (72) */
/* 72 */	
			0x2a,		/* FC_ENCAPSULATED_UNION */
			0x88,		/* 136 */
/* 74 */	NdrFcShort( 0x8 ),	/* 8 */
/* 76 */	NdrFcShort( 0x3 ),	/* 3 */
/* 78 */	NdrFcLong( 0x48746457 ),	/* 1215587415 */
/* 82 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 84 */	NdrFcLong( 0x52746457 ),	/* 1383359575 */
/* 88 */	NdrFcShort( 0xa ),	/* Offset= 10 (98) */
/* 90 */	NdrFcLong( 0x50746457 ),	/* 1349805143 */
/* 94 */	NdrFcShort( 0x800b ),	/* Simple arm type: FC_HYPER */
/* 96 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (95) */
/* 98 */	
			0x13, 0x0,	/* FC_OP */
/* 100 */	NdrFcShort( 0xc ),	/* Offset= 12 (112) */
/* 102 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 104 */	NdrFcShort( 0x1 ),	/* 1 */
/* 106 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 108 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 110 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 112 */	
			0x17,		/* FC_CSTRUCT */
			0x3,		/* 3 */
/* 114 */	NdrFcShort( 0x18 ),	/* 24 */
/* 116 */	NdrFcShort( 0xfffffff2 ),	/* Offset= -14 (102) */
/* 118 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 120 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 122 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 124 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 126 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 128 */	NdrFcShort( 0x1 ),	/* 1 */
/* 130 */	NdrFcShort( 0x4 ),	/* 4 */
/* 132 */	NdrFcShort( 0x0 ),	/* 0 */
/* 134 */	NdrFcShort( 0xffffffbe ),	/* Offset= -66 (68) */
/* 136 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 138 */	NdrFcShort( 0x6 ),	/* Offset= 6 (144) */
/* 140 */	
			0x13, 0x0,	/* FC_OP */
/* 142 */	NdrFcShort( 0xffffffba ),	/* Offset= -70 (72) */
/* 144 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 146 */	NdrFcShort( 0x1 ),	/* 1 */
/* 148 */	NdrFcShort( 0x4 ),	/* 4 */
/* 150 */	NdrFcShort( 0x0 ),	/* 0 */
/* 152 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (140) */
/* 154 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 156 */	NdrFcShort( 0x6 ),	/* Offset= 6 (162) */
/* 158 */	
			0x13, 0x0,	/* FC_OP */
/* 160 */	NdrFcShort( 0xffffffa8 ),	/* Offset= -88 (72) */
/* 162 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 164 */	NdrFcShort( 0x1 ),	/* 1 */
/* 166 */	NdrFcShort( 0x4 ),	/* 4 */
/* 168 */	NdrFcShort( 0x0 ),	/* 0 */
/* 170 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (158) */
/* 172 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 174 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */

			0x0
        }
    };

static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ] = 
        {
            
            {
            HICON_UserSize
            ,HICON_UserMarshal
            ,HICON_UserUnmarshal
            ,HICON_UserFree
            },
            {
            HBITMAP_UserSize
            ,HBITMAP_UserMarshal
            ,HBITMAP_UserUnmarshal
            ,HBITMAP_UserFree
            }

        };



/* Standard interface: __MIDL_itf_mscormmc_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: ISnapinAbout, ver. 0.0,
   GUID={0x1245208C,0xA151,0x11D0,{0xA7,0xD7,0x00,0xC0,0x4F,0xD9,0x09,0xDD}} */

#pragma code_seg(".orpc")
static const unsigned short ISnapinAbout_FormatStringOffsetTable[] =
    {
    0,
    28,
    56,
    84,
    112
    };

static const MIDL_STUBLESS_PROXY_INFO ISnapinAbout_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ISnapinAbout_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ISnapinAbout_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ISnapinAbout_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(8) _ISnapinAboutProxyVtbl = 
{
    &ISnapinAbout_ProxyInfo,
    &IID_ISnapinAbout,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ISnapinAbout::GetSnapinDescription */ ,
    (void *) (INT_PTR) -1 /* ISnapinAbout::GetProvider */ ,
    (void *) (INT_PTR) -1 /* ISnapinAbout::GetSnapinVersion */ ,
    (void *) (INT_PTR) -1 /* ISnapinAbout::GetSnapinImage */ ,
    (void *) (INT_PTR) -1 /* ISnapinAbout::GetStaticFolderImage */
};

const CInterfaceStubVtbl _ISnapinAboutStubVtbl =
{
    &IID_ISnapinAbout,
    &ISnapinAbout_ServerInfo,
    8,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x20000, /* Ndr library version */
    0,
    0x600015b, /* MIDL Version 6.0.347 */
    0,
    UserMarshalRoutines,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

const CInterfaceProxyVtbl * _mscormmc_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_ISnapinAboutProxyVtbl,
    0
};

const CInterfaceStubVtbl * _mscormmc_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_ISnapinAboutStubVtbl,
    0
};

PCInterfaceName const _mscormmc_InterfaceNamesList[] = 
{
    "ISnapinAbout",
    0
};


#define _mscormmc_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _mscormmc, pIID, n)

int __stdcall _mscormmc_IID_Lookup( const IID * pIID, int * pIndex )
{
    
    if(!_mscormmc_CHECK_IID(0))
        {
        *pIndex = 0;
        return 1;
        }

    return 0;
}

const ExtendedProxyFileInfo mscormmc_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _mscormmc_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _mscormmc_StubVtblList,
    (const PCInterfaceName * ) & _mscormmc_InterfaceNamesList,
    0, // no delegation
    & _mscormmc_IID_Lookup, 
    1,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};


#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\mscoree_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Thu Feb 20 18:27:05 2003
 */
/* Compiler settings for mscoree.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IObjectHandle,0xC460E2B4,0xE199,0x412a,0x84,0x56,0x84,0xDC,0x3E,0x48,0x38,0xC3);


MIDL_DEFINE_GUID(IID, IID_IAppDomainBinding,0x5C2B07A7,0x1E98,0x11d3,0x87,0x2F,0x00,0xC0,0x4F,0x79,0xED,0x0D);


MIDL_DEFINE_GUID(IID, IID_IGCThreadControl,0xF31D1788,0xC397,0x4725,0x87,0xA5,0x6A,0xF3,0x47,0x2C,0x27,0x91);


MIDL_DEFINE_GUID(IID, IID_IGCHostControl,0x5513D564,0x8374,0x4cb9,0xAE,0xD9,0x00,0x83,0xF4,0x16,0x0A,0x1D);


MIDL_DEFINE_GUID(IID, IID_ICorThreadpool,0x84680D3A,0xB2C1,0x46e8,0xAC,0xC2,0xDB,0xC0,0xA3,0x59,0x15,0x9A);


MIDL_DEFINE_GUID(IID, IID_IDebuggerThreadControl,0x23D86786,0x0BB5,0x4774,0x8F,0xB5,0xE3,0x52,0x2A,0xDD,0x62,0x46);


MIDL_DEFINE_GUID(IID, IID_IDebuggerInfo,0xBF24142D,0xA47D,0x4d24,0xA6,0x6D,0x8C,0x21,0x41,0x94,0x4E,0x44);


MIDL_DEFINE_GUID(IID, IID_ICorConfiguration,0x5C2B07A5,0x1E98,0x11d3,0x87,0x2F,0x00,0xC0,0x4F,0x79,0xED,0x0D);


MIDL_DEFINE_GUID(IID, IID_ICorRuntimeHost,0xCB2F6722,0xAB3A,0x11d2,0x9C,0x40,0x00,0xC0,0x4F,0xA3,0x0A,0x3E);


MIDL_DEFINE_GUID(IID, LIBID_mscoree,0x5477469e,0x83b1,0x11d2,0x8b,0x49,0x00,0xa0,0xc9,0xb7,0xc9,0xc4);


MIDL_DEFINE_GUID(IID, IID_IApartmentCallback,0x178E5337,0x1528,0x4591,0xB1,0xC9,0x1C,0x6E,0x48,0x46,0x86,0xD8);


MIDL_DEFINE_GUID(IID, IID_IManagedObject,0xC3FCC19E,0xA970,0x11d2,0x8B,0x5A,0x00,0xA0,0xC9,0xB7,0xC9,0xC4);


MIDL_DEFINE_GUID(IID, IID_ICatalogServices,0x04C6BE1E,0x1DB1,0x4058,0xAB,0x7A,0x70,0x0C,0xCC,0xFB,0xF2,0x54);


MIDL_DEFINE_GUID(CLSID, CLSID_ComCallUnmarshal,0x3F281000,0xE95A,0x11d2,0x88,0x6B,0x00,0xC0,0x4F,0x86,0x9F,0x04);


MIDL_DEFINE_GUID(CLSID, CLSID_CorRuntimeHost,0xCB2F6723,0xAB3A,0x11d2,0x9C,0x40,0x00,0xC0,0x4F,0xA3,0x0A,0x3E);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\ngen.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef _NGEN_H_
#define _NGEN_H_

// This structure cannot have any fields removed from it!!!
//
// If additional options need to be added to this structure, 
// add them to the end of the structure and make sure you update
// logic throughout the runtime to look at a different size in the dwSize
// field. This is how we'll 'version' this structure.

typedef struct _NGenOptions
{
    DWORD       dwSize;
    bool        	  fDebug;    
    bool        	  fDebugOpt;    
    bool        	  fProf;    
    bool        	  fSilent;
    LPCWSTR     lpszExecutableFileName;
} NGenOptions;


// Function pointer types that we use to dynamically bind to the appropriate 
extern "C" typedef HRESULT STDAPICALLTYPE CreateZapper(HANDLE* hZapper, NGenOptions *options);
typedef CreateZapper *PNGenCreateZapper;

extern "C" typedef HRESULT STDAPICALLTYPE TryEnumerateFusionCache(HANDLE hZapper, LPCWSTR assemblyName, bool fPrint, bool fDelete);
typedef TryEnumerateFusionCache *PNGenTryEnumerateFusionCache;

extern "C" typedef HRESULT STDAPICALLTYPE Compile(HANDLE hZapper, LPCWSTR path);
typedef Compile *PNGenCompile;

extern "C" typedef HRESULT STDAPICALLTYPE FreeZapper(HANDLE hZapper);
typedef FreeZapper *PNGenFreeZapper;



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\nlog.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef _NLOG_H_
#define _NLOG_H_

#include "miniio.h"
#include "corzap.h"
#include "arraylist.h"

class NLogFile;
class NLogDirectory;
class NLog;
class NLogRecord;
class NLogAssembly;
class NLogModule;
class NLogIndexList;

//
// NLogFile is an I/O abstraction used to read and write to a file 
// in the NLog directory.
//

class NLogFile : public MiniFile
{
 public:
    NLogFile(LPCWSTR pPath);

    CorZapSharing ReadSharing();
    void WriteSharing(CorZapSharing sharing);

    CorZapDebugging ReadDebugging();
    void WriteDebugging(CorZapDebugging debugging);

    CorZapProfiling ReadProfiling();
    void WriteProfiling(CorZapProfiling profiling);

    void ReadTimestamp(SYSTEMTIME *pTimestamp);
    void WriteTimestamp(SYSTEMTIME *pTimestamp);

    IApplicationContext *ReadApplicationContext();
    void WriteApplicationContext(IApplicationContext *pContext);

    IAssemblyName *ReadAssemblyName();
    void WriteAssemblyName(IAssemblyName *pName);
};

//
// An NLogDirectory is the set of all NLog records available for a given EE version.
//

class NLogDirectory
{
 public:
    NLogDirectory();

    LPCWSTR GetPath() { return m_wszDirPath; }

    class Iterator
    {
    public:
        ~Iterator();

        BOOL Next();
        NLog *GetLog();

    private:
        friend class NLogDirectory;
        Iterator(NLogDirectory *pDir, LPCWSTR pSimpleName);

        NLogDirectory       *m_dir;
        LPWSTR              m_path;
        LPWSTR              m_pFile;    
        HANDLE              m_findHandle;
        WIN32_FIND_DATA     m_data;
    };

    Iterator IterateLogs(LPCWSTR simpleName = NULL);

 private:
    DWORD m_cDirPath;
    WCHAR m_wszDirPath[MAX_PATH];
};

//
// An NLog contains the records about zap files for a given application.
// (As identified by its fusion application context.)
//

class NLog
{
public:

    //
    // Read/write scenarios:
    // 
    // Open new/existing nlog from IApplicationContext, append record
    //
    // Init with IApplicationContext
    //      Hash to filename, append directory, open and read file
    // Create nlog from iterator, read records, possibly delete
    //      Create from file name, open and read file
    // 

    NLog(NLogDirectory *pDir, IApplicationContext *pContext);
    NLog(NLogDirectory *pDir, LPCWSTR fileName);
    ~NLog();

    IApplicationContext *GetFusionContext() { return m_pContext; }

    // 
    // A permanent log ensures that the log entry is never deleted, and hence
    // there will always be a prejitted version of the application.
    // ???
    //
    // void SetPermanent(BOOL fPermanent);

    //
    // Iterator iterates through all records listed in the log.
    //

    class Iterator
    {
    public:
        BOOL Next();
        NLogRecord *GetRecord() { return m_pNext; }

    private:
        friend class NLog;
        Iterator(NLogFile *pFile);

        NLogFile    *m_pFile;
        NLogRecord  *m_pNext;
    };

    Iterator IterateRecords();

    //
    // Appends a record to the log. Automatically handles "overflow" conditions
    // (where the log file has grown too large.)
    //

    void AppendRecord(NLogRecord *pRecord);

    //
    // Operations
    //

    void Delete();

 private:
    DWORD HashAssemblyName(IAssemblyName *pAssemblyName);
    DWORD HashApplicationContext(IApplicationContext *pApplicationContext);

    LPWSTR              m_pPath;
    IApplicationContext *m_pContext;
    NLogFile            *m_pFile;
    BOOL                m_fDelete;  
    DWORD               m_recordStartOffset;
};

//
// An NLogRecord is an entry in an NLog; it contains a list of all assemblies loaded
// during the instantiation of the application.
//
class NLogRecord
{
 public:
    NLogRecord(NLogFile *pFile);
    NLogRecord();

    ~NLogRecord();

    //
    // A full record contains all possible assemblies 
    // (does this really mean anything???)
    // void SetFull(BOOL fFull);
    // BOOL IsFull();
    //

    void AppendAssembly(NLogAssembly *pAssembly) { m_Assemblies.Append(pAssembly); }
    
    class Iterator
    {
    public:
        BOOL Next() { return m_i.Next(); }
        NLogAssembly *GetAssembly() { return (NLogAssembly*) m_i.GetElement(); }

    private:
        friend class NLogRecord;
        Iterator(ArrayList *pList) { m_i = pList->Iterate(); }

        ArrayList::Iterator m_i;
    };

    Iterator IterateAssemblies() { return Iterator(&m_Assemblies); }

    //
    // Operations
    //

    BOOL Merge(NLogRecord *pRecord);

    void Write(NLogFile *pFile);
    void Read(NLogFile *pFile);

 private:
    ArrayList           m_Assemblies;

    SYSTEMTIME          m_Timestamp;
    DWORD               m_Weight;
};

//
// An NLogAssembly is a record of a single assembly which was loaded into a 
// given application instance
// 
class NLogAssembly
{
 public:
    NLogAssembly(IAssemblyName *pAssemblyName, 
                 CorZapSharing sharing, 
                 CorZapDebugging debugging,
                 CorZapProfiling profiling, 
                 GUID *pMVID);
    NLogAssembly(NLogFile *pFile);
    NLogAssembly(NLogAssembly *pAssembly);
    ~NLogAssembly();

    IAssemblyName *GetAssemblyName()    { return m_pAssemblyName; }
    LPCWSTR GetDisplayName();

    ICorZapConfiguration *GetConfiguration();

    // 
    // May have 
    //  (a) application context.  This is the case of all zap records which are read
    //      from zap logs.
    //  (b) explicit binding list.  These are constructed by analyzing many zap logs,
    //      extracting common strong named assemblies, and coalescing them together.
    //

    DWORD GetBindingsCount()            { return m_cBindings; }         
    ICorZapBinding **GetBindings()      { return m_pBindings; }

    //
    // A full assembly contains all methods & classes of all modules
    // void SetFull(BOOL fFull);
    // BOOL IsFull();
    // 

    //
    //  List of modules
    //

    void AppendModule(NLogModule *pModule) { m_Modules.Append(pModule); }

    class Iterator
    {
    public:
        BOOL Next() { return m_i.Next(); }
        NLogModule *GetModule() { return (NLogModule*) m_i.GetElement(); }

    private:
        friend class NLogAssembly;
        Iterator(ArrayList *pList) { m_i = pList->Iterate(); }

        ArrayList::Iterator m_i;
    };

    Iterator IterateModules() { return Iterator(&m_Modules); }

    //
    // Operations
    //

    BOOL Merge(NLogAssembly *pAssembly);

    void Write(NLogFile *pFile);
    void Read(NLogFile *pFile);

    //
    // Converts an Application Context specified NLogAssembly to an explicitly bound one.
    // The explicitly bound version can then possibly be shared across multiple NLogs.
    //

    BOOL HasStrongName();
    NLogAssembly *Bind(IApplicationContext *pContext);

    unsigned long Hash();
    unsigned long Compare(NLogAssembly *pAssembly);

    CorZapSharing GetSharing() { return m_sharing; }
    CorZapDebugging GetDebugging() { return m_debugging; }
    CorZapProfiling GetProfiling() { return m_profiling; }

 private:
    IAssemblyName           *m_pAssemblyName;
    LPWSTR                  m_pDisplayName;
    CorZapSharing           m_sharing;
    CorZapDebugging         m_debugging;
    CorZapProfiling         m_profiling;
    GUID                    m_mvid;

    DWORD                   m_cBindings;
    ICorZapBinding          **m_pBindings;

    ArrayList               m_Modules;
};

//
// An NLogIndexList is an efficient representation of a generic list of indices.  This
// can be used to record which methods or classes were used in a particular module.
//
// Note that this abstraction doesn't guarantee absolute perfection in recording each 
// individual instance.  It is free to approximate as appropriate. (For example, if 75% of 
// the indices are filled, it might set the set to full & stop tracking individual indices.)
//
// @todo: right now this has a trivial implementation -  fix it later if we really
// want to use this feature.
//
class NLogIndexList
{
 public:
    NLogIndexList() : m_max(0) {}
    NLogIndexList(NLogFile *pFile) : m_max(0) { Read(pFile); }
    NLogIndexList(NLogIndexList *pIndexList);

    //
    // A full index list contains all indexes
    //
    // void SetFull(BOOL fFull) {}
    // BOOL IsFull() { return TRUE; }

    void AppendIndex(SIZE_T index) 
    { 
        _ASSERTE(index != 0xCDCDCDCD);
        m_list.Append((void*)index); 
        if (index > m_max)
            m_max = index;
    }

    class Iterator
    {
    public:
        BOOL Next() { return m_i.Next(); }
        SIZE_T GetIndex() { return (SIZE_T) m_i.GetElement(); }

    private:
        friend class NLogIndexList;
        Iterator(ArrayList *pList) { m_i = pList->Iterate(); }

        ArrayList::Iterator m_i;
    };

    Iterator IterateIndices() { return Iterator(&m_list); }

    BOOL Merge(NLogIndexList *pIndexList); 
    void Write(NLogFile *pFile);
    void Read(NLogFile *pFile);

 private:
    ArrayList m_list;
    SIZE_T    m_max;
};

//
// An NLogModule is a record of a single Module which was loaded into an assembly.
//
class NLogModule
{
 public:
    NLogModule(LPCSTR pModuleName);
    NLogModule(NLogFile *pFile);
    NLogModule(NLogModule *pModule);
    ~NLogModule();

    LPCSTR GetModuleName()              { return m_pName; }

    NLogIndexList *GetCompiledMethods() { return &m_compiledMethods; }
    NLogIndexList *GetLoadedClasses()   { return &m_loadedClasses; }

    BOOL Merge(NLogModule *pModule);

    void Write(NLogFile *pFile);
    void Read(NLogFile *pFile);

    unsigned long Hash();
    unsigned long Compare(NLogModule *pModule);

 private:
    LPSTR           m_pName;
    NLogIndexList   m_compiledMethods;
    NLogIndexList   m_loadedClasses;
};


#endif _NLOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\openum.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef __openum_h__
#define __openum_h__


typedef enum opcode_t
{
#define OPDEF(c,s,pop,push,args,type,l,s1,s2,ctrl) c,
#include "opcode.def"
#undef OPDEF
  CEE_COUNT,        /* number of instructions and macros pre-defined */
} OPCODE;


typedef enum opcode_format_t 
{
	InlineNone		= 0,	// no inline args       
	InlineVar		= 1,	// local variable       (U2 (U1 if Short on))
	InlineI			= 2,	// an signed integer    (I4 (I1 if Short on))
	InlineR			= 3,	// a real number        (R8 (R4 if Short on))
	InlineBrTarget	= 4,    // branch target        (I4 (I1 if Short on))
	InlineI8		= 5,
	InlineMethod	= 6,   // method token (U4)
	InlineField		= 7,   // field token  (U4)
	InlineType		= 8,   // type token   (U4)
	InlineString	= 9,   // string TOKEN (U4)
	InlineSig		= 10,  // signature tok (U4)
	InlineRVA		= 11,  // ldptr token  (U4)
	InlineTok		= 12,  // a meta-data token of unknown type (U4)
	InlineSwitch	= 13,  // count (U4), pcrel1 (U4) .... pcrelN (U4)
	InlinePhi		= 14,  // count (U1), var1 (U2) ... varN (U2) 

	// WATCH OUT we are close to the limit here, if you add
	// more enumerations you need to change ShortIline definition below

	// The extended enumeration also encodes the size in the IL stream
	ShortInline 	= 16,						// if this bit is set, the format is the 'short' format
	PrimaryMask   	= (ShortInline-1),			// mask these off to get primary enumeration above
	ShortInlineVar 	= (ShortInline + InlineVar),
	ShortInlineI	= (ShortInline + InlineI),
	ShortInlineR	= (ShortInline + InlineR),
	ShortInlineBrTarget = (ShortInline + InlineBrTarget),
	InlineOpcode	= (ShortInline + InlineNone),    // This is only used internally.  It means the 'opcode' is two byte instead of 1
} OPCODE_FORMAT;

#endif /* __openum_h__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\nsutilpriv.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// NSUtilPriv.h
//
// Helpers for converting namespace separators.
//
//*****************************************************************************
#ifndef __NSUTILPRIV_H__
#define __NSUTILPRIV_H__

extern "C" 
{
extern int g_SlashesToDots;
};

template <class T> class CQuickArray;

struct ns
{

//*****************************************************************************
// Determine how many chars large a fully qualified name would be given the
// two parts of the name.  The return value includes room for every character
// in both names, as well as room for the separator and a final terminator.
//*****************************************************************************
static
int GetFullLength(                      // Number of chars in full name.
    const WCHAR *szNameSpace,           // Namspace for value.
    const WCHAR *szName);               // Name of value.

static
int GetFullLength(                      // Number of chars in full name.
    LPCUTF8     szNameSpace,            // Namspace for value.
    LPCUTF8     szName);                // Name of value.

//*****************************************************************************
// Scan the given string to see if the name contains any invalid characters
// that are not allowed.
//*****************************************************************************
static
int IsValidName(                        // true if valid, false invalid.
    const WCHAR *szName);               // Name to parse.

static
int IsValidName(                        // true if valid, false invalid.
    LPCUTF8     szName);                // Name to parse.


//*****************************************************************************
// Scan the string from the rear looking for the first valid separator.  If
// found, return a pointer to it.  Else return null.  This code is smart enough
// to skip over special sequences, such as:
//      a.b..ctor
//         ^
//         |
// The ".ctor" is considered one token.
//*****************************************************************************
static 
WCHAR *FindSep(                         // Pointer to separator or null.
    const WCHAR *szPath);               // The path to look in.

static 
LPUTF8 FindSep(                         // Pointer to separator or null.
    LPCUTF8     szPath);                // The path to look in.


//*****************************************************************************
// Take a path and find the last separator (nsFindSep), and then replace the
// separator with a '\0' and return a pointer to the name.  So for example:
//      a.b.c
// becomes two strings "a.b" and "c" and the return value points to "c".
//*****************************************************************************
static 
WCHAR *SplitInline(                     // Pointer to name portion.
    WCHAR       *szPath);               // The path to split.

static 
LPUTF8       SplitInline(               // Pointer to name portion.
    LPUTF8      szPath);                // The path to split.

static
void SplitInline(
    LPWSTR     szPath,                  // Path to split.
    LPCWSTR      &szNameSpace,          // Return pointer to namespace.
    LPCWSTR     &szName);               // Return pointer to name.

static
void SplitInline(
    LPUTF8       szPath,                // Path to split.
    LPCUTF8      &szNameSpace,          // Return pointer to namespace.
    LPCUTF8      &szName);              // Return pointer to name.


//*****************************************************************************
// Split the last parsable element from the end of the string as the name,
// the first part as the namespace.
//*****************************************************************************
static 
int SplitPath(                          // true ok, false trunction.
    const WCHAR *szPath,                // Path to split.
    WCHAR       *szNameSpace,           // Output for namespace value.
    int         cchNameSpace,           // Max chars for output.
    WCHAR       *szName,                // Output for name.
    int         cchName);               // Max chars for output.

static 
int SplitPath(                          // true ok, false trunction.
    LPCUTF8     szPath,                 // Path to split.
    LPUTF8      szNameSpace,            // Output for namespace value.
    int         cchNameSpace,           // Max chars for output.
    LPUTF8      szName,                 // Output for name.
    int         cchName);               // Max chars for output.


//*****************************************************************************
// Take two values and put them together in a fully qualified path using the
// correct separator.
//*****************************************************************************
static 
int MakePath(                           // true ok, false truncation.
    WCHAR       *szOut,                 // output path for name.
    int         cchChars,               // max chars for output path.
    const WCHAR *szNameSpace,           // Namespace.
    const WCHAR *szName);               // Name.

static 
int MakePath(                           // true ok, false truncation.
    LPUTF8      szOut,                  // output path for name.
    int         cchChars,               // max chars for output path.
    LPCUTF8     szNameSpace,            // Namespace.
    LPCUTF8     szName);                // Name.

static
int MakePath(                           // true ok, false truncation.
    WCHAR       *szOut,                 // output path for name.
    int         cchChars,               // max chars for output path.
    LPCUTF8     szNameSpace,            // Namespace.
    LPCUTF8     szName);                // Name.

static
int MakePath(                           // true ok, false out of memory
    CQuickBytes &qb,                    // Where to put results.
    LPCUTF8     szNameSpace,            // Namespace for name.
    LPCUTF8     szName);                // Final part of name.

static
int MakePath(                           // true ok, false out of memory
    CQuickArray<WCHAR> &qa,             // Where to put results.
    LPCUTF8            szNameSpace,     // Namespace for name.
    LPCUTF8            szName);         // Final part of name.

static
int MakePath(                           // true ok, false out of memory
    CQuickBytes &qb,                    // Where to put results.
    const WCHAR *szNameSpace,           // Namespace for name.
    const WCHAR *szName);               // Final part of name.

static
int MakeLowerCasePath(                    // true ok, false out of memory
                  LPUTF8     szOut,       // Where to put results
                  int        cBytes,      // max bytes for output path.
                  LPCUTF8    szNameSpace, // Namespace for name.
                  LPCUTF8    szName);     // Final part of name.

//*****************************************************************************
// Given a buffer that already contains a namespace, this function appends a
// name onto that buffer with the inclusion of the separator between the two.
// The return value is a pointer to where the separator was written.
//*****************************************************************************
static 
const WCHAR *AppendPath(                // Pointer to start of appended data.
    WCHAR       *szBasePath,            // Current path to append to.
    int         cchMax,                 // Max chars for output buffer, including existing data.
    const WCHAR *szAppend);             // Value to append to existing path.

static 
LPCUTF8     AppendPath(                 // Pointer to start of appended data.
    LPUTF8      szBasePath,             // Current path to append to.
    int         cchMax,                 // Max chars for output buffer, including existing data.
    LPCUTF8     szAppend);              // Value to append to existing path.

//*****************************************************************************
// Given a two sets of name and namespace, this function, compares if the
// concatenation of each sets gives the same full-qualified name.  Instead of
// actually doing the concatenation and making the comparison, this does the
// comparison in a more optimized manner that avoid any kind of allocations.
//*****************************************************************************
static
bool FullQualNameCmp(                   // true if identical, false otherwise.
    LPCUTF8     szNameSpace1,           // NameSpace 1.
    LPCUTF8     szName1,                // Name 1.
    LPCUTF8     szNameSpace2,           // NameSpace 2.
    LPCUTF8     szName2);               // Name 2.

//*****************************************************************************
// Concatinate type names to assembly names
//*****************************************************************************
static 
bool MakeAssemblyQualifiedName(                                  // true if ok, false if out of memory
                               CQuickBytes &qb,                  // location to put result
                               const WCHAR *szTypeName,          // Type name
                               const WCHAR *szAssemblyName);     // Assembly Name
    
static 
bool MakeAssemblyQualifiedName(                                        // true ok, false truncation
                               WCHAR* pBuffer,                         // Buffer to recieve the results
                               int    dwBuffer,                        // Number of characters total in buffer
                               const WCHAR *szTypeName,                // Namespace for name.
                               int   dwTypeName,                       // Number of characters (not including null)
                               const WCHAR *szAssemblyName,            // Final part of name.
                               int   dwAssemblyName);                  // Number of characters (not including null)

static 
int MakeNestedTypeName(                 // true ok, false out of memory
    CQuickBytes &qb,                    // Where to put results.
    LPCUTF8     szEnclosingName,        // Full name for enclosing type
    LPCUTF8     szNestedName);          // Full name for nested type

static 
int MakeNestedTypeName(                 // true ok, false truncation.
    LPUTF8      szOut,                  // output path for name.
    int         cchChars,               // max chars for output path.
    LPCUTF8     szEnclosingName,        // Full name for enclosing type
    LPCUTF8     szNestedName);          // Full name for nested type

static 
INT32 InvariantToLower(
                       LPUTF8 szOut,      // Buffer to receive results
                       INT32  cMaxBytes,  // Number of bytes in buffer
                       LPCUTF8 szIn);     // String to convert to lowercase.

}; // struct ns


#ifndef NAMESPACE_SEPARATOR_CHAR
#define NAMESPACE_SEPARATOR_CHAR '.'
#define NAMESPACE_SEPARATOR_WCHAR L'.'
#define NAMESPACE_SEPARATOR_STR "."
#define NAMESPACE_SEPARATOR_WSTR L"."
#define NAMESPACE_SEPARATOR_LEN 1
#define ASSEMBLY_SEPARATOR_CHAR ','
#define ASSEMBLY_SEPARATOR_WCHAR L','
#define ASSEMBLY_SEPARATOR_STR ", "
#define ASSEMBLY_SEPARATOR_WSTR L", "
#define ASSEMBLY_SEPARATOR_LEN 2
#define BACKSLASH_CHAR '\\'
#define BACKSLASH_WCHAR L'\\'
#define NESTED_SEPARATOR_CHAR '+'
#define NESTED_SEPARATOR_WCHAR L'+'
#define NESTED_SEPARATOR_STR "+"
#define NESTED_SEPARATOR_WSTR L"+"
#endif

#define EMPTY_STR ""
#define EMPTY_WSTR L""

// From legacy to current value.
void SlashesToDots(char* pStr, int iLen=-1);
void SlashesToDots(WCHAR* pStr, int iLen=-1);

// From current value to legacy.
void DotsToSlashes(char* pStr, int iLen=-1);
void DotsToSlashes(WCHAR* pStr, int iLen=-1);

#define SLASHES2DOTS_NAMESPACE_BUFFER_UTF8(fromptr, toptr) \
    long __l##fromptr = (fromptr) ? (strlen(fromptr) + 1) : 0; \
    CQuickBytes __CQuickBytes##fromptr; \
    if (__l##fromptr) { \
        __CQuickBytes##fromptr.Alloc(__l##fromptr); \
        strcpy((char *) __CQuickBytes##fromptr.Ptr(), fromptr); \
        SlashesToDots((LPUTF8) __CQuickBytes##fromptr.Ptr()); \
        toptr = (LPUTF8) __CQuickBytes##fromptr.Ptr(); \
    }

#define SLASHES2DOTS_NAMESPACE_BUFFER_UNICODE(fromptr, toptr) \
    long __l##fromptr = (fromptr) ? (wcslen(fromptr) + 1) : 0; \
    CQuickBytes __CQuickBytes##fromptr; \
    if ( __l##fromptr) { \
        __CQuickBytes##fromptr.Alloc(__l##fromptr * sizeof(WCHAR)); \
        wcscpy((WCHAR *) __CQuickBytes##fromptr.Ptr(), fromptr); \
        SlashesToDots((LPWSTR) __CQuickBytes##fromptr.Ptr()); \
        toptr = (LPWSTR) __CQuickBytes##fromptr.Ptr(); \
    }


#define DOTS2SLASHES_NAMESPACE_BUFFER_UTF8(fromptr, toptr) \
    long __l##fromptr = (fromptr) ? (strlen(fromptr) + 1) : 0; \
    CQuickBytes __CQuickBytes##fromptr; \
    if (__l##fromptr) { \
        __CQuickBytes##fromptr.Alloc(__l##fromptr); \
        strcpy((char *) __CQuickBytes##fromptr.Ptr(), fromptr); \
        DotsToSlashes((LPUTF8) __CQuickBytes##fromptr.Ptr()); \
        toptr = (LPUTF8) __CQuickBytes##fromptr.Ptr(); \
    }

#define DOTS2SLASHES_NAMESPACE_BUFFER_UNICODE(fromptr, toptr) \
    long __l##fromptr = (fromptr) ? (wcslen(fromptr) + 1) : 0; \
    CQuickBytes __CQuickBytes##fromptr; \
    if (__l##fromptr) { \
        __CQuickBytes##fromptr.Alloc(__l##fromptr * sizeof(WCHAR)); \
        wcscpy((WCHAR *) __CQuickBytes##fromptr.Ptr(), fromptr); \
        DotsToSlashes((LPWSTR) __CQuickBytes##fromptr.Ptr()); \
        toptr = (LPWSTR) __CQuickBytes##fromptr.Ptr(); \
    }

#define MAKE_FULL_PATH_ON_STACK_UTF8(toptr, pnamespace, pname) \
{ \
    int __i##toptr = ns::GetFullLength(pnamespace, pname); \
    toptr = (char *) alloca(__i##toptr); \
    ns::MakePath(toptr, __i##toptr, pnamespace, pname); \
}

#define MAKE_FULL_PATH_ON_STACK_UNICODE(toptr, pnamespace, pname) \
{ \
    int __i##toptr = ns::GetFullLength(pnamespace, pname); \
    toptr = (WCHAR *) alloca(__i##toptr * sizeof(WCHAR)); \
    ns::MakePath(toptr, __i##toptr, pnamespace, pname); \
}

#define MAKE_FULLY_QUALIFIED_NAME(pszFullyQualifiedName, pszNameSpace, pszName) MAKE_FULL_PATH_ON_STACK_UTF8(pszFullyQualifiedName, pszNameSpace, pszName)

#define MAKE_FULLY_QUALIFIED_MEMBER_NAME(ptr, pszNameSpace, pszClassName, pszMemberName, pszSig) \
{ \
    int __i##ptr = ns::GetFullLength(pszNameSpace, pszClassName); \
    __i##ptr += (pszMemberName ? (int) strlen(pszMemberName) : 0); \
    __i##ptr += NAMESPACE_SEPARATOR_LEN; \
    __i##ptr += (pszSig ? (int) strlen(pszSig) : 0); \
    ptr = (LPUTF8) alloca(__i##ptr); \
    ns::MakePath(ptr, __i##ptr, pszNameSpace, pszClassName); \
    if (pszMemberName) { \
        strcat(ptr, NAMESPACE_SEPARATOR_STR); \
        strcat(ptr, pszMemberName); \
    } \
    if (pszSig) { \
        if (! pszMemberName) \
            strcat(ptr, NAMESPACE_SEPARATOR_STR); \
        strcat(ptr, pszSig); \
    } \
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\perfcounters.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//-----------------------------------------------------------------------------
// PerfCounters.h
//
// Internal Interface for CLR to use Performance counters
//-----------------------------------------------------------------------------

#ifndef _PerfCounters_h_
#define _PerfCounters_h_

#include "PerfCounterDefs.h"

#pragma pack()

#ifdef ENABLE_PERF_COUNTERS
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// This code section active iff we're using Perf Counters
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// PerfCounter class serves as namespace with data protection. 
// Enforce this by making constructor private
//-----------------------------------------------------------------------------
class PerfCounters
{
private:
	PerfCounters();

public:
	static HRESULT Init();
	static void Terminate();

    static PerfCounterIPCControlBlock * GetPrivatePerfCounterPtr();
    static PerfCounterIPCControlBlock * GetGlobalPerfCounterPtr();

private:
	static HANDLE m_hGlobalMapPerf;
	static HANDLE m_hPrivateMapPerf;

	static PerfCounterIPCControlBlock * m_pGlobalPerf;
	static PerfCounterIPCControlBlock * m_pPrivatePerf;

	static BOOL m_fInit;
	
// Set pointers to garbage so they're never null.
	static PerfCounterIPCControlBlock m_garbage;


    friend PerfCounterIPCControlBlock & GetGlobalPerfCounters();
    friend PerfCounterIPCControlBlock & GetPrivatePerfCounters();
};

//-----------------------------------------------------------------------------
// Utility functions
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Get the perf counters that all process share
//-----------------------------------------------------------------------------
inline PerfCounterIPCControlBlock & GetGlobalPerfCounters()
{
	return *PerfCounters::m_pGlobalPerf;
}

//-----------------------------------------------------------------------------
// Get the perf counters specific to our process
//-----------------------------------------------------------------------------
inline PerfCounterIPCControlBlock & GetPrivatePerfCounters()
{
	return *PerfCounters::m_pPrivatePerf;
}

inline PerfCounterIPCControlBlock *PerfCounters::GetPrivatePerfCounterPtr()
{
    return m_pPrivatePerf;
};

inline PerfCounterIPCControlBlock *PerfCounters::GetGlobalPerfCounterPtr()
{
    return m_pGlobalPerf;
};

Perf_Contexts *GetPrivateContextsPerfCounters();
Perf_Contexts *GetGlobalContextsPerfCounters();

#define COUNTER_ONLY(x) x

#define PERF_COUNTER_NUM_OF_ITERATIONS 10

#ifdef _X86_
#pragma warning(disable:4035)

#define CCNT_OVERHEAD64 13

/* This is like QueryPerformanceCounter but a lot faster */
static __declspec(naked) __int64 getPentiumCycleCount() {
   __asm {
        RDTSC   // read time stamp counter
        ret
    };
}

extern "C" DWORD __stdcall GetSpecificCpuType();

inline UINT64 GetCycleCount_UINT64()
{
    if ((GetSpecificCpuType() & 0x0000FFFF) > 4) 
        return getPentiumCycleCount();
    else    
        return(0);
}

#pragma warning(default:4035)

#else // _X86_
inline UINT64 GetCycleCount_UINT64()
{
    LARGE_INTEGER qwTmp;
    QueryPerformanceCounter(&qwTmp);
    return qwTmp.QuadPart;
}
#endif // _X86_

#define PERF_COUNTER_TIMER_PRECISION UINT64
#define GET_CYCLE_COUNT GetCycleCount_UINT64

#define PERF_COUNTER_TIMER_START() \
PERF_COUNTER_TIMER_PRECISION _startPerfCounterTimer = GET_CYCLE_COUNT();

#define PERF_COUNTER_TIMER_STOP(global) \
global = (GET_CYCLE_COUNT() - _startPerfCounterTimer);




#else // ENABLE_PERF_COUNTERS
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// This code section active iff we're NOT using Perf Counters
// Note, not even a class definition, so all usages of PerfCounters in client
// should be in #ifdef or COUNTER_ONLY(). 
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

#define COUNTER_ONLY(x)


#endif // ENABLE_PERF_COUNTERS


#endif // _PerfCounters_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\perfalloc.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// PerfAlloc.h
//
//  Routines layered on top of allocation primitives to dissect working set
//  Used for free builds only. Debug builds have their own routines called Dbgalloc
//  to maintain allocation stats.
//

#ifndef __PERFALLOC_H__
#define __PERFALLOC_H__

#include "ImageHlp.h"
#include "winreg.h"

#define MAX_CLASSNAME_LENGTH    1024

#ifdef GOLDEN
#undef PERF_TRACKING
#undef PERFALLOC
#endif // GOLDEN

#ifdef PERF_TRACKING
#define PERFALLOC 1
#endif

#ifdef PERFALLOC
#include "corhlpr.h"
#include <stdio.h>
//---------------------------------------------------------------------------
// All code ifdef'd within PERFALLOC is for figuring out the allocations made in the process
// heap. This helps us figure out the working set when built using this flag on a free build. 


// We used a zero sized array, disable the non-standard extension warning.
#pragma warning(push)
#pragma warning(disable:4200)

// Allocation header prepended to allocated memory.
struct PerfAllocHeader {
    unsigned        m_Length;           // Length of user data in packet
    PerfAllocHeader *m_Next;             // Next packet in chain of live allocations
    PerfAllocHeader *m_Prev;             // Previous packet in chain of live allocations
    void           *m_AllocEIP;         // EIP of allocator
    char            m_Data[];           // Start of user data
};

// Various global allocation statistics.
struct PerfAllocStats {
    __int64         m_Allocs;           // Number of calls to PerfAlloc
    __int64         m_Frees;            // Number of calls to PerfFree
    __int64         m_AllocBytes;       // Total number of bytes ever allocated
    __int64         m_FreeBytes;        // Total number of bytes ever freed
    __int64         m_MaxAlloc;         // Largest number of bytes ever allocated simultaneously
};

// Function pointer types for routines in IMAGEHLP.DLL that we late bind to.
typedef bool (__stdcall * SYMPROC_INIT)(HANDLE, LPSTR, BOOL);
typedef bool (__stdcall * SYMPROC_CLEAN)(HANDLE);
typedef bool (__stdcall * SYMPROC_GETSYM)(HANDLE, DWORD, PDWORD, LPVOID);


struct PerfAllocVars
{
    CRITICAL_SECTION    g_AllocMutex;
    PerfAllocHeader    *g_AllocListFirst;
    PerfAllocHeader    *g_AllocListLast;
    BOOL                g_SymbolsInitialized;
    SYMPROC_INIT        g_SymInitialize;
    SYMPROC_CLEAN       g_SymCleanup;
    SYMPROC_GETSYM      g_SymGetSymFromAddr;
    HMODULE             g_LibraryHandle;
    DWORD               g_PerfEnabled;
    HANDLE              g_HeapHandle;
};

// Macros to switch between packet header and body addresses.
#define CDA_HEADER_TO_DATA(_h) (char *)((_h)->m_Data)
#define CDA_DATA_TO_HEADER(_d) ((PerfAllocHeader *)(_d) - 1)

// Routine to retrieve caller's EIP (where caller is the caller of the routine
// that calls PerfAllocCallerEIP, rather than the direct caller of PerfAllocCallerEIP).
// We assume here that the frame is not built and hence we use esp instead of ebp
// to get the return address.
#ifdef _X86_
static __declspec(naked) void *PerfAllocCallerEIP()
{
#pragma warning(push)
#pragma warning(disable:4035)
    __asm {
        mov     eax, [esp]
        ret
    };
#pragma warning(pop)
#else
static void *PerfAllocCallerEIP()
{
    return NULL;
#endif
}


class PerfUtil
{
public:
    // Global variables
    static BOOL                g_PerfAllocHeapInitialized;
    static LONG                g_PerfAllocHeapInitializing;
    static PerfAllocVars       g_PerfAllocVariables;

    // Routine to initialize access to debugging symbols.
    static void PerfInitSymbols()
    {
    //    char        filename[256];

        // Attempt to load IMAGHLP.DLL.
        if ((PerfUtil::g_PerfAllocVariables.g_LibraryHandle = LoadLibraryA("imagehlp.dll")) == NULL)
            goto Error;

        // Try to find the entrypoints we need.
        PerfUtil::g_PerfAllocVariables.g_SymInitialize = (SYMPROC_INIT)GetProcAddress(PerfUtil::g_PerfAllocVariables.g_LibraryHandle, "SymInitialize");
        PerfUtil::g_PerfAllocVariables.g_SymCleanup = (SYMPROC_CLEAN)GetProcAddress(PerfUtil::g_PerfAllocVariables.g_LibraryHandle, "SymCleanup");
        PerfUtil::g_PerfAllocVariables.g_SymGetSymFromAddr = (SYMPROC_GETSYM)GetProcAddress(PerfUtil::g_PerfAllocVariables.g_LibraryHandle, "SymGetSymFromAddr");

        if ((PerfUtil::g_PerfAllocVariables.g_SymInitialize == NULL) ||
            (PerfUtil::g_PerfAllocVariables.g_SymCleanup == NULL) ||
            (PerfUtil::g_PerfAllocVariables.g_SymGetSymFromAddr == NULL))
            goto Error;

        // Initialize IMAGEHLP.DLLs symbol handling. Use the directory where
        // MSCOREE.DLL was loaded from to initialize the symbol search path.
        if (!PerfUtil::g_PerfAllocVariables.g_SymInitialize(GetCurrentProcess(), NULL, TRUE))
            goto Error;

        PerfUtil::g_PerfAllocVariables.g_SymbolsInitialized = TRUE;

        return;

     Error:
        if (PerfUtil::g_PerfAllocVariables.g_LibraryHandle)
            FreeLibrary(PerfUtil::g_PerfAllocVariables.g_LibraryHandle);
    }


    // Called to free resources allocated by PerfInitSymbols.
    static void PerfUnloadSymbols()
    {
        if (!PerfUtil::g_PerfAllocVariables.g_SymbolsInitialized)
            return;

        // Get rid of symbols.
        PerfUtil::g_PerfAllocVariables.g_SymCleanup(GetCurrentProcess());

        // Unload IMAGEHLP.DLL.
        FreeLibrary(PerfUtil::g_PerfAllocVariables.g_LibraryHandle);

        PerfUtil::g_PerfAllocVariables.g_SymbolsInitialized = FALSE;
    }


    // Transform an address into a string of the form '(symbol + offset)' if
    // possible. Note that the string returned is statically allocated, so don't
    // make a second call to this routine until you've finsihed with the results of
    // this call.
    static char *PerfSymbolize(void *Address)
    {
        static char         buffer[MAX_CLASSNAME_LENGTH];
        DWORD               offset;
        CQuickBytes         qb;
        IMAGEHLP_SYMBOL    *syminfo = (IMAGEHLP_SYMBOL *) qb.Alloc(sizeof(IMAGEHLP_SYMBOL) + MAX_CLASSNAME_LENGTH);

        // Initialize symbol tables if not done so already.
        if (!PerfUtil::g_PerfAllocVariables.g_SymbolsInitialized)
            PerfInitSymbols();

        // If still not initialized, we couldn't get IMAGEHLP.DLL to play ball.
        if (!PerfUtil::g_PerfAllocVariables.g_SymbolsInitialized)
            return "(no symbols available)";

        syminfo->SizeOfStruct = sizeof(IMAGEHLP_SYMBOL);
        syminfo->MaxNameLength = MAX_CLASSNAME_LENGTH;

        // Ask IMAGEHLP.DLL to do the actual transformation.
        if (PerfUtil::g_PerfAllocVariables.g_SymGetSymFromAddr(GetCurrentProcess(), (DWORD)(size_t)Address, &offset, syminfo) != NULL)
            sprintf(buffer, "(%s + 0x%x)", syminfo->Name, offset);
        else
            sprintf(buffer, "(symbol not found, %u)", GetLastError());

        return buffer;
    }
    static DWORD GetConfigDWORD (LPSTR name, DWORD defValue)
    {
        DWORD ret = 0;
        DWORD rtn;
        HKEY machineKey;
        DWORD type;
        DWORD size = 4;

        if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, FRAMEWORK_REGISTRY_KEY, 0, KEY_QUERY_VALUE, &machineKey) == ERROR_SUCCESS)
        {
            rtn = RegQueryValueExA(machineKey, name, 0, &type, (LPBYTE)&ret, &size);
            RegCloseKey(machineKey);
            if (rtn == ERROR_SUCCESS && type == REG_DWORD)
                return(ret);
        }

        return(defValue);
    }
};

#pragma warning(pop)

class PerfNew
{
public:
    // Called to initialise the allocation subsystem (the first time it's used).
    static void PerfAllocInit()
    {
        // @TODO: Add synchronization here.
        PerfUtil::g_PerfAllocVariables.g_AllocListFirst = NULL;
        PerfUtil::g_PerfAllocVariables.g_AllocListLast = NULL;
#define PERF_ALLOC_NO_STATS 0 
#define PERF_ALLOC_CURRENT  1
#define PERF_ALLOC_STARTUP  2
#define PERF_ALLOC_DETAILED 3
#define PERF_ALLOC_ALL      10
		#ifdef ENABLE_PERF_ALLOC
        PerfUtil::g_PerfAllocVariables.g_PerfEnabled = PerfUtil::GetConfigDWORD ("EnablePerfAllocStats", 0);
		#else
		PerfUtil::g_PerfAllocVariables.g_PerfEnabled = 0;
		#endif
		
        PerfUtil::g_PerfAllocVariables.g_HeapHandle = GetProcessHeap();

        PerfUtil::g_PerfAllocHeapInitialized = TRUE;
    }

    static DWORD GetEnabledPerfAllocStats () { return PerfUtil::g_PerfAllocVariables.g_PerfEnabled; }

    // Allocate a block of memory at least n bytes big.
    static void *PerfAlloc(size_t n, void *EIP)
    {
        // Initialize if necessary (PerfAllocInit takes care of the synchronization).
        if (!PerfUtil::g_PerfAllocHeapInitialized)
            PerfAllocInit();

        if (!PerfUtil::g_PerfAllocVariables.g_PerfEnabled)
            return HeapAlloc(GetProcessHeap(), 0, n);

        // Allocate enough memory for the caller and our debugging header
        unsigned        length = (unsigned) sizeof(PerfAllocHeader) + n;
        PerfAllocHeader *h;

        h = (PerfAllocHeader *)HeapAlloc(PerfUtil::g_PerfAllocVariables.g_HeapHandle, 0, length);
        
        if (h == NULL) {
            // Whoops, allocation failure. Record it.
            printf("PerfAlloc: alloc fail for %u bytes\n", n);

        } else {

        // Fill in the packet debugging header.
        h->m_AllocEIP = EIP;
        h->m_Length = (unsigned int)n;
        h->m_Prev = PerfUtil::g_PerfAllocVariables.g_AllocListLast;
        h->m_Next = NULL;

        // Link the packet into the queue of live packets.
        if (PerfUtil::g_PerfAllocVariables.g_AllocListLast != NULL) {
            PerfUtil::g_PerfAllocVariables.g_AllocListLast->m_Next = h;
            PerfUtil::g_PerfAllocVariables.g_AllocListLast = h;
        }
        
        if (PerfUtil::g_PerfAllocVariables.g_AllocListFirst == NULL) {
            _ASSERTE(PerfUtil::g_PerfAllocVariables.g_AllocListLast == NULL);
            PerfUtil::g_PerfAllocVariables.g_AllocListFirst = h;
            PerfUtil::g_PerfAllocVariables.g_AllocListLast = h;
        }
        
        }
        
        return h ? CDA_HEADER_TO_DATA(h) : NULL;
    }
        
    // Free a packet allocated with PerfAlloc.
    static void PerfFree(void *b, void *EIP)
    {
        if (!PerfUtil::g_PerfAllocVariables.g_PerfEnabled) {
            if (b) // check for null pointer Win98 doesn't like being
                    // called to free null pointers.
                HeapFree(GetProcessHeap(), 0, b);
            return;
        }

        // Technically it's possible to get here without having gone through
        // PerfAlloc (since it's legal to deallocate a NULL pointer), so we
        // better check for initializtion to be on the safe side.
        if (!PerfUtil::g_PerfAllocHeapInitialized)
            PerfAllocInit();
        
        // It's legal to deallocate NULL. 
        if (b == NULL) {
            return;
        }

        // Locate the packet header in front of the data packet.
        PerfAllocHeader *h = CDA_DATA_TO_HEADER(b);

        // Unlink the packet from the live packet queue.
        if (h->m_Prev)
            h->m_Prev->m_Next = h->m_Next;
        else
            PerfUtil::g_PerfAllocVariables.g_AllocListFirst = h->m_Next;
        if (h->m_Next)
            h->m_Next->m_Prev = h->m_Prev;
        else
            PerfUtil::g_PerfAllocVariables.g_AllocListLast = h->m_Prev;

        HeapFree(PerfUtil::g_PerfAllocVariables.g_HeapHandle, 0, h);
    }

    // report stats
    static void PerfAllocReport()
    {
        if (!PerfUtil::g_PerfAllocHeapInitialized)
            return;

        if (GetEnabledPerfAllocStats() == PERF_ALLOC_NO_STATS)
            return;

    //    FILE *hPerfAllocLogFile = fopen ("WSAllocPerf.log", "w");
        PerfAllocHeader *h = PerfUtil::g_PerfAllocVariables.g_AllocListFirst;
        
        printf ("Alloc Addr\tAlloc Page\tSize\tSymbol\n");
        while (h) {
            //fprintf (hPerfAllocLogFile, "0x%0x,%u,%s\n", h->m_Data, h->m_Length, PerfSymbolize(h->m_AllocEIP));   
            printf ("0x%0x\t0x%0x\t%u\t%s\n", (size_t)h->m_Data, ((size_t)h->m_Data & ~0xfff), h->m_Length, PerfUtil::PerfSymbolize(h->m_AllocEIP));   
            h = h->m_Next;
        }
        
        //fflush (hPerfAllocLogFile);
        // PerfUtil::PerfUnloadSymbols();
    }
};

typedef struct _PerfBlock
{
    struct _PerfBlock *next;
    //PerfBlock *prev;
    LPVOID address;
    SIZE_T size;
    void *eip;
} PerfBlock;

class PerfVirtualAlloc
{
private:
    static BOOL m_fPerfVirtualAllocInited;
    static PerfBlock* m_pFirstBlock;
    static PerfBlock* m_pLastBlock;
    static DWORD      m_dwEnableVirtualAllocStats;
public:
    static void InitPerfVirtualAlloc ()
    {
        if (m_fPerfVirtualAllocInited)
            return;

        // Perf Settings
        // VirtualAllocStats
        // 0 -> no stats
        // 1 -> Current allocations when prompted
        // 2 -> Report MEM_COMMIT'd at startup and shutdown
        // 3 -> Detailed report
        // 10 -> Report all allocations on every MEM_COMMIT and MEM_RELEASE
#define PERF_VIRTUAL_ALLOC_NO_STATS 0 
#define PERF_VIRTUAL_ALLOC_CURRENT  1
#define PERF_VIRTUAL_ALLOC_STARTUP  2
#define PERF_VIRTUAL_ALLOC_DETAILED 3
#define PERF_VIRTUAL_ALLOC_ALL      10

		#ifdef ENABLE_VIRTUAL_ALLOC
        m_dwEnableVirtualAllocStats = PerfUtil::GetConfigDWORD ("EnableVirtualAllocStats", 0);
		#else
		m_dwEnableVirtualAllocStats = 0;
		#endif

        m_fPerfVirtualAllocInited = TRUE;
    }

    static BOOL IsInitedPerfVirtualAlloc () { return m_fPerfVirtualAllocInited; }
    static DWORD GetEnabledVirtualAllocStats() { return m_dwEnableVirtualAllocStats; }
    
    static void PerfVirtualAllocHack ()
    {
        // @TODO: AGK. Total HACK to remove compilation erros in the JIT build process. In the JIT build we
        // only use the VirtualAlloc instrumentation and not the "new/delete" instrumentation
        // so the following never get called but are needed for the runtime instrumentation and
        // we want to keep the same file....If you can figure out a better workaround please remove
        // this hack.
        PerfNew::PerfAlloc(0,0);
        PerfNew::PerfFree(0,0);
        PerfNew::PerfAllocReport();
        PerfAllocCallerEIP();
    }

    static void ReportPerfBlock (PerfBlock *pb, char t)
    {
        _ASSERTE (GetEnabledVirtualAllocStats() != PERF_VIRTUAL_ALLOC_NO_STATS);
        printf("0x%0x\t0x%0x\t%d%c\t%s\n", (size_t)pb->address, ((size_t)pb->address+pb->size+1023)&~0xfff, pb->size, t, PerfUtil::PerfSymbolize(pb->eip));
    }
        
    static void ReportPerfAllocStats ()
    {
        if (!IsInitedPerfVirtualAlloc())
            InitPerfVirtualAlloc();
        
        if (GetEnabledVirtualAllocStats() == PERF_VIRTUAL_ALLOC_NO_STATS)
            return;

        PerfBlock *pb = m_pFirstBlock;
        printf ("Committed Range\t\tSize\n");
        while (pb != 0)
        {
            ReportPerfBlock(pb, ' ');
            pb = pb->next;
        }

        // PerfUtil::PerfUnloadSymbols();
    }

    static void InsertAllocation (LPVOID lpAddress, SIZE_T dwSize, void *eip)
    {
        _ASSERTE (GetEnabledVirtualAllocStats() != PERF_VIRTUAL_ALLOC_NO_STATS);

        PerfBlock *pb = new PerfBlock();
        pb->next = 0;
        pb->size = dwSize;
        pb->address = lpAddress;
        pb->eip = eip;
        
        if (m_dwEnableVirtualAllocStats > PERF_VIRTUAL_ALLOC_STARTUP)
            ReportPerfBlock(pb, '+');
        if (m_pLastBlock == 0)
        {
            m_pLastBlock = pb;
            m_pFirstBlock = pb;
        }
        else
        {
            m_pLastBlock->next = pb;
            m_pLastBlock = pb;
        }
    }   

    static void DeleteAllocation (LPVOID lpAddress, SIZE_T dwSize)
    {
        _ASSERTE (GetEnabledVirtualAllocStats() != PERF_VIRTUAL_ALLOC_NO_STATS);

        PerfBlock *cur = m_pFirstBlock;
        PerfBlock *prev = 0;
        if (cur->address == lpAddress)
        {
            _ASSERTE (cur->size == dwSize);
            if (m_pLastBlock == m_pFirstBlock)
                m_pLastBlock = cur->next;
            m_pFirstBlock = cur->next;
            cur->next = 0;
            if (m_dwEnableVirtualAllocStats > PERF_VIRTUAL_ALLOC_STARTUP)
                ReportPerfBlock(cur, '-');
            delete cur;
            return;
        }

        prev = cur;
        cur = cur->next;
        while (cur != 0)
        {
            if (cur->address == lpAddress)
            {
                _ASSERTE (cur->size == dwSize);
                if (m_pLastBlock == cur)
                    m_pLastBlock = prev;
                prev->next = cur->next;
                cur->next = 0;
                if (m_dwEnableVirtualAllocStats > PERF_VIRTUAL_ALLOC_STARTUP)
                    ReportPerfBlock(cur, '-');
                delete cur;
                return;
            }
            prev = cur;
            cur = cur->next;
        }

        _ASSERTE("Deleting block not committed!");
    }

    static LPVOID VirtualAlloc (LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect, void * eip)
    {
        if (!IsInitedPerfVirtualAlloc())
            InitPerfVirtualAlloc();

        LPVOID lpRetAddr = VirtualAllocEx (GetCurrentProcess(), lpAddress, dwSize, flAllocationType, flProtect);
        if ((GetEnabledVirtualAllocStats() != PERF_VIRTUAL_ALLOC_NO_STATS) && (flAllocationType & MEM_COMMIT))
        {
            PerfVirtualAlloc::InsertAllocation (lpRetAddr, dwSize, eip);

            if (GetEnabledVirtualAllocStats() > PERF_VIRTUAL_ALLOC_STARTUP)
                ReportPerfAllocStats();
        }
        
        return lpRetAddr;
    }

    static BOOL VirtualFree (LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType)
    {
        if (!IsInitedPerfVirtualAlloc())
            InitPerfVirtualAlloc();
        
        if (GetEnabledVirtualAllocStats() != PERF_VIRTUAL_ALLOC_NO_STATS)
            PerfVirtualAlloc::DeleteAllocation (lpAddress, dwSize);

        BOOL retVal = VirtualFreeEx (GetCurrentProcess(), lpAddress, dwSize, dwFreeType);

        if (GetEnabledVirtualAllocStats() > PERF_VIRTUAL_ALLOC_STARTUP)
            ReportPerfAllocStats();

        return retVal;
    }
};

#endif // #ifdef PERFALLOC

#endif // #ifndef __PERFALLOC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\outstring.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************/
/*                         OutString.h                           */
/*****************************************************************/
/* A simple, lightweight, character output stream, with very few
   external dependancies (like sprintf ... ) */

/* Author: Vance Morrison 
   Date :  2/1/99               */
/*****************************************************************/

#ifndef _OutString_h
#define _OutString_h 1

#include "utilcode.h"   // for overloaded new
#include <string.h>     // for strlen, strcpy

/*****************************************************************/
    // a light weight character 'output' stream 
class OutString {
public:
    enum FormatFlags {          // used to control printing of numbers
        none        = 0,
        put0x       = 1,        // put leading 0x on hexidecimal 
        zeroFill    = 2,        // zero fill (instead of space fill)
    };

    OutString() : start(0), cur(0), end(0) {}

    OutString(unsigned initialAlloc) { 
        cur = start = new char[initialAlloc+1]; // for null termination
        end = &start[initialAlloc];
    }
    
    ~OutString() { delete start; }
    
    // shortcut for printing decimal  
    OutString& operator<<(int i) { return(dec(i)); }

    OutString& operator<<(double d);
 
    // FIX make this really unsigned
    OutString& operator<<(unsigned i) { return(dec(i)); }

    // prints out the hexidecimal representation
    OutString& dec(int i, unsigned minWidth = 0);
    
    // prints out the hexidecimal representation 
    OutString& hex(unsigned i, int minWidth = 0, unsigned flags = none);

    OutString& hex(unsigned __int64 i, int minWidth = 0, unsigned flags = none);

    OutString& hex(int i, int minWidth = 0, unsigned flags = none) {
        return hex(unsigned(i), minWidth, flags);
    }

    OutString& hex(__int64 i, int minWidth = 0, unsigned flags = none) {
        return hex((unsigned __int64) i, minWidth, flags);
    }
    
    //  print out 'count' instances of the character 'c'
    OutString& pad(unsigned count, char c);
    
    OutString& operator<<(char c) {
        if (cur >= end)
            realloc(1);
        *cur++ = c;
        _ASSERTE(start <= cur && cur <= end);
        return(*this);
    }
    
    OutString& operator<<(const wchar_t* str) {
        size_t len = wcslen(str);
        if (cur+len > end)
            realloc(len);
        while(str != 0) 
            *cur++ = (char) *str++;
        _ASSERTE(start <= cur && cur <= end);
        return(*this);
    }

    OutString& prepend(const char c) {
        char buff[2]; buff[0] = c; buff[1] = 0;
        return(prepend(buff));
    }

    OutString& prepend(const char* str) {
        size_t len = strlen(str);
        if (cur+len > end)
            realloc(len);
        memmove(start+len, start, cur-start);
        memcpy(start, str, len);
        cur = cur + len;
        _ASSERTE(start <= cur && cur <= end);
        return(*this);
        }

    OutString& operator=(const OutString& str) {
        clear();
        *this << str;
        return(*this);
    }

    OutString& operator<<(const OutString& str) {
        write(str.start, str.cur-str.start);
        return(*this);
    }

    OutString& operator<<(const char* str) {
        write(str, strlen(str));
        return(*this);
    }

    void write(const char* str, size_t len) {
        if (cur+len > end)
            realloc(len);
        memcpy(cur, str, len);
        cur = cur + len;
        _ASSERTE(start <= cur && cur <= end);
    }

    void swap(OutString& str) {
        char* tmp = start;
        start = str.start;
        str.start = tmp;
        tmp = end;
        end = str.end;
        str.end = tmp;
        tmp = cur;
        cur = str.cur;
        str.cur = tmp;
        _ASSERTE(start <= cur && cur <= end);
    }

    void clear()                { cur = start; }
    size_t length() const       { return(cur-start); }
    
    // return the null terminated string, OutString keeps ownership
    const char* val() const     { *cur = 0; return(start); }
    
    // grab string (caller must now delete) OutString is cleared 
    char* grab()        { char* ret = start; *cur = 0; end = cur = start = 0; return(ret); }
    
private:
    void realloc(size_t neededSpace);
    
    char *start;    // start of the buffer
    char *end;      // points at the last place null terminator can go
    char *cur;      // points at a null terminator
};

#endif // _OutString_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\opinfo.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/***************************************************************************/
/*                                OpInfo.h                                 */
/***************************************************************************/

/* contains OpInfo, a wrapper that allows you to get useful information
   about IL opcodes, and how to decode them */

/***************************************************************************/

#ifndef OpInfo_h
#define OpInfo_h

#include "openum.h"

	// Decribes the flow of control properties of the instruction
enum OpFlow {
	META,			// not a real instuction
	CALL,			// a call instruction
	BRANCH,			// unconditional branch, does not fall through
	COND_BRANCH,	// may fall through
	PHI,			
	THROW,
	BREAK,
	RETURN,		
	NEXT,			// flows into next instruction (none of the above)
};

	// These are all the possible arguments for the instruction
/****************************************************************************/
union OpArgsVal {
	__int32  i;
	__int64 i8;
	double   r;
	struct {
		unsigned count;
		int* targets;   // targets are pcrelative displacements (little-endian)
		} switch_;
	struct {
		unsigned count;
		unsigned short* vars;
		} phi;
};

/***************************************************************************/
#define BYTE unsigned char

	// OpInfo parses a il instrution into an opcode, and a arg and updates the IP
class OpInfo {
public:
	OpInfo()			  { data = 0; }
	OpInfo(OPCODE opCode) { _ASSERTE(opCode < CEE_COUNT); data = &table[opCode]; } 

		// fetch instruction at 'instrPtr, fills in 'args' returns pointer 
		// to next instruction 
	const BYTE* fetch(const BYTE* instrPtr, OpArgsVal* args);	

	const char* getName() 	 	{ return(data->name); }
	OPCODE_FORMAT getArgsInfo()	{ return(OPCODE_FORMAT(data->format & PrimaryMask)); }
	OpFlow 		getFlow()	 	{ return(data->flow); }
	OPCODE 		getOpcode()	 	{ return((OPCODE) (data-table)); }
    int         getNumPop()     { return(data->numPop); }
    int         getNumPush()    { return(data->numPush); }

private:
	struct OpInfoData {
        const char* name;
        OPCODE_FORMAT format  	: 8;
		OpFlow     	flow		: 8;
		int     	numPop		: 3;	// < 0 means depends on instr args
		int       	numPush		: 3;	// < 0 means depends on instr args
        OPCODE      opcode      : 10;  	// This is the same as the index into the table
    };

	static OpInfoData table[];
private:
	OpInfoData* data;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\perfcounterdefs.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//-----------------------------------------------------------------------------
// PerfCounterDefs.h
//
// Internal Interface for CLR to use Performance counters
//-----------------------------------------------------------------------------

#ifndef _PerfCounterDefs_h_
#define _PerfCounterDefs_h_

//-----------------------------------------------------------------------------
// PerfCounters are only enabled if ENABLE_PERF_COUNTERS is defined.
// If we know we want them (such as in the impl or perfmon, then define this
// in before we include this header, else define this from the sources file.
//
// Note that WINCE (and others) don't use perfcounters, so to avoid a build
// break, you must wrap PerfCounter code (such as instrumenting in either 
// #ifdef or use the COUNTER_ONLY(x) macro (defined below)
// 


// Do some sanity checks/warnings:

#if !defined (ENABLE_PERF_COUNTERS)
// Counters Off: Make us very aware if PerfCounters are off.
#pragma message ("Notice: PerfCounters included, but turned off (ENABLE_PERF_COUNTERS undefined)")
#endif // !defined(ENABLE_PERF_COUNTERS)
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// Name of global IPC block
#define SHARED_PERF_IPC_NAME L"SharedPerfIPCBlock"


//-----------------------------------------------------------------------------
// Attributes for the IPC block
//-----------------------------------------------------------------------------
const PERF_ATTR_ON      = 0x0001;   // Are we even updating any counters?
const PERF_ATTR_GLOBAL  = 0x0002;   // Is this a global or private block?





//.............................................................................
// Tri Counter. Support for the common trio of counters (Total, Current, and 
// Instantaneous). This compiles to the same thing if we had them all separate,
// but it's a lot cleaner this way.
//.............................................................................
struct TRICOUNT
{
    DWORD Cur;                              // Current, has +, -
    DWORD Total;                            // Total, has  only +

    inline void operator++(int) {
        Cur ++; Total ++;
    }
    inline void operator--(int) {
        Cur --;
    }
    inline void operator+=(int delta) {
        Cur += delta; Total += delta;
    }
    inline void operator-=(int delta) {
        Cur -= delta;
    }
    inline void operator=(int delta) {
        Cur = delta;
        Total = delta;
    }
};

//.............................................................................
// Dual Counter. Support for the (Total and Instantaneous (rate)). Helpful in cases
// where the current value is always same as the total value. ie. the counter is never
// decremented.
// This compiles to the same thing if we had them separate, but it's a lot cleaner 
// this way.
//.............................................................................
struct DUALCOUNT
{
    DWORD Total;                            
    
    inline void operator++(int) {
        Total ++;
    }

    inline void operator+=(int delta) {
        Total += delta;
    }

};

//-----------------------------------------------------------------------------
// Format for the Perf Counter IPC Block
// IPC block is broken up into sections. This marks it easier to marshall
// into different perfmon objects
//
//.............................................................................
// Naming convention (by prefix):
// c - Raw count of something.
// cb- count of bytes
// time - time value.
// depth - stack depth
//-----------------------------------------------------------------------------

const int MAX_TRACKED_GENS = 3; // number of generations we track
#pragma pack(4)
struct Perf_GC
{
    size_t cGenCollections[MAX_TRACKED_GENS];// count of collects per gen
    size_t cbPromotedMem[MAX_TRACKED_GENS-1]; // count of promoted memory
    size_t cbPromotedFinalizationMem[MAX_TRACKED_GENS-1]; // count of memory promoted due to finalization
    size_t cGenHeapSize[MAX_TRACKED_GENS];  // size of heaps per gen
    size_t cTotalCommittedBytes;            // total number of committed bytes.
    size_t cTotalReservedBytes;             // bytes reserved via VirtualAlloc
    size_t cLrgObjSize;                     // size of Large Object Heap
    size_t cSurviveFinalize;                // count of instances surviving from finalizing
    size_t cHandles;                        // count of GC handles
    size_t cbAlloc;                         // bytes allocated
    size_t cbLargeAlloc;                    // bytes allocated for Large Objects
    size_t cInducedGCs;                     // number of explicit GCs
    DWORD  timeInGC;                        // Time in GC
    DWORD  timeInGCBase;                    // must follow time in GC counter
    
    size_t cPinnedObj;                      // # of Pinned Objects
    size_t cSinkBlocks;                     // # of sink blocks
};

#pragma pack(4)
struct Perf_Loading
{
// Loading
    TRICOUNT cClassesLoaded;
    TRICOUNT cAppDomains;                   // Current # of AppDomains
    TRICOUNT cAssemblies;                   // Current # of Assemblies.
    LONGLONG timeLoading;                   // % time loading
    DWORD cAsmSearchLen;                    // Avg search length for assemblies
    DUALCOUNT cLoadFailures;                // Classes Failed to load
    DWORD cbLoaderHeapSize;                 // Total size of heap used by the loader
    DUALCOUNT cAppDomainsUnloaded;          // Rate at which app domains are unloaded
};

#pragma pack(4)
struct Perf_Jit
{
// Jitting
    DWORD cMethodsJitted;                   // number of methods jitted
    TRICOUNT cbILJitted;                    // IL jitted stats
//    DUALCOUNT cbPitched;                    // Total bytes pitched
    DWORD cJitFailures;                     // # of standard Jit failures
    DWORD timeInJit;                        // Time in JIT since last sample
    DWORD timeInJitBase;                    // Time in JIT base counter
};

#pragma pack(4)
struct Perf_Excep
{
// Exceptions
    DUALCOUNT cThrown;                          // Number of Exceptions thrown
    DWORD cFiltersExecuted;                 // Number of Filters executed
    DWORD cFinallysExecuted;                // Number of Finallys executed
    DWORD cThrowToCatchStackDepth;          // Delta from throw to catch site on stack
};

#pragma pack(4)
struct Perf_Interop
{
// Interop
    DWORD cCCW;                             // Number of CCWs
    DWORD cStubs;                           // Number of stubs
    DWORD cMarshalling;                      // # of time marshalling args and return values.
    DWORD cTLBImports;                      // Number of tlbs we import
    DWORD cTLBExports;                      // Number of tlbs we export
};

#pragma pack(4)
struct Perf_LocksAndThreads
{
// Locks
    DUALCOUNT cContention;                      // # of times in AwareLock::EnterEpilogue()
    TRICOUNT cQueueLength;                      // Lenght of queue
// Threads
    DWORD cCurrentThreadsLogical;           // Number (created - destroyed) of logical threads 
    DWORD cCurrentThreadsPhysical;          // Number (created - destroyed) of OS threads 
    TRICOUNT cRecognizedThreads;            // # of Threads execute in runtime's control
};


// IMPORTANT!!!!!!!: The first two fields in the struct have to be together
// and be the first two fields in the struct. The managed code in ChannelServices.cs
// depends on this.
#pragma pack(4)
struct Perf_Contexts
{
// Contexts & Remoting
    DUALCOUNT cRemoteCalls;                 // # of remote calls    
    DWORD cChannels;                        // Number of current channels
    DWORD cProxies;                         // Number of context proxies. 
    DWORD cClasses;                         // # of Context-bound classes
    DWORD cObjAlloc;                        // # of context bound objects allocated
    DWORD cContexts;                        // The current number of contexts.
};

#pragma pack(4)
struct Perf_Security
{
// Security
    DWORD cTotalRTChecks;                   // Total runtime checks
    LONGLONG timeAuthorize;                 // % time authenticating
    DWORD cLinkChecks;                      // link time checks
    DWORD timeRTchecks;                     // % time in Runtime checks
    DWORD timeRTchecksBase;                 // % time in Runtime checks base counter
    DWORD stackWalkDepth;                   // depth of stack for security checks
};


// Note: PerfMonDll marshalls data out of here by copying a continous block of memory.
// We can still add new members to the subsections above, but if we change their
// placement in the structure below, we may break PerfMon's marshalling
#pragma pack(4)
struct PerfCounterIPCControlBlock
{   
// Versioning info
    WORD m_cBytes;      // size of this entire block
    WORD m_wAttrs;      // attributes for this block

// Counter Sections
    Perf_GC         m_GC;
    Perf_Contexts   m_Context;
    Perf_Interop    m_Interop;
    Perf_Loading    m_Loading;
    Perf_Excep      m_Excep;
    Perf_LocksAndThreads      m_LocksAndThreads;
    Perf_Jit        m_Jit;
    Perf_Security   m_Security;
};
#pragma pack()

#endif // _PerfCounterDefs_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\perflog.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//-----------------------------------------------------------------------------
// PerfLog.h
// Internal interface for logging perfromance data. Currently, two types of logging 
// formats are supported, Pretty print for stdout and perf automation friendly 
// format.
// The logging code is compiled in for non Golden builds but logs are generated only if
// PERF_OUTPUT environment variable is set. (This can be changed to a registry entry
// if we want perf logs on CE or other platforms that don't supprt env vars.))
//-----------------------------------------------------------------------------
#ifndef _PERFLOG_H_
#define _PERFLOG_H_

//-----------------------------------------------------------------------------
// Don't attempt to log perf data in Golden bits or on CE. If GOLDEN or CE is defined
// then explicitely undef ENABLE_PERF_LOG and warn the build.
#if !defined(GOLDEN) && !defined(_WIN64)
#define ENABLE_PERF_LOG
#else
#undef ENABLE_PERF_LOG
#pragma message ("Performance logs are disabled...")
#endif

// Also disable Perf logging code if there's a explicite define to do so in SOURCES
// file or another hdr file. This provides one point where all perf log related baggage
// can be avoided in the build.
#if defined(DISABLE_PERF_LOG)
#undef ENABLE_PERF_LOG
#endif


//-----------------------------------------------------------------------------
// PERFLOG is the public interface that should be used from EE source to log perf data.
// If 
#if !defined (ENABLE_PERF_LOG)
#define PERFLOG(x) 
#else
#define PERFLOG(x) do {if (PerfLog::PerfLoggingEnabled()) PerfLog::Log x;} while (0)
#endif

//=============================================================================
// ALL THE PERF LOG CODE IS COMPILED ONLY IF THE ENABLE_PERF_LOG WAS DEFINED.
#if defined (ENABLE_PERF_LOG)
//=============================================================================
//-----------------------------------------------------------------------------
// Static allocation of logging related memory, avoid dynamic allocation to
// skew perf numbers.
#define PRINT_STR_LEN 256 // Temp work space 
#define MAX_CHARS_UNIT 20
#define MAX_CHARS_DIRECTION 6

//-----------------------------------------------------------------------------
// ENUM of units for all kinds of perf data the we might get. Grow this as needed.
// **keep in sync ***  with the array of strings defined in PerfLog.cpp
typedef enum 
{
    COUNT = 0,
    SECONDS,
    BYTES,
    KBYTES,
    KBYTES_PER_SEC,
    CYCLES,
    MAX_UNITS_OF_MEASURE
} UnitOfMeasure;

//-----------------------------------------------------------------------------
// Widechar strings representing the above units. *** Keep in sync  *** with the 
// array defined in PerfLog.cpp
extern wchar_t wszUnitOfMeasureDescr[MAX_UNITS_OF_MEASURE][MAX_CHARS_UNIT];

//-----------------------------------------------------------------------------
// Widechar strings representing the "direction" property of above units. 
// *** Keep in sync  *** with the array defined in PerfLog.cpp
// "Direction" property is false if an increase in the value of the counter indicates
// a degrade.
// "Direction" property is true if an increase in the value of the counter indicates
// an improvement.
extern wchar_t wszIDirection[MAX_UNITS_OF_MEASURE][MAX_CHARS_DIRECTION];

//-----------------------------------------------------------------------------
// Namespace for perf log. Don't create perf log objects (private ctor).
class PerfLog
{
public:
    
    // Called during EEStartup
    static void PerfLogInitialize();
    
    // Called during EEShutdown
    static void PerfLogDone();
    
    // Perf logging is enabled if the env var PERF_LOG is set.
    static int PerfLoggingEnabled () { return m_fLogPerfData; }
    
    // Perf automation format is desired.
    static bool PerfAutomationFormat () { return m_perfAutomationFormat; }

    // CSV format is desired.
    static bool CommaSeparatedFormat () { return m_commaSeparatedFormat; }

    // Overloaded member functions to print different data types. Grow as needed.
    // wszName is the name of thet perf counter, val is the perf counter value,
    static void Log(wchar_t *wszName, __int64 val, UnitOfMeasure unit, wchar_t *wszDescr = 0);
    static void Log(wchar_t *wszName, double val, UnitOfMeasure unit, wchar_t *wszDescr = 0);
    static void Log(wchar_t *wszName, unsigned val, UnitOfMeasure unit, wchar_t *wszDescr = 0);
    static void Log(wchar_t *wszName, DWORD val, UnitOfMeasure unit, wchar_t *wszDescr = 0);
    
private:
    PerfLog();
    ~PerfLog();
    
    // Helper routine to hide some details of the perf automation
    static void OutToPerfFile(wchar_t *wszName, UnitOfMeasure unit, wchar_t *wszDescr = 0);
    
    // Helper routine to hide some details of output to stdout
    static void OutToStdout(wchar_t *wszName, UnitOfMeasure unit, wchar_t *wszDescr = 0);

    // Perf log initialized ?
    static bool m_perfLogInit;

    // Output in perf automation format ?
    static bool m_perfAutomationFormat;

    // Output in csv format ?
    static bool m_commaSeparatedFormat;

    // Temp storage to convert wide char to multibyte for file IO.
    static wchar_t m_wszOutStr_1[PRINT_STR_LEN];
    static wchar_t m_wszOutStr_2[PRINT_STR_LEN];
    static char m_szPrintStr[PRINT_STR_LEN];
    static DWORD m_dwWriteByte;

    // State of the env var PERF_OUTPUT
    static int m_fLogPerfData;

    // Open handle of the file which is used by the perf auotmation. (Currently 
    // its at C:\PerfData.data
    static HANDLE m_hPerfLogFileHandle;
};

#endif // ENABLE_PERF_LOG

#endif //_PERFLOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\profilepriv.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
//*****************************************************************************
#pragma once


// Forward declarations
class EEToProfInterface;
class Object;
struct ScanContext;

#ifdef PROFILING_SUPPORTED

#include "corprof.h"

/*
 * A struct to contain the status of profiling in the VM
 */
struct ProfControlBlock
{
    DWORD              dwSig;
    DWORD              dwControlFlags;
    EEToProfInterface *pProfInterface;

    // The following fields are for in-proc debugging
    CRITICAL_SECTION   crSuspendLock;
    DWORD              dwSuspendVersion;
    BOOL               fIsSuspended;
    BOOL               fIsSuspendSimulated;

    // This enumeration provides state for the inprocess debugging when
    // the runtime is suspended for a GC.  When the runtime is suspended
    // for a GC, then inprocState indicates whether or not inproc debugging
    // is allowed at this point or not.
    enum INPROC_STATE
    {
        INPROC_FORBIDDEN = 0,
        INPROC_PERMITTED = 1
    };

    INPROC_STATE       inprocState;

    FunctionEnter     *pEnter;
    FunctionEnter     *pLeave;
    FunctionEnter     *pTailcall;

    ProfControlBlock()
    {
        dwSig = 0;
        dwControlFlags = COR_PRF_MONITOR_NONE;
        pProfInterface = NULL;
        pEnter = NULL;
        pLeave = NULL;
        pTailcall = NULL;
        dwSuspendVersion = 1;
        fIsSuspended = FALSE;
        fIsSuspendSimulated = FALSE;
		inprocState = INPROC_PERMITTED;
    }
};

/*
 * Enumerates the various init states of profiling.
 */
enum ProfilerStatus
{
    profNone   = 0x0,               // No profiler running.
    profCoInit = 0x1,               // Profiler has called CoInit.
    profInit   = 0x2,               // profCoInit and profiler running.
    profInInit = 0x4                // the profiler is initializing
};

enum InprocStatus
{
    profThreadPGCEnabled    = 0x1,      // The thread had preemptive GC enabled
    profRuntimeSuspended    = 0x2       // The runtime was suspended for the profiler
};

extern ProfilerStatus     g_profStatus;
extern ProfControlBlock   g_profControlBlock;

//
// Use IsProfilerPresent() to check whether or not a CLR Profiler is
// attached.
//
#define IsProfilerPresent() (g_profStatus & (profInit | profInInit))
#define IsProfilerInInit() (g_profStatus & profInit)
#define CORProfilerPresent() IsProfilerPresent()
#define CORProfilerTrackJITInfo() \
    (IsProfilerPresent() && (g_profControlBlock.dwControlFlags & COR_PRF_MONITOR_JIT_COMPILATION))
#define CORProfilerTrackCacheSearches() \
    (IsProfilerPresent() && (g_profControlBlock.dwControlFlags & COR_PRF_MONITOR_CACHE_SEARCHES))
#define CORProfilerTrackModuleLoads() \
    (IsProfilerPresent() && (g_profControlBlock.dwControlFlags & COR_PRF_MONITOR_MODULE_LOADS))
#define CORProfilerTrackAssemblyLoads() \
    (IsProfilerPresent() && (g_profControlBlock.dwControlFlags & COR_PRF_MONITOR_ASSEMBLY_LOADS))
#define CORProfilerTrackAppDomainLoads() \
    (IsProfilerPresent() && (g_profControlBlock.dwControlFlags & COR_PRF_MONITOR_APPDOMAIN_LOADS))
#define CORProfilerTrackThreads() \
    (IsProfilerPresent() && (g_profControlBlock.dwControlFlags & COR_PRF_MONITOR_THREADS))
#define CORProfilerTrackClasses() \
    (IsProfilerPresent() && (g_profControlBlock.dwControlFlags & COR_PRF_MONITOR_CLASS_LOADS))
#define CORProfilerTrackGC() \
    (IsProfilerPresent() && (g_profControlBlock.dwControlFlags & COR_PRF_MONITOR_GC))
#define CORProfilerTrackAllocationsEnabled() \
    (IsProfilerPresent() && (g_profControlBlock.dwControlFlags & COR_PRF_ENABLE_OBJECT_ALLOCATED))
#define CORProfilerTrackAllocations() \
    (IsProfilerPresent() && CORProfilerTrackAllocationsEnabled() && \
    (g_profControlBlock.dwControlFlags & COR_PRF_MONITOR_OBJECT_ALLOCATED))
#define CORProfilerAllowRejit() \
    (IsProfilerPresent() && (g_profControlBlock.dwControlFlags & COR_PRF_ENABLE_REJIT))
#define CORProfilerTrackExceptions() \
    (IsProfilerPresent() && (g_profControlBlock.dwControlFlags & COR_PRF_MONITOR_EXCEPTIONS))
#define CORProfilerTrackCLRExceptions() \
    (IsProfilerPresent() && (g_profControlBlock.dwControlFlags & COR_PRF_MONITOR_CLR_EXCEPTIONS))
#define CORProfilerTrackTransitions() \
    (IsProfilerPresent() && (g_profControlBlock.dwControlFlags & COR_PRF_MONITOR_CODE_TRANSITIONS))
#define CORProfilerTrackEnterLeave() \
    (IsProfilerPresent() && (g_profControlBlock.dwControlFlags & COR_PRF_MONITOR_ENTERLEAVE))
#define CORProfilerTrackCCW() \
    (IsProfilerPresent() && (g_profControlBlock.dwControlFlags & COR_PRF_MONITOR_CCW))
#define CORProfilerTrackRemoting() \
    (IsProfilerPresent() && (g_profControlBlock.dwControlFlags & COR_PRF_MONITOR_REMOTING))
#define CORProfilerTrackRemotingCookie() \
    (IsProfilerPresent() && ((g_profControlBlock.dwControlFlags & COR_PRF_MONITOR_REMOTING_COOKIE) \
                             == COR_PRF_MONITOR_REMOTING_COOKIE))
#define CORProfilerTrackRemotingAsync() \
    (IsProfilerPresent() && ((g_profControlBlock.dwControlFlags & COR_PRF_MONITOR_REMOTING_ASYNC) \
                             == COR_PRF_MONITOR_REMOTING_ASYNC))
#define CORProfilerTrackSuspends() \
    (IsProfilerPresent() && (g_profControlBlock.dwControlFlags & COR_PRF_MONITOR_SUSPENDS))
#define CORProfilerDisableInlining() \
    (IsProfilerPresent() && (g_profControlBlock.dwControlFlags & COR_PRF_DISABLE_INLINING))
#define CORProfilerInprocEnabled() \
    (IsProfilerPresent() && (g_profControlBlock.dwControlFlags & COR_PRF_ENABLE_INPROC_DEBUGGING))
#define CORProfilerJITMapEnabled() \
    (IsProfilerPresent() && (g_profControlBlock.dwControlFlags & COR_PRF_ENABLE_JIT_MAPS))
#define CORProfilerDisableOptimizations() \
    (IsProfilerPresent() && (g_profControlBlock.dwControlFlags & COR_PRF_DISABLE_OPTIMIZATIONS))

#endif // PROFILING_SUPPORTED

// This is the helper callback that the gc uses when walking the heap.
BOOL HeapWalkHelper(Object* pBO, void* pv);
void ScanRootsHelper(Object*& o, ScanContext *pSC, DWORD dwUnused);
BOOL AllocByClassHelper(Object* pBO, void* pv);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\persistedstore.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
 *
 * Purpose: Structure of the Persisted Store
 *
 * Author: Shajan Dasan
 * Date:  Feb 14, 2000
 *
 ===========================================================*/

#pragma once

// non-standard extension: 0-length arrays in struct
#pragma warning(disable:4200)
#pragma pack(push, 1)

typedef unsigned __int8     PS_OFFSET8;
typedef unsigned __int8     PS_SIZE8;

typedef unsigned __int16    PS_OFFSET16;
typedef unsigned __int16    PS_SIZE16;

typedef unsigned __int32    PS_OFFSET32;
typedef unsigned __int32    PS_SIZE32;

typedef unsigned __int64    PS_OFFSET64;
typedef unsigned __int64    PS_SIZE64;

#if (PS_STORE_WORD_LENGTH == 8)
typedef PS_OFFSET8  PS_OFFSET;
typedef PS_SIZE8    PS_SIZE;
#elif (PS_STORE_WORD_LENGTH == 16)
typedef PS_OFFSET16 PS_OFFSET;
typedef PS_SIZE16   PS_SIZE;
#elif (PS_STORE_WORD_LENGTH == 32)
typedef PS_OFFSET32 PS_OFFSET;
typedef PS_SIZE32   PS_SIZE;
#else   // 64 bit is the default settings
typedef PS_OFFSET64 PS_OFFSET;
typedef PS_SIZE64   PS_SIZE;
#endif

typedef unsigned __int64    PS_HANDLE;

// @Todo : define a full header with all 8/16/32/64 version of all structs when 
// we have migration tools where we port from one HANDLE size to another

#define PS_MAJOR_VERSION    0x0
#define PS_MINOR_VERSION    0x4
#define PS_VERSION_STRING   "0.4"
#define PS_VERSION_STRING_L L"0.4"

#define PS_TABLE_VERSION    0x1

#define PS_SIGNATURE        0x1A5452202B4D4F43I64

#define PS_DEFAULT_BLOCK_SIZE   0x4000  // For physical store
#define PS_INNER_BLOCK_SIZE     0x100   // For logical store

typedef unsigned __int64    QWORD;

// All blocks (used and free) start with a header and end with a footer.
// PS_HEADER which will be the first block in the stream is excempted from
// this rule. The least significant bit of Size is used as a flag for 
// Used / Free memory

// Free block will start with PS_MEM_FREE header and end with a PS_MEM_FOOTER
typedef struct
{
    PS_SIZE   sSize;            // Size includes size of this header
                                // Last bit of sSize will be 0
    PS_OFFSET ofsNext;          // Next free block in the sorted linked list
    PS_OFFSET ofsPrev;          // Previous free block in the sorted linked list
} PS_MEM_FREE, *PPS_MEM_FREE;

// Used blocks (except the one that contains PS_HEADER) start with this 
// header and ends with PS_MEM_FOOTER
// Used & Free blocks (except PS_HEADER) ends with PS_MEM_FOOTER
typedef struct
{
    PS_SIZE     sSize;          // Size includes size of header and footer
                                // Last bit of sSize will be 1
                                // This bit should be ignored
}   PS_MEM_USED,    *PPS_MEM_USED, 
    PS_MEM_HEADER,  *PPS_MEM_HEADER, 
    PS_MEM_FOOTER,  *PPS_MEM_FOOTER;

#define PS_MEM_IN_USE   1
#define PS_IS_USED(x)   (((PPS_MEM_HEADER)(x))->sSize & PS_MEM_IN_USE)
#define PS_IS_FREE(x)   (PS_IS_USED(x) == 0)
#define PS_SET_USED(x)  (((PPS_MEM_HEADER)(x))->sSize |=  PS_MEM_IN_USE)
#define PS_SET_FREE(x)  (((PPS_MEM_HEADER)(x))->sSize &= ~PS_MEM_IN_USE)

#define PS_SIZE(x)      (((PPS_MEM_HEADER)(x))->sSize & ~PS_MEM_IN_USE)

#define PS_HDR_TO_FTR(x) \
    (PPS_MEM_FOOTER)((PBYTE)(x) + PS_SIZE(x) - sizeof(PS_MEM_FOOTER))
#define PS_FTR_TO_HDR(x) \
    (PPS_MEM_HEADER)((PBYTE)(x) - PS_SIZE(x) + sizeof(PS_MEM_FOOTER))

// Store streams start with a PS_HEADER
typedef struct
{
    QWORD       qwSignature;    // A fast check to reject bad streams
    DWORD       dwSystemFlag;   // Used by the system
    DWORD       dwPlatform;     // The platform on which this store was created
    DWORD       dwBlockSize;    // Allocation in multiples of BlockSize bytes
    WORD        wMajorVersion;  // A major version mismatch will reject file
    WORD        wMinorVersion;  // Minor version changes are not rejected
    PS_OFFSET   ofsHandleTable; // Offset to the handle table
    PS_HANDLE   hAppData;       // Set and used by applications
    PS_MEM_FREE sFreeList;      // Head node for doubly linked free blocks list
    WORD        wReserved[20];  // For future use, must be set to 0

    // System flags used in dwSystemFlag

    #define     PS_OFFSET_SIZE_8    1
    #define     PS_OFFSET_SIZE_16   2
    #define     PS_OFFSET_SIZE_32   3 
    #define     PS_OFFSET_SIZE_64   4
    #if (PS_STORE_WORD_LENGTH == 8)
    #define     PS_OFFSET_SIZE      PS_OFFSET_SIZE_8
    #elif (PS_STORE_WORD_LENGTH == 16)
    #define     PS_OFFSET_SIZE      PS_OFFSET_SIZE_16
    #elif (PS_STORE_WORD_LENGTH == 32)
    #define     PS_OFFSET_SIZE      PS_OFFSET_SIZE_32
    #else
    #define     PS_OFFSET_SIZE      PS_OFFSET_SIZE_64
    #endif

    // Platform flags used in dwPlatform

    #define     PS_PLATFORM_X86     1
    #define     PS_PLATFORM_ALPHA   2
    #define     PS_PLATFORM_SHX     3
    #define     PS_PLATFORM_PPC     4

    #define     PS_PLATFORM_NT      (1<<4)
    #define     PS_PLATFORM_9x      (2<<4)
    #define     PS_PLATFORM_CE      (3<<4)

    #define     PS_PLATFORM_8       (1<<8)
    #define     PS_PLATFORM_16      (2<<8)
    #define     PS_PLATFORM_32      (4<<8)
    #define     PS_PLATFORM_64      (8<<8)

} PS_HEADER, *PPS_HEADER;

// Size followed by sSize number of bytes
typedef struct
{
    PS_SIZE sSize;              // Size does not include the sizeof(sSize)
    BYTE    bData[];            // Raw data goes here
} PS_RAW_DATA, *PP_RAW_DATA;

// Size followed by wSize number of bytes
typedef struct
{
    DWORD dwSize;               // Size does not include the sizeof(dwSize)
    BYTE  bData[];              // Raw data goes here
} PS_RAW_DATA_DWORD_SIZE, *PP_RAW_DATA_DWORD_SIZE;

// Size followed by wSize number of bytes
typedef struct
{
    WORD wSize;                 // Size does not include the sizeof(wSize)
    BYTE bData[];               // Raw data goes here
} PS_RAW_DATA_WORD_SIZE, *PP_RAW_DATA_WORD_SIZE;

// Size followed by bSize number of bytes
typedef struct
{
    BYTE bSize;                 // Size does not include the sizeof(bSize)
    BYTE bData[];               // Raw data goes here
} PS_RAW_DATA_BYTE_SIZE, *PP_RAW_DATA_BYTE_SIZE;

// The size of the size field in PS_RAW_XXX structures
#define PS_SIZEOF_PS_SIZE     sizeof(PS_SIZE)
#define PS_SIZEOF_BYTE        sizeof(BYTE)
#define PS_SIZEOF_WORD        sizeof(WORD)
#define PS_SIZEOF_DWORD       sizeof(DWORD)
#define PS_SIZEOF_NUM_BITS    3

// A linked list representing an array
typedef struct
{
    PS_HANDLE hNext;        // Next in node in the list
    DWORD     dwValid;      // Number of valid entries in this array
    BYTE      bData[];      // The array
} PS_ARRAY_LIST, *PPS_ARRAY_LIST;

// A table is a linked list of table blocks.
// All table blocks start with a PS_TABLE_HEADER
// The rows of a table follow the table header

typedef struct
{
    union {
        DWORD   dwSystemFlag;   // Set by the system unused flags are set to 0

        struct {
            unsigned long Version            : 4;   // Version Number
            unsigned long TableType          : 4;   // PS_HAS_KEY, 
                                                    // PS_SORTED_BY_KEY, 
                                                    // PS_HASH_TABLE...
            union {
                unsigned long KeyLength      : PS_SIZEOF_NUM_BITS;   
                unsigned long SizeOfLength   : PS_SIZEOF_NUM_BITS;
                                                    // size of count field for
                                                    // blob pool
            };

            unsigned long fHasMinMax         : 1;

            unsigned long fHasUsedRowsBitmap : 1;   // UsedRowsBitmap follows 
                                                    // HasMin (if present)
            // Add new fields here.. MSBs of the DWORD will get the new bits
        } Flags;
    };

    #define PS_GENERIC_TABLE 1  // No special semantics
    #define PS_HAS_KEY       2  // Each row has a unique key
    #define PS_SORTED_BY_KEY 3  // Key is unique and rows are sorted by key
    #define PS_HASH_TABLE    4  // Table represents a hash table
    #define PS_BLOB_POOL     5  // Table represents a blob pool
    #define PS_ARRAY_TABLE   6  // linked list of fixed sized arrays, each
                                // fixed size array being a row in the table


    // SORTED_BY_KEY is a special case of HAS_KEY
    // HASH_TABLE is a special case of SORTED_BY_KEY

    PS_HANDLE  hNext;           // If the table does not fit in this block,
                                // follow this pointer to reach the next block. 
                                // Set to 0 if no more blocks.

    PS_HANDLE  hAppData;        // Application defined data

    union {
        DWORD dwReserved[8];    // size of this union.. unused bits must be 0

        struct {

            // The wRows and wRowSize fields are shared between
            // ArrayTable and Table structures. Do not move these fields

            WORD  wRows;        // The number of rows in this block of the table
                                // including unused rows.
            WORD  wRowSize;     // Size of one row in bytes
            DWORD dwMin;        // min key / hash value
            DWORD dwMax;        // max key / hash value
                                // Min / Max are valid only if fHasMinMax is set
        } Table;

        // TableType is PS_BLOB_POOL
        struct {
            PS_SIZE   sFree;    // Free space available
            PS_HANDLE hFree;    // Next free block
        } BlobPool;

        // TableType is PS_ARRAY_TABLE
        struct {

            // The wRows and wRowSize fields are shared between
            // ArrayTable and Table structures. Do not move these fields

            WORD wRows;         // The number of rows in this block of the table
                                // including unused rows.
            WORD wRowSize;      // Size of one row in bytes
                                // (nRec * RecSize + sizeof(PS_HANDLE)
            WORD wRecsInRow;    // Number of records in one row
            WORD wRecSize;      // sizeof one record
        } ArrayTable;
    };

    // If fHasUsedRowsBitmap is set PS_USED_ROWS_BITMAP is put here
    // If fHasAppData is set PS_RAW_DATA is put here
    // Actual Rows Start here. 

} PS_TABLE_HEADER, *PPS_TABLE_HEADER;

// USED_ROWS_BITMAP will follow TABLE_HEADER, [TABLE_RANGE]
typedef struct
{
    DWORD   dwUsedRowsBitmap[]; // The length of this array is the minimum 
                                // number of DWORDS required to represent each
                                // row in the block of this table, one bit per 
                                // row. Bit set to 1 means Row is occupied.
} PS_USED_ROWS_BITMAP, *PPS_USED_ROWS_BITMAP;

// Given the number of bits (n), gives the minimum number of DWORDS 
// required to represent n bits as an array of DWORDS

#define NUM_DWORDS_IN_BITMAP(nBits) (((nBits) + 31) >> 5)

// Sets the given bit in an array of DWORDS

#define SET_DWORD_BITMAP(dwBitmapArray, nPos) \
        (dwBitmapArray[((nPos) >> 5)] |= (1 << ((nPos) & 31)))

// Checks if the given bit is set

#define IS_SET_DWORD_BITMAP(dwBitmapArray, nPos) \
        (dwBitmapArray[((nPos) >> 5)] & (1 << ((nPos) & 31)))

#pragma pack(pop)
#pragma warning(default:4200)

// PPS_ALLOC provides a way for Applications to allocate more space at the
// end of pByte[] or allocate a new buffer with size *psSize + sAlloc
// and copy sSizeUsed bytes of pByte on to the new location and update pByte.

typedef HRESULT (*PPS_ALLOC)
                       (void    *pvHandle,  // Application supplied handle
                        void   **ppv,       // allocated memory     [in / out]
                        void   **ppStream,  // the stream           [in / out]
                        PS_SIZE *psSize,    // bytes in the stream  [in / out]
                        PS_SIZE  sAlloc);   // additional bytes req [in]

class PersistedStore
{
public:

    // wszName / wszFileName will be cached in the instance of this class if 
    // PS_MAKE_COPY_OF_STRING is not set in the flags.
    // pAlloc is used to allocate more space at the end of the stream

    PersistedStore(WCHAR *wszFileName, WORD wFlags);

    PersistedStore (WCHAR      *wszName,    // Unique name on this machine
                    BYTE       *pByte,      // pointer to a byte stream
                    PS_SIZE     sSize,      // number of bytes in the stream
                    PPS_ALLOC   psAlloc,    // Allocation call back function
                    void       *pvMemHandle,// Handle to be passed back to the
                                            // Alloc function
                    WORD        wFlags);    // PS_MAKE_COPY_OF_STRING... etc

    #define PS_MAKE_COPY_OF_STRING      1   // Makes a copy of Name
    #define PS_OPEN_WRITE               2   // Open for Read / Write
    #define PS_CREATE_FILE_IF_NECESSARY 4   // Creates the store if necessary
    #define PS_VERIFY_STORE_HEADER      8   // Checks signature and version

    ~PersistedStore();

    HRESULT Init();     // Creates the file if necessary and creates PS_HEADER
    HRESULT Map();      // Maps the store file into memory
    void    Unmap();    // Unmaps the store file from memory
    void    Close();    // Close the store file, and file mapping

    HRESULT Alloc(PS_SIZE sSize, void **ppv); // [out] ppv

    void    Free(void* pv);
    void    Free(PS_HANDLE hnd);

    HRESULT SetAppData(PS_HANDLE hnd);  // Set HEADER.hAppData
    HRESULT GetAppData(PS_HANDLE *phnd);// Get HEADER.hAppData

    void*     HndToPtr(PS_HANDLE hnd);  // Converts HANDLE to pointer
    PS_HANDLE PtrToHnd(void *pv);       // Converts pointer to HANDLE

    bool IsValidPtr(void *pv);          // pointer is within the file
    bool IsValidHnd(PS_HANDLE hnd);     // HANDLE is < file length

    HRESULT Lock();         // Machine wide Lock the store 
    void    Unlock();       // Unlock the store

    WCHAR* GetName();       // Returns the actual name pointer
    WCHAR* GetFileName();   // Returns the file name

private:

    void    SetName(WCHAR *wszName);        // Allocates memory if necessary
    HRESULT Create();                       // Create PS_HEADER and allocate
                                            // space if necessary
    HRESULT VerifyHeader();                 // Checks the signature and version
    HRESULT GetFileSize(PS_SIZE *psSize);   // Updates m_Size

    // Allocates more space in a memory mapped file.
    HRESULT AllocMemoryMappedFile  (PS_SIZE sSizeRequested, // [in]
                                    void    **ppv);         // [out]

    void*     OfsToPtr(PS_OFFSET ofs);      // Converts OFFSET to pointer
    PS_OFFSET PtrToOfs(void *pv);           // Converts pointer to OFFSET

private:

    PS_SIZE         m_sSize;        // Number of bytes in the stream

    union {
        PBYTE       m_pData;        // The start of the stream
        PPS_HEADER  m_pHdr;
    };

    PPS_ALLOC       m_pAlloc;       // The allocation call back function
    void           *m_pvMemHandle;  // Application supplied handle used for
                                    // Allocating more space
    DWORD           m_dwBlockSize;  // Allocation in mul of BlockSize bytes

    // Some of the items below are not applicable to memory streams
    WCHAR          *m_wszFileName;  // The file name
    HANDLE          m_hFile;        // File handle for the file
    HANDLE          m_hMapping;     // File mapping for the memory mapped file

    // members used for synchronization 
    WCHAR          *m_wszName;      // The name of the mutex object
    HANDLE          m_hLock;        // Handle to the Mutex object

#ifdef _DEBUG
    DWORD           m_dwNumLocks;   // The number of locks owned by this thread
#endif

    WORD            m_wFlags;       // PS_MAKE_COPY_OF_STRING : alloc m_szName 
                                    // PS_CREATE_FILE_IF_NECESSARY
                                    // PS_OPEN_WRITE : Open for Read / Write
                                    // PS_VERIFY_STORE_HEADER : verify version
private:
#ifdef _DEBUG

    // Pointers handed out by persisted store could become invalid if an
    // alloc happens after xxToPtr() and before it is used.
    // When the use of a ptr is over, call PS_DONE_USING_PTR(ps, ptr);
    // Use PS_DONE_USING_PTR_ if the ptr is needed in the next instruction.
    // Limit the use of PS_DONE_USING_PTR_
    // Do not make a copy of the pointer to avoid an assert, this will hide
    // invalid pointer bugs.

    DWORD           m_dwNumLivePtrs;

public:
    void DoneUseOfPtr(void **pp, bool fInvalidatePtr);

    void AssertNoLivePtrs();

#define PS_DONE_USING_PTR(ps, ptr) (ps)->DoneUseOfPtr((void **)&(ptr), true);
#define PS_DONE_USING_PTR_(ps, ptr) (ps)->DoneUseOfPtr((void **)&(ptr), false);
#define PS_REQUIRES_ALLOC(ps) (ps)->AssertNoLivePtrs();

#else

#define PS_DONE_USING_PTR(ps, ptr)
#define PS_DONE_USING_PTR_(ps, ptr)
#define PS_REQUIRES_ALLOC(ps)

#endif
};

class PSBlock
{
public:
    PSBlock(PersistedStore *ps, PS_HANDLE hnd) 
        :  m_ps(ps), m_hnd(hnd) {}

    PS_HANDLE GetHnd() { return m_hnd; }
    void      SetHnd(PS_HANDLE hnd) { m_hnd = hnd; }

protected:

    PersistedStore *m_ps;
    PS_HANDLE       m_hnd;
};

// Length of the blob is not persisted in PSBlobPool.
class PSBlobPool : public PSBlock
{
public:
    PSBlobPool(PersistedStore *ps, PS_HANDLE hnd)
        : PSBlock(ps, hnd) {}

    HRESULT Create (PS_SIZE   sData,      // Initial Size of the blob pool
                    PS_HANDLE hAppData);  // [in] Application Data, can be 0

    HRESULT Insert(PVOID pv, DWORD cb, PS_HANDLE *phnd);
};

class PSTable : public PSBlock
{
public:
    PSTable(PersistedStore *ps, PS_HANDLE hnd) 
        : PSBlock(ps, hnd) {}

    HRESULT HandleOfRow(WORD wRow, PS_HANDLE *phnd);
    virtual PS_SIZE SizeOfHeader();
};

/*
    Generic tables have a bitmap which keeps track of what rows are free / used.
    When the table is full, an insert will cause a new table to be created and
    will be added to the end of the linked list of tables.
 */

class PSGenericTable : public PSTable
{
public:
    PSGenericTable(PersistedStore *ps, PS_HANDLE hnd)
        : PSTable(ps, hnd) {}

    virtual PS_SIZE SizeOfHeader();

    HRESULT Create (WORD      nRows,      // Number of rows
                    WORD      wRecSize,   // Size of one record
                    PS_HANDLE hAppData);  // [in] can be 0

    // The number of bytes copied will be Table.wRowSize
    HRESULT Insert(PVOID pv, PS_HANDLE *phnd);
};

/*
    ArrayTables are made of a linked list of fixed length arrays.
    Each row in the table is an array (with a fixed max # of records / row).

    The main use of this table is to represent a set of arrays (or one large 
    array). This can be used to represent a hash table.

    Eg: An array table with 3 elements per array block

    -----------------------------------------------------------------------
    ArrayTable (at HANDLE 100) : (wRows, wRowSize=3*wRecSize + sizeof(hdr), 
                                    wRecInRow=3, wRecSize, hNext=500)
    -----------------------------------------------------------------------
    ...
    ...
    Row #10 (at HANDLE 300) : [x][y][z][nValid=3, hNext=700]
    ...
    ...
    Row #25 (at HANDLE 370) : [a][b][*][nValid=2, hNext=0]
    ...

    -----------------------------------------------------------
    GenericTable (at HANDLE 500) : (wRows, wRowSize, hNext=0)
    -----------------------------------------------------------
    ...
    ...
    (at HANDLE 700) : [p][q][*][nValid=2, hNext 0]
    ...
    ...


    Logical view of the Array starting at row #10 of the table :

    [x][y][z][p][q]

    The number of nodes in the first TableBlock is fixed.

    hNext will form a linked list of spill over tables, which are
    GenericTables

 */

class PSArrayTable : public PSTable
{
public:
    PSArrayTable(PersistedStore *ps, PS_HANDLE hnd)
        : PSTable(ps, hnd) {}

    HRESULT Create (WORD      wRows,     // Number of rows
                    WORD      wRecInRow, // records in one row
                    WORD      wRecSize,  // Size of one record
                    PS_HANDLE hAppData); // [in] can be 0

    // Insert one Record in the linked list array starting at wRow
    // The number of bytes copied from pb is ArrayTable.sRecSize
    // For a Table with only one Row, wRow will be 0
    HRESULT Insert(PVOID pv, WORD wRow);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\prettyprintsig.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// This code supports formatting a method and it's signature in a friendly
// and consistent format.
//
// Microsoft Confidential.
//*****************************************************************************
#ifndef __PrettyPrintSig_h__
#define __PrettyPrintSig_h__

#include <cor.h>

class CQuickBytes;


LPCWSTR PrettyPrintSig(
	PCCOR_SIGNATURE typePtr,			// type to convert, 	
	unsigned	typeLen,				// length of type
	LPCWSTR 	name,					// can be L"", the name of the method for this sig	
	CQuickBytes *out,					// where to put the pretty printed string	
	IMetaDataImport *pIMDI);			// Import api to use.

struct IMDInternalImport;
HRESULT PrettyPrintSigInternal(         // S_OK or error.
	PCCOR_SIGNATURE typePtr,			// type to convert, 	
	unsigned	typeLen,				// length of type
	LPCSTR 	name,					    // can be "", the name of the method for this sig	
	CQuickBytes *out,					// where to put the pretty printed string	
	IMDInternalImport *pIMDI);			// Import api to use.


#endif // __PrettyPrintSig_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\posterror.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// UtilCode.h
//
// Utility functions implemented in UtilCode.lib.
//
//*****************************************************************************
#ifndef __PostError_h__
#define __PostError_h__

#include "switches.h"

#pragma once

#define INITPUBLICMETHODFULL(piid, progid)	SSAutoEnter sSSAutoEnter(piid, progid)
#define INITPUBLICMETHOD(piid)	SSAutoEnter sSSAutoEnter(piid, _GetProgID())

// Index for this process for thread local storage.
extern DWORD g_iTlsIndex;


//*****************************************************************************
// This class is used to automatic construction/destruction on entry and exit
// of every public function.  This class retrieves the pointer to the ref count
// for this thread on the ctor, and uses this same value on the dtor, so it
// must never be possible for the dtor to execute on a different thread than
// the ctor (don't know a way you could make that happen, but then again...).
//*****************************************************************************
class /*EXPORTCLASS */ SSAutoEnter
{
public:
//*****************************************************************************
// Expand on every public entry point for the engine.  It will clear setup for
// error handling on exit.
//*****************************************************************************
	SSAutoEnter::SSAutoEnter(
		const IID	*psIID,					// Interface we are in.
		LPCWSTR		szProgID) :				// Prog id of class causing error.
		m_psIID(psIID),
		m_szProgID(szProgID)
	{
		_ASSERTE(g_iTlsIndex != 0xffffffff);

		// Get the ref count, create one if required.  Out of mem on a 4 byte
		// value is ignored.
		if ((m_pcRef = (long *) TlsGetValue(g_iTlsIndex)) == 0)
			m_pcRef = InitSSAutoEnterThread();

		// Increment the ref count.
		++(*m_pcRef);
	}

//*****************************************************************************
// If this is the last function on the call stack, and an error occured, then
// update the error information with the current IID and progid.  Errors are
// indicated by setting the highest order bit in PostError.
//*****************************************************************************
	~SSAutoEnter()
	{
		if (m_pcRef)
		{
			if (--(*m_pcRef)  == 0x80000000)
			{
				*m_pcRef = 0;
				UpdateError();
			}
		}
	}

private:
	// Disable default ctor.
	SSAutoEnter() { };

	void UpdateError();
	long * InitSSAutoEnterThread();

private:
	const IID	*m_psIID;				// Interface we are in.
	LPCWSTR		m_szProgID;				// ProgID of class.
	long		*m_pcRef;				// Pointer to ref count.
};


//*****************************************************************************
// Call at DLL startup to init the error system.
//*****************************************************************************
 void InitErrors(DWORD *piTlsIndex);


//*****************************************************************************
// Call at DLL shutdown to free TLS.
//*****************************************************************************
 void UninitErrors();

//*****************************************************************************
// Call at DLL shutdown to free memory allocated my CCompRC.
//*****************************************************************************
#ifdef SHOULD_WE_CLEANUP
 void ShutdownCompRC();
#endif /* SHOULD_WE_CLEANUP */

//*****************************************************************************
// This function will post an error for the client.  If the LOWORD(hrRpt) can
// be found as a valid error message, then it is loaded and formatted with
// the arguments passed in.  If it cannot be found, then the error is checked
// against FormatMessage to see if it is a system error.  System errors are
// not formatted so no add'l parameters are required.  If any errors in this
// process occur, hrRpt is returned for the client with no error posted.
//*****************************************************************************
 HRESULT _cdecl PostError(				// Returned error.
	HRESULT		hrRpt,					// Reported error.
	...);								// Error arguments.

//*****************************************************************************
// This function formats an error message, but doesn't fill the IErrorInfo.
//*****************************************************************************
HRESULT _cdecl FormatRuntimeErrorVa(        
    WCHAR       *rcMsg,                 // Buffer into which to format.         
    ULONG       cchMsg,                 // Size of buffer, characters.          
    HRESULT     hrRpt,                  // The HR to report.                    
    va_list     marker);                // Optional args.                       

HRESULT _cdecl FormatRuntimeError(
    WCHAR       *rcMsg,                 // Buffer into which to format.
    ULONG       cchMsg,                 // Size of buffer, characters.
    HRESULT     hrRpt,                  // The HR to report.
    ...);                                // Optional args.

#endif // __PostError_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\querybinding.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//****************************************************************************
//  File: ColBind.CPP
//  Notes:
//   Query binding macros for internal use in mscoree.
//****************************************************************************

#ifndef lengthof
#define lengthof(x) (sizeof(x)/sizeof(x[0]))
#endif

// Binding info for SetColumns
#define DECLARE_QUERY_BINDING__(n, prefix)											\
	int			prefix##_bind_cColumns(0);			/* Count of the columns.	*/	\
	ULONG		prefix##_bind_iColumn[n];			/* Most recent column.		*/	\
	DBCOMPAREOP	prefix##_bind_rgfCompare[n];		/* Comparison operations	*/	\
	const void*	prefix##_bind_rpvData[n];			/* The data.				*/	\
	ULONG		prefix##_bind_rcbData[n];			/* Size of the data.		*/	\
	DBTYPE		prefix##_bind_rType[n];				/* The types				*/

#define BIND_QUERY_COLUMN__(column, type, addr, size, dbop, prefix)					\
{																					\
	_ASSERTE(prefix##_bind_cColumns < lengthof(prefix##_bind_rType));				\
	prefix##_bind_iColumn[prefix##_bind_cColumns] = column;							\
	prefix##_bind_rType[prefix##_bind_cColumns] = type;								\
	prefix##_bind_rpvData[prefix##_bind_cColumns] = addr;							\
	prefix##_bind_rcbData[prefix##_bind_cColumns] = size;							\
	prefix##_bind_rgfCompare[prefix##_bind_cColumns] = dbop;						\
	++prefix##_bind_cColumns;														\
}

#define QUERY_BOUND_COLUMNS__(table, records, numrecords, cursor, result, prefix)	\
	QueryByColumns(																	\
		table,																		\
		NULL,																		\
		prefix##_bind_cColumns,														\
		prefix##_bind_iColumn,														\
		prefix##_bind_rgfCompare,													\
		prefix##_bind_rpvData,														\
		prefix##_bind_rcbData,														\
		prefix##_bind_rType,														\
		records,																	\
		numrecords,																	\
		cursor,																		\
		result)


#define NUM_BOUND_QUERY_COLUMNS__(prefix) prefix##_bind_cColumns

#define UNBIND_QUERY_COLUMNS__(prefix)												\
	prefix##_bind_cColumns = 0;														\

#define DECLARE_QUERY_BINDING(n) DECLARE_QUERY_BINDING__(n,qdef)
#define BIND_QUERY_COLUMN(c,t,a,d,s) BIND_QUERY_COLUMN__(c,t,a,d,s,qdef)
#define NUM_BOUND_QUERY_COLUMNS() NUM_BOUND_QUERY_COLUMNS__(qdef)
#define UNBIND_QUERY_COLUMNS() UNBIND_QUERY_COLUMNS__(qdef)
#define QUERY_BOUND_COLUMNS(table, records, numrecords, cursor, result)				\
	QUERY_BOUND_COLUMNS__(table, records, numrecords, cursor, result, qdef)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\pesectionman.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// Section Manager for portable executables
// Common to both Memory Only and Static (EXE making) code

#ifndef PESectionMan_H
#define PESectionMan_H

#include <CrtWrap.h>

#include <windows.h>

#include "CeeGen.h"
#include "BlobFetcher.h"

class PESection;
struct PESectionReloc;

struct _IMAGE_SECTION_HEADER;

class PESectionMan
{
public:
	HRESULT Init();
	HRESULT Cleanup();

    // Finds section with given name or creates a new one
    HRESULT getSectionCreate(
		const char *name, unsigned flags, 
		PESection **section);

    // Since we allocate, we must delete (Bug in VC, see knowledge base Q122675)
	void sectionDestroy(PESection **section);

	// Apply all the relocs for in memory conversion
	void applyRelocs(CeeGenTokenMapper *pTokenMapper);

    HRESULT cloneInstance(PESectionMan *destination);

private:

    // Create a new section
	HRESULT newSection(const char* name, PESection **section,
						unsigned flags=sdNone, unsigned estSize=0x10000, 
						unsigned estRelocs=0x100);

    // Finds section with given name.  returns 0 if not found
    PESection* getSection(const char* name);        

protected:
// Keep proctected & no accessors, so that Derived class PEWriter 
// is the ONLY one with access
	PESection** sectStart;
	PESection** sectCur;
    PESection** sectEnd;
};

/***************************************************************/
class PESection : public CeeSectionImpl {
  public:
	// bytes in this section at present
	unsigned dataLen();		

	// Apply all the relocs for in memory conversion
	void applyRelocs(CeeGenTokenMapper *pTokenMapper);
	
	// get a block to write on (use instead of write to avoid copy)
    char* getBlock(unsigned len, unsigned align=1);

	// make the section the min of the curren len and 'newLen' 
    HRESULT truncate(unsigned newLen);                              

	// writes 'val' (which is offset into section 'relativeTo')
	// and adds a relocation fixup for that section
    void writeSectReloc(unsigned val, CeeSection& relativeTo, 
				CeeSectionRelocType reloc = srRelocHighLow, CeeSectionRelocExtra *extra=0);
                        
    // Indicates that the DWORD at 'offset' in the current section should
    // have the base of section 'relativeTo added to it
    HRESULT addSectReloc(unsigned offset, CeeSection& relativeTo, 
							CeeSectionRelocType reloc = srRelocHighLow, CeeSectionRelocExtra *extra=0);

    HRESULT addSectReloc(unsigned offset, PESection *relativeTo, 
							CeeSectionRelocType reloc = srRelocHighLow, CeeSectionRelocExtra *extra=0);

    // Add a base reloc for the given offset in the current section
    HRESULT addBaseReloc(unsigned offset, CeeSectionRelocType reloc = srRelocHighLow, CeeSectionRelocExtra *extra = 0);

    // section name
    unsigned char *name() {
		return (unsigned char *) m_name;
	}

    // section flags
    unsigned flags() {
		return m_flags;
	}

	// virtual base
	unsigned getBaseRVA() {
		return m_baseRVA;
	}
	  
	// return the dir entry for this section
	int getDirEntry() {
		return dirEntry;
	}
	// this section will be directory entry 'num'
    HRESULT directoryEntry(unsigned num);

	// Indexes offset as if this were an array
	virtual char * computePointer(unsigned offset) const;

	// Checks to see if pointer is in section
	virtual BOOL containsPointer(char *ptr) const;

	// Computes an offset as if this were an array
	virtual unsigned computeOffset(char *ptr) const;

    HRESULT cloneInstance(PESection *destination);

    ~PESection();
private:

	// purposely not defined, 
	PESection();			

	// purposely not defined,
    PESection(const PESection&);                     

	// purposely not defined,
    PESection& operator=(const PESection& x);        

	// this dir entry points to this section
	int dirEntry; 			

protected:
	friend class PEWriter;
	friend class PEWriterSection;
	friend class PESectionMan;

    PESection(const char* name, unsigned flags, 
					unsigned estSize, unsigned estRelocs);

    // Blob fetcher handles getBlock() and fetching binary chunks.
	CBlobFetcher m_blobFetcher;
    
    PESectionReloc* m_relocStart;
    PESectionReloc* m_relocCur;
    PESectionReloc* m_relocEnd;

	unsigned m_baseRVA;
	unsigned m_filePos;
	unsigned m_filePad;
	char m_name[8+6]; // extra room for digits
	unsigned m_flags;

    struct _IMAGE_SECTION_HEADER* m_header;
};

/***************************************************************/
/* implementation section */

inline HRESULT PESection::directoryEntry(unsigned num) { 
	TESTANDRETURN(num < 16, E_INVALIDARG); 
	dirEntry = num; 
	return S_OK;
}

// Chop off all data beyond newLen
inline HRESULT PESection::truncate(unsigned newLen)  {
	m_blobFetcher.Truncate(newLen);
	return S_OK;
}

struct PESectionReloc {
    CeeSectionRelocType type;
    unsigned offset;
    CeeSectionRelocExtra extra;
    PESection* section;
};

#endif // #define PESectionMan_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\regdbblobs.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// Structures for RegDB.clb
// 2/13/1998  11:03:47
//*****************************************************************************
#pragma once
extern const __declspec(selectany) int g_iRegDBTables = 10;
extern const BYTE __declspec(selectany) g_rgRegDBSchemaDataRW[] = 
{
	0x0A,0x00,0x00,0x00,0x68,0x05,0x00,0x00,0x30,0x00,0x00,0x00,0xA4,0x00,0x00,0x00,0x18,0x01,0x00,0x00,
	0x7C,0x01,0x00,0x00,0xF0,0x01,0x00,0x00,0x54,0x03,0x00,0x00,0xB8,0x03,0x00,0x00,0x3C,0x04,0x00,0x00,
	0x80,0x04,0x00,0x00,0xC4,0x04,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x03,0x28,0x03,0x01,0x00,0x54,
	0x00,0x00,0xFF,0xFF,0x18,0x00,0x74,0x00,0x12,0x00,0x00,0x00,0x01,0x04,0x2C,0x01,0x00,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0x16,0x00,0x00,0x00,0x02,0x02,0x2C,0x01,0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x1E,0x00,0x00,0x00,0x03,0x03,0x48,0x00,0x08,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x27,0x00,0x00,0x00,
	0x4E,0x08,0x01,0x01,0x11,0x0B,0x0C,0x00,0x01,0x01,0x00,0x58,0x3E,0x00,0x00,0x00,0x08,0x10,0x02,0x01,
	0x11,0x05,0x10,0x00,0x01,0x02,0x00,0x58,0x54,0x00,0x00,0x00,0x08,0x10,0x03,0x01,0x11,0x05,0x14,0x00,
	0x01,0x03,0x00,0x58,0x63,0x00,0x00,0x00,0x01,0x00,0x02,0x28,0x04,0x00,0x00,0x54,0x00,0x00,0xFF,0xFF,
	0x18,0x00,0x74,0x00,0x12,0x00,0x00,0x00,0x01,0x04,0x2C,0x01,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x16,0x00,0x00,0x00,0x02,0x00,0x2C,0x01,0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x78,0x00,0x00,0x00,
	0x03,0x02,0x82,0x00,0x0C,0x00,0x04,0x00,0xFF,0x00,0xFF,0x43,0x7F,0x00,0x00,0x00,0x04,0x02,0x12,0x00,
	0x08,0x00,0x02,0x00,0x02,0x00,0xFF,0x43,0x8B,0x00,0x00,0x00,0x4E,0x08,0x01,0x01,0x11,0x0B,0x10,0x00,
	0x01,0x01,0x00,0x58,0xA6,0x00,0x00,0x00,0x08,0x10,0x02,0x01,0x11,0x05,0x14,0x00,0x02,0x03,0x04,0x58,
	0xB8,0x00,0x00,0x00,0x02,0x00,0x02,0x28,0x03,0x00,0x00,0x54,0x00,0x00,0xFF,0xFF,0x14,0x00,0x64,0x00,
	0x12,0x00,0x00,0x00,0x01,0x04,0x2C,0x01,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x16,0x00,0x00,0x00,
	0x02,0x00,0x2C,0x01,0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0xCA,0x00,0x00,0x00,0x03,0x02,0x48,0x00,
	0x08,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0xD3,0x00,0x00,0x00,0x4E,0x08,0x01,0x01,0x11,0x0B,0x0C,0x00,
	0x01,0x01,0x00,0x58,0xEB,0x00,0x00,0x00,0x08,0x10,0x02,0x01,0x11,0x05,0x10,0x00,0x01,0x03,0x00,0x58,
	0xFB,0x00,0x00,0x00,0x03,0x00,0x02,0x28,0x04,0x00,0x00,0x54,0x00,0x00,0xFF,0xFF,0x18,0x00,0x74,0x00,
	0x12,0x00,0x00,0x00,0x01,0x04,0x2C,0x01,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x0D,0x01,0x00,0x00,
	0x02,0x00,0x2C,0x01,0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x17,0x01,0x00,0x00,0x03,0x00,0x82,0x00,
	0x08,0x00,0x04,0x00,0xFF,0x00,0xFF,0x43,0x1C,0x01,0x00,0x00,0x04,0x02,0x48,0x00,0x0C,0x00,0x04,0x00,
	0xFF,0xFF,0xFF,0x43,0x22,0x01,0x00,0x00,0x4E,0x08,0x01,0x01,0x11,0x0B,0x10,0x00,0x01,0x01,0x00,0x58,
	0x3A,0x01,0x00,0x00,0x08,0x10,0x02,0x01,0x11,0x05,0x14,0x00,0x01,0x04,0x00,0x58,0x47,0x01,0x00,0x00,
	0x04,0x00,0x02,0x28,0x13,0x0B,0x06,0x54,0x00,0x00,0x44,0x00,0x54,0x00,0x64,0x01,0x12,0x00,0x00,0x00,
	0x01,0x04,0x2C,0x01,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x0D,0x01,0x00,0x00,0x02,0x00,0x2C,0x01,
	0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x17,0x01,0x00,0x00,0x03,0x00,0x82,0x00,0x20,0x00,0x04,0x00,
	0x04,0x01,0xFF,0x43,0x56,0x01,0x00,0x00,0x04,0x02,0x48,0x00,0x24,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,
	0x5C,0x01,0x00,0x00,0x05,0x00,0x48,0x00,0x28,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x61,0x01,0x00,0x00,
	0x06,0x00,0x82,0x00,0x2C,0x00,0x04,0x00,0x0C,0x00,0xFF,0x43,0x69,0x01,0x00,0x00,0x07,0x00,0x2C,0x01,
	0x08,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x70,0x01,0x00,0x00,0x08,0x00,0x12,0x00,0x14,0x00,0x02,0x00,
	0x02,0x00,0xFF,0x43,0x7E,0x01,0x00,0x00,0x09,0x01,0x12,0x00,0x16,0x00,0x02,0x00,0x02,0x00,0x00,0x43,
	0x8D,0x01,0x00,0x00,0x0A,0x01,0x12,0x00,0x18,0x00,0x02,0x00,0x02,0x00,0x01,0x43,0x9E,0x01,0x00,0x00,
	0x0B,0x01,0x12,0x00,0x1A,0x00,0x02,0x00,0x02,0x00,0x02,0x43,0xAC,0x01,0x00,0x00,0x0C,0x01,0x12,0x00,
	0x1C,0x00,0x02,0x00,0x02,0x00,0x03,0x43,0xB7,0x01,0x00,0x00,0x0D,0x01,0x82,0x00,0x30,0x00,0x04,0x00,
	0x04,0x01,0xFF,0x43,0xBE,0x01,0x00,0x00,0x0E,0x01,0x82,0x00,0x34,0x00,0x04,0x00,0x04,0x01,0xFF,0x43,
	0xC7,0x01,0x00,0x00,0x0F,0x01,0x82,0x00,0x38,0x00,0x04,0x00,0x00,0x04,0xFF,0x43,0xD3,0x01,0x00,0x00,
	0x10,0x01,0x03,0x00,0x0C,0x00,0x04,0x00,0x04,0x00,0x04,0x43,0xE2,0x01,0x00,0x00,0x11,0x01,0x82,0x00,
	0x3C,0x00,0x04,0x00,0x00,0x04,0xFF,0x43,0xF2,0x01,0x00,0x00,0x12,0x01,0x03,0x00,0x10,0x00,0x04,0x00,
	0x04,0x00,0x05,0x43,0x03,0x02,0x00,0x00,0x13,0x01,0x82,0x00,0x40,0x00,0x04,0x00,0x04,0x01,0xFF,0x43,
	0x14,0x02,0x00,0x00,0x4E,0x08,0x01,0x01,0x11,0x0B,0x4C,0x00,0x01,0x01,0x00,0x58,0x29,0x02,0x00,0x00,
	0x0A,0x10,0x02,0x01,0x11,0x05,0x50,0x00,0x01,0x04,0x00,0x58,0x38,0x02,0x00,0x00,0x05,0x00,0x01,0x28,
	0x04,0x01,0x01,0x54,0x00,0x00,0x10,0x00,0x18,0x00,0x64,0x00,0x12,0x00,0x00,0x00,0x01,0x04,0x2C,0x01,
	0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x47,0x02,0x00,0x00,0x02,0x00,0x48,0x00,0x08,0x00,0x04,0x00,
	0xFF,0xFF,0xFF,0x43,0x4B,0x02,0x00,0x00,0x03,0x00,0x48,0x00,0x0C,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,
	0x55,0x02,0x00,0x00,0x04,0x01,0x2C,0x01,0x04,0x00,0x04,0x00,0x04,0x00,0x00,0x43,0x62,0x02,0x00,0x00,
	0x4E,0x08,0x01,0x01,0x11,0x0B,0x14,0x00,0x01,0x01,0x00,0x58,0x77,0x02,0x00,0x00,0x06,0x00,0x01,0x28,
	0x06,0x00,0x00,0x54,0x00,0x00,0xFF,0xFF,0x1C,0x00,0x84,0x00,0x12,0x00,0x00,0x00,0x01,0x04,0x2C,0x01,
	0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x0D,0x01,0x00,0x00,0x02,0x00,0x2C,0x01,0x04,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0x17,0x01,0x00,0x00,0x03,0x00,0x82,0x00,0x08,0x00,0x04,0x00,0x04,0x01,0xFF,0x43,
	0x89,0x02,0x00,0x00,0x04,0x00,0x48,0x00,0x0C,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x90,0x02,0x00,0x00,
	0x05,0x00,0x82,0x00,0x10,0x00,0x04,0x00,0x04,0x01,0xFF,0x43,0x98,0x02,0x00,0x00,0x06,0x00,0x82,0x00,
	0x14,0x00,0x04,0x00,0x04,0x01,0xFF,0x43,0xA5,0x02,0x00,0x00,0x4E,0x08,0x01,0x01,0x11,0x0B,0x18,0x00,
	0x01,0x01,0x00,0x58,0xBD,0x02,0x00,0x00,0x07,0x00,0x01,0x28,0x02,0x00,0x00,0x54,0x00,0x00,0xFF,0xFF,
	0x0C,0x00,0x44,0x00,0x12,0x00,0x00,0x00,0x01,0x04,0x2C,0x01,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0xCD,0x02,0x00,0x00,0x02,0x00,0x82,0x00,0x04,0x00,0x04,0x00,0x04,0x01,0xFF,0x43,0xD6,0x02,0x00,0x00,
	0x4E,0x08,0x01,0x01,0x11,0x0B,0x08,0x00,0x01,0x01,0x00,0x58,0xEC,0x02,0x00,0x00,0x08,0x00,0x01,0x28,
	0x02,0x00,0x00,0x54,0x00,0x00,0xFF,0xFF,0x0C,0x00,0x44,0x00,0x12,0x00,0x00,0x00,0x01,0x04,0x2C,0x01,
	0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x0D,0x01,0x00,0x00,0x02,0x00,0x82,0x00,0x04,0x00,0x04,0x00,
	0x04,0x01,0xFF,0x43,0xFF,0x02,0x00,0x00,0x4E,0x08,0x01,0x01,0x11,0x0B,0x08,0x00,0x01,0x01,0x00,0x58,
	0x18,0x03,0x00,0x00,0x09,0x00,0x01,0x28,0x08,0x04,0x03,0x54,0x00,0x00,0x20,0x00,0x28,0x00,0xA4,0x00,
	0x12,0x00,0x00,0x00,0x01,0x04,0x2C,0x01,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x29,0x03,0x00,0x00,
	0x02,0x00,0x48,0x00,0x14,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x2D,0x03,0x00,0x00,0x03,0x00,0x82,0x00,
	0x18,0x00,0x04,0x00,0x04,0x01,0xFF,0x43,0x0D,0x01,0x00,0x00,0x04,0x01,0x2C,0x01,0x04,0x00,0x04,0x00,
	0x04,0x00,0x00,0x43,0x39,0x03,0x00,0x00,0x05,0x01,0x12,0x00,0x10,0x00,0x02,0x00,0x02,0x00,0x01,0x43,
	0x46,0x03,0x00,0x00,0x06,0x01,0x03,0x00,0x08,0x00,0x04,0x00,0x04,0x00,0x02,0x43,0x56,0x03,0x00,0x00,
	0x07,0x01,0x82,0x00,0x1C,0x00,0x04,0x00,0x40,0x00,0xFF,0x43,0x69,0x01,0x00,0x00,0x08,0x00,0x2C,0x01,
	0x0C,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x62,0x03,0x00,0x00,0x4E,0x08,0x01,0x01,0x11,0x0B,0x24,0x00,
	0x01,0x01,0x00,0x58,
};
extern const __declspec(selectany) int g_cbRegDBSchemaRW = 1384;
extern const __declspec(selectany) BYTE g_rgRegDBSchemaStringHeap[] = 
{
	0x00,0x52,0x65,0x67,0x44,0x42,0x2E,0x43,0x6F,0x63,0x6C,0x61,0x73,0x73,0x43,0x61,0x74,0x00,0x6F,0x69,
	0x64,0x00,0x43,0x6F,0x63,0x6C,0x61,0x73,0x73,0x00,0x43,0x61,0x74,0x65,0x67,0x6F,0x72,0x79,0x00,0x23,
	0x23,0x52,0x65,0x67,0x44,0x42,0x2E,0x43,0x6F,0x63,0x6C,0x61,0x73,0x73,0x43,0x61,0x74,0x5F,0x44,0x65,
	0x78,0x00,0x52,0x65,0x67,0x44,0x42,0x2E,0x43,0x6F,0x63,0x6C,0x61,0x73,0x73,0x43,0x61,0x74,0x49,0x6E,
	0x64,0x65,0x78,0x00,0x52,0x65,0x67,0x44,0x42,0x2E,0x43,0x61,0x74,0x49,0x6E,0x64,0x65,0x78,0x00,0x52,
	0x65,0x67,0x44,0x42,0x2E,0x43,0x6F,0x63,0x6C,0x61,0x73,0x73,0x46,0x6F,0x72,0x6D,0x61,0x74,0x73,0x00,
	0x46,0x6F,0x72,0x6D,0x61,0x74,0x00,0x46,0x6F,0x72,0x6D,0x61,0x74,0x46,0x6C,0x61,0x67,0x73,0x00,0x23,
	0x23,0x52,0x65,0x67,0x44,0x42,0x2E,0x43,0x6F,0x63,0x6C,0x61,0x73,0x73,0x46,0x6F,0x72,0x6D,0x61,0x74,
	0x73,0x5F,0x44,0x65,0x78,0x00,0x52,0x65,0x67,0x44,0x42,0x2E,0x46,0x6F,0x72,0x6D,0x61,0x74,0x49,0x6E,
	0x64,0x65,0x78,0x00,0x52,0x65,0x67,0x44,0x42,0x2E,0x43,0x6F,0x63,0x6C,0x61,0x73,0x73,0x4D,0x49,0x4D,
	0x45,0x00,0x4D,0x49,0x4D,0x45,0x54,0x79,0x70,0x65,0x00,0x23,0x23,0x52,0x65,0x67,0x44,0x42,0x2E,0x43,
	0x6F,0x63,0x6C,0x61,0x73,0x73,0x4D,0x49,0x4D,0x45,0x5F,0x44,0x65,0x78,0x00,0x52,0x65,0x67,0x44,0x42,
	0x2E,0x4D,0x49,0x4D,0x45,0x49,0x6E,0x64,0x65,0x78,0x00,0x52,0x65,0x67,0x44,0x42,0x2E,0x52,0x65,0x67,
	0x43,0x61,0x74,0x65,0x67,0x6F,0x72,0x79,0x00,0x4E,0x61,0x6D,0x65,0x73,0x70,0x61,0x63,0x65,0x00,0x4E,
	0x61,0x6D,0x65,0x00,0x43,0x41,0x54,0x49,0x44,0x00,0x23,0x23,0x52,0x65,0x67,0x44,0x42,0x2E,0x52,0x65,
	0x67,0x43,0x61,0x74,0x65,0x67,0x6F,0x72,0x79,0x5F,0x44,0x65,0x78,0x00,0x52,0x65,0x67,0x44,0x42,0x2E,
	0x52,0x65,0x67,0x43,0x61,0x74,0x00,0x52,0x65,0x67,0x44,0x42,0x2E,0x52,0x65,0x67,0x43,0x6C,0x61,0x73,
	0x73,0x00,0x63,0x6C,0x73,0x69,0x64,0x00,0x63,0x76,0x69,0x64,0x00,0x56,0x65,0x72,0x73,0x69,0x6F,0x6E,
	0x00,0x4D,0x6F,0x64,0x75,0x6C,0x65,0x00,0x42,0x65,0x68,0x61,0x76,0x69,0x6F,0x72,0x46,0x6C,0x61,0x67,
	0x73,0x00,0x54,0x68,0x72,0x65,0x61,0x64,0x69,0x6E,0x67,0x4D,0x6F,0x64,0x65,0x6C,0x00,0x54,0x72,0x61,
	0x6E,0x73,0x61,0x63,0x74,0x69,0x6F,0x6E,0x52,0x65,0x71,0x74,0x73,0x00,0x53,0x65,0x63,0x75,0x72,0x69,
	0x74,0x79,0x52,0x65,0x71,0x74,0x73,0x00,0x53,0x79,0x6E,0x63,0x68,0x52,0x65,0x71,0x74,0x73,0x00,0x50,
	0x72,0x6F,0x67,0x49,0x44,0x00,0x56,0x49,0x50,0x72,0x6F,0x67,0x49,0x44,0x00,0x44,0x65,0x66,0x61,0x75,
	0x6C,0x74,0x49,0x63,0x6F,0x6E,0x00,0x49,0x63,0x6F,0x6E,0x52,0x65,0x73,0x6F,0x75,0x72,0x63,0x65,0x49,
	0x44,0x00,0x54,0x6F,0x6F,0x6C,0x62,0x6F,0x78,0x42,0x69,0x74,0x6D,0x61,0x70,0x33,0x32,0x00,0x42,0x69,
	0x74,0x6D,0x61,0x70,0x52,0x65,0x73,0x6F,0x75,0x72,0x63,0x65,0x49,0x44,0x00,0x53,0x68,0x6F,0x72,0x74,
	0x44,0x69,0x73,0x70,0x6C,0x61,0x79,0x4E,0x61,0x6D,0x65,0x00,0x23,0x23,0x52,0x65,0x67,0x44,0x42,0x2E,
	0x52,0x65,0x67,0x43,0x6C,0x61,0x73,0x73,0x5F,0x44,0x65,0x78,0x00,0x52,0x65,0x67,0x44,0x42,0x2E,0x52,
	0x65,0x67,0x43,0x6C,0x73,0x69,0x64,0x00,0x52,0x65,0x67,0x44,0x42,0x2E,0x52,0x65,0x67,0x49,0x66,0x61,
	0x63,0x65,0x00,0x49,0x49,0x44,0x00,0x50,0x72,0x6F,0x78,0x79,0x53,0x74,0x75,0x62,0x00,0x50,0x72,0x6F,
	0x78,0x79,0x53,0x74,0x75,0x62,0x4F,0x49,0x44,0x00,0x23,0x23,0x52,0x65,0x67,0x44,0x42,0x2E,0x52,0x65,
	0x67,0x49,0x66,0x61,0x63,0x65,0x5F,0x44,0x65,0x78,0x00,0x52,0x65,0x67,0x44,0x42,0x2E,0x52,0x65,0x67,
	0x4D,0x49,0x4D,0x45,0x54,0x79,0x70,0x65,0x00,0x4D,0x49,0x4D,0x45,0x49,0x44,0x00,0x46,0x69,0x6C,0x65,
	0x45,0x78,0x74,0x00,0x4D,0x49,0x4D,0x45,0x45,0x6E,0x63,0x6F,0x64,0x69,0x6E,0x67,0x00,0x23,0x23,0x52,
	0x65,0x67,0x44,0x42,0x2E,0x52,0x65,0x67,0x4D,0x49,0x4D,0x45,0x54,0x79,0x70,0x65,0x5F,0x44,0x65,0x78,
	0x00,0x52,0x65,0x67,0x44,0x42,0x2E,0x52,0x65,0x67,0x4D,0x6F,0x64,0x75,0x6C,0x65,0x00,0x46,0x69,0x6C,
	0x65,0x6E,0x61,0x6D,0x65,0x00,0x23,0x23,0x52,0x65,0x67,0x44,0x42,0x2E,0x52,0x65,0x67,0x4D,0x6F,0x64,
	0x75,0x6C,0x65,0x5F,0x44,0x65,0x78,0x00,0x52,0x65,0x67,0x44,0x42,0x2E,0x52,0x65,0x67,0x4E,0x61,0x6D,
	0x65,0x73,0x70,0x61,0x63,0x65,0x00,0x23,0x23,0x52,0x65,0x67,0x44,0x42,0x2E,0x52,0x65,0x67,0x4E,0x61,
	0x6D,0x65,0x73,0x70,0x61,0x63,0x65,0x5F,0x44,0x65,0x78,0x00,0x52,0x65,0x67,0x44,0x42,0x2E,0x52,0x65,
	0x67,0x50,0x72,0x6F,0x63,0x65,0x73,0x73,0x00,0x50,0x49,0x44,0x00,0x50,0x72,0x6F,0x63,0x65,0x73,0x73,
	0x4E,0x61,0x6D,0x65,0x00,0x50,0x72,0x6F,0x63,0x65,0x73,0x73,0x46,0x6C,0x61,0x67,0x73,0x00,0x53,0x68,
	0x75,0x74,0x64,0x6F,0x77,0x6E,0x4C,0x61,0x74,0x65,0x6E,0x63,0x79,0x00,0x52,0x75,0x6E,0x41,0x73,0x4E,
	0x54,0x55,0x73,0x65,0x72,0x00,0x23,0x23,0x52,0x65,0x67,0x44,0x42,0x2E,0x52,0x65,0x67,0x50,0x72,0x6F,
	0x63,0x65,0x73,0x73,0x5F,0x44,0x65,0x78,0x00,0x00,0x00,0x00,
};
extern const __declspec(selectany) BYTE * g_pbRegDBSchemaStringHeap = g_rgRegDBSchemaStringHeap;
extern const __declspec(selectany) int g_cbRegDBSchemaStringHeap = 892;
extern const BYTE __declspec(selectany) g_rgRegDBSchemaDataRO[] = 
{
	0x0A,0x00,0x00,0x00,0x68,0x05,0x00,0x00,0x30,0x00,0x00,0x00,0xA4,0x00,0x00,0x00,0x18,0x01,0x00,0x00,
	0x7C,0x01,0x00,0x00,0xF0,0x01,0x00,0x00,0x54,0x03,0x00,0x00,0xB8,0x03,0x00,0x00,0x3C,0x04,0x00,0x00,
	0x80,0x04,0x00,0x00,0xC4,0x04,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x03,0x28,0x03,0x01,0x00,0x54,
	0x00,0x00,0xFF,0xFF,0x18,0x00,0x74,0x00,0x12,0x00,0x00,0x00,0x01,0x04,0x2C,0x01,0x00,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0x16,0x00,0x00,0x00,0x02,0x02,0x2C,0x01,0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x1E,0x00,0x00,0x00,0x03,0x03,0x48,0x00,0x08,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x27,0x00,0x00,0x00,
	0x4E,0x08,0x01,0x01,0x11,0x0B,0x0C,0x00,0x01,0x01,0x00,0x58,0x3E,0x00,0x00,0x00,0x08,0x10,0x02,0x01,
	0x11,0x05,0x10,0x00,0x01,0x02,0x00,0x58,0x54,0x00,0x00,0x00,0x08,0x10,0x03,0x01,0x11,0x05,0x14,0x00,
	0x01,0x03,0x00,0x58,0x63,0x00,0x00,0x00,0x01,0x00,0x02,0x28,0x04,0x00,0x00,0x54,0x00,0x00,0xFF,0xFF,
	0x18,0x00,0x74,0x00,0x12,0x00,0x00,0x00,0x01,0x04,0x2C,0x01,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x16,0x00,0x00,0x00,0x02,0x00,0x2C,0x01,0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x78,0x00,0x00,0x00,
	0x03,0x02,0x82,0x00,0x0C,0x00,0x04,0x00,0xFF,0x00,0xFF,0x43,0x7F,0x00,0x00,0x00,0x04,0x02,0x12,0x00,
	0x08,0x00,0x02,0x00,0x02,0x00,0xFF,0x43,0x8B,0x00,0x00,0x00,0x4E,0x08,0x01,0x01,0x11,0x0B,0x10,0x00,
	0x01,0x01,0x00,0x58,0xA6,0x00,0x00,0x00,0x08,0x10,0x02,0x01,0x11,0x05,0x14,0x00,0x02,0x03,0x04,0x58,
	0xB8,0x00,0x00,0x00,0x02,0x00,0x02,0x28,0x03,0x00,0x00,0x54,0x00,0x00,0xFF,0xFF,0x14,0x00,0x64,0x00,
	0x12,0x00,0x00,0x00,0x01,0x04,0x2C,0x01,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x16,0x00,0x00,0x00,
	0x02,0x00,0x2C,0x01,0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0xCA,0x00,0x00,0x00,0x03,0x02,0x48,0x00,
	0x08,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0xD3,0x00,0x00,0x00,0x4E,0x08,0x01,0x01,0x11,0x0B,0x0C,0x00,
	0x01,0x01,0x00,0x58,0xEB,0x00,0x00,0x00,0x08,0x10,0x02,0x01,0x11,0x05,0x10,0x00,0x01,0x03,0x00,0x58,
	0xFB,0x00,0x00,0x00,0x03,0x00,0x02,0x28,0x04,0x00,0x00,0x54,0x00,0x00,0xFF,0xFF,0x18,0x00,0x74,0x00,
	0x12,0x00,0x00,0x00,0x01,0x04,0x2C,0x01,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x0D,0x01,0x00,0x00,
	0x02,0x00,0x2C,0x01,0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x17,0x01,0x00,0x00,0x03,0x00,0x82,0x00,
	0x08,0x00,0x04,0x00,0xFF,0x00,0xFF,0x43,0x1C,0x01,0x00,0x00,0x04,0x02,0x48,0x00,0x0C,0x00,0x04,0x00,
	0xFF,0xFF,0xFF,0x43,0x22,0x01,0x00,0x00,0x4E,0x08,0x01,0x01,0x11,0x0B,0x10,0x00,0x01,0x01,0x00,0x58,
	0x3A,0x01,0x00,0x00,0x08,0x10,0x02,0x01,0x11,0x05,0x14,0x00,0x01,0x04,0x00,0x58,0x47,0x01,0x00,0x00,
	0x04,0x00,0x02,0x28,0x13,0x0B,0x06,0x54,0x00,0x00,0x44,0x00,0x54,0x00,0x64,0x01,0x12,0x00,0x00,0x00,
	0x01,0x04,0x2C,0x01,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x0D,0x01,0x00,0x00,0x02,0x00,0x2C,0x01,
	0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x17,0x01,0x00,0x00,0x03,0x00,0x82,0x00,0x20,0x00,0x04,0x00,
	0x04,0x01,0xFF,0x43,0x56,0x01,0x00,0x00,0x04,0x02,0x48,0x00,0x24,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,
	0x5C,0x01,0x00,0x00,0x05,0x00,0x48,0x00,0x28,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x61,0x01,0x00,0x00,
	0x06,0x00,0x82,0x00,0x2C,0x00,0x04,0x00,0x0C,0x00,0xFF,0x43,0x69,0x01,0x00,0x00,0x07,0x00,0x2C,0x01,
	0x08,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x70,0x01,0x00,0x00,0x08,0x00,0x12,0x00,0x14,0x00,0x02,0x00,
	0x02,0x00,0xFF,0x43,0x7E,0x01,0x00,0x00,0x09,0x01,0x12,0x00,0x16,0x00,0x02,0x00,0x02,0x00,0x00,0x43,
	0x8D,0x01,0x00,0x00,0x0A,0x01,0x12,0x00,0x18,0x00,0x02,0x00,0x02,0x00,0x01,0x43,0x9E,0x01,0x00,0x00,
	0x0B,0x01,0x12,0x00,0x1A,0x00,0x02,0x00,0x02,0x00,0x02,0x43,0xAC,0x01,0x00,0x00,0x0C,0x01,0x12,0x00,
	0x1C,0x00,0x02,0x00,0x02,0x00,0x03,0x43,0xB7,0x01,0x00,0x00,0x0D,0x01,0x82,0x00,0x30,0x00,0x04,0x00,
	0x04,0x01,0xFF,0x43,0xBE,0x01,0x00,0x00,0x0E,0x01,0x82,0x00,0x34,0x00,0x04,0x00,0x04,0x01,0xFF,0x43,
	0xC7,0x01,0x00,0x00,0x0F,0x01,0x82,0x00,0x38,0x00,0x04,0x00,0x00,0x04,0xFF,0x43,0xD3,0x01,0x00,0x00,
	0x10,0x01,0x03,0x00,0x0C,0x00,0x04,0x00,0x04,0x00,0x04,0x43,0xE2,0x01,0x00,0x00,0x11,0x01,0x82,0x00,
	0x3C,0x00,0x04,0x00,0x00,0x04,0xFF,0x43,0xF2,0x01,0x00,0x00,0x12,0x01,0x03,0x00,0x10,0x00,0x04,0x00,
	0x04,0x00,0x05,0x43,0x03,0x02,0x00,0x00,0x13,0x01,0x82,0x00,0x40,0x00,0x04,0x00,0x04,0x01,0xFF,0x43,
	0x14,0x02,0x00,0x00,0x4E,0x08,0x01,0x01,0x11,0x0B,0x4C,0x00,0x01,0x01,0x00,0x58,0x29,0x02,0x00,0x00,
	0x0A,0x10,0x02,0x01,0x11,0x05,0x50,0x00,0x01,0x04,0x00,0x58,0x38,0x02,0x00,0x00,0x05,0x00,0x01,0x28,
	0x04,0x01,0x01,0x54,0x00,0x00,0x10,0x00,0x18,0x00,0x64,0x00,0x12,0x00,0x00,0x00,0x01,0x04,0x2C,0x01,
	0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x47,0x02,0x00,0x00,0x02,0x00,0x48,0x00,0x08,0x00,0x04,0x00,
	0xFF,0xFF,0xFF,0x43,0x4B,0x02,0x00,0x00,0x03,0x00,0x48,0x00,0x0C,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,
	0x55,0x02,0x00,0x00,0x04,0x01,0x2C,0x01,0x04,0x00,0x04,0x00,0x04,0x00,0x00,0x43,0x62,0x02,0x00,0x00,
	0x4E,0x08,0x01,0x01,0x11,0x0B,0x14,0x00,0x01,0x01,0x00,0x58,0x77,0x02,0x00,0x00,0x06,0x00,0x01,0x28,
	0x06,0x00,0x00,0x54,0x00,0x00,0xFF,0xFF,0x1C,0x00,0x84,0x00,0x12,0x00,0x00,0x00,0x01,0x04,0x2C,0x01,
	0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x0D,0x01,0x00,0x00,0x02,0x00,0x2C,0x01,0x04,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0x17,0x01,0x00,0x00,0x03,0x00,0x82,0x00,0x08,0x00,0x04,0x00,0x04,0x01,0xFF,0x43,
	0x89,0x02,0x00,0x00,0x04,0x00,0x48,0x00,0x0C,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x90,0x02,0x00,0x00,
	0x05,0x00,0x82,0x00,0x10,0x00,0x04,0x00,0x04,0x01,0xFF,0x43,0x98,0x02,0x00,0x00,0x06,0x00,0x82,0x00,
	0x14,0x00,0x04,0x00,0x04,0x01,0xFF,0x43,0xA5,0x02,0x00,0x00,0x4E,0x08,0x01,0x01,0x11,0x0B,0x18,0x00,
	0x01,0x01,0x00,0x58,0xBD,0x02,0x00,0x00,0x07,0x00,0x01,0x28,0x02,0x00,0x00,0x54,0x00,0x00,0xFF,0xFF,
	0x0C,0x00,0x44,0x00,0x12,0x00,0x00,0x00,0x01,0x04,0x2C,0x01,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0xCD,0x02,0x00,0x00,0x02,0x00,0x82,0x00,0x04,0x00,0x04,0x00,0x04,0x01,0xFF,0x43,0xD6,0x02,0x00,0x00,
	0x4E,0x08,0x01,0x01,0x11,0x0B,0x08,0x00,0x01,0x01,0x00,0x58,0xEC,0x02,0x00,0x00,0x08,0x00,0x01,0x28,
	0x02,0x00,0x00,0x54,0x00,0x00,0xFF,0xFF,0x0C,0x00,0x44,0x00,0x12,0x00,0x00,0x00,0x01,0x04,0x2C,0x01,
	0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x0D,0x01,0x00,0x00,0x02,0x00,0x82,0x00,0x04,0x00,0x04,0x00,
	0x04,0x01,0xFF,0x43,0xFF,0x02,0x00,0x00,0x4E,0x08,0x01,0x01,0x11,0x0B,0x08,0x00,0x01,0x01,0x00,0x58,
	0x18,0x03,0x00,0x00,0x09,0x00,0x01,0x28,0x08,0x04,0x03,0x54,0x00,0x00,0x20,0x00,0x28,0x00,0xA4,0x00,
	0x12,0x00,0x00,0x00,0x01,0x04,0x2C,0x01,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x29,0x03,0x00,0x00,
	0x02,0x00,0x48,0x00,0x14,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x2D,0x03,0x00,0x00,0x03,0x00,0x82,0x00,
	0x18,0x00,0x04,0x00,0x04,0x01,0xFF,0x43,0x0D,0x01,0x00,0x00,0x04,0x01,0x2C,0x01,0x04,0x00,0x04,0x00,
	0x04,0x00,0x00,0x43,0x39,0x03,0x00,0x00,0x05,0x01,0x12,0x00,0x10,0x00,0x02,0x00,0x02,0x00,0x01,0x43,
	0x46,0x03,0x00,0x00,0x06,0x01,0x03,0x00,0x08,0x00,0x04,0x00,0x04,0x00,0x02,0x43,0x56,0x03,0x00,0x00,
	0x07,0x01,0x82,0x00,0x1C,0x00,0x04,0x00,0x40,0x00,0xFF,0x43,0x69,0x01,0x00,0x00,0x08,0x00,0x2C,0x01,
	0x0C,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x62,0x03,0x00,0x00,0x4E,0x08,0x01,0x01,0x11,0x0B,0x24,0x00,
	0x01,0x01,0x00,0x58,
};
extern const __declspec(selectany) int g_cbRegDBSchemaRO = 1384;
extern const COMPLIBSCHEMABLOB __declspec(selectany) RegDBSchemaBlob = 
{
	&RegDBSchema,
	RegDB_TABLE_COUNT,
	0,
	g_rgRegDBSchemaDataRW,
	g_cbRegDBSchemaRW,
	g_rgRegDBSchemaDataRO,
	g_cbRegDBSchemaRO,
	g_rgRegDBSchemaStringHeap,
	g_cbRegDBSchemaStringHeap
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\safegetfilesize.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef __SafeGetFileSize_h__
#define __SafeGetFileSize_h__

//*****************************************************************************
// This provides a wrapper around GetFileSize() that forces it to fail
// if the file is >4g and pdwHigh is NULL. Other than that, it acts like
// the genuine GetFileSize().
//
// It's not very sporting to fail just because the file exceeds 4gb,
// but it's better than risking a security hole where a bad guy could
// force a small buffer allocation and a large file read.
//*****************************************************************************
DWORD inline SafeGetFileSize(HANDLE hFile, DWORD *pdwHigh)
{
    if (pdwHigh != NULL)
    {
        return ::GetFileSize(hFile, pdwHigh);
    }
    else
    {
        DWORD hi;
        DWORD lo = ::GetFileSize(hFile, &hi);
        if (lo == 0xffffffff && GetLastError() != NO_ERROR)
        {
            return lo;
        }
        // api succeeded. is the file too large?
        if (hi != 0)
        {
            // there isn't really a good error to set here...
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return 0xffffffff;
        }

        if (lo == 0xffffffff)
        {
            // note that a success return of (hi=0,lo=0xffffffff) will be
            // treated as an error by the caller. Again, that's part of the
            // price of being a slacker and not handling the high dword.
            // We'll set a lasterror for him to pick up. (a bad error
            // code is better than a random one, I guess...)
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        }

        return lo;
    }

}

#endif //__SafeGetFileSize_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\rotate.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// rotate.h
//
//*****************************************************************************

#ifndef __ROTATE_H__
#define __ROTATE_H__

#ifdef _DEBUG

inline void RotateUSHORT(USHORT &iHash)
{
	USHORT iRotate = iHash & 0x8000;
	iHash <<= 1;
	if (iRotate) iHash += 1;
}

inline void RotateLong(long &iHash)
{
	long iRotate = iHash & 0x80000000;
	iHash <<= 1;
	if (iRotate) iHash += 1;
}

#else

#ifdef	_M_IX86

#define RotateUSHORT(iHash) \
	__asm \
	{ \
		rol		WORD PTR iHash, 1 \
	}

#define RotateLong(iHash) \
	__asm \
	{ \
		rol		DWORD PTR iHash, 1 \
	}

#else

#define RotateUSHORT(iHash) \
	{ \
	USHORT iRotate = iHash & 0x8000; \
	iHash <<= 1; \
	if (iRotate) iHash += 1; \
	}

#define RotateLong(iHash) \
	{ \
	USHORT iRotate = iHash & 0x80000000; \
	iHash <<= 1; \
	if (iRotate) iHash += 1; \
	}

#endif

#endif // _DEBUG

#endif //__ROTATE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\regdisp.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef __REGDISP_H
#define __REGDISP_H

#include "winnt.h"

#undef N_CALLEE_SAVED_REGISTERS


#ifdef _X86_

#define N_CALLEE_SAVED_REGISTERS    4
//#define JIT_OR_NATIVE_SUPPORTED

typedef struct _REGDISPLAY {
    PCONTEXT pContext;          // points to current Context; either
                                // returned by GetContext or provided
                                // at exception time.

    DWORD * pEdi;
    DWORD * pEsi;
    DWORD * pEbx;
    DWORD * pEdx;
    DWORD * pEcx;
    DWORD * pEax;

    DWORD * pEbp;
    DWORD   Esp;
    SLOT  * pPC;                // processor neutral name

} REGDISPLAY;

inline LPVOID GetRegdisplaySP(REGDISPLAY *display) {
	return (LPVOID)(size_t)display->Esp;
}

#endif

#ifdef _ALPHA_

#define N_CALLEE_SAVED_REGISTERS 0xCC           // just a bogus value for now

typedef struct {
    DWORD * pIntFP;
    DWORD   IntSP;
    SLOT  * pPC;
} REGDISPLAY;

inline LPVOID GetRegdisplaySP(REGDISPLAY *display) {
	return (LPVOID)display->IntSP;
}

#endif

#ifdef _SH3_
#pragma message("SH3 TODO -- define REGDISPLAY")
#endif

#ifndef N_CALLEE_SAVED_REGISTERS // none of the above processors

#define N_CALLEE_SAVED_REGISTERS 1
typedef struct {
    size_t   SP;
    size_t * FramePtr;
    SLOT   * pPC;
} REGDISPLAY;
// #error  Target architecture undefined OR not yet supported

inline LPVOID GetRegdisplaySP(REGDISPLAY *display) {
	return (LPVOID)display->SP;
}

#endif  // others

typedef REGDISPLAY *PREGDISPLAY;

#endif  // __REGDISP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\setupcodes.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// SetupCodes.h
//
// This file contains the errors that the Setup and related tools return
//
//*****************************************************************************
#ifndef SetupCodes_h_
#define SetupCodes_h_

#define COR_EXIT_SUCCESS		    0x0002		// Module Completed Successfully
#define COR_EXIT_FAILURE            0xFFFF      // Setup Failure - unknown reason

#define COR_SUCCESS_NO_REBOOT 		0x0000		// Setup succeded, no reboot.
#define COR_SUCCESS_REBOOT_REQUIRED	0x0004		// Setup succeded, must reboot.
#define DARWIN_UPDATE_MUST_REBOOT	0x0008		// Darwin bits updated. Must Reboot before continuing

#define COR_DARWIN_INSTALL_FAILURE 	0x0010		// Installation of Darwin components failed
#define COR_INVALID_INSTALL_PATH	0x0020		// Invalid path with /dir switch
#define COR_DAWIN_NOT_INSTALLED		0x0040		// Can't find Darwin on machine
#define COR_NON_EXISTENT_PRODUCT 	0x0080		// Can't find Common Language Runtime
#define COR_UNSUPPORTED_PLATFORM	0x0100		// This platform is not supported
#define COR_CANCELLED_BY_USER       0x0200		// User cancelled install

#define COR_INSUFFICIENT_PRIVILEGES 0x0400		// On NT, Need Admin rights to (un)install
#define COR_USAGE_ERROR				0x0800 		// Improper usage/invalid parameters
#define COR_MISSING_ENTRY_POINT		0x1000		// Can't find function in dll
#define COR_SETTINGS_FAILURE        0x2000      // Configuring product (security settings etc) failed
#define COR_BLOCKED_PLATFORM        0x4000      // Blocked Platform - Non Win2k as of Sept 2, 1999
#define COR_GUIDBG_INSTALL_FAILURE  0x8000		// Installation of GUI Debugger Failed.

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\sha.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/* Copyright (C) RSA Data Security, Inc. created 1993.  This is an
   unpublished work protected as such under copyright law.  This work
   contains proprietary, confidential, and trade secret information of
   RSA Data Security, Inc.  Use, disclosure or reproduction without the
   express written authorization of RSA Data Security, Inc. is
   prohibited.
 */

#ifndef _SHA_H_
#define _SHA_H_ 1

#ifdef __cplusplus
extern "C" {
#endif

#include "shacomm.h"

typedef struct {
	DWORD		Final;
	BYTE		HashVal[A_SHA_DIGEST_LEN];
	A_SHA_COMM_CTX  commonContext;
} A_SHA_CTX;

void PASCAL A_SHAInit(A_SHA_CTX *);
void PASCAL A_SHAUpdate(A_SHA_CTX *, const unsigned char *, DWORD);
void PASCAL A_SHAFinal(A_SHA_CTX *, unsigned char [A_SHA_DIGEST_LEN]);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\regdbstructs.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// Structures for ..\..\inc\RegDBStructs.h
// 2/13/1998  11:03:47
//*****************************************************************************
#pragma once
#include "icmprecs.h"


// Script supplied data.





#define RegDBTABLENAMELIST() \
	TABLENAME( CoclassCat ) \
	TABLENAME( CoclassFormats ) \
	TABLENAME( CoclassMIME ) \
	TABLENAME( RegCategory ) \
	TABLENAME( RegClass ) \
	TABLENAME( RegIface ) \
	TABLENAME( RegMIMEType ) \
	TABLENAME( RegModule ) \
	TABLENAME( RegNamespace ) \
	TABLENAME( RegProcess ) 


#undef TABLENAME
#define TABLENAME( TblName ) TABLENUM_##TblName, 
enum
{
	RegDBTABLENAMELIST()
};

#define RegDB_TABLE_COUNT 10
extern const GUID __declspec(selectany) SCHEMA_RegDB = { 0x44641EA4, 0x703A, 0x11D1, {  0xB7, 0x4C, 0x00, 0xC0, 0x4F, 0xC3, 0x24, 0x80 }};
extern const COMPLIBSCHEMA __declspec(selectany) RegDBSchema = 
{
	&SCHEMA_RegDB,
	1
};


#pragma pack(push)
#pragma pack(1)


//*****************************************************************************
//  RegDB.CoclassCat
//*****************************************************************************
typedef struct
{
    ULONG fNullFlags;
    OID oid;
    OID Coclass;
    GUID Category;

	inline int IsCategoryNull(void)
	{ return (GetBit(fNullFlags, 1)); }

	inline void SetCategoryNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 1, nullBitVal); }

    void Init()
    {
         memset(this, 0, sizeof(RegDB_CoclassCat));
         fNullFlags = (ULONG) -1;
    }

} RegDB_CoclassCat;

#define COLID_RegDB_CoclassCat_oid 1
#define COLID_RegDB_CoclassCat_Coclass 2
#define COLID_RegDB_CoclassCat_Category 3



//*****************************************************************************
//  RegDB.CoclassFormats
//*****************************************************************************
typedef struct
{
    OID oid;
    OID Coclass;
    ULONG cbFormatLen;
    wchar_t Format[256];
    unsigned short FormatFlags;
    BYTE pad00 [2];

    void Init()
    {
         memset(this, 0, sizeof(RegDB_CoclassFormats));
    }

} RegDB_CoclassFormats;

#define COLID_RegDB_CoclassFormats_oid 1
#define COLID_RegDB_CoclassFormats_Coclass 2
#define COLID_RegDB_CoclassFormats_Format 3
#define COLID_RegDB_CoclassFormats_FormatFlags 4



//*****************************************************************************
//  RegDB.CoclassMIME
//*****************************************************************************
typedef struct
{
    OID oid;
    OID Coclass;
    GUID MIMEType;

    void Init()
    {
         memset(this, 0, sizeof(RegDB_CoclassMIME));
    }

} RegDB_CoclassMIME;

#define COLID_RegDB_CoclassMIME_oid 1
#define COLID_RegDB_CoclassMIME_Coclass 2
#define COLID_RegDB_CoclassMIME_MIMEType 3



//*****************************************************************************
//  RegDB.RegCategory
//*****************************************************************************
typedef struct
{
    OID oid;
    OID Namespace;
    ULONG cbNameLen;
    wchar_t Name[256];
    GUID CATID;

    void Init()
    {
         memset(this, 0, sizeof(RegDB_RegCategory));
    }

} RegDB_RegCategory;

#define COLID_RegDB_RegCategory_oid 1
#define COLID_RegDB_RegCategory_Namespace 2
#define COLID_RegDB_RegCategory_Name 3
#define COLID_RegDB_RegCategory_CATID 4



//*****************************************************************************
//  RegDB.RegClass
//*****************************************************************************
typedef struct
{
    ULONG fNullFlags;
    OID oid;
    OID Namespace;
    ULONG cbNameLen;
    wchar_t Name[260];
    GUID clsid;
    GUID cvid;
    ULONG cbVersionLen;
    wchar_t Version[13];
    BYTE pad00 [2];
    OID Module;
    unsigned short BehaviorFlags;
    unsigned short ThreadingModel;
    unsigned short TransactionReqts;
    unsigned short SecurityReqts;
    unsigned short SynchReqts;
    BYTE pad01 [2];
    ULONG cbProgIDLen;
    wchar_t ProgID[260];
    ULONG cbVIProgIDLen;
    wchar_t VIProgID[260];
    ULONG cbDefaultIconLen;
    wchar_t DefaultIcon[260];
    long IconResourceID;
    ULONG cbToolboxBitmap32Len;
    wchar_t ToolboxBitmap32[260];
    long BitmapResourceID;
    ULONG cbShortDisplayNameLen;
    wchar_t ShortDisplayName[260];

	inline int IsShortDisplayNameNull(void)
	{ return (GetBit(fNullFlags, 11)); }

	inline void SetShortDisplayNameNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 11, nullBitVal); }

	inline int IsBitmapResourceIDNull(void)
	{ return (GetBit(fNullFlags, 10)); }

	inline void SetBitmapResourceIDNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 10, nullBitVal); }

	inline int IsToolboxBitmap32Null(void)
	{ return (GetBit(fNullFlags, 9)); }

	inline void SetToolboxBitmap32Null(int nullBitVal = true)
	{ SetBit(fNullFlags, 9, nullBitVal); }

	inline int IsIconResourceIDNull(void)
	{ return (GetBit(fNullFlags, 8)); }

	inline void SetIconResourceIDNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 8, nullBitVal); }

	inline int IsDefaultIconNull(void)
	{ return (GetBit(fNullFlags, 7)); }

	inline void SetDefaultIconNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 7, nullBitVal); }

	inline int IsVIProgIDNull(void)
	{ return (GetBit(fNullFlags, 6)); }

	inline void SetVIProgIDNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 6, nullBitVal); }

	inline int IsProgIDNull(void)
	{ return (GetBit(fNullFlags, 5)); }

	inline void SetProgIDNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 5, nullBitVal); }

	inline int IsSynchReqtsNull(void)
	{ return (GetBit(fNullFlags, 4)); }

	inline void SetSynchReqtsNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 4, nullBitVal); }

	inline int IsSecurityReqtsNull(void)
	{ return (GetBit(fNullFlags, 3)); }

	inline void SetSecurityReqtsNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 3, nullBitVal); }

	inline int IsTransactionReqtsNull(void)
	{ return (GetBit(fNullFlags, 2)); }

	inline void SetTransactionReqtsNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 2, nullBitVal); }

	inline int IsThreadingModelNull(void)
	{ return (GetBit(fNullFlags, 1)); }

	inline void SetThreadingModelNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 1, nullBitVal); }

    void Init()
    {
         memset(this, 0, sizeof(RegDB_RegClass));
         fNullFlags = (ULONG) -1;
    }

} RegDB_RegClass;

#define COLID_RegDB_RegClass_oid 1
#define COLID_RegDB_RegClass_Namespace 2
#define COLID_RegDB_RegClass_Name 3
#define COLID_RegDB_RegClass_clsid 4
#define COLID_RegDB_RegClass_cvid 5
#define COLID_RegDB_RegClass_Version 6
#define COLID_RegDB_RegClass_Module 7
#define COLID_RegDB_RegClass_BehaviorFlags 8
#define COLID_RegDB_RegClass_ThreadingModel 9
#define COLID_RegDB_RegClass_TransactionReqts 10
#define COLID_RegDB_RegClass_SecurityReqts 11
#define COLID_RegDB_RegClass_SynchReqts 12
#define COLID_RegDB_RegClass_ProgID 13
#define COLID_RegDB_RegClass_VIProgID 14
#define COLID_RegDB_RegClass_DefaultIcon 15
#define COLID_RegDB_RegClass_IconResourceID 16
#define COLID_RegDB_RegClass_ToolboxBitmap32 17
#define COLID_RegDB_RegClass_BitmapResourceID 18
#define COLID_RegDB_RegClass_ShortDisplayName 19



//*****************************************************************************
//  RegDB.RegIface
//*****************************************************************************
typedef struct
{
    ULONG fNullFlags;
    OID oid;
    GUID IID;
    GUID ProxyStub;
    OID ProxyStubOID;

	inline int IsProxyStubOIDNull(void)
	{ return (GetBit(fNullFlags, 1)); }

	inline void SetProxyStubOIDNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 1, nullBitVal); }

    void Init()
    {
         memset(this, 0, sizeof(RegDB_RegIface));
         fNullFlags = (ULONG) -1;
    }

} RegDB_RegIface;

#define COLID_RegDB_RegIface_oid 1
#define COLID_RegDB_RegIface_IID 2
#define COLID_RegDB_RegIface_ProxyStub 3
#define COLID_RegDB_RegIface_ProxyStubOID 4



//*****************************************************************************
//  RegDB.RegMIMEType
//*****************************************************************************
typedef struct
{
    OID oid;
    OID Namespace;
    ULONG cbNameLen;
    wchar_t Name[260];
    GUID MIMEID;
    ULONG cbFileExtLen;
    wchar_t FileExt[260];
    ULONG cbMIMEEncodingLen;
    wchar_t MIMEEncoding[260];

    void Init()
    {
         memset(this, 0, sizeof(RegDB_RegMIMEType));
    }

} RegDB_RegMIMEType;

#define COLID_RegDB_RegMIMEType_oid 1
#define COLID_RegDB_RegMIMEType_Namespace 2
#define COLID_RegDB_RegMIMEType_Name 3
#define COLID_RegDB_RegMIMEType_MIMEID 4
#define COLID_RegDB_RegMIMEType_FileExt 5
#define COLID_RegDB_RegMIMEType_MIMEEncoding 6



//*****************************************************************************
//  RegDB.RegModule
//*****************************************************************************
typedef struct
{
    OID oid;
    ULONG cbFilenameLen;
    wchar_t Filename[260];

    void Init()
    {
         memset(this, 0, sizeof(RegDB_RegModule));
    }

} RegDB_RegModule;

#define COLID_RegDB_RegModule_oid 1
#define COLID_RegDB_RegModule_Filename 2



//*****************************************************************************
//  RegDB.RegNamespace
//*****************************************************************************
typedef struct
{
    OID oid;
    ULONG cbNamespaceLen;
    wchar_t Namespace[260];

    void Init()
    {
         memset(this, 0, sizeof(RegDB_RegNamespace));
    }

} RegDB_RegNamespace;

#define COLID_RegDB_RegNamespace_oid 1
#define COLID_RegDB_RegNamespace_Namespace 2



//*****************************************************************************
//  RegDB.RegProcess
//*****************************************************************************
typedef struct
{
    ULONG fNullFlags;
    OID oid;
    GUID PID;
    ULONG cbProcessNameLen;
    wchar_t ProcessName[260];
    OID Namespace;
    unsigned short ProcessFlags;
    BYTE pad00 [2];
    long ShutdownLatency;
    ULONG cbRunAsNTUserLen;
    wchar_t RunAsNTUser[65];
    BYTE pad01 [2];
    OID Module;

	inline int IsRunAsNTUserNull(void)
	{ return (GetBit(fNullFlags, 4)); }

	inline void SetRunAsNTUserNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 4, nullBitVal); }

	inline int IsShutdownLatencyNull(void)
	{ return (GetBit(fNullFlags, 3)); }

	inline void SetShutdownLatencyNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 3, nullBitVal); }

	inline int IsProcessFlagsNull(void)
	{ return (GetBit(fNullFlags, 2)); }

	inline void SetProcessFlagsNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 2, nullBitVal); }

	inline int IsNamespaceNull(void)
	{ return (GetBit(fNullFlags, 1)); }

	inline void SetNamespaceNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 1, nullBitVal); }

    void Init()
    {
         memset(this, 0, sizeof(RegDB_RegProcess));
         fNullFlags = (ULONG) -1;
    }

} RegDB_RegProcess;

#define COLID_RegDB_RegProcess_oid 1
#define COLID_RegDB_RegProcess_PID 2
#define COLID_RegDB_RegProcess_ProcessName 3
#define COLID_RegDB_RegProcess_Namespace 4
#define COLID_RegDB_RegProcess_ProcessFlags 5
#define COLID_RegDB_RegProcess_ShutdownLatency 6
#define COLID_RegDB_RegProcess_RunAsNTUser 7
#define COLID_RegDB_RegProcess_Module 8



#pragma pack(pop)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\shimload.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header:  ShimLoad.hpp
**
** Purpose: Delay load hook used to images to bind to 
**          dll's shim shipped with the EE
**
** Date:    April 4, 2000
**
===========================================================*/
#ifndef _SHIMLOAD_H
#define _SHIMLOAD_H

#include <delayimp.h>

extern FARPROC __stdcall ShimDelayLoadHook(unsigned        dliNotify,          // What event has occured, dli* flag.
                                           DelayLoadInfo   *pdli);             // Description of the event.

//and one for safe mode
extern FARPROC __stdcall ShimSafeModeDelayLoadHook(unsigned        dliNotify,          // What event has occured, dli* flag.
                                           DelayLoadInfo   *pdli);             // Description of the event.

extern WCHAR g_wszDelayLoadVersion[64];

//*****************************************************************************
// Sets/Gets the directory based on the location of the module. This routine
// is called at COR setup time. Set is called during EEStartup and by the 
// MetaData dispenser.
//*****************************************************************************
HRESULT SetInternalSystemDirectory();
HRESULT GetInternalSystemDirectory(LPWSTR buffer, DWORD* pdwLength);
typedef HRESULT (WINAPI* GetCORSystemDirectoryFTN)(LPWSTR buffer,
                                                   DWORD  ccBuffer,
                                                   DWORD  *pcBuffer);
typedef HRESULT (WINAPI* LoadLibraryWithPolicyShimFTN)(LPCWSTR szDllName,
												   LPCWSTR szVersion,
												   BOOL bSafeMode,
												   HMODULE *phModDll);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\shacomm.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/* Copyright (C) RSA Data Security, Inc. created 1993.  This is an
   unpublished work protected as such under copyright law.  This work
   contains proprietary, confidential, and trade secret information of
   RSA Data Security, Inc.  Use, disclosure or reproduction without the
   express written authorization of RSA Data Security, Inc. is
   prohibited.
 */

#ifndef _SHACOMM_H_
#define _SHACOMM_H_ 1

#ifdef __cplusplus
extern "C" {
#endif

#define A_SHA_DIGEST_LEN 20

typedef struct {
  DWORD state[5];                                           /* state (ABCDE) */
  DWORD count[2];                              /* number of bytes, msb first */
  unsigned char buffer[64];                                  /* input buffer */
} A_SHA_COMM_CTX;

typedef void (A_SHA_TRANSFORM) (DWORD [5], unsigned char [64]);

void A_SHAInitCommon (A_SHA_COMM_CTX *);
void A_SHAUpdateCommon(A_SHA_COMM_CTX *, BYTE *, DWORD, A_SHA_TRANSFORM *);
void A_SHAFinalCommon(A_SHA_COMM_CTX *, BYTE[A_SHA_DIGEST_LEN],
		      A_SHA_TRANSFORM *);

void DWORDToBigEndian(unsigned char *, DWORD *, unsigned int);
void DWORDFromBigEndian(DWORD *, unsigned int, unsigned char *);

#ifdef __cplusplus
}
#endif

#endif // _SHACOMM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\sighelper.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ===========================================================================
// File: SIGHELPER.h
//
// This file defines the helpers for processing signature
// ===========================================================================
#ifndef __SigHelper_h__
#define __SigHelper_h__
#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef COMPLUS98

#include "utilcode.h"

#define CB_ELEMENT_TYPE_MAX						0x4

#define CorSigElementTypeSimple					0x0
#define CorSigElementTypeByRef					0x1
#define CorSigElementTypePtr					0x2


// Structure to represent a simple element type.
// Note that SDARRAY and MDARRAY cannot be represented by this struct. 
typedef struct 
{
	mdTypeRef	typeref;						// type reference for ELEMENT_TYPE_COMPOSITE and ELEMENT_TYPE_CLASS
	CorElementType corEType;					// element type
	BYTE		dwFlags;						// CorSigElementTypeBy*
	BYTE		cIndirection;					// count of indirection in the case that CorSigElementTypeByPtr is set
} CorSimpleETypeStruct;


// helpers to process and form CLR signature
HRESULT CorSigGetSimpleEType(
	void		*pData,					// [IN] pointing to the starting of an element type
	CorSimpleETypeStruct *pEType,		// [OUT] struct containing parsing result
	ULONG		*pcbCount);				// [OUT] how many bytes this element type consisted of

HRESULT CorSigGetSimpleETypeCbSize(		// return hresult
	CorSimpleETypeStruct *pEType,		// [IN] pass in 
	ULONG		*pcbCount);				// [OUT]count of bytes

HRESULT	CorSigPutSimpleEType(			// return hresult
	CorSimpleETypeStruct *pEType,		// [IN] pass in
	void		*pSig,					// [IN] buffer where the signature will be write to
	ULONG		*pcbCount);				// [OUT] optional, count of bytes that write to pSig

// helpers for processing Text signatures
BOOL ResolveTextSigToSimpleEType(		// return false if not a valid CorSimpleETypeStruct
	LPCUTF8		*ppwzSig,				// [IN|OUT] pointing to the signature
	CorSimpleETypeStruct *pEType,		// [OUT] struct to fill after parsing an arg or a ret type
	ULONG		*pcDims,				// count of '[' in the signature
	BOOL		fAllowVoid);			// [IN] allow void or not

// Banjara specific
BOOL BJResolveTextSigToSimpleEType(		// return false if not a valid CorSimpleETypeStruct
	LPCUTF8		*ppwzSig,				// [IN|OUT] pointing to the signature
	CorSimpleETypeStruct *pEType,		// [OUT] struct to fill after parsing an arg or a ret type
	ULONG		*pcDims,				// count of '[' in the signature
	BOOL		fAllowVoid);			// [IN] allow void or not

BOOL ExtractClassNameFromTextSig(		// return false if not a valid CorSimpleETypeStruct
	LPCUTF8		*ppSrc,					// [IN|OUT] text signature. On exit, *ppSrc will skip over the class name including ";"
	CQuickBytes *pqbClassName,			// [IN|OUT] buffer to hold class name
	ULONG		*pcbBuffer);			// [OUT] count of bytes for the class name

DWORD CountArgsInTextSignature(			// return count of arguments 
	LPCUTF8		pwzSig);				// [IN] given a Text signature

#endif // !COMPLUS98



// CeeCallSignature
// ***** CeeCallSignature classes

class CeeCallSignature {
    unsigned _numArgs;
	unsigned _curPosNibble; // Current position in Nibble stream
	UCHAR *_signature;
	unsigned calcNumBytes(unsigned numArgs) const;
	void setMost(UCHAR *byte, UCHAR val);
	void setLeast(UCHAR *byte, UCHAR val);
	HRESULT addType(UCHAR argType, unsigned structSize, bool returnType);
  public:
	CeeCallSignature(unsigned numArgs=255);
	~CeeCallSignature();
	HRESULT addArg(UCHAR argType, unsigned structSize=0);
	HRESULT setReturnType(UCHAR returnType, unsigned structSize=0);
	HRESULT setCallingConvention(UCHAR callingConvention);
	unsigned signatureSize() const;
	void *signatureData();
};

// ***** CeeCallSignature inline methods

inline unsigned CeeCallSignature::calcNumBytes(unsigned numArgs) const {
    // Each signature is made up of 4 bit nibbles. There are always
	// at least 3 (calling convention, return type, end code) and
	// the total number is padded to an even count for byte alignment

    return (numArgs + 3)/2 + (numArgs + 3)%2;
}

inline unsigned CeeCallSignature::signatureSize() const {
	// signature may have been preallocated with more args than needed
	// so use _curPosNibble to determine real length
	// since _curPosNibble is not a count of args, can't pass it to calcNumBytes()
	// so must compute size indepedently

	return (_curPosNibble / 2) + 1;

}

inline void *CeeCallSignature::signatureData() {
    return _signature;
}

inline void CeeCallSignature::setMost(UCHAR *byte, UCHAR val) {
	_ASSERTE(val < 0x0F);
	_ASSERTE((*byte & 0xF0) == 0); // must |= with 0 to do assignment
	*byte |= val << 4;
}

inline void CeeCallSignature::setLeast(UCHAR *byte, UCHAR val) {
	_ASSERTE(val < 0x0F);
	_ASSERTE((*byte & 0x0F) == 0); // must |= with 0 to do assignment
	*byte |= val;
}

inline HRESULT 
CeeCallSignature::setReturnType(UCHAR returnType, unsigned structSize) {
	return addType(returnType, structSize, true);
}

inline HRESULT CeeCallSignature::setCallingConvention(UCHAR callingConvention) {
    // set the least significant 4 bits of first byte
	setLeast(_signature, callingConvention);
	return S_OK;
}

#endif // __SigHelper_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\stacktrace.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//----------------------------------------------------------------------------- 
// Microsoft Confidential 
// robch@microsoft.com
//----------------------------------------------------------------------------- 

#pragma once

HINSTANCE LoadImageHlp();

#ifdef _DEBUG

//#include <windows.h>

#define strupr _strupr

//
//--- Constants ---------------------------------------------------------------
//

#define cchMaxAssertModuleLen 12
#define cchMaxAssertSymbolLen 257
#define cfrMaxAssertStackLevels 20
#define cchMaxAssertExprLen 257

#define cchMaxAssertStackLevelStringLen \
    ((2 * 8) + cchMaxAssertModuleLen + cchMaxAssertSymbolLen + 12)
    // 2 addresses of at most 8 char, module, symbol, and the extra chars:
    // 0x<address>: <module>! <symbol> + 0x<offset>\n

//
//--- Prototypes --------------------------------------------------------------
//

/****************************************************************************
* MagicDeinit *
*-------------*
*   Description:  
*       Cleans up for the symbol loading code. Should be called before
*       exiting in order to free the dynamically loaded imagehlp.dll
******************************************************************** robch */
void MagicDeinit(void);

/****************************************************************************
* GetStringFromStackLevels *
*--------------------------*
*   Description:  
*       Retrieves a string from the stack frame. If more than one frame, they
*       are separated by newlines. Each fram appears in this format:
*
*           0x<address>: <module>! <symbol> + 0x<offset>
******************************************************************** robch */
void GetStringFromStackLevels(UINT ifrStart, UINT cfrTotal, CHAR *pszString);

/****************************************************************************
* GetAddrFromStackLevel *
*-----------------------*
*   Description:  
*       Retrieves the address of the next instruction to be executed on a
*       particular stack frame.
*
*   Return:
*       The address as a DWORD.
******************************************************************** robch */
DWORD GetAddrFromStackLevel(UINT ifrStart);

/****************************************************************************
* GetStringFromAddr *
*-------------------*
*   Description:  
*       Builds a string from an address in the format:
*
*           0x<address>: <module>! <symbol> + 0x<offset>
******************************************************************** robch */
void GetStringFromAddr(DWORD dwAddr, LPSTR szString);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\stresslog.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*************************************************************************************/
/*                                   StressLog.h                                     */
/*************************************************************************************/

/* StressLog is a binary, memory based cirular queue of logging messages.  It is 
   intended to be used in retail, non-golden builds during stress runs (activated
   by registry key), so to help find bugs that only turn up during stress runs.  

   It is meant to have very low overhead and can not cause deadlocks, etc.  It is
   however thread safe */

/* The log has a very simple structure, and it meant to be dumped from a NTSD 
   extention (eg. strike). There is no memory allocation system calls etc to purtub things */

/* see the tools/strike/stressdump.cpp for the dumper utility that parses this log */

/*************************************************************************************/

#ifndef StressLog_h 
#define StressLog_h  1

#ifdef STRESS_LOG

#include "log.h"

/* The STRESS_LOG* macros work like printf.  In fact the use printf in their implementation
   so all printf format specifications work.  In addition the Stress log dumper knows 
   about certain suffixes for the %p format specification (normally used to print a pointer)

			%pM		// The poitner is a MethodDesc
			%pT		// The pointer is a type (MethodTable)
			%pV		// The pointer is a C++ Vtable pointer (useful for distinguishing different types of frames
*/
	
#define STRESS_LOG0(facility, level, msg) do {					\
			if (StressLog::StressLogOn(facility))				\
				StressLog::LogMsg(msg, 0);						\
			LOG((facility, level, msg));						\
			} while(0)

#define STRESS_LOG1(facility, level, msg, data1) do {					\
			if (StressLog::StressLogOn(facility))						\
				StressLog::LogMsg(msg, (void*)(size_t)data1);			\
			LOG((facility, level, msg, data1));							\
			} while(0)

#define STRESS_LOG2(facility, level, msg, data1, data2) do {								\
			if (StressLog::StressLogOn(facility))											\
				StressLog::LogMsg(msg, (void*)(size_t) data1,(void*)(size_t) data2, 0, 0);	\
			LOG((facility, level, msg, data1, data2));										\
			} while(0)

#define STRESS_LOG3(facility, level, msg, data1, data2, data3) do {												\
			if (StressLog::StressLogOn(facility))																\
				StressLog::LogMsg(msg, (void*)(size_t) data1,(void*)(size_t) data2,(void*)(size_t) data3, 0);	\
			LOG((facility, level, msg, data1, data2, data3));					 								\
			} while(0)

#define STRESS_LOG4(facility, level, msg, data1, data2, data3, data4) do {								\
			if (StressLog::StressLogOn(facility))														\
				StressLog::LogMsg(msg, (void*)(size_t) data1,(void*)(size_t) data2,(void*)(size_t) data3,(void*)(size_t) data4);\
			LOG((facility, level, msg, data1, data2, data3, data4));									\
			} while(0)

/*************************************************************************************/
/* a log is a circular queue of messages */
	
class StressLog {
public:
	static void Initialize(unsigned facilities,  unsigned logBytesPerThread);
	static void Terminate();
	static void ThreadDetach();			// call at DllMain	THREAD_DETACH if you want to recycle thread logs

		// used by out of process debugger to dump the stress log to 'fileName'
		// IDebugDataSpaces is the NTSD execution callback for getting process memory.  
		// This function is defined in the tools\strike\stressLogDump.cpp file
	static HRESULT Dump(ULONG64 logAddr, const char* fileName, struct IDebugDataSpaces* memCallBack);
	static BOOL StressLogOn(unsigned facility) { return theLog.facilitiesToLog & facility; }

// private:
	unsigned facilitiesToLog;				// Bitvector of facilities to log (see loglf.h)
	unsigned size;							// maximum number of bytes each thread should have before wrapping
	class ThreadStressLog* volatile logs;	// the list of logs for every thread.
	volatile unsigned TLSslot;				// Each thread gets a log this is used to fetch each threads log
	volatile LONG deadCount;				// count of dead threads in the log
	volatile LONG lock;						// spin lock

// private: 
	void static Enter();
	void static Leave();
	static ThreadStressLog* CreateThreadStressLog();
	static void LogMsg(const char* format, void* data);
	static void LogMsg(const char* format, void* data1, void* data2, void* data3, void* data4);
	
// private: // static variables
	static StressLog theLog; 	// We only have one log, and this is it
};


/*************************************************************************************/
/* private classes */

#pragma warning(disable:4200)					// don't warn about 0 sized array below

class StressMsg {
	const char* format;
	void* data;									// right now stress logs can have 0 or 1 parameter
	union {
		unsigned __int64 timeStamp;
		struct {
			void* data2;
			void* data3;
		} moreData;
	};
	friend class ThreadStressLog;
	friend class StressLog;
};

class ThreadStressLog {
	ThreadStressLog* next;		// we keep a linked list of these
	unsigned  threadId;			// the id for the thread using this buffer
	BOOL isDead;				// Is this thread dead 
	StressMsg* endPtr;			// points just past allocated space
	StressMsg* curPtr;			// where packets are being put on the queue
	StressMsg* readPtr;			// where we are reading off the queue (used during dumping)
	StressMsg startPtr[0];		// start of the cirular buffer

	static const char* continuationMsg() { return "StressLog Continuation Marker\n"; }
	StressMsg* Prev(StressMsg* ptr) const;
	StressMsg* Next(StressMsg* ptr) const;
	ThreadStressLog* FindLatestThreadLog() const;
	friend class StressLog;
};

/*********************************************************************************/
inline StressMsg* ThreadStressLog::Prev(StressMsg* ptr) const {
	if (ptr == startPtr)
		ptr = endPtr;
	--ptr;
	return ptr;
}

/*********************************************************************************/
inline StressMsg* ThreadStressLog::Next(StressMsg* ptr) const {
	ptr++;
	if (ptr == endPtr)
		ptr = const_cast<StressMsg*>(startPtr);
	return ptr;
}


#else  	// STRESS_LOG

#define STRESS_LOG0(facility, level, msg)								0
#define STRESS_LOG1(facility, level, msg, data1)						0
#define STRESS_LOG2(facility, level, msg, data1, data2)					0
#define STRESS_LOG3(facility, level, msg, data1, data2, data3)			0
#define STRESS_LOG4(facility, level, msg, data1, data2, data3, data4)	0

#endif // STRESS_LOG

#endif // StressLog_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\stgpool.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// StgPool.h
//
// Pools are used to reduce the amount of data actually required in the database.
// This allows for duplicate string and binary values to be folded into one
// copy shared by the rest of the database.  Strings are tracked in a hash
// table when insert/changing data to find duplicates quickly.  The strings
// are then persisted consecutively in a stream in the database format.
//
//*****************************************************************************
#ifndef __StgPool_h__
#define __StgPool_h__

#pragma warning (disable : 4355)        // warning C4355: 'this' : used in base member initializer list

#include <limits.h>
#include "StgPooli.h"                   // Internal helpers.
#include "CorError.h"                   // Error codes.
#include "Metadatatracker.h"


//*****************************************************************************
// NOTE:
// One limitation with the pools, we have no way to removing strings from
// the pool.  To remove, you need to know the ref count on the string, and
// need the ability to compact the pool and reset all references.
//*****************************************************************************

//********** Constants ********************************************************
const int DFT_STRING_HEAP_SIZE = 2048;
const int DFT_GUID_HEAP_SIZE = 2048;
const int DFT_BLOB_HEAP_SIZE = 1024;
const int DFT_VARIANT_HEAP_SIZE = 512;
const int DFT_CODE_HEAP_SIZE = 8192;



// Forwards.
class StgStringPool;
class StgBlobPool;
class StgCodePool;


//*****************************************************************************
// This class provides common definitions for heap segments.  It is both the
//  base class for the heap, and the class for heap extensions (additional
//  memory that must be allocated to grow the heap).
//*****************************************************************************
class StgPoolSeg
{
public:
    StgPoolSeg() : 
        m_pSegData((BYTE*)m_zeros), 
        m_pNextSeg(0), 
        m_cbSegSize(0), 
        m_cbSegNext(0) 
    { }
    ~StgPoolSeg() 
    { _ASSERTE(m_pSegData == m_zeros);_ASSERTE(m_pNextSeg == 0); }
protected:
    BYTE        *m_pSegData;            // Pointer to the data.
    StgPoolSeg  *m_pNextSeg;            // Pointer to next segment, or 0.
    ULONG       m_cbSegSize;            // Size of the buffer.  Note that this may
                                        //  be less than the allocated size of the
                                        //  buffer, if the segment has been filled
                                        //  and a "next" allocated.
    ULONG       m_cbSegNext;            // Offset of next available byte in segment.
                                        //  Segment relative.

    friend class StgPool;
    friend class StgStringPool;
    friend class StgGuidPool;
    friend class StgBlobPool;
    friend class RecordPool;

public:
    const BYTE *GetSegData() const { return m_pSegData; }
    const StgPoolSeg* GetNextSeg() const { return m_pNextSeg; }
    ULONG GetSegSize() const { return m_cbSegSize; }

    static const BYTE m_zeros[16];          // array of zeros for "0" indices.
};

//
//
// StgPoolReadOnly
//
// 
//*****************************************************************************
// This is the read only StgPool class
//*****************************************************************************
class StgPoolReadOnly : public StgPoolSeg
{
friend CBlobPoolHash;

public:
    StgPoolReadOnly() { };

    ~StgPoolReadOnly();

    
//*****************************************************************************
// Init the pool from existing data.
//*****************************************************************************
    virtual HRESULT InitOnMemReadOnly(              // Return code.
        void        *pData,                 // Predefined data.
        ULONG       iSize);                 // Size of data.

//*****************************************************************************
// Prepare to shut down or reinitialize.
//*****************************************************************************
    virtual void Uninit();

//*****************************************************************************
// Return the size of the pool.
//*****************************************************************************
    virtual ULONG GetPoolSize()
    { return m_cbSegSize; }

//*****************************************************************************
// Indicate if heap is empty.
//*****************************************************************************
    virtual int IsEmpty()                   // true if empty.
    { return (m_pSegData == m_zeros); }

//*****************************************************************************
// How big is a cookie for this heap.
//*****************************************************************************
    virtual int OffsetSize()
    {
        if (m_cbSegSize < USHRT_MAX)
            return (sizeof(USHORT));
        else
            return (sizeof(ULONG));
    }

//*****************************************************************************
// true if the heap is read only.
//*****************************************************************************
    virtual int IsReadOnly() { return true ;};

//*****************************************************************************
// Is the given cookie a valid offset, index, etc?
//*****************************************************************************
    virtual int IsValidCookie(ULONG ulCookie)
    { return (IsValidOffset(ulCookie)); }


//*****************************************************************************
// Return a pointer to a null terminated string given an offset previously
// handed out by AddString or FindString.
//*****************************************************************************
    FORCEINLINE LPCSTR GetStringReadOnly(   // Pointer to string.
        ULONG       iOffset)                // Offset of string in pool.
    {     return (reinterpret_cast<LPCSTR>(GetDataReadOnly(iOffset))); }

//*****************************************************************************
// Return a pointer to a null terminated string given an offset previously
// handed out by AddString or FindString.
//*****************************************************************************
    FORCEINLINE LPCSTR GetString(           // Pointer to string.
        ULONG       iOffset)                // Offset of string in pool.
    {     return (reinterpret_cast<LPCSTR>(GetData(iOffset))); }

//*****************************************************************************
// Convert a string to UNICODE into the caller's buffer.
//*****************************************************************************
    virtual HRESULT GetStringW(                     // Return code.
        ULONG       iOffset,                // Offset of string in pool.
        LPWSTR      szOut,                  // Output buffer for string.
        int         cchBuffer);             // Size of output buffer.

//*****************************************************************************
// Return a pointer to a Guid given an index previously handed out by
// AddGuid or FindGuid.
//*****************************************************************************
    virtual GUID *GetGuid(                  // Pointer to guid in pool.
        ULONG       iIndex);                // 1-based index of Guid in pool.



//*****************************************************************************
// Copy a GUID into the caller's buffer.
//*****************************************************************************
    virtual HRESULT GetGuid(                // Return code.
        ULONG       iIndex,                 // 1-based index of Guid in pool.
        GUID        *pGuid)                 // Output buffer for Guid.
    {
        *pGuid = *GetGuid(iIndex);
        return (S_OK);
    }


//*****************************************************************************
// Return a pointer to a null terminated blob given an offset previously
// handed out by Addblob or Findblob.
//*****************************************************************************
    virtual void *GetBlob(                  // Pointer to blob's bytes.
        ULONG       iOffset,                // Offset of blob in pool.
        ULONG       *piSize);               // Return size of blob.


protected:

//*****************************************************************************
// Check whether a given offset is valid in the pool.
//*****************************************************************************
    virtual int IsValidOffset(ULONG ulOffset)
    { return ulOffset == 0 || (m_pSegData != m_zeros && ulOffset < m_cbSegSize); }

//*****************************************************************************
// Get a pointer to an offset within the heap.  Inline for base segment,
//  helper for extension segments.
//*****************************************************************************
    FORCEINLINE BYTE *GetDataReadOnly(ULONG ulOffset)
    {
        _ASSERTE(IsReadOnly());
        //_ASSERTE(ulOffset < m_cbSegSize && "Attempt to access past end of heap.");
        METADATATRACKER_ONLY(MetaDataTracker::NoteAccess(m_pSegData+ulOffset, -1));
        METADATATRACKER_ONLY(MetaDataTracker::LogHeapAccess(m_pSegData+ulOffset, -1));

#if !defined(NO_INLINE_METADATA_CHECKS)
        // If off the end of the heap, return the 'nul' item from the beginning.
        if (ulOffset >= m_cbSegSize)
            ulOffset = 0;
#endif // !defined(NO_INLINE_METADATA_CHECKS)

        return (m_pSegData+ulOffset); 
    }

//*****************************************************************************
// Get a pointer to an offset within the heap.  Inline for base segment,
//  helper for extension segments.
//*****************************************************************************
    virtual BYTE *GetData(ULONG ulOffset)
    {
        return (GetDataReadOnly(ulOffset));
    }

//*****************************************************************************
// Return a pointer to a Guid given an index previously handed out by
// AddGuid or FindGuid.
//*****************************************************************************
    GUID *GetGuidi(                         // Pointer to guid in pool.
        ULONG       iIndex);                // 0-based index of Guid in pool.

};

//
//
// StgBlobPoolReadOnly
//
// 
//*****************************************************************************
// This is the read only StgBlobPool class
//*****************************************************************************
class StgBlobPoolReadOnly : public StgPoolReadOnly
{
friend CBlobPoolHash;

protected:

//*****************************************************************************
// Check whether a given offset is valid in the pool.
//*****************************************************************************
    virtual int IsValidOffset(ULONG ulOffset)
    { 
        if(ulOffset)
        {
            if((m_pSegData != m_zeros) && (ulOffset < m_cbSegSize))
            {
                ULONG ulSize = CPackedLen::GetLength(m_pSegData+ulOffset, (void const **)NULL);
                if(ulOffset+ulSize < m_cbSegSize) return true;
            }
            return false;
        }
        else return true;
    }
};

//
//
// StgPool
//
//

//*****************************************************************************
// This base class provides common pool management code, such as allocation
// of dynamic memory.
//*****************************************************************************
class StgPool : public StgPoolReadOnly
{
friend StgStringPool;
friend StgBlobPool;
friend class RecordPool;
friend CBlobPoolHash;

public:
    StgPool(ULONG ulGrowInc=512, ULONG ulAlignment=4) :
        m_ulGrowInc(ulGrowInc),
        m_pCurSeg(this),
        m_cbCurSegOffset(0),
        m_bFree(true),
        m_bDirty(false),
        m_bReadOnly(false),
        m_State(eNormal),
        m_ulAlignment(ulAlignment-1)
    { }

    virtual ~StgPool();

//*****************************************************************************
// Init the pool for use.  This is called for the create empty case.
//*****************************************************************************
    virtual HRESULT InitNew(                // Return code.
        ULONG       cbSize=0,               // Estimated size.
        ULONG       cItems=0);              // Estimated item count.

//*****************************************************************************
// Init the pool from existing data.
//*****************************************************************************
    virtual HRESULT InitOnMem(              // Return code.
        void        *pData,                 // Predefined data.
        ULONG       iSize,                  // Size of data.
        int         bReadOnly);             // true if append is forbidden.

//*****************************************************************************
// Init the pool from existing data.
//*****************************************************************************
    virtual HRESULT InitOnMemReadOnly(      // Return code.
        void        *pData,                 // Predefined data.
        ULONG       iSize);                 // Size of data.

//*****************************************************************************
// Called when the pool must stop accessing memory passed to InitOnMem().
//*****************************************************************************
    virtual HRESULT TakeOwnershipOfInitMem();

//*****************************************************************************
// Clear out this pool.  Cannot use until you call InitNew.
//*****************************************************************************
    virtual void Uninit();

//*****************************************************************************
// Called to copy the pool to writable memory, reset the r/o bit.
//*****************************************************************************
    virtual HRESULT ConvertToRW();

//*****************************************************************************
// Turn hashing off or on.  Implemented as required in subclass.
//*****************************************************************************
    virtual HRESULT SetHash(int bHash);

//*****************************************************************************
// Allocate memory if we don't have any, or grow what we have.  If successful,
// then at least iRequired bytes will be allocated.
//*****************************************************************************
    bool Grow(                              // true if successful.
        ULONG       iRequired);             // Min required bytes to allocate.

//*****************************************************************************
// Add a segment to the chain of segments.
//*****************************************************************************
    virtual HRESULT AddSegment(             // S_OK or error.
        const void  *pData,                 // The data.
        ULONG       cbData,                 // Size of the data.
        bool        bCopy);                 // If true, make a copy of the data.

//*****************************************************************************
// Trim any empty final segment.
//*****************************************************************************
    void Trim();                            //

//*****************************************************************************
// Return the size in bytes of the persistent version of this pool.  If
// PersistToStream were the next call, the amount of bytes written to pIStream
// has to be same as the return value from this function.
//*****************************************************************************
    virtual HRESULT GetSaveSize(            // Return code.
        ULONG       *pcbSaveSize)           // Return save size of this pool.
    {
        _ASSERTE(pcbSaveSize);
        // Size is offset of last seg + size of last seg.
        ULONG ulSize = m_pCurSeg->m_cbSegNext + m_cbCurSegOffset;
        // Align.
        ulSize = Align(ulSize);

        *pcbSaveSize = ulSize;
        return (S_OK);
    }

//*****************************************************************************
// Copy the given pool into this pool in the organized format.
//*****************************************************************************
    static HRESULT SaveCopy(                // Return code.
        StgPool     *pTo,                   // Copy to this heap.
        StgPool     *pFrom,                 // From this heap.
        StgBlobPool *pBlobPool=0,           // Pool to keep blobs in.
        StgStringPool *pStringPool=0);      // String pool for variant heap.

//*****************************************************************************
// Free the data that was allocated for this heap.  The SaveCopy method
// allocates the data from the mem heap and then gives it to this heap to
// use as read only memory.  We'll ask the heap for that pointer and free it.
//*****************************************************************************
    static void FreeCopy(
        StgPool     *pCopy);                // Heap with copy data.

//*****************************************************************************
// The entire pool is written to the given stream. The stream is aligned
// to a 4 byte boundary.
//*****************************************************************************
    virtual HRESULT PersistToStream(        // Return code.
        IStream     *pIStream);             // The stream to write to.

//*****************************************************************************
// A portion of the pool is written to the stream.  Must not be optimized.
//*****************************************************************************
    virtual HRESULT PersistPartialToStream( // Return code.
        IStream     *pIStream,              // The stream to write to.
        ULONG       iOffset);               // Starting byte.

//*****************************************************************************
// Return true if this pool is dirty.
//*****************************************************************************
    virtual int IsDirty()                   // true if dirty.
    { return (m_bDirty); }
    void SetDirty(int bDirty=true)
    { m_bDirty = bDirty; }

//*****************************************************************************
// Return the size of the pool.
//*****************************************************************************
    virtual ULONG GetPoolSize()
    { return m_pCurSeg->m_cbSegNext + m_cbCurSegOffset; }

//*****************************************************************************
// Indicate if heap is empty.
//*****************************************************************************
    virtual int IsEmpty()                   // true if empty.
    { return (m_pSegData == m_zeros); }

//*****************************************************************************
// How big is a cookie for this heap.
//*****************************************************************************
    virtual int OffsetSize()
    {
        if (m_pCurSeg->m_cbSegNext + m_cbCurSegOffset < USHRT_MAX)
            return (sizeof(USHORT));
        else
            return (sizeof(ULONG));
    }

//*****************************************************************************
// true if the heap is read only.
//*****************************************************************************
    int IsReadOnly()
    { return (m_bReadOnly == false); }

//*****************************************************************************
// Is the given cookie a valid offset, index, etc?
//*****************************************************************************
    virtual int IsValidCookie(ULONG ulCookie)
    { return (IsValidOffset(ulCookie)); }

//*****************************************************************************
// Reorganization interface.
//*****************************************************************************
    // Prepare for pool re-organization.
    virtual HRESULT OrganizeBegin();
    // Mark an object as being live in the organized pool.
    virtual HRESULT OrganizeMark(ULONG ulOffset);
    // Organize, based on marked items.
    virtual HRESULT OrganizePool();
    // Remap a cookie from the in-memory state to the persisted state.
    virtual HRESULT OrganizeRemap(ULONG ulOld, ULONG *pulNew);
    // Done with regoranization.  Release any state.
    virtual HRESULT OrganizeEnd();

    enum {eNormal, eMarking, eOrganized} m_State;

#if defined(_TRACE_SIZE)
    virtual ULONG PrintSizeInfo(bool verbose) PURE;
#endif

//*****************************************************************************
// Get a pointer to an offset within the heap.  Inline for base segment,
//  helper for extension segments.
//*****************************************************************************
    FORCEINLINE BYTE *GetData(ULONG ulOffset)
    { return ((ulOffset < m_cbSegNext) ? (m_pSegData+ulOffset) : GetData_i(ulOffset)); }


//*****************************************************************************
// Helpers for dump utilities.    
//*****************************************************************************
    HRESULT GetRawSize(                     // Return code.
        ULONG       *pcbSaveSize)           // Return save size of this pool.
    {
        // Size is offset of last seg + size of last seg.
        *pcbSaveSize = m_pCurSeg->m_cbSegNext + m_cbCurSegOffset;
        return (S_OK);
    }
    
    virtual HRESULT GetNextItem(            // Return code.
        ULONG       ulItem,                 // Current item.
        ULONG       *pulNext)               // Return offset of next pool item.
    {
        // Must provide an implementation.
        return E_NOTIMPL;
    }

protected:

//*****************************************************************************
// Check whether a given offset is valid in the pool.
//*****************************************************************************
    virtual int IsValidOffset(ULONG ulOffset)
    { return ulOffset == 0 || (m_pSegData != m_zeros && ulOffset < GetNextOffset()); }

    // Following virtual because a) this header included outside the project, and
    //  non-virtual function call (in non-expanded inline function!!) generates
    //  an external def, which causes linkage errors.
    virtual BYTE *GetData_i(ULONG ulOffset);

    // Get pointer to next location to which to write.
    BYTE *GetNextLocation()
    { return (m_pCurSeg->m_pSegData + m_pCurSeg->m_cbSegNext); }

    // Get pool-relative offset of next location to which to write.
    ULONG GetNextOffset()
    { return (m_cbCurSegOffset + m_pCurSeg->m_cbSegNext); }

    // Get count of bytes available in tail segment of pool.
    ULONG GetCbSegAvailable()
    { return (m_pCurSeg->m_cbSegSize - m_pCurSeg->m_cbSegNext); }

    // Allocate space from the segment.
    void SegAllocate(ULONG cb)
    {
        _ASSERTE(cb <= GetCbSegAvailable());
        m_pCurSeg->m_cbSegNext += cb;
    }

    ULONG       m_ulGrowInc;                // How many bytes at a time.
    StgPoolSeg  *m_pCurSeg;                 // Current seg for append -- end of chain.
    ULONG       m_cbCurSegOffset;           // Base offset of current seg.

    unsigned    m_bFree     : 1;            // True if we should free base data.
                                            //  Extension data is always freed.
    unsigned    m_bDirty    : 1;            // Dirty bit.
    unsigned    m_bReadOnly : 1;            // True if we shouldn't append.

    ULONG       m_ulAlignment;              // Alignment boundary.

    template<class T> T Align(T val) { return (T)((((UINT_PTR)val) + m_ulAlignment) & ~m_ulAlignment); }

};


//
//
// StgStringPool
//
//



//*****************************************************************************
// This string pool class collects user strings into a big consecutive heap.
// Internally it manages this data in a hash table at run time to help throw
// out duplicates.  The list of strings is kept in memory while adding, and
// finally flushed to a stream at the caller's request.
//*****************************************************************************
class StgStringPool : public StgPool
{
public:
    StgStringPool() :
        StgPool(DFT_STRING_HEAP_SIZE),
        m_Hash(this),
        m_bHash(true)
    {   // force some code in debug.
        _ASSERTE(m_bHash);
    }

//*****************************************************************************
// Create a new, empty string pool.
//*****************************************************************************
    HRESULT InitNew(                        // Return code.
        ULONG       cbSize=0,               // Estimated size.
        ULONG       cItems=0);              // Estimated item count.

//*****************************************************************************
// Load a string heap from persisted memory.  If a copy of the data is made
// (so that it may be updated), then a new hash table is generated which can
// be used to elminate duplicates with new strings.
//*****************************************************************************
    HRESULT InitOnMem(                      // Return code.
        void        *pData,                 // Predefined data.
        ULONG       iSize,                  // Size of data.
        int         bReadOnly);             // true if append is forbidden.

//*****************************************************************************
// Clears the hash table then calls the base class.
//*****************************************************************************
    void Uninit();

//*****************************************************************************
// Turn hashing off or on.  If you turn hashing on, then any existing data is
// thrown away and all data is rehashed during this call.
//*****************************************************************************
    virtual HRESULT SetHash(int bHash);

//*****************************************************************************
// The string will be added to the pool.  The offset of the string in the pool
// is returned in *piOffset.  If the string is already in the pool, then the
// offset will be to the existing copy of the string.
// 
// The first version essentially adds a zero-terminated sequence of bytes
//  to the pool.  MBCS pairs will not be converted to the appropriate UTF8
//  sequence.  The second version does perform necessary conversions.
//  The third version converts from Unicode.
//*****************************************************************************
    HRESULT AddString(                      // Return code.
        LPCSTR      szString,               // The string to add to pool.
        ULONG       *piOffset,              // Return offset of string here.
        int         iLength=-1);            // chars in string; -1 null terminated.

    HRESULT AddStringA(                     // Return code.
        LPCSTR      szString,               // The string to add to pool.
        ULONG       *piOffset,              // Return offset of string here.
        int         iLength=-1);            // chars in string; -1 null terminated.

    HRESULT AddStringW(                     // Return code.
        LPCWSTR     szString,               // The string to add to pool.
        ULONG       *piOffset,              // Return offset of string here.
        int         iLength=-1);            // chars in string; -1 null terminated.

//*****************************************************************************
// Look for the string and return its offset if found.
//*****************************************************************************
    HRESULT FindString(                     // S_OK, S_FALSE.
        LPCSTR      szString,               // The string to find in pool.
        ULONG       *piOffset)              // Return offset of string here.
    {
        STRINGHASH  *pHash;                 // Hash item for lookup.
        if ((pHash = m_Hash.Find(szString)) == 0)
            return (S_FALSE);
        *piOffset = pHash->iOffset;
        return (S_OK);
    }

#if 0
//*****************************************************************************
// Return a pointer to a null terminated string given an offset previously
// handed out by AddString or FindString.
//*****************************************************************************
    virtual LPCSTR GetString(               // Pointer to string.
        ULONG       iOffset);               // Offset of string in pool.

//*****************************************************************************
// Convert a string to UNICODE into the caller's buffer.
//*****************************************************************************
    virtual HRESULT GetStringW(             // Return code.
        ULONG       iOffset,                // Offset of string in pool.
        LPWSTR      szOut,                  // Output buffer for string.
        int         cchBuffer);             // Size of output buffer.
#endif // 0


//*****************************************************************************
// How many objects are there in the pool?  If the count is 0, you don't need
// to persist anything at all to disk.
//*****************************************************************************
    int Count()
    { _ASSERTE(m_bHash);
        return (m_Hash.Count()); }

//*****************************************************************************
// String heap is considered empty if the only thing it has is the initial
// empty string, or if after organization, there are no strings.
//*****************************************************************************
    int IsEmpty()                       // true if empty.
    { 
        if (m_State == eNormal)
            return (GetNextOffset() <= 1); 
        else
            return (m_cbOrganizedSize == 0);
    }

//*****************************************************************************
// Reorganization interface.
//*****************************************************************************
    // Prepare for pool re-organization.
    virtual HRESULT OrganizeBegin();
    // Mark an object as being live in the organized pool.
    virtual HRESULT OrganizeMark(ULONG ulOffset);
    // Organize, based on marked items.
    virtual HRESULT OrganizePool();
    // Remap a cookie from the in-memory state to the persisted state.
    virtual HRESULT OrganizeRemap(ULONG ulOld, ULONG *pulNew);
    // Done with regoranization.  Release any state.
    virtual HRESULT OrganizeEnd();

//*****************************************************************************
// How big is a cookie for this heap.
//*****************************************************************************
    int OffsetSize()
    {
        ULONG       ulOffset;

        // Pick an offset based on whether we've been organized.
        if (m_State == eOrganized)
            ulOffset = m_cbOrganizedOffset;
        else
            ulOffset = GetNextOffset();

        if (ulOffset< USHRT_MAX)
            return (sizeof(USHORT));
        else
            return (sizeof(ULONG));
    }

//*****************************************************************************
// Return the size in bytes of the persistent version of this pool.  If
// PersistToStream were the next call, the amount of bytes written to pIStream
// has to be same as the return value from this function.
//*****************************************************************************
    virtual HRESULT GetSaveSize(            // Return code.
        ULONG       *pcbSaveSize)           // Return save size of this pool.
    {
        ULONG       ulSize;                 // The size.
        _ASSERTE(pcbSaveSize);

        if (m_State == eOrganized)
            ulSize = m_cbOrganizedSize;
        else
        {   // Size is offset of last seg + size of last seg.
            ulSize = m_pCurSeg->m_cbSegNext + m_cbCurSegOffset;
        }
        // Align.
        ulSize = ALIGN4BYTE(ulSize);

        *pcbSaveSize = ulSize;
        return (S_OK);
    }

//*****************************************************************************
// The entire string pool is written to the given stream. The stream is aligned
// to a 4 byte boundary.
//*****************************************************************************
    virtual HRESULT PersistToStream(        // Return code.
        IStream     *pIStream);             // The stream to write to.

#if defined(_TRACE_SIZE)
    // Prints out information (either verbosely or not, depending on argument) about
    // the contents of this pool.  Returns the total size of this pool.
    virtual ULONG PrintSizeInfo(bool verbose)
    {
        // for the moment, just return size of pool.  In the future, show us the 
        // sizes of indiviudual items in this pool.
        ULONG size;
        StgPool::GetSaveSize(&size);
        PrintSize("String Pool",size);
        return size; 
    }
#endif
    
//*****************************************************************************
// Helper gets the next item, given an input item.    
//*****************************************************************************
    virtual HRESULT GetNextItem(            // Return code.
        ULONG       ulItem,                 // Current item.
        ULONG       *pulNext);              // Return offset of next pool item.

private:
    HRESULT RehashStrings();

private:
    CStringPoolHash m_Hash;                 // Hash table for lookups.
    int         m_bHash;                    // true to keep hash table.
    ULONG       m_cbOrganizedSize;          // Size of the optimized pool.
    ULONG       m_cbOrganizedOffset;        // Highest offset.

    //*************************************************************************
    // Private classes used in optimization.
    //*************************************************************************
    struct StgStringRemap
    {
        ULONG   ulOldOffset;
        ULONG   ulNewOffset;
        ULONG   cbString;
    };

    CDynArray<StgStringRemap> m_Remap;      // For use in reorganization.
    ULONGARRAY  m_RemapIndex;               // For use in reorganization.

    // Sort by reversed strings.
    friend class SortReversedName;
    class BinarySearch : public CBinarySearch<StgStringRemap>
    {
    public:
        BinarySearch(StgStringRemap *pBase, int iCount) : CBinarySearch<StgStringRemap>(pBase, iCount) {}

        int Compare(StgStringRemap const *pFirst, StgStringRemap const *pSecond)
        {
            if (pFirst->ulOldOffset < pSecond->ulOldOffset)
                return -1;
            if (pFirst->ulOldOffset > pSecond->ulOldOffset)
                return 1;
            return 0;
        }
    };
};

class SortReversedName : public CQuickSort<ULONG>
{
public:
    SortReversedName(ULONG *pBase, int iCount, StgStringPool &Pool) 
        :  CQuickSort<ULONG>(pBase, iCount),
        m_Pool(Pool)
    {}
    
    int Compare(ULONG *pUL1, ULONG *pUL2)
    {
        StgStringPool::StgStringRemap *pRM1 = m_Pool.m_Remap.Get(*pUL1);
        StgStringPool::StgStringRemap *pRM2 = m_Pool.m_Remap.Get(*pUL2);
        LPCSTR p1 = m_Pool.GetString(pRM1->ulOldOffset) + pRM1->cbString - 1;
        LPCSTR p2 = m_Pool.GetString(pRM2->ulOldOffset) + pRM2->cbString - 1;
        while (*p1 == *p2 && *p1)
            --p1, --p2;
        if (*p1 < *p2)
            return -1;
        if (*p1 > *p2)
            return 1;
        return 0;
    }
    
    StgStringPool   &m_Pool;
};


//
//
// StgGuidPool
//
//



//*****************************************************************************
// This Guid pool class collects user Guids into a big consecutive heap.
// Internally it manages this data in a hash table at run time to help throw
// out duplicates.  The list of Guids is kept in memory while adding, and
// finally flushed to a stream at the caller's request.
//*****************************************************************************
class StgGuidPool : public StgPool
{
public:
    StgGuidPool() :
        StgPool(DFT_GUID_HEAP_SIZE),
        m_Hash(this),
        m_bHash(true)
    { }

//*****************************************************************************
// Init the pool for use.  This is called for the create empty case.
//*****************************************************************************
    HRESULT InitNew(                        // Return code.
        ULONG       cbSize=0,               // Estimated size.
        ULONG       cItems=0);              // Estimated item count.

//*****************************************************************************
// Load a Guid heap from persisted memory.  If a copy of the data is made
// (so that it may be updated), then a new hash table is generated which can
// be used to elminate duplicates with new Guids.
//*****************************************************************************
    HRESULT InitOnMem(                      // Return code.
        void        *pData,                 // Predefined data.
        ULONG       iSize,                  // Size of data.
        int         bReadOnly);             // true if append is forbidden.

//*****************************************************************************
// Clears the hash table then calls the base class.
//*****************************************************************************
    void Uninit();

//*****************************************************************************
// Add a segment to the chain of segments.
//*****************************************************************************
    virtual HRESULT AddSegment(             // S_OK or error.
        const void  *pData,                 // The data.
        ULONG       cbData,                 // Size of the data.
        bool        bCopy);                 // If true, make a copy of the data.

//*****************************************************************************
// Turn hashing off or on.  If you turn hashing on, then any existing data is
// thrown away and all data is rehashed during this call.
//*****************************************************************************
    virtual HRESULT SetHash(int bHash);

//*****************************************************************************
// The Guid will be added to the pool.  The index of the Guid in the pool
// is returned in *piIndex.  If the Guid is already in the pool, then the
// index will be to the existing copy of the Guid.
//*****************************************************************************
    HRESULT AddGuid(                        // Return code.
        REFGUID     guid,                   // The Guid to add to pool.
        ULONG       *piIndex);              // Return index of Guid here.

#if 0
//*****************************************************************************
// Look for the Guid and return its index if found.
//*****************************************************************************
    HRESULT FindGuid(                       // S_OK, S_FALSE.
        REFGUID     guid,                   // The Guid to find in pool.
        ULONG       *piIndex)               // Return index of Guid here.
    {
        GUIDHASH    *pHash;                 // Hash item for lookup.
        if ((pHash = m_Hash.Find((void *) &guid)) == 0)
            return (S_FALSE);
        *piIndex = pHash->iIndex;
        return (S_OK);
    }
#endif

//*****************************************************************************
// Return a pointer to a Guid given an index previously handed out by
// AddGuid or FindGuid.
//*****************************************************************************
    virtual GUID *GetGuid(                  // Pointer to guid in pool.
        ULONG       iIndex);                // 1-based index of Guid in pool.

//*****************************************************************************
// Copy a GUID into the caller's buffer.
//*****************************************************************************
    HRESULT GetGuid(                        // Return code.
        ULONG       iIndex,                 // 1-based index of Guid in pool.
        GUID        *pGuid)                 // Output buffer for Guid.
    {
        *pGuid = *GetGuid(iIndex);
        return (S_OK);
    }

//*****************************************************************************
// How many objects are there in the pool?  If the count is 0, you don't need
// to persist anything at all to disk.
//*****************************************************************************
    int Count()
    { _ASSERTE(m_bHash);
        return (m_Hash.Count()); }

//*****************************************************************************
// Indicate if heap is empty.  This has to be based on the size of the data
// we are keeping.  If you open in r/o mode on memory, there is no hash
// table.  
//*****************************************************************************
    virtual int IsEmpty()                   // true if empty.
    { 
        if (m_State == eNormal)
            return (GetNextOffset() == 0);
        else
            return (m_cbOrganizedSize == 0);
    }

//*****************************************************************************
// Is the index valid for the GUID?
//*****************************************************************************
    virtual int IsValidCookie(ULONG ulCookie)
    { return (ulCookie == 0 || IsValidOffset((ulCookie-1) * sizeof(GUID))); }

//*****************************************************************************
// Return the size of the heap.
//*****************************************************************************
    ULONG GetNextIndex()
    { return (GetNextOffset() / sizeof(GUID)); }

//*****************************************************************************
// How big is an offset in this heap.
//*****************************************************************************
    int OffsetSize()
    {
        ULONG cbSaveSize;
        GetSaveSize(&cbSaveSize);
        ULONG iIndex = cbSaveSize / sizeof(GUID);
        if (iIndex < 0xffff)
            return (sizeof(short));
        else
            return (sizeof(long));
    }

//*****************************************************************************
// Reorganization interface.
//*****************************************************************************
    // Prepare for pool re-organization.
    virtual HRESULT OrganizeBegin();
    // Mark an object as being live in the organized pool.
    virtual HRESULT OrganizeMark(ULONG ulOffset);
    // Organize, based on marked items.
    virtual HRESULT OrganizePool();
    // Remap a cookie from the in-memory state to the persisted state.
    virtual HRESULT OrganizeRemap(ULONG ulOld, ULONG *pulNew);
    // Done with regoranization.  Release any state.
    virtual HRESULT OrganizeEnd();

//*****************************************************************************
// Return the size in bytes of the persistent version of this pool.  If
// PersistToStream were the next call, the amount of bytes written to pIStream
// has to be same as the return value from this function.
//*****************************************************************************
    virtual HRESULT GetSaveSize(            // Return code.
        ULONG       *pcbSaveSize)           // Return save size of this pool.
    {
        ULONG       ulSize;                 // The size.

        _ASSERTE(pcbSaveSize);

        if (m_State == eNormal)
            // Size is offset of last seg + size of last seg.
            ulSize = m_pCurSeg->m_cbSegNext + m_cbCurSegOffset;
        else
            ulSize = m_cbOrganizedSize;

        // Should be aligned.
        _ASSERTE(ulSize == ALIGN4BYTE(ulSize));

        *pcbSaveSize = ulSize;
        return (S_OK);
    }

//*****************************************************************************
// The entire string pool is written to the given stream. The stream is aligned
// to a 4 byte boundary.
//*****************************************************************************
    virtual HRESULT PersistToStream(        // Return code.
        IStream     *pIStream);             // The stream to write to.

#if defined(_TRACE_SIZE)
    // Prints out information (either verbosely or not, depending on argument) about
    // the contents of this pool.  Returns the total size of this pool.
    virtual ULONG PrintSizeInfo(bool verbose) 
    { 
        // for the moment, just return size of pool.  In the future, show us the 
        // sizes of indiviudual items in this pool.
        ULONG size;
        StgPool::GetSaveSize(&size);
        PrintSize("Guid Pool",size);
        return size; 
    }
#endif

//*****************************************************************************
// Helper gets the next item, given an input item.    
//*****************************************************************************
    virtual HRESULT GetNextItem(            // Return code.
        ULONG       ulItem,                 // Current item.
        ULONG       *pulNext);              // Return offset of next pool item.


private:

    HRESULT RehashGuids();


private:
    ULONGARRAY  m_Remap;                    // For remaps.
    ULONG       m_cbOrganizedSize;          // Size after organization.
    CGuidPoolHash m_Hash;                   // Hash table for lookups.
    int         m_bHash;                    // true to keep hash table.
};



//
//
// StgBlobPool
//
//


//*****************************************************************************
// Just like the string pool, this pool manages a list of items, throws out
// duplicates using a hash table, and can be persisted to a stream.  The only
// difference is that instead of saving null terminated strings, this code
// manages binary values of up to 64K in size.  Any data you have larger than
// this should be stored someplace else with a pointer in the record to the
// external source.
//*****************************************************************************
class StgBlobPool : public StgPool
{
public:
    StgBlobPool(ULONG ulGrowInc=DFT_BLOB_HEAP_SIZE) :
        StgPool(ulGrowInc),
        m_Hash(this),
        m_bAlign(false)
    { }

//*****************************************************************************
// Init the pool for use.  This is called for the create empty case.
//*****************************************************************************
    HRESULT InitNew(                        // Return code.
        ULONG       cbSize=0,               // Estimated size.
        ULONG       cItems=0);              // Estimated item count.

//*****************************************************************************
// Init the blob pool for use.  This is called for both create and read case.
// If there is existing data and bCopyData is true, then the data is rehashed
// to eliminate dupes in future adds.
//*****************************************************************************
    HRESULT InitOnMem(                      // Return code.
        void        *pData,                 // Predefined data.
        ULONG       iSize,                  // Size of data.
        int         bReadOnly);             // true if append is forbidden.

//*****************************************************************************
// Clears the hash table then calls the base class.
//*****************************************************************************
    void Uninit();

//*****************************************************************************
// The blob will be added to the pool.  The offset of the blob in the pool
// is returned in *piOffset.  If the blob is already in the pool, then the
// offset will be to the existing copy of the blob.
//*****************************************************************************
    HRESULT AddBlob(                        // Return code.
        ULONG       iSize,                  // Size of data item.
        const void  *pData,                 // The data.
        ULONG       *piOffset);             // Return offset of blob here.

//*****************************************************************************
// Return a pointer to a null terminated blob given an offset previously
// handed out by Addblob or Findblob.
//*****************************************************************************
    virtual void *GetBlob(                  // Pointer to blob's bytes.
        ULONG       iOffset,                // Offset of blob in pool.
        ULONG       *piSize);               // Return size of blob.

    virtual void *GetBlobNext(              // Pointer to blob's bytes.
        ULONG       iOffset,                // Offset of blob in pool.
        ULONG       *piSize,                // Return size of blob.
        ULONG       *piNext);               // Return offset of next blob.



//*****************************************************************************
// Turn hashing off or on.  If you turn hashing on, then any existing data is
// thrown away and all data is rehashed during this call.
//*****************************************************************************
    virtual HRESULT SetHash(int bHash);

//*****************************************************************************
// How many objects are there in the pool?  If the count is 0, you don't need
// to persist anything at all to disk.
//*****************************************************************************
    int Count()
    { return (m_Hash.Count()); }

//*****************************************************************************
// String heap is considered empty if the only thing it has is the initial
// empty string, or if after organization, there are no strings.
//*****************************************************************************
    virtual int IsEmpty()                   // true if empty.
    { 
        if (m_State == eNormal)
            return (GetNextOffset() <= 1); 
        else
            return (m_Remap.Count() == 0);
    }

//*****************************************************************************
// Reorganization interface.
//*****************************************************************************
    // Prepare for pool re-organization.
    virtual HRESULT OrganizeBegin();
    // Mark an object as being live in the organized pool.
    virtual HRESULT OrganizeMark(ULONG ulOffset);
    // Organize, based on marked items.
    virtual HRESULT OrganizePool();
    // Remap a cookie from the in-memory state to the persisted state.
    virtual HRESULT OrganizeRemap(ULONG ulOld, ULONG *pulNew);
    // Done with regoranization.  Release any state.
    virtual HRESULT OrganizeEnd();

//*****************************************************************************
// How big is a cookie for this heap.
//*****************************************************************************
    int OffsetSize()
    {
        ULONG       ulOffset;

        // Pick an offset based on whether we've been organized.
        if (m_State == eOrganized)
            ulOffset = m_cbOrganizedOffset;
        else
            ulOffset = GetNextOffset();

        if (ulOffset< USHRT_MAX)
            return (sizeof(USHORT));
        else
            return (sizeof(ULONG));
    }

//*****************************************************************************
// Return the size in bytes of the persistent version of this pool.  If
// PersistToStream were the next call, the amount of bytes written to pIStream
// has to be same as the return value from this function.
//*****************************************************************************
    virtual HRESULT GetSaveSize(            // Return code.
        ULONG       *pcbSaveSize)           // Return save size of this pool.
    {
        _ASSERTE(pcbSaveSize);

        if (m_State == eOrganized)
        {
            *pcbSaveSize = m_cbOrganizedSize;
            return (S_OK);
        }

        return (StgPool::GetSaveSize(pcbSaveSize));
    }

//*****************************************************************************
// The entire blob pool is written to the given stream. The stream is aligned
// to a 4 byte boundary.
//*****************************************************************************
    virtual HRESULT PersistToStream(        // Return code.
        IStream     *pIStream);             // The stream to write to.

    //*************************************************************************
    // Private classes used in optimization.
    //*************************************************************************
    struct StgBlobRemap
    {
        ULONG   ulOldOffset;
        int     iNewOffset;
    };
    class BinarySearch : public CBinarySearch<StgBlobRemap>
    {
    public:
        BinarySearch(StgBlobRemap *pBase, int iCount) : CBinarySearch<StgBlobRemap>(pBase, iCount) {}

        int Compare(StgBlobRemap const *pFirst, StgBlobRemap const *pSecond)
        {
            if (pFirst->ulOldOffset < pSecond->ulOldOffset)
                return -1;
            if (pFirst->ulOldOffset > pSecond->ulOldOffset)
                return 1;
            return 0;
        }
    };

    const void *GetBuffer() {return (m_pSegData);}

    int IsAligned() { return (m_bAlign); };
    void SetAligned(int bAlign) { m_bAlign = bAlign; };

#if defined(_TRACE_SIZE)
    // Prints out information (either verbosely or not, depending on argument) about
    // the contents of this pool.  Returns the total size of this pool.
    virtual ULONG PrintSizeInfo(bool verbose)
    { 
        // for the moment, just return size of pool.  In the future, show us the 
        // sizes of indiviudual items in this pool.
        ULONG size;
        StgPool::GetSaveSize(&size);
        PrintSize("Blob Pool",size);
        return size; 
    }
#endif

//*****************************************************************************
// Helper gets the next item, given an input item.    
//*****************************************************************************
    virtual HRESULT GetNextItem(            // Return code.
        ULONG       ulItem,                 // Current item.
        ULONG       *pulNext);              // Return offset of next pool item.

protected:

//*****************************************************************************
// Check whether a given offset is valid in the pool.
//*****************************************************************************
    virtual int IsValidOffset(ULONG ulOffset)
    { 
        if(ulOffset)
        {
            if(m_pSegData != m_zeros && (ulOffset < GetNextOffset()))
            {
                ULONG ulSize = CPackedLen::GetLength(GetData(ulOffset), (void const **)NULL);
                if(ulOffset+ulSize < GetNextOffset()) return true;
            }
            return false;
        }
        else return true;
    }


private:
    HRESULT RehashBlobs();

    CBlobPoolHash m_Hash;                   // Hash table for lookups.
    CDynArray<StgBlobRemap> m_Remap;        // For use in reorganization.
    ULONG       m_cbOrganizedSize;          // Size of the optimized pool.
    ULONG       m_cbOrganizedOffset;        // Highest offset.
    unsigned    m_bAlign : 1;               // if blob data should be aligned on DWORDs
};


#if 0
//
//
// StgVariantPool
//
//

//*****************************************************************************
// This pool is for storing variants.  The storage is optimized to store
// short, long, and string data types.  Other types may be persisted but
// require more overhead.  The pool must have a pointer to a string and blob
// pool which it uses to store the actual string data and the binary data for
// types which aren't specialized.  A detailed desription of this subsystem
// can be found in EngineNotes.doc.
//*****************************************************************************
class StgVariantPool : public StgPool
{
public:
    StgVariantPool() :
        StgPool(DFT_VARIANT_HEAP_SIZE)
    {
        ClearVars();
    }

    void ClearVars()
    {
        m_rVariants.Clear();
        m_Remap.Clear();
        m_pIStream = 0;
        m_cOrganizedVariants = 0;
        m_cbOrganizedSize = 0;
    }


//*****************************************************************************
// Init the variant pool for usage.  This is called for both the create and
// open existing case.
//*****************************************************************************
    HRESULT InitNew(                        // Return code.
        StgBlobPool *pBlobPool,             // Pool to keep blobs in.
        StgStringPool *pStringPool);        // Pool to keep strings in.

//*****************************************************************************
// Init the variant pool for usage.  This is called for both the create and
// open existing case.
//*****************************************************************************
    HRESULT InitOnMem(                      // Return code.
        StgBlobPool *pBlobPool,             // Pool to keep blobs in.
        StgStringPool *pStringPool,         // Pool to keep strings in.
        void        *pData,                 // Predefined data.
        ULONG       iSize,                  // Size of data.
        int         bReadOnly);             // true if update is forbidden.

//*****************************************************************************
// Clear out this pool.  Cannot use until you call InitNew.
//*****************************************************************************
    void Uninit();

//*****************************************************************************
// Add a segment to the chain of segments.
//*****************************************************************************
    virtual HRESULT AddSegment(             // S_OK or error.
        const void  *pData,                 // The data.
        ULONG       cbData,                 // Size of the data.
        bool        bCopy)                  // If true, make a copy of the data.
    { return E_NOTIMPL; }

//*****************************************************************************
// Indicate if heap is empty.
//*****************************************************************************
    virtual int IsEmpty()                   // true if empty.
    {   
        if (m_State == eOrganized)
            return (m_cOrganizedVariants == 0); 
        else
            return (m_rVariants.Count() == 0);
    }

//*****************************************************************************
// Check whether a given index is valid in the pool.
//*****************************************************************************
    virtual int IsValidCookie(ULONG ulCookie)
    { return (ulCookie <= static_cast<ULONG>(m_rVariants.Count())) ;}

//*****************************************************************************
// Add the given variant to the pool.  The index returned is good only for
// the duration of the load.  It must be converted into a final index when you
// persist the information to disk.
//*****************************************************************************
    HRESULT AddVariant(                     // Return code.
        VARIANT     *pVal,                  // The value to store.
        ULONG       *piIndex);              // The index of the new item.
    HRESULT AddVariant(                     // Return code.
        ULONG       iSize,                  // Size of data item.
        const void  *pData,                 // The data.
        ULONG       *piIndex);              // The index of the new item.

//*****************************************************************************
// Lookup the logical variant and return a copy to the caller.
//*****************************************************************************
    HRESULT GetVariant(                     // Return code.
        ULONG       iIndex,                 // Index of the item to get.
        VARIANT     *pVal);                 // Put variant here.
    HRESULT GetVariant(                     // Return code.
        ULONG       iIndex,                 // Index of the item to get.
        ULONG       *pcbBlob,               // Return size of blob.
        const void  **ppBlob);              // Put blob pointer here.
    HRESULT GetVariantType(                 // Return code.
        ULONG       iIndex,                 // Index of the item to get.
        VARTYPE     *pVt);                  // Put variant type here.

//*****************************************************************************
// Reorganization interface.
//*****************************************************************************
    // Prepare for pool re-organization.
    virtual HRESULT OrganizeBegin();
    // Mark an object as being live in the organized pool.
    virtual HRESULT OrganizeMark(ULONG ulOffset);
    // Organize, based on marked items.
    virtual HRESULT OrganizePool();
    // Remap a cookie from the in-memory state to the persisted state.
    virtual HRESULT OrganizeRemap(ULONG ulOld, ULONG *pulNew);
    // Done with regoranization.  Release any state.
    virtual HRESULT OrganizeEnd();

//*****************************************************************************
// Return the size in bytes of the persistent version of this pool.  If
// PersistToStream were the next call, the amount of bytes written to pIStream
// has to be same as the return value from this function.
//*****************************************************************************
    HRESULT GetSaveSize(                    // Return code.
        ULONG       *pcbSaveSize);          // Return save size of this pool.

//*****************************************************************************
// Save the pool data into the given stream.
//*****************************************************************************
    HRESULT PersistToStream(                // Return code.
        IStream     *pIStream);             // The stream to write to.

//*****************************************************************************
// Return the size of the current variable sized data.
//*****************************************************************************
    HRESULT GetOtherSize(                   // Return code.
        ULONG       *pulSize);              // Put size of the stream here.

//*****************************************************************************
// Return the maximum offset for next item.  To be used to determine offset
// sizes for heap.
//*****************************************************************************
    int OffsetSize()
    {
        _ASSERTE(m_State == eOrganized);
        if (m_cOrganizedVariants < USHRT_MAX)
            return (sizeof(short));
        else
            return (sizeof(long));
    }

#if defined(_TRACE_SIZE)
    // Prints out information (either verbosely or not, depending on argument) about
    // the contents of this pool.  Returns the total size of this pool.
    virtual ULONG PrintSizeInfo(bool verbose) 
    { 
        // for the moment, just return size of pool.  In the future, show us the 
        // sizes of indiviudual items in this pool.
        ULONG size;
        StgPool::GetSaveSize(&size);
        PrintSize("Variant Pool",size);
        return size; 
    }
#endif

    ULONG GetBlobIndex(                     // Return blob pool index.
        ULONG       ix);                    // 1-based Variant index.

private:
    HRESULT AddVarianti(                    // Return code.
        VARIANT     *pVal,                  // The value to store, if variant.
        ULONG       cbBlob,                 // The size to store, if blob.
        const void  *pBlob,                 // Pointer to data, if blob.
        ULONG       *piIndex);              // The index of the new item.

    struct StgVariant;
    HRESULT GetValue(                       // Get the value directly or from the stream.
        StgVariant  *pStgVariant,           // The internal form of variant.
        void        *pRead,                 // Where to put the value.
        ULONG       cbRead);                // Bytes to read for value.
        
    HRESULT GetEntrysStreamSize(            // Get the size for the streamed part of this item.
        StgVariant  *pStgVariant,           // The internal form of variant.
        ULONG       *pSize);                // Put size here.
        

    // Internal clases.
    struct StgVariant
    {
        unsigned    m_vt : 7;               // The var type.
        unsigned    m_bDirect : 1;          // Is value stored directly?
        unsigned    m_iSign : 1;            // Sign bit for value.
        unsigned    m_iVal : 23;            // Value or offset into stream.

        enum                                // class constants.
        {
            VALUE_MASK = 0x007fffff,        // Mask the same size as the value field.
            SIGN_MASK  = 0xff800000         // Mask the same size as the missing bits.
        };

        // Set the value.  (Note: arg is signed so we get sign extension)
        void Set(long l)
        {
            ULONG ul = static_cast<ULONG>(l);
            m_iSign = ul >> (sizeof(ul)*8-1);
            m_iVal = ul;
        }
        long Get()
        {
            return (m_iSign ? SIGN_MASK : 0) | m_iVal;
        }
        int operator==(const StgVariant &v) const
        {   return *reinterpret_cast<const long*>(this) == *reinterpret_cast<const long*>(&v); }

    };
    typedef CDynArray<StgVariant> StgVariantArray;
    

    // Member variables.
    StgBlobPool *m_pBlobPool;               // Pool to keep Blobs in.
    StgStringPool *m_pStringPool;           // Pool to keep strings in.

    StgVariantArray m_rVariants;            // The variants.

    ULONGARRAY  m_Remap;                    // Remap array or organizing.

    CIfacePtr<IStream> m_pIStream;          // For variable size data.

private:
    // Organized information.
    ULONG       m_cbOrganizedSize;          // Size of the Organized pool.
    ULONG       m_cOrganizedVariants;       // Count of variants in Organized pool.
    int         m_cbOrganizedCookieSize;    // Size of a cookie in the Organized pool.

};
#endif

//*****************************************************************************
// This pool is for storing Codes, Byte or Native.  This pool is different
// from the blob pool: 1) clients may obtain pointers to data which are
// guaranteed to remain valid, and 2) we attempt no duplicate folding.
// The non-movability leads to a different organization -- instead of a single
// block that grows as required, the data is stored in a linked list of
// blocks.
//*****************************************************************************
class StgCodePool : public StgBlobPool
{
public:
    StgCodePool() :
        StgBlobPool(DFT_CODE_HEAP_SIZE)
    {
    }


//*****************************************************************************
// Add the given Code to the pool.
//*****************************************************************************
    HRESULT AddCode(                        // Return code.
        const void  *pVal,                  // The value to store.
        ULONG       iLen,                   // Count of bytes to store.
        ULONG       *piOffset)              // The offset of the new item.
    {
        return (AddBlob(iLen, pVal, piOffset));
    }

//*****************************************************************************
// Lookup the logical Code and return a copy to the caller.
//*****************************************************************************
    HRESULT GetCode(                        // Return code.
        ULONG       iOffset,                // Offset of the item to get.
        const void  **ppVal,                // Put pointer to Code here.
        ULONG       *piLen)                 // Put length of code here.
    {
        *ppVal = GetBlob(iOffset, piLen);
        return (S_OK);
    }

};

#pragma warning (default : 4355)


//*****************************************************************************
// Unfortunately the CreateStreamOnHGlobal is a little too smart in that
// it gets its size from GlobalSize.  This means that even if you give it the
// memory for the stream, it has to be globally allocated.  We don't want this
// because we have the stream read only in the middle of a memory mapped file.
// CreateStreamOnMemory and the corresponding, internal only stream object solves
// that problem.
//*****************************************************************************
class CInMemoryStream : public IStream
{
public:
    CInMemoryStream() :
        m_pMem(0),
        m_cbSize(0),
        m_cbCurrent(0),
        m_cRef(1),
        m_noHacks(false),
        m_dataCopy(NULL)
    { }

    void InitNew(
        void        *pMem,
        ULONG       cbSize)
    {
        m_pMem = pMem;
        m_cbSize = cbSize;
        m_cbCurrent = 0;
    }

    ULONG STDMETHODCALLTYPE AddRef() {
        return (InterlockedIncrement((long *) &m_cRef));
    }


    ULONG STDMETHODCALLTYPE Release();

    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, PVOID *ppOut);

    HRESULT STDMETHODCALLTYPE Read(void *pv, ULONG cb, ULONG *pcbRead);

    HRESULT STDMETHODCALLTYPE Write(const void  *pv, ULONG cb, ULONG *pcbWritten);

    HRESULT STDMETHODCALLTYPE Seek(LARGE_INTEGER dlibMove,DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition);

    HRESULT STDMETHODCALLTYPE SetSize(ULARGE_INTEGER libNewSize)
    {
        return (BadError(E_NOTIMPL));
    }

    HRESULT STDMETHODCALLTYPE CopyTo(
        IStream     *pstm,
        ULARGE_INTEGER cb,
        ULARGE_INTEGER *pcbRead,
        ULARGE_INTEGER *pcbWritten);

    HRESULT STDMETHODCALLTYPE Commit(
        DWORD       grfCommitFlags)
    {
        return (BadError(E_NOTIMPL));
    }

    HRESULT STDMETHODCALLTYPE Revert()
    {
        return (BadError(E_NOTIMPL));
    }

    HRESULT STDMETHODCALLTYPE LockRegion(
        ULARGE_INTEGER libOffset,
        ULARGE_INTEGER cb,
        DWORD       dwLockType)
    {
        return (BadError(E_NOTIMPL));
    }

    HRESULT STDMETHODCALLTYPE UnlockRegion(
        ULARGE_INTEGER libOffset,
        ULARGE_INTEGER cb,
        DWORD       dwLockType)
    {
        return (BadError(E_NOTIMPL));
    }

    HRESULT STDMETHODCALLTYPE Stat(
        STATSTG     *pstatstg,
        DWORD       grfStatFlag)
    {
        pstatstg->cbSize.QuadPart = m_cbSize;
        return (S_OK);
    }

    HRESULT STDMETHODCALLTYPE Clone(
        IStream     **ppstm)
    {
        return (BadError(E_NOTIMPL));
    }

    static HRESULT CreateStreamOnMemory(           // Return code.
                                 void        *pMem,                  // Memory to create stream on.
                                 ULONG       cbSize,                 // Size of data.
                                 IStream     **ppIStream,           // Return stream object here.
                                 BOOL       fDeleteMemoryOnRelease = FALSE
                                 );            

    static HRESULT CreateStreamOnMemoryNoHacks(
                                 void        *pMem,
                                 ULONG       cbSize,
                                 IStream     **ppIStream);

    static HRESULT CreateStreamOnMemoryCopy(
                                 void        *pMem,
                                 ULONG       cbSize,
                                 IStream     **ppIStream);

private:
    void        *m_pMem;                // Memory for the read.
    ULONG       m_cbSize;               // Size of the memory.
    ULONG       m_cbCurrent;            // Current offset.
    ULONG       m_cRef;                 // Ref count.
    bool        m_noHacks;              // Don't use any hacks.
    BYTE       *m_dataCopy;             // Optional copy of the data.
};

//*****************************************************************************
// CGrowableStream is a simple IStream implementation that grows as
// its written to. All the memory is contigious, so read access is
// fast. A grow does a realloc, so be aware of that if you're going to
// use this.
//*****************************************************************************
class CGrowableStream : public IStream
{
public:
    CGrowableStream();
   ~CGrowableStream();

    void *GetBuffer(void)
    {
        return (void*)m_swBuffer;
    }

private:
    char *  m_swBuffer;
    DWORD   m_dwBufferSize;
    DWORD   m_dwBufferIndex;
    ULONG   m_cRef;

    // IStream methods
public:
    ULONG STDMETHODCALLTYPE AddRef() {
        return (InterlockedIncrement((long *) &m_cRef));
    }


    ULONG STDMETHODCALLTYPE Release();

    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, PVOID *ppOut);

    STDMETHOD(Read)(
         void HUGEP * pv,
         ULONG cb,
         ULONG * pcbRead);

    STDMETHOD(Write)(
         const void HUGEP * pv,
         ULONG cb,
         ULONG * pcbWritten);

    STDMETHOD(Seek)(
         LARGE_INTEGER dlibMove,
         DWORD dwOrigin,
         ULARGE_INTEGER * plibNewPosition);

    STDMETHOD(SetSize)(ULARGE_INTEGER libNewSize);

    STDMETHOD(CopyTo)(
         IStream * pstm,
         ULARGE_INTEGER cb,
         ULARGE_INTEGER * pcbRead,
         ULARGE_INTEGER * pcbWritten) { return E_NOTIMPL; }

    STDMETHOD(Commit)(
         DWORD grfCommitFlags) { return NOERROR; }

    STDMETHOD(Revert)( void) { return E_NOTIMPL; }

    STDMETHOD(LockRegion)(
         ULARGE_INTEGER libOffset,
         ULARGE_INTEGER cb,
         DWORD dwLockType) { return E_NOTIMPL; }

    STDMETHOD(UnlockRegion)(
         ULARGE_INTEGER libOffset,
         ULARGE_INTEGER cb,
         DWORD dwLockType) { return E_NOTIMPL; }

    STDMETHOD(Stat)(
         STATSTG * pstatstg,
         DWORD grfStatFlag);

    STDMETHOD(Clone)(
         IStream ** ppstm) { return E_NOTIMPL; }

}; // Class CGrowableStream


#endif // __StgPool_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\stgpooli.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// StgPooli.h
//
// This is helper code for the string and blob pools.  It is here because it is
// secondary to the pooling interface and reduces clutter in the main file.
//
//*****************************************************************************
#ifndef __StgPooli_h__
#define __StgPooli_h__

#include "UtilCode.h"					// Base hashing code.



//
//
// CPackedLen
//
//

//*****************************************************************************
// Helper class to pack and unpack lengths.
//*****************************************************************************
struct CPackedLen
{
	enum {MAX_LEN = 0x1fffffff};
	static int Size(ULONG len)
	{
		// Smallest.
		if (len <= 0x7F)
			return 1;
		// Medium.
		if (len <= 0x3FFF)
			return 2;
		// Large (too large?).
		_ASSERTE(len <= MAX_LEN);
		return 4;
	}

	// Get a pointer to the data, and store the length.
	static void const *GetData(void const *pData, ULONG *pLength);
	// Get the length value encoded at *pData.  Update ppData to point past data.
	static ULONG GetLength(void const *pData, void const **ppData=0);
	// Get the length value encoded at *pData, and the size of that encoded value.
	static ULONG GetLength(void const *pData, int *pSizeOfLength);
	// Pack a length at *pData; return a pointer to the next byte.
	static void* PutLength(void *pData, ULONG len);
};


class StgPoolReadOnly;

//*****************************************************************************
// This hash class will handle strings inside of a chunk of the pool.
//*****************************************************************************
struct STRINGHASH : HASHLINK
{
	ULONG		iOffset;				// Offset of this item.
};

class CStringPoolHash : public CChainedHash<STRINGHASH>
{
public:
	CStringPoolHash(StgPoolReadOnly *pool) : m_Pool(pool) {}

	virtual bool InUse(STRINGHASH *pItem)
	{ return (pItem->iOffset != 0xffffffff); }

	virtual void SetFree(STRINGHASH *pItem)
	{ pItem->iOffset = 0xffffffff; }

	virtual ULONG Hash(const void *pData)
	{ return (HashStringA(reinterpret_cast<LPCSTR>(pData))); }

	virtual int Cmp(const void *pData, void *pItem);

private:
	StgPoolReadOnly *m_Pool;				// String pool which this hashes.
};


//*****************************************************************************
// This version is for byte streams with a 2 byte WORD giving the lenght of
// the data.
//*****************************************************************************
typedef STRINGHASH BLOBHASH;

class CBlobPoolHash : public CChainedHash<STRINGHASH>
{
public:
    CBlobPoolHash(StgPoolReadOnly *pool) : m_Pool(pool) {}

    virtual bool InUse(BLOBHASH *pItem)
	{ return (pItem->iOffset != 0xffffffff); }

    virtual void SetFree(BLOBHASH *pItem)
	{ pItem->iOffset = 0xffffffff; }

	virtual ULONG Hash(const void *pData)
	{
		ULONG		ulSize;
		ulSize = CPackedLen::GetLength(pData);
		ulSize += CPackedLen::Size(ulSize);
		return (HashBytes(reinterpret_cast<BYTE const *>(pData), ulSize));
	}

	virtual int Cmp(const void *pData, void *pItem);

private:
    StgPoolReadOnly *m_Pool;                // Blob pool which this hashes.
};

//*****************************************************************************
// This hash class will handle guids inside of a chunk of the pool.
//*****************************************************************************
struct GUIDHASH : HASHLINK
{
	ULONG		iIndex;					// Index of this item.
};

class CGuidPoolHash : public CChainedHash<GUIDHASH>
{
public:
    CGuidPoolHash(StgPoolReadOnly *pool) : m_Pool(pool) {}

	virtual bool InUse(GUIDHASH *pItem)
	{ return (pItem->iIndex != 0xffffffff); }

	virtual void SetFree(GUIDHASH *pItem)
	{ pItem->iIndex = 0xffffffff; }

	virtual ULONG Hash(const void *pData)
	{ return (HashBytes(reinterpret_cast<BYTE const *>(pData), sizeof(GUID))); }

    virtual int Cmp(const void *pData, void *pItem);

private:
    StgPoolReadOnly *m_Pool;                // The GUID pool which this hashes.
};


#endif // __StgPooli_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\strongname.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef __STRONG_NAME_H
#define __STRONG_NAME_H

// ===========================================================================
// File: StrongName.h
// 
// Wrappers for signing and hashing functions needed to implement strong names
// ===========================================================================


#include <windows.h>
#include <wincrypt.h>
#include <ole2.h>
#include <corerror.h>


#ifdef __cplusplus
extern "C"{
#endif 


// Public key blob binary format.
typedef struct {
    unsigned int SigAlgID;       // (ALG_ID) signature algorithm used to create the signature
    unsigned int HashAlgID;      // (ALG_ID) hash algorithm used to create the signature
    ULONG        cbPublicKey;    // length of the key in bytes
    BYTE         PublicKey[1];   // variable length byte array containing the key value in format output by CryptoAPI
} PublicKeyBlob;


// Location in the registry (under HKLM) that strong name configuration info is
// stored.
#define SN_CONFIG_KEY               "Software\\Microsoft\\StrongName"
#define SN_CONFIG_CSP               "CSP"                   // REG_SZ
#define SN_CONFIG_MACHINE_KEYSET    "MachineKeyset"         // REG_DWORD
#define SN_CONFIG_HASH_ALG          "HashAlgorithm"         // REG_DWORD
#define SN_CONFIG_SIGN_ALG          "SignAlgorithm"         // REG_DWORD
#define SN_CONFIG_VERIFICATION      "Verification"          // Registry subkey
#define SN_CONFIG_USERLIST          "UserList"              // REG_MULTI_SZ
#define SN_CONFIG_CACHE_VERIFY      "CacheVerify"           // REG_DWORD

#define SN_CONFIG_KEY_W             L"Software\\Microsoft\\StrongName"
#define SN_CONFIG_CSP_W             L"CSP"                  // REG_SZ
#define SN_CONFIG_MACHINE_KEYSET_W  L"MachineKeyset"        // REG_DWORD
#define SN_CONFIG_HASH_ALG_W        L"HashAlgorithm"        // REG_DWORD
#define SN_CONFIG_SIGN_ALG_W        L"SignAlgorithm"        // REG_DWORD
#define SN_CONFIG_VERIFICATION_W    L"Verification"         // Registry subkey
#define SN_CONFIG_USERLIST_W        L"UserList"             // REG_MULTI_SZ
#define SN_CONFIG_CACHE_VERIFY_W    L"CacheVerify"          // REG_DWORD


#ifdef SNAPI_INTERNAL
#define SNAPI __declspec(dllexport) BOOLEAN __stdcall
#define SNAPI_(_type) __declspec(dllexport) _type __stdcall
#else
#define SNAPI __declspec(dllimport) BOOLEAN __stdcall
#define SNAPI_(_type) __declspec(dllimport) _type __stdcall
#endif


// Return last error.
SNAPI_(DWORD) StrongNameErrorInfo(VOID);


// Free buffer allocated by routines below.
SNAPI_(VOID) StrongNameFreeBuffer(BYTE *pbMemory);  // [in] address of memory to free


// Generate a new key pair for strong name use.
SNAPI StrongNameKeyGen(LPCWSTR  wszKeyContainer,    // [in] desired key container name
                       DWORD    dwFlags,            // [in] flags (see below)
                       BYTE   **ppbKeyBlob,         // [out] public/private key blob
                       ULONG   *pcbKeyBlob);

// Flags for StrongNameKeyGen.
#define SN_LEAVE_KEY    0x00000001                  // Leave key pair registered with CSP


// Import key pair into a key container.
SNAPI StrongNameKeyInstall(LPCWSTR  wszKeyContainer,// [in] desired key container name, must be a non-empty string
                           BYTE    *pbKeyBlob,      // [in] public/private key pair blob
                           ULONG    cbKeyBlob);


// Delete a key pair.
SNAPI StrongNameKeyDelete(LPCWSTR wszKeyContainer); // [in] desired key container name


// Retrieve the public portion of a key pair.
SNAPI StrongNameGetPublicKey (LPCWSTR   wszKeyContainer,    // [in] desired key container name
                              BYTE     *pbKeyBlob,          // [in] public/private key blob (optional)
                              ULONG     cbKeyBlob,
                              BYTE    **ppbPublicKeyBlob,   // [out] public key blob
                              ULONG    *pcbPublicKeyBlob);


// Hash and sign a manifest.
SNAPI StrongNameSignatureGeneration(LPCWSTR     wszFilePath,        // [in] valid path to the PE file for the assembly
                                    LPCWSTR     wszKeyContainer,    // [in] desired key container name
                                    BYTE       *pbKeyBlob,          // [in] public/private key blob (optional)
                                    ULONG       cbKeyBlob,
                                    BYTE      **ppbSignatureBlob,   // [out] signature blob
                                    ULONG      *pcbSignatureBlob);


// Create a strong name token from an assembly file.
SNAPI StrongNameTokenFromAssembly(LPCWSTR   wszFilePath,            // [in] valid path to the PE file for the assembly
                                  BYTE    **ppbStrongNameToken,     // [out] strong name token 
                                  ULONG    *pcbStrongNameToken);

// Create a strong name token from an assembly file and additionally return the full public key.
SNAPI StrongNameTokenFromAssemblyEx(LPCWSTR   wszFilePath,            // [in] valid path to the PE file for the assembly
                                    BYTE    **ppbStrongNameToken,     // [out] strong name token 
                                    ULONG    *pcbStrongNameToken,
                                    BYTE    **ppbPublicKeyBlob,       // [out] public key blob
                                    ULONG    *pcbPublicKeyBlob);

// Create a strong name token from a public key blob.
SNAPI StrongNameTokenFromPublicKey(BYTE    *pbPublicKeyBlob,        // [in] public key blob
                                   ULONG    cbPublicKeyBlob,
                                   BYTE   **ppbStrongNameToken,     // [out] strong name token 
                                   ULONG   *pcbStrongNameToken);


// Verify a strong name/manifest against a public key blob.
SNAPI StrongNameSignatureVerification(LPCWSTR wszFilePath,      // [in] valid path to the PE file for the assembly
                                      DWORD   dwInFlags,        // [in] flags modifying behaviour (see below)
                                      DWORD  *pdwOutFlags);     // [out] additional output info (see below)


// Verify a strong name/manifest against a public key blob.
SNAPI StrongNameSignatureVerificationEx(LPCWSTR     wszFilePath,        // [in] valid path to the PE file for the assembly
                                        BOOLEAN     fForceVerification, // [in] verify even if settings in the registry disable it
                                        BOOLEAN    *pfWasVerified);     // [out] set to false if verify succeeded due to registry settings


// Verify a strong name/manifest against a public key blob when the assembly is
// already memory mapped.
SNAPI StrongNameSignatureVerificationFromImage(BYTE     *pbBase,             // [in] base address of mapped manifest file
                                               DWORD     dwLength,           // [in] length of mapped image in bytes
                                               DWORD     dwInFlags,          // [in] flags modifying behaviour (see below)
                                               DWORD    *pdwOutFlags);       // [out] additional output info (see below)

// Flags for use with the verify routines.
#define SN_INFLAG_FORCE_VER      0x00000001     // verify even if settings in the registry disable it
#define SN_INFLAG_INSTALL        0x00000002     // verification is the first (on entry to the cache)
#define SN_INFLAG_ADMIN_ACCESS   0x00000004     // cache protects assembly from all but admin access
#define SN_INFLAG_USER_ACCESS    0x00000008     // cache protects user's assembly from other users
#define SN_INFLAG_ALL_ACCESS     0x00000010     // cache provides no access restriction guarantees
#define SN_INFLAG_RUNTIME        0x80000000     // internal debugging use only 

#define SN_OUTFLAG_WAS_VERIFIED  0x00000001     // set to false if verify succeeded due to registry settings


// Verify that two assemblies differ only by signature blob.
SNAPI StrongNameCompareAssemblies(LPCWSTR   wszAssembly1,           // [in] file name of first assembly
                                  LPCWSTR   wszAssembly2,           // [in] file name of second assembly
                                  DWORD    *pdwResult);             // [out] result of comparison (see codes below)

#define SN_CMP_DIFFERENT    0   // Assemblies contain different data
#define SN_CMP_IDENTICAL    1   // Assemblies are exactly the same, even signatures
#define SN_CMP_SIGONLY      2   // Assemblies differ only by signature (and checksum etc.)


// Compute the size of buffer needed to hold a hash for a given hash algorithm.
SNAPI StrongNameHashSize(ULONG  ulHashAlg,  // [in] hash algorithm
                         DWORD *pcbSize);   // [out] size of the hash in bytes


// Compute the size that needs to be allocated for a signature in an assembly.
SNAPI StrongNameSignatureSize(BYTE    *pbPublicKeyBlob,    // [in] public key blob
                              ULONG    cbPublicKeyBlob,
                              DWORD   *pcbSize);           // [out] size of the signature in bytes


SNAPI_(DWORD) GetHashFromAssemblyFile(LPCSTR szFilePath, // [IN] location of file to be hashed
                                      unsigned int *piHashAlg, // [IN/OUT] constant specifying the hash algorithm (set to 0 if you want the default)
                                      BYTE   *pbHash,    // [OUT] hash buffer
                                      DWORD  cchHash,    // [IN]  max size of buffer
                                      DWORD  *pchHash);  // [OUT] length of hash byte array
    
SNAPI_(DWORD) GetHashFromAssemblyFileW(LPCWSTR wszFilePath, // [IN] location of file to be hashed
                                       unsigned int *piHashAlg, // [IN/OUT] constant specifying the hash algorithm (set to 0 if you want the default)
                                       BYTE   *pbHash,    // [OUT] hash buffer
                                       DWORD  cchHash,    // [IN]  max size of buffer
                                       DWORD  *pchHash);  // [OUT] length of hash byte array
    
SNAPI_(DWORD) GetHashFromFile(LPCSTR szFilePath, // [IN] location of file to be hashed
                              unsigned int *piHashAlg,   // [IN/OUT] constant specifying the hash algorithm (set to 0 if you want the default)
                              BYTE   *pbHash,    // [OUT] hash buffer
                              DWORD  cchHash,    // [IN]  max size of buffer
                              DWORD  *pchHash);  // [OUT] length of hash byte array
    
SNAPI_(DWORD) GetHashFromFileW(LPCWSTR wszFilePath, // [IN] location of file to be hashed
                               unsigned int *piHashAlg,   // [IN/OUT] constant specifying the hash algorithm (set to 0 if you want the default)
                               BYTE   *pbHash,    // [OUT] hash buffer
                               DWORD  cchHash,    // [IN]  max size of buffer
                               DWORD  *pchHash);  // [OUT] length of hash byte array
    
SNAPI_(DWORD) GetHashFromHandle(HANDLE hFile,      // [IN] handle of file to be hashed
                                unsigned int *piHashAlg,   // [IN/OUT] constant specifying the hash algorithm (set to 0 if you want the default)
                                BYTE   *pbHash,    // [OUT] hash buffer
                                DWORD  cchHash,    // [IN]  max size of buffer
                                DWORD  *pchHash);  // [OUT] length of hash byte array

SNAPI_(DWORD) GetHashFromBlob(BYTE   *pbBlob,       // [IN] pointer to memory block to hash
                              DWORD  cchBlob,       // [IN] length of blob
                              unsigned int *piHashAlg,  // [IN/OUT] constant specifying the hash algorithm (set to 0 if you want the default)
                              BYTE   *pbHash,       // [OUT] hash buffer
                              DWORD  cchHash,       // [IN]  max size of buffer
                              DWORD  *pchHash);     // [OUT] length of hash byte array

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\switches.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// switches.h switch configuration of common runtime features
//


// This file defines the golden vs. non-golden features.
// 
// If you have something you'd like marked #ifndef GOLDEN, DON'T DO IT!!
// Create a feature name and use that instead, then define it in this file.
// This allows for finer control on !golden features and will be invaluable for
// post-release bug work.
//

#ifndef GOLDEN
#define STRESS_HEAP
#define STRESS_THREAD
#define META_ADDVER
#define GC_SIZE
#define VERIFY_HEAP
#define DEBUG_FEATURES
#define STRESS_LOG      1
#endif //!GOLDEN

//#define SHOULD_WE_CLEANUP

#if 0
    #define APPDOMAIN_STATE
    #define BREAK_ON_UNLOAD
    #define AD_LOG_MEMORY
    #define AD_NO_UNLOAD
    #define AD_SNAPSHOT
    #define ZAP_LOG_ENABLE
    #define ZAP_MONITOR
    #define BREAK_META_ACCESS
    #define ENABLE_PERF_ALLOC
    #define ENABLE_VIRTUAL_ALLOC
    #define _WS_PERF_OUTPUT
    #define AD_BREAK_ON_CANNOT_UNLOAD
    #define BREAK_ON_CLSLOAD
#endif

#define CUSTOMER_CHECKED_BUILD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\sxsapi.h ===
/*++ BUILD Version: 0002    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    sxsapi.h

Abstract:

    Include file with definitions for calling into the sxs.dll private APIs

Author:

    Michael Grier (MGrier) 4-May-2000

Environment:


Revision History:

    Jay Krell (JayKrell) November 30, 2001
        seperated guids out into sxsapi_guids.h

--*/

#ifndef _SXSAPI_
#define _SXSAPI_

#if (_MSC_VER > 1020)
#pragma once
#endif

//
// bring in IStream / ISequentialStream
//
#if !defined(COM_NO_WINDOWS_H)
#define COM_NO_WINDOWS_H COM_NO_WINDOWS_H
#endif
#pragma push_macro("COM_NO_WINDOWS_H")
#undef COM_NO_WINDOWS_H
#include "objidl.h"
#pragma pop_macro("COM_NO_WINDOWS_H")

// from setupapi.h
typedef PVOID HSPFILEQ;

#include <sxstypes.h>

#ifdef __cplusplus
extern "C" {
#endif

#define SXS_DLL_NAME_A      ( "sxs.dll")
#define SXS_DLL_NAME_W      (L"sxs.dll")
#define SXS_DLL_NAME   (TEXT( "sxs.dll"))

typedef struct _SXS_XML_DOCUMENT *PSXS_XML_DOCUMENT;
typedef const struct _SXS_XML_DOCUMENT *PCSXS_XML_DOCUMENT;

typedef struct _SXS_XML_STRING *PSXS_XML_STRING;
typedef const struct _SXS_XML_STRING *PCSXS_XML_STRING;

typedef struct _SXS_XML_LOCATION *PSXS_XML_LOCATION;
typedef const struct _SXS_XML_LOCATION *PCSXS_XML_LOCATION;

typedef struct _SXS_XML_NODE *PSXS_XML_NODE;
typedef const struct _SXS_XML_NODE *PCSXS_XML_NODE;

typedef struct _SXS_XML_ATTRIBUTE *PSXS_XML_ATTRIBUTE;
typedef const struct _SXS_XML_ATTRIBUTE *PCSXS_XML_ATTRIBUTE;

typedef struct _SXS_XML_DOCUMENT {
    ULONG Flags;
    ULONG StringCount;
    PCSXS_XML_STRING Strings;   // Note that index 0 is reserved to mean "no string" or "no value"
    LIST_ENTRY ElementListHead; // conceptually just one element, but PIs also appear in this list
} SXS_XML_DOCUMENT;

// Most will not be null terminated; if they happen to be this flag will be set; this can be used
// to avoid a string copy if you really need them to be null terminated.
#define SXS_XML_STRING_FLAG_NULL_TERMINATED (0x00000001)
#define SXS_XML_STRING_FLAG_INVALID (0x00000002)

typedef struct _SXS_XML_STRING {
    ULONG Flags;
    ULONG PseudoKey;
    ULONG Length; // in bytes
    const WCHAR *Buffer; // pointer to first character of non-null-terminated string
} SXS_XML_STRING;

typedef struct _SXS_XML_LOCATION {
    ULONG Flags;
    ULONG SourceString; // source file name
    ULONG BeginningLine;
    ULONG BeginningColumn;
    ULONG EndingLine;
    ULONG EndingColumn;
} SXS_XML_LOCATION;

#define SXS_XML_NODE_TYPE_INVALID   (0)
#define SXS_XML_NODE_TYPE_XML_DECL  (1)
#define SXS_XML_NODE_TYPE_PI        (2)
#define SXS_XML_NODE_TYPE_ELEMENT   (3)
#define SXS_XML_NODE_TYPE_PCDATA    (4)
#define SXS_XML_NODE_TYPE_CDATA     (5)

typedef struct _SXS_XML_NODE_XML_DECL_DATA {
    ULONG AttributeCount;
    PCSXS_XML_ATTRIBUTE Attributes;
} SXS_XML_NODE_XML_DECL_DATA;

typedef struct _SXS_XML_NODE_ELEMENT_DATA {
    ULONG NamespaceString;
    ULONG NameString;
    ULONG AttributeCount;
    PCSXS_XML_ATTRIBUTE Attributes;
    LIST_ENTRY ChildListHead;
} SXS_XML_NODE_ELEMENT_DATA;

typedef struct _SXS_XML_NODE {
    LIST_ENTRY SiblingLink;
    ULONG Flags;
    ULONG Type;
    PCSXS_XML_NODE Parent;
    union {
        SXS_XML_NODE_XML_DECL_DATA XMLDecl;
        ULONG PIString;
        SXS_XML_NODE_ELEMENT_DATA Element;
        ULONG PCDataString;
        ULONG CDataString;
    };
} SXS_XML_NODE;

#define SXS_XML_ATTRIBUTE_FLAG_NAMESPACE_ATTRIBUTE (0x00000001)

typedef struct _SXS_XML_ATTRIBUTE {
    ULONG Flags;
    ULONG NamespaceString;
    ULONG NameString;
    ULONG ValueString;
} SXS_XML_ATTRIBUTE;

//
//  structs for walking/locating things in the XML parse tree
//

typedef struct _SXS_XML_NAMED_REFERENCE *PSXS_XML_NAMED_REFERENCE;
typedef const struct _SXS_XML_NAMED_REFERENCE *PCSXS_XML_NAMED_REFERENCE;

typedef struct _SXS_XML_NODE_PATH *PSXS_XML_NODE_PATH;
typedef const struct _SXS_XML_NODE_PATH *PCSXS_XML_NODE_PATH;

typedef struct _SXS_XML_NAMED_REFERENCE {
    PCWSTR Namespace;
    ULONG NamespaceLength; // in bytes
    PCWSTR Name;
    ULONG NameLength; // in bytes
} SXS_XML_NAMED_REFERENCE;

typedef struct _SXS_XML_NODE_PATH {
    ULONG ElementCount;
    const PCSXS_XML_NAMED_REFERENCE *Elements;
} SXS_XML_NODE_PATH;

typedef VOID (WINAPI * PSXS_ENUM_XML_NODES_CALLBACK)(
    IN PVOID Context,
    IN PCSXS_XML_NODE Element,
    OUT BOOL *ContinueEnumeration
    );

BOOL
WINAPI
SxsEnumXmlNodes(
    IN ULONG Flags,
    IN PCSXS_XML_DOCUMENT Document,
    IN PCSXS_XML_NODE_PATH PathToMatch,
    IN PSXS_ENUM_XML_NODES_CALLBACK Callback,
    IN PVOID Context
    );

#define SXS_INSTALLATION_FILE_COPY_DISPOSITION_FILE_COPIED (1)
#define SXS_INSTALLATION_FILE_COPY_DISPOSITION_FILE_QUEUED (2)
#define SXS_INSTALLATION_FILE_COPY_DISPOSITION_PLEASE_COPY (3)
#define SXS_INSTALLATION_FILE_COPY_DISPOSITION_PLEASE_MOVE (4)

typedef struct _SXS_INSTALLATION_FILE_COPY_CALLBACK_PARAMETERS {
    IN DWORD            cbSize;
    IN PVOID            pvContext;
    IN DWORD            dwFileFlags;
    IN PVOID            pAlternateSource;
    IN PCWSTR           pSourceFile;
    IN PCWSTR           pDestinationFile;
    IN ULONGLONG        nFileSize;
    OUT INT             nDisposition;
} SXS_INSTALLATION_FILE_COPY_CALLBACK_PARAMETERS, *PSXS_INSTALLATION_FILE_COPY_CALLBACK_PARAMETERS;

typedef BOOL (WINAPI * PSXS_INSTALLATION_FILE_COPY_CALLBACK)(
    PSXS_INSTALLATION_FILE_COPY_CALLBACK_PARAMETERS pParameters
    );

//
//  If SxsBeginAssemblyInstall() is called with SXS_INSTALL_ASSEMBLY_FILE_COPY_CALLBACK_SETUP_COPY_QUEUE as the
//  InstallationCallback parameter, the InstallationContext parameter is assumed to be an
//  HSPFILEQ copy queue handle.  If SXS_INSTALL_ASSEMBLY_FILE_COPY_CALLBACK_SETUP_COPY_QUEUE_EX,
//  the InstallationContext must point to a SXS_INSTALL_ASSEMBLY_SETUP_COPY_QUEUE_EX_PARAMETERS.
//
//  This provides an easy mechanism for someone maintaining a copy queue to interact with assembly installation.
//

#define SXS_INSTALLATION_FILE_COPY_CALLBACK_SETUP_COPY_QUEUE    ((PSXS_INSTALLATION_FILE_COPY_CALLBACK) 1)
#define SXS_INSTALLATION_FILE_COPY_CALLBACK_SETUP_COPY_QUEUE_EX ((PSXS_INSTALLATION_FILE_COPY_CALLBACK) 2)

//
// Parameters to Setupapi.dll::SetupQueueCopy
//
typedef struct _SXS_INSTALLATION_SETUP_COPY_QUEUE_EX_PARAMETERS {
    DWORD       cbSize;
    HSPFILEQ    hSetupCopyQueue; // SetupOpenFileQueue
    PCWSTR      pszSourceDescription;
    DWORD       dwCopyStyle;
} SXS_INSTALLATION_SETUP_COPY_QUEUE_EX_PARAMETERS, *PSXS_INSTALLATION_SETUP_COPY_QUEUE_EX_PARAMETERS;
typedef const SXS_INSTALLATION_SETUP_COPY_QUEUE_EX_PARAMETERS* PCSXS_INSTALLATION_SETUP_COPY_QUEUE_EX_PARAMETERS;

typedef BOOL (WINAPI * PSXS_IMPERSONATION_CALLBACK)(
    IN PVOID Context,
    IN BOOL Impersonate
    );

#define SXS_BEGIN_ASSEMBLY_INSTALL_FLAG_MOVE                        (0x00000001)
#define SXS_BEGIN_ASSEMBLY_INSTALL_FLAG_FROM_RESOURCE               (0x00000002)
#define SXS_BEGIN_ASSEMBLY_INSTALL_FLAG_FROM_DIRECTORY              (0x00000004)
#define SXS_BEGIN_ASSEMBLY_INSTALL_FLAG_FROM_DIRECTORY_RECURSIVE    (0x00000008)
#define SXS_BEGIN_ASSEMBLY_INSTALL_FLAG_NOT_TRANSACTIONAL           (0x00000010)
#define SXS_BEGIN_ASSEMBLY_INSTALL_FLAG_NO_VERIFY                   (0x00000020)
#define SXS_BEGIN_ASSEMBLY_INSTALL_FLAG_REPLACE_EXISTING            (0x00000040)

typedef BOOL (WINAPI * PSXS_BEGIN_ASSEMBLY_INSTALL)(
    IN DWORD Flags,
    IN PSXS_INSTALLATION_FILE_COPY_CALLBACK InstallationCallback OPTIONAL,
    IN PVOID InstallationContext OPTIONAL,
    IN PSXS_IMPERSONATION_CALLBACK ImpersonationCallback OPTIONAL,
    IN PVOID ImpersonationContext OPTIONAL,
    OUT PVOID *InstallCookie
    );

#define SXS_BEGIN_ASSEMBLY_INSTALL ("SxsBeginAssemblyInstall")

BOOL
WINAPI
SxsBeginAssemblyInstall(
    IN DWORD Flags,
    IN PSXS_INSTALLATION_FILE_COPY_CALLBACK InstallationCallback OPTIONAL,
    IN PVOID InstallationContext OPTIONAL,
    IN PSXS_IMPERSONATION_CALLBACK ImpersonationCallback OPTIONAL,
    IN PVOID ImpersonationContext OPTIONAL,
    OUT PVOID *InstallCookie
    );

typedef struct tagSXS_INSTALL_REFERENCEW
{
    DWORD cbSize;
    DWORD dwFlags;
    GUID guidScheme;
    PCWSTR lpIdentifier;
    PCWSTR lpNonCanonicalData;
} SXS_INSTALL_REFERENCEW, *PSXS_INSTALL_REFERENCEW;

typedef const struct tagSXS_INSTALL_REFERENCEW *PCSXS_INSTALL_REFERENCEW;

typedef struct tagSXS_INSTALLW
{
    DWORD cbSize;
    DWORD dwFlags;
    PCWSTR lpManifestPath;
    PVOID pvInstallCookie;
    PCWSTR lpCodebaseURL;
    PCWSTR lpRefreshPrompt;
    PCWSTR lpLogFileName;
    PCSXS_INSTALL_REFERENCEW lpReference;
} SXS_INSTALLW, *PSXS_INSTALLW;

typedef const struct tagSXS_INSTALLW *PCSXS_INSTALLW;

//
//  These flags are distinct from the begin install flags, but
//  we're assigning them unique numbers so that flag-reuse errors can
//  be caught more easily.
//

#define SXS_INSTALL_FLAG_CODEBASE_URL_VALID         (0x00000100)
#define SXS_INSTALL_FLAG_MOVE                       (0x00000200)
#define SXS_INSTALL_FLAG_FROM_RESOURCE              (0x00000400)
#define SXS_INSTALL_FLAG_FROM_DIRECTORY             (0x00000800)
#define SXS_INSTALL_FLAG_FROM_DIRECTORY_RECURSIVE   (0x00001000)
#define SXS_INSTALL_FLAG_NOT_TRANSACTIONAL          (0x00002000)
#define SXS_INSTALL_FLAG_NO_VERIFY                  (0x00004000)
#define SXS_INSTALL_FLAG_REPLACE_EXISTING           (0x00008000)
#define SXS_INSTALL_FLAG_LOG_FILE_NAME_VALID        (0x00010000)
#define SXS_INSTALL_FLAG_INSTALLED_BY_DARWIN        (0x00020000)
#define SXS_INSTALL_FLAG_INSTALLED_BY_OSSETUP       (0x00040000)
#define SXS_INSTALL_FLAG_INSTALL_COOKIE_VALID       (0x00080000)
#define SXS_INSTALL_FLAG_REFRESH_PROMPT_VALID       (0x00100000)
#define SXS_INSTALL_FLAG_REFERENCE_VALID            (0x00200000)
#define SXS_INSTALL_FLAG_REFRESH                    (0x00400000)

typedef BOOL (WINAPI * PSXS_INSTALL_W)(
    IN OUT PSXS_INSTALLW lpInstall
    );
typedef PSXS_INSTALL_W PSXS_INSTALL_W_ROUTINE;

BOOL
WINAPI
SxsInstallW(
    IN OUT PSXS_INSTALLW lpInstall
    );

#define SXS_INSTALL_W                               ("SxsInstallW")

//
//  These flags are distinct from the begin assembly install flags, but
//  we're assigning them unique numbers so that flag-reuse errors can
//  be caught more easily.
//

#define SXS_INSTALL_ASSEMBLY_FLAG_CODEBASE_URL_VALID        (0x00000100)
#define SXS_INSTALL_ASSEMBLY_FLAG_MOVE                      (0x00000200)
#define SXS_INSTALL_ASSEMBLY_FLAG_FROM_RESOURCE             (0x00000400)
#define SXS_INSTALL_ASSEMBLY_FLAG_FROM_DIRECTORY            (0x00000800)
#define SXS_INSTALL_ASSEMBLY_FLAG_FROM_DIRECTORY_RECURSIVE  (0x00001000)
#define SXS_INSTALL_ASSEMBLY_FLAG_NOT_TRANSACTIONAL         (0x00002000)
#define SXS_INSTALL_ASSEMBLY_FLAG_NO_VERIFY                 (0x00004000)
#define SXS_INSTALL_ASSEMBLY_FLAG_REPLACE_EXISTING          (0x00008000)
#define SXS_INSTALL_ASSEMBLY_FLAG_LOG_FILE_NAME_VALID       (0x00010000)
#define SXS_INSTALL_ASSEMBLY_FLAG_INSTALLED_BY_DARWIN	    (0x00020000)
#define SXS_INSTALL_ASSEMBLY_FLAG_INSTALLED_BY_OSSETUP      (0x00040000)
#define SXS_INSTALL_ASSEMBLY_FLAG_INSTALL_COOKIE_VALID      (0x00080000)
#define SXS_INSTALL_ASSEMBLY_FLAG_REFRESH_PROMPT_VALID      (0x00100000)


#define SXS_INSTALL_ASSEMBLY_FLAG_INCLUDE_CODEBASE SXS_INSTALL_ASSEMBLY_FLAG_CODEBASE_URL_VALID
#define SXS_INSTALL_ASSEMBLY_FLAG_CREATE_LOGFILE SXS_INSTALL_ASSEMBLY_FLAG_LOG_FILE_NAME_VALID

typedef BOOL (WINAPI * PSXS_INSTALL_ASSEMBLY_W)(
    IN PVOID InstallCookie OPTIONAL,
    IN DWORD Flags,
    IN PCWSTR ManifestPath,
    IN OUT PVOID Reserved OPTIONAL
    );

#define SXS_INSTALL_ASSEMBLY_W ("SxsInstallAssemblyW")

BOOL
WINAPI
SxsInstallAssemblyW(
    IN PVOID InstallCookie OPTIONAL,
    IN DWORD Flags,
    IN PCWSTR ManifestPath,
    IN OUT PVOID Reserved OPTIONAL
    );

//
// If you've specified SXS_INSTALL_ASSEMBLY_FLAG_INCLUDE_CODEBASE, you must pass 
// a PSXS_INSTALL_SOURCE_INFO in the Reserved value of SxsInstallAssemblyW.
// This is the definition of that structure.
//
typedef struct _SXS_INSTALL_SOURCE_INFO {
    // Size of this structure.  Required.
    SIZE_T      cbSize;

    // Any combination of SXSINSTALLSOURCE_*
    DWORD       dwFlags;

    // Codebase to reinstall this assembly from.  Can be determined from the
    // manifest name that's being installed, but not preferrably.
    PCWSTR      pcwszCodebaseName;

    // What string (localized!) that should be presented to the user during
    // recovery to request the media that this assembly came from.
    PCWSTR      pcwszPromptOnRefresh;

    PCWSTR      pcwszLogFileName;
} SXS_INSTALL_SOURCE_INFO, *PSXS_INSTALL_SOURCE_INFO;

typedef const struct _SXS_INSTALL_SOURCE_INFO *PCSXS_INSTALL_SOURCE_INFO;

// The SXS_INSTALL_SOURCE_INFO structure has the pcwszCodebase member filled in.
#define SXSINSTALLSOURCE_HAS_CODEBASE       ( 0x00000001 )

// The SXS_INSTALL_SOURCE_INFO structure has the pcwszPromptOnRefresh member filled in.
#define SXSINSTALLSOURCE_HAS_PROMPT         ( 0x00000002 )

// The assembly has a catalog that must be present and copied over.  If missing, then the
// instaler will intuit whether it has a catalog or not.
#define SXSINSTALLSOURCE_HAS_CATALOG        ( 0x00000004 )

// This assembly is being installed as part of OS-setup, and so the codebase actually
// contains the source-relative path of the root directory of the assembly source
#define SXSINSTALLSOURCE_INSTALLING_SETUP   ( 0x00000008 )

// The installer should not attempt to autodetect whether or not there's a catalog
// associated with this assembly.
#define SXSINSTALLSOURCE_DONT_DETECT_CATALOG ( 0x0000010 )

#define SXSINSTALLSOURCE_CREATE_LOGFILE      ( 0x0000020 )
// for WFP recovery usage
#define SXSINSTALLSOURCE_INSTALL_BY_DARWIN   ( 0x0000040 )
#define SXSINSTALLSOURCE_INSTALL_BY_OSSETUP  ( 0x0000080 )


//
//  These flags are distinct from the begin assembly install flags, but
//  we're assigning them unique numbers so that flag-reuse errors can
//  be caught more easily.
//

#define SXS_END_ASSEMBLY_INSTALL_FLAG_COMMIT            (0x01000000)
#define SXS_END_ASSEMBLY_INSTALL_FLAG_ABORT             (0x02000000)
#define SXS_END_ASSEMBLY_INSTALL_FLAG_NO_VERIFY         (0x04000000)
#define SXS_END_ASSEMBLY_INSTALL_FLAG_GET_STATUS        (0x08000000)

typedef BOOL (WINAPI * PSXS_END_ASSEMBLY_INSTALL)(
    IN PVOID InstallCookie,
    IN DWORD Flags,
    OUT DWORD *Reserved OPTIONAL
    );

#define SXS_END_ASSEMBLY_INSTALL ("SxsEndAssemblyInstall")

BOOL
WINAPI
SxsEndAssemblyInstall(
    IN PVOID InstallCookie,
    IN DWORD Flags,
    IN OUT PVOID Reserved OPTIONAL
    );

//
// Uninstallation of an assembly
//

typedef struct _tagSXS_UNINSTALLW {

    SIZE_T                      cbSize;
    DWORD                       dwFlags;
    LPCWSTR                     lpAssemblyIdentity;
    PCSXS_INSTALL_REFERENCEW    lpInstallReference;
    LPCWSTR                     lpInstallLogFile;
    
} SXS_UNINSTALLW, *PSXS_UNINSTALLW;

typedef const struct _tagSXS_UNINSTALLW *PCSXS_UNINSTALLW;

#define SXS_UNINSTALL_FLAG_REFERENCE_VALID          (0x00000001)
#define SXS_UNINSTALL_FLAG_FORCE_DELETE             (0x00000002)
#define SXS_UNINSTALL_FLAG_USE_INSTALL_LOG          (0x00000004)
#define SXS_UNINSTALL_FLAG_REFERENCE_COMPUTED       (0x00000008)

//
// The reference to the assembly was removed
//
#define SXS_UNINSTALL_DISPOSITION_REMOVED_REFERENCE        (0x00000001)

//
// The actual assembly was removed because it ran out of references.
//
#define SXS_UNINSTALL_DISPOSITION_REMOVED_ASSEMBLY         (0x00000002)

typedef BOOL (WINAPI * PSXS_UNINSTALL_ASSEMBLYW)(
    IN  PCSXS_UNINSTALLW pcUnInstallData,
    OUT DWORD *pdwDisposition
    );
typedef PSXS_UNINSTALL_ASSEMBLYW PSXS_UNINSTALL_W_ROUTINE;

#define SXS_UNINSTALL_ASSEMBLYW ("SxsUninstallW")

BOOL
WINAPI
SxsUninstallW(
    IN  PCSXS_UNINSTALLW pcUnInstallData,
    OUT DWORD *pdwDisposition
    );

    

#define SXS_PROBE_ASSEMBLY_INSTALLATION_DISPOSITION_NOT_INSTALLED   (0x00000001)
#define SXS_PROBE_ASSEMBLY_INSTALLATION_DISPOSITION_INSTALLED       (0x00000002)
#define SXS_PROBE_ASSEMBLY_INSTALLATION_DISPOSITION_RESIDENT        (0x00000004)

typedef BOOL (WINAPI * PSXS_PROBE_ASSEMBLY_INSTALLATION)(
    IN DWORD dwFlags,
    IN PCWSTR lpIdentity,
    OUT DWORD *plpDisposition
    );

#define SXS_PROBE_ASSEMBLY_INSTALLATION ("SxsProbeAssemblyInstallation")

BOOL
WINAPI
SxsProbeAssemblyInstallation(
    DWORD dwFlags,
    PCWSTR lpIdentity,
    PDWORD lpDisposition
    );

#define SXS_QUERY_MANIFEST_INFORMATION_INFOCLASS_BASIC  (1)

#define SXS_QUERY_MANIFEST_INFORMATION_FLAG_SOURCE_IS_DLL   (0x00000001)

#define SXS_QUERY_MANIFEST_INFORMATION_INFOCLASS_BASIC_FLAG_OMIT_IDENTITY   (0x00000001)
#define SXS_QUERY_MANIFEST_INFORMATION_INFOCLASS_BASIC_FLAG_OMIT_SHORTNAME  (0x00000002)

typedef struct _SXS_MANIFEST_INFORMATION_BASIC
{
    PCWSTR lpIdentity;
    PCWSTR lpShortName;
} SXS_MANIFEST_INFORMATION_BASIC, *PSXS_MANIFEST_INFORMATION_BASIC;

#define SXS_QUERY_MANIFEST_INFORMATION_DLL_SOURCE_FLAG_RESOURCE_TYPE_VALID      (0x00000001)
#define SXS_QUERY_MANIFEST_INFORMATION_DLL_SOURCE_FLAG_RESOURCE_LANGUAGE_VALID  (0x00000002)
#define SXS_QUERY_MANIFEST_INFORMATION_DLL_SOURCE_FLAG_RESOURCE_ID_VALID        (0x00000004)

typedef struct _SXS_MANIFEST_INFORMATION_SOURCE_DLL
{
    DWORD dwSize;
    DWORD dwFlags;
    PCWSTR pcwszDllPath;
    PCWSTR pcwszResourceType;
    PCWSTR pcwszResourceName;
    INT Language;
} SXS_MANIFEST_INFORMATION_SOURCE_DLL, *PSXS_MANIFEST_INFORMATION_SOURCE_DLL;
typedef const struct _SXS_MANIFEST_INFORMATION_SOURCE_DLL *PCSXS_MANIFEST_INFORMATION_SOURCE_DLL;


typedef BOOL (WINAPI * PSXS_QUERY_MANIFEST_INFORMATION)(
    IN DWORD dwFlags,
    IN PCWSTR pszSource,
    IN ULONG ulInfoClass,
    IN DWORD dwInfoClassSpecificFlags,
    IN SIZE_T cbBuffer,
    OUT PVOID lpBuffer,
    OUT PSIZE_T cbWrittenOrRequired OPTIONAL
    );

BOOL
WINAPI
SxsQueryManifestInformation(
    IN DWORD dwFlags,
    IN PCWSTR pszSource,
    IN ULONG ulInfoClass,
    IN DWORD dwInfoClassSpecificFlags,
    IN SIZE_T cbBuffer,
    OUT PVOID lpBuffer,
    OUT PSIZE_T cbWrittenOrRequired OPTIONAL
    );

//
// these flags are used for sxs.dll. when ActCtx generation for system default fails, there are two cases we could ignore this error :
// Case 1 : there is no system-default at all 
// Case 2 : the dependency of system-default could not be found: this case may happen during the GUImode setup, when system-default is 
//          installed before GUI assembly is installed 
//  SXS.dll would pass out these two failure cases using these flags
//

#define BASESRV_SXS_RETURN_RESULT_SYSTEM_DEFAULT_NOT_FOUND                      (0x0001)
#define BASESRV_SXS_RETURN_RESULT_SYSTEM_DEFAULT_DEPENDENCY_ASSEMBLY_NOT_FOUND  (0x0002)

#define SXS_GENERATE_ACTIVATION_CONTEXT_FLAG_SUPPRESS_EVENT_LOG         (0x00000001)
#define SXS_GENERATE_ACTIVATION_CONTEXT_FLAG_SYSTEM_DEFAULT_TEXTUAL_ASSEMBLY_IDENTITY  (0x00000002)
#define SXS_GENERATE_ACTIVATION_CONTEXT_FLAG_TEXTUAL_ASSEMBLY_IDENTITY                 (0x00000004)

typedef struct _SXS_GENERATE_ACTIVATION_CONTEXT_STREAM
{
    IStream* Stream;

    //
    // This is not necessarily a file system path, just something
    // for descriptive/debugging purposes.
    //
    // Still, when they are file system paths, we try to keep them as Win32 paths instead of Nt paths.
    //
    PCWSTR  Path;
    ULONG   PathType;
} SXS_GENERATE_ACTIVATION_CONTEXT_STREAM;

typedef struct _SXS_GENERATE_ACTIVATION_CONTEXT_PARAMETERS
{
    IN DWORD    Flags;
    IN USHORT   ProcessorArchitecture;
    IN LANGID   LangId;
    IN PCWSTR   AssemblyDirectory; // should be a Win32 path
    IN PCWSTR   TextualAssemblyIdentity;

    IN SXS_GENERATE_ACTIVATION_CONTEXT_STREAM Manifest;
    IN SXS_GENERATE_ACTIVATION_CONTEXT_STREAM Policy; 

    OUT DWORD   SystemDefaultActCxtGenerationResult; // when generate activation context for system default fails, this mask shows whether it fails for some certain reason which we could ignore the error.
       
    PSXS_IMPERSONATION_CALLBACK ImpersonationCallback;
    PVOID                       ImpersonationContext;

    OUT HANDLE  SectionObjectHandle;
} SXS_GENERATE_ACTIVATION_CONTEXT_PARAMETERS, *PSXS_GENERATE_ACTIVATION_CONTEXT_PARAMETERS;
typedef const SXS_GENERATE_ACTIVATION_CONTEXT_PARAMETERS* PCSXS_GENERATE_ACTIVATION_CONTEXT_PARAMETERS;

typedef
BOOL
(WINAPI*
PSXS_GENERATE_ACTIVATION_CONTEXT_FUNCTION)(
    PSXS_GENERATE_ACTIVATION_CONTEXT_PARAMETERS Parameters
    );

BOOL
WINAPI
SxsGenerateActivationContext(
    IN OUT PSXS_GENERATE_ACTIVATION_CONTEXT_PARAMETERS Parameters
    );

//
//  Opaque ASSEMBLY_IDENTITY structure
//

typedef struct _ASSEMBLY_IDENTITY *PASSEMBLY_IDENTITY;
typedef const struct _ASSEMBLY_IDENTITY *PCASSEMBLY_IDENTITY;

//
//  The types of assembly identities.
//
//  Definitions may not include wildcard attributes; definitions
//  match only if they are exactly equal.  A wildcard matches
//  a definition if for all the non-wildcarded attributes,
//  there is an exact match.  References may not contain
//  wildcarded attributes but may contain a different set of
//  attributes than a definition that they match.  (Example:
//  definitions carry the full public key of the publisher, but
//  references usually carry just the "strong name" which is
//  the first 8 bytes of the SHA-1 hash of the public key.)
//

#define ASSEMBLY_IDENTITY_TYPE_DEFINITION (1)
#define ASSEMBLY_IDENTITY_TYPE_REFERENCE (2)
#define ASSEMBLY_IDENTITY_TYPE_WILDCARD (3)

#define SXS_ASSEMBLY_MANIFEST_STD_NAMESPACE L"urn:schemas-microsoft-com:asm.v1"
#define SXS_ASSEMBLY_MANIFEST_STD_NAMESPACE_CCH (32)

#define SXS_ASSEMBLY_MANIFEST_STD_ELEMENT_NAME_ASSEMBLY                     L"assembly"
#define SXS_ASSEMBLY_MANIFEST_STD_ELEMENT_NAME_ASSEMBLY_CCH                 (8)
#define SXS_ASSEMBLY_MANIFEST_STD_ELEMENT_NAME_ASSEMBLY_IDENTITY            L"assemblyIdentity"
#define SXS_ASSEMBLY_MANIFEST_STD_ELEMENT_NAME_ASSEMBLY_IDENTITY_CCH        (16)

#define SXS_APPLICATION_CONFIGURATION_MANIFEST_STD_ELEMENT_NAME_CONFIGURATION L"configuration"
#define SXS_APPLICATION_CONFIGURATION_MANIFEST_STD_ELEMENT_NAME_CONFIGURATION_CCH (13)

#define SXS_ASSEMBLY_MANIFEST_STD_ATTRIBUTE_NAME_MANIFEST_VERSION           L"manifestVersion"
#define SXS_ASSEMBLY_MANIFEST_STD_ATTRIBUTE_NAME_MANIFEST_VERSION_CCH       (15)

#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME                       L"name"
#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME_CCH                   (4)
#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_VERSION                    L"version"
#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_VERSION_CCH                (7)
#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_LANGUAGE                   L"language"
#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_LANGUAGE_CCH               (8)
#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY                 L"publicKey"
#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY_CCH             (9)
#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY_TOKEN           L"publicKeyToken"
#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY_TOKEN_CCH       (14)
#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PROCESSOR_ARCHITECTURE     L"processorArchitecture"
#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PROCESSOR_ARCHITECTURE_CCH (21)
#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_TYPE                       L"type"
#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_TYPE_CCH                   (4)

// Pseudo-value used in some places when the language= attribute is missing from the identity.
// An identity that does not have language is implicitly "worldwide".

#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_LANGUAGE_MISSING_VALUE          L"x-ww"
#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_LANGUAGE_MISSING_VALUE_CCH      (4)

//
//  All win32 assemblies must have "win32" as their type.
//

#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_TYPE_VALUE_WIN32                L"win32"
#define SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_TYPE_VALUE_WIN32_CCH            (5)

//
//  Global flags describing the assembly identity state
//

//
//  SXS_ASSEMBLY_IDENTITY_FLAG_FROZEN means that the assembly
//  identity's contents are frozen and are not subject to additional
//  change.
//

#define ASSEMBLY_IDENTITY_FLAG_FROZEN           (0x80000000)

//
//  ASSEMBLY_IDENTITY_ATTRIBUTE structure
//

typedef struct _ASSEMBLY_IDENTITY_ATTRIBUTE {
    DWORD Flags;
    SIZE_T NamespaceCch;
    SIZE_T NameCch;
    SIZE_T ValueCch;
    const WCHAR *Namespace;
    const WCHAR *Name;
    const WCHAR *Value;
} ASSEMBLY_IDENTITY_ATTRIBUTE, *PASSEMBLY_IDENTITY_ATTRIBUTE;

typedef const struct _ASSEMBLY_IDENTITY_ATTRIBUTE *PCASSEMBLY_IDENTITY_ATTRIBUTE;

typedef enum _ASSEMBLY_IDENTITY_INFORMATION_CLASS {
    AssemblyIdentityBasicInformation = 1,
} ASSEMBLY_IDENTITY_INFORMATION_CLASS;

typedef struct _ASSEMBLY_IDENTITY_BASIC_INFORMATION {
    DWORD Flags;
    ULONG Type;
    ULONG Hash;
    ULONG AttributeCount;
} ASSEMBLY_IDENTITY_BASIC_INFORMATION, *PASSEMBLY_IDENTITY_BASIC_INFORMATION;

#define SXS_CREATE_ASSEMBLY_IDENTITY_FLAG_FREEZE    (0x00000001)

BOOL
WINAPI
SxsCreateAssemblyIdentity(
    IN DWORD Flags,
    IN ULONG Type,
    OUT PASSEMBLY_IDENTITY *AssemblyIdentity,
    IN ULONG InitialAttributeCount OPTIONAL,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE const * InitialAttributes OPTIONAL
    );

typedef BOOL (WINAPI * PSXS_CREATE_ASSEMBLY_IDENTITY_ROUTINE)(
    IN DWORD Flags,
    IN ULONG Type,
    OUT PASSEMBLY_IDENTITY *AssemblyIdentity,
    IN ULONG InitialAttributeCount OPTIONAL,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE const * InitialAttributes OPTIONAL
    );

BOOL
WINAPI
SxsHashAssemblyIdentity(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    OUT ULONG *Hash
    );

typedef BOOL (WINAPI * PSXS_HASH_ASSEMBLY_IDENTITY_ROUTINE)(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    OUT ULONG *Hash
    );

#define SXS_ARE_ASSEMBLY_IDENTITIES_EQUAL_FLAG_ALLOW_REF_TO_MATCH_DEF (0x00000001)

BOOL
WINAPI
SxsAreAssemblyIdentitiesEqual(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity1,
    IN PCASSEMBLY_IDENTITY AssemlbyIdentity2,
    OUT BOOL *Equal
    );

typedef BOOL (WINAPI * PSXS_ARE_ASSEMBLY_IDENTITIES_EQUAL_ROUTINE)(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity1,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity2,
    OUT BOOL *Equal
    );

BOOL
WINAPI
SxsFreezeAssemblyIdentity(
    IN DWORD Flags,
    IN PASSEMBLY_IDENTITY AssemblyIdentity
    );

typedef BOOL (WINAPI *PSXS_FREEZE_ASSEMBLY_IDENTITY_ROUTINE)(
    IN DWORD Flags,
    IN PASSEMBLY_IDENTITY AssemblyIdentity
    );

VOID
WINAPI
SxsDestroyAssemblyIdentity(
    IN PASSEMBLY_IDENTITY AssemblyIdentity
    );

typedef VOID (WINAPI * PSXS_DESTROY_ASSEMBLY_IDENTITY_ROUTINE)(
    IN PASSEMBLY_IDENTITY AssemblyIdentity
    );

#define SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_NAMESPACE    (0x00000001)
#define SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_NAME         (0x00000002)
#define SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_VALIDATE_VALUE        (0x00000004)
#define SXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_WILDCARDS_PERMITTED   (0x00000008)

#define SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_NAMESPACE    (0x00000001)
#define SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_NAME         (0x00000002)
#define SXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_HASH_VALUE        (0x00000004)

BOOL
WINAPI
SxsValidateAssemblyIdentityAttribute(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute
    );

typedef BOOL (WINAPI * PSXS_VALIDATE_ASSEMBLY_IDENTITY_ATTRIBUTES_ROUTINE)(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute
    );

BOOL
WINAPI
SxsHashAssemblyIdentityAttribute(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute,
    OUT ULONG *HashValue
    );

typedef BOOL (WINAPI * PSXS_HASH_ASSEMBLY_IDENTITY_ATTRIBUTE_ROUTINE)(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute,
    OUT ULONG *HashValue
    );

#define SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_INVALID          (0)
#define SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_LESS_THAN        (1)
#define SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_EQUAL            (2)
#define SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_COMPARISON_RESULT_GREATER_THAN     (3)

#define SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_NAMESPACE     (0x00000001)
#define SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_NAME          (0x00000002)
#define SXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_COMPARE_VALUE         (0x00000004)

BOOL
WINAPI
SxsCompareAssemblyIdentityAttributes(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute1,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute2,
    OUT ULONG *ComparisonResult
    );

typedef BOOL (WINAPI * PSXS_COMPARE_ASSEMBLY_IDENTITY_ATTRIBUTES_ROUTINE)(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute1,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute2,
    OUT ULONG *ComparisonResult
    );

#define SXS_INSERT_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_OVERWRITE_EXISTING (0x00000001)

BOOL
WINAPI
SxsInsertAssemblyIdentityAttribute(
    IN DWORD Flags,
    IN PASSEMBLY_IDENTITY AssemblyIdentity,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE AssemblyIdentityAttribute
    );

typedef BOOL (WINAPI * PSXS_INSERT_ASSEMBLY_IDENTITY_ATTRIBUTE_ROUTINE)(
    IN DWORD Flags,
    IN PASSEMBLY_IDENTITY AssemblyIdentity,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE AssemblyIdentityAttribute
    );

BOOL
WINAPI
SxsRemoveAssemblyIdentityAttributesByOrdinal(
    IN DWORD Flags,
    IN PASSEMBLY_IDENTITY AssemblyIdentity,
    IN ULONG AttributeOrdinal,
    IN ULONG AttributeCount
    );

typedef BOOL (WINAPI * PSXS_REMOVE_ASSEMBLY_IDENTITY_ATTRIBUTES_BY_ORDINAL_ROUTINE)(
    IN DWORD Flags,
    IN PASSEMBLY_IDENTITY AssemblyIdentity,
    IN ULONG AttributeOrdinal,
    IN ULONG AttributeCount
    );

#define SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAMESPACE       (0x00000001)
#define SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_NAME            (0x00000002)
#define SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_MATCH_VALUE           (0x00000004)
#define SXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_FLAG_NOT_FOUND_SUCCEEDS    (0x00000008)

BOOL
WINAPI
SxsFindAssemblyIdentityAttribute(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE AttributeToMatch,
    OUT ULONG *FirstMatchOrdinal OPTIONAL,
    OUT ULONG *MatchCount OPTIONAL
    );

typedef BOOL (WINAPI * PSXS_FIND_ASSEMBLY_IDENTITY_ATTRIBUTE_ROUTINE)(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE AttributeToMatch,
    OUT ULONG *FirstMatchOrdinal OPTIONAL,
    OUT ULONG *MatchCount OPTIONAL
    );

//
//  Rather than making "n" heap allocations, the pattern for SxsGetAssemblyIdentityAttributeByOrdinal()
//  is to call once with BufferSize = 0 or some reasonable fixed number to get the size of the
//  buffer required, allocate the buffer if the buffer passed in was too small and call again.
//
//  The strings returned in the ASSEMBLY_IDENTITY_ATTRIBUTE are *not*
//  dynamically allocated, but are instead expected to fit in the buffer passed in.
//

BOOL
WINAPI
SxsGetAssemblyIdentityAttributeByOrdinal(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    IN ULONG AttributeOrdinal, // 0-based
    IN SIZE_T BufferSize,
    OUT PASSEMBLY_IDENTITY_ATTRIBUTE AssemblyIdentityAttributeBuffer,
    OUT SIZE_T *BytesWrittenOrRequired
    );

typedef BOOL (WINAPI * PSXS_GET_ASSEMBLY_IDENTITY_ATTRIBUTE_BY_ORDINAL_ROUTINE)(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    IN ULONG AttributeOrdinal, // 0-based
    IN SIZE_T BufferSize,
    OUT PASSEMBLY_IDENTITY_ATTRIBUTE AssemblyIdentityAttributeBuffer,
    OUT SIZE_T *BytesWrittenOrRequired
    );

#define SXS_DUPLICATE_ASSEMBLY_IDENTITY_FLAG_FREEZE         (0x00000001)
#define SXS_DUPLICATE_ASSEMBLY_IDENTITY_FLAG_ALLOW_NULL     (0x00000002)

BOOL
WINAPI
SxsDuplicateAssemblyIdentity(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY Source,
    OUT PASSEMBLY_IDENTITY *Destination
    );

typedef BOOL (WINAPI * PSXS_DUPLICATE_ASSEMBLY_IDENTITY_ROUTINE)(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY Source,
    OUT PASSEMBLY_IDENTITY *Destination
    );

BOOL
WINAPI
SxsQueryInformationAssemblyIdentity(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    OUT PVOID AssemblyIdentityInformation,
    IN SIZE_T AssemblyIdentityInformationLength,
    IN ASSEMBLY_IDENTITY_INFORMATION_CLASS AssemblyIdentityInformationClass
    );

typedef BOOL (WINAPI * PSXS_QUERY_INFORMATION_ASSEMBLY_IDENTITY_ROUTINE)(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    OUT PVOID AssemblyIdentityInformation,
    IN SIZE_T AssemblyIdentityInformationLength,
    IN ASSEMBLY_IDENTITY_INFORMATION_CLASS AssemblyIdentityInformationClass
    );

#define SXS_ENUMERATE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_MATCH_NAMESPACE (0x00000001)
#define SXS_ENUMERATE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_MATCH_NAME      (0x00000002)
#define SXS_ENUMERATE_ASSEMBLY_IDENTITY_ATTRIBUTES_FLAG_MATCH_VALUE     (0x00000004)

typedef VOID (WINAPI * PSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_ENUMERATION_ROUTINE)(
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute,
    IN PVOID Context
    );

BOOL
WINAPI
SxsEnumerateAssemblyIdentityAttributes(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute OPTIONAL,
    IN PSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_ENUMERATION_ROUTINE EnumerationRoutine,
    IN PVOID Context
    );

typedef BOOL (WINAPI * PSXS_ENUMERATE_ASSEMBLY_IDENTITY_ATTRIBUTES_ROUTINE)(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    IN PCASSEMBLY_IDENTITY_ATTRIBUTE Attribute OPTIONAL,
    IN PSXS_ASSEMBLY_IDENTITY_ATTRIBUTE_ENUMERATION_ROUTINE EnumerationRoutine,
    IN PVOID Context
    );

//
//  Assembly Identity encoding:
//
//  Assembly identities may be encoded in various forms.  The two usual ones
//  are either a binary stream, suitable for embedding in other data structures
//  or for persisting or a textual format that looks like:
//
//      name;[ns1,]n1="v1";[ns2,]n2="v2"[;...]
//

#define SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_BINARY (1)
#define SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_TEXTUAL (2)

BOOL
SxsComputeAssemblyIdentityEncodedSize(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    IN const GUID *EncodingGroup OPTIONAL, // use NULL to use any of the SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_* encodings
    IN ULONG EncodingFormat,
    OUT SIZE_T *SizeOut
    );

typedef BOOL (WINAPI * PSXS_COMPUTE_ASSEMBLY_IDENTITY_ENCODED_SIZE_ROUTINE)(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    IN const GUID *EncodingGroup OPTIONAL, // use NULL to use any of the SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_* encodings
    IN ULONG EncodingFormat,
    OUT SIZE_T *SizeOut
    );

BOOL
WINAPI
SxsEncodeAssemblyIdentity(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    IN const GUID *EncodingGroup OPTIONAL, // use NULL to use any of the SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_* encodings
    IN ULONG EncodingFormat,
    IN SIZE_T BufferSize,
    OUT PVOID Buffer,
    OUT SIZE_T *BytesWrittenOrRequired
    );

typedef BOOL (WINAPI * PSXS_ENCODE_ASSEMBLY_IDENTITY_ROUTINE)(
    IN DWORD Flags,
    IN PCASSEMBLY_IDENTITY AssemblyIdentity,
    IN const GUID *EncodingGroup OPTIONAL, // use NULL to use any of the SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_* encodings
    IN ULONG EncodingFormat,
    IN SIZE_T BufferSize,
    OUT PVOID Buffer,
    OUT SIZE_T *BytesWrittenOrRequired
    );

#define SXS_DECODE_ASSEMBLY_IDENTITY_FLAG_FREEZE        (0x00000001)

BOOL
WINAPI
SxsDecodeAssemblyIdentity(
    IN ULONG Flags,
    IN const GUID *EncodingGroup OPTIONAL, // use NULL to use any of the SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_* encodings
    IN ULONG EncodingFormat,
    IN SIZE_T BufferSize,
    IN const VOID *Buffer,
    OUT PASSEMBLY_IDENTITY *AssemblyIdentity
    );

typedef BOOL (WINAPI * PSXS_DECODE_ASSEMBLY_IDENTITY_ROUTINE)(
    IN DWORD Flags,
    IN const GUID *EncodingGroup OPTIONAL, // use NULL to use any of the SXS_ASSEMBLY_IDENTITY_ENCODING_DEFAULTGROUP_* encodings
    IN ULONG EncodingFormat,
    IN SIZE_T BufferSize,
    IN const VOID *Buffer,
    OUT PASSEMBLY_IDENTITY *AssemblyIdentity
    );

//
// These are the definitions that SFC requires to interact with SXS.
//

#define SXS_PROTECT_RECURSIVE       ( 0x00000001 )
#define SXS_PROTECT_SINGLE_LEVEL    ( 0x00000000 )
#define SXS_PROTECT_FILTER_DEFAULT ( FILE_NOTIFY_CHANGE_FILE_NAME | FILE_NOTIFY_CHANGE_DIR_NAME | FILE_NOTIFY_CHANGE_ATTRIBUTES | FILE_NOTIFY_CHANGE_SIZE | FILE_NOTIFY_CHANGE_LAST_WRITE | FILE_NOTIFY_CHANGE_LAST_ACCESS | FILE_NOTIFY_CHANGE_CREATION | FILE_NOTIFY_CHANGE_SECURITY )

typedef struct _SXS_PROTECT_DIRECTORY {
	WCHAR       pwszDirectory[MAX_PATH];
	PVOID       pvCookie;
	ULONG       ulRecursiveFlag;
	ULONG       ulNotifyFilter;
} SXS_PROTECT_DIRECTORY, *PSXS_PROTECT_DIRECTORY;
typedef const SXS_PROTECT_DIRECTORY* PCSXS_PROTECT_DIRECTORY;

typedef BOOL ( WINAPI * PSXS_PROTECT_NOTIFICATION )(
    PVOID pvCookie,
    PCWSTR  wsChangeText,
    SIZE_T  cchChangeText,
    DWORD   dwChangeAction
    );

BOOL 
WINAPI
SxsProtectionNotifyW( 
    PVOID pvCookie, 
    PCWSTR  wsChangeText,
    SIZE_T  cchChangeText,
    DWORD   dwChangeAction
    );


typedef BOOL ( WINAPI * PSXS_PROTECT_RETRIEVELISTS )(
    PCSXS_PROTECT_DIRECTORY *prgpProtectListing,
    SIZE_T *pcProtectEntries
    );

BOOL
WINAPI
SxsProtectionGatherEntriesW(
    PCSXS_PROTECT_DIRECTORY *prgpProtectListing,
    SIZE_T *pcProtectEntries
    );

//
// This is for both the Logon and the Logoff events
//
typedef BOOL ( WINAPI * PSXS_PROTECT_LOGIN_EVENT )(void);

BOOL
WINAPI
SxsProtectionUserLogonEvent(
    void
    );

BOOL
WINAPI
SxsProtectionUserLogoffEvent(
    void
    );

typedef BOOL ( WINAPI * PSXS_PROTECT_SCAN_ONCE )( HWND, BOOL, BOOL );

BOOL
WINAPI
SxsProtectionPerformScanNow(
    HWND hwProgressWindow,
    BOOL bValidate,
    BOOL bUIAllowed
    );

#define PFN_NAME_PROTECTION_GATHER_LISTS_W  ( "SxsProtectionGatherEntriesW" )
#define PFN_NAME_PROTECTION_NOTIFY_CHANGE_W ( "SxsProtectionNotifyW" )
#define PFN_NAME_PROTECTION_NOTIFY_LOGON    ( "SxsProtectionUserLogonEvent" )
#define PFN_NAME_PROTECTION_NOTIFY_LOGOFF   ( "SxsProtectionUserLogoffEvent" )
#define PFN_NAME_PROTECTION_SCAN_ONCE       ( "SxsProtectionPerformScanNow" )


//
//  Settings API
//

//
//  These APIs are deliberately designed to look like a subset of the registry
//  APIs; their behavior should match the documented registry behavior in general;
//  the major missing functionality includes security, the win16 compatibility
//  APIs, loading and unloading of keys/hives and change notification.
//
//  Settings are strictly local to the process; changes are not visible to other
//  processes until the settings are saved.
//

typedef struct _SXS_SETTINGS_KEY *PSXS_SETTINGS_KEY;
typedef const struct _SXS_SETTINGS_KEY *PCSXS_SETTINGS_KEY;

#define SXS_SETTINGS_USERSCOPE_INVALID (0)
#define SXS_SETTINGS_USERSCOPE_PER_USER (1)
#define SXS_SETTINGS_USERSCOPE_SYSTEM_WIDE (2)

#define SXS_SETTINGS_APPSCOPE_INVALID (0)
#define SXS_SETTINGS_APPSCOPE_PER_PROCESS_ROOT (1)
#define SXS_SETTINGS_APPSCOPE_PER_CONTEXT_ROOT (2)
#define SXS_SETTINGS_APPSCOPE_PER_COMPONENT (3)

#define SXS_SETTINGS_ITEMTYPE_INVALID (0)
#define SXS_SETTINGS_ITEMTYPE_KEY (1)
#define SXS_SETTINGS_ITEMTYPE_VALUE (2)

typedef VOID (WINAPI * PSXS_OPEN_SETTINGS_INITIALIZATION_CALLBACK)(
    IN PVOID pvContext,
    IN PSXS_SETTINGS_KEY lpUninitializedSettingsKey,
    OUT BOOL *pfFailed
    );

#define SXS_OPEN_SETTINGS_FLAG_RETURN_NULL_IF_NONE (0x00000001)

typedef LONG (WINAPI * PSXS_OPEN_SETTINGS_W)(
    IN DWORD dwFlags,
    IN ULONG ulUserScope,
    IN ULONG ulAppScope,
    IN PCWSTR lpAssemblyName,
    IN PSXS_OPEN_SETTINGS_INITIALIZATION_CALLBACK lpInitializationCallback OPTIONAL,
    IN PVOID pvContext,
    OUT PSXS_SETTINGS_KEY *lpKey
    );

LONG
WINAPI
SxsOpenSettingsW(
    IN DWORD dwFlags,
    IN ULONG ulUserScope,
    IN ULONG ulAppScope,
    IN PCWSTR lpAssemblyName,
    IN PSXS_OPEN_SETTINGS_INITIALIZATION_CALLBACK lpInitializationCallback OPTIONAL,
    IN PVOID pvContext,
    OUT PSXS_SETTINGS_KEY *lpKey
    );

#define SXS_MERGE_SETTINGS_KEYDISPOSITION_INVALID (0)
#define SXS_MERGE_SETTINGS_KEYDISPOSITION_COPY_ENTIRE_SUBTREE (1)
#define SXS_MERGE_SETTINGS_KEYDISPOSITION_COPY_KEY_WALK_SUBTREE (2)

typedef VOID (WINAPI * PSXS_MERGE_SETTINGS_KEY_CALLBACKW)(
    IN PVOID pvContext,
    IN PCWSTR lpKeyPath,
    OUT ULONG *lpKeyDisposition
    );

#define SXS_MERGE_SETTINGS_VALUEDISPOSITION_INVALID (0)
#define SXS_MERGE_SETTINGS_VALUEDISPOSITION_COPY (1)
#define SXS_MERGE_SETTINGS_VALUEDISPOSITION_DONT_COPY (2)

typedef VOID (WINAPI * PSXS_MERGE_SETTINGS_VALUE_CALLBACKW)(
    IN PVOID pvContext,
    IN PCWSTR lpKeyPath,
    IN LPCWSTR lpValueName,
    IN OUT LPDWORD lpType,
    IN OUT LPBYTE *lplpData, // pointer to replacable data pointer.  Allocate replacements using GlobalAlloc(GPTR, nBytes)
    IN DWORD dwDataBufferSize, // for modifying data you can write up to this many bytes
    OUT ULONG *lpValueDisposition
    );

typedef LONG (WINAPI * PSXS_MERGE_SETTINGS_W)(
    IN DWORD dwFlags,
    IN PCSXS_SETTINGS_KEY lpKeyToMergeFrom,
    IN PSXS_SETTINGS_KEY lpKeyToMergeInTo,
    IN PSXS_MERGE_SETTINGS_KEY_CALLBACKW lpKeyCallback,
    IN PSXS_MERGE_SETTINGS_VALUE_CALLBACKW lpValueCallback,
    LPVOID pvContext
    );

LONG
WINAPI
SxsMergeSettingsW(
    IN DWORD dwFlags,
    IN PCSXS_SETTINGS_KEY lpKeyToMergeFrom,
    IN PSXS_SETTINGS_KEY lpKeyToMergeInTo,
    IN PSXS_MERGE_SETTINGS_KEY_CALLBACKW lpKeyCallback,
    IN PSXS_MERGE_SETTINGS_VALUE_CALLBACKW lpValueCallback,
    LPVOID pvContext
    );

LONG
WINAPI
SxsCloseSettingsKey(
    PSXS_SETTINGS_KEY lpKey
    );

LONG
WINAPI
SxsCreateSettingsKeyExW(
    PSXS_SETTINGS_KEY lpKey,
    LPCWSTR lpSubKey,
    DWORD Reserved,
    LPWSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PSXS_SETTINGS_KEY *lplpKeyResult,
    LPDWORD lpdwDisposition
    );

LONG
WINAPI
SxsDeleteSettingsKeyW(
    PSXS_SETTINGS_KEY lpKey,
    LPCWSTR lpSubKey
    );

LONG
WINAPI
SxsDeleteSettingsValueW(
    PSXS_SETTINGS_KEY lpKey,
    LPCWSTR lpValueName
    );

LONG
WINAPI
SxsEnumSettingsKeyW(
    IN PSXS_SETTINGS_KEY lpKey,
    DWORD dwIndex,
    LPWSTR lpName,
    DWORD cbName
    );

LONG
WINAPI
SxsEnumSettingsKeyExW(
    IN PSXS_SETTINGS_KEY lpKey,
    IN DWORD dwIndex,
    OUT PWSTR lpName,
    IN OUT LPDWORD lpcName,
    IN OUT LPDWORD lpReserved,
    OUT PWSTR lpClass,
    OUT LPDWORD lpcClass,
    OUT PFILETIME lpftLastWriteTime
    );

LONG
WINAPI
SxsEnumSettingsValueW(
    IN PSXS_SETTINGS_KEY lpKey,
    IN DWORD dwIndex,
    OUT PWSTR lpValueName,
    IN OUT LPDWORD lpcValueName,
    IN OUT LPDWORD lpReserved,
    OUT LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    );

LONG
WINAPI
SxsFlushSettingsKey(
    IN PSXS_SETTINGS_KEY lpKey
    );

LONG
WINAPI
SxsOpenSettingsKeyEx(
    IN PSXS_SETTINGS_KEY lpKey,
    LPCWSTR lpSubKey,
    DWORD ulOptions,
    REGSAM samDesired,
    PSXS_SETTINGS_KEY *lplpKeyResult
    );

LONG
WINAPI
SxsQuerySettingsInfoKeyW(
    IN PSXS_SETTINGS_KEY lpKey,
    OUT PWSTR lpClass,
    IN OUT LPDWORD lpcClass,
    IN OUT LPDWORD lpReserved,
    OUT LPDWORD lpcSubKeys,
    OUT LPDWORD lpcMaxSubKeyLen,
    OUT LPDWORD lpcMaxClassLen,
    OUT LPDWORD lpcValues,
    OUT LPDWORD lpcMaxValueNameLen,
    OUT LPDWORD lpcMaxValueLen,
    OUT LPDWORD lpcSecurityDescriptor,
    OUT PFILETIME lpftLastWriteTime
    );

LONG
WINAPI
SxsQuerySettingsMultipleValuesW(
    IN PSXS_SETTINGS_KEY lpKey,
    PVALENT val_list,
    DWORD num_vals,
    LPWSTR lpValueBuf,
    LPDWORD lpdwTotsize
    );

LONG
WINAPI
SxsQuerySettingsValueExW(
    IN PSXS_SETTINGS_KEY lpKey,
    IN LPCWSTR lpValueName,
    IN OUT LPDWORD lpReserved,
    OUT LPDWORD lpType,
    OUT LPBYTE lpData,
    IN OUT LPDWORD lpcbData
    );

LONG
WINAPI
SxsSetSettingsValueExW(
    IN PSXS_SETTINGS_KEY lpKey,
    LPCWSTR lpValueName,
    DWORD dwReserved,
    DWORD dwType,
    CONST BYTE *lpData,
    DWORD cbData
    );


typedef struct _SXS_CLR_SURROGATE_INFORMATION {
    DWORD       cbSize;
    DWORD       dwFlags;
    GUID        SurrogateIdent;
    PCWSTR      pcwszSurrogateType;
    PCWSTR      pcwszImplementingAssembly;
    PCWSTR      pcwszRuntimeVersion;
} SXS_CLR_SURROGATE_INFORMATION, *PSXS_CLR_SURROGATE_INFORMATION;
typedef const SXS_CLR_SURROGATE_INFORMATION *PCSXS_CLR_SURROGATE_INFORMATION;

typedef struct _SXS_CLR_CLASS_INFORMATION {
    DWORD       dwSize;
    DWORD       dwFlags;
    ULONG       ulThreadingModel;
    ULONG       ulType;
    GUID        ReferenceClsid;
    PCWSTR      pcwszProgId;
    PCWSTR      pcwszImplementingAssembly;
    PCWSTR      pcwszTypeName;
    PCWSTR      pcwszRuntimeVersion;
} SXS_CLR_CLASS_INFORMATION, *PSXS_CLR_CLASS_INFORMATION;
typedef const SXS_CLR_CLASS_INFORMATION *PCSXS_CLR_CLASS_INFORMATION;

#define SXS_FIND_CLR_SURROGATE_USE_ACTCTX           (0x00000001)
#define SXS_FIND_CLR_SURROGATE_GET_IDENTITY         (0x00000002)
#define SXS_FIND_CLR_SURROGATE_GET_RUNTIME_VERSION  (0x00000004)
#define SXS_FIND_CLR_SURROGATE_GET_TYPE_NAME        (0x00000008)
#define SXS_FIND_CLR_SURROGATE_GET_ALL              (SXS_FIND_CLR_SURROGATE_GET_IDENTITY | SXS_FIND_CLR_SURROGATE_GET_RUNTIME_VERSION | SXS_FIND_CLR_SURROGATE_GET_TYPE_NAME)

#define SXS_FIND_CLR_SURROGATE_INFO                 ("SxsFindClrSurrogateInformation")

typedef BOOL (WINAPI* PFN_SXS_FIND_CLR_SURROGATE_INFO)(
    IN DWORD        dwFlags,
    IN LPGUID       lpGuidToFind,
    IN HANDLE       hActivationContext,
    IN OUT PVOID    pvDataBuffer,
    IN SIZE_T       cbDataBuffer,
    IN OUT PSIZE_T  pcbDataBufferWrittenOrRequired
    );

// The 'pvSearchData' parameter is really a progid to look up
#define SXS_FIND_CLR_CLASS_SEARCH_PROGID            (0x00000001)
// The 'pvSearchData' is an LPGUID to look up
#define SXS_FIND_CLR_CLASS_SEARCH_GUID              (0x00000002)
// Activate the given actctx before looking up information in it
#define SXS_FIND_CLR_CLASS_ACTIVATE_ACTCTX          (0x00000004)

#define SXS_FIND_CLR_CLASS_GET_PROGID               (0x00000008)
#define SXS_FIND_CLR_CLASS_GET_IDENTITY             (0x00000010)
#define SXS_FIND_CLR_CLASS_GET_TYPE_NAME            (0x00000020)
#define SXS_FIND_CLR_CLASS_GET_RUNTIME_VERSION      (0x00000040)
#define SXS_FIND_CLR_CLASS_GET_ALL                  (SXS_FIND_CLR_CLASS_GET_PROGID | SXS_FIND_CLR_CLASS_GET_IDENTITY | SXS_FIND_CLR_CLASS_GET_TYPE_NAME | SXS_FIND_CLR_CLASS_GET_RUNTIME_VERSION)

#define SXS_FIND_CLR_CLASS_INFO                     ("SxsFindClrClassInformation")

typedef BOOL (WINAPI* PFN_SXS_FIND_CLR_CLASS_INFO)(
    IN DWORD        dwFlags,
    IN PVOID        pvSearchData,
    IN HANDLE       hActivationContext,
    IN OUT PVOID    pvDataBuffer,
    IN SIZE_T       cbDataBuffer,
    OUT PSIZE_T     pcbDataBufferWrittenOrRequired
    );


#define SXS_GUID_INFORMATION_CLR_FLAG_IS_SURROGATE          (0x00000001)
#define SXS_GUID_INFORMATION_CLR_FLAG_IS_CLASS              (0x00000002)

typedef struct _SXS_GUID_INFORMATION_CLR
{
    DWORD       cbSize;
    DWORD       dwFlags;
    PCWSTR      pcwszRuntimeVersion;
    PCWSTR      pcwszTypeName;
    PCWSTR      pcwszAssemblyIdentity;
} SXS_GUID_INFORMATION_CLR, *PSXS_GUID_INFORMATION_CLR;
typedef const SXS_GUID_INFORMATION_CLR *PCSXS_GUID_INFORMATION_CLR;

#define SXS_LOOKUP_CLR_GUID_USE_ACTCTX                      (0x00000001)
#define SXS_LOOKUP_CLR_GUID_FIND_SURROGATE                  (0x00010000)
#define SXS_LOOKUP_CLR_GUID_FIND_CLR_CLASS                  (0x00020000)
#define SXS_LOOKUP_CLR_GUID_FIND_ANY                        (SXS_LOOKUP_CLR_GUID_FIND_CLR_CLASS | SXS_LOOKUP_CLR_GUID_FIND_SURROGATE)

#define SXS_LOOKUP_CLR_GUID                                 ("SxsLookupClrGuid")

typedef BOOL (WINAPI* PFN_SXS_LOOKUP_CLR_GUID)(
    IN DWORD       dwFlags,
    IN LPGUID      pClsid,
    IN HANDLE      hActCtx,
    IN OUT PVOID       pvOutputBuffer,
    IN SIZE_T      cbOutputBuffer,
    OUT PSIZE_T     pcbOutputBuffer
    );


#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _SXSAPI_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\symbolregblobs.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// Structures for SymbolReg.clb
// 10/22/1998  15:23:34
//*****************************************************************************
#pragma once
#ifndef DECLSPEC_SELECTANY
#define DECLSPEC_SELECTANY __declspec(selectany)
#endif
extern const DECLSPEC_SELECTANY int g_iCompRegTables = 9;
extern const BYTE DECLSPEC_SELECTANY g_rgCompRegSchemaDataRW[] = 
{
	0x09,0x00,0x00,0x00,0x10,0x04,0x00,0x00,0x2C,0x00,0x00,0x00,0x60,0x00,0x00,0x00,0x04,0x01,0x00,0x00,
	0x58,0x01,0x00,0x00,0xDC,0x01,0x00,0x00,0x40,0x02,0x00,0x00,0xC4,0x02,0x00,0x00,0x38,0x03,0x00,0x00,
	0x8C,0x03,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x22,0x02,0x01,0x00,0x54,0x00,0x00,0xFF,0xFF,
	0x08,0x00,0x34,0x00,0x13,0x00,0x00,0x00,0x01,0x01,0x48,0x00,0x04,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,
	0x1D,0x00,0x00,0x00,0x02,0x00,0x12,0x00,0x00,0x00,0x02,0x00,0x02,0x00,0xFF,0x43,0x26,0x00,0x00,0x00,
	0x01,0x00,0x01,0x2A,0x08,0x07,0x04,0x54,0x00,0x00,0x20,0x00,0x28,0x00,0xA4,0x00,0x37,0x00,0x00,0x00,
	0x01,0x04,0x2C,0x01,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x3B,0x00,0x00,0x00,0x02,0x01,0x82,0x00,
	0x14,0x00,0x04,0x00,0x00,0x04,0xFF,0x43,0x42,0x00,0x00,0x00,0x03,0x01,0x82,0x00,0x18,0x00,0x04,0x00,
	0x00,0x04,0xFF,0x43,0x4B,0x00,0x00,0x00,0x04,0x01,0x2C,0x01,0x04,0x00,0x04,0x00,0x04,0x00,0x00,0x43,
	0x57,0x00,0x00,0x00,0x05,0x01,0x03,0x00,0x08,0x00,0x04,0x00,0x04,0x00,0x01,0x43,0x66,0x00,0x00,0x00,
	0x06,0x01,0x2C,0x01,0x0C,0x00,0x04,0x00,0x04,0x00,0x02,0x43,0x76,0x00,0x00,0x00,0x07,0x01,0x03,0x00,
	0x10,0x00,0x04,0x00,0x04,0x00,0x03,0x43,0x87,0x00,0x00,0x00,0x08,0x01,0x82,0x00,0x1C,0x00,0x04,0x00,
	0x00,0x04,0xFF,0x43,0x98,0x00,0x00,0x00,0x4E,0x08,0x01,0x01,0x11,0x0B,0x24,0x00,0x01,0x01,0x00,0x58,
	0xAF,0x00,0x00,0x00,0x02,0x00,0x01,0x2A,0x03,0x00,0x00,0x54,0x00,0x00,0xFF,0xFF,0x10,0x00,0x54,0x00,
	0x37,0x00,0x00,0x00,0x01,0x04,0x2C,0x01,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0xC0,0x00,0x00,0x00,
	0x02,0x00,0x48,0x00,0x08,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0xCA,0x00,0x00,0x00,0x03,0x00,0x12,0x00,
	0x04,0x00,0x02,0x00,0x02,0x00,0xFF,0x43,0xD8,0x00,0x00,0x00,0x4E,0x08,0x01,0x01,0x11,0x0B,0x0C,0x00,
	0x01,0x01,0x00,0x58,0xEF,0x00,0x00,0x00,0x03,0x00,0x02,0x3A,0x05,0x00,0x00,0x54,0x01,0x00,0xFF,0xFF,
	0x18,0x00,0x84,0x00,0x04,0x01,0x00,0x00,0x01,0x08,0x13,0x00,0x00,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,
	0x37,0x00,0x00,0x00,0x02,0x04,0x2C,0x01,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x09,0x01,0x00,0x00,
	0x03,0x02,0x2C,0x01,0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x11,0x01,0x00,0x00,0x04,0x00,0x48,0x00,
	0x0C,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x1A,0x01,0x00,0x00,0x05,0x00,0x12,0x00,0x08,0x00,0x02,0x00,
	0x02,0x00,0xFF,0x43,0x20,0x01,0x00,0x00,0x4E,0x08,0x01,0x01,0x11,0x0B,0x10,0x00,0x01,0x02,0x00,0x58,
	0x3B,0x01,0x00,0x00,0x08,0x00,0x02,0x01,0x11,0xFF,0x14,0x00,0x01,0x03,0x00,0x58,0x54,0x01,0x00,0x00,
	0x04,0x00,0x01,0x3A,0x04,0x00,0x00,0x54,0x01,0x00,0xFF,0xFF,0x10,0x00,0x64,0x00,0x04,0x01,0x00,0x00,
	0x01,0x08,0x13,0x00,0x00,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x37,0x00,0x00,0x00,0x02,0x04,0x2C,0x01,
	0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x09,0x01,0x00,0x00,0x03,0x00,0x2C,0x01,0x04,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0x3B,0x00,0x00,0x00,0x04,0x00,0x82,0x00,0x08,0x00,0x04,0x00,0x00,0x04,0xFF,0x43,
	0x6B,0x01,0x00,0x00,0x4E,0x08,0x01,0x01,0x11,0x0B,0x0C,0x00,0x01,0x02,0x00,0x58,0x88,0x01,0x00,0x00,
	0x05,0x00,0x02,0x3A,0x05,0x00,0x00,0x54,0x01,0x00,0xFF,0xFF,0x18,0x00,0x84,0x00,0x04,0x01,0x00,0x00,
	0x01,0x08,0x13,0x00,0x00,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x37,0x00,0x00,0x00,0x02,0x04,0x2C,0x01,
	0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x09,0x01,0x00,0x00,0x03,0x02,0x2C,0x01,0x04,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0x9B,0x01,0x00,0x00,0x04,0x00,0x82,0x00,0x0C,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,
	0xA2,0x01,0x00,0x00,0x05,0x00,0x12,0x00,0x08,0x00,0x02,0x00,0x02,0x00,0xFF,0x43,0xAE,0x01,0x00,0x00,
	0x4E,0x08,0x01,0x01,0x11,0x0B,0x10,0x00,0x01,0x02,0x00,0x58,0xC7,0x01,0x00,0x00,0x08,0x00,0x02,0x01,
	0x11,0xFF,0x14,0x00,0x01,0x03,0x00,0x58,0xDE,0x01,0x00,0x00,0x06,0x00,0x02,0x3A,0x04,0x00,0x00,0x54,
	0x01,0x00,0xFF,0xFF,0x14,0x00,0x74,0x00,0x04,0x01,0x00,0x00,0x01,0x08,0x13,0x00,0x00,0x00,0x04,0x00,
	0xFF,0xFF,0xFF,0x43,0x37,0x00,0x00,0x00,0x02,0x04,0x2C,0x01,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x09,0x01,0x00,0x00,0x03,0x02,0x2C,0x01,0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0xF3,0x01,0x00,0x00,
	0x04,0x00,0x82,0x00,0x08,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0xFC,0x01,0x00,0x00,0x4E,0x08,0x01,0x01,
	0x11,0x0B,0x0C,0x00,0x01,0x02,0x00,0x58,0x17,0x02,0x00,0x00,0x08,0x00,0x02,0x01,0x11,0xFF,0x10,0x00,
	0x01,0x03,0x00,0x58,0x30,0x02,0x00,0x00,0x07,0x00,0x01,0x3A,0x03,0x00,0x00,0x54,0x01,0x00,0xFF,0xFF,
	0x0C,0x00,0x54,0x00,0x04,0x01,0x00,0x00,0x01,0x08,0x13,0x00,0x00,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,
	0x37,0x00,0x00,0x00,0x02,0x04,0x2C,0x01,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x41,0x02,0x00,0x00,
	0x03,0x00,0x82,0x00,0x04,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x45,0x02,0x00,0x00,0x4E,0x08,0x01,0x01,
	0x11,0x0B,0x08,0x00,0x01,0x02,0x00,0x58,0x5C,0x02,0x00,0x00,0x08,0x00,0x02,0x3A,0x05,0x00,0x00,0x54,
	0x01,0x00,0xFF,0xFF,0x18,0x00,0x84,0x00,0x04,0x01,0x00,0x00,0x01,0x08,0x13,0x00,0x00,0x00,0x04,0x00,
	0xFF,0xFF,0xFF,0x43,0x37,0x00,0x00,0x00,0x02,0x04,0x2C,0x01,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x6E,0x02,0x00,0x00,0x03,0x00,0x82,0x00,0x0C,0x00,0x04,0x00,0x00,0x04,0xFF,0x43,0x77,0x02,0x00,0x00,
	0x04,0x02,0x2C,0x01,0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x84,0x02,0x00,0x00,0x05,0x00,0x12,0x00,
	0x08,0x00,0x02,0x00,0x02,0x00,0xFF,0x43,0x8E,0x02,0x00,0x00,0x4E,0x08,0x01,0x01,0x11,0x0B,0x10,0x00,
	0x01,0x02,0x00,0x58,0xA6,0x02,0x00,0x00,0x08,0x00,0x02,0x01,0x11,0xFF,0x14,0x00,0x01,0x04,0x00,0x58,
};
extern const DECLSPEC_SELECTANY int g_cbCompRegSchemaRW = 1040;
extern const DECLSPEC_SELECTANY BYTE g_rgCompRegSchemaStringHeap[] = 
{
	0x00,0x43,0x6F,0x6D,0x70,0x52,0x65,0x67,0x2E,0x4D,0x6F,0x64,0x75,0x6C,0x65,0x52,0x65,0x67,0x00,0x52,
	0x65,0x67,0x69,0x73,0x74,0x72,0x61,0x72,0x00,0x52,0x65,0x67,0x46,0x6C,0x61,0x67,0x73,0x00,0x43,0x6F,
	0x6D,0x70,0x52,0x65,0x67,0x2E,0x43,0x6C,0x61,0x73,0x73,0x52,0x65,0x67,0x00,0x6F,0x69,0x64,0x00,0x50,
	0x72,0x6F,0x67,0x49,0x44,0x00,0x56,0x49,0x50,0x72,0x6F,0x67,0x49,0x44,0x00,0x44,0x65,0x66,0x61,0x75,
	0x6C,0x74,0x49,0x63,0x6F,0x6E,0x00,0x49,0x63,0x6F,0x6E,0x52,0x65,0x73,0x6F,0x75,0x72,0x63,0x65,0x49,
	0x44,0x00,0x54,0x6F,0x6F,0x6C,0x62,0x6F,0x78,0x42,0x69,0x74,0x6D,0x61,0x70,0x33,0x32,0x00,0x42,0x69,
	0x74,0x6D,0x61,0x70,0x52,0x65,0x73,0x6F,0x75,0x72,0x63,0x65,0x49,0x44,0x00,0x53,0x68,0x6F,0x72,0x74,
	0x44,0x69,0x73,0x70,0x6C,0x61,0x79,0x4E,0x61,0x6D,0x65,0x00,0x23,0x23,0x43,0x6F,0x6D,0x70,0x52,0x65,
	0x67,0x2E,0x43,0x6C,0x61,0x73,0x73,0x52,0x65,0x67,0x5F,0x44,0x65,0x78,0x00,0x43,0x6F,0x6D,0x70,0x52,
	0x65,0x67,0x2E,0x49,0x66,0x61,0x63,0x65,0x52,0x65,0x67,0x00,0x50,0x72,0x6F,0x78,0x79,0x53,0x74,0x75,
	0x62,0x00,0x49,0x66,0x61,0x63,0x65,0x53,0x65,0x72,0x76,0x69,0x63,0x65,0x73,0x00,0x23,0x23,0x43,0x6F,
	0x6D,0x70,0x52,0x65,0x67,0x2E,0x49,0x66,0x61,0x63,0x65,0x52,0x65,0x67,0x5F,0x44,0x65,0x78,0x00,0x43,
	0x6F,0x6D,0x70,0x52,0x65,0x67,0x2E,0x43,0x61,0x74,0x65,0x67,0x6F,0x72,0x79,0x49,0x6D,0x70,0x6C,0x00,
	0x5F,0x72,0x69,0x64,0x00,0x43,0x6F,0x63,0x6C,0x61,0x73,0x73,0x00,0x43,0x61,0x74,0x65,0x67,0x6F,0x72,
	0x79,0x00,0x46,0x6C,0x61,0x67,0x73,0x00,0x23,0x23,0x43,0x6F,0x6D,0x70,0x52,0x65,0x67,0x2E,0x43,0x61,
	0x74,0x65,0x67,0x6F,0x72,0x79,0x49,0x6D,0x70,0x6C,0x5F,0x44,0x65,0x78,0x00,0x43,0x6F,0x6D,0x70,0x52,
	0x65,0x67,0x2E,0x43,0x61,0x74,0x65,0x67,0x6F,0x72,0x79,0x49,0x6D,0x70,0x6C,0x5F,0x64,0x65,0x78,0x00,
	0x43,0x6F,0x6D,0x70,0x52,0x65,0x67,0x2E,0x52,0x65,0x64,0x69,0x72,0x65,0x63,0x74,0x50,0x72,0x6F,0x67,
	0x49,0x44,0x00,0x23,0x23,0x43,0x6F,0x6D,0x70,0x52,0x65,0x67,0x2E,0x52,0x65,0x64,0x69,0x72,0x65,0x63,
	0x74,0x50,0x72,0x6F,0x67,0x49,0x44,0x5F,0x44,0x65,0x78,0x00,0x43,0x6F,0x6D,0x70,0x52,0x65,0x67,0x2E,
	0x46,0x6F,0x72,0x6D,0x61,0x74,0x49,0x6D,0x70,0x6C,0x00,0x46,0x6F,0x72,0x6D,0x61,0x74,0x00,0x46,0x6F,
	0x72,0x6D,0x61,0x74,0x46,0x6C,0x61,0x67,0x73,0x00,0x23,0x23,0x43,0x6F,0x6D,0x70,0x52,0x65,0x67,0x2E,
	0x46,0x6F,0x72,0x6D,0x61,0x74,0x49,0x6D,0x70,0x6C,0x5F,0x44,0x65,0x78,0x00,0x43,0x6F,0x6D,0x70,0x52,
	0x65,0x67,0x2E,0x46,0x6F,0x72,0x6D,0x61,0x74,0x49,0x6D,0x70,0x6C,0x5F,0x64,0x65,0x78,0x00,0x43,0x6F,
	0x6D,0x70,0x52,0x65,0x67,0x2E,0x4D,0x49,0x4D,0x45,0x54,0x79,0x70,0x65,0x49,0x6D,0x70,0x6C,0x00,0x4D,
	0x49,0x4D,0x45,0x54,0x79,0x70,0x65,0x00,0x23,0x23,0x43,0x6F,0x6D,0x70,0x52,0x65,0x67,0x2E,0x4D,0x49,
	0x4D,0x45,0x54,0x79,0x70,0x65,0x49,0x6D,0x70,0x6C,0x5F,0x44,0x65,0x78,0x00,0x43,0x6F,0x6D,0x70,0x52,
	0x65,0x67,0x2E,0x4D,0x49,0x4D,0x45,0x54,0x79,0x70,0x65,0x49,0x6D,0x70,0x6C,0x5F,0x64,0x65,0x78,0x00,
	0x43,0x6F,0x6D,0x70,0x52,0x65,0x67,0x2E,0x52,0x65,0x73,0x6F,0x75,0x72,0x63,0x65,0x00,0x55,0x52,0x4C,
	0x00,0x23,0x23,0x43,0x6F,0x6D,0x70,0x52,0x65,0x67,0x2E,0x52,0x65,0x73,0x6F,0x75,0x72,0x63,0x65,0x5F,
	0x44,0x65,0x78,0x00,0x43,0x6F,0x6D,0x70,0x52,0x65,0x67,0x2E,0x52,0x6F,0x6C,0x65,0x43,0x68,0x65,0x63,
	0x6B,0x00,0x52,0x6F,0x6C,0x65,0x4E,0x61,0x6D,0x65,0x00,0x53,0x65,0x63,0x75,0x72,0x69,0x74,0x79,0x47,
	0x61,0x74,0x65,0x00,0x52,0x6F,0x6C,0x65,0x46,0x6C,0x61,0x67,0x73,0x00,0x23,0x23,0x43,0x6F,0x6D,0x70,
	0x52,0x65,0x67,0x2E,0x52,0x6F,0x6C,0x65,0x43,0x68,0x65,0x63,0x6B,0x5F,0x44,0x65,0x78,0x00,0x43,0x6F,
	0x6D,0x70,0x52,0x65,0x67,0x2E,0x52,0x6F,0x6C,0x65,0x43,0x68,0x65,0x63,0x6B,0x5F,0x64,0x65,0x78,0x00,
};
extern const DECLSPEC_SELECTANY BYTE * g_pbCompRegSchemaStringHeap = g_rgCompRegSchemaStringHeap;
extern const DECLSPEC_SELECTANY int g_cbCompRegSchemaStringHeap = 700;
extern const BYTE DECLSPEC_SELECTANY g_rgCompRegSchemaDataRO[] = 
{
	0x09,0x00,0x00,0x00,0x10,0x04,0x00,0x00,0x2C,0x00,0x00,0x00,0x60,0x00,0x00,0x00,0x04,0x01,0x00,0x00,
	0x58,0x01,0x00,0x00,0xDC,0x01,0x00,0x00,0x40,0x02,0x00,0x00,0xC4,0x02,0x00,0x00,0x38,0x03,0x00,0x00,
	0x8C,0x03,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x22,0x02,0x01,0x00,0x54,0x00,0x00,0xFF,0xFF,
	0x08,0x00,0x34,0x00,0x13,0x00,0x00,0x00,0x01,0x01,0x48,0x00,0x04,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,
	0x1D,0x00,0x00,0x00,0x02,0x00,0x12,0x00,0x00,0x00,0x02,0x00,0x02,0x00,0xFF,0x43,0x26,0x00,0x00,0x00,
	0x01,0x00,0x01,0x2A,0x08,0x07,0x04,0x54,0x00,0x00,0x20,0x00,0x28,0x00,0xA4,0x00,0x37,0x00,0x00,0x00,
	0x01,0x04,0x2C,0x01,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x3B,0x00,0x00,0x00,0x02,0x01,0x82,0x00,
	0x14,0x00,0x04,0x00,0x00,0x04,0xFF,0x43,0x42,0x00,0x00,0x00,0x03,0x01,0x82,0x00,0x18,0x00,0x04,0x00,
	0x00,0x04,0xFF,0x43,0x4B,0x00,0x00,0x00,0x04,0x01,0x2C,0x01,0x04,0x00,0x04,0x00,0x04,0x00,0x00,0x43,
	0x57,0x00,0x00,0x00,0x05,0x01,0x03,0x00,0x08,0x00,0x04,0x00,0x04,0x00,0x01,0x43,0x66,0x00,0x00,0x00,
	0x06,0x01,0x2C,0x01,0x0C,0x00,0x04,0x00,0x04,0x00,0x02,0x43,0x76,0x00,0x00,0x00,0x07,0x01,0x03,0x00,
	0x10,0x00,0x04,0x00,0x04,0x00,0x03,0x43,0x87,0x00,0x00,0x00,0x08,0x01,0x82,0x00,0x1C,0x00,0x04,0x00,
	0x00,0x04,0xFF,0x43,0x98,0x00,0x00,0x00,0x4E,0x08,0x01,0x01,0x11,0x0B,0x24,0x00,0x01,0x01,0x00,0x58,
	0xAF,0x00,0x00,0x00,0x02,0x00,0x01,0x2A,0x03,0x00,0x00,0x54,0x00,0x00,0xFF,0xFF,0x10,0x00,0x54,0x00,
	0x37,0x00,0x00,0x00,0x01,0x04,0x2C,0x01,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0xC0,0x00,0x00,0x00,
	0x02,0x00,0x48,0x00,0x08,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0xCA,0x00,0x00,0x00,0x03,0x00,0x12,0x00,
	0x04,0x00,0x02,0x00,0x02,0x00,0xFF,0x43,0xD8,0x00,0x00,0x00,0x4E,0x08,0x01,0x01,0x11,0x0B,0x0C,0x00,
	0x01,0x01,0x00,0x58,0xEF,0x00,0x00,0x00,0x03,0x00,0x02,0x3A,0x05,0x00,0x00,0x54,0x01,0x00,0xFF,0xFF,
	0x18,0x00,0x84,0x00,0x04,0x01,0x00,0x00,0x01,0x08,0x13,0x00,0x00,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,
	0x37,0x00,0x00,0x00,0x02,0x04,0x2C,0x01,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x09,0x01,0x00,0x00,
	0x03,0x02,0x2C,0x01,0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x11,0x01,0x00,0x00,0x04,0x00,0x48,0x00,
	0x0C,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x1A,0x01,0x00,0x00,0x05,0x00,0x12,0x00,0x08,0x00,0x02,0x00,
	0x02,0x00,0xFF,0x43,0x20,0x01,0x00,0x00,0x4E,0x08,0x01,0x01,0x11,0x0B,0x10,0x00,0x01,0x02,0x00,0x58,
	0x3B,0x01,0x00,0x00,0x08,0x00,0x02,0x01,0x11,0xFF,0x14,0x00,0x01,0x03,0x00,0x58,0x54,0x01,0x00,0x00,
	0x04,0x00,0x01,0x3A,0x04,0x00,0x00,0x54,0x01,0x00,0xFF,0xFF,0x10,0x00,0x64,0x00,0x04,0x01,0x00,0x00,
	0x01,0x08,0x13,0x00,0x00,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x37,0x00,0x00,0x00,0x02,0x04,0x2C,0x01,
	0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x09,0x01,0x00,0x00,0x03,0x00,0x2C,0x01,0x04,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0x3B,0x00,0x00,0x00,0x04,0x00,0x82,0x00,0x08,0x00,0x04,0x00,0x00,0x04,0xFF,0x43,
	0x6B,0x01,0x00,0x00,0x4E,0x08,0x01,0x01,0x11,0x0B,0x0C,0x00,0x01,0x02,0x00,0x58,0x88,0x01,0x00,0x00,
	0x05,0x00,0x02,0x3A,0x05,0x00,0x00,0x54,0x01,0x00,0xFF,0xFF,0x18,0x00,0x84,0x00,0x04,0x01,0x00,0x00,
	0x01,0x08,0x13,0x00,0x00,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x37,0x00,0x00,0x00,0x02,0x04,0x2C,0x01,
	0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x09,0x01,0x00,0x00,0x03,0x02,0x2C,0x01,0x04,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0x9B,0x01,0x00,0x00,0x04,0x00,0x82,0x00,0x0C,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,
	0xA2,0x01,0x00,0x00,0x05,0x00,0x12,0x00,0x08,0x00,0x02,0x00,0x02,0x00,0xFF,0x43,0xAE,0x01,0x00,0x00,
	0x4E,0x08,0x01,0x01,0x11,0x0B,0x10,0x00,0x01,0x02,0x00,0x58,0xC7,0x01,0x00,0x00,0x08,0x00,0x02,0x01,
	0x11,0xFF,0x14,0x00,0x01,0x03,0x00,0x58,0xDE,0x01,0x00,0x00,0x06,0x00,0x02,0x3A,0x04,0x00,0x00,0x54,
	0x01,0x00,0xFF,0xFF,0x14,0x00,0x74,0x00,0x04,0x01,0x00,0x00,0x01,0x08,0x13,0x00,0x00,0x00,0x04,0x00,
	0xFF,0xFF,0xFF,0x43,0x37,0x00,0x00,0x00,0x02,0x04,0x2C,0x01,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x09,0x01,0x00,0x00,0x03,0x02,0x2C,0x01,0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0xF3,0x01,0x00,0x00,
	0x04,0x00,0x82,0x00,0x08,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0xFC,0x01,0x00,0x00,0x4E,0x08,0x01,0x01,
	0x11,0x0B,0x0C,0x00,0x01,0x02,0x00,0x58,0x17,0x02,0x00,0x00,0x08,0x00,0x02,0x01,0x11,0xFF,0x10,0x00,
	0x01,0x03,0x00,0x58,0x30,0x02,0x00,0x00,0x07,0x00,0x01,0x3A,0x03,0x00,0x00,0x54,0x01,0x00,0xFF,0xFF,
	0x0C,0x00,0x54,0x00,0x04,0x01,0x00,0x00,0x01,0x08,0x13,0x00,0x00,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,
	0x37,0x00,0x00,0x00,0x02,0x04,0x2C,0x01,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x41,0x02,0x00,0x00,
	0x03,0x00,0x82,0x00,0x04,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x45,0x02,0x00,0x00,0x4E,0x08,0x01,0x01,
	0x11,0x0B,0x08,0x00,0x01,0x02,0x00,0x58,0x5C,0x02,0x00,0x00,0x08,0x00,0x02,0x3A,0x05,0x00,0x00,0x54,
	0x01,0x00,0xFF,0xFF,0x18,0x00,0x84,0x00,0x04,0x01,0x00,0x00,0x01,0x08,0x13,0x00,0x00,0x00,0x04,0x00,
	0xFF,0xFF,0xFF,0x43,0x37,0x00,0x00,0x00,0x02,0x04,0x2C,0x01,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x6E,0x02,0x00,0x00,0x03,0x00,0x82,0x00,0x0C,0x00,0x04,0x00,0x00,0x04,0xFF,0x43,0x77,0x02,0x00,0x00,
	0x04,0x02,0x2C,0x01,0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x84,0x02,0x00,0x00,0x05,0x00,0x12,0x00,
	0x08,0x00,0x02,0x00,0x02,0x00,0xFF,0x43,0x8E,0x02,0x00,0x00,0x4E,0x08,0x01,0x01,0x11,0x0B,0x10,0x00,
	0x01,0x02,0x00,0x58,0xA6,0x02,0x00,0x00,0x08,0x00,0x02,0x01,0x11,0xFF,0x14,0x00,0x01,0x04,0x00,0x58,
};
extern const DECLSPEC_SELECTANY int g_cbCompRegSchemaRO = 1040;
extern const COMPLIBSCHEMABLOB DECLSPEC_SELECTANY CompRegSchemaBlob = 
{
	&CompRegSchema,
	CompReg_TABLE_COUNT,
	0,
	g_rgCompRegSchemaDataRW,
	g_cbCompRegSchemaRW,
	g_rgCompRegSchemaDataRO,
	g_cbCompRegSchemaRO,
	g_rgCompRegSchemaStringHeap,
	g_cbCompRegSchemaStringHeap
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\symbolregstructs.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// Structures for ..\..\inc\SymbolRegStructs.h
// 10/22/1998  15:23:34
//*****************************************************************************
#pragma once
#ifndef DECLSPEC_SELECTANY
#define DECLSPEC_SELECTANY __declspec(selectany)
#endif
#include "icmprecs.h"


// Script supplied data.





#define CompRegTABLENAMELIST() \
	TABLENAME( ModuleReg ) \
	TABLENAME( ClassReg ) \
	TABLENAME( IfaceReg ) \
	TABLENAME( CategoryImpl ) \
	TABLENAME( RedirectProgID ) \
	TABLENAME( FormatImpl ) \
	TABLENAME( MIMETypeImpl ) \
	TABLENAME( Resource ) \
	TABLENAME( RoleCheck ) 


#undef TABLENAME
#define TABLENAME( TblName ) TABLENUM_CompReg_##TblName, 
enum
{
	CompRegTABLENAMELIST()
};

#define CompReg_TABLE_COUNT 9
extern const GUID DECLSPEC_SELECTANY SCHEMA_CompReg = { 0x4D2BB18F, 0x1A72, 0x11D2, {  0x97, 0x65, 0x00, 0xA0, 0xC9, 0xB4, 0xD5, 0x0C }};
extern const COMPLIBSCHEMA DECLSPEC_SELECTANY CompRegSchema = 
{
	&SCHEMA_CompReg,
	2
};


#define SCHEMA_CompReg_Name "CompReg"


#include "pshpack1.h"


//*****************************************************************************
//  CompReg.ModuleReg
//*****************************************************************************
typedef struct
{
    ULONG fNullFlags;
    GUID Registrar;
    unsigned short RegFlags;
    BYTE pad00 [2];

	inline int IsRegistrarNull(void)
	{ return (GetBit(fNullFlags, 1)); }

	inline void SetRegistrarNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 1, nullBitVal); }

    void Init()
    {
         memset(this, 0, sizeof(CompReg_ModuleReg));
         fNullFlags = (ULONG) -1;
    }

} CompReg_ModuleReg;

#define COLID_CompReg_ModuleReg_Registrar 1
#define COLID_CompReg_ModuleReg_RegFlags 2




//*****************************************************************************
//  CompReg.ClassReg
//*****************************************************************************
typedef struct
{
    ULONG fNullFlags;
    OID oid;
    ULONG cbProgIDLen;
    wchar_t ProgID[260];
    ULONG cbVIProgIDLen;
    wchar_t VIProgID[260];
    OID DefaultIcon;
    long IconResourceID;
    OID ToolboxBitmap32;
    long BitmapResourceID;
    ULONG cbShortDisplayNameLen;
    wchar_t ShortDisplayName[260];

	inline int IsShortDisplayNameNull(void)
	{ return (GetBit(fNullFlags, 8)); }

	inline void SetShortDisplayNameNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 8, nullBitVal); }

	inline int IsBitmapResourceIDNull(void)
	{ return (GetBit(fNullFlags, 7)); }

	inline void SetBitmapResourceIDNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 7, nullBitVal); }

	inline int IsToolboxBitmap32Null(void)
	{ return (GetBit(fNullFlags, 6)); }

	inline void SetToolboxBitmap32Null(int nullBitVal = true)
	{ SetBit(fNullFlags, 6, nullBitVal); }

	inline int IsIconResourceIDNull(void)
	{ return (GetBit(fNullFlags, 5)); }

	inline void SetIconResourceIDNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 5, nullBitVal); }

	inline int IsDefaultIconNull(void)
	{ return (GetBit(fNullFlags, 4)); }

	inline void SetDefaultIconNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 4, nullBitVal); }

	inline int IsVIProgIDNull(void)
	{ return (GetBit(fNullFlags, 3)); }

	inline void SetVIProgIDNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 3, nullBitVal); }

	inline int IsProgIDNull(void)
	{ return (GetBit(fNullFlags, 2)); }

	inline void SetProgIDNull(int nullBitVal = true)
	{ SetBit(fNullFlags, 2, nullBitVal); }

    void Init()
    {
         memset(this, 0, sizeof(CompReg_ClassReg));
         fNullFlags = (ULONG) -1;
    }

} CompReg_ClassReg;

#define COLID_CompReg_ClassReg_oid 1
#define COLID_CompReg_ClassReg_ProgID 2
#define COLID_CompReg_ClassReg_VIProgID 3
#define COLID_CompReg_ClassReg_DefaultIcon 4
#define COLID_CompReg_ClassReg_IconResourceID 5
#define COLID_CompReg_ClassReg_ToolboxBitmap32 6
#define COLID_CompReg_ClassReg_BitmapResourceID 7
#define COLID_CompReg_ClassReg_ShortDisplayName 8




//*****************************************************************************
//  CompReg.IfaceReg
//*****************************************************************************
typedef struct
{
    OID oid;
    GUID ProxyStub;
    unsigned short IfaceServices;
    BYTE pad00 [2];

    void Init()
    {
         memset(this, 0, sizeof(CompReg_IfaceReg));
    }

} CompReg_IfaceReg;

#define COLID_CompReg_IfaceReg_oid 1
#define COLID_CompReg_IfaceReg_ProxyStub 2
#define COLID_CompReg_IfaceReg_IfaceServices 3




//*****************************************************************************
//  CompReg.CategoryImpl
//*****************************************************************************
typedef struct
{
    unsigned long _rid;
    OID oid;
    OID Coclass;
    GUID Category;
    unsigned short Flags;
    BYTE pad00 [2];

    void Init()
    {
         memset(this, 0, sizeof(CompReg_CategoryImpl));
    }

} CompReg_CategoryImpl;

#define COLID_CompReg_CategoryImpl__rid 1
#define COLID_CompReg_CategoryImpl_oid 2
#define COLID_CompReg_CategoryImpl_Coclass 3
#define COLID_CompReg_CategoryImpl_Category 4
#define COLID_CompReg_CategoryImpl_Flags 5

#define Index_CompReg_CategoryImpl_dex "CompReg.CategoryImpl_dex"



//*****************************************************************************
//  CompReg.RedirectProgID
//*****************************************************************************
typedef struct
{
    unsigned long _rid;
    OID oid;
    OID Coclass;
    ULONG cbProgIDLen;
    wchar_t ProgID[260];

    void Init()
    {
         memset(this, 0, sizeof(CompReg_RedirectProgID));
    }

} CompReg_RedirectProgID;

#define COLID_CompReg_RedirectProgID__rid 1
#define COLID_CompReg_RedirectProgID_oid 2
#define COLID_CompReg_RedirectProgID_Coclass 3
#define COLID_CompReg_RedirectProgID_ProgID 4




//*****************************************************************************
//  CompReg.FormatImpl
//*****************************************************************************
typedef struct
{
    unsigned long _rid;
    OID oid;
    OID Coclass;
    ULONG cbFormatLen;
    wchar_t Format[260];
    unsigned short FormatFlags;
    BYTE pad00 [2];

    void Init()
    {
         memset(this, 0, sizeof(CompReg_FormatImpl));
    }

} CompReg_FormatImpl;

#define COLID_CompReg_FormatImpl__rid 1
#define COLID_CompReg_FormatImpl_oid 2
#define COLID_CompReg_FormatImpl_Coclass 3
#define COLID_CompReg_FormatImpl_Format 4
#define COLID_CompReg_FormatImpl_FormatFlags 5

#define Index_CompReg_FormatImpl_dex "CompReg.FormatImpl_dex"



//*****************************************************************************
//  CompReg.MIMETypeImpl
//*****************************************************************************
typedef struct
{
    unsigned long _rid;
    OID oid;
    OID Coclass;
    ULONG cbMIMETypeLen;
    wchar_t MIMEType[260];

    void Init()
    {
         memset(this, 0, sizeof(CompReg_MIMETypeImpl));
    }

} CompReg_MIMETypeImpl;

#define COLID_CompReg_MIMETypeImpl__rid 1
#define COLID_CompReg_MIMETypeImpl_oid 2
#define COLID_CompReg_MIMETypeImpl_Coclass 3
#define COLID_CompReg_MIMETypeImpl_MIMEType 4

#define Index_CompReg_MIMETypeImpl_dex "CompReg.MIMETypeImpl_dex"



//*****************************************************************************
//  CompReg.Resource
//*****************************************************************************
typedef struct
{
    unsigned long _rid;
    OID oid;
    ULONG cbURLLen;
    wchar_t URL[260];

    void Init()
    {
         memset(this, 0, sizeof(CompReg_Resource));
    }

} CompReg_Resource;

#define COLID_CompReg_Resource__rid 1
#define COLID_CompReg_Resource_oid 2
#define COLID_CompReg_Resource_URL 3




//*****************************************************************************
//  CompReg.RoleCheck
//*****************************************************************************
typedef struct
{
    unsigned long _rid;
    OID oid;
    ULONG cbRoleNameLen;
    wchar_t RoleName[260];
    OID SecurityGate;
    unsigned short RoleFlags;
    BYTE pad00 [2];

    void Init()
    {
         memset(this, 0, sizeof(CompReg_RoleCheck));
    }

} CompReg_RoleCheck;

#define COLID_CompReg_RoleCheck__rid 1
#define COLID_CompReg_RoleCheck_oid 2
#define COLID_CompReg_RoleCheck_RoleName 3
#define COLID_CompReg_RoleCheck_SecurityGate 4
#define COLID_CompReg_RoleCheck_RoleFlags 5

#define Index_CompReg_RoleCheck_dex "CompReg.RoleCheck_dex"



#include "poppack.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\sxshelpers.h ===
// ==++==
//
//   Copyright (c) Microsoft Corporation.  All rights reserved.
//
// ==--==
//****************************************************************************
//
//   SxSHelpers.h
//
//   Some helping classes and methods for SxS in mscoree and mscorwks/mscorsvr
//
//****************************************************************************

#pragma once

#define V1_VERSION_NUM L"v1.0.3705"


// Find the runtime version from registry for rclsid
// If succeeded, *ppwzRuntimeVersion will have the runtime version 
//      corresponding to the highest version
// If failed, *ppwzRuntimeVersion will be NULL
// 
// fListedVersion must be true before the RuntimeVersion entry for a managed-server
// is returned. An unmanaged server will always return the listed RuntimeVersion.
//
// Note: If succeeded, this function will allocate memory for 
//      *ppwzRuntimeVersion. It if the caller's repsonsibility to
//      release that memory
HRESULT FindRuntimeVersionFromRegistry(REFCLSID rclsid, LPWSTR *ppwzRuntimeVersion, BOOL fListedVersion);

// Find assembly info from registry for rclsid
// If succeeded, *ppwzClassName, *ppwzAssemblyString, *ppwzCodeBase
//      will have their value corresponding to the highest version
// If failed, they will be set to NULL
// Note: If succeeded, this function will allocate memory for 
//      *ppwzClassName, *ppwzAssemblyString and *ppwzCodeBase. 
//      Caller is responsible to release them.
HRESULT FindShimInfoFromRegistry(REFCLSID rclsid, BOOL bLoadReocrd, 
    LPWSTR *ppwzClassName, LPWSTR *ppwzAssemblyString, LPWSTR *ppwzCodeBase);

// Find assembly info from Win32 activattion context for rclsid
// If succeeded, *ppwzRuntimeVersion, *ppwzClassName, *ppwzAssemblyString, 
//      will have their value corresponding to the highest version
// If failed, they will be set to NULL
// Note: If succeeded, this function will allocate memory for 
//      *ppwzClassName, *ppwzAssemblyString and *ppwzCodeBase. 
//      Caller is responsible to release them.
//      Also notice codebase is not supported in Win32 case.
//
HRESULT FindShimInfoFromWin32(REFCLSID rclsid, BOOL bLoadRecord, LPWSTR *ppwzRuntimeVersion,
                      LPWSTR *ppwzClassName, LPWSTR *ppwzAssemblyString);



// Get information from the Win32 fusion about the config file and the application base.
HRESULT GetConfigFileFromWin32Manifest(WCHAR* buffer, DWORD dwBuffer, DWORD* pSize);
HRESULT GetApplicationPathFromWin32Manifest(WCHAR* buffer, DWORD dwBuffer, DWORD* pSize);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\symboltableblobs.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// Structures for SymbolTable.clb
// 12/18/1998  16:13:45
//*****************************************************************************
#pragma once
#ifndef DECLSPEC_SELECTANY
#define DECLSPEC_SELECTANY __declspec(selectany)
#endif
extern const DECLSPEC_SELECTANY int g_iSymTables = 25;
extern const BYTE DECLSPEC_SELECTANY g_rgSymSchemaDataRW[] = 
{
	0x19,0x00,0x00,0x00,0x60,0x0C,0x00,0x00,0x6C,0x00,0x00,0x00,0xF0,0x00,0x00,0x00,0xB4,0x01,0x00,0x00,
	0x38,0x02,0x00,0x00,0xCC,0x02,0x00,0x00,0xC0,0x03,0x00,0x00,0x44,0x04,0x00,0x00,0x98,0x04,0x00,0x00,
	0xCC,0x04,0x00,0x00,0x90,0x05,0x00,0x00,0x24,0x06,0x00,0x00,0xA8,0x06,0x00,0x00,0x1C,0x07,0x00,0x00,
	0x80,0x07,0x00,0x00,0xC4,0x07,0x00,0x00,0x38,0x08,0x00,0x00,0x0C,0x09,0x00,0x00,0xB0,0x09,0x00,0x00,
	0x14,0x0A,0x00,0x00,0x88,0x0A,0x00,0x00,0xDC,0x0A,0x00,0x00,0x30,0x0B,0x00,0x00,0x74,0x0B,0x00,0x00,
	0xE8,0x0B,0x00,0x00,0x2C,0x0C,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x01,0x38,0x06,0x00,0x00,0x54,
	0x01,0x00,0xFF,0xFF,0x18,0x00,0x84,0x00,0x0C,0x00,0x00,0x00,0x01,0x08,0x13,0x00,0x00,0x00,0x04,0x00,
	0xFF,0xFF,0xFF,0x43,0x11,0x00,0x00,0x00,0x02,0x04,0x2C,0x01,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x15,0x00,0x00,0x00,0x03,0x00,0x48,0x00,0x08,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x1A,0x00,0x00,0x00,
	0x04,0x00,0x48,0x00,0x0C,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x1F,0x00,0x00,0x00,0x05,0x00,0x82,0x00,
	0x10,0x00,0x04,0x00,0x00,0x04,0xFF,0x43,0x24,0x00,0x00,0x00,0x06,0x00,0x13,0x00,0x04,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0x2B,0x00,0x00,0x00,0x4E,0x08,0x01,0x01,0x11,0x0B,0x14,0x00,0x01,0x02,0x00,0x58,
	0x3C,0x00,0x00,0x00,0x01,0x00,0x01,0x38,0x0A,0x01,0x00,0x54,0x01,0x00,0xFF,0xFF,0x24,0x00,0xC4,0x00,
	0x0C,0x00,0x00,0x00,0x01,0x08,0x13,0x00,0x00,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x11,0x00,0x00,0x00,
	0x02,0x04,0x2C,0x01,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x48,0x00,0x00,0x00,0x03,0x00,0x82,0x00,
	0x14,0x00,0x04,0x00,0x00,0x04,0xFF,0x43,0x1F,0x00,0x00,0x00,0x04,0x00,0x82,0x00,0x18,0x00,0x04,0x00,
	0x00,0x04,0xFF,0x43,0x52,0x00,0x00,0x00,0x05,0x00,0x12,0x00,0x10,0x00,0x02,0x00,0x02,0x00,0xFF,0x43,
	0x58,0x00,0x00,0x00,0x06,0x00,0x2C,0x01,0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x60,0x00,0x00,0x00,
	0x07,0x00,0x12,0x00,0x12,0x00,0x02,0x00,0x02,0x00,0xFF,0x43,0x15,0x00,0x00,0x00,0x08,0x01,0x48,0x00,
	0x1C,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x6C,0x00,0x00,0x00,0x09,0x00,0x13,0x00,0x08,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0x76,0x00,0x00,0x00,0x0A,0x00,0x13,0x00,0x0C,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x80,0x00,0x00,0x00,0x4E,0x08,0x01,0x01,0x11,0x0B,0x20,0x00,0x01,0x02,0x00,0x58,0x92,0x00,0x00,0x00,
	0x02,0x00,0x01,0x3A,0x06,0x04,0x04,0x54,0x01,0x00,0x0C,0x00,0x14,0x00,0x84,0x00,0x0C,0x00,0x00,0x00,
	0x01,0x08,0x13,0x00,0x00,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x11,0x00,0x00,0x00,0x02,0x04,0x2C,0x01,
	0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0xA3,0x00,0x00,0x00,0x03,0x01,0x12,0x00,0x04,0x00,0x02,0x00,
	0x02,0x00,0x00,0x43,0xB1,0x00,0x00,0x00,0x04,0x01,0x12,0x00,0x06,0x00,0x02,0x00,0x02,0x00,0x01,0x43,
	0xC0,0x00,0x00,0x00,0x05,0x01,0x12,0x00,0x08,0x00,0x02,0x00,0x02,0x00,0x02,0x43,0xD1,0x00,0x00,0x00,
	0x06,0x01,0x12,0x00,0x0A,0x00,0x02,0x00,0x02,0x00,0x03,0x43,0xDC,0x00,0x00,0x00,0x4E,0x08,0x01,0x01,
	0x11,0x0B,0x10,0x00,0x01,0x02,0x00,0x58,0xF3,0x00,0x00,0x00,0x03,0x00,0x03,0x3A,0x05,0x00,0x00,0x54,
	0x01,0x00,0xFF,0xFF,0x1A,0x00,0x94,0x00,0x0C,0x00,0x00,0x00,0x01,0x08,0x13,0x00,0x00,0x00,0x04,0x00,
	0xFF,0xFF,0xFF,0x43,0x11,0x00,0x00,0x00,0x02,0x04,0x2C,0x01,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x05,0x01,0x00,0x00,0x03,0x02,0x2C,0x01,0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x0B,0x01,0x00,0x00,
	0x04,0x02,0x2C,0x01,0x08,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x15,0x01,0x00,0x00,0x05,0x00,0x12,0x00,
	0x0C,0x00,0x02,0x00,0x02,0x00,0xFF,0x43,0x1F,0x01,0x00,0x00,0x4E,0x08,0x01,0x01,0x11,0x0B,0x0E,0x00,
	0x01,0x02,0x00,0x58,0x37,0x01,0x00,0x00,0x08,0x10,0x02,0x01,0x11,0x05,0x12,0x00,0x01,0x03,0x00,0x58,
	0x53,0x01,0x00,0x00,0x08,0x10,0x03,0x01,0x11,0x05,0x16,0x00,0x01,0x04,0x00,0x58,0x73,0x01,0x00,0x00,
	0x04,0x00,0x01,0x3A,0x0D,0x09,0x05,0x54,0x01,0x00,0x30,0x00,0x3C,0x00,0xF4,0x00,0x0C,0x00,0x00,0x00,
	0x01,0x08,0x13,0x00,0x00,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x11,0x00,0x00,0x00,0x02,0x04,0x2C,0x01,
	0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x7F,0x01,0x00,0x00,0x03,0x00,0x82,0x00,0x1C,0x00,0x04,0x00,
	0xFF,0xFF,0xFF,0x43,0x83,0x01,0x00,0x00,0x04,0x00,0x12,0x00,0x18,0x00,0x02,0x00,0x02,0x00,0xFF,0x43,
	0x15,0x00,0x00,0x00,0x05,0x01,0x48,0x00,0x20,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x8D,0x01,0x00,0x00,
	0x06,0x01,0x82,0x00,0x24,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x9A,0x01,0x00,0x00,0x07,0x01,0x48,0x00,
	0x28,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x9E,0x01,0x00,0x00,0x08,0x01,0x82,0x00,0x2C,0x00,0x04,0x00,
	0xFF,0xFF,0xFF,0x43,0xA7,0x01,0x00,0x00,0x09,0x01,0x13,0x00,0x04,0x00,0x04,0x00,0x04,0x00,0x00,0x43,
	0x6C,0x00,0x00,0x00,0x0A,0x01,0x13,0x00,0x08,0x00,0x04,0x00,0x04,0x00,0x01,0x43,0x76,0x00,0x00,0x00,
	0x0B,0x01,0x13,0x00,0x0C,0x00,0x04,0x00,0x04,0x00,0x02,0x43,0xAC,0x01,0x00,0x00,0x0C,0x01,0x13,0x00,
	0x10,0x00,0x04,0x00,0x04,0x00,0x03,0x43,0xB7,0x01,0x00,0x00,0x0D,0x01,0x13,0x00,0x14,0x00,0x04,0x00,
	0x04,0x00,0x04,0x43,0xC2,0x01,0x00,0x00,0x4E,0x08,0x01,0x01,0x11,0x0B,0x38,0x00,0x01,0x02,0x00,0x58,
	0xD4,0x01,0x00,0x00,0x05,0x00,0x02,0x3A,0x05,0x00,0x00,0x54,0x01,0x00,0xFF,0xFF,0x18,0x00,0x84,0x00,
	0x0C,0x00,0x00,0x00,0x01,0x08,0x13,0x00,0x00,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x11,0x00,0x00,0x00,
	0x02,0x04,0x2C,0x01,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x1F,0x00,0x00,0x00,0x03,0x00,0x82,0x00,
	0x08,0x00,0x04,0x00,0x00,0x04,0xFF,0x43,0xE4,0x01,0x00,0x00,0x04,0x02,0x2C,0x01,0x04,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0xEB,0x01,0x00,0x00,0x05,0x00,0x80,0x00,0x0C,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,
	0xF1,0x01,0x00,0x00,0x4E,0x08,0x01,0x01,0x11,0x0B,0x10,0x00,0x01,0x02,0x00,0x58,0x07,0x02,0x00,0x00,
	0x08,0x10,0x02,0x01,0x11,0x05,0x14,0x00,0x01,0x04,0x00,0x58,0x1B,0x02,0x00,0x00,0x06,0x00,0x01,0x28,
	0x03,0x00,0x00,0x54,0x00,0x00,0xFF,0xFF,0x10,0x00,0x54,0x00,0x11,0x00,0x00,0x00,0x01,0x04,0x2C,0x01,
	0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x28,0x02,0x00,0x00,0x02,0x00,0x11,0x00,0x04,0x00,0x01,0x00,
	0x01,0x00,0xFF,0x43,0x2D,0x02,0x00,0x00,0x03,0x00,0x80,0x00,0x08,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,
	0x37,0x02,0x00,0x00,0x4E,0x08,0x01,0x01,0x11,0x0B,0x0C,0x00,0x01,0x01,0x00,0x58,0x4A,0x02,0x00,0x00,
	0x07,0x00,0x00,0x30,0x02,0x00,0x00,0x54,0x01,0x00,0xFF,0xFF,0x08,0x00,0x34,0x00,0x0C,0x00,0x00,0x00,
	0x01,0x08,0x13,0x00,0x00,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0xEB,0x01,0x00,0x00,0x02,0x00,0x15,0x00,
	0x00,0x00,0x08,0x00,0x08,0x00,0xFF,0x43,0x54,0x02,0x00,0x00,0x08,0x00,0x02,0x38,0x09,0x00,0x00,0x54,
	0x01,0x00,0xFF,0xFF,0x24,0x00,0xC4,0x00,0x0C,0x00,0x00,0x00,0x01,0x08,0x13,0x00,0x00,0x00,0x04,0x00,
	0xFF,0xFF,0xFF,0x43,0x11,0x00,0x00,0x00,0x02,0x04,0x2C,0x01,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x05,0x01,0x00,0x00,0x03,0x02,0x2C,0x01,0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x1F,0x00,0x00,0x00,
	0x04,0x00,0x82,0x00,0x14,0x00,0x04,0x00,0x00,0x04,0xFF,0x43,0x5F,0x02,0x00,0x00,0x05,0x00,0x80,0x00,
	0x18,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x52,0x00,0x00,0x00,0x06,0x00,0x12,0x00,0x0C,0x00,0x02,0x00,
	0x02,0x00,0xFF,0x43,0x6D,0x02,0x00,0x00,0x07,0x00,0x12,0x00,0x0E,0x00,0x02,0x00,0x02,0x00,0xFF,0x43,
	0x72,0x02,0x00,0x00,0x08,0x00,0x13,0x00,0x08,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x15,0x01,0x00,0x00,
	0x09,0x00,0x12,0x00,0x10,0x00,0x02,0x00,0x02,0x00,0xFF,0x43,0x76,0x02,0x00,0x00,0x4E,0x08,0x01,0x01,
	0x11,0x0B,0x1C,0x00,0x01,0x02,0x00,0x58,0x87,0x02,0x00,0x00,0x08,0x10,0x02,0x01,0x11,0x05,0x20,0x00,
	0x01,0x03,0x00,0x58,0x96,0x02,0x00,0x00,0x09,0x00,0x02,0x38,0x06,0x00,0x00,0x54,0x01,0x00,0xFF,0xFF,
	0x1C,0x00,0x94,0x00,0x0C,0x00,0x00,0x00,0x01,0x08,0x13,0x00,0x00,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,
	0x11,0x00,0x00,0x00,0x02,0x04,0x2C,0x01,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x05,0x01,0x00,0x00,
	0x03,0x02,0x2C,0x01,0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x1F,0x00,0x00,0x00,0x04,0x00,0x82,0x00,
	0x0C,0x00,0x04,0x00,0x00,0x04,0xFF,0x43,0x5F,0x02,0x00,0x00,0x05,0x00,0x80,0x00,0x10,0x00,0x04,0x00,
	0xFF,0xFF,0xFF,0x43,0x52,0x00,0x00,0x00,0x06,0x00,0x12,0x00,0x08,0x00,0x02,0x00,0x02,0x00,0xFF,0x43,
	0xA0,0x02,0x00,0x00,0x4E,0x08,0x01,0x01,0x11,0x0B,0x14,0x00,0x01,0x02,0x00,0x58,0xB0,0x02,0x00,0x00,
	0x08,0x10,0x02,0x01,0x11,0x05,0x18,0x00,0x01,0x03,0x00,0x58,0xBE,0x02,0x00,0x00,0x0A,0x00,0x01,0x30,
	0x06,0x00,0x00,0x54,0x01,0x00,0xFF,0xFF,0x14,0x00,0x84,0x00,0x0C,0x00,0x00,0x00,0x01,0x08,0x13,0x00,
	0x00,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x11,0x00,0x00,0x00,0x02,0x00,0x2C,0x01,0x00,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0xC8,0x02,0x00,0x00,0x03,0x02,0x2C,0x01,0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x1F,0x00,0x00,0x00,0x04,0x00,0x82,0x00,0x0C,0x00,0x04,0x00,0x00,0x04,0xFF,0x43,0xCF,0x02,0x00,0x00,
	0x05,0x00,0x12,0x00,0x08,0x00,0x02,0x00,0x02,0x00,0xFF,0x43,0x52,0x00,0x00,0x00,0x06,0x00,0x12,0x00,
	0x0A,0x00,0x02,0x00,0x02,0x00,0xFF,0x43,0xD8,0x02,0x00,0x00,0x08,0x10,0x01,0x01,0x11,0x05,0x10,0x00,
	0x01,0x03,0x00,0x58,0xE6,0x02,0x00,0x00,0x0B,0x00,0x01,0x38,0x05,0x00,0x00,0x54,0x01,0x00,0xFF,0xFF,
	0x14,0x00,0x74,0x00,0x0C,0x00,0x00,0x00,0x01,0x08,0x13,0x00,0x00,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,
	0x11,0x00,0x00,0x00,0x02,0x04,0x2C,0x01,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x1F,0x00,0x00,0x00,
	0x03,0x00,0x82,0x00,0x08,0x00,0x04,0x00,0x00,0x04,0xFF,0x43,0x5F,0x02,0x00,0x00,0x04,0x00,0x80,0x00,
	0x0C,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x05,0x01,0x00,0x00,0x05,0x00,0x2C,0x01,0x04,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0xF4,0x02,0x00,0x00,0x4E,0x08,0x01,0x01,0x11,0x0B,0x10,0x00,0x01,0x02,0x00,0x58,
	0x08,0x03,0x00,0x00,0x0C,0x00,0x00,0x30,0x05,0x00,0x00,0x54,0x01,0x00,0xFF,0xFF,0x0E,0x00,0x64,0x00,
	0x0C,0x00,0x00,0x00,0x01,0x08,0x13,0x00,0x00,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x05,0x01,0x00,0x00,
	0x02,0x00,0x2C,0x01,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x17,0x03,0x00,0x00,0x03,0x00,0x2C,0x01,
	0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x72,0x02,0x00,0x00,0x04,0x00,0x13,0x00,0x08,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0x15,0x01,0x00,0x00,0x05,0x00,0x12,0x00,0x0C,0x00,0x02,0x00,0x02,0x00,0xFF,0x43,
	0x1E,0x03,0x00,0x00,0x0D,0x00,0x00,0x30,0x03,0x00,0x00,0x54,0x01,0x00,0xFF,0xFF,0x08,0x00,0x44,0x00,
	0x0C,0x00,0x00,0x00,0x01,0x08,0x13,0x00,0x00,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x1F,0x00,0x00,0x00,
	0x02,0x00,0x82,0x00,0x04,0x00,0x04,0x00,0xFF,0x00,0xFF,0x43,0x11,0x00,0x00,0x00,0x03,0x00,0x2C,0x01,
	0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x2F,0x03,0x00,0x00,0x0E,0x00,0x02,0x38,0x04,0x00,0x00,0x54,
	0x01,0x00,0xFF,0xFF,0x14,0x00,0x74,0x00,0x3D,0x03,0x00,0x00,0x01,0x08,0x13,0x00,0x00,0x00,0x04,0x00,
	0xFF,0xFF,0xFF,0x43,0x11,0x00,0x00,0x00,0x02,0x04,0x2C,0x01,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x17,0x03,0x00,0x00,0x03,0x02,0x2C,0x01,0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x05,0x01,0x00,0x00,
	0x04,0x00,0x2C,0x01,0x08,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x41,0x03,0x00,0x00,0x4E,0x08,0x01,0x01,
	0x11,0x0B,0x0C,0x00,0x01,0x02,0x00,0x58,0x55,0x03,0x00,0x00,0x08,0x10,0x02,0x01,0x11,0x05,0x10,0x00,
	0x01,0x03,0x00,0x58,0x6E,0x03,0x00,0x00,0x0F,0x00,0x03,0x38,0x09,0x00,0x00,0x54,0x01,0x00,0xFF,0xFF,
	0x2C,0x00,0xD4,0x00,0x3D,0x03,0x00,0x00,0x01,0x08,0x13,0x00,0x00,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,
	0x11,0x00,0x00,0x00,0x02,0x04,0x2C,0x01,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0xE4,0x01,0x00,0x00,
	0x03,0x02,0x2C,0x01,0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x1F,0x00,0x00,0x00,0x04,0x02,0x82,0x00,
	0x18,0x00,0x04,0x00,0xFF,0x00,0xFF,0x43,0x28,0x02,0x00,0x00,0x05,0x00,0x80,0x00,0x1C,0x00,0x04,0x00,
	0xFF,0xFF,0xFF,0x43,0x7B,0x03,0x00,0x00,0x06,0x00,0x12,0x00,0x14,0x00,0x02,0x00,0x02,0x00,0xFF,0x43,
	0x85,0x03,0x00,0x00,0x07,0x00,0x2C,0x01,0x08,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x92,0x03,0x00,0x00,
	0x08,0x00,0x2C,0x01,0x0C,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0xA0,0x03,0x00,0x00,0x09,0x00,0x2C,0x01,
	0x10,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0xAD,0x03,0x00,0x00,0x4E,0x08,0x01,0x01,0x11,0x0B,0x20,0x00,
	0x01,0x02,0x00,0x58,0xC0,0x03,0x00,0x00,0x08,0x10,0x02,0x01,0x11,0x05,0x24,0x00,0x01,0x04,0x00,0x58,
	0xD6,0x03,0x00,0x00,0x08,0x10,0x03,0x01,0x11,0x05,0x28,0x00,0x01,0x03,0x00,0x58,0xEE,0x03,0x00,0x00,
	0x10,0x00,0x03,0x38,0x06,0x00,0x00,0x54,0x01,0x00,0xFF,0xFF,0x20,0x00,0xA4,0x00,0x3D,0x03,0x00,0x00,
	0x01,0x08,0x13,0x00,0x00,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x11,0x00,0x00,0x00,0x02,0x04,0x2C,0x01,
	0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0xE4,0x01,0x00,0x00,0x03,0x02,0x2C,0x01,0x04,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0x1F,0x00,0x00,0x00,0x04,0x02,0x82,0x00,0x10,0x00,0x04,0x00,0xFF,0x00,0xFF,0x43,
	0xF8,0x03,0x00,0x00,0x05,0x00,0x2C,0x01,0x08,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x02,0x04,0x00,0x00,
	0x06,0x00,0x12,0x00,0x0C,0x00,0x02,0x00,0x02,0x00,0xFF,0x43,0x0D,0x04,0x00,0x00,0x4E,0x08,0x01,0x01,
	0x11,0x0B,0x14,0x00,0x01,0x02,0x00,0x58,0x1D,0x04,0x00,0x00,0x08,0x10,0x02,0x01,0x11,0x05,0x18,0x00,
	0x01,0x04,0x00,0x58,0x30,0x04,0x00,0x00,0x08,0x10,0x03,0x01,0x11,0x05,0x1C,0x00,0x01,0x03,0x00,0x58,
	0x45,0x04,0x00,0x00,0x11,0x00,0x02,0x20,0x03,0x00,0x00,0x54,0x00,0x00,0xFF,0xFF,0x12,0x00,0x64,0x00,
	0x17,0x03,0x00,0x00,0x01,0x02,0x2C,0x01,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x59,0x04,0x00,0x00,
	0x02,0x02,0x2C,0x01,0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x65,0x04,0x00,0x00,0x03,0x00,0x12,0x00,
	0x08,0x00,0x02,0x00,0x02,0x00,0xFF,0x43,0x6E,0x04,0x00,0x00,0x08,0x10,0x01,0x01,0x11,0x05,0x0A,0x00,
	0x01,0x02,0x00,0x58,0x82,0x04,0x00,0x00,0x08,0x10,0x02,0x01,0x11,0x05,0x0E,0x00,0x01,0x01,0x00,0x58,
	0xA1,0x04,0x00,0x00,0x12,0x00,0x02,0x28,0x04,0x00,0x00,0x54,0x00,0x00,0xFF,0xFF,0x18,0x00,0x74,0x00,
	0x05,0x01,0x00,0x00,0x01,0x06,0x2C,0x01,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0xB1,0x04,0x00,0x00,
	0x02,0x00,0x12,0x00,0x08,0x00,0x02,0x00,0x02,0x00,0xFF,0x43,0xBD,0x04,0x00,0x00,0x03,0x00,0x80,0x00,
	0x0C,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0xC9,0x04,0x00,0x00,0x04,0x00,0x13,0x00,0x04,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0xD3,0x04,0x00,0x00,0x4E,0x08,0x01,0x01,0x11,0x0B,0x10,0x00,0x01,0x01,0x00,0x58,
	0xE9,0x04,0x00,0x00,0x08,0x10,0x02,0x01,0x11,0x05,0x14,0x00,0x01,0x01,0x00,0x58,0xFD,0x04,0x00,0x00,
	0x13,0x00,0x02,0x28,0x02,0x00,0x00,0x54,0x00,0x00,0xFF,0xFF,0x10,0x00,0x54,0x00,0x0E,0x05,0x00,0x00,
	0x01,0x06,0x2C,0x01,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x14,0x05,0x00,0x00,0x02,0x00,0x80,0x00,
	0x04,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x1F,0x05,0x00,0x00,0x4E,0x08,0x01,0x01,0x11,0x0B,0x08,0x00,
	0x01,0x01,0x00,0x58,0x36,0x05,0x00,0x00,0x08,0x10,0x02,0x01,0x11,0x05,0x0C,0x00,0x01,0x01,0x00,0x58,
	0x4B,0x05,0x00,0x00,0x14,0x00,0x00,0x30,0x04,0x00,0x00,0x54,0x01,0x00,0xFF,0xFF,0x0C,0x00,0x54,0x00,
	0x3D,0x03,0x00,0x00,0x01,0x08,0x13,0x00,0x00,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x5C,0x05,0x00,0x00,
	0x02,0x00,0x2C,0x01,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x67,0x05,0x00,0x00,0x03,0x00,0x12,0x00,
	0x04,0x00,0x02,0x00,0x02,0x00,0xFF,0x43,0x6E,0x05,0x00,0x00,0x04,0x00,0x80,0x00,0x08,0x00,0x04,0x00,
	0xFF,0xFF,0xFF,0x43,0x7C,0x05,0x00,0x00,0x15,0x00,0x01,0x30,0x02,0x00,0x00,0x54,0x01,0x00,0xFF,0xFF,
	0x08,0x00,0x44,0x00,0x3D,0x03,0x00,0x00,0x01,0x08,0x13,0x00,0x00,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,
	0x8E,0x05,0x00,0x00,0x02,0x02,0x80,0x00,0x00,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x98,0x05,0x00,0x00,
	0x48,0x10,0x01,0x01,0x11,0x05,0x04,0x00,0x01,0x02,0x00,0x58,0xAE,0x05,0x00,0x00,0x16,0x00,0x01,0x38,
	0x05,0x02,0x00,0x54,0x01,0x00,0xFF,0xFF,0x14,0x00,0x74,0x00,0x0C,0x00,0x00,0x00,0x01,0x08,0x13,0x00,
	0x00,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x11,0x00,0x00,0x00,0x02,0x04,0x2C,0x01,0x00,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0x15,0x00,0x00,0x00,0x03,0x01,0x48,0x00,0x04,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,
	0x1A,0x00,0x00,0x00,0x04,0x01,0x48,0x00,0x08,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x1F,0x00,0x00,0x00,
	0x05,0x00,0x82,0x00,0x0C,0x00,0x04,0x00,0x00,0x04,0xFF,0x43,0xBC,0x05,0x00,0x00,0x4E,0x08,0x01,0x01,
	0x11,0x0B,0x10,0x00,0x01,0x02,0x00,0x58,0xD0,0x05,0x00,0x00,0x17,0x00,0x01,0x30,0x02,0x00,0x00,0x54,
	0x01,0x00,0xFF,0xFF,0x08,0x00,0x44,0x00,0x3D,0x03,0x00,0x00,0x01,0x08,0x13,0x00,0x00,0x00,0x04,0x00,
	0xFF,0xFF,0xFF,0x43,0x8E,0x05,0x00,0x00,0x02,0x02,0x80,0x00,0x00,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,
	0xDE,0x05,0x00,0x00,0x48,0x10,0x01,0x01,0x11,0x05,0x04,0x00,0x01,0x02,0x00,0x58,0xFA,0x05,0x00,0x00,
	0x18,0x00,0x00,0x20,0x02,0x00,0x00,0x54,0x00,0x00,0xFF,0xFF,0x08,0x00,0x34,0x00,0x72,0x02,0x00,0x00,
	0x01,0x00,0x13,0x00,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x08,0x06,0x00,0x00,0x02,0x00,0x13,0x00,
	0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
};
extern const DECLSPEC_SELECTANY int g_cbSymSchemaRW = 3168;
extern const DECLSPEC_SELECTANY BYTE g_rgSymSchemaStringHeap[] = 
{
	0x00,0x53,0x79,0x6D,0x2E,0x4D,0x6F,0x64,0x75,0x6C,0x65,0x00,0x5F,0x72,0x69,0x64,0x00,0x6F,0x69,0x64,
	0x00,0x67,0x75,0x69,0x64,0x00,0x6D,0x76,0x69,0x64,0x00,0x4E,0x61,0x6D,0x65,0x00,0x4C,0x6F,0x63,0x61,
	0x6C,0x65,0x00,0x23,0x23,0x53,0x79,0x6D,0x2E,0x4D,0x6F,0x64,0x75,0x6C,0x65,0x5F,0x44,0x65,0x78,0x00,
	0x53,0x79,0x6D,0x2E,0x54,0x79,0x70,0x65,0x44,0x65,0x66,0x00,0x4E,0x61,0x6D,0x65,0x73,0x70,0x61,0x63,
	0x65,0x00,0x46,0x6C,0x61,0x67,0x73,0x00,0x45,0x78,0x74,0x65,0x6E,0x64,0x73,0x00,0x45,0x78,0x74,0x65,
	0x6E,0x64,0x73,0x46,0x6C,0x61,0x67,0x00,0x56,0x65,0x72,0x73,0x69,0x6F,0x6E,0x4D,0x53,0x00,0x56,0x65,
	0x72,0x73,0x69,0x6F,0x6E,0x4C,0x53,0x00,0x23,0x23,0x53,0x79,0x6D,0x2E,0x54,0x79,0x70,0x65,0x44,0x65,
	0x66,0x5F,0x44,0x65,0x78,0x00,0x53,0x79,0x6D,0x2E,0x43,0x6C,0x61,0x73,0x73,0x43,0x6F,0x6E,0x74,0x65,
	0x78,0x74,0x00,0x42,0x65,0x68,0x61,0x76,0x69,0x6F,0x72,0x46,0x6C,0x61,0x67,0x73,0x00,0x54,0x68,0x72,
	0x65,0x61,0x64,0x69,0x6E,0x67,0x4D,0x6F,0x64,0x65,0x6C,0x00,0x54,0x72,0x61,0x6E,0x73,0x61,0x63,0x74,
	0x69,0x6F,0x6E,0x52,0x65,0x71,0x74,0x73,0x00,0x53,0x79,0x6E,0x63,0x68,0x52,0x65,0x71,0x74,0x73,0x00,
	0x23,0x23,0x53,0x79,0x6D,0x2E,0x43,0x6C,0x61,0x73,0x73,0x43,0x6F,0x6E,0x74,0x65,0x78,0x74,0x5F,0x44,
	0x65,0x78,0x00,0x53,0x79,0x6D,0x2E,0x49,0x6E,0x74,0x65,0x72,0x66,0x61,0x63,0x65,0x49,0x6D,0x70,0x6C,
	0x00,0x43,0x6C,0x61,0x73,0x73,0x00,0x49,0x6E,0x74,0x65,0x72,0x66,0x61,0x63,0x65,0x00,0x49,0x6D,0x70,
	0x6C,0x46,0x6C,0x61,0x67,0x73,0x00,0x23,0x23,0x53,0x79,0x6D,0x2E,0x49,0x6E,0x74,0x65,0x72,0x66,0x61,
	0x63,0x65,0x49,0x6D,0x70,0x6C,0x5F,0x44,0x65,0x78,0x00,0x53,0x79,0x6D,0x2E,0x49,0x6E,0x74,0x65,0x72,
	0x66,0x61,0x63,0x65,0x49,0x6D,0x70,0x6C,0x5F,0x43,0x6C,0x61,0x73,0x73,0x5F,0x44,0x65,0x78,0x00,0x53,
	0x79,0x6D,0x2E,0x49,0x6E,0x74,0x65,0x72,0x66,0x61,0x63,0x65,0x49,0x6D,0x70,0x6C,0x5F,0x49,0x6E,0x74,
	0x65,0x72,0x66,0x61,0x63,0x65,0x5F,0x44,0x65,0x78,0x00,0x53,0x79,0x6D,0x2E,0x54,0x79,0x70,0x65,0x52,
	0x65,0x66,0x00,0x55,0x52,0x4C,0x00,0x42,0x69,0x6E,0x64,0x46,0x6C,0x61,0x67,0x73,0x00,0x46,0x75,0x6C,
	0x6C,0x51,0x75,0x61,0x6C,0x4E,0x61,0x6D,0x65,0x00,0x56,0x49,0x44,0x00,0x43,0x6F,0x64,0x65,0x62,0x61,
	0x73,0x65,0x00,0x4C,0x43,0x49,0x44,0x00,0x56,0x65,0x72,0x73,0x69,0x6F,0x6E,0x4D,0x69,0x6E,0x00,0x56,
	0x65,0x72,0x73,0x69,0x6F,0x6E,0x4D,0x61,0x78,0x00,0x23,0x23,0x53,0x79,0x6D,0x2E,0x54,0x79,0x70,0x65,
	0x52,0x65,0x66,0x5F,0x44,0x65,0x78,0x00,0x53,0x79,0x6D,0x2E,0x43,0x75,0x73,0x74,0x6F,0x6D,0x56,0x61,
	0x6C,0x75,0x65,0x00,0x50,0x61,0x72,0x65,0x6E,0x74,0x00,0x56,0x61,0x6C,0x75,0x65,0x00,0x23,0x23,0x53,
	0x79,0x6D,0x2E,0x43,0x75,0x73,0x74,0x6F,0x6D,0x56,0x61,0x6C,0x75,0x65,0x5F,0x44,0x65,0x78,0x00,0x53,
	0x79,0x6D,0x2E,0x43,0x75,0x73,0x74,0x6F,0x6D,0x56,0x61,0x6C,0x75,0x65,0x5F,0x44,0x65,0x78,0x00,0x53,
	0x79,0x6D,0x2E,0x43,0x6F,0x6E,0x73,0x74,0x61,0x6E,0x74,0x00,0x54,0x79,0x70,0x65,0x00,0x56,0x61,0x6C,
	0x75,0x65,0x42,0x6C,0x6F,0x62,0x00,0x23,0x23,0x53,0x79,0x6D,0x2E,0x43,0x6F,0x6E,0x73,0x74,0x61,0x6E,
	0x74,0x5F,0x44,0x65,0x78,0x00,0x53,0x79,0x6D,0x2E,0x54,0x6F,0x6B,0x65,0x6E,0x00,0x53,0x79,0x6D,0x2E,
	0x4D,0x65,0x74,0x68,0x6F,0x64,0x00,0x53,0x69,0x67,0x6E,0x61,0x74,0x75,0x72,0x65,0x42,0x6C,0x6F,0x62,
	0x00,0x53,0x6C,0x6F,0x74,0x00,0x52,0x56,0x41,0x00,0x23,0x23,0x53,0x79,0x6D,0x2E,0x4D,0x65,0x74,0x68,
	0x6F,0x64,0x5F,0x44,0x65,0x78,0x00,0x53,0x79,0x6D,0x2E,0x4D,0x65,0x74,0x68,0x6F,0x64,0x5F,0x44,0x65,
	0x78,0x00,0x53,0x79,0x6D,0x2E,0x46,0x69,0x65,0x6C,0x64,0x00,0x23,0x23,0x53,0x79,0x6D,0x2E,0x46,0x69,
	0x65,0x6C,0x64,0x5F,0x44,0x65,0x78,0x00,0x53,0x79,0x6D,0x2E,0x46,0x69,0x65,0x6C,0x64,0x5F,0x44,0x65,
	0x78,0x00,0x53,0x79,0x6D,0x2E,0x50,0x61,0x72,0x61,0x6D,0x00,0x4D,0x65,0x6D,0x62,0x65,0x72,0x00,0x53,
	0x65,0x71,0x75,0x65,0x6E,0x63,0x65,0x00,0x53,0x79,0x6D,0x2E,0x50,0x61,0x72,0x61,0x6D,0x5F,0x44,0x65,
	0x78,0x00,0x53,0x79,0x6D,0x2E,0x4D,0x65,0x6D,0x62,0x65,0x72,0x52,0x65,0x66,0x00,0x23,0x23,0x53,0x79,
	0x6D,0x2E,0x4D,0x65,0x6D,0x62,0x65,0x72,0x52,0x65,0x66,0x5F,0x44,0x65,0x78,0x00,0x53,0x79,0x6D,0x2E,
	0x4D,0x65,0x74,0x68,0x6F,0x64,0x49,0x6D,0x70,0x6C,0x00,0x4D,0x65,0x74,0x68,0x6F,0x64,0x00,0x53,0x79,
	0x6D,0x2E,0x52,0x65,0x67,0x4E,0x61,0x6D,0x65,0x73,0x70,0x61,0x63,0x65,0x00,0x53,0x79,0x6D,0x2E,0x45,
	0x78,0x63,0x65,0x70,0x74,0x69,0x6F,0x6E,0x00,0x72,0x69,0x64,0x00,0x23,0x23,0x53,0x79,0x6D,0x2E,0x45,
	0x78,0x63,0x65,0x70,0x74,0x69,0x6F,0x6E,0x5F,0x44,0x65,0x78,0x00,0x53,0x79,0x6D,0x2E,0x45,0x78,0x63,
	0x65,0x70,0x74,0x69,0x6F,0x6E,0x5F,0x4D,0x65,0x74,0x68,0x6F,0x64,0x5F,0x44,0x65,0x78,0x00,0x53,0x79,
	0x6D,0x2E,0x50,0x72,0x6F,0x70,0x65,0x72,0x74,0x79,0x00,0x50,0x72,0x6F,0x70,0x46,0x6C,0x61,0x67,0x73,
	0x00,0x42,0x61,0x63,0x6B,0x69,0x6E,0x67,0x46,0x69,0x65,0x6C,0x64,0x00,0x45,0x76,0x65,0x6E,0x74,0x43,
	0x68,0x61,0x6E,0x67,0x69,0x6E,0x67,0x00,0x45,0x76,0x65,0x6E,0x74,0x43,0x68,0x61,0x6E,0x67,0x65,0x64,
	0x00,0x23,0x23,0x53,0x79,0x6D,0x2E,0x50,0x72,0x6F,0x70,0x65,0x72,0x74,0x79,0x5F,0x44,0x65,0x78,0x00,
	0x53,0x79,0x6D,0x2E,0x50,0x72,0x6F,0x70,0x65,0x72,0x74,0x79,0x5F,0x4E,0x61,0x6D,0x65,0x5F,0x44,0x65,
	0x78,0x00,0x53,0x79,0x6D,0x2E,0x50,0x72,0x6F,0x70,0x65,0x72,0x74,0x79,0x5F,0x50,0x61,0x72,0x65,0x6E,
	0x74,0x5F,0x44,0x65,0x78,0x00,0x53,0x79,0x6D,0x2E,0x45,0x76,0x65,0x6E,0x74,0x00,0x45,0x76,0x65,0x6E,
	0x74,0x54,0x79,0x70,0x65,0x00,0x45,0x76,0x65,0x6E,0x74,0x46,0x6C,0x61,0x67,0x73,0x00,0x23,0x23,0x53,
	0x79,0x6D,0x2E,0x45,0x76,0x65,0x6E,0x74,0x5F,0x44,0x65,0x78,0x00,0x53,0x79,0x6D,0x2E,0x45,0x76,0x65,
	0x6E,0x74,0x5F,0x4E,0x61,0x6D,0x65,0x5F,0x44,0x65,0x78,0x00,0x53,0x79,0x6D,0x2E,0x45,0x76,0x65,0x6E,
	0x74,0x5F,0x50,0x61,0x72,0x65,0x6E,0x74,0x5F,0x44,0x65,0x78,0x00,0x53,0x79,0x6D,0x2E,0x4D,0x65,0x74,
	0x68,0x6F,0x64,0x53,0x65,0x6D,0x61,0x6E,0x74,0x69,0x63,0x73,0x00,0x41,0x73,0x73,0x6F,0x63,0x69,0x61,
	0x74,0x69,0x6F,0x6E,0x00,0x53,0x65,0x6D,0x61,0x6E,0x74,0x69,0x63,0x00,0x53,0x79,0x6D,0x2E,0x41,0x73,
	0x73,0x6F,0x63,0x69,0x61,0x74,0x69,0x6F,0x6E,0x5F,0x44,0x65,0x78,0x00,0x53,0x79,0x6D,0x2E,0x4D,0x65,
	0x74,0x68,0x6F,0x64,0x53,0x65,0x6D,0x61,0x6E,0x74,0x69,0x63,0x73,0x5F,0x4D,0x65,0x74,0x68,0x6F,0x64,
	0x5F,0x44,0x65,0x78,0x00,0x53,0x79,0x6D,0x2E,0x43,0x6C,0x61,0x73,0x73,0x4C,0x61,0x79,0x6F,0x75,0x74,
	0x00,0x50,0x61,0x63,0x6B,0x69,0x6E,0x67,0x53,0x69,0x7A,0x65,0x00,0x46,0x69,0x65,0x6C,0x64,0x4C,0x61,
	0x79,0x6F,0x75,0x74,0x00,0x43,0x6C,0x61,0x73,0x73,0x53,0x69,0x7A,0x65,0x00,0x23,0x23,0x53,0x79,0x6D,
	0x2E,0x43,0x6C,0x61,0x73,0x73,0x4C,0x61,0x79,0x6F,0x75,0x74,0x5F,0x44,0x65,0x78,0x00,0x53,0x79,0x6D,
	0x2E,0x43,0x6C,0x61,0x73,0x73,0x4C,0x61,0x79,0x6F,0x75,0x74,0x5F,0x44,0x65,0x78,0x00,0x53,0x79,0x6D,
	0x2E,0x46,0x69,0x65,0x6C,0x64,0x4D,0x61,0x72,0x73,0x68,0x61,0x6C,0x00,0x46,0x69,0x65,0x6C,0x64,0x00,
	0x4E,0x61,0x74,0x69,0x76,0x65,0x54,0x79,0x70,0x65,0x00,0x23,0x23,0x53,0x79,0x6D,0x2E,0x46,0x69,0x65,
	0x6C,0x64,0x4D,0x61,0x72,0x73,0x68,0x61,0x6C,0x5F,0x44,0x65,0x78,0x00,0x53,0x79,0x6D,0x2E,0x46,0x69,
	0x65,0x6C,0x64,0x4D,0x61,0x72,0x73,0x68,0x61,0x6C,0x5F,0x44,0x65,0x78,0x00,0x53,0x79,0x6D,0x2E,0x44,
	0x65,0x63,0x6C,0x53,0x65,0x63,0x75,0x72,0x69,0x74,0x79,0x00,0x44,0x65,0x63,0x6C,0x61,0x72,0x61,0x74,
	0x6F,0x72,0x00,0x41,0x63,0x74,0x69,0x6F,0x6E,0x00,0x50,0x65,0x72,0x6D,0x69,0x73,0x73,0x69,0x6F,0x6E,
	0x53,0x65,0x74,0x00,0x53,0x79,0x6D,0x2E,0x53,0x74,0x61,0x6E,0x64,0x41,0x6C,0x6F,0x6E,0x65,0x53,0x69,
	0x67,0x00,0x53,0x69,0x67,0x6E,0x61,0x74,0x75,0x72,0x65,0x00,0x53,0x79,0x6D,0x2E,0x53,0x74,0x61,0x6E,
	0x64,0x41,0x6C,0x6F,0x6E,0x65,0x53,0x69,0x67,0x5F,0x44,0x65,0x78,0x00,0x53,0x79,0x6D,0x2E,0x4D,0x6F,
	0x64,0x75,0x6C,0x65,0x52,0x65,0x66,0x00,0x23,0x23,0x53,0x79,0x6D,0x2E,0x4D,0x6F,0x64,0x75,0x6C,0x65,
	0x52,0x65,0x66,0x5F,0x44,0x65,0x78,0x00,0x53,0x79,0x6D,0x2E,0x41,0x72,0x72,0x61,0x79,0x53,0x70,0x65,
	0x63,0x00,0x53,0x79,0x6D,0x2E,0x41,0x72,0x72,0x61,0x79,0x53,0x70,0x65,0x63,0x5F,0x53,0x69,0x67,0x6E,
	0x61,0x74,0x75,0x72,0x65,0x5F,0x44,0x65,0x78,0x00,0x53,0x79,0x6D,0x2E,0x46,0x69,0x78,0x75,0x70,0x4C,
	0x69,0x73,0x74,0x00,0x43,0x6F,0x75,0x6E,0x74,0x00,0x00,0x00,
};
extern const DECLSPEC_SELECTANY BYTE * g_pbSymSchemaStringHeap = g_rgSymSchemaStringHeap;
extern const DECLSPEC_SELECTANY int g_cbSymSchemaStringHeap = 1552;
extern const BYTE DECLSPEC_SELECTANY g_rgSymSchemaDataRO[] = 
{
	0x19,0x00,0x00,0x00,0x60,0x0C,0x00,0x00,0x6C,0x00,0x00,0x00,0xF0,0x00,0x00,0x00,0xB4,0x01,0x00,0x00,
	0x38,0x02,0x00,0x00,0xCC,0x02,0x00,0x00,0xC0,0x03,0x00,0x00,0x44,0x04,0x00,0x00,0x98,0x04,0x00,0x00,
	0xCC,0x04,0x00,0x00,0x90,0x05,0x00,0x00,0x24,0x06,0x00,0x00,0xA8,0x06,0x00,0x00,0x1C,0x07,0x00,0x00,
	0x80,0x07,0x00,0x00,0xC4,0x07,0x00,0x00,0x38,0x08,0x00,0x00,0x0C,0x09,0x00,0x00,0xB0,0x09,0x00,0x00,
	0x14,0x0A,0x00,0x00,0x88,0x0A,0x00,0x00,0xDC,0x0A,0x00,0x00,0x30,0x0B,0x00,0x00,0x74,0x0B,0x00,0x00,
	0xE8,0x0B,0x00,0x00,0x2C,0x0C,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x01,0x38,0x06,0x00,0x00,0x54,
	0x01,0x00,0xFF,0xFF,0x18,0x00,0x84,0x00,0x0C,0x00,0x00,0x00,0x01,0x08,0x13,0x00,0x00,0x00,0x04,0x00,
	0xFF,0xFF,0xFF,0x43,0x11,0x00,0x00,0x00,0x02,0x04,0x2C,0x01,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x15,0x00,0x00,0x00,0x03,0x00,0x48,0x00,0x08,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x1A,0x00,0x00,0x00,
	0x04,0x00,0x48,0x00,0x0C,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x1F,0x00,0x00,0x00,0x05,0x00,0x82,0x00,
	0x10,0x00,0x04,0x00,0x00,0x04,0xFF,0x43,0x24,0x00,0x00,0x00,0x06,0x00,0x13,0x00,0x04,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0x2B,0x00,0x00,0x00,0x4E,0x08,0x01,0x01,0x11,0x0B,0x14,0x00,0x01,0x02,0x00,0x58,
	0x3C,0x00,0x00,0x00,0x01,0x00,0x01,0x38,0x0A,0x01,0x00,0x54,0x01,0x00,0xFF,0xFF,0x24,0x00,0xC4,0x00,
	0x0C,0x00,0x00,0x00,0x01,0x08,0x13,0x00,0x00,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x11,0x00,0x00,0x00,
	0x02,0x04,0x2C,0x01,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x48,0x00,0x00,0x00,0x03,0x00,0x82,0x00,
	0x14,0x00,0x04,0x00,0x00,0x04,0xFF,0x43,0x1F,0x00,0x00,0x00,0x04,0x00,0x82,0x00,0x18,0x00,0x04,0x00,
	0x00,0x04,0xFF,0x43,0x52,0x00,0x00,0x00,0x05,0x00,0x12,0x00,0x10,0x00,0x02,0x00,0x02,0x00,0xFF,0x43,
	0x58,0x00,0x00,0x00,0x06,0x00,0x2C,0x01,0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x60,0x00,0x00,0x00,
	0x07,0x00,0x12,0x00,0x12,0x00,0x02,0x00,0x02,0x00,0xFF,0x43,0x15,0x00,0x00,0x00,0x08,0x01,0x48,0x00,
	0x1C,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x6C,0x00,0x00,0x00,0x09,0x00,0x13,0x00,0x08,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0x76,0x00,0x00,0x00,0x0A,0x00,0x13,0x00,0x0C,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x80,0x00,0x00,0x00,0x4E,0x08,0x01,0x01,0x11,0x0B,0x20,0x00,0x01,0x02,0x00,0x58,0x92,0x00,0x00,0x00,
	0x02,0x00,0x01,0x3A,0x06,0x04,0x04,0x54,0x01,0x00,0x0C,0x00,0x14,0x00,0x84,0x00,0x0C,0x00,0x00,0x00,
	0x01,0x08,0x13,0x00,0x00,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x11,0x00,0x00,0x00,0x02,0x04,0x2C,0x01,
	0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0xA3,0x00,0x00,0x00,0x03,0x01,0x12,0x00,0x04,0x00,0x02,0x00,
	0x02,0x00,0x00,0x43,0xB1,0x00,0x00,0x00,0x04,0x01,0x12,0x00,0x06,0x00,0x02,0x00,0x02,0x00,0x01,0x43,
	0xC0,0x00,0x00,0x00,0x05,0x01,0x12,0x00,0x08,0x00,0x02,0x00,0x02,0x00,0x02,0x43,0xD1,0x00,0x00,0x00,
	0x06,0x01,0x12,0x00,0x0A,0x00,0x02,0x00,0x02,0x00,0x03,0x43,0xDC,0x00,0x00,0x00,0x4E,0x08,0x01,0x01,
	0x11,0x0B,0x10,0x00,0x01,0x02,0x00,0x58,0xF3,0x00,0x00,0x00,0x03,0x00,0x03,0x3A,0x05,0x00,0x00,0x54,
	0x01,0x00,0xFF,0xFF,0x1A,0x00,0x94,0x00,0x0C,0x00,0x00,0x00,0x01,0x08,0x13,0x00,0x00,0x00,0x04,0x00,
	0xFF,0xFF,0xFF,0x43,0x11,0x00,0x00,0x00,0x02,0x04,0x2C,0x01,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x05,0x01,0x00,0x00,0x03,0x02,0x2C,0x01,0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x0B,0x01,0x00,0x00,
	0x04,0x02,0x2C,0x01,0x08,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x15,0x01,0x00,0x00,0x05,0x00,0x12,0x00,
	0x0C,0x00,0x02,0x00,0x02,0x00,0xFF,0x43,0x1F,0x01,0x00,0x00,0x4E,0x08,0x01,0x01,0x11,0x0B,0x0E,0x00,
	0x01,0x02,0x00,0x58,0x37,0x01,0x00,0x00,0x08,0x10,0x02,0x01,0x11,0x05,0x12,0x00,0x01,0x03,0x00,0x58,
	0x53,0x01,0x00,0x00,0x08,0x10,0x03,0x01,0x11,0x05,0x16,0x00,0x01,0x04,0x00,0x58,0x73,0x01,0x00,0x00,
	0x04,0x00,0x01,0x3A,0x0D,0x09,0x05,0x54,0x01,0x00,0x30,0x00,0x3C,0x00,0xF4,0x00,0x0C,0x00,0x00,0x00,
	0x01,0x08,0x13,0x00,0x00,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x11,0x00,0x00,0x00,0x02,0x04,0x2C,0x01,
	0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x7F,0x01,0x00,0x00,0x03,0x00,0x82,0x00,0x1C,0x00,0x04,0x00,
	0xFF,0xFF,0xFF,0x43,0x83,0x01,0x00,0x00,0x04,0x00,0x12,0x00,0x18,0x00,0x02,0x00,0x02,0x00,0xFF,0x43,
	0x15,0x00,0x00,0x00,0x05,0x01,0x48,0x00,0x20,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x8D,0x01,0x00,0x00,
	0x06,0x01,0x82,0x00,0x24,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x9A,0x01,0x00,0x00,0x07,0x01,0x48,0x00,
	0x28,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x9E,0x01,0x00,0x00,0x08,0x01,0x82,0x00,0x2C,0x00,0x04,0x00,
	0xFF,0xFF,0xFF,0x43,0xA7,0x01,0x00,0x00,0x09,0x01,0x13,0x00,0x04,0x00,0x04,0x00,0x04,0x00,0x00,0x43,
	0x6C,0x00,0x00,0x00,0x0A,0x01,0x13,0x00,0x08,0x00,0x04,0x00,0x04,0x00,0x01,0x43,0x76,0x00,0x00,0x00,
	0x0B,0x01,0x13,0x00,0x0C,0x00,0x04,0x00,0x04,0x00,0x02,0x43,0xAC,0x01,0x00,0x00,0x0C,0x01,0x13,0x00,
	0x10,0x00,0x04,0x00,0x04,0x00,0x03,0x43,0xB7,0x01,0x00,0x00,0x0D,0x01,0x13,0x00,0x14,0x00,0x04,0x00,
	0x04,0x00,0x04,0x43,0xC2,0x01,0x00,0x00,0x4E,0x08,0x01,0x01,0x11,0x0B,0x38,0x00,0x01,0x02,0x00,0x58,
	0xD4,0x01,0x00,0x00,0x05,0x00,0x02,0x3A,0x05,0x00,0x00,0x54,0x01,0x00,0xFF,0xFF,0x18,0x00,0x84,0x00,
	0x0C,0x00,0x00,0x00,0x01,0x08,0x13,0x00,0x00,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x11,0x00,0x00,0x00,
	0x02,0x04,0x2C,0x01,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x1F,0x00,0x00,0x00,0x03,0x00,0x82,0x00,
	0x08,0x00,0x04,0x00,0x00,0x04,0xFF,0x43,0xE4,0x01,0x00,0x00,0x04,0x02,0x2C,0x01,0x04,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0xEB,0x01,0x00,0x00,0x05,0x00,0x80,0x00,0x0C,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,
	0xF1,0x01,0x00,0x00,0x4E,0x08,0x01,0x01,0x11,0x0B,0x10,0x00,0x01,0x02,0x00,0x58,0x07,0x02,0x00,0x00,
	0x08,0x10,0x02,0x01,0x11,0x05,0x14,0x00,0x01,0x04,0x00,0x58,0x1B,0x02,0x00,0x00,0x06,0x00,0x01,0x28,
	0x03,0x00,0x00,0x54,0x00,0x00,0xFF,0xFF,0x10,0x00,0x54,0x00,0x11,0x00,0x00,0x00,0x01,0x04,0x2C,0x01,
	0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x28,0x02,0x00,0x00,0x02,0x00,0x11,0x00,0x04,0x00,0x01,0x00,
	0x01,0x00,0xFF,0x43,0x2D,0x02,0x00,0x00,0x03,0x00,0x80,0x00,0x08,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,
	0x37,0x02,0x00,0x00,0x4E,0x08,0x01,0x01,0x11,0x0B,0x0C,0x00,0x01,0x01,0x00,0x58,0x4A,0x02,0x00,0x00,
	0x07,0x00,0x00,0x30,0x02,0x00,0x00,0x54,0x01,0x00,0xFF,0xFF,0x08,0x00,0x34,0x00,0x0C,0x00,0x00,0x00,
	0x01,0x08,0x13,0x00,0x00,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0xEB,0x01,0x00,0x00,0x02,0x00,0x15,0x00,
	0x00,0x00,0x08,0x00,0x08,0x00,0xFF,0x43,0x54,0x02,0x00,0x00,0x08,0x00,0x02,0x38,0x09,0x00,0x00,0x54,
	0x01,0x00,0xFF,0xFF,0x24,0x00,0xC4,0x00,0x0C,0x00,0x00,0x00,0x01,0x08,0x13,0x00,0x00,0x00,0x04,0x00,
	0xFF,0xFF,0xFF,0x43,0x11,0x00,0x00,0x00,0x02,0x04,0x2C,0x01,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x05,0x01,0x00,0x00,0x03,0x02,0x2C,0x01,0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x1F,0x00,0x00,0x00,
	0x04,0x00,0x82,0x00,0x14,0x00,0x04,0x00,0x00,0x04,0xFF,0x43,0x5F,0x02,0x00,0x00,0x05,0x00,0x80,0x00,
	0x18,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x52,0x00,0x00,0x00,0x06,0x00,0x12,0x00,0x0C,0x00,0x02,0x00,
	0x02,0x00,0xFF,0x43,0x6D,0x02,0x00,0x00,0x07,0x00,0x12,0x00,0x0E,0x00,0x02,0x00,0x02,0x00,0xFF,0x43,
	0x72,0x02,0x00,0x00,0x08,0x00,0x13,0x00,0x08,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x15,0x01,0x00,0x00,
	0x09,0x00,0x12,0x00,0x10,0x00,0x02,0x00,0x02,0x00,0xFF,0x43,0x76,0x02,0x00,0x00,0x4E,0x08,0x01,0x01,
	0x11,0x0B,0x1C,0x00,0x01,0x02,0x00,0x58,0x87,0x02,0x00,0x00,0x08,0x10,0x02,0x01,0x11,0x05,0x20,0x00,
	0x01,0x03,0x00,0x58,0x96,0x02,0x00,0x00,0x09,0x00,0x02,0x38,0x06,0x00,0x00,0x54,0x01,0x00,0xFF,0xFF,
	0x1C,0x00,0x94,0x00,0x0C,0x00,0x00,0x00,0x01,0x08,0x13,0x00,0x00,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,
	0x11,0x00,0x00,0x00,0x02,0x04,0x2C,0x01,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x05,0x01,0x00,0x00,
	0x03,0x02,0x2C,0x01,0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x1F,0x00,0x00,0x00,0x04,0x00,0x82,0x00,
	0x0C,0x00,0x04,0x00,0x00,0x04,0xFF,0x43,0x5F,0x02,0x00,0x00,0x05,0x00,0x80,0x00,0x10,0x00,0x04,0x00,
	0xFF,0xFF,0xFF,0x43,0x52,0x00,0x00,0x00,0x06,0x00,0x12,0x00,0x08,0x00,0x02,0x00,0x02,0x00,0xFF,0x43,
	0xA0,0x02,0x00,0x00,0x4E,0x08,0x01,0x01,0x11,0x0B,0x14,0x00,0x01,0x02,0x00,0x58,0xB0,0x02,0x00,0x00,
	0x08,0x10,0x02,0x01,0x11,0x05,0x18,0x00,0x01,0x03,0x00,0x58,0xBE,0x02,0x00,0x00,0x0A,0x00,0x01,0x30,
	0x06,0x00,0x00,0x54,0x01,0x00,0xFF,0xFF,0x14,0x00,0x84,0x00,0x0C,0x00,0x00,0x00,0x01,0x08,0x13,0x00,
	0x00,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x11,0x00,0x00,0x00,0x02,0x00,0x2C,0x01,0x00,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0xC8,0x02,0x00,0x00,0x03,0x02,0x2C,0x01,0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x1F,0x00,0x00,0x00,0x04,0x00,0x82,0x00,0x0C,0x00,0x04,0x00,0x00,0x04,0xFF,0x43,0xCF,0x02,0x00,0x00,
	0x05,0x00,0x12,0x00,0x08,0x00,0x02,0x00,0x02,0x00,0xFF,0x43,0x52,0x00,0x00,0x00,0x06,0x00,0x12,0x00,
	0x0A,0x00,0x02,0x00,0x02,0x00,0xFF,0x43,0xD8,0x02,0x00,0x00,0x08,0x10,0x01,0x01,0x11,0x05,0x10,0x00,
	0x01,0x03,0x00,0x58,0xE6,0x02,0x00,0x00,0x0B,0x00,0x01,0x38,0x05,0x00,0x00,0x54,0x01,0x00,0xFF,0xFF,
	0x14,0x00,0x74,0x00,0x0C,0x00,0x00,0x00,0x01,0x08,0x13,0x00,0x00,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,
	0x11,0x00,0x00,0x00,0x02,0x04,0x2C,0x01,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x1F,0x00,0x00,0x00,
	0x03,0x00,0x82,0x00,0x08,0x00,0x04,0x00,0x00,0x04,0xFF,0x43,0x5F,0x02,0x00,0x00,0x04,0x00,0x80,0x00,
	0x0C,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x05,0x01,0x00,0x00,0x05,0x00,0x2C,0x01,0x04,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0xF4,0x02,0x00,0x00,0x4E,0x08,0x01,0x01,0x11,0x0B,0x10,0x00,0x01,0x02,0x00,0x58,
	0x08,0x03,0x00,0x00,0x0C,0x00,0x00,0x30,0x05,0x00,0x00,0x54,0x01,0x00,0xFF,0xFF,0x0E,0x00,0x64,0x00,
	0x0C,0x00,0x00,0x00,0x01,0x08,0x13,0x00,0x00,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x05,0x01,0x00,0x00,
	0x02,0x00,0x2C,0x01,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x17,0x03,0x00,0x00,0x03,0x00,0x2C,0x01,
	0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x72,0x02,0x00,0x00,0x04,0x00,0x13,0x00,0x08,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0x15,0x01,0x00,0x00,0x05,0x00,0x12,0x00,0x0C,0x00,0x02,0x00,0x02,0x00,0xFF,0x43,
	0x1E,0x03,0x00,0x00,0x0D,0x00,0x00,0x30,0x03,0x00,0x00,0x54,0x01,0x00,0xFF,0xFF,0x08,0x00,0x44,0x00,
	0x0C,0x00,0x00,0x00,0x01,0x08,0x13,0x00,0x00,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x1F,0x00,0x00,0x00,
	0x02,0x00,0x82,0x00,0x04,0x00,0x04,0x00,0xFF,0x00,0xFF,0x43,0x11,0x00,0x00,0x00,0x03,0x00,0x2C,0x01,
	0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x2F,0x03,0x00,0x00,0x0E,0x00,0x02,0x38,0x04,0x00,0x00,0x54,
	0x01,0x00,0xFF,0xFF,0x14,0x00,0x74,0x00,0x3D,0x03,0x00,0x00,0x01,0x08,0x13,0x00,0x00,0x00,0x04,0x00,
	0xFF,0xFF,0xFF,0x43,0x11,0x00,0x00,0x00,0x02,0x04,0x2C,0x01,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
	0x17,0x03,0x00,0x00,0x03,0x02,0x2C,0x01,0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x05,0x01,0x00,0x00,
	0x04,0x00,0x2C,0x01,0x08,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x41,0x03,0x00,0x00,0x4E,0x08,0x01,0x01,
	0x11,0x0B,0x0C,0x00,0x01,0x02,0x00,0x58,0x55,0x03,0x00,0x00,0x08,0x10,0x02,0x01,0x11,0x05,0x10,0x00,
	0x01,0x03,0x00,0x58,0x6E,0x03,0x00,0x00,0x0F,0x00,0x03,0x38,0x09,0x00,0x00,0x54,0x01,0x00,0xFF,0xFF,
	0x2C,0x00,0xD4,0x00,0x3D,0x03,0x00,0x00,0x01,0x08,0x13,0x00,0x00,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,
	0x11,0x00,0x00,0x00,0x02,0x04,0x2C,0x01,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0xE4,0x01,0x00,0x00,
	0x03,0x02,0x2C,0x01,0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x1F,0x00,0x00,0x00,0x04,0x02,0x82,0x00,
	0x18,0x00,0x04,0x00,0xFF,0x00,0xFF,0x43,0x28,0x02,0x00,0x00,0x05,0x00,0x80,0x00,0x1C,0x00,0x04,0x00,
	0xFF,0xFF,0xFF,0x43,0x7B,0x03,0x00,0x00,0x06,0x00,0x12,0x00,0x14,0x00,0x02,0x00,0x02,0x00,0xFF,0x43,
	0x85,0x03,0x00,0x00,0x07,0x00,0x2C,0x01,0x08,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x92,0x03,0x00,0x00,
	0x08,0x00,0x2C,0x01,0x0C,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0xA0,0x03,0x00,0x00,0x09,0x00,0x2C,0x01,
	0x10,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0xAD,0x03,0x00,0x00,0x4E,0x08,0x01,0x01,0x11,0x0B,0x20,0x00,
	0x01,0x02,0x00,0x58,0xC0,0x03,0x00,0x00,0x08,0x10,0x02,0x01,0x11,0x05,0x24,0x00,0x01,0x04,0x00,0x58,
	0xD6,0x03,0x00,0x00,0x08,0x10,0x03,0x01,0x11,0x05,0x28,0x00,0x01,0x03,0x00,0x58,0xEE,0x03,0x00,0x00,
	0x10,0x00,0x03,0x38,0x06,0x00,0x00,0x54,0x01,0x00,0xFF,0xFF,0x20,0x00,0xA4,0x00,0x3D,0x03,0x00,0x00,
	0x01,0x08,0x13,0x00,0x00,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x11,0x00,0x00,0x00,0x02,0x04,0x2C,0x01,
	0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0xE4,0x01,0x00,0x00,0x03,0x02,0x2C,0x01,0x04,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0x1F,0x00,0x00,0x00,0x04,0x02,0x82,0x00,0x10,0x00,0x04,0x00,0xFF,0x00,0xFF,0x43,
	0xF8,0x03,0x00,0x00,0x05,0x00,0x2C,0x01,0x08,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x02,0x04,0x00,0x00,
	0x06,0x00,0x12,0x00,0x0C,0x00,0x02,0x00,0x02,0x00,0xFF,0x43,0x0D,0x04,0x00,0x00,0x4E,0x08,0x01,0x01,
	0x11,0x0B,0x14,0x00,0x01,0x02,0x00,0x58,0x1D,0x04,0x00,0x00,0x08,0x10,0x02,0x01,0x11,0x05,0x18,0x00,
	0x01,0x04,0x00,0x58,0x30,0x04,0x00,0x00,0x08,0x10,0x03,0x01,0x11,0x05,0x1C,0x00,0x01,0x03,0x00,0x58,
	0x45,0x04,0x00,0x00,0x11,0x00,0x02,0x20,0x03,0x00,0x00,0x54,0x00,0x00,0xFF,0xFF,0x12,0x00,0x64,0x00,
	0x17,0x03,0x00,0x00,0x01,0x02,0x2C,0x01,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x59,0x04,0x00,0x00,
	0x02,0x02,0x2C,0x01,0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x65,0x04,0x00,0x00,0x03,0x00,0x12,0x00,
	0x08,0x00,0x02,0x00,0x02,0x00,0xFF,0x43,0x6E,0x04,0x00,0x00,0x08,0x10,0x01,0x01,0x11,0x05,0x0A,0x00,
	0x01,0x02,0x00,0x58,0x82,0x04,0x00,0x00,0x08,0x10,0x02,0x01,0x11,0x05,0x0E,0x00,0x01,0x01,0x00,0x58,
	0xA1,0x04,0x00,0x00,0x12,0x00,0x02,0x28,0x04,0x00,0x00,0x54,0x00,0x00,0xFF,0xFF,0x18,0x00,0x74,0x00,
	0x05,0x01,0x00,0x00,0x01,0x06,0x2C,0x01,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0xB1,0x04,0x00,0x00,
	0x02,0x00,0x12,0x00,0x08,0x00,0x02,0x00,0x02,0x00,0xFF,0x43,0xBD,0x04,0x00,0x00,0x03,0x00,0x80,0x00,
	0x0C,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0xC9,0x04,0x00,0x00,0x04,0x00,0x13,0x00,0x04,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0xD3,0x04,0x00,0x00,0x4E,0x08,0x01,0x01,0x11,0x0B,0x10,0x00,0x01,0x01,0x00,0x58,
	0xE9,0x04,0x00,0x00,0x08,0x10,0x02,0x01,0x11,0x05,0x14,0x00,0x01,0x01,0x00,0x58,0xFD,0x04,0x00,0x00,
	0x13,0x00,0x02,0x28,0x02,0x00,0x00,0x54,0x00,0x00,0xFF,0xFF,0x10,0x00,0x54,0x00,0x0E,0x05,0x00,0x00,
	0x01,0x06,0x2C,0x01,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x14,0x05,0x00,0x00,0x02,0x00,0x80,0x00,
	0x04,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x1F,0x05,0x00,0x00,0x4E,0x08,0x01,0x01,0x11,0x0B,0x08,0x00,
	0x01,0x01,0x00,0x58,0x36,0x05,0x00,0x00,0x08,0x10,0x02,0x01,0x11,0x05,0x0C,0x00,0x01,0x01,0x00,0x58,
	0x4B,0x05,0x00,0x00,0x14,0x00,0x00,0x30,0x04,0x00,0x00,0x54,0x01,0x00,0xFF,0xFF,0x0C,0x00,0x54,0x00,
	0x3D,0x03,0x00,0x00,0x01,0x08,0x13,0x00,0x00,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x5C,0x05,0x00,0x00,
	0x02,0x00,0x2C,0x01,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x67,0x05,0x00,0x00,0x03,0x00,0x12,0x00,
	0x04,0x00,0x02,0x00,0x02,0x00,0xFF,0x43,0x6E,0x05,0x00,0x00,0x04,0x00,0x80,0x00,0x08,0x00,0x04,0x00,
	0xFF,0xFF,0xFF,0x43,0x7C,0x05,0x00,0x00,0x15,0x00,0x01,0x30,0x02,0x00,0x00,0x54,0x01,0x00,0xFF,0xFF,
	0x08,0x00,0x44,0x00,0x3D,0x03,0x00,0x00,0x01,0x08,0x13,0x00,0x00,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,
	0x8E,0x05,0x00,0x00,0x02,0x02,0x80,0x00,0x00,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x98,0x05,0x00,0x00,
	0x48,0x10,0x01,0x01,0x11,0x05,0x04,0x00,0x01,0x02,0x00,0x58,0xAE,0x05,0x00,0x00,0x16,0x00,0x01,0x38,
	0x05,0x02,0x00,0x54,0x01,0x00,0xFF,0xFF,0x14,0x00,0x74,0x00,0x0C,0x00,0x00,0x00,0x01,0x08,0x13,0x00,
	0x00,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x11,0x00,0x00,0x00,0x02,0x04,0x2C,0x01,0x00,0x00,0x04,0x00,
	0x04,0x00,0xFF,0x43,0x15,0x00,0x00,0x00,0x03,0x01,0x48,0x00,0x04,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,
	0x1A,0x00,0x00,0x00,0x04,0x01,0x48,0x00,0x08,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,0x1F,0x00,0x00,0x00,
	0x05,0x00,0x82,0x00,0x0C,0x00,0x04,0x00,0x00,0x04,0xFF,0x43,0xBC,0x05,0x00,0x00,0x4E,0x08,0x01,0x01,
	0x11,0x0B,0x10,0x00,0x01,0x02,0x00,0x58,0xD0,0x05,0x00,0x00,0x17,0x00,0x01,0x30,0x02,0x00,0x00,0x54,
	0x01,0x00,0xFF,0xFF,0x08,0x00,0x44,0x00,0x3D,0x03,0x00,0x00,0x01,0x08,0x13,0x00,0x00,0x00,0x04,0x00,
	0xFF,0xFF,0xFF,0x43,0x8E,0x05,0x00,0x00,0x02,0x02,0x80,0x00,0x00,0x00,0x04,0x00,0xFF,0xFF,0xFF,0x43,
	0xDE,0x05,0x00,0x00,0x48,0x10,0x01,0x01,0x11,0x05,0x04,0x00,0x01,0x02,0x00,0x58,0xFA,0x05,0x00,0x00,
	0x18,0x00,0x00,0x20,0x02,0x00,0x00,0x54,0x00,0x00,0xFF,0xFF,0x08,0x00,0x34,0x00,0x72,0x02,0x00,0x00,
	0x01,0x00,0x13,0x00,0x00,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,0x08,0x06,0x00,0x00,0x02,0x00,0x13,0x00,
	0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0x43,
};
extern const DECLSPEC_SELECTANY int g_cbSymSchemaRO = 3168;
extern const COMPLIBSCHEMABLOB DECLSPEC_SELECTANY SymSchemaBlob = 
{
	&SymSchema,
	Sym_TABLE_COUNT,
	0,
	g_rgSymSchemaDataRW,
	g_cbSymSchemaRW,
	g_rgSymSchemaDataRO,
	g_cbSymSchemaRO,
	g_rgSymSchemaStringHeap,
	g_cbSymSchemaStringHeap
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\threadpool.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// Threadpool.h
//
// Class factories are used by the pluming in COM to activate new objects.  
// This module contains the class factory code to instantiate the debugger
// objects described in <cordb.h>.
//
//*****************************************************************************
#ifndef __Threadpool__h__
#define __Threadpool__h__

#define WAIT_SINGLE_EXECUTION      0x00000001
#define WAIT_FREE_CONTEXT          0x00000002

#define QUEUE_ONLY                 0x00000000  // do not attempt to call on the thread
#define CALL_OR_QUEUE              0x00000001  // call on the same thread if not too busy, else queue

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\sxstypes.h ===
/*++ BUILD Version: 0005    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    sxstypes.h

Abstract:

    Include file with definitions for data structures used for side-by-side
    binding.

Author:

    Michael Grier (MGrier) 28-Mar-2000

Environment:


Revision History:

--*/

#ifndef _SXSTYPES_
#define _SXSTYPES_

#if (_MSC_VER > 1020)
#pragma once
#endif

#if defined(__cplusplus)
extern "C" {
#endif

typedef struct _ACTIVATION_CONTEXT_DATA ACTIVATION_CONTEXT_DATA;
typedef const ACTIVATION_CONTEXT_DATA *PCACTIVATION_CONTEXT_DATA;

// This string is the magic string located in the registry which determines that a key is actually
// a version.
// 
// For example:
//
// HCR/clsid/xxxx-xx-xx-xx/InprocServer32/1.0.3705.0
//									    /1.0.3705.125
//
// If this SBSVERSIONVALUE is set as a ValueName in these
// version keys, then we're saying that there is an implementation of the object
// for that version of the runtime.
//
// i.e., if 1.0.3705.0 has the value name of SBSVERSIONVALUE, then 1.0.3705.0 implements
// this class id.
#define SBSVERSIONVALUE	L"ImplementedInThisVersion"

//
// These data structures have to line up in a number of different run-time
// environments, so we explicitly set the alignment.
//
#include "pshpack4.h"
//
// These data structures may be generated by 64bit code and consumed
// in 32bit code, as in the case of 32bit processes on Win64.
// Therefore they have no pointers and no SIZE_Ts.
//
// Besides that, they are created in a different process than they
// are consumed. They are position independent.
//

//
//  ASSEMBLY_VERSION represents a traditional four-part version
//  as in Major.Minor.Revision.Build.
//
//  They are laid out so that you can perform a simple ULONGLONG-
//  based comparison on them.
//
//  They are interpreted as:
//
//      Major.Minor.Build.Revision
//
//  So for example you might have "5.1.2505.2" (where 5.1 is the major
//  minor, 2505 represents the daily build number and 2 is the number
//  of updates to the build since its initial build).
//
//  Overloaded comparison operators are provided at the end of this file
//  for C++ clients (outside the extern "C" { } block).
//

#include "pshpack1.h"

typedef union _ASSEMBLY_VERSION {
    struct {
        USHORT Build;
        USHORT Revision;
        USHORT Minor;
        USHORT Major;
    };
    ULONGLONG QuadPart;
} ASSEMBLY_VERSION, *PASSEMBLY_VERSION;

#include "poppack.h"

typedef const ASSEMBLY_VERSION *PCASSEMBLY_VERSION;

//
//  Standard Activation Context section IDs:
//

// begin_winnt
#define ACTIVATION_CONTEXT_SECTION_ASSEMBLY_INFORMATION         (1)
#define ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION              (2)
#define ACTIVATION_CONTEXT_SECTION_WINDOW_CLASS_REDIRECTION     (3)
#define ACTIVATION_CONTEXT_SECTION_COM_SERVER_REDIRECTION       (4)
#define ACTIVATION_CONTEXT_SECTION_COM_INTERFACE_REDIRECTION    (5)
#define ACTIVATION_CONTEXT_SECTION_COM_TYPE_LIBRARY_REDIRECTION (6)
#define ACTIVATION_CONTEXT_SECTION_COM_PROGID_REDIRECTION       (7)
#define ACTIVATION_CONTEXT_SECTION_GLOBAL_OBJECT_RENAME_TABLE   (8)
// end_winnt

//
//  Activation Context section format identifiers:
//

#define ACTIVATION_CONTEXT_SECTION_FORMAT_UNKNOWN               (0)
#define ACTIVATION_CONTEXT_SECTION_FORMAT_STRING_TABLE          (1)
#define ACTIVATION_CONTEXT_SECTION_FORMAT_GUID_TABLE            (2)

typedef struct _ACTIVATION_CONTEXT_DATA {
    ULONG Magic;
    ULONG HeaderSize;
    ULONG FormatVersion;
    ULONG TotalSize;
    ULONG DefaultTocOffset;
    ULONG ExtendedTocOffset;
    ULONG AssemblyRosterOffset;
    ULONG Flags;
} ACTIVATION_CONTEXT_DATA, *PACTIVATION_CONTEXT_DATA;
typedef const ACTIVATION_CONTEXT_DATA *PCACTIVATION_CONTEXT_DATA;

#define ACTIVATION_CONTEXT_DATA_MAGIC ((ULONG) 'xtcA')
#define ACTIVATION_CONTEXT_DATA_FORMAT_WHISTLER (1)

// Internally this is associated with the data, but externally
// the data is usually opaque and it is associated with the activation context.
#define ACTIVATION_CONTEXT_FLAG_NO_INHERIT (0x00000001)

typedef struct _ACTIVATION_CONTEXT_DATA_TOC_HEADER {
    ULONG HeaderSize;
    ULONG EntryCount;
    ULONG FirstEntryOffset;
    ULONG Flags;
} ACTIVATION_CONTEXT_DATA_TOC_HEADER, *PACTIVATION_CONTEXT_DATA_TOC_HEADER;
typedef const struct _ACTIVATION_CONTEXT_DATA_TOC_HEADER *PCACTIVATION_CONTEXT_DATA_TOC_HEADER;

#define ACTIVATION_CONTEXT_DATA_TOC_HEADER_DENSE (0x00000001)
#define ACTIVATION_CONTEXT_DATA_TOC_HEADER_INORDER (0x00000002)

typedef struct _ACTIVATION_CONTEXT_DATA_TOC_ENTRY {
    ULONG Id;
    ULONG Offset;            // from ACTIVATION_CONTEXT_DATA base
    ULONG Length;           // in bytes
    ULONG Format;           // ACTIVATION_CONTEXT_SECTION_FORMAT_*
} ACTIVATION_CONTEXT_DATA_TOC_ENTRY, *PACTIVATION_CONTEXT_DATA_TOC_ENTRY;
typedef const struct _ACTIVATION_CONTEXT_DATA_TOC_ENTRY *PCACTIVATION_CONTEXT_DATA_TOC_ENTRY;

typedef struct _ACTIVATION_CONTEXT_DATA_EXTENDED_TOC_HEADER {
    ULONG HeaderSize;
    ULONG EntryCount;
    ULONG FirstEntryOffset;     // from ACTIVATION_CONTEXT_DATA base
    ULONG Flags;
} ACTIVATION_CONTEXT_DATA_EXTENDED_TOC_HEADER, *PACTIVATION_CONTEXT_DATA_EXTENDED_TOC_HEADER;
typedef const struct _ACTIVATION_CONTEXT_DATA_EXTENDED_TOC_HEADER *PCACTIVATION_CONTEXT_DATA_EXTENDED_TOC_HEADER;

typedef struct _ACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY {
    GUID ExtensionGuid;
    ULONG TocOffset;            // from ACTIVATION_CONTEXT_DATA base
    ULONG Length;
} ACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY, *PACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY;
typedef const struct _ACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY *PCACTIVATION_CONTEXT_DATA_EXTENDED_TOC_ENTRY;

typedef struct _ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER {
    ULONG HeaderSize;
    ULONG HashAlgorithm;
    ULONG EntryCount;               // Entry 0 is reserved; this is the number of assemblies plus 1.
    ULONG FirstEntryOffset;         // From ACTIVATION_CONTEXT_DATA base
    ULONG AssemblyInformationSectionOffset; // Offset from the ACTIVATION_CONTEXT_DATA base to the
                                    // header of the assembly information string section.  Needed because
                                    // the roster entries contain the offsets from the ACTIVATION_CONTEXT_DATA
                                    // to the assembly information structs, but those structs contain offsets
                                    // from their section base to the strings etc.
} ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER, *PACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER;
typedef const struct _ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER *PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_HEADER;

#define ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY_INVALID (0x00000001)
#define ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY_ROOT    (0x00000002)

typedef struct _ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY {
    ULONG Flags;
    ULONG PseudoKey;                // case-insentively-hashed assembly name
    ULONG AssemblyNameOffset;       // from ACTIVATION_CONTEXT_DATA base
    ULONG AssemblyNameLength;       // length in bytes
    ULONG AssemblyInformationOffset; // from ACTIVATION_CONTEXT_DATA base to ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION
    ULONG AssemblyInformationLength; // length in bytes
} ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY, *PACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY;
typedef const struct _ACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY *PCACTIVATION_CONTEXT_DATA_ASSEMBLY_ROSTER_ENTRY;

//
//  ActivationContext string sections are organized as follows:
//
//  Header
//  Hash structure (optional)
//  List of subelements
//  Variable length data
//
//
//  If you don't recognize the FormatVersion, you should still
//  be able to navigate to the list of subelements; once there
//  you can still do a very fast linear search avoiding many
//  string comparisons if the hash algorithms align.
//
//  If you can't even use the hash algorithm, you can still do
//  string comparisons.
//

typedef struct _ACTIVATION_CONTEXT_STRING_SECTION_HEADER {
    ULONG Magic;
    ULONG HeaderSize;               // in bytes
    ULONG FormatVersion;
    ULONG DataFormatVersion;
    ULONG Flags;
    ULONG ElementCount;
    ULONG ElementListOffset;        // offset from section header
    ULONG HashAlgorithm;
    ULONG SearchStructureOffset;    // offset from section header
    ULONG UserDataOffset;           // offset from section header
    ULONG UserDataSize;             // in bytes
} ACTIVATION_CONTEXT_STRING_SECTION_HEADER, *PACTIVATION_CONTEXT_STRING_SECTION_HEADER;

typedef const ACTIVATION_CONTEXT_STRING_SECTION_HEADER *PCACTIVATION_CONTEXT_STRING_SECTION_HEADER;

#define ACTIVATION_CONTEXT_STRING_SECTION_MAGIC ((ULONG) 'dHsS')

#define ACTIVATION_CONTEXT_STRING_SECTION_FORMAT_WHISTLER (1)

#define ACTIVATION_CONTEXT_STRING_SECTION_CASE_INSENSITIVE              (0x00000001)
#define ACTIVATION_CONTEXT_STRING_SECTION_ENTRIES_IN_PSEUDOKEY_ORDER    (0x00000002)

typedef struct _ACTIVATION_CONTEXT_STRING_SECTION_HASH_TABLE {
    ULONG BucketTableEntryCount;
    ULONG BucketTableOffset;        // offset from section header
} ACTIVATION_CONTEXT_STRING_SECTION_HASH_TABLE, *PACTIVATION_CONTEXT_STRING_SECTION_HASH_TABLE;

typedef const ACTIVATION_CONTEXT_STRING_SECTION_HASH_TABLE *PCACTIVATION_CONTEXT_STRING_SECTION_HASH_TABLE;

typedef struct _ACTIVATION_CONTEXT_STRING_SECTION_HASH_BUCKET {
    ULONG ChainCount;
    ULONG ChainOffset;              // offset from section header
} ACTIVATION_CONTEXT_STRING_SECTION_HASH_BUCKET, *PACTIVATION_CONTEXT_STRING_SECTION_HASH_BUCKET;

typedef const ACTIVATION_CONTEXT_STRING_SECTION_HASH_BUCKET *PCACTIVATION_CONTEXT_STRING_SECTION_HASH_BUCKET;

// The hash table bucket chain is then a list of offsets from the section header to
// the section entries for the chain.

typedef struct _ACTIVATION_CONTEXT_STRING_SECTION_ENTRY {
    ULONG PseudoKey;
    ULONG KeyOffset;            // offset from the section header
    ULONG KeyLength;            // in bytes
    ULONG Offset;               // offset from the section header
    ULONG Length;               // in bytes
    ULONG AssemblyRosterIndex;  // 1-based index into the assembly roster for the assembly that
                                // provided this entry.  If the entry is not associated with
                                // an assembly, zero.
} ACTIVATION_CONTEXT_STRING_SECTION_ENTRY, *PACTIVATION_CONTEXT_STRING_SECTION_ENTRY;

typedef const ACTIVATION_CONTEXT_STRING_SECTION_ENTRY *PCACTIVATION_CONTEXT_STRING_SECTION_ENTRY;

//
//  ActivationContext GUID sections are organized as follows:
//
//  Header
//  Hash structure (optional)
//  List of subelements
//  Variable length data
//
//  If you don't recognize the FormatVersion, you should still
//  be able to navigate to the list of subelements; once there
//  you can still do a very fast linear search avoiding many
//  GUID comparisons.
//

typedef struct _ACTIVATION_CONTEXT_GUID_SECTION_HEADER {
    ULONG Magic;
    ULONG HeaderSize;
    ULONG FormatVersion;
    ULONG DataFormatVersion;
    ULONG Flags;
    ULONG ElementCount;
    ULONG ElementListOffset;        // offset from section header
    ULONG SearchStructureOffset;    // offset from section header
    ULONG UserDataOffset;           // offset from section header
    ULONG UserDataSize;             // in bytes
} ACTIVATION_CONTEXT_GUID_SECTION_HEADER, *PACTIVATION_CONTEXT_GUID_SECTION_HEADER;

typedef const ACTIVATION_CONTEXT_GUID_SECTION_HEADER *PCACTIVATION_CONTEXT_GUID_SECTION_HEADER;

#define ACTIVATION_CONTEXT_GUID_SECTION_MAGIC ((ULONG) 'dHsG')

#define ACTIVATION_CONTEXT_GUID_SECTION_FORMAT_WHISTLER (1)

#define ACTIVATION_CONTEXT_GUID_SECTION_ENTRIES_IN_ORDER    (0x00000001)

typedef struct _ACTIVATION_CONTEXT_GUID_SECTION_HASH_TABLE {
    ULONG BucketTableEntryCount;
    ULONG BucketTableOffset;        // offset from section header
} ACTIVATION_CONTEXT_GUID_SECTION_HASH_TABLE, *PACTIVATION_CONTEXT_GUID_SECTION_HASH_TABLE;

typedef const ACTIVATION_CONTEXT_GUID_SECTION_HASH_TABLE *PCACTIVATION_CONTEXT_GUID_SECTION_HASH_TABLE;

typedef struct _ACTIVATION_CONTEXT_GUID_SECTION_HASH_BUCKET {
    ULONG ChainCount;
    ULONG ChainOffset;              // offset from section header
} ACTIVATION_CONTEXT_GUID_SECTION_HASH_BUCKET, *PACTIVATION_CONTEXT_GUID_SECTION_HASH_BUCKET;

typedef const ACTIVATION_CONTEXT_GUID_SECTION_HASH_BUCKET *PCACTIVATION_CONTEXT_GUID_SECTION_HASH_BUCKET;

// The hash table bucket chain is then a list of offsets from the section header to
// the section entries for the chain.

typedef struct _ACTIVATION_CONTEXT_GUID_SECTION_ENTRY {
    GUID Guid;
    ULONG Offset;               // offset from the section header
    ULONG Length;               // in bytes
    ULONG AssemblyRosterIndex;  // 1-based index into the assembly roster for the assembly that
                                // provided this entry.  If the entry is not associated with
                                // an assembly, zero.
} ACTIVATION_CONTEXT_GUID_SECTION_ENTRY, *PACTIVATION_CONTEXT_GUID_SECTION_ENTRY;

typedef const ACTIVATION_CONTEXT_GUID_SECTION_ENTRY *PCACTIVATION_CONTEXT_GUID_SECTION_ENTRY;

//
//  Data structures for the assembly information section (NULL Extension GUID, ACTIVATION_CONTEXT_SECTION_ASSEMBLY_INFORMATION)
//

typedef struct _ACTIVATION_CONTEXT_DATA_ASSEMBLY_GLOBAL_INFORMATION {
    ULONG Size;
    ULONG Flags;
    GUID PolicyCoherencyGuid;
    GUID PolicyOverrideGuid;
    ULONG ApplicationDirectoryPathType;
    ULONG ApplicationDirectoryLength;
    ULONG ApplicationDirectoryOffset; // Offset from base of ACTIVATION_CONTEXT_DATA_ASSEMBLY_GLOBAL_INFORMATION
} ACTIVATION_CONTEXT_DATA_ASSEMBLY_GLOBAL_INFORMATION, *PACTIVATION_CONTEXT_DATA_ASSEMBLY_GLOBAL_INFORMATION;
typedef const ACTIVATION_CONTEXT_DATA_ASSEMBLY_GLOBAL_INFORMATION *PCACTIVATION_CONTEXT_DATA_ASSEMBLY_GLOBAL_INFORMATION;

//
//  Leaf node structure for the assembly information section
//

#define ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION_FORMAT_WHISTLER (1)

//
//  Bitflags for the Flags member of an assembly information section element.
//

#define ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION_ROOT_ASSEMBLY              (0x00000001)
#define ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION_POLICY_APPLIED             (0x00000002)
#define ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION_ASSEMBLY_POLICY_APPLIED    (0x00000004)
#define ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION_ROOT_POLICY_APPLIED        (0x00000008)
#define ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION_PRIVATE_ASSEMBLY            (0x00000010)

// ACTIVATION_CONTEXT_PATH_TYPE_NONE is used when
// a manifest has no stored location or identity, such as when a manifest is found
// in the app compat database.  The client is free to specify a manifest path
// string which should assist in diagnosing where the manifest came from, but
// cannot be assumed to have any particular format or syntax.

typedef struct _ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION {
    ULONG Size;                                    // size of this structure, in bytes
    ULONG Flags;
    ULONG EncodedAssemblyIdentityLength;        // in bytes
    ULONG EncodedAssemblyIdentityOffset;        // offset from section header base

    ULONG ManifestPathType;
    ULONG ManifestPathLength;                    // in bytes
    ULONG ManifestPathOffset;                    // offset from section header base
    LARGE_INTEGER ManifestLastWriteTime;
    ULONG PolicyPathType;
    ULONG PolicyPathLength;         // in bytes
    ULONG PolicyPathOffset;         // offset from section header base
    LARGE_INTEGER PolicyLastWriteTime;
    ULONG MetadataSatelliteRosterIndex;
    ULONG Unused2;
    ULONG ManifestVersionMajor;
    ULONG ManifestVersionMinor;
    ULONG PolicyVersionMajor;
    ULONG PolicyVersionMinor;
    ULONG AssemblyDirectoryNameLength; // in bytes
    ULONG AssemblyDirectoryNameOffset; // from section header base
    ULONG NumOfFilesInAssembly;
} ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION, *PACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION;

typedef const ACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION *PCACTIVATION_CONTEXT_DATA_ASSEMBLY_INFORMATION;

//
//  Leaf node structure for the dll redirection section (NULL Extension GUID, ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION)
//

#define ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_FORMAT_WHISTLER (1)

//
//  ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION Flags:
//
//      ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_INCLUDES_BASE_NAME
//
//          Provides for a redirection that remaps not just the path but the actual
//          base name of the file to access.
//
//          Not used in any current Whistler scenarios.
//
//      ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_OMITS_ASSEMBLY_ROOT
//
//          Provides for a redirection where the actual storage path of the file
//          must be determined at runtime by via the assembly roster.  This allows
//          for a cached activation context to remain valid across when an assembly
//          is relocated across storage volumes.
//
//      ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_EXPAND
//
//          The path must be constructed by appending all the segments and then
//          the resultant string must be passed through either the
//          RtlExpandEnvironmentStrings() or the Win32 ExpandEnvironmentStrings() APIs.
//
//          Used generally only for app compat where a manifest for the executable
//          may call out a file which the application may erroneously carry with it
//          (possibly on read-only media) to be redirected to, for example,
//          "%windir%\system32\"
//
//  Note!
//
//      You may not have a single entry with both the
//      ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_OMITS_ASSEMBLY_ROOT and
//      ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_EXPAND flags set.
//

#define ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_INCLUDES_BASE_NAME     (0x00000001)
#define ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_OMITS_ASSEMBLY_ROOT    (0x00000002)
#define ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_EXPAND                 (0x00000004)

typedef struct _ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION {
    ULONG Size;
    ULONG Flags;
    ULONG TotalPathLength; // bytewise length of concatenated segments only
    ULONG PathSegmentCount;
    ULONG PathSegmentOffset; // offset from section base header so that entries can share
} ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION, *PACTIVATION_CONTEXT_DATA_DLL_REDIRECTION;

typedef const ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION *PCACTIVATION_CONTEXT_DATA_DLL_REDIRECTION;

typedef struct _ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_SEGMENT {
    ULONG Length; // in bytes
    ULONG Offset; // from section header so that individual entries can share
} ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_SEGMENT, *PACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_SEGMENT;

typedef const ACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_SEGMENT *PCACTIVATION_CONTEXT_DATA_DLL_REDIRECTION_PATH_SEGMENT;

//
//  Leaf node structures for window class redirection section (NULL Extension GUID, ACTIVATION_CONTEXT_SECTION_WINDOW_CLASS_REDIRECTION)
//

#define ACTIVATION_CONTEXT_DATA_WINDOW_CLASS_REDIRECTION_FORMAT_WHISTLER (1)

typedef struct _ACTIVATION_CONTEXT_DATA_WINDOW_CLASS_REDIRECTION {
    ULONG Size;
    ULONG Flags;
    ULONG VersionSpecificClassNameLength; // in bytes
    ULONG VersionSpecificClassNameOffset; // Offset from ACTIVATION_CONTEXT_DATA_WINDOW_CLASS_REDIRECTION base
    ULONG DllNameLength; // in bytes
    ULONG DllNameOffset; // Offset from section base because this can be shared across multiple entries
} ACTIVATION_CONTEXT_DATA_WINDOW_CLASS_REDIRECTION, *PACTIVATION_CONTEXT_DATA_WINDOW_CLASS_REDIRECTION;

typedef const ACTIVATION_CONTEXT_DATA_WINDOW_CLASS_REDIRECTION *PCACTIVATION_CONTEXT_DATA_WINDOW_CLASS_REDIRECTION;

//
//  Leaf node structures for COM activation redirection section (NULL Extension GUID, ACTIVATION_CONTEXT_SECTION_COM_SERVER_REDIRECTION)
//

#define ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_FORMAT_WHISTLER (1)

#define ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_THREADING_MODEL_INVALID (0)
#define ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_THREADING_MODEL_APARTMENT (1)
#define ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_THREADING_MODEL_FREE (2)
#define ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_THREADING_MODEL_SINGLE (3)
#define ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_THREADING_MODEL_BOTH (4)
#define ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_THREADING_MODEL_NEUTRAL (5)

typedef struct _ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION {
    ULONG Size;
    ULONG Flags;
    ULONG ThreadingModel;
    GUID ReferenceClsid;
    GUID ConfiguredClsid;
    GUID ImplementedClsid;
    GUID TypeLibraryId;
    ULONG ModuleLength; // in bytes
    ULONG ModuleOffset; // offset from section base because this can be shared across multiple entries
    ULONG ProgIdLength; // in bytes
    ULONG ProgIdOffset; // offset from ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION because this is never shared
    ULONG ShimDataLength; // in bytes
    ULONG ShimDataOffset; // offset from ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION because this is not shared
} ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION, *PACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION;

typedef const ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION *PCACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION;

//
//    ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM is a struct optionally hung
//    off an ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION that describes shimming. 
//    The common use of a shim is a file that is not a PE that implements
//    DllGetClassObject(); instead some other DLL will use the path
//    to the file in question plus metadata (typename for managed code and Java)
//    to provide a COM object that implements the CLSID.  Note that the file may not
//    even be a PE for things like scriptlets.  Most shims will reference the
//    system registry for this metadata; Fusion-aware shims can use the information
//    here in the activation context.
//
//    The format version of the ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION should
//    account for any format changes in the _SHIM struct here.
//

#define ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM_TYPE_OTHER (1)
#define ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM_TYPE_NDP_CLASS (2)

typedef struct _ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM {
    ULONG Size;
    ULONG Flags;
    ULONG Type;
    ULONG ModuleLength; // in bytes
    ULONG ModuleOffset; // offset from ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM
    ULONG TypeLength; // in bytes
    ULONG TypeOffset; // offset from ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM
    ULONG ShimVersionLength; // in bytes
    ULONG ShimVersionOffset; // offset from ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM
    ULONG DataLength; // in bytes
    ULONG DataOffset; // offset from ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM
} ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM, *PACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM;

typedef const ACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM *PCACTIVATION_CONTEXT_DATA_COM_SERVER_REDIRECTION_SHIM;

//
//  Leaf node structures for COM interface marshalling redirection section (NULL Extension GUID, ACTIVATION_CONTEXT_SECTION_COM_INTERFACE_REDIRECTION)
//

#define ACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION_FORMAT_WHISTLER (1)

#define ACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION_FLAG_NUM_METHODS_VALID    (0x00000001)
#define ACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION_FLAG_BASE_INTERFACE_VALID (0x00000002)

typedef struct _ACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION {
    ULONG Size;
    ULONG Flags;
    GUID ProxyStubClsid32;
    ULONG NumMethods;
    GUID TypeLibraryId;
    GUID BaseInterface;
    ULONG NameLength; // in bytes
    ULONG NameOffset; // offset from ACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION because this is not shared
} ACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION, *PACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION;

typedef const ACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION *PCACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION;

//
//  Leaf node structures for COM type library redirection section (NULL Extension GUID, ACTIVATION_CONTEXT_SECTION_COM_TYPE_LIBRARY_REDIRECTION)
//

//
//  The type library redirection section is keyed off a string composed of the type library GUID,
//  the hexidecimal representation of the LCID for the tlb and the version number of the
//  type library.
//
//  e.g.
//
//      "{0ECD9B60-23AA-11D0-B351-00A0C9055D8E}_en-us_6.0"
//

#define ACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION_FORMAT_WHISTLER (1)

typedef struct _ACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION {
    ULONG Size;
    ULONG Flags;
    ULONG NameLength; // in bytes
    ULONG NameOffset; // offset from section header
    USHORT ResourceId; // Resource ID of type library resource in PE
    USHORT LibraryFlags; // flags, as defined by the LIBFLAGS enumeration in oaidl.h
    ULONG HelpDirLength; // in bytes
    ULONG HelpDirOffset; // offset from ACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION
} ACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION, *PACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION;

typedef const ACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION *PCACTIVATION_CONTEXT_DATA_COM_TYPE_LIBRARY_REDIRECTION;

//
//  Leaf node structures for COM ProgId redirection section (NULL Extension GUID, ACTIVATION_CONTEXT_SECTION_COM_PROGID_REDIRECTION)
//

#define ACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION_FORMAT_WHISTLER (1)

typedef struct _ACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION {
    ULONG Size;
    ULONG Flags;
    ULONG ConfiguredClsidOffset; // offset from section header
} ACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION, *PACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION;


// data structures copied from winbase.h to avoid compiling 
// mscoree.dll with _WIN32_WINNT >= 0x0500
typedef const ACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION *PCACTIVATION_CONTEXT_DATA_COM_PROGID_REDIRECTION;

#if (!_WIN32_FUSION) || (_WIN32_FUSION < 0x0100)
typedef struct tagACTCTX_SECTION_KEYED_DATA {
    ULONG cbSize;
    ULONG ulDataFormatVersion;
    PVOID lpData;
    ULONG ulLength;
    PVOID lpSectionGlobalData;
    ULONG ulSectionGlobalDataLength;
    PVOID lpSectionBase;
    ULONG ulSectionTotalLength;
    HANDLE hActCtx;
    ULONG ulAssemblyRosterIndex;
} ACTCTX_SECTION_KEYED_DATA, *PACTCTX_SECTION_KEYED_DATA;

#define FIND_ACTCTX_SECTION_KEY_RETURN_HACTCTX (0x00000001)
#endif


/* these are defined in winnt.h
 * comment them out to avoid redefine compiler error
typedef enum _ACTIVATION_CONTEXT_INFO_CLASS {
    ActivationContextBasicInformation                       = 1,
    ActivationContextDetailedInformation                    = 2,
    AssemblyDetailedInformationInActivationContext          = 3,
    FileInformationInAssemblyOfAssemblyInActivationContext  = 4,
    MaxActivationContextInfoClass,
 
    //
    // compatibility with old names
    //
    AssemblyDetailedInformationInActivationContxt           = 3,
    FileInformationInAssemblyOfAssemblyInActivationContxt   = 4
} ACTIVATION_CONTEXT_INFO_CLASS;

typedef struct _ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION {
    ULONG ulFlags;
    ULONG ulEncodedAssemblyIdentityLength;      // in bytes
    ULONG ulManifestPathType;                   // ACTIVATION_CONTEXT_PATH_TYPE_*
    ULONG ulManifestPathLength;                 // in bytes
    LARGE_INTEGER liManifestLastWriteTime;      // FILETIME
    ULONG ulPolicyPathType;                     // ACTIVATION_CONTEXT_PATH_TYPE_*
    ULONG ulPolicyPathLength;                   // in bytes
    LARGE_INTEGER liPolicyLastWriteTime;        // FILETIME
    ULONG ulMetadataSatelliteRosterIndex;
    
    ULONG ulManifestVersionMajor;               // 1
    ULONG ulManifestVersionMinor;               // 0
    ULONG ulPolicyVersionMajor;                 // 0
    ULONG ulPolicyVersionMinor;                 // 0
    ULONG ulAssemblyDirectoryNameLength;        // in bytes
 
    PCWSTR lpAssemblyEncodedAssemblyIdentity;
    PCWSTR lpAssemblyManifestPath;
    PCWSTR lpAssemblyPolicyPath;
    PCWSTR lpAssemblyDirectoryName;
 
    ULONG  ulFileCount;
} ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION, * PACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION;
 
typedef const struct _ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION * PCACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION ;
*/

#include "poppack.h"

#if defined(__cplusplus)
} /* extern "C" */

inline bool operator ==(const ASSEMBLY_VERSION &av1, const ASSEMBLY_VERSION &av2) { return av1.QuadPart == av2.QuadPart; }
inline bool operator !=(const ASSEMBLY_VERSION &av1, const ASSEMBLY_VERSION &av2) { return av1.QuadPart != av2.QuadPart; }
inline bool operator <(const ASSEMBLY_VERSION &av1, const ASSEMBLY_VERSION &av2) { return av1.QuadPart < av2.QuadPart; }
inline bool operator >(const ASSEMBLY_VERSION &av1, const ASSEMBLY_VERSION &av2) { return av1.QuadPart > av2.QuadPart; }
inline bool operator <=(const ASSEMBLY_VERSION &av1, const ASSEMBLY_VERSION &av2) { return av1.QuadPart <= av2.QuadPart; }
inline bool operator >=(const ASSEMBLY_VERSION &av1, const ASSEMBLY_VERSION &av2) { return av1.QuadPart >= av2.QuadPart; }

#endif

#endif /* _SXSTYPES_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\timeline.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef TIMELINE_H_
#define TIMELINE_H_ 1

//*****************************************************************************
// Timeline.h
//
// Simple timed manual event log, for profiling purposes.
//
//*****************************************************************************

#ifndef ENABLE_TIMELINE

#if !GOLDEN
#define ENABLE_TIMELINE 1
#endif

#endif

class Timeline
{
 public:
    enum
    {
        GENERAL             = 0x00000001,
        LOADER              = 0x00000002,
        ZAP                 = 0x00000004,
        FUSIONBIND          = 0x00000008,
        // Add more categories here
    } Category;

    enum
    {
        LEVEL_MAJOR = 1,
        MAX_LEVEL = 20
    };

#if ENABLE_TIMELINE
    static Timeline g_Timeline;
#endif

    static void Startup();
    static void Shutdown();

    void Init();
    void Destroy();

    BOOL Enabled(int category) { return (m_enabled&category) != 0; }
    void Stamp(int level);
    void Event(LPCSTR formatString, ...);
    void EventStart(LPCSTR formatString, ...);
    void EventEnd(LPCSTR formatString, ...);

    class Monitor
    {
#if ENABLE_TIMELINE
    public:
        int m_level;
        LPCSTR m_string;

        Monitor() 
        { 
            m_level = Timeline::g_Timeline.m_lastLevel; 
            m_string = "";
        }

        ~Monitor() 
        { 
            while (m_level < Timeline::g_Timeline.m_lastLevel) 
                g_Timeline.EventEnd(m_string); 
        }
#endif
    };

 private:

    typedef LARGE_INTEGER timestamp;

    int         m_enabled;
    timestamp   m_frequency;
    timestamp   m_start;

    int         m_lastLevel;    
    timestamp   m_lastTime[MAX_LEVEL];

    void        *m_out;
};

#if ENABLE_TIMELINE

#define TIMELINE(c, a) \
        do { if ((Timeline::g_Timeline.Enabled(Timeline::c))) Timeline::g_Timeline.Event a; } while (0)
#define TIMELINE_START(c, a) \
        do { if ((Timeline::g_Timeline.Enabled(Timeline::c))) Timeline::g_Timeline.EventStart a; } while (0)
#define TIMELINE_END(c, a) \
        do { if ((Timeline::g_Timeline.Enabled(Timeline::c))) Timeline::g_Timeline.EventEnd a; } while (0)

#define TIMELINE_START_SAFE(c, a)                   \
        Timeline::Monitor __timelinemonitor;        \
        TIMELINE_START(c, a)

#define TIMELINE_AUTO(c, s)                         \
        Timeline::Monitor __timelineauto;           \
        __timelineauto.m_string = (s);              \
        TIMELINE_START(c, (s))

#else

#define TIMELINE(c, a)
#define TIMELINE_START(c, a)
#define TIMELINE_END(c, a)
#define TIMELINE_START_SAFE(c, a)
#define TIMELINE_AUTO(c, a)

inline void Timeline::Startup() {}
inline void Timeline::Shutdown() {}
inline void Timeline::Init() {}
inline void Timeline::Destroy() {}
inline void Timeline::Event(LPCSTR formatString, ...) {}
inline void Timeline::EventStart(LPCSTR formatString, ...) {}
inline void Timeline::EventEnd(LPCSTR formatString, ...) {}

#endif

#endif // TIMELINE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\symboltablestructs.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// Structures for ..\..\inc\SymbolTableStructs.h
// 12/18/1998  16:13:45
//*****************************************************************************
#pragma once
#ifndef DECLSPEC_SELECTANY
#define DECLSPEC_SELECTANY __declspec(selectany)
#endif
#include "icmprecs.h"


// Script supplied data.





#define SymTABLENAMELIST() \
    TABLENAME( Module ) \
    TABLENAME( TypeDef ) \
    TABLENAME( ClassContext ) \
    TABLENAME( InterfaceImpl ) \
    TABLENAME( TypeRef ) \
    TABLENAME( CustomValue ) \
    TABLENAME( Constant ) \
    TABLENAME( Token ) \
    TABLENAME( Method ) \
    TABLENAME( Field ) \
    TABLENAME( Param ) \
    TABLENAME( MemberRef ) \
    TABLENAME( MethodImpl ) \
    TABLENAME( RegNamespace ) \
    TABLENAME( Exception ) \
    TABLENAME( Property ) \
    TABLENAME( Event ) \
    TABLENAME( MethodSemantics ) \
    TABLENAME( ClassLayout ) \
    TABLENAME( FieldMarshal ) \
    TABLENAME( DeclSecurity ) \
    TABLENAME( StandAloneSig ) \
    TABLENAME( ModuleRef ) \
    TABLENAME( ArraySpec ) \
    TABLENAME( FixupList ) 


#undef TABLENAME
#define TABLENAME( TblName ) TABLENUM_Sym_##TblName, 
enum
{
    SymTABLENAMELIST()
};

#define Sym_TABLE_COUNT 25
extern const GUID DECLSPEC_SELECTANY SCHEMA_Sym = { 0x44641EA3, 0x703A, 0x11D1, {  0xB7, 0x4C, 0x00, 0xC0, 0x4F, 0xC3, 0x24, 0x80 }};
extern const COMPLIBSCHEMA DECLSPEC_SELECTANY SymSchema = 
{
    &SCHEMA_Sym,
    2
};


#define SCHEMA_Sym_Name "Sym"


#include "pshpack1.h"


//*****************************************************************************
//  Sym.Module
//*****************************************************************************
typedef struct
{
    unsigned long _rid;
    OID oid;
    GUID guid;
    GUID mvid;
    ULONG cbNameLen;
    wchar_t Name[260];
    unsigned long Locale;

    void Init()
    {
         memset(this, 0, sizeof(Sym_Module));
    }

} Sym_Module;

#define COLID_Sym_Module__rid 1
#define COLID_Sym_Module_oid 2
#define COLID_Sym_Module_guid 3
#define COLID_Sym_Module_mvid 4
#define COLID_Sym_Module_Name 5
#define COLID_Sym_Module_Locale 6




//*****************************************************************************
//  Sym.TypeDef
//*****************************************************************************
typedef struct
{
    ULONG fNullFlags;
    unsigned long _rid;
    OID oid;
    ULONG cbNamespaceLen;
    wchar_t Namespace[260];
    ULONG cbNameLen;
    wchar_t Name[260];
    unsigned short Flags;
    BYTE pad00 [2];
    OID Extends;
    unsigned short ExtendsFlag;
    BYTE pad01 [2];
    GUID guid;
    unsigned long VersionMS;
    unsigned long VersionLS;

    inline int IsguidNull(void)
    { return (GetBit(fNullFlags, 8)); }

    inline void SetguidNull(int nullBitVal = true)
    { SetBit(fNullFlags, 8, nullBitVal); }

    void Init()
    {
         memset(this, 0, sizeof(Sym_TypeDef));
         fNullFlags = (ULONG) -1;
    }

} Sym_TypeDef;

#define COLID_Sym_TypeDef__rid 1
#define COLID_Sym_TypeDef_oid 2
#define COLID_Sym_TypeDef_Namespace 3
#define COLID_Sym_TypeDef_Name 4
#define COLID_Sym_TypeDef_Flags 5
#define COLID_Sym_TypeDef_Extends 6
#define COLID_Sym_TypeDef_ExtendsFlag 7
#define COLID_Sym_TypeDef_guid 8
#define COLID_Sym_TypeDef_VersionMS 9
#define COLID_Sym_TypeDef_VersionLS 10




//*****************************************************************************
//  Sym.ClassContext
//*****************************************************************************
typedef struct
{
    ULONG fNullFlags;
    unsigned long _rid;
    OID oid;
    unsigned short BehaviorFlags;
    unsigned short ThreadingModel;
    unsigned short TransactionReqts;
    unsigned short SynchReqts;

    inline int IsSynchReqtsNull(void)
    { return (GetBit(fNullFlags, 6)); }

    inline void SetSynchReqtsNull(int nullBitVal = true)
    { SetBit(fNullFlags, 6, nullBitVal); }

    inline int IsTransactionReqtsNull(void)
    { return (GetBit(fNullFlags, 5)); }

    inline void SetTransactionReqtsNull(int nullBitVal = true)
    { SetBit(fNullFlags, 5, nullBitVal); }

    inline int IsThreadingModelNull(void)
    { return (GetBit(fNullFlags, 4)); }

    inline void SetThreadingModelNull(int nullBitVal = true)
    { SetBit(fNullFlags, 4, nullBitVal); }

    inline int IsBehaviorFlagsNull(void)
    { return (GetBit(fNullFlags, 3)); }

    inline void SetBehaviorFlagsNull(int nullBitVal = true)
    { SetBit(fNullFlags, 3, nullBitVal); }

    void Init()
    {
         memset(this, 0, sizeof(Sym_ClassContext));
         fNullFlags = (ULONG) -1;
    }

} Sym_ClassContext;

#define COLID_Sym_ClassContext__rid 1
#define COLID_Sym_ClassContext_oid 2
#define COLID_Sym_ClassContext_BehaviorFlags 3
#define COLID_Sym_ClassContext_ThreadingModel 4
#define COLID_Sym_ClassContext_TransactionReqts 5
#define COLID_Sym_ClassContext_SynchReqts 6




//*****************************************************************************
//  Sym.InterfaceImpl
//*****************************************************************************
typedef struct
{
    unsigned long _rid;
    OID oid;
    OID Class;
    OID Interface;
    unsigned short ImplFlags;
    BYTE pad00 [2];

    void Init()
    {
         memset(this, 0, sizeof(Sym_InterfaceImpl));
    }

} Sym_InterfaceImpl;

#define COLID_Sym_InterfaceImpl__rid 1
#define COLID_Sym_InterfaceImpl_oid 2
#define COLID_Sym_InterfaceImpl_Class 3
#define COLID_Sym_InterfaceImpl_Interface 4
#define COLID_Sym_InterfaceImpl_ImplFlags 5

#define Index_Sym_InterfaceImpl_Class_Dex "Sym.InterfaceImpl_Class_Dex"
#define Index_Sym_InterfaceImpl_Interface_Dex "Sym.InterfaceImpl_Interface_Dex"



//*****************************************************************************
//  Sym.TypeRef
//*****************************************************************************
typedef struct
{
    ULONG fNullFlags;
    unsigned long _rid;
    OID oid;
    ULONG cbURLLen;
    wchar_t URL[260];
    unsigned short BindFlags;
    BYTE pad00 [2];
    GUID guid;
    ULONG cbFullQualNameLen;
    wchar_t FullQualName[260];
    GUID VID;
    ULONG cbCodebaseLen;
    wchar_t Codebase[260];
    unsigned long LCID;
    unsigned long VersionMS;
    unsigned long VersionLS;
    unsigned long VersionMin;
    unsigned long VersionMax;

    inline int IsVersionMaxNull(void)
    { return (GetBit(fNullFlags, 13)); }

    inline void SetVersionMaxNull(int nullBitVal = true)
    { SetBit(fNullFlags, 13, nullBitVal); }

    inline int IsVersionMinNull(void)
    { return (GetBit(fNullFlags, 12)); }

    inline void SetVersionMinNull(int nullBitVal = true)
    { SetBit(fNullFlags, 12, nullBitVal); }

    inline int IsVersionLSNull(void)
    { return (GetBit(fNullFlags, 11)); }

    inline void SetVersionLSNull(int nullBitVal = true)
    { SetBit(fNullFlags, 11, nullBitVal); }

    inline int IsVersionMSNull(void)
    { return (GetBit(fNullFlags, 10)); }

    inline void SetVersionMSNull(int nullBitVal = true)
    { SetBit(fNullFlags, 10, nullBitVal); }

    inline int IsLCIDNull(void)
    { return (GetBit(fNullFlags, 9)); }

    inline void SetLCIDNull(int nullBitVal = true)
    { SetBit(fNullFlags, 9, nullBitVal); }

    inline int IsCodebaseNull(void)
    { return (GetBit(fNullFlags, 8)); }

    inline void SetCodebaseNull(int nullBitVal = true)
    { SetBit(fNullFlags, 8, nullBitVal); }

    inline int IsVIDNull(void)
    { return (GetBit(fNullFlags, 7)); }

    inline void SetVIDNull(int nullBitVal = true)
    { SetBit(fNullFlags, 7, nullBitVal); }

    inline int IsFullQualNameNull(void)
    { return (GetBit(fNullFlags, 6)); }

    inline void SetFullQualNameNull(int nullBitVal = true)
    { SetBit(fNullFlags, 6, nullBitVal); }

    inline int IsguidNull(void)
    { return (GetBit(fNullFlags, 5)); }

    inline void SetguidNull(int nullBitVal = true)
    { SetBit(fNullFlags, 5, nullBitVal); }

    void Init()
    {
         memset(this, 0, sizeof(Sym_TypeRef));
         fNullFlags = (ULONG) -1;
    }

} Sym_TypeRef;

#define COLID_Sym_TypeRef__rid 1
#define COLID_Sym_TypeRef_oid 2
#define COLID_Sym_TypeRef_URL 3
#define COLID_Sym_TypeRef_BindFlags 4
#define COLID_Sym_TypeRef_guid 5
#define COLID_Sym_TypeRef_FullQualName 6
#define COLID_Sym_TypeRef_VID 7
#define COLID_Sym_TypeRef_Codebase 8
#define COLID_Sym_TypeRef_LCID 9
#define COLID_Sym_TypeRef_VersionMS 10
#define COLID_Sym_TypeRef_VersionLS 11
#define COLID_Sym_TypeRef_VersionMin 12
#define COLID_Sym_TypeRef_VersionMax 13




//*****************************************************************************
//  Sym.CustomValue
//*****************************************************************************
typedef struct
{
    unsigned long _rid;
    OID oid;
    ULONG cbNameLen;
    wchar_t Name[260];
    OID Parent;
    ULONG cbValueLen;
    BYTE Value[260];

    void Init()
    {
         memset(this, 0, sizeof(Sym_CustomValue));
    }

} Sym_CustomValue;

#define COLID_Sym_CustomValue__rid 1
#define COLID_Sym_CustomValue_oid 2
#define COLID_Sym_CustomValue_Name 3
#define COLID_Sym_CustomValue_Parent 4
#define COLID_Sym_CustomValue_Value 5

#define Index_Sym_CustomValue_Dex "Sym.CustomValue_Dex"



//*****************************************************************************
//  Sym.Constant
//*****************************************************************************
typedef struct
{
    OID oid;
    unsigned char Type;
    BYTE pad00 [3];
    ULONG cbValueBlobLen;
    BYTE ValueBlob[260];

    void Init()
    {
         memset(this, 0, sizeof(Sym_Constant));
    }

} Sym_Constant;

#define COLID_Sym_Constant_oid 1
#define COLID_Sym_Constant_Type 2
#define COLID_Sym_Constant_ValueBlob 3




//*****************************************************************************
//  Sym.Token
//*****************************************************************************
typedef struct
{
    unsigned long _rid;
    unsigned __int64 Value;

    void Init()
    {
         memset(this, 0, sizeof(Sym_Token));
    }

} Sym_Token;

#define COLID_Sym_Token__rid 1
#define COLID_Sym_Token_Value 2




//*****************************************************************************
//  Sym.Method
//*****************************************************************************
typedef struct
{
    unsigned long _rid;
    OID oid;
    OID Class;
    ULONG cbNameLen;
    wchar_t Name[260];
    ULONG cbSignatureBlobLen;
    BYTE SignatureBlob[260];
    unsigned short Flags;
    unsigned short Slot;
    unsigned long RVA;
    unsigned short ImplFlags;
    BYTE pad00 [2];

    void Init()
    {
         memset(this, 0, sizeof(Sym_Method));
    }

} Sym_Method;

#define COLID_Sym_Method__rid 1
#define COLID_Sym_Method_oid 2
#define COLID_Sym_Method_Class 3
#define COLID_Sym_Method_Name 4
#define COLID_Sym_Method_SignatureBlob 5
#define COLID_Sym_Method_Flags 6
#define COLID_Sym_Method_Slot 7
#define COLID_Sym_Method_RVA 8
#define COLID_Sym_Method_ImplFlags 9

#define Index_Sym_Method_Dex "Sym.Method_Dex"



//*****************************************************************************
//  Sym.Field
//*****************************************************************************
typedef struct
{
    unsigned long _rid;
    OID oid;
    OID Class;
    ULONG cbNameLen;
    wchar_t Name[260];
    ULONG cbSignatureBlobLen;
    BYTE SignatureBlob[260];
    unsigned short Flags;
    BYTE pad00 [2];

    void Init()
    {
         memset(this, 0, sizeof(Sym_Field));
    }

} Sym_Field;

#define COLID_Sym_Field__rid 1
#define COLID_Sym_Field_oid 2
#define COLID_Sym_Field_Class 3
#define COLID_Sym_Field_Name 4
#define COLID_Sym_Field_SignatureBlob 5
#define COLID_Sym_Field_Flags 6

#define Index_Sym_Field_Dex "Sym.Field_Dex"



//*****************************************************************************
//  Sym.Param
//*****************************************************************************
typedef struct
{
    unsigned long _rid;
    OID oid;
    OID Member;
    ULONG cbNameLen;
    wchar_t Name[260];
    unsigned short Sequence;
    unsigned short Flags;

    void Init()
    {
         memset(this, 0, sizeof(Sym_Param));
    }

} Sym_Param;

#define COLID_Sym_Param__rid 1
#define COLID_Sym_Param_oid 2
#define COLID_Sym_Param_Member 3
#define COLID_Sym_Param_Name 4
#define COLID_Sym_Param_Sequence 5
#define COLID_Sym_Param_Flags 6

#define Index_Sym_Param_Dex "Sym.Param_Dex"



//*****************************************************************************
//  Sym.MemberRef
//*****************************************************************************
typedef struct
{
    unsigned long _rid;
    OID oid;
    ULONG cbNameLen;
    wchar_t Name[260];
    ULONG cbSignatureBlobLen;
    BYTE SignatureBlob[260];
    OID Class;

    void Init()
    {
         memset(this, 0, sizeof(Sym_MemberRef));
    }

} Sym_MemberRef;

#define COLID_Sym_MemberRef__rid 1
#define COLID_Sym_MemberRef_oid 2
#define COLID_Sym_MemberRef_Name 3
#define COLID_Sym_MemberRef_SignatureBlob 4
#define COLID_Sym_MemberRef_Class 5




//*****************************************************************************
//  Sym.MethodImpl
//*****************************************************************************
typedef struct
{
    unsigned long _rid;
    OID Class;
    OID Method;
    unsigned long RVA;
    unsigned short ImplFlags;
    BYTE pad00 [2];

    void Init()
    {
         memset(this, 0, sizeof(Sym_MethodImpl));
    }

} Sym_MethodImpl;

#define COLID_Sym_MethodImpl__rid 1
#define COLID_Sym_MethodImpl_Class 2
#define COLID_Sym_MethodImpl_Method 3
#define COLID_Sym_MethodImpl_RVA 4
#define COLID_Sym_MethodImpl_ImplFlags 5




//*****************************************************************************
//  Sym.RegNamespace
//*****************************************************************************
typedef struct
{
    unsigned long _rid;
    ULONG cbNameLen;
    wchar_t Name[MAX_CLASSNAME_LENGTH];
    OID oid;

    void Init()
    {
         memset(this, 0, sizeof(Sym_RegNamespace));
    }

} Sym_RegNamespace;

#define COLID_Sym_RegNamespace__rid 1
#define COLID_Sym_RegNamespace_Name 2
#define COLID_Sym_RegNamespace_oid 3




//*****************************************************************************
//  Sym.Exception
//*****************************************************************************
typedef struct
{
    unsigned long rid;
    OID oid;
    OID Method;
    OID Class;

    void Init()
    {
         memset(this, 0, sizeof(Sym_Exception));
    }

} Sym_Exception;

#define COLID_Sym_Exception_rid 1
#define COLID_Sym_Exception_oid 2
#define COLID_Sym_Exception_Method 3
#define COLID_Sym_Exception_Class 4

#define Index_Sym_Exception_Method_Dex "Sym.Exception_Method_Dex"



//*****************************************************************************
//  Sym.Property
//*****************************************************************************
typedef struct
{
    unsigned long rid;
    OID oid;
    OID Parent;
    ULONG cbNameLen;
    wchar_t Name[MAX_CLASSNAME_LENGTH];
    ULONG cbTypeLen;
    BYTE Type[260];
    unsigned short PropFlags;
    BYTE pad00 [2];
    OID BackingField;
    OID EventChanging;
    OID EventChanged;

    void Init()
    {
         memset(this, 0, sizeof(Sym_Property));
    }

} Sym_Property;

#define COLID_Sym_Property_rid 1
#define COLID_Sym_Property_oid 2
#define COLID_Sym_Property_Parent 3
#define COLID_Sym_Property_Name 4
#define COLID_Sym_Property_Type 5
#define COLID_Sym_Property_PropFlags 6
#define COLID_Sym_Property_BackingField 7
#define COLID_Sym_Property_EventChanging 8
#define COLID_Sym_Property_EventChanged 9

#define Index_Sym_Property_Name_Dex "Sym.Property_Name_Dex"
#define Index_Sym_Property_Parent_Dex "Sym.Property_Parent_Dex"



//*****************************************************************************
//  Sym.Event
//*****************************************************************************
typedef struct
{
    unsigned long rid;
    OID oid;
    OID Parent;
    ULONG cbNameLen;
    wchar_t Name[MAX_CLASSNAME_LENGTH];
    OID EventType;
    unsigned short EventFlags;
    BYTE pad00 [2];

    void Init()
    {
         memset(this, 0, sizeof(Sym_Event));
    }

} Sym_Event;

#define COLID_Sym_Event_rid 1
#define COLID_Sym_Event_oid 2
#define COLID_Sym_Event_Parent 3
#define COLID_Sym_Event_Name 4
#define COLID_Sym_Event_EventType 5
#define COLID_Sym_Event_EventFlags 6

#define Index_Sym_Event_Name_Dex "Sym.Event_Name_Dex"
#define Index_Sym_Event_Parent_Dex "Sym.Event_Parent_Dex"



//*****************************************************************************
//  Sym.MethodSemantics
//*****************************************************************************
typedef struct
{
    OID Method;
    OID Association;
    unsigned short Semantic;
    BYTE pad00 [2];

    void Init()
    {
         memset(this, 0, sizeof(Sym_MethodSemantics));
    }

} Sym_MethodSemantics;

#define COLID_Sym_MethodSemantics_Method 1
#define COLID_Sym_MethodSemantics_Association 2
#define COLID_Sym_MethodSemantics_Semantic 3

#define Index_Sym_Association_Dex "Sym.Association_Dex"
#define Index_Sym_MethodSemantics_Method_Dex "Sym.MethodSemantics_Method_Dex"



//*****************************************************************************
//  Sym.ClassLayout
//*****************************************************************************
typedef struct
{
    OID Class;
    unsigned short PackingSize;
    BYTE pad00 [2];
    ULONG cbFieldLayoutLen;
    BYTE FieldLayout[260];
    unsigned long ClassSize;

    void Init()
    {
         memset(this, 0, sizeof(Sym_ClassLayout));
    }

} Sym_ClassLayout;

#define COLID_Sym_ClassLayout_Class 1
#define COLID_Sym_ClassLayout_PackingSize 2
#define COLID_Sym_ClassLayout_FieldLayout 3
#define COLID_Sym_ClassLayout_ClassSize 4

#define Index_Sym_ClassLayout_Dex "Sym.ClassLayout_Dex"



//*****************************************************************************
//  Sym.FieldMarshal
//*****************************************************************************
typedef struct
{
    OID Field;
    ULONG cbNativeTypeLen;
    BYTE NativeType[260];

    void Init()
    {
         memset(this, 0, sizeof(Sym_FieldMarshal));
    }

} Sym_FieldMarshal;

#define COLID_Sym_FieldMarshal_Field 1
#define COLID_Sym_FieldMarshal_NativeType 2

#define Index_Sym_FieldMarshal_Dex "Sym.FieldMarshal_Dex"



//*****************************************************************************
//  Sym.DeclSecurity
//*****************************************************************************
typedef struct
{
    unsigned long rid;
    OID Declarator;
    unsigned short Action;
    BYTE pad00 [2];
    ULONG cbPermissionSetLen;
    BYTE PermissionSet[260];

    void Init()
    {
         memset(this, 0, sizeof(Sym_DeclSecurity));
    }

} Sym_DeclSecurity;

#define COLID_Sym_DeclSecurity_rid 1
#define COLID_Sym_DeclSecurity_Declarator 2
#define COLID_Sym_DeclSecurity_Action 3
#define COLID_Sym_DeclSecurity_PermissionSet 4




//*****************************************************************************
//  Sym.StandAloneSig
//*****************************************************************************
typedef struct
{
    unsigned long rid;
    ULONG cbSignatureLen;
    BYTE Signature[260];

    void Init()
    {
         memset(this, 0, sizeof(Sym_StandAloneSig));
    }

} Sym_StandAloneSig;

#define COLID_Sym_StandAloneSig_rid 1
#define COLID_Sym_StandAloneSig_Signature 2




//*****************************************************************************
//  Sym.ModuleRef
//*****************************************************************************
typedef struct
{
    ULONG fNullFlags;
    unsigned long _rid;
    OID oid;
    GUID guid;
    GUID mvid;
    ULONG cbNameLen;
    wchar_t Name[260];

    inline int IsmvidNull(void)
    { return (GetBit(fNullFlags, 4)); }

    inline void SetmvidNull(int nullBitVal = true)
    { SetBit(fNullFlags, 4, nullBitVal); }

    inline int IsguidNull(void)
    { return (GetBit(fNullFlags, 3)); }

    inline void SetguidNull(int nullBitVal = true)
    { SetBit(fNullFlags, 3, nullBitVal); }

    void Init()
    {
         memset(this, 0, sizeof(Sym_ModuleRef));
         fNullFlags = (ULONG) -1;
    }

} Sym_ModuleRef;

#define COLID_Sym_ModuleRef__rid 1
#define COLID_Sym_ModuleRef_oid 2
#define COLID_Sym_ModuleRef_guid 3
#define COLID_Sym_ModuleRef_mvid 4
#define COLID_Sym_ModuleRef_Name 5




//*****************************************************************************
//  Sym.ArraySpec
//*****************************************************************************
typedef struct
{
    unsigned long rid;
    ULONG cbSignatureLen;
    BYTE Signature[260];

    void Init()
    {
         memset(this, 0, sizeof(Sym_ArraySpec));
    }

} Sym_ArraySpec;

#define COLID_Sym_ArraySpec_rid 1
#define COLID_Sym_ArraySpec_Signature 2




//*****************************************************************************
//  Sym.FixupList
//*****************************************************************************
typedef struct
{
    unsigned long RVA;
    unsigned long Count;

    void Init()
    {
         memset(this, 0, sizeof(Sym_FixupList));
    }

} Sym_FixupList;

#define COLID_Sym_FixupList_RVA 1
#define COLID_Sym_FixupList_Count 2




#include "poppack.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\timer.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// timer.h
//
// This module contains the CTimer class which will time events and keep
// running totals.  This class will first try to use a high performance
// counter if the system supports it.  This type of counter is much more
// accurate than the system clock.  If the system does not support this, then
// the normal clock is used.  The total time is returned
//
//*****************************************************************************
#ifndef __timer_h__
#define __timer_h__

class CTimer
{
protected:
	BOOL		m_bQPSupport;			// TRUE when high perf counter available.
	__int64		m_iStart;				// Start timer.
	__int64		m_iTot;					// Total time.
	DWORD		m_dwStart;				// Elapsed counts for perf counter.
	DWORD		m_dwTot;				// Elapsed time for system clock.

public:
//*****************************************************************************
// Init vars.
//*****************************************************************************
	inline CTimer();

//*****************************************************************************
// Resets the duration counter to zero.
//*****************************************************************************
	inline void Reset();

//*****************************************************************************
// Starts timing an event.
//*****************************************************************************
	inline void Start();

//*****************************************************************************
// Stop timing the current event and add the total to the duration.
//*****************************************************************************
	inline void End();

//*****************************************************************************
// Return the total time accounted for by Start()/End() pairs.  Return time
// is in milliseconds.
//*****************************************************************************
	inline DWORD GetEllapsedMS();

//*****************************************************************************
// Return the total time accounted for by Start()/End() pairs.  Return time
// is in seconds.
//*****************************************************************************
	inline DWORD GetEllapsedSeconds();
};




//*****************************************************************************
// Init vars.
//*****************************************************************************
CTimer::CTimer() :
	m_iStart(0),
	m_dwStart(0),
	m_iTot(0)
{
	__int64		iTest;					// For testing perf counter.

	m_bQPSupport = QueryPerformanceCounter((LARGE_INTEGER*)&iTest);
	if (!m_bQPSupport)
		printf("\tNo high performance counter available.  Using system clock.\n");
}


//*****************************************************************************
// Resets the duration counter to zero.
//*****************************************************************************
void CTimer::Reset()
{
	m_iTot = 0;
	m_dwTot = 0;
}


//*****************************************************************************
// Starts timing an event.
//*****************************************************************************
void CTimer::Start()
{
	if (m_bQPSupport)
		QueryPerformanceCounter((LARGE_INTEGER*)&m_iStart);
	else
		m_dwStart = GetTickCount();
}


//*****************************************************************************
// Stop timing the current event and add the total to the duration.
//*****************************************************************************
void CTimer::End()
{
	if (m_bQPSupport)
	{
		__int64			iEnd;			// End time.

		QueryPerformanceCounter((LARGE_INTEGER*)&iEnd);
		m_iTot += (iEnd - m_iStart);
	}
	else
	{
		DWORD			dwEnd;			// End time.
		dwEnd = GetTickCount();
		m_dwTot += (dwEnd - m_dwStart);
	}
}


//*****************************************************************************
// Return the total time accounted for by Start()/End() pairs.  Return time
// is in milliseconds.
//*****************************************************************************
DWORD CTimer::GetEllapsedMS()
{
	if (m_bQPSupport)
	{
		__int64			iFreq;
		double			fms;
		QueryPerformanceFrequency((LARGE_INTEGER*)&iFreq);
		fms = (double)m_iTot / (double)iFreq * 1000;
		return ((DWORD)(fms));
	}
	else
	{
		return (m_dwTot);
	}
}


//*****************************************************************************
// Return the total time accounted for by Start()/End() pairs.  Return time
// is in seconds.
//*****************************************************************************
DWORD CTimer::GetEllapsedSeconds()
{
	if (m_bQPSupport)
	{
		__int64			iFreq;

		QueryPerformanceFrequency((LARGE_INTEGER*)&iFreq);
		return ((DWORD)(m_iTot / iFreq));
	}
	else
	{
		return (m_dwTot / 1000);
	}
}

#endif // __timer_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\tlbimpexp.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Thu Feb 20 18:27:20 2003
 */
/* Compiler settings for tlbimpexp.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __tlbimpexp_h__
#define __tlbimpexp_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ITypeLibImporterNotifySink_FWD_DEFINED__
#define __ITypeLibImporterNotifySink_FWD_DEFINED__
typedef interface ITypeLibImporterNotifySink ITypeLibImporterNotifySink;
#endif 	/* __ITypeLibImporterNotifySink_FWD_DEFINED__ */


#ifndef __ITypeLibExporterNotifySink_FWD_DEFINED__
#define __ITypeLibExporterNotifySink_FWD_DEFINED__
typedef interface ITypeLibExporterNotifySink ITypeLibExporterNotifySink;
#endif 	/* __ITypeLibExporterNotifySink_FWD_DEFINED__ */


#ifndef __ITypeLibExporterNameProvider_FWD_DEFINED__
#define __ITypeLibExporterNameProvider_FWD_DEFINED__
typedef interface ITypeLibExporterNameProvider ITypeLibExporterNameProvider;
#endif 	/* __ITypeLibExporterNameProvider_FWD_DEFINED__ */


#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 


#ifndef __TlbImpLib_LIBRARY_DEFINED__
#define __TlbImpLib_LIBRARY_DEFINED__

/* library TlbImpLib */
/* [version][uuid] */ 

typedef /* [public][public][public][uuid] */  DECLSPEC_UUID("F82895D2-1338-36A8-9A89-F9B0AFBE7801") 
enum __MIDL___MIDL_itf_tlbimpexp_0000_0001
    {	NOTIF_TYPECONVERTED	= 0,
	NOTIF_CONVERTWARNING	= 1,
	ERROR_REFTOINVALIDTYPELIB	= 2
    } 	ImporterEventKind;


EXTERN_C const IID LIBID_TlbImpLib;

#ifndef __ITypeLibImporterNotifySink_INTERFACE_DEFINED__
#define __ITypeLibImporterNotifySink_INTERFACE_DEFINED__

/* interface ITypeLibImporterNotifySink */
/* [object][oleautomation][uuid] */ 


EXTERN_C const IID IID_ITypeLibImporterNotifySink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F1C3BF76-C3E4-11D3-88E7-00902754C43A")
    ITypeLibImporterNotifySink : public IUnknown
    {
    public:
        virtual HRESULT __stdcall ReportEvent( 
            /* [in] */ ImporterEventKind EventKind,
            /* [in] */ long EventCode,
            /* [in] */ BSTR EventMsg) = 0;
        
        virtual HRESULT __stdcall ResolveRef( 
            /* [in] */ IUnknown *Typelib,
            /* [retval][out] */ IUnknown **pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITypeLibImporterNotifySinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITypeLibImporterNotifySink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITypeLibImporterNotifySink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITypeLibImporterNotifySink * This);
        
        HRESULT ( __stdcall *ReportEvent )( 
            ITypeLibImporterNotifySink * This,
            /* [in] */ ImporterEventKind EventKind,
            /* [in] */ long EventCode,
            /* [in] */ BSTR EventMsg);
        
        HRESULT ( __stdcall *ResolveRef )( 
            ITypeLibImporterNotifySink * This,
            /* [in] */ IUnknown *Typelib,
            /* [retval][out] */ IUnknown **pRetVal);
        
        END_INTERFACE
    } ITypeLibImporterNotifySinkVtbl;

    interface ITypeLibImporterNotifySink
    {
        CONST_VTBL struct ITypeLibImporterNotifySinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITypeLibImporterNotifySink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITypeLibImporterNotifySink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITypeLibImporterNotifySink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITypeLibImporterNotifySink_ReportEvent(This,EventKind,EventCode,EventMsg)	\
    (This)->lpVtbl -> ReportEvent(This,EventKind,EventCode,EventMsg)

#define ITypeLibImporterNotifySink_ResolveRef(This,Typelib,pRetVal)	\
    (This)->lpVtbl -> ResolveRef(This,Typelib,pRetVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall ITypeLibImporterNotifySink_ReportEvent_Proxy( 
    ITypeLibImporterNotifySink * This,
    /* [in] */ ImporterEventKind EventKind,
    /* [in] */ long EventCode,
    /* [in] */ BSTR EventMsg);


void __RPC_STUB ITypeLibImporterNotifySink_ReportEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeLibImporterNotifySink_ResolveRef_Proxy( 
    ITypeLibImporterNotifySink * This,
    /* [in] */ IUnknown *Typelib,
    /* [retval][out] */ IUnknown **pRetVal);


void __RPC_STUB ITypeLibImporterNotifySink_ResolveRef_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITypeLibImporterNotifySink_INTERFACE_DEFINED__ */


#ifndef __ITypeLibExporterNotifySink_INTERFACE_DEFINED__
#define __ITypeLibExporterNotifySink_INTERFACE_DEFINED__

/* interface ITypeLibExporterNotifySink */
/* [object][oleautomation][uuid] */ 


EXTERN_C const IID IID_ITypeLibExporterNotifySink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F1C3BF77-C3E4-11D3-88E7-00902754C43A")
    ITypeLibExporterNotifySink : public IUnknown
    {
    public:
        virtual HRESULT __stdcall ReportEvent( 
            /* [in] */ ImporterEventKind EventKind,
            /* [in] */ long EventCode,
            /* [in] */ BSTR EventMsg) = 0;
        
        virtual HRESULT __stdcall ResolveRef( 
            /* [in] */ IUnknown *Asm,
            /* [retval][out] */ IUnknown **pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITypeLibExporterNotifySinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITypeLibExporterNotifySink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITypeLibExporterNotifySink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITypeLibExporterNotifySink * This);
        
        HRESULT ( __stdcall *ReportEvent )( 
            ITypeLibExporterNotifySink * This,
            /* [in] */ ImporterEventKind EventKind,
            /* [in] */ long EventCode,
            /* [in] */ BSTR EventMsg);
        
        HRESULT ( __stdcall *ResolveRef )( 
            ITypeLibExporterNotifySink * This,
            /* [in] */ IUnknown *Asm,
            /* [retval][out] */ IUnknown **pRetVal);
        
        END_INTERFACE
    } ITypeLibExporterNotifySinkVtbl;

    interface ITypeLibExporterNotifySink
    {
        CONST_VTBL struct ITypeLibExporterNotifySinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITypeLibExporterNotifySink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITypeLibExporterNotifySink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITypeLibExporterNotifySink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITypeLibExporterNotifySink_ReportEvent(This,EventKind,EventCode,EventMsg)	\
    (This)->lpVtbl -> ReportEvent(This,EventKind,EventCode,EventMsg)

#define ITypeLibExporterNotifySink_ResolveRef(This,Asm,pRetVal)	\
    (This)->lpVtbl -> ResolveRef(This,Asm,pRetVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall ITypeLibExporterNotifySink_ReportEvent_Proxy( 
    ITypeLibExporterNotifySink * This,
    /* [in] */ ImporterEventKind EventKind,
    /* [in] */ long EventCode,
    /* [in] */ BSTR EventMsg);


void __RPC_STUB ITypeLibExporterNotifySink_ReportEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITypeLibExporterNotifySink_ResolveRef_Proxy( 
    ITypeLibExporterNotifySink * This,
    /* [in] */ IUnknown *Asm,
    /* [retval][out] */ IUnknown **pRetVal);


void __RPC_STUB ITypeLibExporterNotifySink_ResolveRef_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITypeLibExporterNotifySink_INTERFACE_DEFINED__ */


#ifndef __ITypeLibExporterNameProvider_INTERFACE_DEFINED__
#define __ITypeLibExporterNameProvider_INTERFACE_DEFINED__

/* interface ITypeLibExporterNameProvider */
/* [object][oleautomation][uuid] */ 


EXTERN_C const IID IID_ITypeLibExporterNameProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FA1F3615-ACB9-486d-9EAC-1BEF87E36B09")
    ITypeLibExporterNameProvider : public IUnknown
    {
    public:
        virtual HRESULT __stdcall GetNames( 
            /* [retval][out] */ SAFEARRAY * *Names) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITypeLibExporterNameProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITypeLibExporterNameProvider * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITypeLibExporterNameProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITypeLibExporterNameProvider * This);
        
        HRESULT ( __stdcall *GetNames )( 
            ITypeLibExporterNameProvider * This,
            /* [retval][out] */ SAFEARRAY * *Names);
        
        END_INTERFACE
    } ITypeLibExporterNameProviderVtbl;

    interface ITypeLibExporterNameProvider
    {
        CONST_VTBL struct ITypeLibExporterNameProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITypeLibExporterNameProvider_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITypeLibExporterNameProvider_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITypeLibExporterNameProvider_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITypeLibExporterNameProvider_GetNames(This,Names)	\
    (This)->lpVtbl -> GetNames(This,Names)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall ITypeLibExporterNameProvider_GetNames_Proxy( 
    ITypeLibExporterNameProvider * This,
    /* [retval][out] */ SAFEARRAY * *Names);


void __RPC_STUB ITypeLibExporterNameProvider_GetNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITypeLibExporterNameProvider_INTERFACE_DEFINED__ */

#endif /* __TlbImpLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\tlbutils.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header:  Utilities used to help manipulating typelib's.
**  
**			Created by: dmortens
===========================================================*/

#ifndef _TLBUTILS_H
#define _TLBUTILS_H

#include "windows.h"
#include "utilcode.h"

struct StdConvertibleItfInfo
{
	LPUTF8		m_strMngTypeName;
	GUID	   *m_pNativeTypeIID;
	LPUTF8		m_strCustomMarshalerTypeName;
	LPUTF8		m_strCookie;
};

// This method returns the custom marshaler info to convert the native interface
// to its managed equivalent. Or null if the interface is not a standard convertible interface.
StdConvertibleItfInfo *GetConvertionInfoFromNativeIID(REFGUID rGuidNativeItf);

// This method returns the custom marshaler info to convert the managed type to
// to its native equivalent. Or null if the interface is not a standard convertible interface.
StdConvertibleItfInfo *GetConvertionInfoFromManagedType(LPUTF8 strMngTypeName);

// This method generates a mangled type name based on the original name specified.
// This type name is guaranteed to be unique inside the TLB.
HRESULT GenerateMangledTypeName(ITypeLib *pITLB, BSTR szOriginalTypeName, BSTR *pszMangledTypeName);

// This function determines the namespace name for a TypeLib.
HRESULT GetNamespaceNameForTypeLib(     // S_OK or error.
    ITypeLib    *pITLB,                 // [IN] The TypeLib.
    BSTR        *pwzNamespace);         // [OUT] Put the namespace name here.

// This function determines the namespace.name for a TypeInfo.  If no namespace
//  is provided, it is retrieved from the containing library.
HRESULT GetManagedNameForTypeInfo(      // S_OK or error.
    ITypeInfo   *pITI,                  // [IN] The TypeInfo.
    LPCWSTR     wzNamespace,            // [IN, OPTIONAL] Default namespace name.
    LPCWSTR     wzAsmName,              // [IN, OPTIONAL] Assembly name.
    BSTR        *pwzName);              // [OUT] Put the name here.

#endif  _TLBUTILS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\utilcode.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// UtilCode.h
//
// Utility functions implemented in UtilCode.lib.
//
// Please note that the debugger has a parallel copy of this file elsewhere
// (in Debug\Shell\DebuggerUtil.h), so if you modify this file, please either
// reconcile the two files yourself, or email somebody on the debugger team
// (jasonz, mipanitz, or mikemag, as of Tue May 11 15:45:30 1999) to get them
// to do it.  Thanks!   --Debugger Team
//
//*****************************************************************************
#ifndef __UtilCode_h__
#define __UtilCode_h__



#include "CrtWrap.h"
#include "WinWrap.h"
#include <stdio.h>
#include <malloc.h>
#include <ctype.h>
#include <ole2.h>
#include <limits.h>
#include "rotate.h"
#include "DebugMacros.h"
#include "DbgAlloc.h"
#include "corhlpr.h"
#include "safegetfilesize.h"
#include <member-offset-info.h>
#include "winnls.h"
#include <assert.h>

#ifndef WC_NO_BEST_FIT_CHARS
#define WC_NO_BEST_FIT_CHARS      0x00000400  // do not use best fit chars
#endif

//********** Max Allocation Request support ***********************************
#ifdef _DEBUG
#ifndef _WIN64
#define MAXALLOC
#endif // _WIN64
#endif // _DEBUG

#include "PerfAlloc.h"

typedef LPCSTR  LPCUTF8;
typedef LPSTR   LPUTF8;

#include "nsutilpriv.h"

// used by HashiString
// CharToUpper is defined in ComUtilNative.h
extern WCHAR CharToUpper(WCHAR);

/*// This is for WinCE
#ifdef VERIFY
#undef VERIFY
#endif

#ifdef _ASSERTE
#undef _ASSERTE
#endif
*/

//********** Macros. **********************************************************
#ifndef FORCEINLINE
 #if _MSC_VER < 1200
   #define FORCEINLINE inline
 #else
   #define FORCEINLINE __forceinline
 #endif
#endif


#include <stddef.h> // for offsetof

#ifndef NumItems
#define NumItems(s) (sizeof(s) / sizeof(s[0]))
#endif



#ifdef _DEBUG
#define UNREACHABLE do {_ASSERTE(!"How did we get here?"); __assume(0);} while(0)
#else
#define UNREACHABLE __assume(0)
#endif

// Helper will 4 byte align a value, rounding up.
#define ALIGN4BYTE(val) (((val) + 3) & ~0x3)

// These macros can be used to cast a pointer to a derived/base class to the
// opposite object.  You can do this in a template using a normal cast, but
// the compiler will generate 4 extra insructions to keep a null pointer null
// through the adjustment.  The problem is if it is contained it can never be
// null and those 4 instructions are dead code.
#define INNER_TO_OUTER(p, I, O) ((O *) ((char *) p - (int) ((char *) ((I *) ((O *) 8)) - 8)))
#define OUTER_TO_INNER(p, I, O) ((I *) ((char *) p + (int) ((char *) ((I *) ((O *) 8)) - 8)))

//=--------------------------------------------------------------------------=
// string helpers.

//
// given and ANSI String, copy it into a wide buffer.
// be careful about scoping when using this macro!
//
// how to use the below two macros:
//
//  ...
//  LPSTR pszA;
//  pszA = MyGetAnsiStringRoutine();
//  MAKE_WIDEPTR_FROMANSI(pwsz, pszA);
//  MyUseWideStringRoutine(pwsz);
//  ...
//
// similarily for MAKE_ANSIPTR_FROMWIDE.  note that the first param does not
// have to be declared, and no clean up must be done.
//

// We'll define an upper limit that allows multiplication by 4 (the max 
// bytes/char in UTF-8) but still remains positive, and allows some room for pad.
// Under normal circumstances, we should never get anywhere near this limit.
#define MAKE_MAX_LENGTH 0x1fffff00

#ifndef MAKE_TOOLONGACTION
#define MAKE_TOOLONGACTION RaiseException(EXCEPTION_INT_OVERFLOW, EXCEPTION_NONCONTINUABLE, 0, 0)
#endif

#ifndef MAKE_TRANSLATIONFAILED
#define MAKE_TRANSLATIONFAILED RaiseException(ResultFromScode(ERROR_NO_UNICODE_TRANSLATION), EXCEPTION_NONCONTINUABLE, 0, 0)
#endif


// This version throws on conversion errors (ie, no best fit character 
// mapping to characters that look similar, and no use of the default char
// ('?') when printing out unrepresentable characters.  Use this method for
// most development in the EE, especially anything like metadata or class 
// names.  See the BESTFIT version if you're printing out info to the console.
#define MAKE_MULTIBYTE_FROMWIDE(ptrname, widestr, codepage) \
    long __l##ptrname = (long)wcslen(widestr);        \
    if (__l##ptrname > MAKE_MAX_LENGTH)         \
        MAKE_TOOLONGACTION;                     \
    __l##ptrname = (long)((__l##ptrname + 1) * 2 * sizeof(char)); \
    CQuickBytes __CQuickBytes##ptrname; \
    __CQuickBytes##ptrname.Alloc(__l##ptrname); \
    BOOL __b##ptrname; \
    DWORD __cBytes##ptrname = WszWideCharToMultiByte(codepage, WC_NO_BEST_FIT_CHARS, widestr, -1, (LPSTR)__CQuickBytes##ptrname.Ptr(), __l##ptrname-1, NULL, &__b##ptrname); \
    if (__b##ptrname || (__cBytes##ptrname == 0 && (widestr[0] != L'\0'))) {\
        assert(!"Strict Unicode -> MultiByte character conversion failure!"); \
        MAKE_TRANSLATIONFAILED; \
    } \
    LPSTR ptrname = (LPSTR)__CQuickBytes##ptrname.Ptr()

// This version does best fit character mapping and also allows the use 
// of the default char ('?') for any Unicode character that isn't 
// representable.  This is reasonable for writing to the console, but
// shouldn't be used for most string conversions.
#define MAKE_MULTIBYTE_FROMWIDE_BESTFIT(ptrname, widestr, codepage) \
    long __l##ptrname = (long)wcslen(widestr);        \
    if (__l##ptrname > MAKE_MAX_LENGTH)         \
        MAKE_TOOLONGACTION;                     \
    __l##ptrname = (long)((__l##ptrname + 1) * 2 * sizeof(char)); \
    CQuickBytes __CQuickBytes##ptrname; \
    __CQuickBytes##ptrname.Alloc(__l##ptrname); \
    DWORD __cBytes##ptrname = WszWideCharToMultiByte(codepage, 0, widestr, -1, (LPSTR)__CQuickBytes##ptrname.Ptr(), __l##ptrname-1, NULL, NULL); \
    if (__cBytes##ptrname == 0 && __l##ptrname != 0) { \
        assert(!"Unicode -> MultiByte (with best fit mapping) character conversion failed"); \
        MAKE_TRANSLATIONFAILED; \
    } \
    LPSTR ptrname = (LPSTR)__CQuickBytes##ptrname.Ptr()


// Use for anything critical other than output to console, where weird 
// character mappings are unacceptable.
#define MAKE_ANSIPTR_FROMWIDE(ptrname, widestr) MAKE_MULTIBYTE_FROMWIDE(ptrname, widestr, CP_ACP)

// Use for output to the console.
#define MAKE_ANSIPTR_FROMWIDE_BESTFIT(ptrname, widestr) MAKE_MULTIBYTE_FROMWIDE_BESTFIT(ptrname, widestr, CP_ACP)

#define MAKE_WIDEPTR_FROMANSI(ptrname, ansistr) \
    long __l##ptrname; \
    LPWSTR ptrname; \
    __l##ptrname = WszMultiByteToWideChar(CP_ACP, 0, ansistr, -1, 0, 0); \
    if (__l##ptrname > MAKE_MAX_LENGTH) \
        MAKE_TOOLONGACTION; \
    ptrname = (LPWSTR) alloca((__l##ptrname+1)*sizeof(WCHAR));  \
    if (WszMultiByteToWideChar(CP_ACP, MB_ERR_INVALID_CHARS, ansistr, -1, ptrname, __l##ptrname) == 0) { \
        assert(!"ANSI -> Unicode translation failed!"); \
        MAKE_TRANSLATIONFAILED; \
    }

#define MAKE_UTF8PTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (long)wcslen(widestr); \
    if (__l##ptrname > MAKE_MAX_LENGTH) \
        MAKE_TOOLONGACTION; \
    __l##ptrname = (long)((__l##ptrname + 1) * 2 * sizeof(char)); \
    LPUTF8 ptrname = (LPUTF8)alloca(__l##ptrname); \
    INT32 __lresult##ptrname=WszWideCharToMultiByte(CP_UTF8, 0, widestr, -1, ptrname, __l##ptrname-1, NULL, NULL); \
    if ((__lresult##ptrname==0) && (((LPCWSTR)widestr)[0] != L'\0')) { \
        if (::GetLastError()==ERROR_INSUFFICIENT_BUFFER) { \
            INT32 __lsize##ptrname=WszWideCharToMultiByte(CP_UTF8, 0, widestr, -1, NULL, 0, NULL, NULL); \
            ptrname = (LPSTR)alloca(__lsize##ptrname); \
            if (0==WszWideCharToMultiByte(CP_UTF8, 0, widestr, -1, ptrname, __lsize##ptrname, NULL, NULL)) { \
                assert(!"Bad Unicode -> UTF-8 translation error!  (Do you have unpaired Unicode surrogate chars in your string?)"); \
                MAKE_TRANSLATIONFAILED; \
            } \
        } \
        else { \
            assert(!"Bad Unicode -> UTF-8 translation error!  (Do you have unpaired Unicode surrogate chars in your string?)"); \
            MAKE_TRANSLATIONFAILED; \
        } \
    }

#define MAKE_WIDEPTR_FROMUTF8(ptrname, utf8str) \
    long __l##ptrname; \
    LPWSTR ptrname; \
    __l##ptrname = WszMultiByteToWideChar(CP_UTF8, 0, utf8str, -1, 0, 0); \
    if (__l##ptrname > MAKE_MAX_LENGTH) \
        MAKE_TOOLONGACTION; \
    ptrname = (LPWSTR) alloca(__l##ptrname*sizeof(WCHAR));  \
    if (0==WszMultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, utf8str, -1, ptrname, __l##ptrname+1))  {\
        assert(!"UTF-8 -> Unicode translation failed!"); \
        MAKE_TRANSLATIONFAILED; \
    }

#define MAKE_WIDEPTR_FROMUTF8_FORPRINT(ptrname, utf8str) \
    long __l##ptrname; \
    LPWSTR ptrname; \
    __l##ptrname = WszMultiByteToWideChar(CP_UTF8, 0, utf8str, -1, 0, 0); \
    if (__l##ptrname > MAKE_MAX_LENGTH) \
        MAKE_TOOLONGACTION; \
    ptrname = (LPWSTR) alloca(__l##ptrname*sizeof(WCHAR));  \
    if (0==WszMultiByteToWideChar(CP_UTF8, 0, utf8str, -1, ptrname, __l##ptrname+1))  {\
        assert(!"UTF-8 -> Unicode translation failed!"); \
        MAKE_TRANSLATIONFAILED; \
    }


#define MAKE_WIDEPTR_FROMUTF8N(ptrname, utf8str, n8chrs) \
    long __l##ptrname; \
    LPWSTR ptrname; \
    __l##ptrname = WszMultiByteToWideChar(CP_UTF8, 0, utf8str, n8chrs, 0, 0); \
    if (__l##ptrname > MAKE_MAX_LENGTH) \
        MAKE_TOOLONGACTION; \
    ptrname = (LPWSTR) alloca((__l##ptrname+1)*sizeof(WCHAR));  \
    if (0==WszMultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, utf8str, n8chrs, ptrname, __l##ptrname)) { \
        assert(0 && !"UTF-8 -> Unicode translation failed!"); \
        MAKE_TRANSLATIONFAILED; \
    } \
    ptrname[__l##ptrname] = 0;

// This method takes the number of characters
#define MAKE_MULTIBYTE_FROMWIDEN(ptrname, widestr, _nCharacters, _pCnt, codepage)        \
    long __l##ptrname; \
    __l##ptrname = WszWideCharToMultiByte(codepage, WC_NO_BEST_FIT_CHARS, widestr, _nCharacters, NULL, 0, NULL, NULL);           \
    if (__l##ptrname > MAKE_MAX_LENGTH) \
        MAKE_TOOLONGACTION; \
    ptrname = (LPUTF8) alloca(__l##ptrname + 1); \
    BOOL __b##ptrname; \
    DWORD _pCnt = WszWideCharToMultiByte(codepage, WC_NO_BEST_FIT_CHARS, widestr, _nCharacters, ptrname, __l##ptrname, NULL, &__b##ptrname);  \
    if (__b##ptrname || (_pCnt == 0 && _nCharacters > 0)) { \
        assert("Unicode -> MultiByte character translation failed!"); \
        MAKE_TRANSLATIONFAILED; \
    } \
    ptrname[__l##ptrname] = 0;

#define MAKE_MULTIBYTE_FROMWIDEN_BESTFIT(ptrname, widestr, _nCharacters, _pCnt, codepage)        \
    long __l##ptrname; \
    __l##ptrname = WszWideCharToMultiByte(codepage, 0, widestr, _nCharacters, NULL, 0, NULL, NULL);           \
    if (__l##ptrname > MAKE_MAX_LENGTH) \
        MAKE_TOOLONGACTION; \
    ptrname = (LPUTF8) alloca(__l##ptrname + 1); \
    DWORD _pCnt = WszWideCharToMultiByte(codepage, 0, widestr, _nCharacters, ptrname, __l##ptrname, NULL, NULL);  \
    if (_pCnt == 0 && _nCharacters > 0) { \
        assert("Unicode -> MultiByte character translation failed!"); \
        MAKE_TRANSLATIONFAILED; \
    } \
    ptrname[__l##ptrname] = 0;


#define MAKE_ANSIPTR_FROMWIDEN(ptrname, widestr, _nCharacters, _pCnt)        \
       MAKE_MULTIBYTE_FROMWIDEN(ptrname, widestr, _nCharacters, _pCnt, CP_ACP)



//*****************************************************************************
// Placement new is used to new and object at an exact location.  The pointer
// is simply returned to the caller without actually using the heap.  The
// advantage here is that you cause the ctor() code for the object to be run.
// This is ideal for heaps of C++ objects that need to get init'd multiple times.
// Example:
//      void        *pMem = GetMemFromSomePlace();
//      Foo *p = new (pMem) Foo;
//      DoSomething(p);
//      p->~Foo();
//*****************************************************************************
#ifndef __PLACEMENT_NEW_INLINE
#define __PLACEMENT_NEW_INLINE
inline void *__cdecl operator new(size_t, void *_P)
{
    return (_P);
}
#endif __PLACEMENT_NEW_INLINE


/********************************************************************************/
/* portability helpers */
#ifdef _WIN64
#define IN_WIN64(x)     x
#define IN_WIN32(x)
#else
#define IN_WIN64(x)
#define IN_WIN32(x)     x
#endif

#ifdef MAXALLOC
// these defs allow testers to specify max number of requests for an allocation before
// returning outofmemory
void * AllocMaxNew( size_t n, void **ppvCallstack);
class AllocRequestManager {
  public:
    UINT m_newRequestCount;
    UINT m_maxRequestCount;
    AllocRequestManager(LPCTSTR key);
    BOOL CheckRequest(size_t n);
    void UndoRequest();
};
#endif

#ifndef __OPERATOR_NEW_INLINE
#define __OPERATOR_NEW_INLINE 1

#ifndef ALLOC_FAILURE_ACTION
#define ALLOC_FAILURE_ACTION
#endif

#if defined( MAXALLOC )

static inline void * __cdecl 
operator new(size_t n) { 
    CDA_DECL_CALLSTACK(); 
    void *p = AllocMaxNew(n, CDA_GET_CALLSTACK()); 
    if (!p) {
        ALLOC_FAILURE_ACTION;
    }
    return p;
}

static inline void * __cdecl 
operator new[](size_t n) { 
    CDA_DECL_CALLSTACK(); 
    void *p = AllocMaxNew(n, CDA_GET_CALLSTACK()); 
    if (!p) {
        ALLOC_FAILURE_ACTION;
    }
    return p;
}

static inline void __cdecl 
operator delete(void *p) { 
    CDA_DECL_CALLSTACK(); 
    DbgFree(p, CDA_GET_CALLSTACK()); 
}

static inline void __cdecl 
operator delete[](void *p) { 
    CDA_DECL_CALLSTACK(); 
    DbgFree(p, CDA_GET_CALLSTACK()); 
}

#elif defined( PERFALLOC )

static __forceinline void * __cdecl 
operator new(size_t n) { 
    void *p = PerfNew::PerfAlloc(n, PerfAllocCallerEIP()); 
    if (!p) {
        ALLOC_FAILURE_ACTION;
    }
    return p;
}

static __forceinline void * __cdecl 
operator new[](size_t n) { 
    void *p = PerfNew::PerfAlloc(n, PerfAllocCallerEIP()); 
    if (!p) {
        ALLOC_FAILURE_ACTION;
    }
    return p;
}

static inline void __cdecl 
operator delete(void *p) { 
    PerfNew::PerfFree(p, NULL); 
}

static inline void __cdecl operator delete[](void *p) {
    PerfNew::PerfFree(p, NULL); 
}

#define VirtualAlloc(addr,size,flags,type) PerfVirtualAlloc::VirtualAlloc(addr,size,flags,type,PerfAllocCallerEIP())
#define VirtualFree(addr,size,type) PerfVirtualAlloc::VirtualFree(addr,size,type)

#else

static inline void * __cdecl 
operator new(size_t n) { 
    void *p = LocalAlloc(LMEM_FIXED, n); 
    if (!p) {
        ALLOC_FAILURE_ACTION;
    }
    return p;
}

static inline void * __cdecl 
operator new[](size_t n) { 
    void *p = LocalAlloc(LMEM_FIXED, n); 
    if (!p) {
        ALLOC_FAILURE_ACTION;
    }
    return p;
};

static inline void __cdecl 
operator delete(void *p) { 
    LocalFree(p); 
}

static inline void __cdecl 
operator delete[](void *p) { 
    LocalFree(p); 
}

#endif // #if defined( MAXALLOC )

#endif // !__OPERATOR_NEW_INLINE


#ifdef _DEBUG
HRESULT _OutOfMemory(LPCSTR szFile, int iLine);
#define OutOfMemory() _OutOfMemory(__FILE__, __LINE__)
#else
inline HRESULT OutOfMemory()
{
    return (E_OUTOFMEMORY);
}
#endif

inline void *GetTopMemoryAddress(void)
{
    static void *result = NULL;

    if (NULL == result)
    {
        SYSTEM_INFO sysInfo;
        GetSystemInfo(&sysInfo);
        result = sysInfo.lpMaximumApplicationAddress;
    }
    
    return result;
}

inline void *GetBotMemoryAddress(void)
{
    static void *result = NULL;
    
    if (NULL == result)
    {
        SYSTEM_INFO sysInfo;
        GetSystemInfo(&sysInfo);
        result = sysInfo.lpMinimumApplicationAddress;
    }
    
    return result;
}

#define TOP_MEMORY (GetTopMemoryAddress())
#define BOT_MEMORY (GetBotMemoryAddress())

//*****************************************************************************
// Handle accessing localizable resource strings
//***************************************************************************** 

// Notes about the culture callbacks:
// - The language we're operating in can change at *runtime*!
// - A process may operate in *multiple* languages. 
//     (ex: Each thread may have it's own language)
// - If we don't care what language we're in (or have no way of knowing), 
//     then return a 0-length name and UICULTUREID_DONTCARE for the culture ID.
// - GetCultureName() and the GetCultureId() must be in sync (refer to the
//     same language). 
// - We have two functions separate functions for better performance. 
//     - The name is used to resolve a directory for MsCorRC.dll.
//     - The id is used as a key to map to a dll hinstance.

// Callback to copy the culture name into szBuffer. Returns the length
typedef int (*FPGETTHREADUICULTURENAME)(LPWSTR szBuffer, int length);

// Callback to obtain the culture's parent culture name
typedef int (*FPGETTHREADUICULTUREPARENTNAME)(LPWSTR szBuffer, int length);

// Callback to return the culture ID. 
const int UICULTUREID_DONTCARE = -1;
typedef int (*FPGETTHREADUICULTUREID)();

// Load a string from the cultured version of MsCorRC.dll.
HRESULT LoadStringRC(UINT iResouceID, LPWSTR szBuffer, int iMax, int bQuiet=FALSE);

// Specify callbacks so that LoadStringRC can find out which language we're in.
// If no callbacks specified (or both parameters are NULL), we default to the 
// resource dll in the root (which is probably english).
void SetResourceCultureCallbacks(
    FPGETTHREADUICULTURENAME fpGetThreadUICultureName,
    FPGETTHREADUICULTUREID fpGetThreadUICultureId,
    FPGETTHREADUICULTUREPARENTNAME fpGetThreadUICultureParentName
);

void GetResourceCultureCallbacks(
        FPGETTHREADUICULTURENAME* fpGetThreadUICultureName,
        FPGETTHREADUICULTUREID* fpGetThreadUICultureId,
        FPGETTHREADUICULTUREPARENTNAME* fpGetThreadUICultureParentName
);

// Get the MUI ID, on downlevel platforms where MUI is not supported it
// returns the default system ID.
extern int GetMUILanguageID();
extern int GetMUILanguageName(LPWSTR szBuffer, int length);  // returns "MUI\<HEX_LANGUAGE_ID>"
extern int GetMUIParentLanguageName(LPWSTR szBuffer, int length);  // returns "MUI\<HEX_LANGUAGE_ID>"

//*****************************************************************************
// Must associate each handle to an instance of a resource dll with the int
// that it represents
//*****************************************************************************
class CCulturedHInstance
{
public:
    CCulturedHInstance() {
        m_LangId = 0;
        m_hInst = NULL;
    };

    int         m_LangId;
    HINSTANCE   m_hInst;
};

//*****************************************************************************
// CCompRC manages string Resource access for COM+. This includes loading 
// the MsCorRC.dll for resources as well allowing each thread to use a 
// a different localized version.
//*****************************************************************************
class CCompRC
{
public:
    CCompRC();
    CCompRC(WCHAR* pResourceFile);
    ~CCompRC();

    HRESULT LoadString(UINT iResourceID, LPWSTR szBuffer, int iMax, int bQuiet=false);
    
    void SetResourceCultureCallbacks(
        FPGETTHREADUICULTURENAME fpGetThreadUICultureName,
        FPGETTHREADUICULTUREID fpGetThreadUICultureId,
        FPGETTHREADUICULTUREPARENTNAME fpGetThreadUICultureParentName
    );

    void GetResourceCultureCallbacks(
        FPGETTHREADUICULTURENAME* fpGetThreadUICultureName,
        FPGETTHREADUICULTUREID* fpGetThreadUICultureId,
        FPGETTHREADUICULTUREPARENTNAME* fpGetThreadUICultureParentName
    );

#ifdef SHOULD_WE_CLEANUP
    void Shutdown();
#endif /* SHOULD_WE_CLEANUP */
    
    HRESULT LoadMUILibrary(HINSTANCE * pHInst);

private:
    HRESULT LoadLibrary(HINSTANCE * pHInst);
    HRESULT GetLibrary(HINSTANCE* phInst);

    // We must map between a thread's int and a dll instance. 
    // Since we only expect 1 language almost all of the time, we'll special case 
    // that and then use a variable size map for everything else.
    CCulturedHInstance m_Primary;
    CCulturedHInstance * m_pHash;   
    int m_nHashSize;
    
    CRITICAL_SECTION m_csMap;
    
    static WCHAR* m_pDefaultResource;
    WCHAR* m_pResourceFile;

    // Main accessors for hash
    HINSTANCE LookupNode(int langId);
    void AddMapNode(int langId, HINSTANCE hInst);

    FPGETTHREADUICULTURENAME m_fpGetThreadUICultureName;
    FPGETTHREADUICULTUREID m_fpGetThreadUICultureId;
    FPGETTHREADUICULTUREPARENTNAME  m_fpGetThreadUICultureParentName;
};


void DisplayError(HRESULT hr, LPWSTR message, UINT nMsgType = MB_OK | MB_ICONEXCLAMATION | MB_TASKMODAL);

int CorMessageBox(
                  HWND hWnd,        // Handle to Owner Window
                  UINT uText,       // Resource Identifier for Text message
                  UINT uCaption,    // Resource Identifier for Caption
                  UINT uType,       // Style of MessageBox
                  BOOL ShowFileNameInTitle, // Flag to show FileName in Caption
                  ...);             // Additional Arguments

int CorMessageBoxCatastrophic(
                  HWND hWnd,        // Handle to Owner Window
                  UINT iText,    // Text for MessageBox
                  UINT iTitle,   // Title for MessageBox
                  UINT uType,       // Style of MessageBox
                  BOOL ShowFileNameInTitle);

int CorMessageBoxCatastrophic(
                  HWND hWnd,        // Handle to Owner Window
                  LPWSTR lpText,    // Text for MessageBox
                  LPWSTR lpTitle,   // Title for MessageBox
                  UINT uType,       // Style of MessageBox
                  BOOL ShowFileNameInTitle, // Flag to show FileName in Caption
                  ...);


inline HRESULT BadError(HRESULT hr)
{
    _ASSERTE(!"Serious Error");
    return (hr);
}

#define TESTANDRETURN(test, hrVal)              \
{                                               \
    int ___test = (int)(test);                  \
    _ASSERTE(___test);                          \
    if (! ___test)                              \
        return hrVal;                           \
}                                               

#define TESTANDRETURNPOINTER(pointer)           \
    TESTANDRETURN(pointer!=NULL, E_POINTER)

#define TESTANDRETURNMEMORY(pointer)            \
    TESTANDRETURN(pointer!=NULL, E_OUTOFMEMORY)

#define TESTANDRETURNHR(hr)                     \
    TESTANDRETURN(SUCCEEDED(hr), hr)

#define TESTANDRETURNARG(argtest)               \
    TESTANDRETURN(argtest, E_INVALIDARG)

// The following is designed to be used within a __try/__finally to test a  
// condition, set hr in the enclosing scope value if failed, and leave the try
#define TESTANDLEAVE(test, hrVal)               \
{                                               \
    int ___test = (int)(test);                  \
    _ASSERTE(___test);                          \
    if (! ___test) {                            \
        hr = hrVal;                             \
        __leave;                                \
    }                                           \
}                                               

// The following is designed to be used within a while loop to test a  
// condition, set hr in the enclosing scope value if failed, and leave the block
#define TESTANDBREAK(test, hrVal)               \
{                                               \
    int ___test = (int)(test);                  \
    _ASSERTE(___test);                          \
    if (! ___test) {                            \
        hr = hrVal;                             \
        break;                                  \
    }                                           \
}                                               

#define TESTANDBREAKHR(hr)                      \
    TESTANDBREAK(SUCCEEDED(hr), hr)

#define TESTANDLEAVEHR(hr)                      \
    TESTANDLEAVE(SUCCEEDED(hr), hr)

#define TESTANDLEAVEMEMORY(pointer)             \
    TESTANDLEAVE(pointer!=NULL, E_OUTOFMEMORY)

// Count the bits in a value in order iBits time.
inline int CountBits(int iNum)
{
    for (int iBits=0;  iNum;  iBits++)
        iNum = iNum & (iNum - 1);
    return (iBits);
}

#ifdef _DEBUG
#define RVA_OR_SHOULD_BE_ZERO(RVA, dwParentAttrs, dwMemberAttrs, dwImplFlags, pImport, methodDef) \
        _ASSERTE(RVA != 0                                                                   \
        || IsTdInterface(dwParentAttrs)                                                     \
        || (                                                                                \
            (IsReallyMdPinvokeImpl(dwMemberAttrs)|| IsMiInternalCall(dwImplFlags))          \
            && NDirect::HasNAT_LAttribute(pImport, methodDef)==S_OK)                        \
        || IsMiRuntime(dwImplFlags)                                                         \
        || IsMdAbstract(dwMemberAttrs)                                                      \
        ) 
        
#endif //_DEBUG


// Turn a bit in a mask into TRUE or FALSE
template<class T, class U> inline VARIANT_BOOL GetBitFlag(T flags, U bit)
{
    if ((flags & bit) != 0)
        return VARIANT_TRUE;
    return VARIANT_FALSE;
}

// Set or clear a bit in a mask, depending on a BOOL.
template<class T, class U> inline void PutBitFlag(T &flags, U bit, VARIANT_BOOL bValue)
{
    if (bValue)
        flags |= bit;
    else
        flags &= ~(bit);
}


// prototype for a function to print formatted string to stdout.

int _cdecl PrintfStdOut(LPCWSTR szFmt, ...);


// Used to remove trailing zeros from Decimal types.
// NOTE: Assumes hi32 bits are empty (used for conversions from Cy->Dec)
inline void DecimalCanonicalize(DECIMAL* dec)
{
    // Remove trailing zeros:
    DECIMAL temp;
    DECIMAL templast;
    temp = templast = *dec;

    // Ensure the hi 32 bits are empty (should be if we came from a currency)
    _ASSERTE(temp.Hi32 == 0);
    _ASSERTE(temp.scale <= 4);

    // Return immediately if dec represents a zero.
    if (temp.Lo64 == 0)
        return;
    
    // Compare to the original to see if we've
    // lost non-zero digits (and make sure we don't overflow the scale BYTE)
    while ((temp.scale <= 4) && (VARCMP_EQ == VarDecCmp(dec, &temp)))
    {
        templast = temp;

        // Remove the last digit and normalize.  Ignore temp.Hi32
        // as Currency values will have a max of 64 bits of data.
        temp.scale--;
        temp.Lo64 /= 10;
    }
    *dec = templast;
}

//*****************************************************************************
//
// Paths functions. Use these instead of the CRT.
//
//*****************************************************************************
extern "C" 
{
void    SplitPath(const WCHAR *, WCHAR *, WCHAR *, WCHAR *, WCHAR *);
void    MakePath(register WCHAR *path, const WCHAR *drive, const WCHAR *dir, const WCHAR *fname, const WCHAR *ext);
WCHAR * FullPath(WCHAR *UserBuf, const WCHAR *path, size_t maxlen);

HRESULT CompletePathA(
    LPSTR               szPath,             //@parm  [out] Full Path name   (Must be MAX_PATH in size)
    LPCSTR              szRelPath,          //@parm  Relative Path name
    LPCSTR              szAbsPath           //@parm  Absolute Path name portion (NULL uses current path)
    );
}


// It is occasionally necessary to verify a Unicode string can be converted
// to the appropriate ANSI code page without any best fit mapping going on.
// Think of code that checks for a '\' or a '/' to make sure you don't access
// a file in a different directory.  Some unicode characters (ie, U+2044, 
// FRACTION SLASH, looks like '/') look like the ASCII equivalents and will 
// be mapped accordingly.  This can fool code that searches for '/' (U+002F).
// You should probably only call this method if you're on Win9x, though it 
// will return the same value on all platforms.
BOOL ContainsUnmappableANSIChars(const WCHAR * const widestr);




//*************************************************************************
// Class to provide QuickBytes behaviour for typed arrays.
//*************************************************************************
//
//
template <class T> class CQuickArrayNoDtor : public CQuickBytesNoDtor
{
public:
    T* Alloc(int iItems) 
        { return (T*)CQuickBytesNoDtor::Alloc(iItems * sizeof(T)); }
    HRESULT ReSize(SIZE_T iItems) 
        { return CQuickBytesNoDtor::ReSize(iItems * sizeof(T)); }
    T* Ptr() 
        { return (T*) CQuickBytesNoDtor::Ptr(); }
    size_t Size()
        { return CQuickBytesNoDtor::Size() / sizeof(T); }
    size_t MaxSize()
        { return CQuickBytesNoDtor::cbTotal / sizeof(T); }
    void Maximize()
        { return CQuickBytesNoDtor::Maximize(); }

    T& operator[] (size_t ix)
    { _ASSERTE(ix < static_cast<unsigned int>(Size()));
        return *(Ptr() + ix);
    }
    void Destroy() 
        { CQuickBytesNoDtor::Destroy(); }
};

template <class T> class CQuickArray : public CQuickArrayNoDtor<T>
{
 public:
    ~CQuickArray<T>() { Destroy(); }
};

typedef CQuickArray<WCHAR> CQuickWSTR;
typedef CQuickArrayNoDtor<WCHAR> CQuickWSTRNoDtor;

typedef CQuickArray<CHAR> CQuickSTR;
typedef CQuickArrayNoDtor<CHAR> CQuickSTRNoDtor;


//*****************************************************************************
//
// **** REGUTIL - Static helper functions for reading/writing to Windows registry.
//
//*****************************************************************************

class REGUTIL
{
public:
//*****************************************************************************
// Open's the given key and returns the value desired.  If the key or value is
// not found, then the default is returned.
//*****************************************************************************
    static long GetLong(                    // Return value from registry or default.
        LPCTSTR     szName,                 // Name of value to get.
        long        iDefault,               // Default value to return if not found.
        LPCTSTR     szKey=NULL,             // Name of key, NULL==default.
        HKEY        hKey=HKEY_LOCAL_MACHINE);// What key to work on.

//*****************************************************************************
// Open's the given key and returns the value desired.  If the key or value is
// not found, then the default is returned.
//*****************************************************************************
    static long SetLong(                    // Return value from registry or default.
        LPCTSTR     szName,                 // Name of value to get.
        long        iValue,                 // Value to set.
        LPCTSTR     szKey=NULL,             // Name of key, NULL==default.
        HKEY        hKey=HKEY_LOCAL_MACHINE);// What key to work on.

//*****************************************************************************
// Open's the given key and returns the value desired.  If the value is not
// in the key, or the key does not exist, then the default is copied to the
// output buffer.
//*****************************************************************************
    /*
    // This is commented out because it calls StrNCpy which calls Wszlstrcpyn which we commented out
    // because we didn't have a Win98 implementation and nobody was using it. jenh

    static LPCTSTR GetString(               // Pointer to user's buffer.
        LPCTSTR     szName,                 // Name of value to get.
        LPCTSTR     szDefault,              // Default value if not found.
        LPTSTR      szBuff,                 // User's buffer to write to.
        ULONG       iMaxBuff,               // Size of user's buffer.
        LPCTSTR     szKey=NULL,             // Name of key, NULL=default.
        int         *pbFound=NULL,          // Found in registry?
        HKEY        hKey=HKEY_LOCAL_MACHINE);// What key to work on.
    */

//*****************************************************************************

    enum CORConfigLevel
    {
        COR_CONFIG_ENV          = 0x01,
        COR_CONFIG_USER         = 0x02,
        COR_CONFIG_MACHINE      = 0x04,

        COR_CONFIG_ALL          =   -1,
        COR_CONFIG_CAN_SET      = (COR_CONFIG_USER|COR_CONFIG_MACHINE)
    };

    static DWORD GetConfigDWORD(
        LPWSTR         name,
        DWORD          defValue,
        CORConfigLevel level = COR_CONFIG_ALL,
        BOOL           fPrependCOMPLUS = TRUE);

    static HRESULT SetConfigDWORD(
        LPWSTR         name,
        DWORD          value,
        CORConfigLevel level = COR_CONFIG_CAN_SET);

    static DWORD GetConfigFlag(
        LPWSTR         name,
        DWORD          bitToSet,
        BOOL           defValue = FALSE);

    static LPWSTR GetConfigString(LPWSTR name,
                                  BOOL fPrependCOMPLUS = TRUE,
                                  CORConfigLevel level = COR_CONFIG_ALL);

    static void   FreeConfigString(LPWSTR name);

//*****************************************************************************
// Set an entry in the registry of the form:
// HKEY_CLASSES_ROOT\szKey\szSubkey = szValue.  If szSubkey or szValue are
// NULL, omit them from the above expression.
//*****************************************************************************
    static BOOL SetKeyAndValue(             // TRUE or FALSE.
        LPCTSTR     szKey,                  // Name of the reg key to set.
        LPCTSTR     szSubkey,               // Optional subkey of szKey.
        LPCTSTR     szValue);               // Optional value for szKey\szSubkey.

//*****************************************************************************
// Delete an entry in the registry of the form:
// HKEY_CLASSES_ROOT\szKey\szSubkey.
//*****************************************************************************
    static LONG DeleteKey(                  // TRUE or FALSE.
        LPCTSTR     szKey,                  // Name of the reg key to set.
        LPCTSTR     szSubkey);              // Subkey of szKey.

//*****************************************************************************
// Open the key, create a new keyword and value pair under it.
//*****************************************************************************
    static BOOL SetRegValue(                // Return status.
        LPCTSTR     szKeyName,              // Name of full key.
        LPCTSTR     szKeyword,              // Name of keyword.
        LPCTSTR     szValue);               // Value of keyword.

//*****************************************************************************
// Does standard registration of a CoClass with a progid.
//*****************************************************************************
    static HRESULT RegisterCOMClass(        // Return code.
        REFCLSID    rclsid,                 // Class ID.
        LPCTSTR     szDesc,                 // Description of the class.
        LPCTSTR     szProgIDPrefix,         // Prefix for progid.
        int         iVersion,               // Version # for progid.
        LPCTSTR     szClassProgID,          // Class progid.
        LPCTSTR     szThreadingModel,       // What threading model to use.
        LPCTSTR     szModule,               // Path to class.
        HINSTANCE   hInst,                  // Handle to module being registered
        LPCTSTR     szAssemblyName,         // Optional assembly name
        LPCTSTR     szVersion,              // Optional Runtime Version (directry containing runtime)
        BOOL        fExternal,              // flag - External to mscoree.
        BOOL        fRelativePath);         // flag - Relative path in szModule 

//*****************************************************************************
// Unregister the basic information in the system registry for a given object
// class.
//*****************************************************************************
    static HRESULT UnregisterCOMClass(      // Return code.
        REFCLSID    rclsid,                 // Class ID we are registering.
        LPCTSTR     szProgIDPrefix,         // Prefix for progid.
        int         iVersion,               // Version # for progid.
        LPCTSTR     szClassProgID,          // Class progid.
        BOOL        fExternal);             // flag - External to mscoree.

//*****************************************************************************
// Does standard registration of a CoClass with a progid.
// NOTE: This is the non-side-by-side execution version.
//*****************************************************************************
    static HRESULT RegisterCOMClass(        // Return code.
        REFCLSID    rclsid,                 // Class ID.
        LPCTSTR     szDesc,                 // Description of the class.
        LPCTSTR     szProgIDPrefix,         // Prefix for progid.
        int         iVersion,               // Version # for progid.
        LPCTSTR     szClassProgID,          // Class progid.
        LPCTSTR     szThreadingModel,       // What threading model to use.
        LPCTSTR     szModule);              // Path to class.

//*****************************************************************************
// Unregister the basic information in the system registry for a given object
// class.
// NOTE: This is the non-side-by-side execution version.
//*****************************************************************************
    static HRESULT UnregisterCOMClass(      // Return code.
        REFCLSID    rclsid,                 // Class ID we are registering.
        LPCTSTR     szProgIDPrefix,         // Prefix for progid.
        int         iVersion,               // Version # for progid.
        LPCTSTR     szClassProgID);         // Class progid.

//*****************************************************************************
// Register a type library.
//*****************************************************************************
    static HRESULT RegisterTypeLib(         // Return code.
        REFGUID     rtlbid,                 // TypeLib ID we are registering.
        int         iVersion,               // Typelib version.
        LPCTSTR     szDesc,                 // TypeLib description.
        LPCTSTR     szModule);              // Path to the typelib.

//*****************************************************************************
// Remove the registry keys for a type library.
//*****************************************************************************
    static HRESULT UnregisterTypeLib(       // Return code.
        REFGUID     rtlbid,                 // TypeLib ID we are registering.
        int         iVersion);              // Typelib version.

private:
//*****************************************************************************
// Register the basics for a in proc server.
//*****************************************************************************
    static HRESULT RegisterClassBase(       // Return code.
        REFCLSID    rclsid,                 // Class ID we are registering.
        LPCTSTR     szDesc,                 // Class description.
        LPCTSTR     szProgID,               // Class prog ID.
        LPCTSTR     szIndepProgID,          // Class version independant prog ID.
        LPTSTR      szOutCLSID,            // CLSID formatted in character form.
        DWORD      cchOutCLSID);           // Out CLS ID buffer size        

//*****************************************************************************
// Delete the basic settings for an inproc server.
//*****************************************************************************
    static HRESULT UnregisterClassBase(     // Return code.
REFCLSID    rclsid,                 // Class ID we are registering.
        LPCTSTR     szProgID,               // Class prog ID.
        LPCTSTR     szIndepProgID,          // Class version independant prog ID.
        LPTSTR      szOutCLSID,            // Return formatted class ID here.
        DWORD      cchOutCLSID);           // Out CLS ID buffer size        
};

//*****************************************************************************
// Enum to track which version of the OS we are running
//*****************************************************************************
typedef enum {
    RUNNING_ON_STATUS_UNINITED = 0,
    RUNNING_ON_WIN95,
    RUNNING_ON_WINNT,
    RUNNING_ON_WINNT5,
    RUNNING_ON_WINXP
} RunningOnStatusEnum;

extern RunningOnStatusEnum gRunningOnStatus;

//*****************************************************************************
// One time initialization of the OS version
//*****************************************************************************
static void InitRunningOnVersionStatus ()
{
        //@todo: when everyone ports to the wrappers, take out this ANSI code
#if defined( __TODO_PORT_TO_WRAPPERS__ ) && !defined( UNICODE )
        OSVERSIONINFOA  sVer;
        sVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
        GetVersionExA(&sVer);
#else
        OSVERSIONINFOW   sVer;
        sVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        WszGetVersionEx(&sVer);
#endif
        if (sVer.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
            gRunningOnStatus = RUNNING_ON_WIN95;
        if (sVer.dwPlatformId == VER_PLATFORM_WIN32_NT)
        {
            if (sVer.dwMajorVersion >= 5) {
                if (sVer.dwMinorVersion == 0)
                    gRunningOnStatus = RUNNING_ON_WINNT5;
                else
                    gRunningOnStatus = RUNNING_ON_WINXP;
            }
            else
                gRunningOnStatus = RUNNING_ON_WINNT;
        }
}

//*****************************************************************************
// Returns TRUE if and only if you are running on Win95.
//*****************************************************************************
inline BOOL RunningOnWin95()
{
    if (gRunningOnStatus == RUNNING_ON_STATUS_UNINITED)
    {
        InitRunningOnVersionStatus();
    }

    return (gRunningOnStatus == RUNNING_ON_WIN95) ? TRUE : FALSE;
}


//*****************************************************************************
// Returns TRUE if and only if you are running on WinNT.
//*****************************************************************************
inline BOOL RunningOnWinNT()
{
    if (gRunningOnStatus == RUNNING_ON_STATUS_UNINITED)
    {
        InitRunningOnVersionStatus();
    }

    return ((gRunningOnStatus == RUNNING_ON_WINNT) || (gRunningOnStatus == RUNNING_ON_WINNT5) || (gRunningOnStatus == RUNNING_ON_WINXP)) ? TRUE : FALSE;
}


//*****************************************************************************
// Returns TRUE if and only if you are running on WinNT5 or WinXP.
//*****************************************************************************
inline BOOL RunningOnWinNT5()
{
    if (gRunningOnStatus == RUNNING_ON_STATUS_UNINITED)
    {
        InitRunningOnVersionStatus();
    }

    return (gRunningOnStatus == RUNNING_ON_WINNT5 || gRunningOnStatus == RUNNING_ON_WINXP) ? TRUE : FALSE;
}

//*****************************************************************************
// Returns TRUE if you are running on WinXP.
//*****************************************************************************
inline BOOL RunningOnWinXP()
{
    if (gRunningOnStatus == RUNNING_ON_STATUS_UNINITED)
    {
        InitRunningOnVersionStatus();
    }

    return (gRunningOnStatus == RUNNING_ON_WINXP) ? TRUE : FALSE;
}

// We either want space after all the modules (start at the top & work down)
// (pModule == NULL), or after a specific address (a module's IL Base)
// (start there & work up)(pModule != NULL).  
HRESULT FindFreeSpaceWithinRange(const BYTE *&pStart, 
                                   const BYTE *&pNext, 
                                   const BYTE *&pLast, 
                                   const BYTE *pBaseAddr = 0,
                                   const BYTE *pMaxAddr = (const BYTE*)0x7ffeffff,
                                   int sizeToFind = 0);

//******************************************************************************
// Returns the number of processors that a process has been configured to run on
//******************************************************************************
int GetCurrentProcessCpuCount(); 

//*****************************************************************************
// This class exists to get an increasing low resolution counter value fast.
//*****************************************************************************
class CTimeCounter
{
    static DWORD m_iTickCount;          // Last tick count value.
    static ULONG m_iTime;               // Current count.

public:
    enum { TICKSPERSEC = 10 };

//*****************************************************************************
// Get the current time for use in the aging algorithm.
//*****************************************************************************
    static ULONG GetCurrentCounter()    // The current time.
    {
        return (m_iTime);
    }

//*****************************************************************************
// Set the current time for use in the aging algorithm.
//*****************************************************************************
    static void UpdateTime()
    {
        DWORD       iTickCount;         // New tick count.

        // Determine the delta since the last update.
        m_iTime += (((iTickCount = GetTickCount()) - m_iTickCount) + 50) / 100;
        m_iTickCount = iTickCount;
    }

//*****************************************************************************
// Calculate refresh age.
//*****************************************************************************
    static USHORT RefreshAge(long iMilliseconds)
    {
        // Figure out the age to allow.
        return ((USHORT)(iMilliseconds / (1000 / TICKSPERSEC)));
    }
};


//*****************************************************************************
// Return != 0 if the bit at the specified index in the array is on and 0 if
// it is off.
//*****************************************************************************
inline int GetBit(const BYTE *pcBits,int iBit)
{
    return (pcBits[iBit>>3] & (1 << (iBit & 0x7)));
}

//*****************************************************************************
// Set the state of the bit at the specified index based on the value of bOn.
//*****************************************************************************
inline void SetBit(BYTE *pcBits,int iBit,int bOn)
{
    if (bOn)
        pcBits[iBit>>3] |= (1 << (iBit & 0x7));
    else
        pcBits[iBit>>3] &= ~(1 << (iBit & 0x7));
}


//*****************************************************************************
// This class implements a dynamic array of structures for which the order of
// the elements is unimportant.  This means that any item placed in the list
// may be swapped to any other location in the list at any time.  If the order
// of the items you place in the array is important, then use the CStructArray
// class.
//*****************************************************************************
template <class T,int iGrowInc>
class CUnorderedArray
{
    USHORT      m_iCount;               // # of elements used in the list.
    USHORT      m_iSize;                // # of elements allocated in the list.
public:
    T           *m_pTable;              // Pointer to the list of elements.

public:
    CUnorderedArray() :
        m_pTable(NULL),
        m_iCount(0),
        m_iSize(0)
    { }
    ~CUnorderedArray()
    {
        // Free the chunk of memory.
        if (m_pTable != NULL)
            free (m_pTable);
    }

    void Clear()
    {
        m_iCount = 0;
        if (m_iSize > iGrowInc)
        {
            m_pTable = (T *) realloc(m_pTable, iGrowInc * sizeof(T));
            m_iSize = iGrowInc;
        }
    }

    void Clear(int iFirst, int iCount)
    {
        int     iSize;

        if (iFirst + iCount < m_iCount)
            memmove(&m_pTable[iFirst], &m_pTable[iFirst + iCount], sizeof(T) * (m_iCount - (iFirst + iCount)));

        m_iCount -= iCount;

        iSize = ((m_iCount / iGrowInc) * iGrowInc) + ((m_iCount % iGrowInc != 0) ? iGrowInc : 0);
        if (m_iSize > iGrowInc && iSize < m_iSize)
        {
            m_pTable = (T *) realloc(m_pTable, iSize * sizeof(T));
            m_iSize = iSize;
        }
        _ASSERTE(m_iCount <= m_iSize);
    }

    T *Table()
    { return (m_pTable); }

    USHORT Count()
    { return (m_iCount); }

    T *Append()
    {
        // The array should grow, if we can't fit one more element into the array.
        if (m_iSize <= m_iCount && Grow() == NULL)
            return (NULL);
        return (&m_pTable[m_iCount++]);
    }

    void Delete(const T &Entry)
    {
        --m_iCount;
        for (int i=0; i <= m_iCount; ++i)
            if (m_pTable[i] == Entry)
            {
                m_pTable[i] = m_pTable[m_iCount];
                return;
            }

        // Just in case we didn't find it.
        ++m_iCount;
    }

    void DeleteByIndex(int i)
    {
        --m_iCount;
        m_pTable[i] = m_pTable[m_iCount];
    }

    void Swap(int i,int j)
    {
        T       tmp;

        if (i == j)
            return;
        tmp = m_pTable[i];
        m_pTable[i] = m_pTable[j];
        m_pTable[j] = tmp;
    }

private:
    T *Grow();
};


//*****************************************************************************
// Increase the size of the array.
//*****************************************************************************
template <class T,int iGrowInc>
T *CUnorderedArray<T,iGrowInc>::Grow()  // NULL if can't grow.
{
    T       *pTemp;

    // try to allocate memory for reallocation.
    if ((pTemp = (T *) realloc(m_pTable, (m_iSize+iGrowInc) * sizeof(T))) == NULL)
        return (NULL);
    m_pTable = pTemp;
    m_iSize += iGrowInc;
    return (pTemp);
}

//Used by the debugger.  Included here in hopes somebody else might, too
typedef CUnorderedArray<SIZE_T, 17> SIZE_T_UNORDERED_ARRAY;

//*****************************************************************************
// This class implements a dynamic array of structures for which the insert
// order is important.  Inserts will slide all elements after the location
// down, deletes slide all values over the deleted item.  If the order of the
// items in the array is unimportant to you, then CUnorderedArray may provide
// the same feature set at lower cost.
//*****************************************************************************
class CStructArray
{
    short       m_iElemSize;            // Size of an array element.
    short       m_iGrowInc;             // Growth increment.
    void        *m_pList;               // Pointer to the list of elements.
    int         m_iCount;               // # of elements used in the list.
    int         m_iSize;                // # of elements allocated in the list.
    bool        m_bFree;                // true if data is automatically maintained.

public:
    CStructArray(short iElemSize, short iGrowInc = 1) :
        m_iElemSize(iElemSize),
        m_iGrowInc(iGrowInc),
        m_pList(NULL),
        m_iCount(0),
        m_iSize(0),
        m_bFree(true)
    { }
    ~CStructArray()
    {
        Clear();
    }

    void *Insert(int iIndex);
    void *Append();
    int AllocateBlock(int iCount);
    void Delete(int iIndex);
    void *Ptr()
    { return (m_pList); }
    void *Get(long iIndex)
    { _ASSERTE(iIndex < m_iCount);
        return ((void *) ((size_t) Ptr() + (iIndex * m_iElemSize))); }
    int Size()
    { return (m_iCount * m_iElemSize); }
    int Count()
    { return (m_iCount); }
    void Clear();
    void ClearCount()
    { m_iCount = 0; }

    void InitOnMem(short iElemSize, void *pList, int iCount, int iSize, int iGrowInc=1)
    {
        m_iElemSize = iElemSize;
        m_iGrowInc = (short) iGrowInc;
        m_pList = pList;
        m_iCount = iCount;
        m_iSize = iSize;
        m_bFree = false;
    }

private:
    int Grow(int iCount);
};


//*****************************************************************************
// This template simplifies access to a CStructArray by removing void * and
// adding some operator overloads.
//*****************************************************************************
template <class T> 
class CDynArray : public CStructArray
{
public:
    CDynArray(int iGrowInc=16) :
        CStructArray(sizeof(T), iGrowInc)
    { }
    T *Insert(long iIndex)
        { return ((T *)CStructArray::Insert((int)iIndex)); }
    T *Append()
        { return ((T *)CStructArray::Append()); }
    T *Ptr()
        { return ((T *)CStructArray::Ptr()); }
    T *Get(long iIndex)
        { return (Ptr() + iIndex); }
    T &operator[](long iIndex)
        { return (*(Ptr() + iIndex)); }
    int ItemIndex(T *p)
        { return (((long) p - (long) Ptr()) / sizeof(T)); }
    void Move(int iFrom, int iTo)
    {
        T       tmp;

        _ASSERTE(iFrom >= 0 && iFrom < Count() &&
                 iTo >= 0 && iTo < Count());

        tmp = *(Ptr() + iFrom);
        if (iTo > iFrom)
            memmove(Ptr() + iFrom, Ptr() + iFrom + 1, (iTo - iFrom) * sizeof(T));
        else
            memmove(Ptr() + iFrom + 1, Ptr() + iFrom, (iTo - iFrom) * sizeof(T));
        *(Ptr() + iTo) = tmp;
    }
};

// Some common arrays.
typedef CDynArray<int> INTARRAY;
typedef CDynArray<short> SHORTARRAY;
typedef CDynArray<long> LONGARRAY;
typedef CDynArray<USHORT> USHORTARRAY;
typedef CDynArray<ULONG> ULONGARRAY;
typedef CDynArray<BYTE> BYTEARRAY;
typedef CDynArray<mdToken> TOKENARRAY;

template <class T> class CStackArray : public CStructArray
{
public:
    CStackArray(int iGrowInc=4) :
        CStructArray(iGrowInc),
        m_curPos(0)
    { }

    void Push(T p)
    {
        T *pT = (T *)CStructArray::Insert(m_curPos++);
        _ASSERTE(pT != NULL);
        *pT = p;
    }

    T * Pop()
    {
        T * retPtr;

        _ASSERTE(m_curPos > 0);

        retPtr = (T *)CStructArray::Get(m_curPos-1);
        CStructArray::Delete(m_curPos--);

        return (retPtr);
    }

    int Count()
    {
        return(m_curPos);
    }

private:
    int m_curPos;
};

//*****************************************************************************
// This class implements a storage system for strings.  It stores a bunch of
// strings in a single large chunk of memory and returns an index to the stored
// string.
//*****************************************************************************
class CStringSet
{
    void        *m_pStrings;            // Chunk of memory holding the strings.
    int         m_iUsed;                // Amount of the chunk that is used.
    int         m_iSize;                // Size of the memory chunk.
    int         m_iGrowInc;

public:
    CStringSet(int iGrowInc = 256) :
        m_pStrings(NULL),
        m_iUsed(0),
        m_iSize(0),
        m_iGrowInc(iGrowInc)
    { }
    ~CStringSet();

    int Delete(int iStr);
    int Shrink();
    int Save(LPCTSTR szStr);
    PVOID Ptr()
    { return (m_pStrings); }
    int Size()
    { return (m_iUsed); }
};



//*****************************************************************************
// This template manages a list of free entries by their 0 based offset.  By
// making it a template, you can use whatever size free chain will match your
// maximum count of items.  -1 is reserved.
//*****************************************************************************
template <class T> class TFreeList
{
public:
    void Init(
        T           *rgList,
        int         iCount)
    {
        // Save off values.
        m_rgList = rgList;
        m_iCount = iCount;
        m_iNext = 0;

        // Init free list.
        for (int i=0;  i<iCount - 1;  i++)
            m_rgList[i] = i + 1;
        m_rgList[i] = (T) -1;
    }

    T GetFreeEntry()                        // Index of free item, or -1.
    {
        T           iNext;

        if (m_iNext == (T) -1)
            return (-1);

        iNext = m_iNext;
        m_iNext = m_rgList[m_iNext];
        return (iNext);
    }

    void DelFreeEntry(T iEntry)
    {
        _ASSERTE(iEntry < m_iCount);
        m_rgList[iEntry] = m_iNext;
        m_iNext = iEntry;
    }

    // This function can only be used when it is guaranteed that the free
    // array is contigous, for example, right after creation to quickly
    // get a range of items from the heap.
    void ReserveRange(int iCount)
    {
        _ASSERTE(iCount < m_iCount);
        _ASSERTE(m_iNext == 0);
        m_iNext = iCount;
    }

private:
    T           *m_rgList;              // List of free info.
    int         m_iCount;               // How many entries to manage.
    T           m_iNext;                // Next item to get.
};


//*****************************************************************************
// This template will manage a pre allocated pool of fixed sized items.
//*****************************************************************************
template <class T, int iMax, class TFree> class TItemHeap
{
public:
    TItemHeap() :
        m_rgList(0),
        m_iCount(0)
    { }

    ~TItemHeap()
    {
        Clear();
    }

    // Retrieve the index of an item that lives in the heap.  Will not work
    // for items that didn't come from this heap.
    TFree ItemIndex(T *p)
    { _ASSERTE(p >= &m_rgList[0] && p <= &m_rgList[m_iCount - 1]);
        _ASSERTE(((ULONG) p - (ULONG) m_rgList) % sizeof(T) == 0);
        return ((TFree) ((ULONG) p - (ULONG) m_rgList) / sizeof(T)); }

    // Retrieve an item that lives in the heap itself.  Overflow items
    // cannot be retrieved using this method.
    T *GetAt(int i)
    {   _ASSERTE(i < m_iCount);
        return (&m_rgList[i]); }

    T *AddEntry()
    {
        // Allocate first time.
        if (!InitList())
            return (0);

        // Get an entry from the free list.  If we don't have any left to give
        // out, then simply allocate a single item from the heap.
        TFree       iEntry;
        if ((iEntry = m_Free.GetFreeEntry()) == (TFree) -1)
            return (new T);

        // Run placement new on the heap entry to init it.
        return (new (&m_rgList[iEntry]) T);
    }

    // Free the entry if it belongs to us, if we allocated it from the heap
    // then delete it for real.
    void DelEntry(T *p)
    {
        if (p >= &m_rgList[0] && p <= &m_rgList[iMax - 1])
        {
            p->~T();
            m_Free.DelFreeEntry(ItemIndex(p));
        }
        else
            delete p;
    }

    // Reserve a range of items from an empty list.
    T *ReserveRange(int iCount)
    {
        // Don't use on existing list.
        _ASSERTE(m_rgList == 0);
        if (!InitList())
            return (0);

        // Heap must have been created large enough to work.
        _ASSERTE(iCount < m_iCount);

        // Mark the range as used, run new on each item, then return first.
        m_Free.ReserveRange(iCount);
        while (iCount--)
            new (&m_rgList[iCount]) T;
        return (&m_rgList[0]);
    }

    void Clear()
    {
        if (m_rgList)
            free(m_rgList);
        m_rgList = 0;
    }

private:
    int InitList()
    {
        if (m_rgList == 0)
        {
            int         iSize = (iMax * sizeof(T)) + (iMax * sizeof(TFree));
            if ((m_rgList = (T *) malloc(iSize)) == 0)
                return (false);
            m_iCount = iMax;
            m_Free.Init((TFree *) &m_rgList[iMax], iMax);
        }
        return (true);
    }

private:
    T           *m_rgList;              // Array of objects to manage.
    int         m_iCount;               // How many items do we have now.
    TFreeList<TFree> m_Free;            // Free list.
};




//*****************************************************************************
//*****************************************************************************
template <class T> class CQuickSort
{
private:
    T           *m_pBase;                   // Base of array to sort.
    SSIZE_T     m_iCount;                   // How many items in array.
    SSIZE_T     m_iElemSize;                // Size of one element.

public:
    CQuickSort(
        T           *pBase,                 // Address of first element.
        SSIZE_T     iCount) :               // How many there are.
        m_pBase(pBase),
        m_iCount(iCount),
        m_iElemSize(sizeof(T))
        {}

//*****************************************************************************
// Call to sort the array.
//*****************************************************************************
    inline void Sort()
        { SortRange(0, m_iCount - 1); }

//*****************************************************************************
// Override this function to do the comparison.
//*****************************************************************************
    virtual int Compare(                    // -1, 0, or 1
        T           *psFirst,               // First item to compare.
        T           *psSecond)              // Second item to compare.
    {
        return (memcmp(psFirst, psSecond, sizeof(T)));
//      return (::Compare(*psFirst, *psSecond));
    }

private:
    inline void SortRange(
        SSIZE_T     iLeft,
        SSIZE_T     iRight)
    {
        SSIZE_T     iLast;
        SSIZE_T     i;                      // loop variable.

        // if less than two elements you're done.
        if (iLeft >= iRight)
            return;

        // The mid-element is the pivot, move it to the left.
        Swap(iLeft, (iLeft+iRight)/2);
        iLast = iLeft;

        // move everything that is smaller than the pivot to the left.
        for(i = iLeft+1; i <= iRight; i++)
            if (Compare(&m_pBase[i], &m_pBase[iLeft]) < 0)
                Swap(i, ++iLast);

        // Put the pivot to the point where it is in between smaller and larger elements.
        Swap(iLeft, iLast);

        // Sort the each partition.
        SortRange(iLeft, iLast-1);
        SortRange(iLast+1, iRight);
    }

    inline void Swap(
        SSIZE_T     iFirst,
        SSIZE_T     iSecond)
    {
        T           sTemp;
        if (iFirst == iSecond) return;
        sTemp = m_pBase[iFirst];
        m_pBase[iFirst] = m_pBase[iSecond];
        m_pBase[iSecond] = sTemp;
    }

};


//*****************************************************************************
// This template encapsulates a binary search algorithm on the given type
// of data.
//*****************************************************************************
class CBinarySearchILMap;
template <class T> class CBinarySearch
{
    friend class CBinarySearchILMap; // CBinarySearchILMap is to be 
        // instantiated once, then used a bunch of different times on
        // a bunch of different arrays.  We need to declare it a friend
        // in order to reset m_pBase and m_iCount
        
private:
    const T     *m_pBase;                   // Base of array to sort.
    int         m_iCount;                   // How many items in array.

public:
    CBinarySearch(
        const T     *pBase,                 // Address of first element.
        int         iCount) :               // Value to find.
        m_pBase(pBase),
        m_iCount(iCount)
    {}

//*****************************************************************************
// Searches for the item passed to ctor.
//*****************************************************************************
    const T *Find(                          // Pointer to found item in array.
        const T     *psFind,                // The key to find.
        int         *piInsert = NULL)       // Index to insert at.
    {
        int         iMid, iFirst, iLast;    // Loop control.
        int         iCmp;                   // Comparison.

        iFirst = 0;
        iLast = m_iCount - 1;
        while (iFirst <= iLast)
        {
            iMid = (iLast + iFirst) / 2;
            iCmp = Compare(psFind, &m_pBase[iMid]);
            if (iCmp == 0)
            {
                if (piInsert != NULL)
                    *piInsert = iMid;
                return (&m_pBase[iMid]);
            }
            else if (iCmp < 0)
                iLast = iMid - 1;
            else
                iFirst = iMid + 1;
        }
        if (piInsert != NULL)
            *piInsert = iFirst;
        return (NULL);
    }

//*****************************************************************************
// Override this function to do the comparison if a comparison operator is
// not valid for your data type (such as a struct).
//*****************************************************************************
    virtual int Compare(                    // -1, 0, or 1
        const T     *psFirst,               // Key you are looking for.
        const T     *psSecond)              // Item to compare to.
    {
        return (memcmp(psFirst, psSecond, sizeof(T)));
//      return (::Compare(*psFirst, *psSecond));
    }
};


//*****************************************************************************
// This class manages a bit vector. Allocation is done implicity through the
// template declaration, so no init code is required.  Due to this design,
// one should keep the max items reasonable (eg: be aware of stack size and
// other limitations).  The intrinsic size used to store the bit vector can
// be set when instantiating the vector.  The FindFree method will search
// using sizeof(T) for free slots, so pick a size that works well on your
// platform.
//*****************************************************************************
template <class T, int iMaxItems> class CBitVector
{
    T       m_bits[((iMaxItems/(sizeof(T)*8)) + ((iMaxItems%(sizeof(T)*8)) ? 1 : 0))];
    T       m_Used;

public:
    CBitVector()
    {
        memset(&m_bits[0], 0, sizeof(m_bits));
        memset(&m_Used, 0xff, sizeof(m_Used));
    }

//*****************************************************************************
// Get or Set the given bit.
//*****************************************************************************
    int GetBit(int iBit)
    {
        return (m_bits[iBit/(sizeof(T)*8)] & (1 << (iBit & ((sizeof(T) * 8) - 1))));
    }

    void SetBit(int iBit, int bOn)
    {
        if (bOn)
            m_bits[iBit/(sizeof(T)*8)] |= (1 << (iBit & ((sizeof(T) * 8) - 1)));
        else
            m_bits[iBit/(sizeof(T)*8)] &= ~(1 << (iBit & ((sizeof(T) * 8) - 1)));
    }

//*****************************************************************************
// Find the first free slot and return its index.
//*****************************************************************************
    int FindFree()                          // Index or -1.
    {
        int         i,j;                    // Loop control.

        // Check a byte at a time.
        for (i=0;  i<sizeof(m_bits);  i++)
        {
            // Look for the first byte with an open slot.
            if (m_bits[i] != m_Used)
            {
                // Walk each bit in the first free byte.
                for (j=i * sizeof(T) * 8;  j<iMaxItems;  j++)
                {
                    // Use first open one.
                    if (GetBit(j) == 0)
                    {
                        SetBit(j, 1);
                        return (j);
                    }
                }
            }
        }

        // No slots open.
        return (-1);
    }
};

//*****************************************************************************
// This class manages a bit vector. Internally, this class uses CQuickBytes, which
// automatically allocates 512 bytes on the stack. So this overhead must be kept in
// mind while using it.
// This class has to be explicitly initialized.
// @todo: add Methods on this class to get first set bit and next set bit.
//*****************************************************************************
class CDynBitVector
{
    BYTE    *m_bits;
    BYTE    m_Used;
    int     m_iMaxItem;
    int     m_iBitsSet;
    CQuickBytes m_Bytes;

public:
    CDynBitVector() :
        m_bits(NULL),
        m_iMaxItem(0)
    {}

    HRESULT Init(int MaxItems)
    {
        int actualSize = (MaxItems/8) + ((MaxItems%8) ? 1 : 0);

        actualSize = ALIGN4BYTE(actualSize);

        m_Bytes.Alloc(actualSize);
        if(!m_Bytes)
        {
            return(E_OUTOFMEMORY);
        }

        m_bits = (BYTE *) m_Bytes.Ptr();

        m_iMaxItem = MaxItems;
        m_iBitsSet = 0;

        memset(m_bits, 0, m_Bytes.Size());
        memset(&m_Used, 0xff, sizeof(m_Used));
        return(S_OK);
    }

//*****************************************************************************
// Get, Set the given bit.
//*****************************************************************************
    int GetBit(int iBit)
    {
        return (m_bits[iBit/8] & (1 << (iBit & 7)));
    }

    void SetBit(int iBit, int bOn)
    {
        if (bOn)
        {
            m_bits[iBit/8] |= (1 << (iBit & 7));
            m_iBitsSet++;
        }
        else
        {
            m_bits[iBit/8] &= ~(1 << (iBit & 7));
            m_iBitsSet--;
        }
    }

//******************************************************************************
// Not all the bits.
//******************************************************************************
    void NotBits()
    {
        ULONG *pCurrent = (ULONG *)m_bits;
        SIZE_T cbSize = Size()/4;
        int iBitsSet;

        m_iBitsSet = 0;

        for(SIZE_T i=0; i<cbSize; i++, pCurrent++)
        {
            iBitsSet = CountBits(*pCurrent);
            m_iBitsSet += (8 - iBitsSet);
            *pCurrent = ~(*pCurrent);
        }
    }

    BYTE * Ptr()
    { return(m_bits); }

    SIZE_T Size()
    { return(m_Bytes.Size()); }

    int BitsSet()
    { return(m_iBitsSet);}
};

//*****************************************************************************
// This is a generic class used to manage an array of items of fixed size.
// It exposes methods allow the size of the array and bulk reads and writes
// to be performed, making it good for cursor fetching.  Memory usage is not
// very bright, using the CRT.  You should only use this class when the overall
// size of the memory must be controlled externally, as is the case when you
// are doing bulk database fetches from a cursor.  Use CStructArray or
// CUnorderedArray for all other cases.
//*****************************************************************************
template <class T> class CDynFetchArray
{
public:
//*****************************************************************************
// ctor inits all values.
//*****************************************************************************
    CDynFetchArray(int iGrowInc) :
        m_pList(NULL),
        m_iCount(0),
        m_iMax(0),
        m_iGrowInc(iGrowInc)
    {
    }

//*****************************************************************************
// Clear any memory allocated.
//*****************************************************************************
    ~CDynFetchArray()
    {
        Clear();
    }

    ULONG Count()
        { return (m_iCount); }

    void SetCount(ULONG iCount)
        { m_iCount = iCount; }

    ULONG MaxCount()
        { return (m_iMax); }

    T *GetAt(ULONG i)
        { return (&m_pList[i]); }

//*****************************************************************************
// Allow for ad-hoc appending of values.  This will grow as required.
//*****************************************************************************
    T *Append(T *pval=NULL)
    {
        T       *pItem;
        if (m_iCount + 1 > m_iMax && Grow() == NULL)
            return (NULL);
        pItem = GetAt(m_iCount++);
        if (pval) *pItem = *pval;
        return (pItem);
    }

//*****************************************************************************
// Grow the internal list by the number of pages (1 set of grow inc size)
// desired. This may move the pointer, invalidating any previously fetched values.
//*****************************************************************************
    T *Grow(ULONG iNewPages=1)
    {
        T       *pList;
        DWORD   dwNewSize;

        // Figure out size required.
        dwNewSize = (m_iMax + (iNewPages * m_iGrowInc)) * sizeof(T);

        // Realloc/alloc a block for the new max.
        if (m_pList)
            pList = (T *)HeapReAlloc(GetProcessHeap(), 0, m_pList, dwNewSize);
        else
            pList = (T *)HeapAlloc(GetProcessHeap(), 0, dwNewSize);
        if (!pList)
            return (NULL);

        // If successful, save off the values and return the first item on the
        // new page.
        m_pList = pList;
        m_iMax += (iNewPages * m_iGrowInc);
        return (GetAt(m_iMax - (iNewPages * m_iGrowInc)));
    }

//*****************************************************************************
// Reduce the internal array down to just the size required by count.
//*****************************************************************************
    void Shrink()
    {
        T       *pList;

        if (m_iMax == m_iCount)
            return;

        if (m_iCount == 0)
        {
            Clear();
            return;
        }

        pList = (T *)HeapReAlloc(GetProcessHeap(), 0, m_pList, m_iCount * sizeof(T));
        _ASSERTE(pList);
        if (pList)
        {
            m_pList = pList;
            m_iMax = m_iCount;
        }
    }

//*****************************************************************************
// Free up all memory.
//*****************************************************************************
    void Clear()
    {
        if (m_pList)
            HeapFree(GetProcessHeap(), 0, m_pList);
        m_pList = NULL;
        m_iCount = m_iMax = 0;
    };

private:
    T           *m_pList;               // The list of items.
    ULONG       m_iCount;               // How many items do we have.
    ULONG       m_iMax;                 // How many could we have.
    int         m_iGrowInc;             // Grow by this many elements.
};


//*****************************************************************************
// The information that the hash table implementation stores at the beginning
// of every record that can be but in the hash table.
//*****************************************************************************
struct HASHENTRY
{
    USHORT      iPrev;                  // Previous bucket in the chain.
    USHORT      iNext;                  // Next bucket in the chain.
};

struct FREEHASHENTRY : HASHENTRY
{
    USHORT      iFree;
};

//*****************************************************************************
// Used by the FindFirst/FindNextEntry functions.  These api's allow you to
// do a sequential scan of all entries.
//*****************************************************************************
struct HASHFIND
{
    USHORT      iBucket;            // The next bucket to look in.
    USHORT      iNext;
};


//*****************************************************************************
// This is a class that implements a chain and bucket hash table.  The table
// is actually supplied as an array of structures by the user of this class
// and this maintains the chains in a HASHENTRY structure that must be at the
// beginning of every structure placed in the hash table.  Immediately
// following the HASHENTRY must be the key used to hash the structure.
//*****************************************************************************
class CHashTable
{
    friend class DebuggerRCThread; //RCthread actually needs access to
    //fields of derrived class DebuggerPatchTable
    
protected:
    BYTE        *m_pcEntries;           // Pointer to the array of structs.
    USHORT      m_iEntrySize;           // Size of the structs.
    USHORT      m_iBuckets;             // # of chains we are hashing into.
    USHORT      *m_piBuckets;           // Ptr to the array of bucket chains.

    HASHENTRY *EntryPtr(USHORT iEntry)
    { return ((HASHENTRY *) (m_pcEntries + (iEntry * m_iEntrySize))); }

    USHORT     ItemIndex(HASHENTRY *p)
    {
        //
        // The following Index calculation is not safe on 64-bit platforms,
        // so we'll assert a range check in debug, which will catch SOME
        // offensive usages.  It also seems, to my eye, not to be safe on 
        // 32-bit platforms, but the 32-bit compilers don't seem to complain
        // about it.  Perhaps our warning levels are set too low? 
        //
        // [[@TODO: brianbec]]
        //

        ULONG ret = (ULONG)(((BYTE *) p - m_pcEntries) / m_iEntrySize);
        _ASSERTE(ret == USHORT(ret));
        return USHORT(ret);
    }
    

public:
    CHashTable(
        USHORT      iBuckets) :         // # of chains we are hashing into.
        m_iBuckets(iBuckets),
        m_piBuckets(NULL),
        m_pcEntries(NULL)
    {
        _ASSERTE(iBuckets < 0xffff);
    }
    ~CHashTable()
    {
        if (m_piBuckets != NULL)
        {
            delete [] m_piBuckets;
            m_piBuckets = NULL;
        }
    }

//*****************************************************************************
// This is the second part of construction where we do all of the work that
// can fail.  We also take the array of structs here because the calling class
// presumably needs to allocate it in its NewInit.
//*****************************************************************************
    HRESULT NewInit(                    // Return status.
        BYTE        *pcEntries,         // Array of structs we are managing.
        USHORT      iEntrySize);        // Size of the entries.

//*****************************************************************************
// Return a boolean indicating whether or not this hash table has been inited.
//*****************************************************************************
    int IsInited()
    { return (m_piBuckets != NULL); }

//*****************************************************************************
// This can be called to change the pointer to the table that the hash table
// is managing.  You might call this if (for example) you realloc the size
// of the table and its pointer is different.
//*****************************************************************************
    void SetTable(
        BYTE        *pcEntries)         // Array of structs we are managing.
    {
        m_pcEntries = pcEntries;
    }

//*****************************************************************************
// Clear the hash table as if there were nothing in it.
//*****************************************************************************
    void Clear()
    {
        _ASSERTE(m_piBuckets != NULL);
        memset(m_piBuckets, 0xff, m_iBuckets * sizeof(USHORT));
    }

//*****************************************************************************
// Add the struct at the specified index in m_pcEntries to the hash chains.
//*****************************************************************************
    BYTE *Add(                          // New entry.
        USHORT      iHash,              // Hash value of entry to add.
        USHORT      iIndex);            // Index of struct in m_pcEntries.

//*****************************************************************************
// Delete the struct at the specified index in m_pcEntries from the hash chains.
//*****************************************************************************
    void Delete(
        USHORT      iHash,              // Hash value of entry to delete.
        USHORT      iIndex);            // Index of struct in m_pcEntries.

    void Delete(
        USHORT      iHash,              // Hash value of entry to delete.
        HASHENTRY   *psEntry);          // The struct to delete.

//*****************************************************************************
// The item at the specified index has been moved, update the previous and
// next item.
//*****************************************************************************
    void Move(
        USHORT      iHash,              // Hash value for the item.
        USHORT      iNew);              // New location.

//*****************************************************************************
// Search the hash table for an entry with the specified key value.
//*****************************************************************************
    BYTE *Find(                         // Index of struct in m_pcEntries.
        USHORT      iHash,              // Hash value of the item.
        BYTE        *pcKey);            // The key to match.

//*****************************************************************************
// Search the hash table for the next entry with the specified key value.
//*****************************************************************************
    USHORT FindNext(                    // Index of struct in m_pcEntries.
        BYTE        *pcKey,             // The key to match.
        USHORT      iIndex);            // Index of previous match.

//*****************************************************************************
// Returns the first entry in the first hash bucket and inits the search
// struct.  Use the FindNextEntry function to continue walking the list.  The
// return order is not gauranteed.
//*****************************************************************************
    BYTE *FindFirstEntry(               // First entry found, or 0.
        HASHFIND    *psSrch)            // Search object.
    {
        if (m_piBuckets == 0)
            return (0);
        psSrch->iBucket = 1;
        psSrch->iNext = m_piBuckets[0];
        return (FindNextEntry(psSrch));
    }

//*****************************************************************************
// Returns the next entry in the list.
//*****************************************************************************
    BYTE *FindNextEntry(                // The next entry, or0 for end of list.
        HASHFIND    *psSrch);           // Search object.

protected:
    virtual inline BOOL Cmp(const BYTE *pc1, const HASHENTRY *pc2) = 0;
};


//*****************************************************************************
// Allocater classes for the CHashTableAndDataclass.  One is for VirtualAlloc
// and the other for malloc.
//*****************************************************************************
class CVMemData
{
public:
    static BYTE *Alloc(int iSize, int iMaxSize)
    {
        BYTE        *pPtr;

        _ASSERTE((iSize & 4095) == 0);
        _ASSERTE((iMaxSize & 4095) == 0);
        if ((pPtr = (BYTE *) VirtualAlloc(NULL, iMaxSize,
                                        MEM_RESERVE, PAGE_NOACCESS)) == NULL ||
            VirtualAlloc(pPtr, iSize, MEM_COMMIT, PAGE_READWRITE) == NULL)
        {
            if (pPtr)
            {
                VirtualFree(pPtr, 0, MEM_RELEASE);
            }
            return (NULL);
        }
        return (pPtr);
    }
    static void Free(BYTE *pPtr, int iSize)
    {
        _ASSERTE((iSize & 4095) == 0);
        VirtualFree(pPtr, iSize, MEM_DECOMMIT);
        VirtualFree(pPtr, 0, MEM_RELEASE);
    }
    static BYTE *Grow(BYTE *pPtr, int iCurSize)
    {
        _ASSERTE((iCurSize & 4095) == 0);
        return ((BYTE *) VirtualAlloc(pPtr + iCurSize, GrowSize(), MEM_COMMIT, PAGE_READWRITE));
    }
    static int RoundSize(int iSize)
    {
        return ((iSize + 4095) & ~4095);
    }
    static int GrowSize()
    {
        return (4096);
    }
};

class CNewData
{
public:
    static BYTE *Alloc(int iSize, int iMaxSize)
    {
        return ((BYTE *) malloc(iSize));
    }
    static void Free(BYTE *pPtr, int iSize)
    {
        free(pPtr);
    }
    static BYTE *Grow(BYTE *&pPtr, int iCurSize)
    {
        void *p = realloc(pPtr, iCurSize + GrowSize());
        if (p == 0) return (0);
        return (pPtr = (BYTE *) p);
    }
    static int RoundSize(int iSize)
    {
        return (iSize);
    }
    static int GrowSize()
    {
        return (256);
    }
};


//*****************************************************************************
// This simple code handles a contiguous piece of memory.  Growth is done via
// realloc, so pointers can move.  This class just cleans up the amount of code
// required in every function that uses this type of data structure.
//*****************************************************************************
class CMemChunk
{
public:
    CMemChunk() : m_pbData(0), m_cbSize(0), m_cbNext(0) { }
    ~CMemChunk()
    {
        Clear();
    }

    BYTE *GetChunk(int cbSize)
    {
        BYTE *p;
        if (m_cbSize - m_cbNext < cbSize)
        {
            int cbNew = max(cbSize, 512);
            p = (BYTE *) realloc(m_pbData, m_cbSize + cbNew);
            if (!p) return (0);
            m_pbData = p;
            m_cbSize += cbNew;
        }
        p = m_pbData + m_cbNext;
        m_cbNext += cbSize;
        return (p);
    }

    // Can only delete the last unused chunk.  no free list.
    void DelChunk(BYTE *p, int cbSize)
    {
        _ASSERTE(p >= m_pbData && p < m_pbData + m_cbNext);
        if (p + cbSize  == m_pbData + m_cbNext)
            m_cbNext -= cbSize;
    }

    int Size()
    { return (m_cbSize); }

    int Offset()
    { return (m_cbNext); }

    BYTE *Ptr(int cbOffset = 0)
    {
        _ASSERTE(m_pbData && m_cbSize);
        _ASSERTE(cbOffset < m_cbSize);
        return (m_pbData + cbOffset);
    }

    void Clear()
    {
        if (m_pbData)
            free(m_pbData);
        m_pbData = 0;
        m_cbSize = m_cbNext = 0;
    }

private:
    BYTE        *m_pbData;              // Data pointer.
    int         m_cbSize;               // Size of current data.
    int         m_cbNext;               // Next place to write.
};


//*****************************************************************************
// This implements a hash table and the allocation and management of the
// records that are being hashed.
//*****************************************************************************
template <class M>
class CHashTableAndData : protected CHashTable
{
public:
    USHORT      m_iFree;
    USHORT      m_iEntries;

public:
    CHashTableAndData(
        USHORT      iBuckets) :         // # of chains we are hashing into.
        CHashTable(iBuckets)
    {}
    ~CHashTableAndData()
    {
        if (m_pcEntries != NULL)
            M::Free(m_pcEntries, M::RoundSize(m_iEntries * m_iEntrySize));
    }

//*****************************************************************************
// This is the second part of construction where we do all of the work that
// can fail.  We also take the array of structs here because the calling class
// presumably needs to allocate it in its NewInit.
//*****************************************************************************
    HRESULT NewInit(                    // Return status.
        USHORT      iEntries,           // # of entries.
        USHORT      iEntrySize,         // Size of the entries.
        int         iMaxSize);          // Max size of data.

//*****************************************************************************
// Clear the hash table as if there were nothing in it.
//*****************************************************************************
    void Clear()
    {
        m_iFree = 0;
        InitFreeChain(0, m_iEntries);
        CHashTable::Clear();
    }

//*****************************************************************************
//*****************************************************************************
    BYTE *Add(
        USHORT      iHash)              // Hash value of entry to add.
    {
        FREEHASHENTRY *psEntry;

        // Make the table bigger if necessary.
        if (m_iFree == 0xffff && !Grow())
            return (NULL);

        // Add the first entry from the free list to the hash chain.
        psEntry = (FREEHASHENTRY *) CHashTable::Add(iHash, m_iFree);
        m_iFree = psEntry->iFree;
        return ((BYTE *) psEntry);
    }

//*****************************************************************************
// Delete the struct at the specified index in m_pcEntries from the hash chains.
//*****************************************************************************
    void Delete(
        USHORT      iHash,              // Hash value of entry to delete.
        USHORT      iIndex)             // Index of struct in m_pcEntries.
    {
        CHashTable::Delete(iHash, iIndex);
        ((FREEHASHENTRY *) EntryPtr(iIndex))->iFree = m_iFree;
        m_iFree = iIndex;
    }

    void Delete(
        USHORT      iHash,              // Hash value of entry to delete.
        HASHENTRY   *psEntry)           // The struct to delete.
    {
        CHashTable::Delete(iHash, psEntry);
        ((FREEHASHENTRY *) psEntry)->iFree = m_iFree;
        m_iFree = ItemIndex(psEntry);
    }

    // This is a sad legacy hack. The debugger's patch table (implemented as this 
    // class) is shared across process. We publish the runtime offsets of
    // some key fields. Since those fields are private, we have to provide 
    // accessors here. So if you're not using these functions, don't start.
    // We can hopefully remove them.
    // Note that we can't just make RCThread a friend of this class (we tried
    // originally) because the inheritence chain has a private modifier,
    // so DebuggerPatchTable::m_pcEntries is illegal.
    static SIZE_T helper_GetOffsetOfEntries()
    {
        return offsetof(CHashTableAndData, m_pcEntries);
    }

    static SIZE_T helper_GetOffsetOfCount()
    {
        return offsetof(CHashTableAndData, m_iEntries);
    }

private:
    void InitFreeChain(USHORT iStart,USHORT iEnd);
    int Grow();
};


//*****************************************************************************
// This is the second part of construction where we do all of the work that
// can fail.  We also take the array of structs here because the calling class
// presumably needs to allocate it in its NewInit.
//*****************************************************************************
template<class M>
HRESULT CHashTableAndData<M>::NewInit(// Return status.
    USHORT      iEntries,               // # of entries.
    USHORT      iEntrySize,             // Size of the entries.
    int         iMaxSize)               // Max size of data.
{
    BYTE        *pcEntries;
    HRESULT     hr;

    // Allocate the memory for the entries.
    if ((pcEntries = M::Alloc(M::RoundSize(iEntries * iEntrySize),
                                M::RoundSize(iMaxSize))) == 0)
        return (E_OUTOFMEMORY);
    m_iEntries = iEntries;

    // Init the base table.
    if (FAILED(hr = CHashTable::NewInit(pcEntries, iEntrySize)))
        M::Free(pcEntries, M::RoundSize(iEntries * iEntrySize));
    else
    {
        // Init the free chain.
        m_iFree = 0;
        InitFreeChain(0, iEntries);
    }
    return (hr);
}

//*****************************************************************************
// Initialize a range of records such that they are linked together to be put
// on the free chain.
//*****************************************************************************
template<class M>
void CHashTableAndData<M>::InitFreeChain(
    USHORT      iStart,                 // Index to start initializing.
    USHORT      iEnd)                   // Index to stop initializing
{
    BYTE        *pcPtr;
    _ASSERTE(iEnd > iStart);

    pcPtr = m_pcEntries + iStart * m_iEntrySize;
    for (++iStart; iStart < iEnd; ++iStart)
    {
        ((FREEHASHENTRY *) pcPtr)->iFree = iStart;
        pcPtr += m_iEntrySize;
    }
    ((FREEHASHENTRY *) pcPtr)->iFree = 0xffff;
}

//*****************************************************************************
// Attempt to increase the amount of space available for the record heap.
//*****************************************************************************
template<class M>
int CHashTableAndData<M>::Grow()        // 1 if successful, 0 if not.
{
    int         iCurSize;               // Current size in bytes.
    int         iEntries;               // New # of entries.

    _ASSERTE(m_pcEntries != NULL);
    _ASSERTE(m_iFree == 0xffff);

    // Compute the current size and new # of entries.
    iCurSize = M::RoundSize(m_iEntries * m_iEntrySize);
    iEntries = (iCurSize + M::GrowSize()) / m_iEntrySize;

    // Make sure we stay below 0xffff.
    if (iEntries >= 0xffff) return (0);

    // Try to expand the array.
    if (M::Grow(m_pcEntries, iCurSize) == 0)
        return (0);

    // Init the newly allocated space.
    InitFreeChain(m_iEntries, iEntries);
    m_iFree = m_iEntries;
    m_iEntries = iEntries;
    return (1);
}

inline ULONG HashBytes(BYTE const *pbData, int iSize)
{
    ULONG   hash = 5381;

    while (--iSize >= 0)
    {
        hash = ((hash << 5) + hash) ^ *pbData;
        ++pbData;
    }
    return hash;
}

// Helper function for hashing a string char by char.
inline ULONG HashStringA(LPCSTR szStr)
{
    ULONG   hash = 5381;
    int     c;

    while ((c = *szStr) != 0)
    {
        hash = ((hash << 5) + hash) ^ c;
        ++szStr;
    }
    return hash;
}

inline ULONG HashString(LPCWSTR szStr)
{
    ULONG   hash = 5381;
    int     c;

    while ((c = *szStr) != 0)
    {
        hash = ((hash << 5) + hash) ^ c;
        ++szStr;
    }
    return hash;
}

// Case-insensitive string hash function.
inline ULONG HashiString(LPCWSTR szStr)
{
    ULONG   hash = 5381;
    while (*szStr != 0)
    {
        hash = ((hash << 5) + hash) ^ CharToUpper(*szStr);
        szStr++;
    }
    return hash;
}

// Case-insensitive string hash function when all of the
// characters in the string are known to be below 0x80.
// Knowing this is much more efficient than calling
// CharToUpper above.
inline ULONG HashiStringKnownLower80(LPCWSTR szStr) {
    ULONG hash = 5381;
    int c;
    int mask = ~0x20;
    while ((c = *szStr)!=0) {
        //If we have a lowercase character, ANDing off 0x20
        //(mask) will make it an uppercase character.
        if (c>='a' && c<='z') {
            c&=mask;
        }
        hash = ((hash << 5) + hash) ^ c;
        ++szStr;
    }
    return hash;
}


// // //  
// // //  See $\src\utilcode\Debug.cpp for "Binomial (K, M, N)", which 
// // //  computes the binomial distribution, with which to compare your
// // //  hash-table statistics.  
// // //



#if defined(_UNICODE) || defined(UNICODE)
#define _tHashString(szStr) HashString(szStr)
#else
#define _tHashString(szStr) HashStringA(szStr)
#endif



//*****************************************************************************
// This helper template is used by the TStringMap to track an item by its
// character name.
//*****************************************************************************
template <class T> class TStringMapItem : HASHENTRY
{
public:
    TStringMapItem() :
        m_szString(0)
    { }
    ~TStringMapItem()
    {
        delete [] m_szString;
    }

    HRESULT SetString(LPCTSTR szValue)
    {
        int         iLen = (int)(_tcslen(szValue) + 1);
        if ((m_szString = new TCHAR[iLen]) == 0)
            return (OutOfMemory());
        _tcscpy(m_szString, szValue);
        return (S_OK);
    }

public:
    LPTSTR      m_szString;             // Key data.
    T           m_value;                // Value for this key.
};


//*****************************************************************************
// This template provides a map from string to item, determined by the template
// type passed in.
//*****************************************************************************
template <class T, int iBuckets=17, class TAllocator=CNewData, int iMaxSize=4096>
class TStringMap :
    protected CHashTableAndData<TAllocator>
{
    typedef CHashTableAndData<TAllocator> Super;

public:
    typedef TStringMapItem<T> TItemType;
    typedef TStringMapItem<long> TOffsetType;

    TStringMap() :
        CHashTableAndData<TAllocator>(iBuckets)
    {
    }

//*****************************************************************************
// This is the second part of construction where we do all of the work that
// can fail.  We also take the array of structs here because the calling class
// presumably needs to allocate it in its NewInit.
//*****************************************************************************
    HRESULT NewInit()                   // Return status.
    {
        return (CHashTableAndData<TAllocator>::NewInit(
                                    (USHORT)(CNewData::GrowSize()/sizeof(TItemType)),
                                    (USHORT)sizeof(TItemType),
                                    iMaxSize));
    }

//*****************************************************************************
// For each item still allocated, invoke its dtor so it frees up anything it
// holds onto.
//*****************************************************************************
    void Clear()
    {
        HASHFIND    sSrch;
        TItemType   *p = (TItemType *) FindFirstEntry(&sSrch);

        while (p != 0)
        {
            // Call dtor on the item, since m_value is contained the scalar
            // dtor will get called.
            p->~TStringMapItem();
            p = (TItemType *) FindNextEntry(&sSrch);
        }
        CHashTableAndData<TAllocator>::Clear();
    }

//*****************************************************************************
// Retrieve an item by name.
//*****************************************************************************
    T *GetItem(                         // Null or object.
        LPCTSTR     szKey)              // What to do the lookup on.
    {
        TItemType   sInfo;
        TItemType   *ptr;               // Working pointer.

        // Create a key.
        sInfo.m_szString = (LPTSTR) szKey;

        // Look it up in the hash table.
        ptr = (TItemType *) Find((USHORT) HashString(szKey), (BYTE *) &sInfo);

        // Don't let dtor free our string.
        sInfo.m_szString = 0;

        // If pointer found, return to caller.  To handle T's that have
        // an operator &(), find raw address without going through &m_value.
        if (ptr)
            return ((T *) ((BYTE *) ptr + offsetof(TOffsetType, m_value)));
        else
            return (0);
    }

//*****************************************************************************
// Initialize an iterator and return the first item.
//*****************************************************************************
    TItemType *FindFirstEntry(
        HASHFIND *psSrch)
    {
        TItemType   *ptr = (TItemType *) Super::FindFirstEntry(psSrch);

        return (ptr);
    }

//*****************************************************************************
// Return the next item, via an iterator.
//*****************************************************************************
    TItemType *FindNextEntry(
        HASHFIND *psSrch)
    {
        TItemType   *ptr = (TItemType *) Super::FindNextEntry(psSrch);

        return (ptr);
    }

//*****************************************************************************
// Add an item to the list.
//*****************************************************************************
    HRESULT AddItem(                    // S_OK, or S_FALSE.
        LPCTSTR     szKey,              // The key value for the item.
        T           &item)              // Thing to add.
    {
        TItemType   *ptr;               // Working pointer.

        // Allocate an entry in the hash table.
        if ((ptr = (TItemType *) Add((USHORT) HashString(szKey))) == 0)
            return (OutOfMemory());

        // Fill the record.
        if (ptr->SetString(szKey) < 0)
        {
            DelItem(ptr);
            return (OutOfMemory());
        }

        // Call the placement new operator on the item so it can init itself.
        // To handle T's that have an operator &(), find raw address without
        // going through &m_value.
        T *p = new ((void *) ((BYTE *) ptr + offsetof(TOffsetType, m_value))) T;
        *p = item;
        return (S_OK);
    }

//*****************************************************************************
// Delete an item.
//*****************************************************************************
    void DelItem(
        LPCTSTR     szKey)                  // What to delete.
    {
        TItemType   sInfo;
        TItemType   *ptr;               // Working pointer.

        // Create a key.
        sInfo.m_szString = (LPTSTR) szKey;

        // Look it up in the hash table.
        ptr = (TItemType *) Find((USHORT) HashString(szKey), (BYTE *) &sInfo);

        // Don't let dtor free our string.
        sInfo.m_szString = 0;

        // If found, delete.
        if (ptr)
            DelItem(ptr);
    }

//*****************************************************************************
// Compare the keys for two collections.
//*****************************************************************************
    BOOL Cmp(                               // 0 or != 0.
        const BYTE  *pData,                 // Raw key data on lookup.
        const HASHENTRY *pElement)          // The element to compare data against.
    {
        TItemType   *p = (TItemType *) (size_t) pElement;
        return (_tcscmp(((TItemType *) pData)->m_szString, p->m_szString));
    }

private:
    void DelItem(
        TItemType   *pItem)             // Entry to delete.
    {
        // Need to destruct this item.
        pItem->~TStringMapItem();
        Delete((USHORT) HashString(pItem->m_szString), (HASHENTRY *)(void *)pItem);
    }
};



//*****************************************************************************
// This class implements a closed hashing table.  Values are hashed to a bucket,
// and if that bucket is full already, then the value is placed in the next
// free bucket starting after the desired target (with wrap around).  If the
// table becomes 75% full, it is grown and rehashed to reduce lookups.  This
// class is best used in a reltively small lookup table where hashing is
// not going to cause many collisions.  By not having the collision chain
// logic, a lot of memory is saved.
//
// The user of the template is required to supply several methods which decide
// how each element can be marked as free, deleted, or used.  It would have
// been possible to write this with more internal logic, but that would require
// either (a) more overhead to add status on top of elements, or (b) hard
// coded types like one for strings, one for ints, etc... This gives you the
// flexibility of adding logic to your type.
//*****************************************************************************
class CClosedHashBase
{
    BYTE *EntryPtr(int iEntry)
    { return (m_rgData + (iEntry * m_iEntrySize)); }
    BYTE *EntryPtr(int iEntry, BYTE *rgData)
    { return (rgData + (iEntry * m_iEntrySize)); }

public:
    enum ELEMENTSTATUS
    {
        FREE,                               // Item is not in use right now.
        DELETED,                            // Item is deleted.
        USED                                // Item is in use.
    };

    CClosedHashBase(
        int         iBuckets,               // How many buckets should we start with.
        int         iEntrySize,             // Size of an entry.
        bool        bPerfect) :             // true if bucket size will hash with no collisions.
        m_bPerfect(bPerfect),
        m_iBuckets(iBuckets),
        m_iEntrySize(iEntrySize),
        m_iCount(0),
        m_iCollisions(0),
        m_rgData(0)
    {
        m_iSize = iBuckets + 7;
    }

    ~CClosedHashBase()
    {
        Clear();
    }

    virtual void Clear()
    {
        delete [] m_rgData;
        m_iCount = 0;
        m_iCollisions = 0;
        m_rgData = 0;
    }

//*****************************************************************************
// Accessors for getting at the underlying data.  Be careful to use Count()
// only when you want the number of buckets actually used.
//*****************************************************************************

    int Count()
    { return (m_iCount); }

    int Collisions()
    { return (m_iCollisions); }

    int Buckets()
    { return (m_iBuckets); }

    void SetBuckets(int iBuckets, bool bPerfect=false)
    {
        _ASSERTE(m_rgData == 0);
        m_iBuckets = iBuckets;
        m_iSize = m_iBuckets + 7;
        m_bPerfect = bPerfect;
    }

    BYTE *Data()
    { return (m_rgData); }

//*****************************************************************************
// Add a new item to hash table given the key value.  If this new entry
// exceeds maximum size, then the table will grow and be re-hashed, which
// may cause a memory error.
//*****************************************************************************
    BYTE *Add(                              // New item to fill out on success.
        void        *pData)                 // The value to hash on.
    {
        // If we haven't allocated any memory, or it is too small, fix it.
        if (!m_rgData || ((m_iCount + 1) > (m_iSize * 3 / 4) && !m_bPerfect))
        {
            if (!ReHash())
                return (0);
        }

        return (DoAdd(pData, m_rgData, m_iBuckets, m_iSize, m_iCollisions, m_iCount));
    }

//*****************************************************************************
// Delete the given value.  This will simply mark the entry as deleted (in
// order to keep the collision chain intact).  There is an optimization that
// consecutive deleted entries leading up to a free entry are themselves freed
// to reduce collisions later on.
//*****************************************************************************
    void Delete(
        void        *pData);                // Key value to delete.


//*****************************************************************************
//  Callback function passed to DeleteLoop.
//*****************************************************************************
    typedef BOOL (* DELETELOOPFUNC)(        // Delete current item?
         BYTE *pEntry,                      // Bucket entry to evaluate
         void *pCustomizer);                // User-defined value

//*****************************************************************************
// Iterates over all active values, passing each one to pDeleteLoopFunc.
// If pDeleteLoopFunc returns TRUE, the entry is deleted. This is safer
// and faster than using FindNext() and Delete().
//*****************************************************************************
    void DeleteLoop(
        DELETELOOPFUNC pDeleteLoopFunc,     // Decides whether to delete item
        void *pCustomizer);                 // Extra value passed to deletefunc.


//*****************************************************************************
// Lookup a key value and return a pointer to the element if found.
//*****************************************************************************
    BYTE *Find(                             // The item if found, 0 if not.
        void        *pData);                // The key to lookup.

//*****************************************************************************
// Look for an item in the table.  If it isn't found, then create a new one and
// return that.
//*****************************************************************************
    BYTE *FindOrAdd(                        // The item if found, 0 if not.
        void        *pData,                 // The key to lookup.
        bool        &bNew);                 // true if created.

//*****************************************************************************
// The following functions are used to traverse each used entry.  This code
// will skip over deleted and free entries freeing the caller up from such
// logic.
//*****************************************************************************
    BYTE *GetFirst()                        // The first entry, 0 if none.
    {
        int         i;                      // Loop control.

        // If we've never allocated the table there can't be any to get.
        if (m_rgData == 0)
            return (0);

        // Find the first one.
        for (i=0;  i<m_iSize;  i++)
        {
            if (Status(EntryPtr(i)) != FREE && Status(EntryPtr(i)) != DELETED)
                return (EntryPtr(i));
        }
        return (0);
    }

    BYTE *GetNext(BYTE *Prev)               // The next entry, 0 if done.
    {
        int         i;                      // Loop control.

        for (i = (int)(((size_t) Prev - (size_t) &m_rgData[0]) / m_iEntrySize) + 1; i<m_iSize;  i++)
        {
            if (Status(EntryPtr(i)) != FREE && Status(EntryPtr(i)) != DELETED)
                return (EntryPtr(i));
        }
        return (0);
    }

private:
//*****************************************************************************
// Hash is called with a pointer to an element in the table.  You must override
// this method and provide a hash algorithm for your element type.
//*****************************************************************************
    virtual unsigned long Hash(             // The key value.
        void const  *pData)=0;              // Raw data to hash.

//*****************************************************************************
// Compare is used in the typical memcmp way, 0 is eqaulity, -1/1 indicate
// direction of miscompare.  In this system everything is always equal or not.
//*****************************************************************************
    virtual unsigned long Compare(          // 0, -1, or 1.
        void const  *pData,                 // Raw key data on lookup.
        BYTE        *pElement)=0;           // The element to compare data against.

//*****************************************************************************
// Return true if the element is free to be used.
//*****************************************************************************
    virtual ELEMENTSTATUS Status(           // The status of the entry.
        BYTE        *pElement)=0;           // The element to check.

//*****************************************************************************
// Sets the status of the given element.
//*****************************************************************************
    virtual void SetStatus(
        BYTE        *pElement,              // The element to set status for.
        ELEMENTSTATUS eStatus)=0;           // New status.

//*****************************************************************************
// Returns the internal key value for an element.
//*****************************************************************************
    virtual void *GetKey(                   // The data to hash on.
        BYTE        *pElement)=0;           // The element to return data ptr for.

//*****************************************************************************
// This helper actually does the add for you.
//*****************************************************************************
    BYTE *DoAdd(void *pData, BYTE *rgData, int &iBuckets, int iSize,
                int &iCollisions, int &iCount);

//*****************************************************************************
// This function is called either to init the table in the first place, or
// to rehash the table if we ran out of room.
//*****************************************************************************
    bool ReHash();                          // true if successful.

//*****************************************************************************
// Walk each item in the table and mark it free.
//*****************************************************************************
    void InitFree(BYTE *ptr, int iSize)
    {
        int         i;
        for (i=0;  i<iSize;  i++, ptr += m_iEntrySize)
            SetStatus(ptr, FREE);
    }

private:
    bool        m_bPerfect;                 // true if the table size guarantees
                                            //  no collisions.
    int         m_iBuckets;                 // How many buckets do we have.
    int         m_iEntrySize;               // Size of an entry.
    int         m_iSize;                    // How many elements can we have.
    int         m_iCount;                   // How many items are used.
    int         m_iCollisions;              // How many have we had.
    BYTE        *m_rgData;                  // Data element list.
};

template <class T> class CClosedHash : public CClosedHashBase
{
public:
    CClosedHash(
        int         iBuckets,               // How many buckets should we start with.
        bool        bPerfect=false) :       // true if bucket size will hash with no collisions.
        CClosedHashBase(iBuckets, sizeof(T), bPerfect)
    {
    }

    T &operator[](long iIndex)
    { return ((T &) *(Data() + (iIndex * sizeof(T)))); }


//*****************************************************************************
// Add a new item to hash table given the key value.  If this new entry
// exceeds maximum size, then the table will grow and be re-hashed, which
// may cause a memory error.
//*****************************************************************************
    T *Add(                                 // New item to fill out on success.
        void        *pData)                 // The value to hash on.
    {
        return ((T *) CClosedHashBase::Add(pData));
    }

//*****************************************************************************
// Lookup a key value and return a pointer to the element if found.
//*****************************************************************************
    T *Find(                                // The item if found, 0 if not.
        void        *pData)                 // The key to lookup.
    {
        return ((T *) CClosedHashBase::Find(pData));
    }

//*****************************************************************************
// Look for an item in the table.  If it isn't found, then create a new one and
// return that.
//*****************************************************************************
    T *FindOrAdd(                           // The item if found, 0 if not.
        void        *pData,                 // The key to lookup.
        bool        &bNew)                  // true if created.
    {
        return ((T *) CClosedHashBase::FindOrAdd(pData, bNew));
    }


//*****************************************************************************
// The following functions are used to traverse each used entry.  This code
// will skip over deleted and free entries freeing the caller up from such
// logic.
//*****************************************************************************
    T *GetFirst()                           // The first entry, 0 if none.
    {
        return ((T *) CClosedHashBase::GetFirst());
    }

    T *GetNext(T *Prev)                     // The next entry, 0 if done.
    {
        return ((T *) CClosedHashBase::GetNext((BYTE *) Prev));
    }
};


//*****************************************************************************
// Closed hash with typed parameters.  The derived class is the second
//  parameter to the template.  The derived class must implement:
//    unsigned long Hash(const T *pData);
//    unsigned long Compare(const T *p1, T *p2);
//    ELEMENTSTATUS Status(T *pEntry);
//    void SetStatus(T *pEntry, ELEMENTSTATUS s);
//    void* GetKey(T *pEntry);
//*****************************************************************************
template<class T, class H>class CClosedHashEx : public CClosedHash<T>
{
public:
    CClosedHashEx(
        int         iBuckets,               // How many buckets should we start with.
        bool        bPerfect=false) :       // true if bucket size will hash with no collisions.
        CClosedHash<T> (iBuckets, bPerfect) 
    {
    }
    
    unsigned long Hash(const void *pData) {return static_cast<H*>(this)->Hash((const T*)pData);}

    unsigned long Compare(const void *p1, BYTE *p2) {return static_cast<H*>(this)->Compare((const T*)p1, (T*)p2);}

    ELEMENTSTATUS Status(BYTE *p) {return static_cast<H*>(this)->Status((T*)p);}

    void SetStatus(BYTE *p, ELEMENTSTATUS s) {static_cast<H*>(this)->SetStatus((T*)p, s);}

    void* GetKey(BYTE *p) {return static_cast<H*>(this)->GetKey((T*)p);}
};


//*****************************************************************************
// This template is another form of a closed hash table.  It handles collisions
// through a linked chain.  To use it, derive your hashed item from HASHLINK
// and implement the virtual functions required.  1.5 * ibuckets will be
// allocated, with the extra .5 used for collisions.  If you add to the point
// where no free nodes are available, the entire table is grown to make room.
// The advantage to this system is that collisions are always directly known,
// there either is one or there isn't.
//*****************************************************************************
struct HASHLINK
{
    ULONG       iNext;                  // Offset for next entry.
};

template <class T> class CChainedHash
{
public:
    CChainedHash(int iBuckets=32) :
        m_iBuckets(iBuckets),
        m_rgData(0),
        m_iFree(0),
        m_iCount(0),
        m_iMaxChain(0)
    {
        m_iSize = iBuckets + (iBuckets / 2);
    }

    ~CChainedHash()
    {
        if (m_rgData)
            free(m_rgData);
    }

    void SetBuckets(int iBuckets)
    {
        _ASSERTE(m_rgData == 0);
        m_iBuckets = iBuckets;
        m_iSize = iBuckets + (iBuckets / 2);
    }

    T *Add(void const *pData)
    {
        ULONG       iHash;
        int         iBucket;
        T           *pItem;

        // Build the list if required.
        if (m_rgData == 0 || m_iFree == 0xffffffff)
        {
            if (!ReHash())
                return (0);
        }

        // Hash the item and pick a bucket.
        iHash = Hash(pData);
        iBucket = iHash % m_iBuckets;

        // Use the bucket if it is free.
        if (InUse(&m_rgData[iBucket]) == false)
        {
            pItem = &m_rgData[iBucket];
            pItem->iNext = 0xffffffff;
        }
        // Else take one off of the free list for use.
        else
        {
            ULONG       iEntry;

            // Pull an item from the free list.
            iEntry = m_iFree;
            pItem = &m_rgData[m_iFree];
            m_iFree = pItem->iNext;

            // Link the new node in after the bucket.
            pItem->iNext = m_rgData[iBucket].iNext;
            m_rgData[iBucket].iNext = iEntry;
        }
        ++m_iCount;
        return (pItem);
    }

    T *Find(void const *pData, bool bAddIfNew=false)
    {
        ULONG       iHash;
        int         iBucket;
        T           *pItem;

        // Check states for lookup.
        if (m_rgData == 0)
        {
            // If we won't be adding, then we are through.
            if (bAddIfNew == false)
                return (0);

            // Otherwise, create the table.
            if (!ReHash())
                return (0);
        }

        // Hash the item and pick a bucket.
        iHash = Hash(pData);
        iBucket = iHash % m_iBuckets;

        // If it isn't in use, then there it wasn't found.
        if (!InUse(&m_rgData[iBucket]))
        {
            if (bAddIfNew == false)
                pItem = 0;
            else
            {
                pItem = &m_rgData[iBucket];
                pItem->iNext = 0xffffffff;
                ++m_iCount;
            }
        }
        // Scan the list for the one we want.
        else
        {
            ULONG iChain = 0;
            for (pItem=(T *) &m_rgData[iBucket];  pItem;  pItem=GetNext(pItem))
            {
                if (Cmp(pData, pItem) == 0)
                    break;
                ++iChain;
            }

            if (!pItem && bAddIfNew)
            {
                ULONG       iEntry;

                // Record maximum chain length.
                if (iChain > m_iMaxChain)
                    m_iMaxChain = iChain;
                
                // Now need more room.
                if (m_iFree == 0xffffffff)
                {
                    if (!ReHash())
                        return (0);
                }

                // Pull an item from the free list.
                iEntry = m_iFree;
                pItem = &m_rgData[m_iFree];
                m_iFree = pItem->iNext;

                // Link the new node in after the bucket.
                pItem->iNext = m_rgData[iBucket].iNext;
                m_rgData[iBucket].iNext = iEntry;
                ++m_iCount;
            }
        }
        return (pItem);
    }

    int Count()
    { return (m_iCount); }
    int Buckets()
    { return (m_iBuckets); }
    ULONG MaxChainLength()
    { return (m_iMaxChain); }

    virtual void Clear()
    {
        // Free up the memory.
        if (m_rgData)
        {
            free(m_rgData);
            m_rgData = 0;
        }

        m_rgData = 0;
        m_iFree = 0;
        m_iCount = 0;
        m_iMaxChain = 0;
    }

    virtual bool InUse(T *pItem)=0;
    virtual void SetFree(T *pItem)=0;
    virtual ULONG Hash(void const *pData)=0;
    virtual int Cmp(void const *pData, void *pItem)=0;
private:
    inline T *GetNext(T *pItem)
    {
        if (pItem->iNext != 0xffffffff)
            return ((T *) &m_rgData[pItem->iNext]);
        return (0);
    }

    bool ReHash()
    {
        T           *rgTemp;
        int         iNewSize;

        // If this is a first time allocation, then just malloc it.
        if (!m_rgData)
        {
            if ((m_rgData = (T *) malloc(m_iSize * sizeof(T))) == 0)
                return (false);

            for (int i=0;  i<m_iSize;  i++)
                SetFree(&m_rgData[i]);

            m_iFree = m_iBuckets;
            for (i=m_iBuckets;  i<m_iSize;  i++)
                ((T *) &m_rgData[i])->iNext = i + 1;
            ((T *) &m_rgData[m_iSize - 1])->iNext = 0xffffffff;
            return (true);
        }

        // Otherwise we need more room on the free chain, so allocate some.
        iNewSize = m_iSize + (m_iSize / 2);

        // Allocate/realloc memory.
        if ((rgTemp = (T *) realloc(m_rgData, iNewSize * sizeof(T))) == 0)
            return (false);

        // Init new entries, save the new free chain, and reset internals.
        m_iFree = m_iSize;
        for (int i=m_iFree;  i<iNewSize;  i++)
        {
            SetFree(&rgTemp[i]);
            ((T *) &rgTemp[i])->iNext = i + 1;
        }
        ((T *) &rgTemp[iNewSize - 1])->iNext = 0xffffffff;

        m_rgData = rgTemp;
        m_iSize = iNewSize;
        return (true);
    }

private:
    T           *m_rgData;              // Data to store items in.
    int         m_iBuckets;             // How many buckets we want.
    int         m_iSize;                // How many are allocated.
    int         m_iCount;               // How many are we using.
    ULONG       m_iMaxChain;            // Max chain length.
    ULONG       m_iFree;                // Free chain.
};




//*****************************************************************************
//
//********** String helper functions.
//
//*****************************************************************************

// This macro returns max chars in UNICODE, or bytes in ANSI.
#define _tsizeof(str) (sizeof(str) / sizeof(TCHAR))



//*****************************************************************************
// Clean up the name including removal of trailing blanks.
//*****************************************************************************
HRESULT ValidateName(                   // Return status.
    LPCTSTR     szName,                 // User string to clean.
    LPTSTR      szOutName,              // Output for string.
    int         iMaxName);              // Maximum size of output buffer.

//*****************************************************************************
// This is a hack for case insensitive _tcsstr.
//*****************************************************************************
LPCTSTR StriStr(                        // Pointer to String2 within String1 or NULL.
    LPCTSTR     szString1,              // String we do the search on.
    LPCTSTR     szString2);             // String we are looking for.

//
// String manipulating functions that handle DBCS.
//
inline const char *NextChar(            // Pointer to next char string.
    const char  *szStr)                 // Starting point.
{
    if (!IsDBCSLeadByte(*szStr))
        return (szStr + 1);
    else
        return (szStr + 2);
}

inline char *NextChar(                  // Pointer to next char string.
    char        *szStr)                 // Starting point.
{
    if (!IsDBCSLeadByte(*szStr))
        return (szStr + 1);
    else
        return (szStr + 2);
}

//*****************************************************************************
// Case insensitive string compare using locale-specific information.
//*****************************************************************************
inline int StrICmp(
    LPCTSTR     szString1,              // String to compare.
    LPCTSTR     szString2)              // String to compare.
{
   return (CompareString(LOCALE_USER_DEFAULT, NORM_IGNORECASE, szString1, -1, szString2, -1) - 2);
}

//*****************************************************************************
// Case sensitive string compare using locale-specific information.
//*****************************************************************************
inline int StrCmp(
    LPCTSTR     szString1,              // String to compare.
    LPCTSTR     szString2)              // String to compare.
{
   return (CompareString(LOCALE_USER_DEFAULT, 0, szString1, -1, szString2, -1) - 2);
}


//*****************************************************************************
// Make sure the byte that pc1 is pointing is not a trail byte.
//*****************************************************************************
inline int IsDBCSSafe(
    LPCTSTR     pc1,                    // Byte we are checking.
    LPCTSTR     pcBegin)                // Begining of the string.
{
#ifdef UNICODE
    return (true);
#else
    LPCTSTR     pcSaved = pc1;

    // Find the first non-lead byte.
    while (pc1-- > pcBegin && IsDBCSLeadByte (*pc1));

    // Return if we are safe.
    return ((int) (pcSaved - pc1) & 0x1);
#endif
}

//*****************************************************************************
// Make sure the byte that pc1 is pointing is not a trail byte.
//*****************************************************************************
inline void SetSafeNull(
    LPTSTR      pc1,                    // Byte we are checking.
    LPTSTR      pcBegin)                // Begining of the string.
{
#ifdef _UNICODE
    *pc1 = '\0';
#else
    if (IsDBCSSafe(pc1, pcBegin))
        *pc1 = '\0';
    else
        *(pc1 - 1) = '\0';
#endif
}


//*****************************************************************************
// strncpy and put a NULL at the end of the buffer.
//*****************************************************************************
/*
// This is commented out because we had to comment out Wszlstrcpyn because we didn't
// have a Win98 implementation and nobody was using it. jenh
inline LPTSTR StrNCpy(                  // The destination string.
    LPTSTR      szDest,                 // Destination string.
    LPCTSTR     szSource,               // Source string.
    int         iCopy)                  // Number of bytes to copy.
{
#ifdef UNICODE
    Wszlstrcpyn(szDest, szSource, iCopy);
#else
    lstrcpynA(szDest, szSource, iCopy);
#endif
    SetSafeNull(&szDest[iCopy], szDest);
    return (szDest);
}
*/

//*****************************************************************************
// Returns the number of bytes to copy if we were to copy this string to an
// iMax size buffer (Does not include terminating NULL).
//*****************************************************************************
inline int StrNSize(
    LPCTSTR     szString,               // String to test.
    int         iMax)                   // return value should not exceed iMax.
{
    int     iLen;
#ifdef UNICODE
    iLen = Wszlstrlen(szString);
#else
    iLen = (int)strlen(szString);
#endif
    if (iLen < iMax)
        return (iLen);
    else
    {
#ifndef UNICODE
        if (IsDBCSSafe(&szString[iMax-1], szString) && IsDBCSLeadByte(szString[iMax-1]))
            return(iMax-1);
        else
            return(iMax);
#else
        return (iMax);
#endif
    }
}

//*****************************************************************************
// Size of a char.
//*****************************************************************************
inline int CharSize(
    const TCHAR *pc1)
{
#ifdef _UNICODE
    return 1;
#else
    if (IsDBCSLeadByte (*pc1))
        return 2;
    return 1;
#endif
}

//*****************************************************************************
// Gets rid of the trailing blanks at the end of a string..
//*****************************************************************************
inline void StripTrailBlanks(
    LPTSTR      szString)
{
    LPTSTR      szBlankStart=NULL;      // Beginng of the trailing blanks.
    WORD        iType;                  // Type of the character.

    while (*szString != NULL)
    {
        GetStringTypeEx (LOCALE_USER_DEFAULT, CT_CTYPE1, szString,
                CharSize(szString), &iType);
        if (iType & C1_SPACE)
        {
            if (!szBlankStart)
                szBlankStart = szString;
        }
        else
        {
            if (szBlankStart)
                szBlankStart = NULL;
        }

        szString += CharSize(szString);
    }
    if (szBlankStart)
        *szBlankStart = '\0';
}

//*****************************************************************************
// Parse a string that is a list of strings separated by the specified
// character.  This eliminates both leading and trailing whitespace.  Two
// important notes: This modifies the supplied buffer and changes the szEnv
// parameter to point to the location to start searching for the next token.
// This also skips empty tokens (e.g. two adjacent separators).  szEnv will be
// set to NULL when no tokens remain.  NULL may also be returned if no tokens
// exist in the string.
//*****************************************************************************
char *StrTok(                           // Returned token.
    char        *&szEnv,                // Location to start searching.
    char        ch);                    // Separator character.


//*****************************************************************************
// Return the length portion of a BSTR which is a ULONG before the start of
// the null terminated string.
//*****************************************************************************
inline int GetBstrLen(BSTR bstr)
{
    return *((ULONG *) bstr - 1);
}


//*****************************************************************************
// Class to parse a list of method names and then find a match
//*****************************************************************************

class MethodNamesList
{
    class MethodName
    {    
        LPUTF8      methodName;     // NULL means wildcard
        LPUTF8      className;      // NULL means wildcard
        int         numArgs;        // number of args, -1 is wildcard
        MethodName *next;           // Next name

    friend class MethodNamesList;
    };

    MethodName     *pNames;         // List of names

public:
    MethodNamesList() : pNames(0) {}
    MethodNamesList(LPWSTR str) : pNames(0) { Insert(str); }
    void Insert(LPWSTR str);
    ~MethodNamesList();

    bool IsInList(LPCUTF8 methodName, LPCUTF8 className, PCCOR_SIGNATURE sig);
    bool IsEmpty()  { return pNames == 0; }
};


/**************************************************************************/
/* simple wrappers around the REGUTIL and MethodNameList routines that make
   the lookup lazy */
   
class ConfigDWORD 
{
public:
    ConfigDWORD(LPWSTR keyName, DWORD defaultVal=0) 
        : m_keyName(keyName), m_inited(false), m_value(defaultVal) {}

    DWORD val() { if (!m_inited) init(); return m_value; }
    void setVal(DWORD val) { m_value = val; } 
private:
    void init();
        
private:
    LPWSTR m_keyName;
    DWORD  m_value;
    bool  m_inited;
};

/**************************************************************************/
class ConfigString 
{
public:
    ConfigString(LPWSTR keyName) : m_keyName(keyName), m_inited(false), m_value(0) {}
    LPWSTR val() { if (!m_inited) init(); return m_value; }
    ~ConfigString();

private:
    void init();
        
private:
    LPWSTR m_keyName;
    LPWSTR m_value;
    bool m_inited;
};

/**************************************************************************/
class ConfigMethodSet
{
public:
    ConfigMethodSet(LPWSTR keyName) : m_keyName(keyName), m_inited(false) {}
    bool isEmpty() { if (!m_inited) init(); return m_list.IsEmpty(); }
    bool contains(LPCUTF8 methodName, LPCUTF8 className, PCCOR_SIGNATURE sig);
private:
    void init();

private:
    LPWSTR m_keyName;
    MethodNamesList m_list;
    bool m_inited;
};

//*****************************************************************************
// Smart Pointers for use with COM Objects.  
//
// Based on the CSmartInterface class in Dale Rogerson's technical
// article "Calling COM Objects with Smart Interface Pointers" on MSDN.
//*****************************************************************************

template <class I>
class CIfacePtr
{
public:
//*****************************************************************************
// Construction - Note that it does not AddRef the pointer.  The caller must
// hand this class a reference.
//*****************************************************************************
    CIfacePtr(
        I           *pI = NULL)         // Interface ptr to store.
    :   m_pI(pI)
    {
    }

//*****************************************************************************
// Copy Constructor
//*****************************************************************************
    CIfacePtr(
        const CIfacePtr<I>& rSI)        // Interface ptr to copy.
    :   m_pI(rSI.m_pI)
    {
        if (m_pI != NULL)
            m_pI->AddRef();
    }
   
//*****************************************************************************
// Destruction
//*****************************************************************************
    ~CIfacePtr()
    {
        if (m_pI != NULL)
            m_pI->Release();
    }

//*****************************************************************************
// Assignment Operator for a plain interface pointer.  Note that it does not
// AddRef the pointer.  Making this assignment hands a reference count to this
// class.
//*****************************************************************************
    CIfacePtr<I>& operator=(            // Reference to this class.
        I           *pI)                // Interface pointer.
    {
        if (m_pI != NULL)
            m_pI->Release();
        m_pI = pI;
        return (*this);
    }

//*****************************************************************************
// Assignment Operator for a CIfacePtr class.  Note this releases the reference
// on the current ptr and AddRefs the new one.
//*****************************************************************************
    CIfacePtr<I>& operator=(            // Reference to this class.
        const CIfacePtr<I>& rSI)
    {
        // Only need to AddRef/Release if difference
        if (m_pI != rSI.m_pI)
        {
            if (m_pI != NULL)
                m_pI->Release();

            if ((m_pI = rSI.m_pI) != NULL)
                m_pI->AddRef();
        }
        return (*this);
    }

//*****************************************************************************
// Conversion to a normal interface pointer.
//*****************************************************************************
    operator I*()                       // The contained interface ptr.
    {
        return (m_pI);
    }

//*****************************************************************************
// Deref
//*****************************************************************************
    I* operator->()                     // The contained interface ptr.
    {
        _ASSERTE(m_pI != NULL);
        return (m_pI);
    }

//*****************************************************************************
// Address of
//*****************************************************************************
    I** operator&()                     // Address of the contained iface ptr.
    {
        return (&m_pI);
    }

//*****************************************************************************
// Equality
//*****************************************************************************
    BOOL operator==(                    // TRUE or FALSE.
        I           *pI) const          // An interface ptr to cmp against.
    {
        return (m_pI == pI);
    }

//*****************************************************************************
// In-equality
//*****************************************************************************
    BOOL operator!=(                    // TRUE or FALSE.
        I           *pI) const          // An interface ptr to cmp against.
    {
        return (m_pI != pI);
    }

//*****************************************************************************
// Negation
//*****************************************************************************
    BOOL operator!() const              // TRUE if NULL, FALSE otherwise.
    {
        return (!m_pI);
    }

protected:
    I           *m_pI;                  // The actual interface Ptr.
};



//
//
// Support for VARIANT's using C++
//
//
#include <math.h>
#include <time.h>
#define MIN_DATE                (-657434L)  // about year 100
#define MAX_DATE                2958465L    // about year 9999
// Half a second, expressed in days
#define HALF_SECOND  (1.0/172800.0)

// One-based array of days in year at month start
extern const int __declspec(selectany) rgMonthDays[13] =
    {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365};



//*****************************************************************************
// This is a utility function to allocate a SafeArray.
//*****************************************************************************
inline SAFEARRAY *AllocSafeArrayLen(    // Return status.
    BYTE        *pData,                 // Data to be placed in the array.
    ULONG       iSize)                  // Size of data.
{
    SAFEARRAYBOUND sBound;              // Used to fill out the bounds.
    SAFEARRAY   *pArray;                // Ptr to the new array.

    sBound.cElements = iSize;
    sBound.lLbound = 0;
    if ((pArray = SafeArrayCreate(VT_UI1, 1, &sBound)) != NULL)
        memcpy(pArray->pvData, (void *) pData, iSize);
    return (pArray);
}


//*****************************************************************************
// Get the # of bytes in the safe array.
//*****************************************************************************
inline int SafeArrayGetDatasize(        // Size of the SafeArray data.
    SAFEARRAY   *psArray)               // Pointer to the SafeArray.
{
    int         iElems = 1;             // # of elements in the array.
    int         i;                      // Loop control.

    // Compute the # of elements in the array.
    for (i=0; i < psArray->cDims; ++i)
        iElems *= psArray->rgsabound[i].cElements;

    // Return the size.
    return (iElems * psArray->cbElements);
}


//*****************************************************************************
// Convert a UTF8 string into a wide string and build a BSTR.
//*****************************************************************************
inline BSTR Utf8StringToBstr(           // The new BSTR.
    LPCSTR      szStr,                  // The string to turn into a BSTR.
    int         iSize=-1)               // Size of string without 0, or -1 for default.
{
    BSTR        bstrVal;
    int         iReq;                   // Chars required for string.

    // Account for terminating 0.
    if (iSize != -1)
        ++iSize;

    // How big a buffer is needed?
    if ((iReq = WszMultiByteToWideChar(CP_UTF8, 0, szStr, iSize, 0, 0)) == 0)
        return (0);

    // Allocate the BSTR.
    if ((bstrVal = ::SysAllocStringLen(0, iReq)) == 0)
        return (0);

    // Convert into the buffer.
    if (WszMultiByteToWideChar(CP_UTF8, 0, szStr, iSize, bstrVal, iReq) == 0)
    {   // Failed, so clean up.
        _ASSERTE(!"Unexpected MultiByteToWideChar() failure");
        ::SysFreeString(bstrVal);
        return 0;
    }

    return (bstrVal);
}

//*****************************************************************************
// Convert a pointer to a string into a GUID.
//*****************************************************************************
HRESULT LPCSTRToGuid(                   // Return status.
    LPCSTR      szGuid,                 // String to convert.
    GUID        *psGuid);               // Buffer for converted GUID.

//*****************************************************************************
// Convert a GUID into a pointer to a string
//*****************************************************************************
int GuidToLPWSTR(                  // Return status.
    GUID        Guid,                  // [IN] The GUID to convert.
    LPWSTR      szGuid,                // [OUT] String into which the GUID is stored
    DWORD       cchGuid);              // [IN] Size in wide chars of szGuid


//*****************************************************************************
// If your application is using exception handling, then define both of the
// macros here to do whatever you need.  Any components of CVariant that can
// fail (which will always be out of memory) will throw using this macro.
//*****************************************************************************
#ifndef __REPOS_EXCEPTIONS__
#define THROW_REPOS_EXCEPTION()
#endif


class RangeList
{
  public:
    RangeList();
    ~RangeList();

    BOOL AddRange(const BYTE *start, const BYTE *end, void *id);
    void RemoveRanges(void *id);
    BOOL IsInRange(const BYTE *address);

    // This is used by the EditAndContinueModule to track open SLOTs that
    // are interspersed among classes.
    // Note that this searches from the start all the way to the end, so that we'll
    // pick element that is the farthest away from start as we can get.
    // Of course, this is pretty slow, so be warned.
    void *FindIdWithinRange(const BYTE *start, const BYTE *end);
        
    enum
    {
        RANGE_COUNT = 10
    };

  protected:
    virtual void Lock() {}
    virtual void Unlock() {}

  private:
    struct Range
    {
        const BYTE *start;
        const BYTE *end;
        void *id;
    };

    struct RangeListBlock
    {
        Range           ranges[RANGE_COUNT];
        RangeListBlock  *next;
    };

    void InitBlock(RangeListBlock *block);

    RangeListBlock m_starterBlock;
    RangeListBlock *m_firstEmptyBlock;
    int             m_firstEmptyRange;
};


// # bytes to leave between allocations in debug mode
// Set to a > 0 boundary to debug problems - I've made this zero, otherwise a 1 byte allocation becomes
// a (1 + LOADER_HEAP_DEBUG_BOUNDARY) allocation
#define LOADER_HEAP_DEBUG_BOUNDARY  0

// KBytes that a call to VirtualAlloc rounds off to.
#define MIN_VIRTUAL_ALLOC_RESERVE_SIZE 64*1024

// We reserve atleast these many pages per LoaderHeap
#define RESERVED_BLOCK_ROUND_TO_PAGES 16

struct LoaderHeapBlock
{
    struct LoaderHeapBlock *pNext;
    void *                  pVirtualAddress;
    DWORD                   dwVirtualSize;
    BOOL                    m_fReleaseMemory;
};

// If we call UnlockedCanAllocMem, we'll actually try and allocate
// the memory, put it into the list, and then not use it till later.  
// But we need to record the following information so that we can
// properly fix up the list when we do actually use it.  So we'll
// stick this info into the block we just allocated, but ONLY
// if the allocation was for a CanAllocMem.  Otherwise it's a waste
// of CPU time, and so we won't do it.
struct LoaderHeapBlockUnused : LoaderHeapBlock
{
    DWORD                   cbCommitted;
    DWORD                   cbReserved;
};

class UnlockedLoaderHeap
{
    friend struct MEMBER_OFFSET_INFO(UnlockedLoaderHeap);
private:
    // Linked list of VirtualAlloc'd pages
    LoaderHeapBlock *   m_pFirstBlock;

    // Allocation pointer in current block
    BYTE *              m_pAllocPtr;

    // Points to the end of the committed region in the current block
    BYTE *              m_pPtrToEndOfCommittedRegion;
    BYTE *              m_pEndReservedRegion;

    LoaderHeapBlock *   m_pCurBlock;

    // When we need to VirtualAlloc() MEM_RESERVE a new set of pages, number of bytes to reserve
    DWORD               m_dwReserveBlockSize;

    // When we need to commit pages from our reserved list, number of bytes to commit at a time
    DWORD               m_dwCommitBlockSize;

    static DWORD        m_dwSystemPageSize;

    // Created by in-place new?
    BOOL                m_fInPlace;

    // Range list to record memory ranges in
    RangeList *         m_pRangeList;

    DWORD               m_dwTotalAlloc; 

    DWORD *             m_pPrivatePerfCounter_LoaderBytes;
    DWORD *             m_pGlobalPerfCounter_LoaderBytes;

protected:
    // If the user is only willing to accept memory addresses above a certain point, then
    // this will be non-NULL.  Note that this involves iteratively testing memory
    // regions, etc, and should be assumed to be slow, a lot.
    const BYTE *        m_pMinAddr;

    // don't allocate anything that overlaps/is greater than this point in memory.
    const BYTE *        m_pMaxAddr;
public:
#ifdef _DEBUG
    DWORD               m_dwDebugWastedBytes;
    static DWORD        s_dwNumInstancesOfLoaderHeaps;
#endif

#ifdef _DEBUG
    DWORD DebugGetWastedBytes()
    {
        return m_dwDebugWastedBytes + GetBytesAvailCommittedRegion();
    }
#endif

public:
    // Regular new
    void *operator new(size_t size)
    {
        void *pResult = new BYTE[size];

        if (pResult != NULL)
            ((UnlockedLoaderHeap *) pResult)->m_fInPlace = FALSE;

        return pResult;
    }

    // In-place new
    void *operator new(size_t size, void *pInPlace)
    {
        ((UnlockedLoaderHeap *) pInPlace)->m_fInPlace = TRUE;
        return pInPlace;
    }

    void operator delete(void *p)
    {
        if (p != NULL)
        {
            if (((UnlockedLoaderHeap *) p)->m_fInPlace == FALSE)
                ::delete(p);
        }
    }

    // Copies all the arguments, but DOESN'T actually allocate any memory,
    // yet.
    UnlockedLoaderHeap(DWORD dwReserveBlockSize, 
                       DWORD dwCommitBlockSize,
                       DWORD *pPrivatePerfCounter_LoaderBytes = NULL,
                       DWORD *pGlobalPerfCounter_LoaderBytes = NULL,
                       RangeList *pRangeList = NULL,
                       const BYTE *pMinAddr = NULL);

    // Use this version if dwReservedRegionAddress already points to a
    // blob of reserved memory.  This will set up internal data structures,
    // using the provided, reserved memory.
    UnlockedLoaderHeap(DWORD dwReserveBlockSize, 
                       DWORD dwCommitBlockSize,
                       const BYTE* dwReservedRegionAddress, 
                       DWORD dwReservedRegionSize, 
                       DWORD *pPrivatePerfCounter_LoaderBytes = NULL,
                       DWORD *pGlobalPerfCounter_LoaderBytes = NULL,
                       RangeList *pRangeList = NULL);

    ~UnlockedLoaderHeap();
    DWORD GetBytesAvailCommittedRegion();
    DWORD GetBytesAvailReservedRegion();

    BYTE *GetAllocPtr()
    {    
        return m_pAllocPtr;
    }

    // number of bytes available in region
    size_t GetReservedBytesFree()
    {    
        return m_pEndReservedRegion - m_pAllocPtr;
    }

    void* GetFirstBlockVirtualAddress()
    {
        if (m_pFirstBlock) 
            return m_pFirstBlock->pVirtualAddress;
        else
            return NULL;
    }

    // Get some more committed pages - either commit some more in the current reserved region, or, if it
    // has run out, reserve another set of pages
    BOOL GetMoreCommittedPages(size_t dwMinSize, 
                               BOOL bGrowHeap,
                               const BYTE *pMinAddr,
                               const BYTE *pMaxAddr,
                               BOOL fCanAlloc);

    // Did a previous call to CanAllocMem(WithinRange) allocate space that we can use now?
    BOOL PreviouslyAllocated(BYTE *pMinAddr, 
                             BYTE *pMaxAddr, 
                             DWORD dwMinSize,
                             BOOL fCanAlloc);


    // Reserve some pages either at any address or assumes the given address to have
    // already been reserved, and commits the given number of bytes.
    BOOL ReservePages(DWORD dwCommitBlockSize, 
                      const BYTE* dwReservedRegionAddress,
                      DWORD dwReservedRegionSize,
                      const BYTE* pMinAddr,
                      const BYTE* pMaxAddr,
                      BOOL fCanAlloc);

    // In debug mode, allocate an extra LOADER_HEAP_DEBUG_BOUNDARY bytes and fill it with invalid data.  The reason we
    // do this is that when we're allocating vtables out of the heap, it is very easy for code to
    // get careless, and end up reading from memory that it doesn't own - but since it will be
    // reading some other allocation's vtable, no crash will occur.  By keeping a gap between
    // allocations, it is more likely that these errors will be encountered.
    void *UnlockedAllocMem(size_t dwSize, BOOL bGrowHeap = TRUE);

    // Don't actually increment the next free pointer, just tell us if we can.
    BOOL UnlockedCanAllocMem(size_t dwSize, BOOL bGrowHeap = TRUE);

    // Don't actually increment the next free pointer, just tell us if we can get
    // memory within a certain range..
    BOOL UnlockedCanAllocMemWithinRange(size_t dwSize, BYTE *pStart, BYTE *pEnd, BOOL bGrowHeap);

    // Perf Counter reports the size of the heap
    virtual DWORD GetSize ()
    {
        return m_dwTotalAlloc;
    }

#if 0
    void DebugGuardHeap();
#endif

#ifdef _DEBUG
    void *UnlockedAllocMemHelper(size_t dwSize,BOOL bGrowHeap = TRUE);
#endif
};


class LoaderHeap : public UnlockedLoaderHeap
{
    friend struct MEMBER_OFFSET_INFO(LoaderHeap);
private:
    CRITICAL_SECTION    m_CriticalSection;

public:
    LoaderHeap(DWORD dwReserveBlockSize, 
               DWORD dwCommitBlockSize,
               DWORD *pPrivatePerfCounter_LoaderBytes = NULL,
               DWORD *pGlobalPerfCounter_LoaderBytes = NULL,
               RangeList *pRangeList = NULL,
               const BYTE *pMinAddr = NULL)
      : UnlockedLoaderHeap(dwReserveBlockSize,
                           dwCommitBlockSize, 
                           pPrivatePerfCounter_LoaderBytes,
                           pGlobalPerfCounter_LoaderBytes,
                           pRangeList,
                           pMinAddr)
    {
        InitializeCriticalSection(&m_CriticalSection);
    }

    LoaderHeap(DWORD dwReserveBlockSize, 
               DWORD dwCommitBlockSize,
               const BYTE* dwReservedRegionAddress, 
               DWORD dwReservedRegionSize, 
               DWORD *pPrivatePerfCounter_LoaderBytes = NULL,
               DWORD *pGlobalPerfCounter_LoaderBytes = NULL,
               RangeList *pRangeList = NULL) 
      : UnlockedLoaderHeap(dwReserveBlockSize, 
                           dwCommitBlockSize, 
                           dwReservedRegionAddress, 
                           dwReservedRegionSize, 
                           pPrivatePerfCounter_LoaderBytes,
                           pGlobalPerfCounter_LoaderBytes,
                           pRangeList)
    {
        InitializeCriticalSection(&m_CriticalSection);
    }
    
    ~LoaderHeap()
    {
        DeleteCriticalSection(&m_CriticalSection);
    }



    BYTE *GetNextAllocAddress()
    {   
        BYTE *ptr;

        LOCKCOUNTINCL("GetNextAllocAddress in utilcode.h");                     \
        EnterCriticalSection(&m_CriticalSection);
        ptr = GetAllocPtr();
        LeaveCriticalSection(&m_CriticalSection);
        LOCKCOUNTDECL("GetNextAllocAddress in utilcode.h");                     \

        return ptr;
    }

    size_t GetSpaceRemaining()
    {   
        size_t count;

        LOCKCOUNTINCL("GetSpaceRemaining in utilcode.h");                       \
        EnterCriticalSection(&m_CriticalSection);
        count = GetReservedBytesFree();
        LeaveCriticalSection(&m_CriticalSection);
        LOCKCOUNTDECL("GetSpaceRemaining in utilcode.h");                       \

        return count;
   }

    BOOL AllocateOntoReservedMem(const BYTE* dwReservedRegionAddress, DWORD dwReservedRegionSize)
    {
        BOOL result;
        LOCKCOUNTINCL("AllocateOntoReservedMem in utilcode.h");                     \
        EnterCriticalSection(&m_CriticalSection);
        result = ReservePages(0, dwReservedRegionAddress, dwReservedRegionSize, (PBYTE)BOT_MEMORY, (PBYTE)TOP_MEMORY, FALSE);
        LeaveCriticalSection(&m_CriticalSection);
        LOCKCOUNTDECL("AllocateOntoReservedMem in utilcode.h");                     \

        return result;
    }

    // This is only used for EnC.
    // If anyone else uses it, please change the above comment.
    BOOL CanAllocMem(size_t dwSize, BOOL bGrowHeap = TRUE)
    {
        BOOL bResult;
        
        LOCKCOUNTINCL("CanAllocMem in utilcode.h");
        EnterCriticalSection(&m_CriticalSection);
        
        bResult = UnlockedCanAllocMem(dwSize, bGrowHeap);
        
        LeaveCriticalSection(&m_CriticalSection);
        LOCKCOUNTDECL("CanAllocMem in utilcode.h");

        return bResult;
    }


    BOOL CanAllocMemWithinRange(size_t dwSize, BYTE *pStart, BYTE *pEnd, BOOL bGrowHeap)
    {
        BOOL bResult;
        
        LOCKCOUNTINCL("CanAllocMem in utilcode.h");
        EnterCriticalSection(&m_CriticalSection);

        bResult = UnlockedCanAllocMemWithinRange(dwSize, pStart, pEnd, bGrowHeap);
        
        LeaveCriticalSection(&m_CriticalSection);
        LOCKCOUNTDECL("CanAllocMem in utilcode.h");

        return bResult;
    }
    
#ifdef _DEBUG
    void *AllocMem(size_t dwSize, BOOL bGrowHeap = TRUE)
    {
        void *pMem = AllocMemHelper(dwSize + LOADER_HEAP_DEBUG_BOUNDARY, bGrowHeap);

        if (pMem == NULL)
            return pMem;

        // Don't fill the entire memory - we assume it is all zeroed -just the memory after our alloc
#if LOADER_HEAP_DEBUG_BOUNDARY > 0
        memset((BYTE *) pMem + dwSize, 0xEE, LOADER_HEAP_DEBUG_BOUNDARY);
#endif

        return pMem;
    }
#endif

    // This is synchronised
#ifdef _DEBUG
    void *AllocMemHelper(size_t dwSize, BOOL bGrowHeap = TRUE)
#else
    void *AllocMem(size_t dwSize, BOOL bGrowHeap = TRUE)
#endif
    {
        void *pResult;

        LOCKCOUNTINCL("AllocMem in utilcode.h");                        \
        EnterCriticalSection(&m_CriticalSection);
        pResult = UnlockedAllocMem(dwSize, bGrowHeap);
        LeaveCriticalSection(&m_CriticalSection);
        LOCKCOUNTDECL("AllocMem in utilcode.h");                        \
        return pResult;
    }



    void *AllocAlignedmem(size_t dwSize, DWORD alignment, BOOL bGrowHeap = TRUE)
    {
        void *pResult;

        _ASSERTE(0 == (alignment & (alignment - 1))); // require power of 2

        LOCKCOUNTINCL("AllocAlignedmem in utilcode.h");                     \
        EnterCriticalSection(&m_CriticalSection);

        // Before checking the current pointer's alignment, make sure it's the one that will be used!
        size_t dwRoomSize = dwSize + alignment;
        // DWORD align
        dwRoomSize = (dwRoomSize + 3) & (~3);

        if (dwRoomSize > GetBytesAvailCommittedRegion())
        {
            if (GetMoreCommittedPages(dwRoomSize, bGrowHeap, m_pMinAddr, m_pMaxAddr, FALSE) == FALSE)
            {
                LeaveCriticalSection(&m_CriticalSection);
                LOCKCOUNTDECL("AllocAlignedmem in utilcode.h");                     \

                return NULL;
            }
        }

        pResult = GetAllocPtr();

        DWORD extra = alignment - (DWORD)((size_t)pResult & ((size_t)alignment - 1));
        if (extra == alignment)
        {
            extra = 0;
        }
        pResult = UnlockedAllocMem(
                      dwSize + extra
#ifdef _DEBUG
                      + LOADER_HEAP_DEBUG_BOUNDARY
#endif
                      , bGrowHeap);
        if (pResult)
        {
            ((BYTE*&)pResult) += extra;
#ifdef _DEBUG
            // Don't fill the entire memory - we assume it is all zeroed -just the memory after our alloc
#if LOADER_HEAP_DEBUG_BOUNDARY > 0
            memset( ((BYTE*)pResult) + dwSize, 0xee, LOADER_HEAP_DEBUG_BOUNDARY );
#endif
#endif
        }


        LeaveCriticalSection(&m_CriticalSection);
        LOCKCOUNTDECL("AllocAlignedmem in utilcode.h");                     \

        return pResult;
    }
};

#ifdef COMPRESSION_SUPPORTED
class InstructionDecoder
{
public:
    static HRESULT DecompressMethod(void *pDecodingTable, const BYTE *pCompressed, DWORD dwSize, BYTE **ppOutput);
    static void *CreateInstructionDecodingTable(const BYTE *pTableStart, DWORD size);
    static void DestroyInstructionDecodingTable(void *pTable);
    static BOOL OpcodeTakesFieldToken(DWORD opcode);
    static BOOL OpcodeTakesMethodToken(DWORD opcode);
    static BOOL OpcodeTakesClassToken(DWORD opcode);
};
#endif // COMPRESSION_SUPPORTED

//
// A private function to do the equavilent of a CoCreateInstance in
// cases where we can't make the real call. Use this when, for
// instance, you need to create a symbol reader in the Runtime but
// we're not CoInitialized. Obviously, this is only good for COM
// objects for which CoCreateInstance is just a glorified
// find-and-load-me operation.
//
HRESULT FakeCoCreateInstance(REFCLSID   rclsid,
                             REFIID     riid,
                             void     **ppv);


//*****************************************************************************
// Sets/Gets the directory based on the location of the module. This routine
// is called at COR setup time. Set is called during EEStartup and by the 
// MetaData dispenser.
//*****************************************************************************
HRESULT SetInternalSystemDirectory();
HRESULT GetInternalSystemDirectory(LPWSTR buffer, DWORD* pdwLength);
typedef HRESULT (WINAPI* GetCORSystemDirectoryFTN)(LPWSTR buffer,
                                                   DWORD  ccBuffer,
                                                   DWORD  *pcBuffer);

//*****************************************************************************
// Checks if string length exceeds the specified limit
//*****************************************************************************
inline BOOL IsStrLongerThan(char* pstr, unsigned N)
{
    unsigned i = 0;
    if(pstr)
    {
        for(i=0; (i < N)&&(pstr[i]); i++);
    }
    return (i >= N);
}
//*****************************************************************************
// This function validates the given Method/Field/Standalone signature. (util.cpp)  
//*****************************************************************************
struct IMDInternalImport;
HRESULT validateTokenSig(
    mdToken             tk,                     // [IN] Token whose signature needs to be validated.
    PCCOR_SIGNATURE     pbSig,                  // [IN] Signature.
    ULONG               cbSig,                  // [IN] Size in bytes of the signature.
    DWORD               dwFlags,                // [IN] Method flags.
    IMDInternalImport*  pImport);               // [IN] Internal MD Import interface ptr


//*****************************************************************************
// Determine the version number of the runtime that was used to build the
// specified image. The pMetadata pointer passed in is the pointer to the
// metadata contained in the image.
//*****************************************************************************
HRESULT GetImageRuntimeVersionString(PVOID pMetaData, LPCSTR* pString);

//*****************************************************************************
// Callback, eg for OutOfMemory, used by utilcode
//*****************************************************************************
typedef void (*FnUtilCodeCallback)();
class UtilCodeCallback
{
public:
    static RegisterOutOfMemoryCallback (FnUtilCodeCallback pfn)
    {
        OutOfMemoryCallback = pfn;
    }
    
    static FnUtilCodeCallback OutOfMemoryCallback;
};


#endif // __UtilCode_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\tlbimpexp_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Thu Feb 20 18:27:20 2003
 */
/* Compiler settings for tlbimpexp.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_TlbImpLib,0x20BC1825,0x06F0,0x11d2,0x8C,0xF4,0x00,0xA0,0xC9,0xB0,0xA0,0x63);


MIDL_DEFINE_GUID(IID, IID_ITypeLibImporterNotifySink,0xF1C3BF76,0xC3E4,0x11D3,0x88,0xE7,0x00,0x90,0x27,0x54,0xC4,0x3A);


MIDL_DEFINE_GUID(IID, IID_ITypeLibExporterNotifySink,0xF1C3BF77,0xC3E4,0x11D3,0x88,0xE7,0x00,0x90,0x27,0x54,0xC4,0x3A);


MIDL_DEFINE_GUID(IID, IID_ITypeLibExporterNameProvider,0xFA1F3615,0xACB9,0x486d,0x9E,0xAC,0x1B,0xEF,0x87,0xE3,0x6B,0x09);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\tpoolfnsp.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/**
 * tpoolfnsp.h
 * 
 * Private declaration of thread pool library APIs in the XSP project. 
 * 
*/

/**
 *
 *  This file needs to be insync of tpool.h in xsp\inc directory.
 *  Whenever there is a change to the threadpool APIs, both header files need update.
 *
 *
 */

STRUCT_ENTRY(RegisterWaitForSingleObject, BOOL,
            (   PHANDLE phNewWaitObject,
                HANDLE hObject,
                WAITORTIMERCALLBACK Callback,
                PVOID Context,
                ULONG dwMilliseconds,
                ULONG dwFlags ),
            (   phNewWaitObject,
                hObject,
                Callback,
                Context,
                dwMilliseconds,
                dwFlags))


STRUCT_ENTRY(UnregisterWaitEx, BOOL,
            (   HANDLE WaitHandle,
                HANDLE CompletionEvent ),
            (   WaitHandle,
                CompletionEvent))

STRUCT_ENTRY(QueueUserWorkItem, BOOL,
            (   LPTHREAD_START_ROUTINE Function,
                PVOID Context,
                ULONG Flags ),
            (   Function,
                Context,
                Flags))
            
STRUCT_ENTRY(BindIoCompletionCallback, BOOL,
            (   HANDLE FileHandle,
                LPOVERLAPPED_COMPLETION_ROUTINE Function,
                ULONG Flags ),
            (   FileHandle,
                Function,
                Flags))

STRUCT_ENTRY(SetMaxThreads, BOOL,
            (   DWORD MaxWorkerThreads,
	            DWORD MaxIOCompletionThreads),
            (   MaxWorkerThreads,
                MaxIOCompletionThreads))

STRUCT_ENTRY(GetMaxThreads, BOOL,
            (   DWORD* MaxWorkerThreads,
	            DWORD* MaxIOCompletionThreads),
            (   MaxWorkerThreads,
                MaxIOCompletionThreads))

STRUCT_ENTRY(GetAvailableThreads, BOOL,
            (   DWORD* AvailableWorkerThreads,
	            DWORD* AvailableIOCompletionThreads),
            (   AvailableWorkerThreads,
                AvailableIOCompletionThreads))

STRUCT_ENTRY(CreateTimerQueueTimer, BOOL,     
            (   PHANDLE phNewTimer,
                WAITORTIMERCALLBACK Callback,
                PVOID Parameter,
                DWORD DueTime,
                DWORD Period,
                ULONG Flags),
            (   phNewTimer,
                Callback,
                Parameter,
                DueTime,
                Period,
                Flags))

STRUCT_ENTRY(ChangeTimerQueueTimer, BOOL, 
            (   HANDLE Timer,
                ULONG DueTime,
                ULONG Period),
            (   Timer,
                DueTime,
                Period))

STRUCT_ENTRY(DeleteTimerQueueTimer, BOOL, 
            (   HANDLE Timer,
                HANDLE CompletionEvent),
            (
                Timer,
                CompletionEvent))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\transact.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Tue Sep 23 15:58:35 1997
 */
/* Compiler settings for transact.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __transact_h__
#define __transact_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __ITransaction_FWD_DEFINED__
#define __ITransaction_FWD_DEFINED__
typedef interface ITransaction ITransaction;
#endif 	/* __ITransaction_FWD_DEFINED__ */


#ifndef __ITransactionDispenser_FWD_DEFINED__
#define __ITransactionDispenser_FWD_DEFINED__
typedef interface ITransactionDispenser ITransactionDispenser;
#endif 	/* __ITransactionDispenser_FWD_DEFINED__ */


#ifndef __ITransactionOptions_FWD_DEFINED__
#define __ITransactionOptions_FWD_DEFINED__
typedef interface ITransactionOptions ITransactionOptions;
#endif 	/* __ITransactionOptions_FWD_DEFINED__ */


#ifndef __ITransactionOutcomeEvents_FWD_DEFINED__
#define __ITransactionOutcomeEvents_FWD_DEFINED__
typedef interface ITransactionOutcomeEvents ITransactionOutcomeEvents;
#endif 	/* __ITransactionOutcomeEvents_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL_itf_transact_0000
 * at Tue Sep 23 15:58:35 1997
 * using MIDL 3.01.75
 ****************************************/
/* [local] */ 







#ifndef DECLSPEC_UUID
#if _MSC_VER >= 1100
#define DECLSPEC_UUID(x)    __declspec(uuid(x))
#else
#define DECLSPEC_UUID(x)
#endif
#endif


extern RPC_IF_HANDLE __MIDL_itf_transact_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_transact_0000_v0_0_s_ifspec;

#ifndef __BasicTransactionTypes_INTERFACE_DEFINED__
#define __BasicTransactionTypes_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: BasicTransactionTypes
 * at Tue Sep 23 15:58:35 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][local] */ 


typedef struct  BOID
    {
    BYTE rgb[ 16 ];
    }	BOID;

#define BOID_NULL (*((BOID*)(&IID_NULL)))
#ifndef MAX_TRAN_DESC_DEFINED
#define MAX_TRAN_DESC_DEFINED
typedef 
enum TX_MISC_CONSTANTS
    {	MAX_TRAN_DESC	= 40
    }	TX_MISC_CONSTANTS;

#endif
typedef BOID XACTUOW;

typedef LONG ISOLEVEL;

typedef 
enum ISOLATIONLEVEL
    {	ISOLATIONLEVEL_UNSPECIFIED	= 0xffffffff,
	ISOLATIONLEVEL_CHAOS	= 0x10,
	ISOLATIONLEVEL_READUNCOMMITTED	= 0x100,
	ISOLATIONLEVEL_BROWSE	= 0x100,
	ISOLATIONLEVEL_CURSORSTABILITY	= 0x1000,
	ISOLATIONLEVEL_READCOMMITTED	= 0x1000,
	ISOLATIONLEVEL_REPEATABLEREAD	= 0x10000,
	ISOLATIONLEVEL_SERIALIZABLE	= 0x100000,
	ISOLATIONLEVEL_ISOLATED	= 0x100000
    }	ISOLATIONLEVEL;

typedef struct  XACTTRANSINFO
    {
    XACTUOW uow;
    ISOLEVEL isoLevel;
    ULONG isoFlags;
    DWORD grfTCSupported;
    DWORD grfRMSupported;
    DWORD grfTCSupportedRetaining;
    DWORD grfRMSupportedRetaining;
    }	XACTTRANSINFO;

typedef struct  XACTSTATS
    {
    ULONG cOpen;
    ULONG cCommitting;
    ULONG cCommitted;
    ULONG cAborting;
    ULONG cAborted;
    ULONG cInDoubt;
    ULONG cHeuristicDecision;
    FILETIME timeTransactionsUp;
    }	XACTSTATS;

typedef 
enum ISOFLAG
    {	ISOFLAG_RETAIN_COMMIT_DC	= 1,
	ISOFLAG_RETAIN_COMMIT	= 2,
	ISOFLAG_RETAIN_COMMIT_NO	= 3,
	ISOFLAG_RETAIN_ABORT_DC	= 4,
	ISOFLAG_RETAIN_ABORT	= 8,
	ISOFLAG_RETAIN_ABORT_NO	= 12,
	ISOFLAG_RETAIN_DONTCARE	= ISOFLAG_RETAIN_COMMIT_DC | ISOFLAG_RETAIN_ABORT_DC,
	ISOFLAG_RETAIN_BOTH	= ISOFLAG_RETAIN_COMMIT | ISOFLAG_RETAIN_ABORT,
	ISOFLAG_RETAIN_NONE	= ISOFLAG_RETAIN_COMMIT_NO | ISOFLAG_RETAIN_ABORT_NO,
	ISOFLAG_OPTIMISTIC	= 16,
	ISOFLAG_READONLY	= 32
    }	ISOFLAG;

typedef 
enum XACTTC
    {	XACTTC_SYNC_PHASEONE	= 1,
	XACTTC_SYNC_PHASETWO	= 2,
	XACTTC_SYNC	= 2,
	XACTTC_ASYNC_PHASEONE	= 4,
	XACTTC_ASYNC	= 4
    }	XACTTC;

typedef 
enum XACTRM
    {	XACTRM_OPTIMISTICLASTWINS	= 1,
	XACTRM_NOREADONLYPREPARES	= 2
    }	XACTRM;

typedef 
enum XACTCONST
    {	XACTCONST_TIMEOUTINFINITE	= 0
    }	XACTCONST;

typedef 
enum XACTHEURISTIC
    {	XACTHEURISTIC_ABORT	= 1,
	XACTHEURISTIC_COMMIT	= 2,
	XACTHEURISTIC_DAMAGE	= 3,
	XACTHEURISTIC_DANGER	= 4
    }	XACTHEURISTIC;

typedef 
enum XACTSTAT
    {	XACTSTAT_NONE	= 0,
	XACTSTAT_OPENNORMAL	= 0x1,
	XACTSTAT_OPENREFUSED	= 0x2,
	XACTSTAT_PREPARING	= 0x4,
	XACTSTAT_PREPARED	= 0x8,
	XACTSTAT_PREPARERETAINING	= 0x10,
	XACTSTAT_PREPARERETAINED	= 0x20,
	XACTSTAT_COMMITTING	= 0x40,
	XACTSTAT_COMMITRETAINING	= 0x80,
	XACTSTAT_ABORTING	= 0x100,
	XACTSTAT_ABORTED	= 0x200,
	XACTSTAT_COMMITTED	= 0x400,
	XACTSTAT_HEURISTIC_ABORT	= 0x800,
	XACTSTAT_HEURISTIC_COMMIT	= 0x1000,
	XACTSTAT_HEURISTIC_DAMAGE	= 0x2000,
	XACTSTAT_HEURISTIC_DANGER	= 0x4000,
	XACTSTAT_FORCED_ABORT	= 0x8000,
	XACTSTAT_FORCED_COMMIT	= 0x10000,
	XACTSTAT_INDOUBT	= 0x20000,
	XACTSTAT_CLOSED	= 0x40000,
	XACTSTAT_OPEN	= 0x3,
	XACTSTAT_NOTPREPARED	= 0x7ffc3,
	XACTSTAT_ALL	= 0x7ffff
    }	XACTSTAT;

typedef struct  XACTOPT
    {
    ULONG ulTimeout;
    char szDescription[ 40 ];
    }	XACTOPT;

typedef 
enum XACT_E
    {	XACT_E_FIRST	= 0x8004d000,
	XACT_E_LAST	= 0x8004d01e,
	XACT_S_FIRST	= 0x4d000,
	XACT_S_LAST	= 0x4d009,
	XACT_E_ALREADYOTHERSINGLEPHASE	= 0x8004d000,
	XACT_E_CANTRETAIN	= 0x8004d001,
	XACT_E_COMMITFAILED	= 0x8004d002,
	XACT_E_COMMITPREVENTED	= 0x8004d003,
	XACT_E_HEURISTICABORT	= 0x8004d004,
	XACT_E_HEURISTICCOMMIT	= 0x8004d005,
	XACT_E_HEURISTICDAMAGE	= 0x8004d006,
	XACT_E_HEURISTICDANGER	= 0x8004d007,
	XACT_E_ISOLATIONLEVEL	= 0x8004d008,
	XACT_E_NOASYNC	= 0x8004d009,
	XACT_E_NOENLIST	= 0x8004d00a,
	XACT_E_NOISORETAIN	= 0x8004d00b,
	XACT_E_NORESOURCE	= 0x8004d00c,
	XACT_E_NOTCURRENT	= 0x8004d00d,
	XACT_E_NOTRANSACTION	= 0x8004d00e,
	XACT_E_NOTSUPPORTED	= 0x8004d00f,
	XACT_E_UNKNOWNRMGRID	= 0x8004d010,
	XACT_E_WRONGSTATE	= 0x8004d011,
	XACT_E_WRONGUOW	= 0x8004d012,
	XACT_E_XTIONEXISTS	= 0x8004d013,
	XACT_E_NOIMPORTOBJECT	= 0x8004d014,
	XACT_E_INVALIDCOOKIE	= 0x8004d015,
	XACT_E_INDOUBT	= 0x8004d016,
	XACT_E_NOTIMEOUT	= 0x8004d017,
	XACT_E_ALREADYINPROGRESS	= 0x8004d018,
	XACT_E_ABORTED	= 0x8004d019,
	XACT_E_LOGFULL	= 0x8004d01a,
	XACT_E_TMNOTAVAILABLE	= 0x8004d01b,
	XACT_E_CONNECTION_DOWN	= 0x8004d01c,
	XACT_E_CONNECTION_DENIED	= 0x8004d01d,
	XACT_E_REENLISTTIMEOUT	= 0x8004d01e,
	XACT_S_ASYNC	= 0x4d000,
	XACT_S_DEFECT	= 0x4d001,
	XACT_S_READONLY	= 0x4d002,
	XACT_S_SOMENORETAIN	= 0x4d003,
	XACT_S_OKINFORM	= 0x4d004,
	XACT_S_MADECHANGESCONTENT	= 0x4d005,
	XACT_S_MADECHANGESINFORM	= 0x4d006,
	XACT_S_ALLNORETAIN	= 0x4d007,
	XACT_S_ABORTING	= 0x4d008,
	XACT_S_SINGLEPHASE	= 0x4d009
    }	XACT_E;



extern RPC_IF_HANDLE BasicTransactionTypes_v0_0_c_ifspec;
extern RPC_IF_HANDLE BasicTransactionTypes_v0_0_s_ifspec;
#endif /* __BasicTransactionTypes_INTERFACE_DEFINED__ */

#ifndef __ITransaction_INTERFACE_DEFINED__
#define __ITransaction_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITransaction
 * at Tue Sep 23 15:58:35 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_ITransaction;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0fb15084-af41-11ce-bd2b-204c4f4f5020")
    ITransaction : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Commit( 
            /* [in] */ BOOL fRetaining,
            /* [in] */ DWORD grfTC,
            /* [in] */ DWORD grfRM) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Abort( 
            /* [in] */ BOID __RPC_FAR *pboidReason,
            /* [in] */ BOOL fRetaining,
            /* [in] */ BOOL fAsync) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTransactionInfo( 
            /* [out] */ XACTTRANSINFO __RPC_FAR *pinfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITransaction __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITransaction __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITransaction __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Commit )( 
            ITransaction __RPC_FAR * This,
            /* [in] */ BOOL fRetaining,
            /* [in] */ DWORD grfTC,
            /* [in] */ DWORD grfRM);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Abort )( 
            ITransaction __RPC_FAR * This,
            /* [in] */ BOID __RPC_FAR *pboidReason,
            /* [in] */ BOOL fRetaining,
            /* [in] */ BOOL fAsync);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTransactionInfo )( 
            ITransaction __RPC_FAR * This,
            /* [out] */ XACTTRANSINFO __RPC_FAR *pinfo);
        
        END_INTERFACE
    } ITransactionVtbl;

    interface ITransaction
    {
        CONST_VTBL struct ITransactionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransaction_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITransaction_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITransaction_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITransaction_Commit(This,fRetaining,grfTC,grfRM)	\
    (This)->lpVtbl -> Commit(This,fRetaining,grfTC,grfRM)

#define ITransaction_Abort(This,pboidReason,fRetaining,fAsync)	\
    (This)->lpVtbl -> Abort(This,pboidReason,fRetaining,fAsync)

#define ITransaction_GetTransactionInfo(This,pinfo)	\
    (This)->lpVtbl -> GetTransactionInfo(This,pinfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITransaction_Commit_Proxy( 
    ITransaction __RPC_FAR * This,
    /* [in] */ BOOL fRetaining,
    /* [in] */ DWORD grfTC,
    /* [in] */ DWORD grfRM);


void __RPC_STUB ITransaction_Commit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITransaction_Abort_Proxy( 
    ITransaction __RPC_FAR * This,
    /* [in] */ BOID __RPC_FAR *pboidReason,
    /* [in] */ BOOL fRetaining,
    /* [in] */ BOOL fAsync);


void __RPC_STUB ITransaction_Abort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITransaction_GetTransactionInfo_Proxy( 
    ITransaction __RPC_FAR * This,
    /* [out] */ XACTTRANSINFO __RPC_FAR *pinfo);


void __RPC_STUB ITransaction_GetTransactionInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITransaction_INTERFACE_DEFINED__ */


#ifndef __ITransactionDispenser_INTERFACE_DEFINED__
#define __ITransactionDispenser_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITransactionDispenser
 * at Tue Sep 23 15:58:35 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_ITransactionDispenser;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("3A6AD9E1-23B9-11cf-AD60-00AA00A74CCD")
    ITransactionDispenser : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetOptionsObject( 
            /* [out] */ ITransactionOptions __RPC_FAR *__RPC_FAR *ppOptions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginTransaction( 
            /* [in] */ IUnknown __RPC_FAR *punkOuter,
            /* [in] */ ISOLEVEL isoLevel,
            /* [in] */ ULONG isoFlags,
            /* [in] */ ITransactionOptions __RPC_FAR *pOptions,
            /* [out] */ ITransaction __RPC_FAR *__RPC_FAR *ppTransaction) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionDispenserVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITransactionDispenser __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITransactionDispenser __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITransactionDispenser __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOptionsObject )( 
            ITransactionDispenser __RPC_FAR * This,
            /* [out] */ ITransactionOptions __RPC_FAR *__RPC_FAR *ppOptions);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginTransaction )( 
            ITransactionDispenser __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *punkOuter,
            /* [in] */ ISOLEVEL isoLevel,
            /* [in] */ ULONG isoFlags,
            /* [in] */ ITransactionOptions __RPC_FAR *pOptions,
            /* [out] */ ITransaction __RPC_FAR *__RPC_FAR *ppTransaction);
        
        END_INTERFACE
    } ITransactionDispenserVtbl;

    interface ITransactionDispenser
    {
        CONST_VTBL struct ITransactionDispenserVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionDispenser_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITransactionDispenser_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITransactionDispenser_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITransactionDispenser_GetOptionsObject(This,ppOptions)	\
    (This)->lpVtbl -> GetOptionsObject(This,ppOptions)

#define ITransactionDispenser_BeginTransaction(This,punkOuter,isoLevel,isoFlags,pOptions,ppTransaction)	\
    (This)->lpVtbl -> BeginTransaction(This,punkOuter,isoLevel,isoFlags,pOptions,ppTransaction)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITransactionDispenser_GetOptionsObject_Proxy( 
    ITransactionDispenser __RPC_FAR * This,
    /* [out] */ ITransactionOptions __RPC_FAR *__RPC_FAR *ppOptions);


void __RPC_STUB ITransactionDispenser_GetOptionsObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITransactionDispenser_BeginTransaction_Proxy( 
    ITransactionDispenser __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *punkOuter,
    /* [in] */ ISOLEVEL isoLevel,
    /* [in] */ ULONG isoFlags,
    /* [in] */ ITransactionOptions __RPC_FAR *pOptions,
    /* [out] */ ITransaction __RPC_FAR *__RPC_FAR *ppTransaction);


void __RPC_STUB ITransactionDispenser_BeginTransaction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITransactionDispenser_INTERFACE_DEFINED__ */


#ifndef __ITransactionOptions_INTERFACE_DEFINED__
#define __ITransactionOptions_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITransactionOptions
 * at Tue Sep 23 15:58:35 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_ITransactionOptions;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("3A6AD9E0-23B9-11cf-AD60-00AA00A74CCD")
    ITransactionOptions : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetOptions( 
            /* [in] */ XACTOPT __RPC_FAR *pOptions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOptions( 
            /* [out][in] */ XACTOPT __RPC_FAR *pOptions) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionOptionsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITransactionOptions __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITransactionOptions __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITransactionOptions __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOptions )( 
            ITransactionOptions __RPC_FAR * This,
            /* [in] */ XACTOPT __RPC_FAR *pOptions);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOptions )( 
            ITransactionOptions __RPC_FAR * This,
            /* [out][in] */ XACTOPT __RPC_FAR *pOptions);
        
        END_INTERFACE
    } ITransactionOptionsVtbl;

    interface ITransactionOptions
    {
        CONST_VTBL struct ITransactionOptionsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionOptions_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITransactionOptions_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITransactionOptions_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITransactionOptions_SetOptions(This,pOptions)	\
    (This)->lpVtbl -> SetOptions(This,pOptions)

#define ITransactionOptions_GetOptions(This,pOptions)	\
    (This)->lpVtbl -> GetOptions(This,pOptions)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITransactionOptions_SetOptions_Proxy( 
    ITransactionOptions __RPC_FAR * This,
    /* [in] */ XACTOPT __RPC_FAR *pOptions);


void __RPC_STUB ITransactionOptions_SetOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITransactionOptions_GetOptions_Proxy( 
    ITransactionOptions __RPC_FAR * This,
    /* [out][in] */ XACTOPT __RPC_FAR *pOptions);


void __RPC_STUB ITransactionOptions_GetOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITransactionOptions_INTERFACE_DEFINED__ */


#ifndef __ITransactionOutcomeEvents_INTERFACE_DEFINED__
#define __ITransactionOutcomeEvents_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITransactionOutcomeEvents
 * at Tue Sep 23 15:58:35 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_ITransactionOutcomeEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("3A6AD9E2-23B9-11cf-AD60-00AA00A74CCD")
    ITransactionOutcomeEvents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Committed( 
            /* [in] */ BOOL fRetaining,
            /* [in] */ XACTUOW __RPC_FAR *pNewUOW,
            /* [in] */ HRESULT hr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Aborted( 
            /* [in] */ BOID __RPC_FAR *pboidReason,
            /* [in] */ BOOL fRetaining,
            /* [in] */ XACTUOW __RPC_FAR *pNewUOW,
            /* [in] */ HRESULT hr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HeuristicDecision( 
            /* [in] */ DWORD dwDecision,
            /* [in] */ BOID __RPC_FAR *pboidReason,
            /* [in] */ HRESULT hr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Indoubt( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionOutcomeEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITransactionOutcomeEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITransactionOutcomeEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITransactionOutcomeEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Committed )( 
            ITransactionOutcomeEvents __RPC_FAR * This,
            /* [in] */ BOOL fRetaining,
            /* [in] */ XACTUOW __RPC_FAR *pNewUOW,
            /* [in] */ HRESULT hr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Aborted )( 
            ITransactionOutcomeEvents __RPC_FAR * This,
            /* [in] */ BOID __RPC_FAR *pboidReason,
            /* [in] */ BOOL fRetaining,
            /* [in] */ XACTUOW __RPC_FAR *pNewUOW,
            /* [in] */ HRESULT hr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HeuristicDecision )( 
            ITransactionOutcomeEvents __RPC_FAR * This,
            /* [in] */ DWORD dwDecision,
            /* [in] */ BOID __RPC_FAR *pboidReason,
            /* [in] */ HRESULT hr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Indoubt )( 
            ITransactionOutcomeEvents __RPC_FAR * This);
        
        END_INTERFACE
    } ITransactionOutcomeEventsVtbl;

    interface ITransactionOutcomeEvents
    {
        CONST_VTBL struct ITransactionOutcomeEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionOutcomeEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITransactionOutcomeEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITransactionOutcomeEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITransactionOutcomeEvents_Committed(This,fRetaining,pNewUOW,hr)	\
    (This)->lpVtbl -> Committed(This,fRetaining,pNewUOW,hr)

#define ITransactionOutcomeEvents_Aborted(This,pboidReason,fRetaining,pNewUOW,hr)	\
    (This)->lpVtbl -> Aborted(This,pboidReason,fRetaining,pNewUOW,hr)

#define ITransactionOutcomeEvents_HeuristicDecision(This,dwDecision,pboidReason,hr)	\
    (This)->lpVtbl -> HeuristicDecision(This,dwDecision,pboidReason,hr)

#define ITransactionOutcomeEvents_Indoubt(This)	\
    (This)->lpVtbl -> Indoubt(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITransactionOutcomeEvents_Committed_Proxy( 
    ITransactionOutcomeEvents __RPC_FAR * This,
    /* [in] */ BOOL fRetaining,
    /* [in] */ XACTUOW __RPC_FAR *pNewUOW,
    /* [in] */ HRESULT hr);


void __RPC_STUB ITransactionOutcomeEvents_Committed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITransactionOutcomeEvents_Aborted_Proxy( 
    ITransactionOutcomeEvents __RPC_FAR * This,
    /* [in] */ BOID __RPC_FAR *pboidReason,
    /* [in] */ BOOL fRetaining,
    /* [in] */ XACTUOW __RPC_FAR *pNewUOW,
    /* [in] */ HRESULT hr);


void __RPC_STUB ITransactionOutcomeEvents_Aborted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITransactionOutcomeEvents_HeuristicDecision_Proxy( 
    ITransactionOutcomeEvents __RPC_FAR * This,
    /* [in] */ DWORD dwDecision,
    /* [in] */ BOID __RPC_FAR *pboidReason,
    /* [in] */ HRESULT hr);


void __RPC_STUB ITransactionOutcomeEvents_HeuristicDecision_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITransactionOutcomeEvents_Indoubt_Proxy( 
    ITransactionOutcomeEvents __RPC_FAR * This);


void __RPC_STUB ITransactionOutcomeEvents_Indoubt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITransactionOutcomeEvents_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_transact_0010
 * at Tue Sep 23 15:58:35 1997
 * using MIDL 3.01.75
 ****************************************/
/* [local] */ 




#if _MSC_VER < 1100 || !defined(__cplusplus)

DEFINE_GUID(IID_ITransaction,				0x0fb15084, 0xaf41, 0x11ce, 0xbd, 0x2b, 0x20, 0x4c, 0x4f, 0x4f, 0x50, 0x20);
DEFINE_GUID(IID_ITransactionDispenser,		0x3A6AD9E1, 0x23B9, 0x11cf, 0xAD, 0x60, 0x00, 0xAA, 0x00, 0xA7, 0x4C, 0xCD);
DEFINE_GUID(IID_ITransactionOptions,			0x3A6AD9E0, 0x23B9, 0x11cf, 0xAD, 0x60, 0x00, 0xAA, 0x00, 0xA7, 0x4C, 0xCD);
DEFINE_GUID(IID_ITransactionOutcomeEvents,	0x3A6AD9E2, 0x23B9, 0x11cf, 0xAD, 0x60, 0x00, 0xAA, 0x00, 0xA7, 0x4C, 0xCD);

#else

#define  IID_ITransaction                    __uuidof(ITransaction)
#define  IID_ITransactionDispenser           __uuidof(ITransactionDispenser)
#define  IID_ITransactionOptions             __uuidof(ITransactionOptions)
#define  IID_ITransactionOutcomeEvents       __uuidof(ITransactionOutcomeEvents)

#endif


extern RPC_IF_HANDLE __MIDL_itf_transact_0010_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_transact_0010_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\utsem.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/* ----------------------------------------------------------------------------
Microsoft   D.T.C (Distributed Transaction Coordinator)

(c) 1995    Microsoft Corporation.  All Rights Reserved

@doc

@module UTSem.H  |

@devnote None

@rev    4   | 6th-Jun-1997  |   JimLyon     | Rewrote
@rev    3   | 1st-Aug-1996  |   GaganC      | Added the spin lock code and class
@rev    2   | 31-May-1996   |   GaganC      | Removed the special code for x86
@rev    1   | 18th Jan, 96  |   GaganC      | Special cased UTGuard for X86
@rev    0   | 4th Feb,95    |   GaganC      | Created
---------------------------------------------------------------------------- */
#ifndef __UTSEM_H__
#define __UTSEM_H__


// -------------------------------------------------------------
//              INCLUDES
// -------------------------------------------------------------
#include "utilcode.h"


// -------------------------------------------------------------
//              CONSTANTS AND TYPES
// -------------------------------------------------------------
typedef enum {SLC_WRITE, SLC_READWRITE, SLC_READWRITEPROMOTE}
             SYNCH_LOCK_CAPS;

typedef enum {SLT_READ, SLT_READPROMOTE, SLT_WRITE}
             SYNCH_LOCK_TYPE;

const int NUM_SYNCH_LOCK_TYPES = SLT_WRITE + 1;



// -------------------------------------------------------------
//              FORWARDS
// -------------------------------------------------------------
class CSemExclusive;
class CSemExclusiveSL;
class CLock;
class UTGuard;
class UTSemReadWrite;
class UTSemRWMgrRead;
class UTSemRWMgrWrite;


// -------------------------------------------------------------
//                  GLOBAL HELPER FUNCTIONS
// -------------------------------------------------------------


/* ----------------------------------------------------------------------------
 @func Description:<nl>

   Guarantees isolated increments of *pl.<nl><nl>

 Usage:<nl>
   Use instead of InterlockedIncrement for Win16/Win32 portability.<nl><nl>

 @rev 0 | 3/21/95 | Rcraig | Created.
---------------------------------------------------------------------------- */
inline LONG SafeIncrement ( LPLONG pl )
{
    return (InterlockedIncrement (pl));
} // SafeIncrement



/* ----------------------------------------------------------------------------
 @func Description:<nl>
   Win16/Win32 abstraction wrapper: 
   Guarantees isolated decrements of *pl.<nl><nl>

 Usage:<nl>
   Use instead of InterlockedDecrement for Win16/Win32 portability.<nl><nl>

 @rev 0 | 3/21/95 | Rcraig | Created.
---------------------------------------------------------------------------- */
inline LONG SafeDecrement ( LPLONG pl )
{
    return (InterlockedDecrement (pl));
} // SafeDecrement



/* ----------------------------------------------------------------------------
@class CSemExclusive:

    An instance of this class represents an exclusive lock. If one thread calls
    Lock(), it will wait until any other thread that has called Lock() calls
    Unlock().

    A thread MAY call Lock multiple times.  It needs to call Unlock a matching
    number of times before the object is available to other threads.

    @rev    2   | 25, Mar 98 | JasonZ       | Added debug IsLocked code
    @rev    1   | 6th Jun 97 | JimLyon      | Added optional spin count
    @rev    0   | 4th Feb,95 | GaganC       | Created
---------------------------------------------------------------------------- */
class CSemExclusive
{
public:
    // Parameter to constructor is the maximum number of times to spin when
    // attempting to acquire the lock. The thread will sleep if the lock does
    // not become available in this period.
    CSemExclusive (unsigned long ulcSpinCount = 0);
    ~CSemExclusive (void)           { DeleteCriticalSection (&m_csx); }
    void Lock (void)                { EnterCriticalSection (&m_csx); _ASSERTE(++m_iLocks > 0);}
    void UnLock (void)              { _ASSERTE(--m_iLocks >= 0);  LeaveCriticalSection (&m_csx); }

#ifdef _DEBUG
    int IsLocked()                  { return (m_iLocks > 0); }
#endif

private:
    CRITICAL_SECTION m_csx;
#ifdef _DEBUG
    int             m_iLocks;           // Count of locks.
#endif
};  //end class CSemExclusive





/* ----------------------------------------------------------------------------
@class CSemExclusiveSL:

    A subclass of CSemExclusive with a different default constructor.
    This subclass is appropriate for locks that are:
    *   Frequently Lock'd and Unlock'd, and
    *   Are held for very brief intervals.


    @rev    1   | 6th Jun 97 | JimLyon      | Rewritten to use CSemExclusive
    @rev    0   | ???        | ???          | Created
---------------------------------------------------------------------------- */
class CSemExclusiveSL : public CSemExclusive
{
public:
    CSemExclusiveSL (unsigned long ulcSpinCount = 400) : CSemExclusive (ulcSpinCount) {}
};


/* ----------------------------------------------------------------------------
@class CLock

    An instance of this class represents the holding of a lock on an instance
    of CSemExclusive. When this object is destroyed, the read lock will be
    automatically released.

@rev    1   | 9th Jun,97 | JimLyon      | Rewritten
@rev    0   | ???        | ???          | Created
---------------------------------------------------------------------------- */

class CLock
{
public:
    CLock (CSemExclusive* val) : m_pSem(val), m_locked(TRUE) {m_pSem->Lock();}
    CLock (CSemExclusive& val) : m_pSem(&val), m_locked(TRUE) {m_pSem->Lock();}
    CLock (CSemExclusive* val,BOOL fInitiallyLocked) : m_pSem(val), m_locked(fInitiallyLocked) {if (fInitiallyLocked) m_pSem->Lock();}
    ~CLock () { if (m_locked) m_pSem->UnLock(); }
    void Unlock () {m_pSem->UnLock(); m_locked = FALSE;}
    void Lock () {m_pSem->Lock(); m_locked = TRUE;}

private:
    BOOL m_locked;
    CSemExclusive* m_pSem;
};


/* ----------------------------------------------------------------------------
Convenience #define's for use with CSemExclusive and CLock

  These #define's assume that your object has a member named 'm_semCritical'.

  LOCK()        // locks m_semCritical; released at end of function if not sooner
  LOCKON(x)     // locks 'x', which is a CSemExclusive
  UNLOCK()      // undo effect of LOCK(), LOCKON(x), or RELOCK()
  RELOCK()      // re-locks the object that UNLOCK() unlocks
  READYLOCK()   // allows use of RELOCK() and UNLOCK() to lock 'm_semCritical', but
                // does not grab the lock at this time.
  READYLOCKON(x)// allows use of RELOCK() and UNLOCK() to lock 'x', but does not
                // grab the lock at this time.

---------------------------------------------------------------------------- */


#define LOCKON(x)       CLock _ll1(x)
#define LOCK()          CLock _ll1(&m_semCritical)
#define READYLOCKON(x)  CLock _ll1(x, FALSE)
#define READYLOCK()     CLock _ll1(&m_semCritical, FALSE)
#define UNLOCK()        _ll1.Unlock()
#define RELOCK()        _ll1.Lock()

#define AUTO_CRIT_LOCK(plck) CLock __sLock(plck)
#define CRIT_LOCK(plck) plck->Lock()
#define CRIT_UNLOCK(plck) plck->Unlock()




/* ----------------------------------------------------------------------------
@function VipInterlockedCompareExchange:
    This function is exactly equivalent to the system-defined InterlockedCompareExchange,
    except that it is inline, and therefore works on Win95.

    It does the following atomically:
    {
        temp = *Destination;
        if (*Destination == Comperand)
            *Destination = Exchange;
        return temp;
    }

    This function occufrs in three variations, for parameters of type void*,
    long, and unsigned long.

    @rev    0   | 13 Jun 97 | JimLyon       | Created
                | 14 May 98 | Brianbec      | for IA64, the 1st one is really equivalent
                                            | to I.C.E.Pointer in wdm.h, not to 
                                            | I.C.E. raw, itself, alone.  Note 
                                            | that the SDK64 version doesn't understand
                                            | volatile, so I crossed my fingers and
                                            | casted it away. 
---------------------------------------------------------------------------- */

#ifdef _IA64_ 

inline LONG VipInterlockedCompareExchange(volatile ULONG* Destination, ULONG Exchange, ULONG Comparand)
{
    return InterlockedCompareExchange((LPLONG)Destination, (LONG)Exchange, (LONG)Comparand);
}

inline LONG VipInterlockedCompareExchange(volatile LONG* Destination, LONG Exchange, LONG Comparand)
{
    return InterlockedCompareExchange((LPLONG)Destination, Exchange, Comparand);
}

inline PVOID VipInterlockedCompareExchange(volatile PVOID* Destination, PVOID Exchange, PVOID Comparand)
{
    return InterlockedCompareExchangePointer((PVOID*)Destination, Exchange, Comparand);
}

#else // !_IA64_

#pragma warning (disable: 4035)     // function doesn't return value warning.
inline void* VipInterlockedCompareExchange (void*volatile* Destination, void* Exchange, void* Comparand)
{
#   ifdef _X86_
        __asm
        {
            mov     eax, Comparand
            mov     ecx, Destination
            mov     edx, Exchange
            lock cmpxchg [ecx], edx
        }           // function result is in eax
#   else
        return InterlockedCompareExchange ((void**) Destination, Exchange, Comparand);
#   endif // _X86_
}
#pragma warning (default: 4035)     // function doesn't return value warning

inline long VipInterlockedCompareExchange (volatile long* Destination, long Exchange, long Comparand)
{
#ifdef _X86_
        __asm
        {
            mov     eax, Comparand
            mov     ecx, Destination
            mov     edx, Exchange
            lock cmpxchg [ecx], edx
        }           // function result is in eax
#else
    return InterlockedCompareExchange(Destination, Exchange, Comparand);
#endif
}

inline unsigned long VipInterlockedCompareExchange (volatile unsigned long* Destination, unsigned long Exchange, unsigned long Comparand)
{
#ifdef _X86_
        __asm
        {
            mov     eax, Comparand
            mov     ecx, Destination
            mov     edx, Exchange
            lock cmpxchg [ecx], edx
        }           // function result is in eax
#else
    return InterlockedCompareExchange(Destination, Exchange, Comparand);
#endif
}

#endif // !_IA64_

/* ----------------------------------------------------------------------------
@class  UTGuard
    This object represents a guard that can be acquired or released. The 
    advantage with useing this instead of a critical section is that this
    is non blocking. If AcquireGuard fails, it will return false and will not
    block.

@rev    0   | 4th Feb,95 | GaganC       | Created
---------------------------------------------------------------------------- */
class UTGuard
{
private:
    long            m_lVal;

public:
    //@cmember Constructor
    UTGuard (void)                      { m_lVal = 0; }
    //@cmember Destructor
    ~UTGuard (void)                     {}

    //@cmember  Acquires the guard
    BOOL            AcquireGuard (void) { return 0 == InterlockedExchange (&m_lVal, 1); }
    //@cmember  Releases the guard
    void            ReleaseGuard (void) { m_lVal = 0; }
    
    //@cmember  Initializes the Guard
    void            Init (void)         { m_lVal = 0; }
} ; //End class UTGuard



/* ----------------------------------------------------------------------------
@class UTSemReadWrite

    An instance of class UTSemReadWrite provides multi-read XOR single-write
    (a.k.a. shared vs. exclusive) lock capabilities, with protection against
    writer starvation.

    A thread MUST NOT call any of the Lock methods if it already holds a Lock.
    (Doing so may result in a deadlock.)

@rev    1   | 9th Jun,97 | JimLyon      | Rewritten
@rev    0   | 4th Feb,95 | GaganC       | Created
---------------------------------------------------------------------------- */
class UTSemReadWrite
{
public:
    UTSemReadWrite(unsigned long ulcSpinCount = 0,
            LPCSTR szSemaphoreName = NULL, LPCSTR szEventName = NULL); // Constructor
    ~UTSemReadWrite(void);                  // Destructor

    // This implementation supports Read and Write locks
    SYNCH_LOCK_CAPS GetCaps(void)   { return SLC_READWRITE; };

    void LockRead(void);                    // Lock the object for reading
    void LockWrite(void);                   // Lock the object for writing
    void UnlockRead(void);                  // Unlock the object for reading
    void UnlockWrite(void);                 // Unlock the object for writing

    // This object is valid if it was initialized
    BOOL IsValid(void)              { return TRUE; }

    BOOL Lock(SYNCH_LOCK_TYPE t)            // Lock the object, mode specified by parameter
    {
        if (t == SLT_READ)
        {
            LockRead();
            return TRUE;
        }

        if (t == SLT_WRITE)
        {
            LockWrite();
            return TRUE;
        }
        return FALSE;
    }

    BOOL UnLock(SYNCH_LOCK_TYPE t)          // Unlock the object, mode specified by parameter
    {
        if (t == SLT_READ)
        {
            UnlockRead();
            return TRUE;
        }
        if (t == SLT_WRITE)
        {
            UnlockWrite();
            return TRUE;
        }
        return FALSE;
    }

private:
    virtual HANDLE GetReadWaiterSemaphore(void); // return Read Waiter Semaphore handle, creating if necessary
    virtual HANDLE GetWriteWaiterEvent (void); // return Write Waiter Event handle, creating if necessary

    unsigned long m_ulcSpinCount;           // spin counter
    volatile unsigned long m_dwFlag;        // internal state, see implementation
    HANDLE m_hReadWaiterSemaphore;          // semaphore for awakening read waiters
    HANDLE m_hWriteWaiterEvent;             // event for awakening write waiters
    LPCSTR m_szSemaphoreName;               // For cross process handle creation.
    LPCSTR m_szEventName;                   // For cross process handle creation.
};



/* ----------------------------------------------------------------------------
@class UTSemRWMgrRead

    An instance of this class represents the holding of a read lock on an instance
    of UTSemReadWrite. When this object is destroyed, the read lock will be
    automatically released.

@rev    1   | 9th Jun,97 | JimLyon      | Rewritten
@rev    0   | 4th Feb,95 | GaganC       | Created
---------------------------------------------------------------------------- */

class UTSemRWMgrRead
{
public:
    UTSemRWMgrRead (UTSemReadWrite* pSemRW) { m_pSemRW = pSemRW; pSemRW->LockRead(); };
    ~UTSemRWMgrRead () { m_pSemRW->UnlockRead(); }

private:
    UTSemReadWrite* m_pSemRW;
};


/* ----------------------------------------------------------------------------
@class UTSemRWMgrWrite

    An instance of this class represents the holding of a write lock on an instance
    of UTSemReadWrite. When this object is destroyed, the write lock will be
    automatically released.

@rev    1   | 9th Jun,97 | JimLyon      | Rewritten
@rev    0   | 4th Feb,95 | GaganC       | Created
---------------------------------------------------------------------------- */

class UTSemRWMgrWrite
{
public:
    inline UTSemRWMgrWrite (UTSemReadWrite* pSemRW) { m_pSemRW = pSemRW; pSemRW->LockWrite(); };
    inline ~UTSemRWMgrWrite () { m_pSemRW->UnlockWrite(); }

private:
    UTSemReadWrite* m_pSemRW;
};


#endif __UTSEM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\vererror.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/**************************************************************************************
 **                                                                                  **
 ** Vererror.h - definitions of data structures, needed to report verifier errors.   **
 **                                                                                  **
 **************************************************************************************/


#pragma once

#ifndef _VER_RAW_STRUCT_FOR_IDL_
#include "CorHdr.h"
#include "OpEnum.h"
#include "CorError.h"


// Set these flags if the error info fields are valid.

#define VER_ERR_FATAL		0x80000000L	// Cannot Continue
#define VER_ERR_OFFSET		0x00000001L
#define VER_ERR_OPCODE	  	0x00000002L
#define VER_ERR_OPERAND		0x00000004L
#define VER_ERR_TOKEN		0x00000008L
#define VER_ERR_EXCEP_NUM_1	0x00000010L
#define VER_ERR_EXCEP_NUM_2	0x00000020L
#define VER_ERR_STACK_SLOT  0x00000040L
#define VER_ERR_ITEM_1      0x00000080L
#define VER_ERR_ITEM_2      0x00000100L
#define VER_ERR_ITEM_F      0x00000200L
#define VER_ERR_ITEM_E      0x00000400L

#define VER_ERR_SIG_MASK	0x07000000L	// Enum
#define VER_ERR_METHOD_SIG 	0x01000000L
#define VER_ERR_LOCAL_SIG  	0x02000000L
#define VER_ERR_FIELD_SIG	0x03000000L
#define VER_ERR_CALL_SIG	0x04000000L

#define VER_ERR_OPCODE_OFFSET (VER_ERR_OPCODE|VER_ERR_OFFSET)

#define VER_ERR_LOCAL_VAR   VER_ERR_LOCAL_SIG
#define VER_ERR_ARGUMENT    VER_ERR_METHOD_SIG

#define VER_ERR_ARG_RET	    0xFFFFFFFEL		// The Argument # is return
#define VER_ERR_NO_ARG	    0xFFFFFFFFL		// Argument # is not valid
#define VER_ERR_NO_LOC	    VER_ERR_NO_ARG	// Local # is not valid

typedef struct
{
	DWORD dwFlags;	// BYREF / BOXED etc.. see veritem.hpp
	void* pv;		// TypeHandle / MethodDesc * etc.
} _VerItem;

// This structure is used to fully define a verification error.
// Verification error codes are found in CorError.h
// The error resource strings are found in src/dlls/mscorrc/mscor.rc

typedef struct
{
	DWORD   dwFlags;            // VER_ERR_XXX

    union {
        OPCODE  opcode;
        unsigned long padding1; // to match with idl generated struct size
    };

    union {
        DWORD   dwOffset;       // #of bytes from start of method
        long    uOffset;        // for backward compat with Metadata validator
    };

    union {
        mdToken         token;
        mdToken         Token;  // for backward compat with metadata validator
        BYTE	        bCallConv;
        CorElementType  elem;
        DWORD           dwStackSlot; // positon in the Stack
        unsigned long   padding2;    // to match with idl generated struct size
    };

    union {
        _VerItem sItem1;
        _VerItem sItemFound;
        DWORD dwException1;		// Exception Record #
        DWORD dwVarNumber;	    // Variable #
        DWORD dwArgNumber;	    // Argument #
        DWORD dwOperand;        // Operand for the opcode
    };

    union {
        _VerItem sItem2;
        _VerItem sItemExpected;
        DWORD dwException2;	    // Exception Record #
    };

} VerError;

#else

// Assert that sizeof(_VerError) == sizeof(VerError) in Verifier.cpp
typedef struct tag_VerError
{
    unsigned long flags;            // DWORD
    unsigned long opcode;           // OPCODE, padded to ulong
    unsigned long uOffset;           // DWORD
    unsigned long Token;            // mdToken
    unsigned long item1_flags;      // _VerItem.DWORD
    int           *item1_data;      // _VerItem.PVOID
    unsigned long item2_flags;      // _VerItem.DWORD
    int           *item2_data;      // _VerItem.PVOID
}  _VerError;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\warningcontrol.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// warningcontrol.h
//
// Header file to globally control the warning settings for the entire Viper build.
// You do not need to explicitly include this file; rather, it gets included
// on the command line with a /FI (force include) directive. This is controlled
// in sources.vip.
//
// KEEP THIS LIST SORTED!
//
#pragma warning(disable :4001)	 // "nonstandard extension 'single line comment' was used"
#pragma warning(error	:4007)	 // 'main' : must be __cdecl
#pragma warning(disable :4010)	 // "single-line comment contains line-continuation character"
#pragma warning(error	:4013)	 // 'function' undefined - assuming extern returning int
#pragma warning(disable :4022)	 // "'%s' : pointer mismatch for actual parameter %d"
#pragma warning(disable :4047)	 // "'%$L' : '%$T' differs in levels of indirection from '%$T'"
#pragma warning(disable :4053)	 // "one void operand for '?:'"
#pragma warning(disable :4056)	 // "overflow in floating-point constant arithmetic"
#pragma warning(disable :4061)	 // "enumerate '%$S' in switch of enum '%$S' is not explicitly handled by a case label"
#pragma warning(error	:4071)	 // no function prototype given
#pragma warning(error	:4072)	 // no function prototype given (fastcall)
#pragma warning(3		:4092)	 // sizeof returns 'unsigned long'
#pragma warning(disable :4100)	 // "'%$S' : unreferenced formal parameter"
//#pragma warning(error	:4101)	 // "'%$S' : unreferenced local variable"
//#pragma warning(error	:4102)	 // "'%$S' : unreferenced label"
#pragma warning(3		:4121)	 // structure is sensitive to alignment
#pragma warning(disable :4127)	 // "conditional expression is constant"
#pragma warning(3		:4125)	 // decimal digit in octal sequence
#pragma warning(3		:4130)	 // logical operation on address of string constant
#pragma warning(3		:4132)	 // const object should be initialized
#pragma warning(error	:4171)	 // no function prototype given (old style)
#pragma warning(4		:4177)	 // pragma data_seg s/b at global scope
#pragma warning(disable :4201)	 // "nonstandard extension used : nameless struct/union"
#pragma warning(disable :4204)	 // "nonstandard extension used : non-constant aggregate initializer"
#pragma warning(4		:4206)	 // Source File is empty
#pragma warning(3		:4212)	 // function declaration used ellipsis
#pragma warning(error	        :4259)	 // pure virtual function was not defined
#pragma warning(disable	        :4291)	 // delete not defined for new, c++ exception may cause leak
#pragma warning(3		:4509)	 // "nonstandard extension used: '%$S' uses SEH and '%$S' has destructor"
								 //
								 // But beware of doing a return from inside such a try block:
								 //
								 // 	int foo()
								 // 		{
								 // 		ClassWithDestructor c;
								 // 		__try {
								 // 			return 0;
								 // 		} __finally {
								 // 			printf("in finally");
								 // 		}
								 //
								 // as (it's a bug) the return value gets toasted. So DON'T casually
								 // dismiss this warning if you're compiling w/o CXX EH turned on (the default).

#pragma warning(3		:4530)	 // C++ exception handler used, but unwind semantics are not enabled. Specify -GX
#pragma warning(error	:4551)	 // Function call missing argument list

#pragma warning(error	:4700)	 // Local used w/o being initialized
#pragma warning(disable	:4706)	 // assignment within conditional expression
#pragma warning(disable :4786)	 // identifier was truncated to '255' characters in the browser (or debug) information
#pragma warning(error	:4806)	 // unsafe operation involving type 'bool'
#pragma warning(disable	:4995)	 // '_OLD_IOSTREAMS_ARE_DEPRECATED': name was marked as #pragma deprecated
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\winwrap.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// WinWrap.h
//
// This file contains wrapper functions for Win32 API's that take strings.
// Support on each platform works as follows:
//      OS          Behavior
//      ---------   -------------------------------------------------------
//      NT          Fully supports both W and A funtions.
//      Win 9x      Supports on A functions, stubs out the W functions but
//                      then fails silently on you with no warning.
//      CE          Only has the W entry points.
//
// The Common Language Runtime internally uses UNICODE as the internal state 
// and string format.  This file will undef the mapping macros so that one 
// cannot mistakingly call a method that isn't going to work.  Instead, you 
// have to call the correct wrapper API.
//
//*****************************************************************************
#pragma once


//********** Macros. **********************************************************
#if !defined(WIN32_LEAN_AND_MEAN)
#define WIN32_LEAN_AND_MEAN
#endif
#if !defined(WIN32_LEAN_AND_MEAN)
#define INC_OLE2
#endif

#ifdef _WIN64
#define HIWORD64(p)     ((ULONG_PTR)(p) >> 16)
#else
#define HIWORD64        HIWORD
#endif

#define SAFEDELARRAY(p) if ((p) != NULL) { delete [] p; (p) = NULL; }

//********** Includes. ********************************************************

#include <crtwrap.h>
#include <windows.h>
#include <wincrypt.h>


#if !defined(__TODO_PORT_TO_WRAPPERS__)
//*****************************************************************************
// Undefine all of the windows wrappers so you can't use them.
//*****************************************************************************

// wincrypt.h
#undef CryptAcquireContext

// winbase.h
#undef GetBinaryType
#undef GetShortPathName
#undef GetLongPathName
#undef GetEnvironmentStrings  
#undef FreeEnvironmentStrings  
#undef FormatMessage  
#undef CreateMailslot  
#undef EncryptFile  
#undef DecryptFile  
#undef OpenRaw  
#undef QueryRecoveryAgents  
#undef lstrcmp  
#undef lstrcmpi  
#undef lstrcpyn  
#undef lstrcpy  
#undef lstrcat  
#undef lstrlen  
#undef CreateMutex  
#undef OpenMutex  
#undef CreateEvent  
#undef OpenEvent  
#undef CreateSemaphore  
#undef OpenSemaphore  
#undef CreateWaitableTimer  
#undef OpenWaitableTimer  
#undef CreateFileMapping  
#undef OpenFileMapping  
#undef GetLogicalDriveStrings  
#undef LoadLibrary  
#undef LoadLibraryEx  
#undef GetModuleFileName  
#undef GetModuleHandle  
#undef CreateProcess  
#undef FatalAppExit  
#undef GetStartupInfo  
#undef GetCommandLine  
#undef GetEnvironmentVariable  
#undef SetEnvironmentVariable  
#undef ExpandEnvironmentStrings  
#undef OutputDebugString  
#undef FindResource  
#undef FindResourceEx  
#undef EnumResourceTypes  
#undef EnumResourceNames  
#undef EnumResourceLanguages  
#undef BeginUpdateResource  
#undef UpdateResource  
#undef EndUpdateResource  
#undef GlobalAddAtom  
#undef GlobalFindAtom  
#undef GlobalGetAtomName  
#undef AddAtom  
#undef FindAtom  
#undef GetAtomName  
#undef GetProfileInt  
#undef GetProfileString  
#undef WriteProfileString  
#undef GetProfileSection  
#undef WriteProfileSection  
#undef GetPrivateProfileInt  
#undef GetPrivateProfileString  
#undef WritePrivateProfileString  
#undef GetPrivateProfileSection  
#undef WritePrivateProfileSection  
#undef GetPrivateProfileSectionNames  
#undef GetPrivateProfileStruct  
#undef WritePrivateProfileStruct  
#undef GetDriveType  
#undef GetSystemDirectory  
#undef GetTempPath  
#undef GetTempFileName  
#undef GetWindowsDirectory  
#undef SetCurrentDirectory  
#undef GetCurrentDirectory  
#undef GetDiskFreeSpace  
#undef GetDiskFreeSpaceEx  
#undef CreateDirectory  
#undef CreateDirectoryEx  
#undef RemoveDirectory  
#undef GetFullPathName  
#undef DefineDosDevice  
#undef QueryDosDevice  
#undef CreateFile  
#undef SetFileAttributes  
#undef GetFileAttributes  
#undef GetCompressedFileSize  
#undef DeleteFile  
#undef FindFirstFileEx  
#undef FindFirstFile  
#undef FindNextFile  
#undef SearchPath  
#undef CopyFile  
#undef CopyFileEx  
#undef MoveFile  
#undef MoveFileEx  
#undef MoveFileWithProgress  
#undef CreateSymbolicLink  
#undef QuerySymbolicLink  
#undef CreateHardLink  
#undef CreateNamedPipe  
#undef GetNamedPipeHandleState  
#undef CallNamedPipe  
#undef WaitNamedPipe  
#undef SetVolumeLabel  
#undef GetVolumeInformation  
#undef ClearEventLog  
#undef BackupEventLog  
#undef OpenEventLog  
#undef RegisterEventSource  
#undef OpenBackupEventLog  
#undef ReadEventLog  
#undef ReportEvent  
#undef AccessCheckAndAuditAlarm  
#undef AccessCheckByTypeAndAuditAlarm  
#undef AccessCheckByTypeResultListAndAuditAlarm  
#undef ObjectOpenAuditAlarm  
#undef ObjectPrivilegeAuditAlarm  
#undef ObjectCloseAuditAlarm  
#undef ObjectDeleteAuditAlarm  
#undef PrivilegedServiceAuditAlarm  
#undef SetFileSecurity  
#undef GetFileSecurity  
#undef FindFirstChangeNotification  
#undef IsBadStringPtr  
#undef LookupAccountSid
#undef LookupAccountName  
#undef LookupPrivilegeValue  
#undef LookupPrivilegeName  
#undef LookupPrivilegeDisplayName  
#undef BuildCommDCB  
#undef BuildCommDCBAndTimeouts  
#undef CommConfigDialog  
#undef GetDefaultCommConfig  
#undef SetDefaultCommConfig  
#undef GetComputerName  
#undef SetComputerName  
#undef GetUserName  
#undef LogonUser  
#undef CreateProcessAsUser  
#undef GetCurrentHwProfile  
#undef GetVersionEx  
#undef CreateJobObject  
#undef OpenJobObject  

// winuser.h
#undef MAKEINTRESOURCE  
#undef wvsprintf  
#undef wsprintf  
#undef LoadKeyboardLayout  
#undef GetKeyboardLayoutName  
#undef CreateDesktop  
#undef OpenDesktop  
#undef EnumDesktops  
#undef CreateWindowStation  
#undef OpenWindowStation  
#undef EnumWindowStations  
#undef GetUserObjectInformation  
#undef SetUserObjectInformation  
#undef RegisterWindowMessage  
#undef SIZEZOOMSHOW        
#undef WS_TILEDWINDOW      
#undef GetMessage  
#undef DispatchMessage  
#undef PeekMessage  
#undef SendMessage  
#undef SendMessageTimeout  
#undef SendNotifyMessage  
#undef SendMessageCallback  
#undef BroadcastSystemMessage  
#undef RegisterDeviceNotification  
#undef PostMessage  
#undef PostThreadMessage  
#undef PostAppMessage  
#undef DefWindowProc  
#undef CallWindowProc  
#undef CallWindowProc  
#undef RegisterClass  
#undef UnregisterClass  
#undef GetClassInfo  
#undef RegisterClassEx  
#undef GetClassInfoEx  
#undef CreateWindowEx  
#undef CreateWindow  
#undef CreateDialogParam  
#undef CreateDialogIndirectParam  
#undef CreateDialog  
#undef CreateDialogIndirect  
#undef DialogBoxParam  
#undef DialogBoxIndirectParam  
#undef DialogBox  
#undef DialogBoxIndirect  
#undef SetDlgItemText  
#undef GetDlgItemText  
#undef SendDlgItemMessage  
#undef DefDlgProc  
#undef CallMsgFilter  
#undef RegisterClipboardFormat  
#undef GetClipboardFormatName  
#undef CharToOem  
#undef OemToChar  
#undef CharToOemBuff  
#undef OemToCharBuff  
#undef CharUpper  
#undef CharUpperBuff  
#undef CharLower  
#undef CharLowerBuff  
#undef CharNext  
//@todo: Does 95 support this? #undef CharPrev  
#undef IsCharAlpha  
#undef IsCharAlphaNumeric  
#undef IsCharUpper  
#undef IsCharLower  
#undef GetKeyNameText  
#undef VkKeyScan  
#undef VkKeyScanEx  
#undef MapVirtualKey  
#undef MapVirtualKeyEx  
#undef LoadAccelerators  
#undef CreateAcceleratorTable  
#undef CopyAcceleratorTable  
#undef TranslateAccelerator  
#undef LoadMenu  
#undef LoadMenuIndirect  
#undef ChangeMenu  
#undef GetMenuString  
#undef InsertMenu  
#undef AppendMenu  
#undef ModifyMenu  
#undef InsertMenuItem  
#undef GetMenuItemInfo  
#undef SetMenuItemInfo  
#undef DrawText  
#undef DrawTextEx  
#undef GrayString  
#undef DrawState  
#undef TabbedTextOut  
#undef GetTabbedTextExtent  
#undef SetProp  
#undef GetProp  
#undef RemoveProp  
#undef EnumPropsEx  
#undef EnumProps  
#undef SetWindowText  
#undef GetWindowText  
#undef GetWindowTextLength  
#undef MessageBox  
#undef MessageBoxEx  
#undef MessageBoxIndirect  
#undef COLOR_3DSHADOW          
#undef GetWindowLong  
#undef SetWindowLong  
#undef GetClassLong  
#undef SetClassLong  
#undef FindWindow  
#undef FindWindowEx  
#undef GetClassName  
#undef SetWindowsHook  
#undef SetWindowsHook  
#undef SetWindowsHookEx  
#undef MFT_OWNERDRAW       
#undef LoadBitmap  
#undef LoadCursor  
#undef LoadCursorFromFile  
#undef LoadIcon  
#undef LoadImage  
#undef LoadString  
#undef IsDialogMessage  
#undef DlgDirList  
#undef DlgDirSelectEx  
#undef DlgDirListComboBox  
#undef DlgDirSelectComboBoxEx  
#undef DefFrameProc  
#undef DefMDIChildProc  
#undef CreateMDIWindow  
#undef WinHelp  
#undef ChangeDisplaySettings  
#undef ChangeDisplaySettingsEx  
#undef EnumDisplaySettings  
#undef EnumDisplayDevices  
#undef SystemParametersInfo  
#undef GetMonitorInfo  
#undef GetWindowModuleFileName  
#undef RealGetWindowClass  
#undef GetAltTabInfo

// Win32 Fusion API's
#undef ReleaseActCtx
#undef GetCurrentActCtx
#undef QueryActCtxW

#endif


//
// Win CE only supports the wide entry points, no ANSI.  So we redefine
// the wrappers right back to the *W entry points as macros.  This way no
// client code needs a wrapper on CE.
//
// _X86_ includes only 32-bit Windows on Intel.  Given every other platform
// we currently port to besides this platform is UNICODE, it makes no sense
// to force them to have both bound (for example, 32-bit Alpha).  Bug 2757.
//
#ifndef _X86_

// crypt.h
#define WszCryptAcquireContext CryptAcquireContextW

// winbase.h
#define WszGetBinaryType GetBinaryTypeW
#define WszGetShortPathName GetShortPathNameW
#define WszGetLongPathName GetLongPathNameW
#define WszGetEnvironmentStrings   GetEnvironmentStringsW
#define WszFreeEnvironmentStrings   FreeEnvironmentStringsW
#define WszFormatMessage   FormatMessageW
#define WszCreateMailslot   CreateMailslotW
#define WszEncryptFile   EncryptFileW
#define WszDecryptFile   DecryptFileW
#define WszOpenRaw   OpenRawW
#define WszQueryRecoveryAgents   QueryRecoveryAgentsW
#define Wszlstrcmp   lstrcmpW
#define Wszlstrcmpi   lstrcmpiW
#define Wszlstrcpy lstrcpyW
#define Wszlstrcat lstrcatW
#define WszCreateMutex CreateMutexW
#define WszOpenMutex OpenMutexW
#define WszCreateEvent CreateEventW
#define WszOpenEvent OpenEventW
#define WszCreateWaitableTimer CreateWaitableTimerW
#define WszOpenWaitableTimer OpenWaitableTimerW
#define WszCreateFileMapping CreateFileMappingW
#define WszOpenFileMapping OpenFileMappingW
#define WszGetLogicalDriveStrings GetLogicalDriveStringsW
#define WszLoadLibrary LoadLibraryW
#define WszLoadLibraryEx LoadLibraryExW
#define WszGetModuleFileName GetModuleFileNameW
#define WszGetModuleHandle GetModuleHandleW
#define WszCreateProcess CreateProcessW
#define WszFatalAppExit FatalAppExitW
#define WszGetStartupInfo GetStartupInfoW
#define WszGetCommandLine GetCommandLineW
#define WszGetEnvironmentVariable GetEnvironmentVariableW
#define WszSetEnvironmentVariable SetEnvironmentVariableW
#define WszExpandEnvironmentStrings ExpandEnvironmentStringsW
#define WszOutputDebugString OutputDebugStringW
#define WszFindResource FindResourceW
#define WszFindResourceEx FindResourceExW
#define WszEnumResourceTypes EnumResourceTypesW
#define WszEnumResourceNames EnumResourceNamesW
#define WszEnumResourceLanguages EnumResourceLanguagesW
#define WszBeginUpdateResource BeginUpdateResourceW
#define WszUpdateResource UpdateResourceW
#define WszEndUpdateResource EndUpdateResourceW
#define WszGlobalAddAtom GlobalAddAtomW
#define WszGlobalFindAtom GlobalFindAtomW
#define WszGlobalGetAtomName GlobalGetAtomNameW
#define WszAddAtom AddAtomW
#define WszFindAtom FindAtomW
#define WszGetAtomName GetAtomNameW
#define WszGetProfileInt GetProfileIntW
#define WszGetProfileString GetProfileStringW
#define WszWriteProfileString WriteProfileStringW
#define WszGetProfileSection GetProfileSectionW
#define WszWriteProfileSection WriteProfileSectionW
#define WszGetPrivateProfileInt GetPrivateProfileIntW
#define WszGetPrivateProfileString GetPrivateProfileStringW
#define WszWritePrivateProfileString WritePrivateProfileStringW
#define WszGetPrivateProfileSection GetPrivateProfileSectionW
#define WszWritePrivateProfileSection WritePrivateProfileSectionW
#define WszGetPrivateProfileSectionNames GetPrivateProfileSectionNamesW
#define WszGetPrivateProfileStruct GetPrivateProfileStructW
#define WszWritePrivateProfileStruct WritePrivateProfileStructW
#define WszGetDriveType GetDriveTypeW
#define WszGetSystemDirectory GetSystemDirectoryW
#define WszGetTempPath GetTempPathW
#define WszGetTempFileName GetTempFileNameW
#define WszGetWindowsDirectory GetWindowsDirectoryW
#define WszSetCurrentDirectory SetCurrentDirectoryW
#define WszGetCurrentDirectory GetCurrentDirectoryW
#define WszGetDiskFreeSpace GetDiskFreeSpaceW
#define WszGetDiskFreeSpaceEx GetDiskFreeSpaceExW
#define WszCreateDirectory CreateDirectoryW
#define WszCreateDirectoryEx CreateDirectoryExW
#define WszRemoveDirectory RemoveDirectoryW
#define WszGetFullPathName GetFullPathNameW
#define WszDefineDosDevice DefineDosDeviceW
#define WszQueryDosDevice QueryDosDeviceW
#define WszCreateFile CreateFileW
#define WszSetFileAttributes SetFileAttributesW
#define WszGetFileAttributes GetFileAttributesW
#define WszGetCompressedFileSize GetCompressedFileSizeW
#define WszDeleteFile DeleteFileW
#define WszFindFirstFileEx FindFirstFileExW
#define WszFindFirstFile FindFirstFileW
#define WszFindNextFile FindNextFileW
#define WszSearchPath SearchPathW
#define WszCopyFile CopyFileW
#define WszCopyFileEx CopyFileExW
#define WszMoveFile MoveFileW
#define WszMoveFileEx MoveFileExW
#define WszMoveFileWithProgress MoveFileWithProgressW
#define WszCreateSymbolicLink CreateSymbolicLinkW
#define WszQuerySymbolicLink QuerySymbolicLinkW
#define WszCreateHardLink CreateHardLinkW
#define WszCreateNamedPipe CreateNamedPipeW
#define WszGetNamedPipeHandleState GetNamedPipeHandleStateW
#define WszCallNamedPipe CallNamedPipeW
#define WszWaitNamedPipe WaitNamedPipeW
#define WszSetVolumeLabel SetVolumeLabelW
#define WszGetVolumeInformation GetVolumeInformationW
#define WszClearEventLog ClearEventLogW
#define WszBackupEventLog BackupEventLogW
#define WszOpenEventLog OpenEventLogW
#define WszRegisterEventSource RegisterEventSourceW
#define WszOpenBackupEventLog OpenBackupEventLogW
#define WszReadEventLog ReadEventLogW
#define WszReportEvent ReportEventW
#define WszAccessCheckAndAuditAlarm AccessCheckAndAuditAlarmW
#define WszAccessCheckByTypeAndAuditAlarm AccessCheckByTypeAndAuditAlarmW
#define WszAccessCheckByTypeResultListAndAuditAlarm AccessCheckByTypeResultListAndAuditAlarmW
#define WszObjectOpenAuditAlarm ObjectOpenAuditAlarmW
#define WszObjectPrivilegeAuditAlarm ObjectPrivilegeAuditAlarmW
#define WszObjectCloseAuditAlarm ObjectCloseAuditAlarmW
#define WszObjectDeleteAuditAlarm ObjectDeleteAuditAlarmW
#define WszPrivilegedServiceAuditAlarm PrivilegedServiceAuditAlarmW
#define WszSetFileSecurity SetFileSecurityW
#define WszGetFileSecurity GetFileSecurityW
#define WszFindFirstChangeNotification FindFirstChangeNotificationW
#define WszIsBadStringPtr IsBadStringPtrW
#define WszLookupAccountSid LookupAccountSidW
#define WszLookupAccountName LookupAccountNameW
#define WszLookupPrivilegeValue LookupPrivilegeValueW
#define WszLookupPrivilegeName LookupPrivilegeNameW
#define WszLookupPrivilegeDisplayName LookupPrivilegeDisplayNameW
#define WszBuildCommDCB BuildCommDCBW
#define WszBuildCommDCBAndTimeouts BuildCommDCBAndTimeoutsW
#define WszCommConfigDialog CommConfigDialogW
#define WszGetDefaultCommConfig GetDefaultCommConfigW
#define WszSetDefaultCommConfig SetDefaultCommConfigW
#define WszGetComputerName GetComputerNameW
#define WszSetComputerName SetComputerNameW
#define WszGetUserName GetUserNameW
#define WszLogonUser LogonUserW
#define WszCreateProcessAsUser CreateProcessAsUserW
#define WszGetCurrentHwProfile GetCurrentHwProfileW
#define WszGetVersionEx GetVersionExW
#define WszCreateJobObject CreateJobObjectW
#define WszOpenJobObject OpenJobObjectW

// @TODO - This wont work - Brian, Bill thanks.
#define lstrcpynW  (LPWSTR)memcpy

// winuser.h
#define WszMAKEINTRESOURCE MAKEINTRESOURCEW
#define Wszwvsprintf wvsprintfW
#define Wszwsprintf wsprintfW
#define WszLoadKeyboardLayout LoadKeyboardLayoutW
#define WszGetKeyboardLayoutName GetKeyboardLayoutNameW
#define WszCreateDesktop CreateDesktopW
#define WszOpenDesktop OpenDesktopW
#define WszEnumDesktops EnumDesktopsW
#define WszCreateWindowStation CreateWindowStationW
#define WszOpenWindowStation OpenWindowStationW
#define WszEnumWindowStations EnumWindowStationsW
#define WszGetUserObjectInformation GetUserObjectInformationW
#define WszSetUserObjectInformation SetUserObjectInformationW
#define WszRegisterWindowMessage RegisterWindowMessageW
#define WszSIZEZOOMSHOW SIZEZOOMSHOWW
#define WszWS_TILEDWINDOW WS_TILEDWINDOWW
#define WszGetMessage GetMessageW
#define WszDispatchMessage DispatchMessageW
#define WszPostMessage PostMessageW
#define WszPeekMessage PeekMessageW
#define WszSendMessage SendMessageW
#define WszSendMessageTimeout SendMessageTimeoutW
#define WszSendNotifyMessage SendNotifyMessageW
#define WszSendMessageCallback SendMessageCallbackW
#define WszBroadcastSystemMessage BroadcastSystemMessageW
#define WszRegisterDeviceNotification RegisterDeviceNotificationW
#define WszPostMessage PostMessageW
#define WszPostThreadMessage PostThreadMessageW
#define WszPostAppMessage PostAppMessageW
#define WszDefWindowProc DefWindowProcW
#define WszCallWindowProc CallWindowProcW
#define WszRegisterClass RegisterClassW
#define WszUnregisterClass UnregisterClassW
#define WszGetClassInfo GetClassInfoW
#define WszRegisterClassEx RegisterClassExW
#define WszGetClassInfoEx GetClassInfoExW
#define WszCreateWindowEx CreateWindowExW
#define WszCreateWindow CreateWindowW
#define WszCreateDialogParam CreateDialogParamW
#define WszCreateDialogIndirectParam CreateDialogIndirectParamW
#define WszCreateDialog CreateDialogW
#define WszCreateDialogIndirect CreateDialogIndirectW
#define WszDialogBoxParam DialogBoxParamW
#define WszDialogBoxIndirectParam DialogBoxIndirectParamW
#define WszDialogBox DialogBoxW
#define WszDialogBoxIndirect DialogBoxIndirectW
#define WszSetDlgItemText SetDlgItemTextW
#define WszGetDlgItemText GetDlgItemTextW
#define WszSendDlgItemMessage SendDlgItemMessageW
#define WszDefDlgProc DefDlgProcW
#define WszCallMsgFilter CallMsgFilterW
#define WszRegisterClipboardFormat RegisterClipboardFormatW
#define WszGetClipboardFormatName GetClipboardFormatNameW
#define WszCharToOem CharToOemW
#define WszOemToChar OemToCharW
#define WszCharToOemBuff CharToOemBuffW
#define WszOemToCharBuff OemToCharBuffW
#define WszCharUpper CharUpperW
#define WszCharUpperBuff CharUpperBuffW
#define WszCharLower CharLowerW
#define WszCharLowerBuff CharLowerBuffW
#define WszCharNext CharNextW
//@todo: Does 95 support this? #define WszCharPrev CharPrevW
#define WszIsCharAlpha IsCharAlphaW
#define WszIsCharAlphaNumeric IsCharAlphaNumericW
#define WszIsCharUpper IsCharUpperW
#define WszIsCharLower IsCharLowerW
#define WszGetKeyNameText GetKeyNameTextW
#define WszVkKeyScan VkKeyScanW
#define WszVkKeyScanEx VkKeyScanExW
#define WszMapVirtualKey MapVirtualKeyW
#define WszMapVirtualKeyEx MapVirtualKeyExW
#define WszLoadAccelerators LoadAcceleratorsW
#define WszCreateAcceleratorTable CreateAcceleratorTableW
#define WszCopyAcceleratorTable CopyAcceleratorTableW
#define WszTranslateAccelerator TranslateAcceleratorW
#define WszLoadMenu LoadMenuW
#define WszLoadMenuIndirect LoadMenuIndirectW
#define WszChangeMenu ChangeMenuW
#define WszGetMenuString GetMenuStringW
#define WszInsertMenu InsertMenuW
#define WszAppendMenu AppendMenuW
#define WszModifyMenu ModifyMenuW
#define WszInsertMenuItem InsertMenuItemW
#define WszGetMenuItemInfo GetMenuItemInfoW
#define WszSetMenuItemInfo SetMenuItemInfoW
#define WszDrawText DrawTextW
#define WszDrawTextEx DrawTextExW
#define WszGrayString GrayStringW
#define WszDrawState DrawStateW
#define WszTabbedTextOut TabbedTextOutW
#define WszGetTabbedTextExtent GetTabbedTextExtentW
#define WszSetProp SetPropW
#define WszGetProp GetPropW
#define WszRemoveProp RemovePropW
#define WszEnumPropsEx EnumPropsExW
#define WszEnumProps EnumPropsW
#define WszSetWindowText SetWindowTextW
#define WszGetWindowText GetWindowTextW
#define WszGetWindowTextLength GetWindowTextLengthW
#define WszMessageBox MessageBoxW
#define WszMessageBoxEx MessageBoxExW
#define WszMessageBoxIndirect MessageBoxIndirectW
#define WszGetWindowLong GetWindowLongW
#define WszSetWindowLong SetWindowLongW
#define WszGetClassLong GetClassLongW
#define WszSetClassLong SetClassLongW
#define WszFindWindow FindWindowW
#define WszFindWindowEx FindWindowExW
#define WszGetClassName GetClassNameW
#define WszSetWindowsHook SetWindowsHookW
#define WszSetWindowsHook SetWindowsHookW
#define WszSetWindowsHookEx SetWindowsHookExW
#define WszLoadBitmap LoadBitmapW
#define WszLoadCursor LoadCursorW
#define WszLoadCursorFromFile LoadCursorFromFileW
#define WszLoadIcon LoadIconW
#define WszLoadImage LoadImageW
#define WszLoadString LoadStringW
#define WszIsDialogMessage IsDialogMessageW
#define WszDlgDirList DlgDirListW
#define WszDlgDirSelectEx DlgDirSelectExW
#define WszDlgDirListComboBox DlgDirListComboBoxW
#define WszDlgDirSelectComboBoxEx DlgDirSelectComboBoxExW
#define WszDefFrameProc DefFrameProcW
#define WszDefMDIChildProc DefMDIChildProcW
#define WszCreateMDIWindow CreateMDIWindowW
#define WszWinHelp WinHelpW
#define WszChangeDisplaySettings ChangeDisplaySettingsW
#define WszChangeDisplaySettingsEx ChangeDisplaySettingsExW
#define WszEnumDisplaySettings EnumDisplaySettingsW
#define WszEnumDisplayDevices EnumDisplayDevicesW
#define WszSystemParametersInfo SystemParametersInfoW
#define WszGetMonitorInfo GetMonitorInfoW
#define WszGetWindowModuleFileName GetWindowModuleFileNameW
#define WszRealGetWindowClass RealGetWindowClassW
#define WszGetAltTabInfo GetAltTabInfoW
#define WszRegOpenKeyEx RegOpenKeyExW
#define WszRegOpenKey(hKey, wszSubKey, phkRes) RegOpenKeyExW(hKey, wszSubKey, 0, KEY_ALL_ACCESS, phkRes)
#define WszRegQueryValueEx RegQueryValueExW
#define WszRegQueryStringValueEx RegQueryValueExW
#define WszRegDeleteKey RegDeleteKeyW
#define WszRegCreateKeyEx RegCreateKeyExW
#define WszRegSetValueEx RegSetValueExW
#define WszRegDeleteValue RegDeleteValueW
#define WszRegLoadKey RegLoadKeyW
#define WszRegUnLoadKey RegUnLoadKeyW
#define WszRegRestoreKey RegRestoreKeyW
#define WszRegReplaceKey RegReplaceKeyW
#define WszRegQueryInfoKey RegQueryInfoKeyW
#define WszRegEnumValue RegEnumValueW
#define WszRegEnumKeyEx RegEnumKeyExW

HRESULT WszConvertToUnicode(LPCSTR pszIn, LONG cbIn, LPWSTR* lpwszOut,
    ULONG* lpcchOut, BOOL fAlloc);

HRESULT WszConvertToAnsi(LPCWSTR pwszIn, LPSTR* lpszOut,
    ULONG cbOutMax, ULONG* lpcbOut, BOOL fAlloc);

// Win32 Fusion API's
#define WszReleaseActCtx ReleaseActCtx
#define WszGetCurrentActCtx GetCurrentActCtx
#define WszQueryActCtxW QueryActCtxW

#else // _X86_

#ifndef IN_WINFIX_CPP

    /*** Redefine the 'standard' names so people don't accidentially use them ***/
// crypt.h
#define CryptAcquireContextW Use_WszCryptAcquireContext

// winbase.h
#define GetBinaryTypeW Use_WszGetBinaryType
#define GetShortPathNameW Use_WszGetShortPathName
#define GetLongPathNameW Use_WszGetLongPathName
#define GetEnvironmentStringsW Use_WszGetEnvironmentStrings
#define FreeEnvironmentStringsW Use_WszFreeEnvironmentStrings
#define FormatMessageW Use_WszFormatMessage
#define CreateMailslotW Use_WszCreateMailslot
#define EncryptFileW Use_WszEncryptFile
#define DecryptFileW Use_WszDecryptFile
#define OpenRawW Use_WszOpenRaw
#define QueryRecoveryAgentsW Use_WszQueryRecoveryAgents
#define CreateMutexW Use_WszCreateMutex
#define OpenMutexW Use_WszOpenMutex
#define CreateEventW Use_WszCreateEvent
#define OpenEventW Use_WszOpenEvent
#define CreateWaitableTimerW Use_WszCreateWaitableTimer
#define OpenWaitableTimerW Use_WszOpenWaitableTimer
#define CreateFileMappingW Use_WszCreateFileMapping
#define OpenFileMappingW Use_WszOpenFileMapping
#define GetLogicalDriveStringsW Use_WszGetLogicalDriveStrings
#define LoadLibraryW Use_WszLoadLibrary
#define LoadLibraryExW Use_WszLoadLibraryEx
#define GetModuleFileNameW Use_WszGetModuleFileName
#define GetModuleHandleW Use_WszGetModuleHandle
#define CreateProcessW Use_WszCreateProcess
#define FatalAppExitW Use_WszFatalAppExit
#define GetStartupInfoW Use_WszGetStartupInfo
#define GetCommandLineW Use_WszGetCommandLine
#define GetEnvironmentVariableW Use_WszGetEnvironmentVariable
#define SetEnvironmentVariableW Use_WszSetEnvironmentVariable
#define ExpandEnvironmentStringsW Use_WszExpandEnvironmentStrings
#define OutputDebugStringW Use_WszOutputDebugString
#define FindResourceW Use_WszFindResource
#define FindResourceExW Use_WszFindResourceEx
#define EnumResourceTypesW Use_WszEnumResourceTypes
#define EnumResourceNamesW Use_WszEnumResourceNames
#define EnumResourceLanguagesW Use_WszEnumResourceLanguages
#define BeginUpdateResourceW Use_WszBeginUpdateResource
#define UpdateResourceW Use_WszUpdateResource
#define EndUpdateResourceW Use_WszEndUpdateResource
#define GlobalAddAtomW Use_WszGlobalAddAtom
#define GlobalFindAtomW Use_WszGlobalFindAtom
#define GlobalGetAtomNameW Use_WszGlobalGetAtomName
#define AddAtomW Use_WszAddAtom
#define FindAtomW Use_WszFindAtom
#define GetAtomNameW Use_WszGetAtomName
#define GetProfileIntW Use_WszGetProfileInt
#define GetProfileStringW Use_WszGetProfileString
#define WriteProfileStringW Use_WszWriteProfileString
#define GetProfileSectionW Use_WszGetProfileSection
#define WriteProfileSectionW Use_WszWriteProfileSection
#define GetPrivateProfileIntW Use_WszGetPrivateProfileInt
#define GetPrivateProfileStringW Use_WszGetPrivateProfileString
#define WritePrivateProfileStringW Use_WszWritePrivateProfileString
#define GetPrivateProfileSectionW Use_WszGetPrivateProfileSection
#define WritePrivateProfileSectionW Use_WszWritePrivateProfileSection
#define GetPrivateProfileSectionNamesW Use_WszGetPrivateProfileSectionNames
#define GetPrivateProfileStructW Use_WszGetPrivateProfileStruct
#define WritePrivateProfileStructW Use_WszWritePrivateProfileStruct
#define GetDriveTypeW Use_WszGetDriveType
#define GetSystemDirectoryW Use_WszGetSystemDirectory
#define GetTempPathW Use_WszGetTempPath
#define GetTempFileNameW Use_WszGetTempFileName
#define GetWindowsDirectoryW Use_WszGetWindowsDirectory
#define SetCurrentDirectoryW Use_WszSetCurrentDirectory
#define GetCurrentDirectoryW Use_WszGetCurrentDirectory
#define GetDiskFreeSpaceW Use_WszGetDiskFreeSpace
#define GetDiskFreeSpaceExW Use_WszGetDiskFreeSpaceEx
#define CreateDirectoryW Use_WszCreateDirectory
#define CreateDirectoryExW Use_WszCreateDirectoryEx
#define RemoveDirectoryW Use_WszRemoveDirectory
#define GetFullPathNameW Use_WszGetFullPathName
#define DefineDosDeviceW Use_WszDefineDosDevice
#define QueryDosDeviceW Use_WszQueryDosDevice
#define CreateFileW Use_WszCreateFile
#define SetFileAttributesW Use_WszSetFileAttributes
#define GetFileAttributesW Use_WszGetFileAttributes
#define GetCompressedFileSizeW Use_WszGetCompressedFileSize
#define DeleteFileW Use_WszDeleteFile
#define FindFirstFileExW Use_WszFindFirstFileEx
#define FindFirstFileW Use_WszFindFirstFile
#define FindNextFileW Use_WszFindNextFile
#define SearchPathW Use_WszSearchPath
#define CopyFileW Use_WszCopyFile
#define CopyFileExW Use_WszCopyFileEx
#define MoveFileW Use_WszMoveFile
#define MoveFileExW Use_WszMoveFileEx
#define MoveFileWithProgressW Use_WszMoveFileWithProgress
#define CreateSymbolicLinkW Use_WszCreateSymbolicLink
#define QuerySymbolicLinkW Use_WszQuerySymbolicLink
#define CreateHardLinkW Use_WszCreateHardLink
#define CreateNamedPipeW Use_WszCreateNamedPipe
#define GetNamedPipeHandleStateW Use_WszGetNamedPipeHandleState
#define CallNamedPipeW Use_WszCallNamedPipe
#define WaitNamedPipeW Use_WszWaitNamedPipe
#define SetVolumeLabelW Use_WszSetVolumeLabel
#define GetVolumeInformationW Use_WszGetVolumeInformation
#define ClearEventLogW Use_WszClearEventLog
#define BackupEventLogW Use_WszBackupEventLog
#define OpenEventLogW Use_WszOpenEventLog
#define RegisterEventSourceW Use_WszRegisterEventSource
#define OpenBackupEventLogW Use_WszOpenBackupEventLog
#define ReadEventLogW Use_WszReadEventLog
#define ReportEventW Use_WszReportEvent
#define AccessCheckAndAuditAlarmW Use_WszAccessCheckAndAuditAlarm
#define AccessCheckByTypeAndAuditAlarmW Use_WszAccessCheckByTypeAndAuditAlarm
#define AccessCheckByTypeResultListAndAuditAlarmW Use_WszAccessCheckByTypeResultListAndAuditAlarm
#define ObjectOpenAuditAlarmW Use_WszObjectOpenAuditAlarm
#define ObjectPrivilegeAuditAlarmW Use_WszObjectPrivilegeAuditAlarm
#define ObjectCloseAuditAlarmW Use_WszObjectCloseAuditAlarm
#define ObjectDeleteAuditAlarmW Use_WszObjectDeleteAuditAlarm
#define PrivilegedServiceAuditAlarmW Use_WszPrivilegedServiceAuditAlarm
#define SetFileSecurityW Use_WszSetFileSecurity
#define GetFileSecurityW Use_WszGetFileSecurity
#define FindFirstChangeNotificationW Use_WszFindFirstChangeNotification
#define IsBadStringPtrW Use_WszIsBadStringPtr
#define LookupAccountSidW Use_WszLookupAccountSid
#define LookupAccountNameW Use_WszLookupAccountName
#define BuildCommDCBW Use_WszBuildCommDCB
#define BuildCommDCBAndTimeoutsW Use_WszBuildCommDCBAndTimeouts
#define CommConfigDialogW Use_WszCommConfigDialog
#define GetDefaultCommConfigW Use_WszGetDefaultCommConfig
#define SetDefaultCommConfigW Use_WszSetDefaultCommConfig
#define SetComputerNameW Use_WszSetComputerName
#define GetUserNameW Use_WszGetUserName
#define LogonUserW Use_WszLogonUser
#define CreateProcessAsUserW Use_WszCreateProcessAsUser
#define GetCurrentHwProfileW Use_WszGetCurrentHwProfile
#define GetVersionExW Use_WszGetVersionEx
#define CreateJobObjectW Use_WszCreateJobObject
#define OpenJobObjectW Use_WszOpenJobObject

// winuser.h
#define LoadKeyboardLayoutW Use_WszLoadKeyboardLayout
#define GetKeyboardLayoutNameW Use_WszGetKeyboardLayoutName
#define CreateDesktopW Use_WszCreateDesktop
#define OpenDesktopW Use_WszOpenDesktop
#define EnumDesktopsW Use_WszEnumDesktops
#define CreateWindowStationW Use_WszCreateWindowStation
#define OpenWindowStationW Use_WszOpenWindowStation
#define EnumWindowStationsW Use_WszEnumWindowStations
#define GetUserObjectInformationW Use_WszGetUserObjectInformation
#define SetUserObjectInformationW Use_WszSetUserObjectInformation
#define RegisterWindowMessageW Use_WszRegisterWindowMessage
#define GetMessageW Use_WszGetMessage
#define DispatchMessageW Use_WszDispatchMessage
#define PostMessageW Use_WszPostMessage
#define PeekMessageW Use_WszPeekMessage
#define SendMessageW Use_WszSendMessage
#define SendMessageTimeoutW Use_WszSendMessageTimeout
#define SendNotifyMessageW Use_WszSendNotifyMessage
#define SendMessageCallbackW Use_WszSendMessageCallback
#define BroadcastSystemMessageW Use_WszBroadcastSystemMessage
#define RegisterDeviceNotificationW Use_WszRegisterDeviceNotification
#define PostThreadMessageW Use_WszPostThreadMessage
#define DefWindowProcW Use_WszDefWindowProc
#define CallWindowProcW Use_WszCallWindowProc
#define RegisterClassW Use_WszRegisterClass
#define UnregisterClassW Use_WszUnregisterClass
#define GetClassInfoW Use_WszGetClassInfo
#define RegisterClassExW Use_WszRegisterClassEx
#define GetClassInfoExW Use_WszGetClassInfoEx
#define CreateWindowExW Use_WszCreateWindowEx
#undef CreateWindowW 
#define CreateDialogParamW Use_WszCreateDialogParam
#define CreateDialogIndirectParamW Use_WszCreateDialogIndirectParam
#undef CreateDialogW 
#undef CreateDialogIndirectW 
#define DialogBoxParamW Use_WszDialogBoxParam
#define DialogBoxIndirectParamW Use_WszDialogBoxIndirectParam
#undef DialogBoxW 
#undef DialogBoxIndirectW
#define SetDlgItemTextW Use_WszSetDlgItemText
#define GetDlgItemTextW Use_WszGetDlgItemText
#define SendDlgItemMessageW Use_WszSendDlgItemMessage
#define DefDlgProcW Use_WszDefDlgProc
#define CallMsgFilterW Use_WszCallMsgFilter
#define RegisterClipboardFormatW Use_WszRegisterClipboardFormat
#define GetClipboardFormatNameW Use_WszGetClipboardFormatName
#define CharToOemW Use_WszCharToOem
#define OemToCharW Use_WszOemToChar
#define CharToOemBuffW Use_WszCharToOemBuff
#define OemToCharBuffW Use_WszOemToCharBuff
#define CharUpperW Use_WszCharUpper
#define CharUpperBuffW Use_WszCharUpperBuff
#define CharLowerW Use_WszCharLower
#define CharLowerBuffW Use_WszCharLowerBuff
#define CharNextW Use_WszCharNext

#define IsCharAlphaW Use_WszIsCharAlpha
#define IsCharAlphaNumericW Use_WszIsCharAlphaNumeric
#define IsCharUpperW Use_WszIsCharUpper
#define IsCharLowerW Use_WszIsCharLower
#define GetKeyNameTextW Use_WszGetKeyNameText
#define VkKeyScanW Use_WszVkKeyScan
#define VkKeyScanExW Use_WszVkKeyScanEx
#define MapVirtualKeyW Use_WszMapVirtualKey
#define MapVirtualKeyExW Use_WszMapVirtualKeyEx
#define LoadAcceleratorsW Use_WszLoadAccelerators
#define CreateAcceleratorTableW Use_WszCreateAcceleratorTable
#define CopyAcceleratorTableW Use_WszCopyAcceleratorTable
#define TranslateAcceleratorW Use_WszTranslateAccelerator
#define LoadMenuW Use_WszLoadMenu
#define LoadMenuIndirectW Use_WszLoadMenuIndirect
#define ChangeMenuW Use_WszChangeMenu
#define GetMenuStringW Use_WszGetMenuString
#define InsertMenuW Use_WszInsertMenu
#define AppendMenuW Use_WszAppendMenu
#define ModifyMenuW Use_WszModifyMenu
#define InsertMenuItemW Use_WszInsertMenuItem
#define GetMenuItemInfoW Use_WszGetMenuItemInfo
#define SetMenuItemInfoW Use_WszSetMenuItemInfo
#define DrawTextW Use_WszDrawText
#define DrawTextExW Use_WszDrawTextEx
#define GrayStringW Use_WszGrayString
#define DrawStateW Use_WszDrawState
#define TabbedTextOutW Use_WszTabbedTextOut
#define GetTabbedTextExtentW Use_WszGetTabbedTextExtent
#define SetPropW Use_WszSetProp
#define GetPropW Use_WszGetProp
#define RemovePropW Use_WszRemoveProp
#define EnumPropsExW Use_WszEnumPropsEx
#define EnumPropsW Use_WszEnumProps
#define SetWindowTextW Use_WszSetWindowText
#define GetWindowTextW Use_WszGetWindowText
#define GetWindowTextLengthW Use_WszGetWindowTextLength
#define MessageBoxW Use_WszMessageBox
#define MessageBoxExW Use_WszMessageBoxEx
#define MessageBoxIndirectW Use_WszMessageBoxIndirect
#define GetWindowLongW Use_WszGetWindowLong
#define SetWindowLongW Use_WszSetWindowLong
#define GetClassLongW Use_WszGetClassLong
#define SetClassLongW Use_WszSetClassLong
#define FindWindowW Use_WszFindWindow
#define FindWindowExW Use_WszFindWindowEx
#define GetClassNameW Use_WszGetClassName
#define SetWindowsHookW Use_WszSetWindowsHook
#define SetWindowsHookW Use_WszSetWindowsHook
#define SetWindowsHookExW Use_WszSetWindowsHookEx
#define LoadBitmapW Use_WszLoadBitmap
#define LoadCursorW Use_WszLoadCursor
#define LoadCursorFromFileW Use_WszLoadCursorFromFile
#define LoadIconW Use_WszLoadIcon
#define LoadImageW Use_WszLoadImage
#define LoadStringW Use_WszLoadString
#define IsDialogMessageW Use_WszIsDialogMessage
#define DlgDirListW Use_WszDlgDirList
#define DlgDirSelectExW Use_WszDlgDirSelectEx
#define DlgDirListComboBoxW Use_WszDlgDirListComboBox
#define DlgDirSelectComboBoxExW Use_WszDlgDirSelectComboBoxEx
#define DefFrameProcW Use_WszDefFrameProc
#define DefMDIChildProcW Use_WszDefMDIChildProc
#define CreateMDIWindowW Use_WszCreateMDIWindow
#define WinHelpW Use_WszWinHelp
#define ChangeDisplaySettingsW Use_WszChangeDisplaySettings
#define ChangeDisplaySettingsExW Use_WszChangeDisplaySettingsEx
#define EnumDisplaySettingsW Use_WszEnumDisplaySettings
#define EnumDisplayDevicesW Use_WszEnumDisplayDevices
#define SystemParametersInfoW Use_WszSystemParametersInfo
#define GetMonitorInfoW Use_WszGetMonitorInfo
#define GetWindowModuleFileNameW Use_WszGetWindowModuleFileName
#define RealGetWindowClassW Use_WszRealGetWindowClass
#define GetAltTabInfoW Use_WszGetAltTabInfo
#define RegOpenKeyExW Use_WszRegOpenKeyEx
#define RegQueryValueExW Use_WszRegQueryValueEx
#define RegQueryValueExW Use_WszRegQueryValueEx
#define RegDeleteKeyW Use_WszRegDeleteKey
#define RegCreateKeyExW Use_WszRegCreateKeyEx
#define RegSetValueExW Use_WszRegSetValueEx
#define RegDeleteValueW Use_WszRegDeleteValue
#define RegRegLoadKeyW Use_WszRegRegLoadKey
#define RegUnLoadKeyW Use_WszRegUnLoadKey
#define RegRestoreKeyW Use_WszRegRestoreKey
#define RegRegReplaceKeyW Use_WszRegRegReplaceKey
#define RegQueryInfoKeyW Use_WszRegQueryInfoKey
#define RegEnumValueW Use_WszRegEnumValue
#define RegEnumKeyExW Use_WszRegEnumKeyEx

// Win32 Fusion API's
#define ReleaseActCtx Use_WszReleaseActCtx
#define GetCurrentActCtx Use_WszGetCurrentActCtx
#define QueryActCtxW Use_WszQueryActCtxW

#endif // IN_WINFIX_CPP
#endif /// _X86_


#ifndef PLATFORM_WIN32
EXTERN_C int CeGenerateGUID(GUID *pGUID);
#define CoCreateGuid(x)  CeGenerateGUID(x)

#undef GetProcAddress
#define GetProcAddress(handle, szProc) WszGetProcAddress(handle, szProc)

// Mem functions

#define EqualMemory(Destination,Source,Length) (!memcmp((Destination),(Source),(Length)))
#undef MoveMemory
#define MoveMemory(Destination,Source,Length) memmove((Destination),(Source),(Length))
#undef CopyMemory
#define CopyMemory(Destination,Source,Length) memcpy((Destination),(Source),(Length))
#undef FillMemory
#define FillMemory(Destination,Length,Fill) memset((Destination),(Fill),(Length))
#undef ZeroMemory
#define ZeroMemory(Destination,Length) memset((Destination),0,(Length))

// map stdio functions as approp
#ifndef STD_INPUT_HANDLE
#define STD_INPUT_HANDLE    (DWORD)-10
#endif
#ifndef STD_OUTPUT_HANDLE
#define STD_OUTPUT_HANDLE   (DWORD)-11
#endif
#ifndef STD_ERROR_HANDLE
#define STD_ERROR_HANDLE    (DWORD)-12
#endif
#define GetStdHandle(x) \
    ((HANDLE*)_fileno( \
        ((x==STD_INPUT_HANDLE) ? stdin : \
        ((x==STD_OUTPUT_HANDLE) ? stdout : \
        ((x==STD_ERROR_HANDLE) ? stderr : NULL))) ))

#endif // !PLATFORM_WIN32

#ifndef _T
#define _T(str) L ## str
#endif


// on win98 and higher
#define Wszlstrlen      lstrlenW
#define Wszlstrcpy      lstrcpyW
#define Wszlstrcat      lstrcatW

// the following are not on win9x. We will remove them for now to prevent anyone
// accidentally using them. They should be added in V2. jenh
// #define Wszlstrcmp      lstrcmpW 
// #define Wszlstrcmpi     lstrcmpiW
// #define Wszlstrcpyn     lstrcpynW



//*****************************************************************************
// Prototypes for API's.
//*****************************************************************************

int UseUnicodeAPI();

BOOL OnUnicodeSystem();

extern DWORD DBCS_MAXWID;
#ifdef __cplusplus
inline DWORD GetMaxDBCSCharByteSize()
{ 
    _ASSERTE(DBCS_MAXWID != 0);
    return (DBCS_MAXWID); 
}
#else
#define GetMaxDBCSCharByteSize() (DBCS_MAXWID)
#endif

BOOL RunningInteractive();

int WszMultiByteToWideChar(
    UINT     CodePage,
    DWORD    dwFlags,
    LPCSTR   lpMultiByteStr,
    int      cchMultiByte,
    LPWSTR   lpWideCharStr,
    int      cchWideChar);

int WszWideCharToMultiByte(
    UINT     CodePage,
    DWORD    dwFlags,
    LPCWSTR  lpWideCharStr,
    int      cchWideChar,
    LPSTR    lpMultiByteStr,
    int      cchMultiByte,
    LPCSTR   lpDefaultChar,
    LPBOOL   lpUsedDefaultChar);


DWORD WszRegDeleteKeyAndSubKeys(                // Return code.
    HKEY        hStartKey,              // The key to start with.
    LPCWSTR     wzKeyName);             // Subkey to delete.

int WszMessageBoxInternal(
    HWND hWnd ,
    LPCWSTR lpText,
    LPCWSTR lpCaption,
    UINT uType);

int Wszwsprintf(
  LPWSTR lpOut, 
  LPCWSTR lpFmt,
  ...           
);

#ifdef PLATFORM_WIN32
#ifdef _X86_

HINSTANCE WszLoadLibraryEx(LPCWSTR lpLibFileName, HANDLE hFile,
    DWORD dwFlags);

#ifndef WszLoadLibrary
#define WszLoadLibrary(lpFileName) WszLoadLibraryEx(lpFileName, NULL, 0)
#endif

int WszLoadString(HINSTANCE hInstance, UINT uID, LPWSTR lpBuffer,
    int nBufferMax);

DWORD WszFormatMessage(DWORD dwFlags, LPCVOID lpSource, 
    DWORD dwMessageId, DWORD dwLanguageId, LPWSTR lpBuffer, DWORD nSize,
    va_list *Arguments);

DWORD WszSearchPath(LPWSTR pwzPath, LPWSTR pwzFileName, LPWSTR pwzExtension, 
    DWORD nBufferLength, LPWSTR pwzBuffer, LPWSTR *pwzFilePart);

DWORD WszGetModuleFileName(HMODULE hModule, LPWSTR lpwszFilename, DWORD nSize);

HRESULT WszConvertToUnicode(LPCSTR pszIn, LONG cbIn, LPWSTR* lpwszOut,
    ULONG* lpcchOut, BOOL fAlloc);

HRESULT WszConvertToAnsi(LPCWSTR pwszIn, LPSTR* lpszOut,
    ULONG cbOutMax, ULONG* lpcbOut, BOOL fAlloc);

LONG WszRegOpenKeyEx(HKEY hKey, LPCWSTR wszSub, 
    DWORD dwRes, REGSAM sam, PHKEY phkRes);

#ifndef WszRegOpenKey
#define WszRegOpenKey(hKey, wszSubKey, phkRes) WszRegOpenKeyEx(hKey, wszSubKey, 0, KEY_ALL_ACCESS, phkRes)
#endif

LONG WszRegEnumKeyEx(HKEY hKey, DWORD dwIndex, LPWSTR lpName, LPDWORD lpcbName,
    LPDWORD lpReserved, LPWSTR lpClass, LPDWORD lpcbClass, PFILETIME lpftLastWriteTime);

LONG WszRegDeleteKey(HKEY hKey, LPCWSTR lpSubKey);

LONG WszRegSetValueEx(HKEY hKey, LPCWSTR lpValueName, DWORD dwReserved,
    DWORD dwType, CONST BYTE* lpData, DWORD cbData);

LONG WszRegCreateKeyEx(HKEY hKey, LPCWSTR lpSubKey, DWORD dwReserved,
    LPWSTR lpClass, DWORD dwOptions, REGSAM samDesired, 
    LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition);

LONG WszRegQueryValue(HKEY hKey, LPCWSTR lpSubKey,
    LPWSTR lpValue, PLONG lpcbValue);

LONG WszRegQueryValueEx(HKEY hKey, LPCWSTR lpValueName,
    LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData,
    LPDWORD lpcbData);

#ifdef _DEBUG
LONG WszRegQueryValueExTrue(HKEY hKey, LPCWSTR lpValueName,
    LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData,
    LPDWORD lpcbData);
#else
#define WszRegQueryValueExTrue WszRegQueryValueEx
#endif


LONG WszRegQueryStringValueEx(HKEY hKey, LPCWSTR lpValueName,
                              LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData,
                              LPDWORD lpcbData);

LONG WszRegDeleteValue(
    HKEY    hKey,
    LPCWSTR lpValueName);

LONG WszRegLoadKey(
    HKEY     hKey,
    LPCWSTR  lpSubKey,
    LPCWSTR  lpFile);

LONG WszRegUnLoadKey(
    HKEY    hKey,
    LPCWSTR lpSubKey);

LONG WszRegRestoreKey(
    HKEY    hKey,
    LPCWSTR lpFile,
    DWORD   dwFlags);

LONG WszRegReplaceKey(
    HKEY     hKey,
    LPCWSTR  lpSubKey,
    LPCWSTR  lpNewFile,
    LPCWSTR  lpOldFile);

LONG WszRegQueryInfoKey(
    HKEY    hKey,
    LPWSTR  lpClass,
    LPDWORD lpcbClass,
    LPDWORD lpReserved,
    LPDWORD lpcSubKeys,
    LPDWORD lpcbMaxSubKeyLen,
    LPDWORD lpcbMaxClassLen,
    LPDWORD lpcValues,
    LPDWORD lpcbMaxValueNameLen,
    LPDWORD lpcbMaxValueLen,
    LPDWORD lpcbSecurityDescriptor,
    PFILETIME lpftLastWriteTime);

LONG WszRegEnumValue(
    HKEY    hKey,
    DWORD   dwIndex,
    LPWSTR  lpValueName,
    LPDWORD lpcbValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE  lpData,
    LPDWORD lpcbData);

UINT WszGetPrivateProfileInt(LPCWSTR wszAppName, LPCWSTR wszKeyName, 
    INT nDefault, LPCWSTR wszFileName);

DWORD WszGetPrivateProfileString(LPCWSTR lpwszSection, LPCWSTR lpwszEntry,
    LPCWSTR lpwszDefault, LPWSTR lpwszRetBuffer, DWORD cchRetBuffer,
    LPCWSTR lpszFile);

BOOL WszWritePrivateProfileString(LPCWSTR lpwszSection, LPCWSTR lpwszKey,
    LPCWSTR lpwszString, LPCWSTR lpwszFile);

HANDLE WszCreateFile(
    LPCWSTR pwszFileName,   // pointer to name of the file 
    DWORD dwDesiredAccess,  // access (read-write) mode 
    DWORD dwShareMode,  // share mode 
    LPSECURITY_ATTRIBUTES lpSecurityAttributes, // pointer to security descriptor 
    DWORD dwCreationDistribution,   // how to create 
    DWORD dwFlagsAndAttributes, // file attributes 
    HANDLE hTemplateFile );     // handle to file with attributes to copy  

BOOL WszCopyFile(
    LPCWSTR pwszExistingFileName,   // pointer to name of an existing file 
    LPCWSTR pwszNewFileName,    // pointer to filename to copy to 
    BOOL bFailIfExists );   // flag for operation if file exists 

BOOL WszMoveFile(
    LPCWSTR pwszExistingFileName,   // address of name of the existing file  
    LPCWSTR pwszNewFileName );    // address of new name for the file 

BOOL WszMoveFileEx(
    LPCWSTR pwszExistingFileName,   // address of name of the existing file  
    LPCWSTR pwszNewFileName,    // address of new name for the file 
    DWORD dwFlags );    // flag to determine how to move file 

BOOL WszSetFileSecurity(
    LPCWSTR lpwFileName,                         // file name
    SECURITY_INFORMATION SecurityInformation,    // contents
    PSECURITY_DESCRIPTOR pSecurityDescriptor );  // SD

UINT WszGetDriveType(
    LPCWSTR lpwRootPath );

BOOL WszGetVolumeInformation(
  LPCWSTR lpwRootPathName,
  LPWSTR lpwVolumeNameBuffer,
  DWORD nVolumeNameSize,
  LPDWORD lpVolumeSerialNumber,
  LPDWORD lpMaximumComponentLength,
  LPDWORD lpFileSystemFlags,
  LPWSTR lpwFileSystemNameBuffer,
  DWORD nFileSystemNameSize);

BOOL WszDeleteFile(
    LPCWSTR pwszFileName ); // address of name of the existing file  

BOOL WszGetVersionEx(
    LPOSVERSIONINFOW lpVersionInformation);

void WszOutputDebugString(
    LPCWSTR lpOutputString
    );

BOOL WszLookupAccountSid(
    LPCWSTR lpSystemName,
    PSID Sid,
    LPWSTR Name,
    LPDWORD cbName,
    LPWSTR DomainName,
    LPDWORD cbDomainName,
    PSID_NAME_USE peUse
    );

BOOL WszLookupAccountName(
    LPCWSTR lpSystemName,
    LPCWSTR lpAccountName,
    PSID Sid,
    LPDWORD cbSid,
    LPWSTR DomainName,
    LPDWORD cbDomainName,
    PSID_NAME_USE peUse
    );

void WszFatalAppExit(
    UINT uAction,
    LPCWSTR lpMessageText
    );

// This method is called in co-operative mode. If you change this, COMMutex::CreateMutexNative will have
// to be fixed. 
HANDLE WszCreateMutex(
    LPSECURITY_ATTRIBUTES lpMutexAttributes,
    BOOL bInitialOwner,
    LPCWSTR lpName
    );

HANDLE WszCreateEvent(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,
    BOOL bInitialState,
    LPCWSTR lpName
    );

HANDLE WszOpenEvent(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    );

HMODULE WszGetModuleHandle(
    LPCWSTR lpModuleName
    );

DWORD
WszGetFileAttributes(
    LPCWSTR lpFileName
    );

BOOL
WszSetFileAttributes(
    LPCWSTR lpFileName,
    DWORD dwFileAttributes
    );

DWORD
WszGetCurrentDirectory(
    DWORD nBufferLength,
    LPWSTR lpBuffer
    );


UINT
WszGetSystemDirectory(
    LPWSTR lpBuffer,
    UINT uSize
    );

UINT
WszGetWindowsDirectory(
    LPWSTR lpBuffer,
    UINT uSize
    );


DWORD
WszGetTempPath(
    DWORD nBufferLength,
    LPWSTR lpBuffer
    );

UINT
WszGetTempFileName(
    LPCWSTR lpPathName,
    LPCWSTR lpPrefixString,
    UINT uUnique,
    LPWSTR lpTempFileName
    );

LPWSTR
WszGetEnvironmentStrings();

BOOL
WszFreeEnvironmentStrings(
    LPWSTR block
    );

DWORD
WszGetEnvironmentVariable(
    LPCWSTR lpName,
    LPWSTR lpBuffer,
    DWORD nSize
    );

BOOL
WINAPI
WszSetEnvironmentVariable(
    LPCWSTR lpName,
    LPCWSTR lpValue
    );

int 
WszGetClassName(
    HWND hwnd,
    LPWSTR lpBuffer, 
    int nMaxCount
    );

DWORD
WszGetFullPathName(
    LPCWSTR lpFileName,
    DWORD nBufferLength,
    LPWSTR lpBuffer,
    LPWSTR *lpFilePart
    );

BOOL 
WszGetComputerName(
    LPWSTR lpBuffer,
    LPDWORD pSize
    );

HANDLE
WszCreateFileMapping(
    HANDLE hFile,
    LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
    DWORD flProtect,
    DWORD dwMaximumSizeHigh,
    DWORD dwMaximumSizeLow,
    LPCWSTR lpName
    );

HANDLE
WszOpenFileMapping(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    );

BOOL
WszCreateProcess(
    LPCWSTR lpApplicationName,
    LPWSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCWSTR lpCurrentDirectory,
    LPSTARTUPINFOW lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    );

LPTSTR
WszGetCommandLine(
    VOID
    );

HANDLE
WszCreateSemaphore(
    LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
    LONG lInitialCount,
    LONG lMaximumCount,
    LPCWSTR lpName
    );

BOOL
WszGetUserName(
    LPWSTR lpBuffer,
    LPDWORD pSize
    );

BOOL 
WszCreateDirectory( 
  LPCWSTR lpPathName, 
  LPSECURITY_ATTRIBUTES lpSecurityAttributes
);

BOOL 
WszRemoveDirectory(
  LPCWSTR lpPathName
);

HANDLE 
WszFindFirstFile(
  LPCWSTR lpFileName,               // pointer to name of file to search for
  LPWIN32_FIND_DATA lpFindFileData  // pointer to returned information
  );

BOOL
WszFindNextFile(
  HANDLE hFindHandle,               // handle returned from FindFirstFile
  LPWIN32_FIND_DATA lpFindFileData  // pointer to returned information
  );

BOOL
WszPeekMessage(
    LPMSG lpMsg,
    HWND hWnd ,
    UINT wMsgFilterMin,
    UINT wMsgFilterMax,
    UINT wRemoveMsg);

LONG
WszDispatchMessage(
    CONST MSG *lpMsg);

BOOL
WszPostMessage(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);

BOOL
WszCryptAcquireContext(
  HCRYPTPROV *phProv,
  LPCWSTR pszContainer,
  LPCWSTR pszProvider,
  DWORD dwProvType,
  DWORD dwFlags);
    
BOOL 
WszEnumResourceLanguages(
  HMODULE hModule,             // module handle
  LPCWSTR lpType,              // resource type
  LPCWSTR lpName,              // resource name
  ENUMRESLANGPROC lpEnumFunc,  // callback function
  LPARAM  lParam              // application-defined parameter
);

int 
WszGetDateFormat(
  LCID Locale,               // locale
  DWORD dwFlags,             // options
  CONST SYSTEMTIME *lpDate,  // date
  LPCWSTR lpFormat,          // date format
  LPWSTR lpDateStr,          // formatted string buffer
  int cchDate                // size of buffer
);

LRESULT
WszSendMessage(
  HWND hWnd,
  UINT Msg,
  WPARAM wParam,
  LPARAM lParam);

HMENU
WszLoadMenu(
  HINSTANCE hInst,
  LPCWSTR lpMenuName);

HANDLE
WszLoadImage(
  HINSTANCE hInst,
  LPCTSTR lpszName,
  UINT uType,
  int cxDesired,
  int cyDesired,
  UINT fuLoad);

int WszMessageBox(
  HWND hWnd ,
  LPCWSTR lpText,
  LPCWSTR lpCaption,
  UINT uType);

LONG
WszGetWindowLong(
  HWND hWnd,
  int  nIndex);

LONG
WszSetWindowLong(
  HWND hWnd,
  int  nIndex,
  LONG lNewVal);

HWND
WszCreateDialog(
  HINSTANCE   hInstance,
  LPCWSTR     lpTemplateName,
  HWND        hWndParent,
  DLGPROC     lpDialogFunc);

HWND
WszCreateDialogParam(
  HINSTANCE   hInstance,
  LPCWSTR     lpTemplateName,
  HWND        hWndParent,
  DLGPROC     lpDialogFunc,
  LPARAM      dwInitParam);

INT_PTR
WszDialogBoxParam(
  HINSTANCE   hInstance,
  LPCWSTR     lpszTemplate,
  HWND        hWndParent,
  DLGPROC     lpDialogFunc,
  LPARAM      dwInitParam);

BOOL
WszIsDialogMessage(
  HWND    hDlg,
  LPMSG   lpMsg);

BOOL
WszGetMessage(
  LPMSG   lpMsg,
  HWND    hWnd,
  UINT    wMsgFilterMin,
  UINT    wMsgFilterMax);

BOOL
WszGetDiskFreeSpaceEx(
  LPCWSTR lpDirectoryName,
  PULARGE_INTEGER lpFreeBytesAvailable,
  PULARGE_INTEGER lpTotalNumberOfBytes,
  PULARGE_INTEGER lpTotalNumberOfFreeBytes);

HANDLE
WszFindFirstChangeNotification(
  LPWSTR lpPathName,
  BOOL bWatchSubtree,
  DWORD dwNotifyFilter);

HACCEL
WszLoadAccelerators(
    HINSTANCE hInstance,
    LPCWSTR lpTableName);

int 
WszTranslateAccelerator(
  HWND hWnd,
  HACCEL hAccTable,
  LPMSG lpMsg);

LRESULT
WszDefWindowProc(
  HWND hWnd,
  UINT Msg,
  WPARAM wParam,
  LPARAM lParam);

HWND
WszCreateWindowEx(
  DWORD       dwExStyle,
  LPCWSTR     lpClassName,
  LPCWSTR     lpWindowName,
  DWORD       dwStyle,
  int         X,
  int         Y,
  int         nWidth,
  int         nHeight,
  HWND        hWndParent,
  HMENU       hMenu,
  HINSTANCE   hInstance,
  LPVOID      lpParam);

ATOM
WszRegisterClass(
    CONST WNDCLASSW *lpWndClass);

BOOL
WszGetClassInfo(
    HINSTANCE hModule,
    LPCWSTR lpClassName,
    LPWNDCLASSW lpWndClassW);

HRSRC
WszFindResource(
  HMODULE hModule,
  LPCWSTR lpName,
  LPCWSTR lpType);

LRESULT
WszSendDlgItemMessage(
  HWND    hDlg,
  int     nIDDlgItem,
  UINT    Msg,
  WPARAM  wParam,
  LPARAM  lParam);

HICON
WszLoadIcon(
  HINSTANCE hInstance,
  LPCWSTR lpIconName);

HCURSOR
WszLoadCursor(
    HINSTANCE hInstance,
    LPCWSTR lpCursorName);

BOOL 
WszSetWindowText(
  HWND hWnd,         // handle to window or control
  LPCWSTR lpString   // title or text
);

LONG_PTR WszSetWindowLongPtr(
  HWND hWnd,           // handle to window
  int nIndex,          // offset of value to set
  LONG_PTR dwNewLong   // new value
);

LONG_PTR WszGetWindowLongPtr(
  HWND hWnd,  // handle to window
  int nIndex  // offset of value to retrieve
);

LRESULT WszCallWindowProc(
  WNDPROC lpPrevWndFunc,  // pointer to previous procedure
  HWND hWnd,              // handle to window
  UINT Msg,               // message
  WPARAM wParam,          // first message parameter
  LPARAM lParam           // second message parameter
);

BOOL WszSystemParametersInfo(
  UINT uiAction,  // system parameter to retrieve or set
  UINT uiParam,   // depends on action to be taken
  PVOID pvParam,  // depends on action to be taken
  UINT fWinIni    // user profile update option
);

int WszGetWindowText(
  HWND hWnd,        // handle to window or control
  LPWSTR lpString,  // text buffer
  int nMaxCount     // maximum number of characters to copy
);

BOOL WszSetDlgItemText(
  HWND hDlg,         // handle to dialog box
  int nIDDlgItem,    // control identifier
  LPCWSTR lpString   // text to set
);

BOOL
WszLookupPrivilegeValue(
  LPCWSTR lpSystemName,
  LPCWSTR lpName,
  PLUID lpLuid);

#endif // _X86_
#endif // PLATFORM_WIN32


#ifndef Wsz_mbstowcs
#define Wsz_mbstowcs(szOut, szIn, iSize) WszMultiByteToWideChar(CP_ACP, 0, szIn, -1, szOut, iSize)
#endif


#ifndef Wsz_wcstombs
#define Wsz_wcstombs(szOut, szIn, iSize) WszWideCharToMultiByte(CP_ACP, 0, szIn, -1, szOut, iSize, 0, 0)
#endif

// For all platforms:

DWORD
WszGetWorkingSet(
    VOID
    );

LPWSTR
Wszltow(
    LONG val,
    LPWSTR buf,
    int radix
    );

LPWSTR
Wszultow(
    ULONG val,
    LPWSTR buf,
    int radix
    );

VOID
WszReleaseActCtx(
    HANDLE hActCtx
    );

BOOL
WszGetCurrentActCtx(
    HANDLE *lphActCtx);

BOOL
WszQueryActCtxW(
    IN DWORD dwFlags,
    IN HANDLE hActCtx,
    IN PVOID pvSubInstance,
    IN ULONG ulInfoClass,
    OUT PVOID pvBuffer,
    IN SIZE_T cbBuffer OPTIONAL,
    OUT SIZE_T *pcbWrittenOrRequired OPTIONAL
    );


#ifndef PLATFORM_WIN32
FARPROC WszGetProcAddress(HMODULE hMod, LPCSTR szProcName);
UINT GetSystemDirectoryW(LPWSTR lpBuffer, UINT uSize);
UINT GetEnvironmentVariableW(LPCWSTR lpName,  LPWSTR lpBuffer, UINT uSize);
#endif // !PLATFORM_WIN32

#ifdef _WIN64
#undef CoInternetCreateSecurityManager
#define CoInternetCreateSecurityManager(x,y,z) E_FAIL
#define WszRegQueryValue RegQueryValue
#endif // _WIN64

#undef InterlockedExchangePointer
#if defined(_WIN64)
    #pragma intrinsic(_InterlockedExchangePointer)
    PVOID WINAPI _InterlockedExchangePointer(IN PVOID * pvDst, IN PVOID pvSrc);
    #define InterlockedExchangePointer _InterlockedExchangePointer
#else
    #define InterlockedExchangePointer(dst, src) (PVOID)(size_t)InterlockedExchange((LPLONG)(size_t)(PVOID*)dst, (LONG)(size_t)(PVOID)src)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\zapper.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef ZAPPER_H_
#define ZAPPER_H_

#include <WinWrap.h>
#include <windows.h>
#include <stdlib.h>
#include <objbase.h>
#include <stddef.h>
#include <float.h>
#include <limits.h>

#include "utilcode.h"
#include "corjit.h"
#include "corcompile.h"
#include "iceefilegen.h"
#include "corzap.h"
#include "wsinfo.h"
#include "ngen.h"

// This definition was pulled out of the SDK
#ifndef IMAGE_REL_BASED_REL32
#define IMAGE_REL_BASED_REL32                 7
#endif


// For side by side issues, it's best to use the exported API calls to generate a
// Zapper Object instead of creating one on your own.

STDAPI NGenCreateZapper(HANDLE* hZapper, NGenOptions* opt);
STDAPI NGenFreeZapper(HANDLE hZapper);
STDAPI NGenTryEnumerateFusionCache(HANDLE hZapper, LPCWSTR assemblyName, bool fPrint, bool fDelete);
STDAPI NGenCompile(HANDLE hZapper, LPCWSTR path);

/* --------------------------------------------------------------------------- *
 * Zapper classes
 * --------------------------------------------------------------------------- */

class ZapperOptions;
class ZapperStats;
class ZapperAttributionStats;
class ZapperModule;
class DynamicInfoTable;
class ImportTable;
class ImportBlobTable;
class LoadTable;

class Zapper : public ICorZapCompile, public ICorZapRequest
{
    friend class ZapperModule;

 private:

    LONG            m_refCount;

    //
    // Interfaces
    //

    ICorCompileInfo         *m_pEECompileInfo;
    ICorJitCompiler         *m_pJitCompiler;
    ICeeFileGen             *m_pCeeFileGen;
    IMetaDataDispenserEx    *m_pMetaDataDispenser;
    HMODULE                 m_hJitLib;

    //
    // Options
    // 
    
    class ZapperOptions *m_pOpt;   
    BOOL                m_fFreeZapperOptions; 

    ICorZapStatus       *m_pStatus;

    WCHAR                m_exeName[MAX_PATH];

    //
    // Current assembly info
    //

    ICorCompilationDomain   *m_pDomain;
    CORINFO_ASSEMBLY_HANDLE m_hAssembly;
    IMetaDataAssemblyImport *m_pAssemblyImport;
    BOOL                    m_fStrongName;

    WCHAR                   m_zapString[CORCOMPILE_MAX_ZAP_STRING_SIZE + 1 + 8];
    WCHAR                   m_outputPath[MAX_PATH]; 
    IMetaDataAssemblyEmit   *m_pAssemblyEmit;

    //
    // Exception info
    // 
    
    HRESULT                 m_hr;

  public:

    Zapper(ZapperOptions *pOpt);
    Zapper(NGenOptions *pOpt);
    
    void Init(ZapperOptions *pOpt, bool fFreeZapperOptions= false, bool fInitExeName = true);

    ~Zapper();

    void InitEE();
    void CleanupDomain();
    void CleanupAssembly();

    HRESULT TryEnumerateFusionCache(LPCWSTR assemblyName, bool fPrint, bool fDelete);
    int EnumerateFusionCache(LPCWSTR assemblyName, bool fPrint, bool fDelete);
    void PrintFusionCacheEntry(IAssemblyName *pZapAssemblyName);
    void DeleteFusionCacheEntry(IAssemblyName *pZapAssemblyName);
    void PrintAssemblyVersionInfo(IAssemblyName *pZapAssemblyName);

    IAssemblyName *GetAssemblyFusionName(IMetaDataAssemblyImport *pImport);
    IAssemblyName *GetAssemblyRefFusionName(IMetaDataAssemblyImport *pImport,
                                            mdAssemblyRef ar);

    BOOL IsAssembly(LPCWSTR path);

    BOOL Compile(LPCWSTR path);

    BOOL EnumerateLog(LPCWSTR pAppName, BOOL doCompile, BOOL doPrint, BOOL doDelete);

    void CompileModule(CORINFO_MODULE_HANDLE hModule, LPCWSTR fileName, 
                       IMetaDataAssemblyEmit *pEmit, ZapperModule **pModule);
    BOOL TryCompileModule(CORINFO_MODULE_HANDLE hModule, LPCWSTR fileName, 
                          IMetaDataAssemblyEmit *pEmit, ZapperModule **pModule);
    void CloseModule(ZapperModule *pModule);
    BOOL TryCloseModule(ZapperModule *pModule);

    void CompileAssembly(CORINFO_ASSEMBLY_HANDLE hAssembly);

    int FilterException(EXCEPTION_POINTERS *info);
    HRESULT GetExceptionHR();

    void Success(LPCWSTR format, ...);
    void Error(LPCWSTR format, ...);
    void Warning(LPCWSTR format, ...);
    void Info(LPCWSTR format, ...);
    void Print(CorZapLogLevel level, LPCWSTR format, va_list args);
    void PrintErrorMessage(HRESULT hr);


    void CleanDirectory(LPCWSTR path);
    void TryCleanDirectory(LPCWSTR path);
    void ComputeHashValue(LPCWSTR pFileName, int hashAlg, 
                          BYTE **ppHashValue, DWORD *cbHashValue);

    //
    // IUnknown
    //

    ULONG STDMETHODCALLTYPE AddRef() 
    {
        return (InterlockedIncrement((long *) &m_refCount));
    }

    ULONG STDMETHODCALLTYPE Release() 
    {
        long refCount = InterlockedDecrement(&m_refCount);
        if (refCount == 0)
            delete this;

        return refCount;
    }

    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppInterface)
    {
        if (riid == IID_IUnknown)
            *ppInterface = (IUnknown *) (ICorZapCompile*) this;
        else if (riid == IID_ICorZapCompile)
            *ppInterface = (ICorZapCompile *) this;
        else if (riid == IID_ICorZapRequest)
            *ppInterface = (ICorZapRequest *) this;
        else
            return (E_NOINTERFACE);

        this->AddRef();
        return S_OK;
    }
    
    // ICorZapCompile
    // 
    // This is the interface to the zap compiler
    // from the zap service.

    HRESULT STDMETHODCALLTYPE Compile(IApplicationContext *pContext,
                                      IAssemblyName *pAssembly,
                                      ICorZapConfiguration *pConfiguration,
                                      ICorZapPreferences *pPreferences,
                                      ICorZapStatus *pStatus);

    HRESULT STDMETHODCALLTYPE CompileBound(IApplicationContext *pContext,
                                           IAssemblyName *pAssembly,
                                           ICorZapConfiguration *pConfiguratino,
                                           ICorZapBinding **ppBindings,
                                           DWORD cBindings,
                                           ICorZapPreferences *pPreferences,
                                           ICorZapStatus *pStatus);

    // ICorZapRequest
    // 
    // This interface is normally implemented by the zap service, but is
    // included here so we can hook up the zapper as a "dumb" zap service
    // for testing purposes.

    HRESULT  STDMETHODCALLTYPE Load(IApplicationContext *pContext,
                                    IAssemblyName *pAssembly,
                                    ICorZapConfiguration *pConfig,
                                    ICorZapBinding **pBindings,
                                    DWORD cBindings);


    HRESULT  STDMETHODCALLTYPE Install(IApplicationContext *pContext,
                                       IAssemblyName *pAssembly,
                                       ICorZapConfiguration *pConfig,
                                       ICorZapPreferences *pPrefs);

 private:

    HRESULT CompileGeneric(IApplicationContext *pContext,
                           IAssemblyName *pAssembly,
                           ICorZapConfiguration *pConfiguratino,
                           ICorZapBinding **ppBindings,
                           DWORD cBindings,
                           ICorZapPreferences *pPreferences,
                           ICorZapStatus *pStatus);

    BOOL CompileInCurrentDomain(LPCWSTR path);

    HRESULT SetPreferences(ICorZapPreferences *pPreferences);
    HRESULT SetConfiguration(ICorZapConfiguration *pConfiguration);

};

class ZapperModule : public ICorJitInfo, public ICorCompileDataStore
{
    friend class Zapper;

 private:

    Zapper          *m_zapper;

    //
    // Output module
    //
    
    HCEEFILE        m_hFile;

    HCEESECTION     m_hHeaderSection;
    HCEESECTION     m_hCodeSection;
    HCEESECTION     m_hMetaDataSection;
    HCEESECTION     m_hExceptionSection;
    HCEESECTION     m_hGCSection;
    HCEESECTION     m_hCodeMgrSection;
    HCEESECTION     m_hReadOnlyDataSection;
    HCEESECTION     m_hWritableDataSection;
    HCEESECTION     m_hEETableSection;
    HCEESECTION     m_hImportTableSection;
    HCEESECTION     m_hDynamicInfoSection;
    HCEESECTION     m_hDynamicInfoTableSection[CORCOMPILE_TABLE_COUNT];
    HCEESECTION     m_hDynamicInfoDelayListSection;
    HCEESECTION     m_hPreloadSection;
    HCEESECTION     m_hDebugTableSection;
    HCEESECTION     m_hDebugSection;
    
    IMetaDataAssemblyEmit   *m_pAssemblyEmit;

    CORCOMPILE_EE_INFO_TABLE    *m_pEEInfoTable;
    void                        *(*m_pHelperTable)[CORINFO_HELP_COUNT];

    ImportTable                 *m_pImportTable;

    IMAGE_DATA_DIRECTORY        (*m_pDynamicInfo)[CORCOMPILE_TABLE_COUNT];

    DynamicInfoTable            *m_pDynamicInfoTable[CORCOMPILE_TABLE_COUNT];
    
    LoadTable                   *m_pLoadTable;

    BYTE                        *m_pPreloadImage;

    DWORD                       *m_ridMap;
    ULONG                       m_ridMapCount;
    SIZE_T                      m_ridMapAlloc;

    CORCOMPILE_DEBUG_ENTRY      *m_debugTable;
    ULONG                       m_debugTableCount;
    SIZE_T                      m_debugTableAlloc;

    CORCOMPILE_HEADER           *m_pZapHeader;

    ULONG                       m_lastDelayListOffset;
    unsigned                    m_lastMethodChunkIndex;

    ZapperStats                 *m_stats;
    ZapperAttributionStats      *m_wsStats;

    //
    // Input module
    //

    LPCWSTR                     m_pFileName;
    SIZE_T                      m_baseAddress;
    SIZE_T                      m_libraryBaseAddress;
    CORINFO_MODULE_HANDLE       m_hModule;
    BOOL                        m_skipVerification;
    IMAGE_COR20_HEADER          *m_pHeader;
    IMetaDataImport             *m_pImport;
    ICorCompilePreloader        *m_pPreloader;
    
    BYTE                        *m_loadOrderFile;
    mdToken                     *m_pLoadOrderArray;
    DWORD                       m_cLoadOrderArray;

    //
    // Current method 
    //
    
    mdMethodDef                 m_currentMethod;
    CORINFO_METHOD_HANDLE       m_currentMethodHandle;
    
    BYTE                        *m_currentMethodCode;
    ULONG                       m_currentMethodCodeSize;
    CORCOMPILE_METHOD_HEADER    *m_currentMethodHeader;
    unsigned                    m_currentMethodHeaderOffset;

 public:

    ZapperModule(Zapper *zapper);
    ~ZapperModule();

    void CleanupMethod();

    // Need this to avoid compiler complaint about calling constructor inside __try
    static ZapperModule *NewModule(Zapper *zapper) 
        { return new ZapperModule(zapper); }

    void OpenOutputFile();
    void CloseOutputFile();

    void Open(CORINFO_MODULE_HANDLE hModule, LPCWSTR name, IMetaDataAssemblyEmit *pEmit);
    void Close();

    void Preload();
    void LinkPreload();

    void OutputTables();

    void Compile();
    BOOL TryCompileMethod(mdMethodDef md);
    void CompileMethod(mdMethodDef md);

    void GrowRidMap(SIZE_T maxRid);

    HRESULT GetClassBlob(CORINFO_CLASS_HANDLE handle,
                         BYTE **ppBlob);
    HRESULT GetFieldBlob(CORINFO_FIELD_HANDLE handle,
                         BYTE **ppBlob);
    HRESULT GetMethodBlob(CORINFO_METHOD_HANDLE handle,
                         BYTE **ppBlob);
    HRESULT GetStringBlob(CORINFO_MODULE_HANDLE handle,
                          mdString string,
                          BYTE **ppBlob);
    HRESULT GetSigBlob(CORINFO_MODULE_HANDLE handle,
                       mdToken sigOrMemberRef,
                       BYTE **ppBlob);

    HRESULT GetMethodDebugEntry(CORINFO_METHOD_HANDLE handle,
                             CORCOMPILE_DEBUG_ENTRY **entry);

    HRESULT DumpTokenDescription(mdToken token);

    // ICorJitInfo
    
    HRESULT __stdcall alloc(ULONG code_len, unsigned char** ppCode, 
                            ULONG EHinfo_len, unsigned char** ppEHinfo, 
                            ULONG GCinfo_len, unsigned char** ppGCinfo);
    HRESULT __stdcall allocMem(ULONG codeSize, ULONG roDataSize, ULONG rwDataSize, 
                               void **codeBlock, void **roDataBlock, void **rwDataBlock);
    HRESULT __stdcall allocGCInfo(ULONG size, void **block);
    HRESULT __stdcall setEHcount(unsigned cEH);
    void __stdcall setEHinfo(unsigned EHnumber, const CORINFO_EH_CLAUSE *clause);

    int canHandleException(struct _EXCEPTION_POINTERS *pExceptionPointers);
    BOOL __cdecl logMsg(unsigned level,  const char *fmt, va_list args);
    int doAssert(const char* szFile, int iLine, const char* szExpr);

    // ICorDynamicInfo

    DWORD __stdcall getThreadTLSIndex(void **ppIndirection);
    const void * __stdcall getInlinedCallFrameVptr(void **ppIndirection);
    LONG * __stdcall getAddrOfCaptureThreadGlobal(void **ppIndirection);

    CORINFO_MODULE_HANDLE __stdcall 
      embedModuleHandle(CORINFO_MODULE_HANDLE handle, 
                        void **ppIndirection);
    CORINFO_CLASS_HANDLE __stdcall 
      embedClassHandle(CORINFO_CLASS_HANDLE handle, 
                       void **ppIndirection);
    CORINFO_FIELD_HANDLE __stdcall 
      embedFieldHandle(CORINFO_FIELD_HANDLE handle, 
                       void **ppIndirection);
    CORINFO_METHOD_HANDLE __stdcall 
      embedMethodHandle(CORINFO_METHOD_HANDLE handle, 
                        void **ppIndirection);
    CORINFO_GENERIC_HANDLE __stdcall
      embedGenericHandle(CORINFO_MODULE_HANDLE module,
                         unsigned metaTOK,
                         CORINFO_METHOD_HANDLE context,
                         void **ppIndirection,
                         CORINFO_CLASS_HANDLE& tokenType);

    void *__stdcall getHelperFtn(CorInfoHelpFunc ftnNum, 
                                 void **ppIndirection);
    void * __stdcall getFunctionEntryPoint(CORINFO_METHOD_HANDLE ftn,
                                           InfoAccessType *pAccessType,
                                           CORINFO_ACCESS_FLAGS  flags);
    void * __stdcall getFunctionFixedEntryPoint(CORINFO_METHOD_HANDLE ftn,
                                        InfoAccessType *pAccessType,
                                        CORINFO_ACCESS_FLAGS  flags);
    void *__stdcall getMethodSync(CORINFO_METHOD_HANDLE ftn, 
                                  void **ppIndirection);
    void **__stdcall AllocHintPointer(CORINFO_METHOD_HANDLE method, 
                                      void **ppIndirection);
    void *__stdcall getPInvokeUnmanagedTarget(CORINFO_METHOD_HANDLE method, 
                                              void **ppIndirection);
    void *__stdcall getAddressOfPInvokeFixup(CORINFO_METHOD_HANDLE method, 
                                             void **ppIndirection);
    CORINFO_PROFILING_HANDLE __stdcall 
      GetProfilingHandle(CORINFO_METHOD_HANDLE method, 
                         BOOL *pbHookFunction,
                         void **ppIndirection);
    void *__stdcall getInterfaceID(CORINFO_CLASS_HANDLE cls, 
                                   void **ppIndirection);
    unsigned __stdcall getInterfaceTableOffset(CORINFO_CLASS_HANDLE cls, 
                                               void **ppIndirection);
    unsigned __stdcall getClassDomainID(CORINFO_CLASS_HANDLE cls, 
                                        void **ppIndirection);
    void *__stdcall getFieldAddress(CORINFO_FIELD_HANDLE field, 
                                    void **ppIndirection);
    CorInfoHelpFunc __stdcall getFieldHelper(CORINFO_FIELD_HANDLE field, 
                                             enum CorInfoFieldAccess kind);
    DWORD __stdcall getFieldThreadLocalStoreID (CORINFO_FIELD_HANDLE field, 
                                                void **ppIndirection);
    CORINFO_VARARGS_HANDLE __stdcall getVarArgsHandle(CORINFO_SIG_INFO *sig, 
                                                      void **ppIndirection);
    LPVOID __stdcall constructStringLiteral(CORINFO_MODULE_HANDLE module, 
                                            unsigned metaTok, void **ppIndirection);

    CORINFO_CLASS_HANDLE __stdcall findMethodClass(CORINFO_MODULE_HANDLE module, 
                                           mdToken methodTok);
    LPVOID __stdcall getInstantiationParam(CORINFO_MODULE_HANDLE module, 
                                           mdToken methodTok, void **ppIndirection);

    void __stdcall setOverride(ICorDynamicInfo *pOverride);

    // Relocations

    bool __stdcall deferLocation(CORINFO_METHOD_HANDLE ftn, 
                                 IDeferredLocation *pIDL);
    void __stdcall recordRelocation(void **ppX, WORD fRelocType);

    // ICorStaticInfo

    void __stdcall getEEInfo(CORINFO_EE_INFO *pEEInfoOut);
    void *__stdcall findPtr(CORINFO_MODULE_HANDLE module, unsigned ptrTOK);

    // ICorArgInfo

    CORINFO_ARG_LIST_HANDLE __stdcall getArgNext(CORINFO_ARG_LIST_HANDLE args);
    CorInfoTypeWithMod __stdcall getArgType(CORINFO_SIG_INFO* sig, 
                                     CORINFO_ARG_LIST_HANDLE args,
                                     CORINFO_CLASS_HANDLE *vcTypeRet);
    CORINFO_CLASS_HANDLE __stdcall getArgClass(CORINFO_SIG_INFO* sig, 
                                               CORINFO_ARG_LIST_HANDLE args);

    // ICorDebugInfo

    void __stdcall getBoundaries(CORINFO_METHOD_HANDLE ftn, unsigned int *cILOffsets, 
                                 DWORD **pILOffsets, BoundaryTypes *implicitBoundaries);
    void __stdcall setBoundaries(CORINFO_METHOD_HANDLE ftn, ULONG32 cMap, 
                                 OffsetMapping *pMap);
    void __stdcall getVars(CORINFO_METHOD_HANDLE ftn, ULONG32 *cVars, 
                           ILVarInfo **vars, bool *extendOthers);
    void __stdcall setVars(CORINFO_METHOD_HANDLE ftn, ULONG32 cVars, 
                           NativeVarInfo*vars);
    void * __stdcall allocateArray(ULONG cBytes);
    void __stdcall freeArray(void *array);

    // ICorFieldInfo

    const char* __stdcall getFieldName(CORINFO_FIELD_HANDLE ftn, const char **moduleName);
    DWORD __stdcall getFieldAttribs(CORINFO_FIELD_HANDLE field, 
                                    CORINFO_METHOD_HANDLE context,
                                    CORINFO_ACCESS_FLAGS  flags);
    CORINFO_CLASS_HANDLE __stdcall getFieldClass(CORINFO_FIELD_HANDLE field);
    CorInfoType __stdcall getFieldType(CORINFO_FIELD_HANDLE field,
                                       CORINFO_CLASS_HANDLE *structType);
    CorInfoFieldCategory __stdcall getFieldCategory(CORINFO_FIELD_HANDLE field);
    unsigned __stdcall getIndirectionOffset();
    unsigned __stdcall getFieldOffset(CORINFO_FIELD_HANDLE field);

    // ICorClassInfo

    CorInfoType __stdcall asCorInfoType(CORINFO_CLASS_HANDLE cls);
    const char* __stdcall getClassName(CORINFO_CLASS_HANDLE cls);
    DWORD __stdcall getClassAttribs(CORINFO_CLASS_HANDLE cls, CORINFO_METHOD_HANDLE context);
    CORINFO_MODULE_HANDLE __stdcall getClassModule(CORINFO_CLASS_HANDLE cls);
    CORINFO_CLASS_HANDLE __stdcall getSDArrayForClass(CORINFO_CLASS_HANDLE cls);
    unsigned __stdcall getClassSize(CORINFO_CLASS_HANDLE cls);
    unsigned __stdcall getClassGClayout(CORINFO_CLASS_HANDLE cls, BYTE *gcPtrs);
    const unsigned __stdcall getClassNumInstanceFields(CORINFO_CLASS_HANDLE cls);
    const unsigned __stdcall getFieldNumber(CORINFO_FIELD_HANDLE fldHnd);

    CORINFO_CLASS_HANDLE __stdcall getEnclosingClass(CORINFO_FIELD_HANDLE field);

    BOOL __stdcall canAccessField(CORINFO_METHOD_HANDLE context,
                                CORINFO_FIELD_HANDLE    target,
                                CORINFO_CLASS_HANDLE    instance);

    CorInfoHelpFunc __stdcall getNewHelper(CORINFO_CLASS_HANDLE newCls, 
                                           CORINFO_METHOD_HANDLE context);
    CorInfoHelpFunc __stdcall getIsInstanceOfHelper(CORINFO_CLASS_HANDLE isInstCls);
    CorInfoHelpFunc __stdcall getNewArrHelper(CORINFO_CLASS_HANDLE arrayCls, 
                                              CORINFO_METHOD_HANDLE context);
    CorInfoHelpFunc __stdcall getChkCastHelper(CORINFO_CLASS_HANDLE IsInstCls);
    BOOL __stdcall initClass(CORINFO_CLASS_HANDLE cls, CORINFO_METHOD_HANDLE context, BOOL speculative);
    BOOL __stdcall loadClass(CORINFO_CLASS_HANDLE cls, CORINFO_METHOD_HANDLE context, BOOL speculative);
    CORINFO_CLASS_HANDLE __stdcall getBuiltinClass(CorInfoClassId classId);
    CorInfoType __stdcall getTypeForPrimitiveValueClass(CORINFO_CLASS_HANDLE cls);
    BOOL __stdcall canCast(CORINFO_CLASS_HANDLE child, CORINFO_CLASS_HANDLE parent);
    CORINFO_CLASS_HANDLE __stdcall mergeClasses(CORINFO_CLASS_HANDLE cls1, 
                                CORINFO_CLASS_HANDLE cls2);
    CORINFO_CLASS_HANDLE __stdcall getParentType(CORINFO_CLASS_HANDLE  cls);
    CorInfoType __stdcall getChildType (CORINFO_CLASS_HANDLE       clsHnd,
                                CORINFO_CLASS_HANDLE       *clsRet);
    BOOL __stdcall canAccessType(CORINFO_METHOD_HANDLE context,
                                CORINFO_CLASS_HANDLE   target);
    BOOL __stdcall isSDArray(CORINFO_CLASS_HANDLE      cls); 


    // ICorModuleInfo

    DWORD __stdcall getModuleAttribs(CORINFO_MODULE_HANDLE module);
    CORINFO_CLASS_HANDLE __stdcall findClass(CORINFO_MODULE_HANDLE module, 
                                             unsigned metaTOK, 
                                             CORINFO_METHOD_HANDLE context);
    CORINFO_FIELD_HANDLE __stdcall findField(CORINFO_MODULE_HANDLE module, 
                                             unsigned metaTOK, 
                                             CORINFO_METHOD_HANDLE context);
    CORINFO_METHOD_HANDLE __stdcall findMethod(CORINFO_MODULE_HANDLE module, 
                                               unsigned metaTOK, 
                                               CORINFO_METHOD_HANDLE context);
    void __stdcall findSig(CORINFO_MODULE_HANDLE module, unsigned sigTOK, 
                           CORINFO_SIG_INFO *sig);
    void __stdcall findCallSiteSig(CORINFO_MODULE_HANDLE module, 
                                   unsigned methTOK, CORINFO_SIG_INFO *sig);
    CORINFO_GENERIC_HANDLE __stdcall findToken(CORINFO_MODULE_HANDLE module, 
                                               unsigned metaTOK, 
                                               CORINFO_METHOD_HANDLE context,
                                               CORINFO_CLASS_HANDLE& tokenType);
    const char * __stdcall findNameOfToken(CORINFO_MODULE_HANDLE module,
                                           unsigned metaTOK);
    BOOL __stdcall canSkipVerification (CORINFO_MODULE_HANDLE module, BOOL fQuickCheckOnly);
    BOOL __stdcall isValidToken(CORINFO_MODULE_HANDLE module,
                                            unsigned metaTOK);
    BOOL __stdcall isValidStringRef(CORINFO_MODULE_HANDLE module,
                                            unsigned metaTOK);


    // ICorMethodInfo

    const char* __stdcall getMethodName(CORINFO_METHOD_HANDLE ftn, 
                                        const char **moduleName);
    unsigned __stdcall getMethodHash(CORINFO_METHOD_HANDLE ftn);
    DWORD __stdcall getMethodAttribs(CORINFO_METHOD_HANDLE  ftn, CORINFO_METHOD_HANDLE context);
    CorInfoCallCategory __stdcall getMethodCallCategory(CORINFO_METHOD_HANDLE method);
    void __stdcall setMethodAttribs(CORINFO_METHOD_HANDLE ftn, DWORD attribs);
    void __stdcall getMethodSig(CORINFO_METHOD_HANDLE ftn, CORINFO_SIG_INFO *sig);
    bool __stdcall getMethodInfo(CORINFO_METHOD_HANDLE ftn, 
                                 CORINFO_METHOD_INFO* info);
    CorInfoInline __stdcall canInline(CORINFO_METHOD_HANDLE caller, 
                             CORINFO_METHOD_HANDLE callee,
                             CORINFO_ACCESS_FLAGS  flags);
    bool __stdcall canTailCall(CORINFO_METHOD_HANDLE caller, 
                               CORINFO_METHOD_HANDLE callee,
                               CORINFO_ACCESS_FLAGS  flags);
    void __stdcall getEHinfo(CORINFO_METHOD_HANDLE ftn, 
                             unsigned EHnumber, CORINFO_EH_CLAUSE* clause);
    CORINFO_CLASS_HANDLE __stdcall getMethodClass(CORINFO_METHOD_HANDLE method);
    CORINFO_MODULE_HANDLE __stdcall getMethodModule(CORINFO_METHOD_HANDLE method);
    unsigned __stdcall getMethodVTableOffset(CORINFO_METHOD_HANDLE method);
    CorInfoIntrinsics __stdcall getIntrinsicID(CORINFO_METHOD_HANDLE method);
    BOOL __stdcall canPutField(CORINFO_METHOD_HANDLE method, CORINFO_FIELD_HANDLE field);
    CorInfoUnmanagedCallConv __stdcall getUnmanagedCallConv(CORINFO_METHOD_HANDLE method);
    BOOL __stdcall pInvokeMarshalingRequired(CORINFO_METHOD_HANDLE method, CORINFO_SIG_INFO* sig);
    LPVOID GetCookieForPInvokeCalliSig(CORINFO_SIG_INFO* szMetaSig,
                                       void ** ppIndirecton);
    BOOL __stdcall compatibleMethodSig(CORINFO_METHOD_HANDLE child, 
                                        CORINFO_METHOD_HANDLE parent);
    BOOL __stdcall canAccessMethod(CORINFO_METHOD_HANDLE      context,
                                        CORINFO_METHOD_HANDLE target,
                                        CORINFO_CLASS_HANDLE  instance);
    BOOL __stdcall isCompatibleDelegate(CORINFO_CLASS_HANDLE  objCls,
                                        CORINFO_METHOD_HANDLE method,
                                        CORINFO_METHOD_HANDLE delegateCtor);


    // ICorErrorInfo

    HRESULT __stdcall GetErrorHRESULT();
    CORINFO_CLASS_HANDLE __stdcall GetErrorClass();
    ULONG __stdcall GetErrorMessage(LPWSTR buffer, ULONG bufferLength);
    int __stdcall FilterException(struct _EXCEPTION_POINTERS *pExceptionPointers);

    // ICorCompileDataStore

    HRESULT __stdcall Allocate(ULONG size, 
                               ULONG *sizesByDescription,
                               void **baseMemory);
    HRESULT __stdcall AddFixup(ULONG offset,
                               CorCompileReferenceDest dest,
                               CorCompileFixup type);
    HRESULT __stdcall AddTokenFixup(ULONG offset,
                                    mdToken tokenType,
                                    CORINFO_MODULE_HANDLE module);
    HRESULT __stdcall GetFunctionAddress(CORINFO_METHOD_HANDLE method, 
                                         void **pCode);
    HRESULT __stdcall AdjustAttribution(mdToken token, LONG size);
    HRESULT __stdcall Error(mdToken token, HRESULT error, LPCWSTR message);
};

class ZapperOptions
{
  public:
    bool        m_preload;
    bool        m_jit;
    bool        m_recurse;
    bool        m_update;
    bool        m_shared;
    LPWSTR      m_set;

    bool        m_autodebug;
    bool        m_restricted;           // Don't allow non-shipping codegen configurations 

    MethodNamesList* m_onlyMethods;     // only methods to process
    MethodNamesList* m_excludeMethods;  // excluded these methods

    bool        m_silent;
    bool        m_verbose;
    bool        m_genBase;  
    bool        m_ignoreErrors;
    bool        m_JITcode;          // produce code as a JIT jit would (can not be run, for debugging)
    bool        m_assumeInit;       // produce code as if all class constructors have been eagerly inited.
    bool        m_stats;            // print statisitcs on number of methods, size of code ...
    bool        m_attribStats;      // print statistics, attributed to managed code
    unsigned    m_compilerFlags;        
    unsigned    m_logLevel;         // what level of jit log messages to print

    ZapperOptions();
    ~ZapperOptions();
};

class ZapperStats 
{
 public:
    
    unsigned m_methods;
    ULONG    m_ilCodeSize;
    ULONG    m_nativeCodeSize;
    ULONG    m_nativeRODataSize;
    ULONG    m_nativeRWDataSize;
    ULONG    m_gcInfoSize;

    unsigned m_inputFileSize;
    unsigned m_outputFileSize;
    unsigned m_metadataSize;
    unsigned m_preloadImageSize;
    unsigned m_preloadImageModuleSize;
    unsigned m_preloadImageMethodTableSize;
    unsigned m_preloadImageClassSize;
    unsigned m_preloadImageMethodDescSize;
    unsigned m_preloadImageFieldDescSize;
    unsigned m_preloadImageDebugSize;
    unsigned m_preloadImageFixupsSize;
    unsigned m_preloadImageOtherSize;
    unsigned m_codeMgrSize;
    unsigned m_eeInfoTableSize;
    unsigned m_helperTableSize;
    unsigned m_dynamicInfoSize[CORCOMPILE_TABLE_COUNT];
    unsigned m_dynamicInfoTableSize;
    unsigned m_dynamicInfoDelayListSize;
    unsigned m_importTableSize;
    unsigned m_importBlobsSize;
    unsigned m_debuggingTableSize;
    unsigned m_headerSectionSize;
    unsigned m_codeSectionSize;
    unsigned m_exceptionSectionSize;
    unsigned m_readOnlyDataSectionSize;
    unsigned m_writableDataSectionSize;
    unsigned m_relocSectionSize;

    ZapperStats();
    void PrintStats(FILE *stream);
};

class ZapperAttributionStats
{
 public:
    WSInfo m_image;
    WSInfo m_metadata;
    WSInfo m_native;
    WSInfo m_il;
    
    IMetaDataImport *m_pImport;

    ZapperAttributionStats(IMetaDataImport *pImport);
    ~ZapperAttributionStats();
    void PrintStats(FILE *stream);
};
    
class DynamicInfoTable : private CHashTableAndData<CNewData>
{
private:
        
    ICeeFileGen *m_pCeeFileGen;
    HCEEFILE     m_hFile;
    HCEESECTION  m_hSection;        
    HCEESECTION  m_hDelayListSection;       

    struct DynamicInfoEntry
    {
        HASHENTRY hash;
        BYTE      *key;
        DWORD     *tableEntry;
        mdToken   lastUsed;
    };

    BOOL Cmp(const BYTE *pc1, const HASHENTRY *pc2)
    {
        return (void*)pc1 != ((DynamicInfoEntry*)pc2)->key;
    }

    USHORT HASH(BYTE *key)
    {
        return (USHORT) (((size_t)key) ^ (((size_t)(key))>>16));
    }

    BYTE *KEY(BYTE *key)
    {
        return (BYTE *) key;
    }

public:

    DynamicInfoTable(USHORT size, ICeeFileGen *pCeeFileGen, HCEEFILE hFile, 
                     HCEESECTION hSection, HCEESECTION hDelayListSection);

    HRESULT InternDynamicInfo(BYTE *pBlob, DWORD **ptr, mdToken used = 0);
};

class ImportBlobTable : private CHashTableAndData<CNewData>
{
private:
    ICorCompileInfo         *m_pEECompileInfo;
    ICeeFileGen             *m_pCeeFileGen;
    CORINFO_MODULE_HANDLE   m_hModule;
    HCEESECTION             m_hSection;

    struct ImportBlobEntry
    {
        HASHENTRY               hash;
        void                    *key;
        BYTE                    *blob;
    };

    BOOL Cmp(const BYTE *pc1, const HASHENTRY *pc2)
    {
        return (void*) pc1 != ((ImportBlobEntry*)pc2)->key;
    }

    USHORT HASH(void *key)
    {
        return (USHORT) (((size_t)key) ^ (((size_t)(key))>>16));
    }

    BYTE *KEY(void *key)
    {
        return (BYTE *) key;
    }

    HRESULT FindEntry(void *key, BYTE **ppBlob);
    HRESULT AddEntry(void *key, BYTE *pBlob);

public:

    ImportBlobTable::ImportBlobTable(ICorCompileInfo *pEECompileInfo,
                                     ICeeFileGen *pCeeFileGen,
                                     CORINFO_MODULE_HANDLE hModule,
                                     HCEESECTION hSection);

    HRESULT InternClass(CORINFO_CLASS_HANDLE handle, BYTE **ptr);
    HRESULT InternField(CORINFO_FIELD_HANDLE handle, BYTE **ptr);
    HRESULT InternMethod(CORINFO_METHOD_HANDLE handle, BYTE **ptr);
    HRESULT InternString(mdString token, BYTE **ptr);
    HRESULT InternSig(mdToken token, BYTE **ptr);

    HCEESECTION GetSection() { return m_hSection; }
};

class ImportTable : private CHashTableAndData<CNewData>
{
private:
    ICorCompileInfo         *m_pEECompileInfo;
    ICeeFileGen             *m_pCeeFileGen;
    HCEEFILE                m_hFile;
    HCEESECTION             m_hSection;
    CORINFO_MODULE_HANDLE   m_hModule;
    IMetaDataAssemblyEmit   *m_pAssemblyEmit;
    DWORD                   m_count;
    ZapperStats             *m_stats;

    struct ImportEntry
    {
        HASHENTRY               hash;
        CORINFO_MODULE_HANDLE   module;
        ImportBlobTable         *blobs;
        DWORD                   index;
};

    BOOL Cmp(const BYTE *pc1, const HASHENTRY *pc2)
    {
        return (CORINFO_MODULE_HANDLE)pc1 != ((ImportEntry*)pc2)->module;
    }

    USHORT HASH(CORINFO_MODULE_HANDLE module)
    {
        return (USHORT) (((size_t)module) ^ (((size_t)(module))>>16));
    }

    BYTE *KEY(CORINFO_MODULE_HANDLE module)
    {
        return (BYTE *) module;
    }

public:
    ImportTable(ICorCompileInfo *pEECompileInfo, ICeeFileGen *pCeeFileGen,
                HCEEFILE hFile, HCEESECTION hSection,
                CORINFO_MODULE_HANDLE hModule,
                IMetaDataAssemblyEmit *pAssemblyEmit,
                ZapperStats *stats);
    ~ImportTable();

    ImportBlobTable *InternModule(CORINFO_MODULE_HANDLE handle);
    HRESULT EmitImportTable();
};

class LoadTable : private CHashTableAndData<CNewData>
{
private:
    ZapperModule            *m_pModule;
    DynamicInfoTable        *m_pLoadTable;

    struct LoadEntry
    {
        HASHENTRY               hash;
        CORINFO_CLASS_HANDLE    hClass;
        BOOL                    fixed;
    };

    BOOL Cmp(const BYTE *pc1, const HASHENTRY *pc2)
    {
        return (CORINFO_CLASS_HANDLE)pc1 != ((LoadEntry*)pc2)->hClass;
    }

    USHORT HASH(CORINFO_CLASS_HANDLE hClass)
    {
        return (USHORT) (((size_t)hClass) ^ (((size_t)(hClass))>>16));
    }

    BYTE *KEY(CORINFO_CLASS_HANDLE hClass)
    {
        return (BYTE *) hClass;
    }

public:
    LoadTable(ZapperModule *pModule, DynamicInfoTable *pLoadTable);

    HRESULT LoadClass(CORINFO_CLASS_HANDLE hClass, BOOL fixed);
    HRESULT EmitLoadFixups(mdToken currentMethod);
};

#endif // ZAPPER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\xmlparser.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0328 */
/* Compiler settings for xmlparser.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __xmlparser_h__
#define __xmlparser_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IXMLNodeSource_FWD_DEFINED__
#define __IXMLNodeSource_FWD_DEFINED__
typedef interface IXMLNodeSource IXMLNodeSource;
#endif 	/* __IXMLNodeSource_FWD_DEFINED__ */


#ifndef __IXMLParser_FWD_DEFINED__
#define __IXMLParser_FWD_DEFINED__
typedef interface IXMLParser IXMLParser;
#endif 	/* __IXMLParser_FWD_DEFINED__ */


#ifndef __IXMLNodeFactory_FWD_DEFINED__
#define __IXMLNodeFactory_FWD_DEFINED__
typedef interface IXMLNodeFactory IXMLNodeFactory;
#endif 	/* __IXMLNodeFactory_FWD_DEFINED__ */


#ifndef __XMLParser_FWD_DEFINED__
#define __XMLParser_FWD_DEFINED__

#ifdef __cplusplus
typedef class XMLParser XMLParser;
#else
typedef struct XMLParser XMLParser;
#endif /* __cplusplus */

#endif 	/* __XMLParser_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "objidl.h"
#include "oaidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_xmlparser_0000 */
/* [local] */ 

typedef /* [public] */ 
enum __MIDL___MIDL_itf_xmlparser_0000_0001
    {	XML_ELEMENT	= 1,
	XML_ATTRIBUTE	= XML_ELEMENT + 1,
	XML_PI	= XML_ATTRIBUTE + 1,
	XML_XMLDECL	= XML_PI + 1,
	XML_DOCTYPE	= XML_XMLDECL + 1,
	XML_DTDATTRIBUTE	= XML_DOCTYPE + 1,
	XML_ENTITYDECL	= XML_DTDATTRIBUTE + 1,
	XML_ELEMENTDECL	= XML_ENTITYDECL + 1,
	XML_ATTLISTDECL	= XML_ELEMENTDECL + 1,
	XML_NOTATION	= XML_ATTLISTDECL + 1,
	XML_GROUP	= XML_NOTATION + 1,
	XML_INCLUDESECT	= XML_GROUP + 1,
	XML_PCDATA	= XML_INCLUDESECT + 1,
	XML_CDATA	= XML_PCDATA + 1,
	XML_IGNORESECT	= XML_CDATA + 1,
	XML_COMMENT	= XML_IGNORESECT + 1,
	XML_ENTITYREF	= XML_COMMENT + 1,
	XML_WHITESPACE	= XML_ENTITYREF + 1,
	XML_NAME	= XML_WHITESPACE + 1,
	XML_NMTOKEN	= XML_NAME + 1,
	XML_STRING	= XML_NMTOKEN + 1,
	XML_PEREF	= XML_STRING + 1,
	XML_MODEL	= XML_PEREF + 1,
	XML_ATTDEF	= XML_MODEL + 1,
	XML_ATTTYPE	= XML_ATTDEF + 1,
	XML_ATTPRESENCE	= XML_ATTTYPE + 1,
	XML_DTDSUBSET	= XML_ATTPRESENCE + 1,
	XML_LASTNODETYPE	= XML_DTDSUBSET + 1
    } 	XML_NODE_TYPE;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_xmlparser_0000_0002
    {	XML_VERSION	= XML_LASTNODETYPE,
	XML_ENCODING	= XML_VERSION + 1,
	XML_STANDALONE	= XML_ENCODING + 1,
	XML_NS	= XML_STANDALONE + 1,
	XML_XMLSPACE	= XML_NS + 1,
	XML_XMLLANG	= XML_XMLSPACE + 1,
	XML_SYSTEM	= XML_XMLLANG + 1,
	XML_PUBLIC	= XML_SYSTEM + 1,
	XML_NDATA	= XML_PUBLIC + 1,
	XML_AT_CDATA	= XML_NDATA + 1,
	XML_AT_ID	= XML_AT_CDATA + 1,
	XML_AT_IDREF	= XML_AT_ID + 1,
	XML_AT_IDREFS	= XML_AT_IDREF + 1,
	XML_AT_ENTITY	= XML_AT_IDREFS + 1,
	XML_AT_ENTITIES	= XML_AT_ENTITY + 1,
	XML_AT_NMTOKEN	= XML_AT_ENTITIES + 1,
	XML_AT_NMTOKENS	= XML_AT_NMTOKEN + 1,
	XML_AT_NOTATION	= XML_AT_NMTOKENS + 1,
	XML_AT_REQUIRED	= XML_AT_NOTATION + 1,
	XML_AT_IMPLIED	= XML_AT_REQUIRED + 1,
	XML_AT_FIXED	= XML_AT_IMPLIED + 1,
	XML_PENTITYDECL	= XML_AT_FIXED + 1,
	XML_EMPTY	= XML_PENTITYDECL + 1,
	XML_ANY	= XML_EMPTY + 1,
	XML_MIXED	= XML_ANY + 1,
	XML_SEQUENCE	= XML_MIXED + 1,
	XML_CHOICE	= XML_SEQUENCE + 1,
	XML_STAR	= XML_CHOICE + 1,
	XML_PLUS	= XML_STAR + 1,
	XML_QUESTIONMARK	= XML_PLUS + 1,
	XML_LASTSUBNODETYPE	= XML_QUESTIONMARK + 1
    } 	XML_NODE_SUBTYPE;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_xmlparser_0000_0003
    {	XML_E_PARSEERRORBASE	= 0xc00ce500L,
	XML_E_ENDOFINPUT	= XML_E_PARSEERRORBASE,
	XML_E_MISSINGEQUALS	= XML_E_ENDOFINPUT + 1,
	XML_E_MISSINGQUOTE	= XML_E_MISSINGEQUALS + 1,
	XML_E_COMMENTSYNTAX	= XML_E_MISSINGQUOTE + 1,
	XML_E_BADSTARTNAMECHAR	= XML_E_COMMENTSYNTAX + 1,
	XML_E_BADNAMECHAR	= XML_E_BADSTARTNAMECHAR + 1,
	XML_E_BADCHARINSTRING	= XML_E_BADNAMECHAR + 1,
	XML_E_XMLDECLSYNTAX	= XML_E_BADCHARINSTRING + 1,
	XML_E_BADCHARDATA	= XML_E_XMLDECLSYNTAX + 1,
	XML_E_MISSINGWHITESPACE	= XML_E_BADCHARDATA + 1,
	XML_E_EXPECTINGTAGEND	= XML_E_MISSINGWHITESPACE + 1,
	XML_E_BADCHARINDTD	= XML_E_EXPECTINGTAGEND + 1,
	XML_E_BADCHARINDECL	= XML_E_BADCHARINDTD + 1,
	XML_E_MISSINGSEMICOLON	= XML_E_BADCHARINDECL + 1,
	XML_E_BADCHARINENTREF	= XML_E_MISSINGSEMICOLON + 1,
	XML_E_UNBALANCEDPAREN	= XML_E_BADCHARINENTREF + 1,
	XML_E_EXPECTINGOPENBRACKET	= XML_E_UNBALANCEDPAREN + 1,
	XML_E_BADENDCONDSECT	= XML_E_EXPECTINGOPENBRACKET + 1,
	XML_E_INTERNALERROR	= XML_E_BADENDCONDSECT + 1,
	XML_E_UNEXPECTED_WHITESPACE	= XML_E_INTERNALERROR + 1,
	XML_E_INCOMPLETE_ENCODING	= XML_E_UNEXPECTED_WHITESPACE + 1,
	XML_E_BADCHARINMIXEDMODEL	= XML_E_INCOMPLETE_ENCODING + 1,
	XML_E_MISSING_STAR	= XML_E_BADCHARINMIXEDMODEL + 1,
	XML_E_BADCHARINMODEL	= XML_E_MISSING_STAR + 1,
	XML_E_MISSING_PAREN	= XML_E_BADCHARINMODEL + 1,
	XML_E_BADCHARINENUMERATION	= XML_E_MISSING_PAREN + 1,
	XML_E_PIDECLSYNTAX	= XML_E_BADCHARINENUMERATION + 1,
	XML_E_EXPECTINGCLOSEQUOTE	= XML_E_PIDECLSYNTAX + 1,
	XML_E_MULTIPLE_COLONS	= XML_E_EXPECTINGCLOSEQUOTE + 1,
	XML_E_INVALID_DECIMAL	= XML_E_MULTIPLE_COLONS + 1,
	XML_E_INVALID_HEXIDECIMAL	= XML_E_INVALID_DECIMAL + 1,
	XML_E_INVALID_UNICODE	= XML_E_INVALID_HEXIDECIMAL + 1,
	XML_E_WHITESPACEORQUESTIONMARK	= XML_E_INVALID_UNICODE + 1,
	XML_E_TOKEN_ERROR	= XML_E_PARSEERRORBASE + 0x50,
	XML_E_SUSPENDED	= XML_E_TOKEN_ERROR,
	XML_E_STOPPED	= XML_E_SUSPENDED + 1,
	XML_E_UNEXPECTEDENDTAG	= XML_E_STOPPED + 1,
	XML_E_UNCLOSEDTAG	= XML_E_UNEXPECTEDENDTAG + 1,
	XML_E_DUPLICATEATTRIBUTE	= XML_E_UNCLOSEDTAG + 1,
	XML_E_MULTIPLEROOTS	= XML_E_DUPLICATEATTRIBUTE + 1,
	XML_E_INVALIDATROOTLEVEL	= XML_E_MULTIPLEROOTS + 1,
	XML_E_BADXMLDECL	= XML_E_INVALIDATROOTLEVEL + 1,
	XML_E_MISSINGROOT	= XML_E_BADXMLDECL + 1,
	XML_E_UNEXPECTEDEOF	= XML_E_MISSINGROOT + 1,
	XML_E_BADPEREFINSUBSET	= XML_E_UNEXPECTEDEOF + 1,
	XML_E_PE_NESTING	= XML_E_BADPEREFINSUBSET + 1,
	XML_E_INVALID_CDATACLOSINGTAG	= XML_E_PE_NESTING + 1,
	XML_E_UNCLOSEDPI	= XML_E_INVALID_CDATACLOSINGTAG + 1,
	XML_E_UNCLOSEDSTARTTAG	= XML_E_UNCLOSEDPI + 1,
	XML_E_UNCLOSEDENDTAG	= XML_E_UNCLOSEDSTARTTAG + 1,
	XML_E_UNCLOSEDSTRING	= XML_E_UNCLOSEDENDTAG + 1,
	XML_E_UNCLOSEDCOMMENT	= XML_E_UNCLOSEDSTRING + 1,
	XML_E_UNCLOSEDDECL	= XML_E_UNCLOSEDCOMMENT + 1,
	XML_E_UNCLOSEDMARKUPDECL	= XML_E_UNCLOSEDDECL + 1,
	XML_E_UNCLOSEDCDATA	= XML_E_UNCLOSEDMARKUPDECL + 1,
	XML_E_BADDECLNAME	= XML_E_UNCLOSEDCDATA + 1,
	XML_E_BADEXTERNALID	= XML_E_BADDECLNAME + 1,
	XML_E_BADELEMENTINDTD	= XML_E_BADEXTERNALID + 1,
	XML_E_RESERVEDNAMESPACE	= XML_E_BADELEMENTINDTD + 1,
	XML_E_EXPECTING_VERSION	= XML_E_RESERVEDNAMESPACE + 1,
	XML_E_EXPECTING_ENCODING	= XML_E_EXPECTING_VERSION + 1,
	XML_E_EXPECTING_NAME	= XML_E_EXPECTING_ENCODING + 1,
	XML_E_UNEXPECTED_ATTRIBUTE	= XML_E_EXPECTING_NAME + 1,
	XML_E_ENDTAGMISMATCH	= XML_E_UNEXPECTED_ATTRIBUTE + 1,
	XML_E_INVALIDENCODING	= XML_E_ENDTAGMISMATCH + 1,
	XML_E_INVALIDSWITCH	= XML_E_INVALIDENCODING + 1,
	XML_E_EXPECTING_NDATA	= XML_E_INVALIDSWITCH + 1,
	XML_E_INVALID_MODEL	= XML_E_EXPECTING_NDATA + 1,
	XML_E_INVALID_TYPE	= XML_E_INVALID_MODEL + 1,
	XML_E_INVALIDXMLSPACE	= XML_E_INVALID_TYPE + 1,
	XML_E_MULTI_ATTR_VALUE	= XML_E_INVALIDXMLSPACE + 1,
	XML_E_INVALID_PRESENCE	= XML_E_MULTI_ATTR_VALUE + 1,
	XML_E_BADXMLCASE	= XML_E_INVALID_PRESENCE + 1,
	XML_E_CONDSECTINSUBSET	= XML_E_BADXMLCASE + 1,
	XML_E_CDATAINVALID	= XML_E_CONDSECTINSUBSET + 1,
	XML_E_INVALID_STANDALONE	= XML_E_CDATAINVALID + 1,
	XML_E_UNEXPECTED_STANDALONE	= XML_E_INVALID_STANDALONE + 1,
	XML_E_DOCTYPE_IN_DTD	= XML_E_UNEXPECTED_STANDALONE + 1,
	XML_E_MISSING_ENTITY	= XML_E_DOCTYPE_IN_DTD + 1,
	XML_E_ENTITYREF_INNAME	= XML_E_MISSING_ENTITY + 1,
	XML_E_DOCTYPE_OUTSIDE_PROLOG	= XML_E_ENTITYREF_INNAME + 1,
	XML_E_INVALID_VERSION	= XML_E_DOCTYPE_OUTSIDE_PROLOG + 1,
	XML_E_DTDELEMENT_OUTSIDE_DTD	= XML_E_INVALID_VERSION + 1,
	XML_E_DUPLICATEDOCTYPE	= XML_E_DTDELEMENT_OUTSIDE_DTD + 1,
	XML_E_RESOURCE	= XML_E_DUPLICATEDOCTYPE + 1,
	XML_E_LASTERROR	= XML_E_RESOURCE + 1
    } 	XML_ERROR_CODE;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_xmlparser_0000_0004
    {	XMLPARSER_IDLE	= 0,
	XMLPARSER_WAITING	= XMLPARSER_IDLE + 1,
	XMLPARSER_BUSY	= XMLPARSER_WAITING + 1,
	XMLPARSER_ERROR	= XMLPARSER_BUSY + 1,
	XMLPARSER_STOPPED	= XMLPARSER_ERROR + 1,
	XMLPARSER_SUSPENDED	= XMLPARSER_STOPPED + 1
    } 	XML_PARSER_STATE;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_xmlparser_0000_0005
    {	XMLFLAG_FLOATINGAMP	= 1,
	XMLFLAG_SHORTENDTAGS	= 2,
	XMLFLAG_CASEINSENSITIVE	= 4,
	XMLFLAG_NONAMESPACES	= 8,
	XMLFLAG_NOWHITESPACE	= 16,
	XMLFLAG_IE4QUIRKS	= 32,
	XMLFLAG_NODTDNODES	= 64,
	XMLFLAG_IE4COMPATIBILITY	= 255
    } 	XML_PARSER_FLAGS;

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_xmlparser_0000_0006
    {	XMLNF_STARTDOCUMENT	= 0,
	XMLNF_STARTDTD	= XMLNF_STARTDOCUMENT + 1,
	XMLNF_ENDDTD	= XMLNF_STARTDTD + 1,
	XMLNF_STARTDTDSUBSET	= XMLNF_ENDDTD + 1,
	XMLNF_ENDDTDSUBSET	= XMLNF_STARTDTDSUBSET + 1,
	XMLNF_ENDPROLOG	= XMLNF_ENDDTDSUBSET + 1,
	XMLNF_STARTENTITY	= XMLNF_ENDPROLOG + 1,
	XMLNF_ENDENTITY	= XMLNF_STARTENTITY + 1,
	XMLNF_ENDDOCUMENT	= XMLNF_ENDENTITY + 1,
	XMLNF_DATAAVAILABLE	= XMLNF_ENDDOCUMENT + 1,
	XMLNF_LASTEVENT	= XMLNF_DATAAVAILABLE
    } 	XML_NODEFACTORY_EVENT;

typedef struct _XML_NODE_INFO
    {
    DWORD dwSize;
    DWORD dwType;
    DWORD dwSubType;
    BOOL fTerminal;
    const WCHAR __RPC_FAR *pwcText;
    ULONG ulLen;
    ULONG ulNsPrefixLen;
    PVOID pNode;
    PVOID pReserved;
    } 	XML_NODE_INFO;



extern RPC_IF_HANDLE __MIDL_itf_xmlparser_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_xmlparser_0000_v0_0_s_ifspec;


#ifndef __XMLPSR_LIBRARY_DEFINED__
#define __XMLPSR_LIBRARY_DEFINED__

/* library XMLPSR */
/* [version][lcid][helpstring][uuid] */ 


EXTERN_C const IID LIBID_XMLPSR;

#ifndef __IXMLNodeSource_INTERFACE_DEFINED__
#define __IXMLNodeSource_INTERFACE_DEFINED__

/* interface IXMLNodeSource */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IXMLNodeSource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d242361d-51a0-11d2-9caf-0060b0ec3d39")
    IXMLNodeSource : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFactory( 
            /* [in] */ IXMLNodeFactory __RPC_FAR *pNodeFactory) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFactory( 
            /* [out] */ IXMLNodeFactory __RPC_FAR *__RPC_FAR *ppNodeFactory) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Abort( 
            /* [in] */ BSTR bstrErrorInfo) = 0;
        
        virtual ULONG STDMETHODCALLTYPE GetLineNumber( void) = 0;
        
        virtual ULONG STDMETHODCALLTYPE GetLinePosition( void) = 0;
        
        virtual ULONG STDMETHODCALLTYPE GetAbsolutePosition( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLineBuffer( 
            /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf,
            /* [out] */ ULONG __RPC_FAR *pulLen,
            /* [out] */ ULONG __RPC_FAR *pulStartPos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLastError( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetErrorInfo( 
            /* [out] */ BSTR __RPC_FAR *pbstrErrorInfo) = 0;
        
        virtual ULONG STDMETHODCALLTYPE GetFlags( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetURL( 
            /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLNodeSourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLNodeSource __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLNodeSource __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLNodeSource __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFactory )( 
            IXMLNodeSource __RPC_FAR * This,
            /* [in] */ IXMLNodeFactory __RPC_FAR *pNodeFactory);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFactory )( 
            IXMLNodeSource __RPC_FAR * This,
            /* [out] */ IXMLNodeFactory __RPC_FAR *__RPC_FAR *ppNodeFactory);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Abort )( 
            IXMLNodeSource __RPC_FAR * This,
            /* [in] */ BSTR bstrErrorInfo);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *GetLineNumber )( 
            IXMLNodeSource __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *GetLinePosition )( 
            IXMLNodeSource __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *GetAbsolutePosition )( 
            IXMLNodeSource __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLineBuffer )( 
            IXMLNodeSource __RPC_FAR * This,
            /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf,
            /* [out] */ ULONG __RPC_FAR *pulLen,
            /* [out] */ ULONG __RPC_FAR *pulStartPos);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLastError )( 
            IXMLNodeSource __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetErrorInfo )( 
            IXMLNodeSource __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrErrorInfo);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *GetFlags )( 
            IXMLNodeSource __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetURL )( 
            IXMLNodeSource __RPC_FAR * This,
            /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf);
        
        END_INTERFACE
    } IXMLNodeSourceVtbl;

    interface IXMLNodeSource
    {
        CONST_VTBL struct IXMLNodeSourceVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLNodeSource_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLNodeSource_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLNodeSource_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLNodeSource_SetFactory(This,pNodeFactory)	\
    (This)->lpVtbl -> SetFactory(This,pNodeFactory)

#define IXMLNodeSource_GetFactory(This,ppNodeFactory)	\
    (This)->lpVtbl -> GetFactory(This,ppNodeFactory)

#define IXMLNodeSource_Abort(This,bstrErrorInfo)	\
    (This)->lpVtbl -> Abort(This,bstrErrorInfo)

#define IXMLNodeSource_GetLineNumber(This)	\
    (This)->lpVtbl -> GetLineNumber(This)

#define IXMLNodeSource_GetLinePosition(This)	\
    (This)->lpVtbl -> GetLinePosition(This)

#define IXMLNodeSource_GetAbsolutePosition(This)	\
    (This)->lpVtbl -> GetAbsolutePosition(This)

#define IXMLNodeSource_GetLineBuffer(This,ppwcBuf,pulLen,pulStartPos)	\
    (This)->lpVtbl -> GetLineBuffer(This,ppwcBuf,pulLen,pulStartPos)

#define IXMLNodeSource_GetLastError(This)	\
    (This)->lpVtbl -> GetLastError(This)

#define IXMLNodeSource_GetErrorInfo(This,pbstrErrorInfo)	\
    (This)->lpVtbl -> GetErrorInfo(This,pbstrErrorInfo)

#define IXMLNodeSource_GetFlags(This)	\
    (This)->lpVtbl -> GetFlags(This)

#define IXMLNodeSource_GetURL(This,ppwcBuf)	\
    (This)->lpVtbl -> GetURL(This,ppwcBuf)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IXMLNodeSource_SetFactory_Proxy( 
    IXMLNodeSource __RPC_FAR * This,
    /* [in] */ IXMLNodeFactory __RPC_FAR *pNodeFactory);


void __RPC_STUB IXMLNodeSource_SetFactory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeSource_GetFactory_Proxy( 
    IXMLNodeSource __RPC_FAR * This,
    /* [out] */ IXMLNodeFactory __RPC_FAR *__RPC_FAR *ppNodeFactory);


void __RPC_STUB IXMLNodeSource_GetFactory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeSource_Abort_Proxy( 
    IXMLNodeSource __RPC_FAR * This,
    /* [in] */ BSTR bstrErrorInfo);


void __RPC_STUB IXMLNodeSource_Abort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG STDMETHODCALLTYPE IXMLNodeSource_GetLineNumber_Proxy( 
    IXMLNodeSource __RPC_FAR * This);


void __RPC_STUB IXMLNodeSource_GetLineNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG STDMETHODCALLTYPE IXMLNodeSource_GetLinePosition_Proxy( 
    IXMLNodeSource __RPC_FAR * This);


void __RPC_STUB IXMLNodeSource_GetLinePosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG STDMETHODCALLTYPE IXMLNodeSource_GetAbsolutePosition_Proxy( 
    IXMLNodeSource __RPC_FAR * This);


void __RPC_STUB IXMLNodeSource_GetAbsolutePosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeSource_GetLineBuffer_Proxy( 
    IXMLNodeSource __RPC_FAR * This,
    /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf,
    /* [out] */ ULONG __RPC_FAR *pulLen,
    /* [out] */ ULONG __RPC_FAR *pulStartPos);


void __RPC_STUB IXMLNodeSource_GetLineBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeSource_GetLastError_Proxy( 
    IXMLNodeSource __RPC_FAR * This);


void __RPC_STUB IXMLNodeSource_GetLastError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeSource_GetErrorInfo_Proxy( 
    IXMLNodeSource __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrErrorInfo);


void __RPC_STUB IXMLNodeSource_GetErrorInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG STDMETHODCALLTYPE IXMLNodeSource_GetFlags_Proxy( 
    IXMLNodeSource __RPC_FAR * This);


void __RPC_STUB IXMLNodeSource_GetFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeSource_GetURL_Proxy( 
    IXMLNodeSource __RPC_FAR * This,
    /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf);


void __RPC_STUB IXMLNodeSource_GetURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLNodeSource_INTERFACE_DEFINED__ */


#ifndef __IXMLParser_INTERFACE_DEFINED__
#define __IXMLParser_INTERFACE_DEFINED__

/* interface IXMLParser */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IXMLParser;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d242361e-51a0-11d2-9caf-0060b0ec3d39")
    IXMLParser : public IXMLNodeSource
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetURL( 
            /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl,
            /* [in] */ const WCHAR __RPC_FAR *pszRelativeUrl,
            /* [in] */ BOOL fAsync) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Load( 
            /* [in] */ BOOL fFullyAvailable,
            /* [in] */ IMoniker __RPC_FAR *pimkName,
            /* [in] */ LPBC pibc,
            /* [in] */ DWORD grfMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetInput( 
            /* [in] */ IUnknown __RPC_FAR *pStm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PushData( 
            /* [in] */ const char __RPC_FAR *pData,
            /* [in] */ ULONG ulChars,
            /* [in] */ BOOL fLastBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadDTD( 
            /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl,
            /* [in] */ const WCHAR __RPC_FAR *pszRelativeUrl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadEntity( 
            /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl,
            /* [in] */ const WCHAR __RPC_FAR *pszRelativeUrl,
            /* [in] */ BOOL fpe) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ParseEntity( 
            /* [in] */ const WCHAR __RPC_FAR *pwcText,
            /* [in] */ ULONG ulLen,
            /* [in] */ BOOL fpe) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExpandEntity( 
            /* [in] */ const WCHAR __RPC_FAR *pwcText,
            /* [in] */ ULONG ulLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRoot( 
            /* [in] */ PVOID pRoot) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRoot( 
            /* [in] */ PVOID __RPC_FAR *ppRoot) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Run( 
            /* [in] */ long lChars) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParserState( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Suspend( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFlags( 
            /* [in] */ ULONG iFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSecureBaseURL( 
            /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSecureBaseURL( 
            /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLParserVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLParser __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLParser __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFactory )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ IXMLNodeFactory __RPC_FAR *pNodeFactory);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFactory )( 
            IXMLParser __RPC_FAR * This,
            /* [out] */ IXMLNodeFactory __RPC_FAR *__RPC_FAR *ppNodeFactory);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Abort )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ BSTR bstrErrorInfo);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *GetLineNumber )( 
            IXMLParser __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *GetLinePosition )( 
            IXMLParser __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *GetAbsolutePosition )( 
            IXMLParser __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLineBuffer )( 
            IXMLParser __RPC_FAR * This,
            /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf,
            /* [out] */ ULONG __RPC_FAR *pulLen,
            /* [out] */ ULONG __RPC_FAR *pulStartPos);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLastError )( 
            IXMLParser __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetErrorInfo )( 
            IXMLParser __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrErrorInfo);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *GetFlags )( 
            IXMLParser __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetURL )( 
            IXMLParser __RPC_FAR * This,
            /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetURL )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl,
            /* [in] */ const WCHAR __RPC_FAR *pszRelativeUrl,
            /* [in] */ BOOL fAsync);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Load )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ BOOL fFullyAvailable,
            /* [in] */ IMoniker __RPC_FAR *pimkName,
            /* [in] */ LPBC pibc,
            /* [in] */ DWORD grfMode);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetInput )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pStm);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PushData )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ const char __RPC_FAR *pData,
            /* [in] */ ULONG ulChars,
            /* [in] */ BOOL fLastBuffer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadDTD )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl,
            /* [in] */ const WCHAR __RPC_FAR *pszRelativeUrl);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadEntity )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl,
            /* [in] */ const WCHAR __RPC_FAR *pszRelativeUrl,
            /* [in] */ BOOL fpe);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ParseEntity )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwcText,
            /* [in] */ ULONG ulLen,
            /* [in] */ BOOL fpe);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExpandEntity )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwcText,
            /* [in] */ ULONG ulLen);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRoot )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ PVOID pRoot);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRoot )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ PVOID __RPC_FAR *ppRoot);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Run )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ long lChars);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetParserState )( 
            IXMLParser __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Suspend )( 
            IXMLParser __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IXMLParser __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFlags )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ ULONG iFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSecureBaseURL )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSecureBaseURL )( 
            IXMLParser __RPC_FAR * This,
            /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf);
        
        END_INTERFACE
    } IXMLParserVtbl;

    interface IXMLParser
    {
        CONST_VTBL struct IXMLParserVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLParser_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLParser_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLParser_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLParser_SetFactory(This,pNodeFactory)	\
    (This)->lpVtbl -> SetFactory(This,pNodeFactory)

#define IXMLParser_GetFactory(This,ppNodeFactory)	\
    (This)->lpVtbl -> GetFactory(This,ppNodeFactory)

#define IXMLParser_Abort(This,bstrErrorInfo)	\
    (This)->lpVtbl -> Abort(This,bstrErrorInfo)

#define IXMLParser_GetLineNumber(This)	\
    (This)->lpVtbl -> GetLineNumber(This)

#define IXMLParser_GetLinePosition(This)	\
    (This)->lpVtbl -> GetLinePosition(This)

#define IXMLParser_GetAbsolutePosition(This)	\
    (This)->lpVtbl -> GetAbsolutePosition(This)

#define IXMLParser_GetLineBuffer(This,ppwcBuf,pulLen,pulStartPos)	\
    (This)->lpVtbl -> GetLineBuffer(This,ppwcBuf,pulLen,pulStartPos)

#define IXMLParser_GetLastError(This)	\
    (This)->lpVtbl -> GetLastError(This)

#define IXMLParser_GetErrorInfo(This,pbstrErrorInfo)	\
    (This)->lpVtbl -> GetErrorInfo(This,pbstrErrorInfo)

#define IXMLParser_GetFlags(This)	\
    (This)->lpVtbl -> GetFlags(This)

#define IXMLParser_GetURL(This,ppwcBuf)	\
    (This)->lpVtbl -> GetURL(This,ppwcBuf)


#define IXMLParser_SetURL(This,pszBaseUrl,pszRelativeUrl,fAsync)	\
    (This)->lpVtbl -> SetURL(This,pszBaseUrl,pszRelativeUrl,fAsync)

#define IXMLParser_Load(This,fFullyAvailable,pimkName,pibc,grfMode)	\
    (This)->lpVtbl -> Load(This,fFullyAvailable,pimkName,pibc,grfMode)

#define IXMLParser_SetInput(This,pStm)	\
    (This)->lpVtbl -> SetInput(This,pStm)

#define IXMLParser_PushData(This,pData,ulChars,fLastBuffer)	\
    (This)->lpVtbl -> PushData(This,pData,ulChars,fLastBuffer)

#define IXMLParser_LoadDTD(This,pszBaseUrl,pszRelativeUrl)	\
    (This)->lpVtbl -> LoadDTD(This,pszBaseUrl,pszRelativeUrl)

#define IXMLParser_LoadEntity(This,pszBaseUrl,pszRelativeUrl,fpe)	\
    (This)->lpVtbl -> LoadEntity(This,pszBaseUrl,pszRelativeUrl,fpe)

#define IXMLParser_ParseEntity(This,pwcText,ulLen,fpe)	\
    (This)->lpVtbl -> ParseEntity(This,pwcText,ulLen,fpe)

#define IXMLParser_ExpandEntity(This,pwcText,ulLen)	\
    (This)->lpVtbl -> ExpandEntity(This,pwcText,ulLen)

#define IXMLParser_SetRoot(This,pRoot)	\
    (This)->lpVtbl -> SetRoot(This,pRoot)

#define IXMLParser_GetRoot(This,ppRoot)	\
    (This)->lpVtbl -> GetRoot(This,ppRoot)

#define IXMLParser_Run(This,lChars)	\
    (This)->lpVtbl -> Run(This,lChars)

#define IXMLParser_GetParserState(This)	\
    (This)->lpVtbl -> GetParserState(This)

#define IXMLParser_Suspend(This)	\
    (This)->lpVtbl -> Suspend(This)

#define IXMLParser_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IXMLParser_SetFlags(This,iFlags)	\
    (This)->lpVtbl -> SetFlags(This,iFlags)

#define IXMLParser_SetSecureBaseURL(This,pszBaseUrl)	\
    (This)->lpVtbl -> SetSecureBaseURL(This,pszBaseUrl)

#define IXMLParser_GetSecureBaseURL(This,ppwcBuf)	\
    (This)->lpVtbl -> GetSecureBaseURL(This,ppwcBuf)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IXMLParser_SetURL_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl,
    /* [in] */ const WCHAR __RPC_FAR *pszRelativeUrl,
    /* [in] */ BOOL fAsync);


void __RPC_STUB IXMLParser_SetURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_Load_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ BOOL fFullyAvailable,
    /* [in] */ IMoniker __RPC_FAR *pimkName,
    /* [in] */ LPBC pibc,
    /* [in] */ DWORD grfMode);


void __RPC_STUB IXMLParser_Load_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_SetInput_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pStm);


void __RPC_STUB IXMLParser_SetInput_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_PushData_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ const char __RPC_FAR *pData,
    /* [in] */ ULONG ulChars,
    /* [in] */ BOOL fLastBuffer);


void __RPC_STUB IXMLParser_PushData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_LoadDTD_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl,
    /* [in] */ const WCHAR __RPC_FAR *pszRelativeUrl);


void __RPC_STUB IXMLParser_LoadDTD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_LoadEntity_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl,
    /* [in] */ const WCHAR __RPC_FAR *pszRelativeUrl,
    /* [in] */ BOOL fpe);


void __RPC_STUB IXMLParser_LoadEntity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_ParseEntity_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pwcText,
    /* [in] */ ULONG ulLen,
    /* [in] */ BOOL fpe);


void __RPC_STUB IXMLParser_ParseEntity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_ExpandEntity_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pwcText,
    /* [in] */ ULONG ulLen);


void __RPC_STUB IXMLParser_ExpandEntity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_SetRoot_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ PVOID pRoot);


void __RPC_STUB IXMLParser_SetRoot_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_GetRoot_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ PVOID __RPC_FAR *ppRoot);


void __RPC_STUB IXMLParser_GetRoot_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_Run_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ long lChars);


void __RPC_STUB IXMLParser_Run_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_GetParserState_Proxy( 
    IXMLParser __RPC_FAR * This);


void __RPC_STUB IXMLParser_GetParserState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_Suspend_Proxy( 
    IXMLParser __RPC_FAR * This);


void __RPC_STUB IXMLParser_Suspend_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_Reset_Proxy( 
    IXMLParser __RPC_FAR * This);


void __RPC_STUB IXMLParser_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_SetFlags_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ ULONG iFlags);


void __RPC_STUB IXMLParser_SetFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_SetSecureBaseURL_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl);


void __RPC_STUB IXMLParser_SetSecureBaseURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_GetSecureBaseURL_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf);


void __RPC_STUB IXMLParser_GetSecureBaseURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLParser_INTERFACE_DEFINED__ */


#ifndef __IXMLNodeFactory_INTERFACE_DEFINED__
#define __IXMLNodeFactory_INTERFACE_DEFINED__

/* interface IXMLNodeFactory */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IXMLNodeFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d242361f-51a0-11d2-9caf-0060b0ec3d39")
    IXMLNodeFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE NotifyEvent( 
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ XML_NODEFACTORY_EVENT iEvt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginChildren( 
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ XML_NODE_INFO __RPC_FAR *pNodeInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndChildren( 
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ BOOL fEmpty,
            /* [in] */ XML_NODE_INFO __RPC_FAR *pNodeInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Error( 
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ HRESULT hrErrorCode,
            /* [in] */ USHORT cNumRecs,
            /* [in] */ XML_NODE_INFO __RPC_FAR *__RPC_FAR *apNodeInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateNode( 
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ PVOID pNodeParent,
            /* [in] */ USHORT cNumRecs,
            /* [in] */ XML_NODE_INFO __RPC_FAR *__RPC_FAR *apNodeInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLNodeFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLNodeFactory __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLNodeFactory __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLNodeFactory __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NotifyEvent )( 
            IXMLNodeFactory __RPC_FAR * This,
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ XML_NODEFACTORY_EVENT iEvt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginChildren )( 
            IXMLNodeFactory __RPC_FAR * This,
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ XML_NODE_INFO __RPC_FAR *pNodeInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndChildren )( 
            IXMLNodeFactory __RPC_FAR * This,
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ BOOL fEmpty,
            /* [in] */ XML_NODE_INFO __RPC_FAR *pNodeInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Error )( 
            IXMLNodeFactory __RPC_FAR * This,
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ HRESULT hrErrorCode,
            /* [in] */ USHORT cNumRecs,
            /* [in] */ XML_NODE_INFO __RPC_FAR *__RPC_FAR *apNodeInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateNode )( 
            IXMLNodeFactory __RPC_FAR * This,
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ PVOID pNodeParent,
            /* [in] */ USHORT cNumRecs,
            /* [in] */ XML_NODE_INFO __RPC_FAR *__RPC_FAR *apNodeInfo);
        
        END_INTERFACE
    } IXMLNodeFactoryVtbl;

    interface IXMLNodeFactory
    {
        CONST_VTBL struct IXMLNodeFactoryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLNodeFactory_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLNodeFactory_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLNodeFactory_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLNodeFactory_NotifyEvent(This,pSource,iEvt)	\
    (This)->lpVtbl -> NotifyEvent(This,pSource,iEvt)

#define IXMLNodeFactory_BeginChildren(This,pSource,pNodeInfo)	\
    (This)->lpVtbl -> BeginChildren(This,pSource,pNodeInfo)

#define IXMLNodeFactory_EndChildren(This,pSource,fEmpty,pNodeInfo)	\
    (This)->lpVtbl -> EndChildren(This,pSource,fEmpty,pNodeInfo)

#define IXMLNodeFactory_Error(This,pSource,hrErrorCode,cNumRecs,apNodeInfo)	\
    (This)->lpVtbl -> Error(This,pSource,hrErrorCode,cNumRecs,apNodeInfo)

#define IXMLNodeFactory_CreateNode(This,pSource,pNodeParent,cNumRecs,apNodeInfo)	\
    (This)->lpVtbl -> CreateNode(This,pSource,pNodeParent,cNumRecs,apNodeInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IXMLNodeFactory_NotifyEvent_Proxy( 
    IXMLNodeFactory __RPC_FAR * This,
    /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
    /* [in] */ XML_NODEFACTORY_EVENT iEvt);


void __RPC_STUB IXMLNodeFactory_NotifyEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeFactory_BeginChildren_Proxy( 
    IXMLNodeFactory __RPC_FAR * This,
    /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
    /* [in] */ XML_NODE_INFO __RPC_FAR *pNodeInfo);


void __RPC_STUB IXMLNodeFactory_BeginChildren_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeFactory_EndChildren_Proxy( 
    IXMLNodeFactory __RPC_FAR * This,
    /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
    /* [in] */ BOOL fEmpty,
    /* [in] */ XML_NODE_INFO __RPC_FAR *pNodeInfo);


void __RPC_STUB IXMLNodeFactory_EndChildren_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeFactory_Error_Proxy( 
    IXMLNodeFactory __RPC_FAR * This,
    /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
    /* [in] */ HRESULT hrErrorCode,
    /* [in] */ USHORT cNumRecs,
    /* [in] */ XML_NODE_INFO __RPC_FAR *__RPC_FAR *apNodeInfo);


void __RPC_STUB IXMLNodeFactory_Error_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeFactory_CreateNode_Proxy( 
    IXMLNodeFactory __RPC_FAR * This,
    /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
    /* [in] */ PVOID pNodeParent,
    /* [in] */ USHORT cNumRecs,
    /* [in] */ XML_NODE_INFO __RPC_FAR *__RPC_FAR *apNodeInfo);


void __RPC_STUB IXMLNodeFactory_CreateNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLNodeFactory_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_XMLParser;

#ifdef __cplusplus

class DECLSPEC_UUID("d2423620-51a0-11d2-9caf-0060b0ec3d39")
XMLParser;
#endif
#endif /* __XMLPSR_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\wsperf.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//-----------------------------------------------------------------------------
// WSPerf.h
// This is the internal interface for collecting and logging dynamic data
// allocations and deallocations. There is two kinds of data collected
// summary and detailed. Summary data gives a summary of of allocations made
// from various heaps (e.g. Highfrequency, Low frequency heap etc.). Summary 
// data also includes number of common data structures allocated e.g. MethodDescs
// etc.
//-----------------------------------------------------------------------------

#ifndef __WSPERF_H__
#define __WSPERF_H__


//-----------------------------------------------------------------------------
// Feature level #define. Disabling this should make the entire WS perf related code 
// compile away.
#if !defined(GOLDEN)
#define ENABLE_WORKING_SET_PERF
#else
#undef  ENABLE_WORKING_SET_PERF
#endif // #if !defined(GOLDEN)

//-----------------------------------------------------------------------------
// Enum for heap types. Note that this is visible in the free and GOLDEN builds. All code that 
// uses it gets reduced to null code if WS_PERFis not defined.
typedef enum {
    OTHER_HEAP = 0,
    HIGH_FREQ_HEAP,
    LOW_FREQ_HEAP,
    LOOKUP_TABLE_HEAP,
    GC_HEAP,
    GCHANDLE_HEAP,
    JIT_HEAP,
    EEJIT_HEAP,
    EEJITMETA_HEAP,
    ECONO_JIT_HEAP,
    SCRATCH_HEAP,
    REFLECT_HEAP,
    SECURITY_HEAP,
    SYSTEM_HEAP,
    STUB_HEAP,
    REMOTING_HEAP,
    METADATA_HEAPS,
    NLS_HEAP,
    INTERFACE_VTABLEMAP_HEAP,
    NUM_HEAP
} HeapTypeEnum;

//-----------------------------------------------------------------------------
// Enum for data structures types. Note that this is visible in the free builds. 
typedef enum {
    METHOD_DESC = 0,    
    COMPLUS_METHOD_DESC,
    NDIRECT_METHOD_DESC,
    FIELD_DESC,
    METHOD_TABLE,
    VTABLES, 
    GCINFO,
    INTERFACE_MAPS,
    STATIC_FIELDS,
    EECLASSHASH_TABLE_BYTES,
    EECLASSHASH_TABLE,
    NUM_COUNTERS 
} CounterTypeEnum;

#if defined(ENABLE_WORKING_SET_PERF)

#ifdef WS_PERF_DETAIL
#ifndef WS_PERF
#pragma message ("WARNING! WS_PERF must be defined with WS_PERF_DETAIL. Defining WS_PERF now ...")
#define WS_PERF
#endif //#ifndef WS_PERF
#endif // WS_PERF_DETAIL

//-----------------------------------------------------------------------------
// WS_PERF is the define which collects and displays working set stats. This code 
// is enabled in private builds with WS_PERF defined only.
#ifdef WS_PERF

// Global counters
extern DWORD g_HeapCount;
extern size_t g_HeapCountCommit[];
extern HeapTypeEnum g_HeapType;
extern int g_fWSPerfOn;
extern size_t g_HeapAccounts[][4];

// WS_PERF_DETAIL is a macro which makes sense only if WS_PERF is defined.
#ifdef WS_PERF_DETAIL
extern HANDLE g_hWSPerfDetailLogFile;
#endif // #ifdef WS_PERF_DETAIL

#endif // #ifdef WS_PERF


// Public interface which can be used by the VM routines.
void InitWSPerf();
void OutputWSPerfStats();
void WS_PERF_UPDATE(char *str, size_t size, void *addr);
void WS_PERF_UPDATE_DETAIL(char *str, size_t size, void *addr);
void WS_PERF_UPDATE_COUNTER(CounterTypeEnum counter, HeapTypeEnum heap, DWORD dwField1);
void WS_PERF_SET_HEAP(HeapTypeEnum heap);
void WS_PERF_ADD_HEAP(HeapTypeEnum heap, void *pHeap);
void WS_PERF_ALLOC_HEAP(void *pHeap, size_t dwSize);
void WS_PERF_COMMIT_HEAP(void *pHeap, size_t dwSize);
void WS_PERF_LOG_PAGE_RANGE(void *pHeap, void *pFirstPageAddr, void *pLastPageAddr, size_t dwsize);

#else
void InitWSPerf();
void OutputWSPerfStats();
void WS_PERF_UPDATE(char *str, size_t size, void *addr);
void WS_PERF_UPDATE_DETAIL(char *str, size_t size, void *addr);
void WS_PERF_UPDATE_COUNTER(CounterTypeEnum counter, HeapTypeEnum heap, DWORD dwField1);
void WS_PERF_SET_HEAP(HeapTypeEnum heap);
void WS_PERF_ADD_HEAP(HeapTypeEnum heap, void *pHeap);
void WS_PERF_ALLOC_HEAP(void *pHeap, size_t dwSize);
void WS_PERF_COMMIT_HEAP(void *pHeap, size_t dwSize);
void WS_PERF_LOG_PAGE_RANGE(void *pHeap, void *pFirstPageAddr, void *pLastPageAddr, size_t dwsize);

#endif // #if defined(ENABLE_WORKING_SET_PERF)

#endif // __WSPERF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\wsinfo.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef WSINFO_H_
#define WSINFO_H_

#include <hrex.h>
#include <cor.h>

class WSInfo
{
 public:

    ULONG   m_total;
    ULONG   m_cTypes;
    ULONG   *m_pTypeSizes;
    ULONG   m_cMethods;
    ULONG   *m_pMethodSizes;
    ULONG   m_cFields;
    ULONG   *m_pFieldSizes;

    IMetaDataImport *m_pImport;

    WSInfo(IMetaDataImport *pImport);
    ~WSInfo();

    void AdjustAllTypeSizes(LONG total);
    void AdjustTypeSize(mdTypeDef token, LONG size);
    void AdjustAllMethodSizes(LONG total);
    void AdjustMethodSize(mdMethodDef token, LONG size);
    void AdjustAllFieldSizes(LONG total);
    void AdjustFieldSize(mdFieldDef token, LONG size);

    void AdjustTokenSize(mdToken token, LONG size);

    ULONG GetTotalAttributedSize();
};


#endif WSINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\__mscoree_file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "mscoree.tlb"
#define VER_FILEDESCRIPTION_STR "Microsoft .NET Runtime Common Language Runtime\0"
#define VER_ORIGFILENAME_STR    "mscoree.tlb\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\version\clrcver.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS		VS_FF_DEBUG
#else
#define VER_FILEFLAGS		VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE		VFT_DLL
#define VER_INTERNALNAME_STR	"CompLib.DLL"
#define VER_FILEDESCRIPTION_STR "Microsoft Component Library\0"
#define VER_ORIGFILENAME_STR    "CompLib.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\version\cldlver.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS		VS_FF_DEBUG
#else
#define VER_FILEFLAGS		VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE		VFT_DLL
#define VER_INTERNALNAME_STR	"Comprc.DLL"
#define VER_FILEDESCRIPTION_STR "Microsoft Component Library Resource DLL\0"
#define VER_ORIGFILENAME_STR    "Comprc.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\version\cordlver.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS		VS_FF_DEBUG
#else
#define VER_FILEFLAGS		VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE		VFT_DLL
#define VER_INTERNALNAME_STR	"COR.DLL"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\version\devtree\cldlver.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS		VS_FF_DEBUG
#else
#define VER_FILEFLAGS		VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE		VFT_DLL
#define VER_INTERNALNAME_STR	"Comprc.DLL"
#define VER_FILEDESCRIPTION_STR "Microsoft Component Library Resource DLL\0"
#define VER_ORIGFILENAME_STR    "Comprc.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\version\corver.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef TEXT
#if defined(UNICODE) || defined(_UNICODE)
#define TEXT(str) L##str
#else
#define TEXT(str) str
#endif
#endif

#define VER_COMPANYNAME_STR      TEXT("Microsoft Corporation\0")
#define VER_LEGALCOPYRIGHT_STR   TEXT("Copyright \251 Microsoft Corporation 1998-2002. All rights reserved.\0")
#define VER_LEGALTRADEMARKS_STR  TEXT("Microsoft\256 is a registered trademark of Microsoft Corporation. Windows(TM) is a trademark of Microsoft Corporation\0")
#define VER_LEGALCOPYRIGHT_DOS_STR   TEXT("Copyright (C) Microsoft Corporation 1998-2002. All rights reserved.\0")
#define VER_LEGALTRADEMARKS_DOS_STR  TEXT("Microsoft (R) is a registered trademark of Microsoft Corporation. Windows(TM) is a trademark of Microsoft Corporation\0")

#define VER_FILEFLAGSMASK        VS_FFI_FILEFLAGSMASK

#define VER_PRODUCTNAME_STR      TEXT("Microsoft .NET Framework\0")


// Windows Specific

#define VER_FILEOS               VOS__WINDOWS32


#if defined( MIPS) || defined(_MIPS_)
	#define VER_PLATFORMINFO_STR         TEXT("Windows NT (MIPS)\0")
#endif

#if defined(ALPHA) || defined(_ALPHA_)
	#define VER_PLATFORMINFO_STR         TEXT("Windows NT (ALPHA-AXP)\0")
#endif

#if defined(_PPC_) || defined(PPC)
	#define VER_PLATFORMINFO_STR         TEXT("Windows NT (POWER PC)\0")
#endif

#if defined(PLATFORM_CE)
#ifndef VER_PLATFORMINFO_STR
	#define VER_PLATFORMINFO_STR         TEXT("Windows CE (x86)\0")
#endif
#endif

// By default use Intel (_X86_)
#ifndef VER_PLATFORMINFO_STR
	#define VER_PLATFORMINFO_STR         TEXT("Windows 95 and Windows NT (I386)\0")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\version\devtree\clrcver.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS		VS_FF_DEBUG
#else
#define VER_FILEFLAGS		VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE		VFT_DLL
#define VER_INTERNALNAME_STR	"CompLib.DLL"
#define VER_FILEDESCRIPTION_STR "Microsoft Component Library\0"
#define VER_ORIGFILENAME_STR    "CompLib.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\version\devtree\cordlver.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS		VS_FF_DEBUG
#else
#define VER_FILEFLAGS		VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE		VFT_DLL
#define VER_INTERNALNAME_STR	"COR.DLL"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\inc\version\devtree\corver.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef TEXT
#if defined(UNICODE) || defined(_UNICODE)
#define TEXT(str) L##str
#else
#define TEXT(str) str
#endif
#endif

#define VER_COMPANYNAME_STR      TEXT("Microsoft Corporation\0")
#define VER_LEGALCOPYRIGHT_STR   TEXT("Copyright \251 Microsoft Corporation 1998-2002. All rights reserved.\0")
#define VER_LEGALTRADEMARKS_STR  TEXT("Microsoft\256 is a registered trademark of Microsoft Corporation. Windows(TM) is a trademark of Microsoft Corporation\0")
#define VER_LEGALCOPYRIGHT_DOS_STR   TEXT("Copyright (C) Microsoft Corporation 1998-2002. All rights reserved.\0")
#define VER_LEGALTRADEMARKS_DOS_STR  TEXT("Microsoft (R) is a registered trademark of Microsoft Corporation. Windows(TM) is a trademark of Microsoft Corporation\0")

#define VER_FILEFLAGSMASK        VS_FFI_FILEFLAGSMASK

#define VER_PRODUCTNAME_STR      TEXT("Microsoft .NET Framework\0")


// Windows Specific

#define VER_FILEOS               VOS__WINDOWS32


#if defined( MIPS) || defined(_MIPS_)
	#define VER_PLATFORMINFO_STR         TEXT("Windows NT (MIPS)\0")
#endif

#if defined(ALPHA) || defined(_ALPHA_)
	#define VER_PLATFORMINFO_STR         TEXT("Windows NT (ALPHA-AXP)\0")
#endif

#if defined(_PPC_) || defined(PPC)
	#define VER_PLATFORMINFO_STR         TEXT("Windows NT (POWER PC)\0")
#endif

#if defined(PLATFORM_CE)
#ifndef VER_PLATFORMINFO_STR
	#define VER_PLATFORMINFO_STR         TEXT("Windows CE (x86)\0")
#endif
#endif

// By default use Intel (_X86_)
#ifndef VER_PLATFORMINFO_STR
	#define VER_PLATFORMINFO_STR         TEXT("Windows 95 and Windows NT (I386)\0")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\ipcman\ipcfunccallimpl.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: IPCFuncCallImpl.cpp
//
// Implement support for a cross process function call. 
//
//*****************************************************************************

#include "StdAfx.h"
#include "IPCFuncCall.h"
#include "IPCShared.h"

#include "Timer.h"
// #define ENABLE_TIMING

#ifndef SM_REMOTESESSION
#define SM_REMOTESESSION 0x1000
#endif

#if defined(ENABLE_TIMING)

CTimer g_time;
#endif

//-----------------------------------------------------------------------------
// @todo: This is very generic. However, If we want to support multiple 
// functions calls, we will have to decorate the event object names.
//-----------------------------------------------------------------------------

// Name of sync objects
#define StartEnumEventName  L"CLR_PerfMon_StartEnumEvent"
#define DoneEnumEventName   L"CLR_PerfMon_DoneEnumEvent"
#define WrapMutexName       L"CLR_PerfMon_WrapMutex"

// Time the Source Caller is willing to wait for Handler to finish
// Note, a nefarious handler can at worst case make caller
// wait twice the delay below.
const DWORD START_ENUM_TIMEOUT = 500; // time out in milliseconds

//-----------------------------------------------------------------------------
// Wrap an unsafe call in a mutex to assure safety
// Biggest error issues are:
// 1. Timeout (probably handler doesn't exist)
// 2. Handler can be destroyed at any time.
//-----------------------------------------------------------------------------
IPCFuncCallSource::EError IPCFuncCallSource::DoThreadSafeCall()
{
    DWORD dwErr;
    EError err = Ok;

#if defined(ENABLE_TIMING)
    g_time.Reset();
    g_time.Start();
#endif

    HANDLE hStartEnum = NULL;
    HANDLE hDoneEnum = NULL;
    HANDLE hWrapCall = NULL;
    DWORD dwWaitRet;

    // Check if we have a handler (handler creates the events) and
    // abort if not.  Do this check asap to optimize the most common
    // case of no handler.
    if (RunningOnWinNT5())
    {
        hStartEnum = WszOpenEvent(EVENT_ALL_ACCESS, 
                                  FALSE,
                                  L"Global\\" StartEnumEventName);
    }
    else
    {
        hStartEnum = WszOpenEvent(EVENT_ALL_ACCESS, 
                                  FALSE,
                                  StartEnumEventName);
    }
    
    dwErr = GetLastError();
    if (hStartEnum == NULL) 
    {
        err = Fail_NoHandler;
        goto errExit;
    }

    if (RunningOnWinNT5())
    {
        hDoneEnum = WszOpenEvent(EVENT_ALL_ACCESS,
                                 FALSE,
                                 L"Global\\" DoneEnumEventName);
    }
    else
    {
        hDoneEnum = WszOpenEvent(EVENT_ALL_ACCESS,
                                 FALSE,
                                 DoneEnumEventName);
    }
    
    dwErr = GetLastError();
    if (hDoneEnum == NULL) 
    {
        err = Fail_NoHandler;
        goto errExit;
    }

    // Need to create the mutex
    if (RunningOnWinNT5())
    {
        hWrapCall = WszCreateMutex(NULL, FALSE, L"Global\\" WrapMutexName);
    }
    else
    {
        hWrapCall = WszCreateMutex(NULL, FALSE, WrapMutexName);
    }
    
    dwErr = GetLastError();

    if (hWrapCall == NULL)
    {
        err = Fail_CreateMutex;
        goto errExit;
    }
    


// Wait for our turn    
    dwWaitRet = WaitForSingleObject(hWrapCall, START_ENUM_TIMEOUT);
    dwErr = GetLastError();
    switch(dwWaitRet) {
    case WAIT_OBJECT_0:
        // Good case. All other cases are errors and goto errExit.
        break;

    case WAIT_TIMEOUT:
        err = Fail_Timeout_Lock;
        goto errExit;
        break;
    default:
        err = Failed;
        goto errExit;
        break;
    }

    // Our turn: Make the function call
    {
        BOOL fSetOK = 0;

    // Reset the 'Done event' to make sure that Handler sets it after they start.
        fSetOK = ResetEvent(hDoneEnum);
        _ASSERTE(fSetOK);
        dwErr = GetLastError();

    // Signal Handler to execute callback   
        fSetOK = SetEvent(hStartEnum);
        _ASSERTE(fSetOK);
        dwErr = GetLastError();

    // Now wait for handler to finish.
        
        dwWaitRet = WaitForSingleObject(hDoneEnum, START_ENUM_TIMEOUT);
        dwErr = GetLastError();
        switch (dwWaitRet)
        {   
        case WAIT_OBJECT_0:
            break;
        case WAIT_TIMEOUT:
            err = Fail_Timeout_Call;
            break;      
        default:
            err = Failed;
            break;
        }
        

        BOOL fMutexOk = ReleaseMutex(hWrapCall);
        _ASSERTE(fMutexOk);
        dwErr = GetLastError();

    } // End function call



errExit:
// Close all handles
    if (hStartEnum != NULL) 
    {
        CloseHandle(hStartEnum);
        hStartEnum = NULL;
        
    }
    if (hDoneEnum != NULL) 
    {
        CloseHandle(hDoneEnum);
        hDoneEnum = NULL;
    }
    if (hWrapCall != NULL) 
    {
        CloseHandle(hWrapCall);
        hWrapCall = NULL;
    }

#if defined(ENABLE_TIMING)
    g_time.End();
    DWORD dwTime = g_time.GetEllapsedMS();
#endif


    return err;

}


// Reset vars so we can be sure that Init was called
IPCFuncCallHandler::IPCFuncCallHandler()
{   
    m_hStartEnum    = NULL; // event to notify start call
    m_hDoneEnum     = NULL; // event to notify end call
    m_hAuxThread    = NULL; // thread to listen for m_hStartEnum
    m_pfnCallback   = NULL; // Callback handler
    m_fShutdownAuxThread = FALSE;
    m_hShutdownThread = NULL;
    m_hAuxThreadShutdown = NULL;
    m_hCallbackModule = NULL; // module in which the aux thread's start function lives
}

IPCFuncCallHandler::~IPCFuncCallHandler()
{
    // If Terminate was not called then do so now. This should have been 
    // called from CloseCtrs perf counters API. But in Whistler this order is
    // not guaranteed.
    TerminateFCHandler();

    _ASSERTE((m_hStartEnum  == NULL) && "Make sure all handles (e.g.reg keys) are closed.");
    _ASSERTE(m_hDoneEnum    == NULL);
    _ASSERTE(m_hAuxThread   == NULL);
    _ASSERTE(m_pfnCallback  == NULL);
}

//-----------------------------------------------------------------------------
// Thread callback
//-----------------------------------------------------------------------------
DWORD WINAPI HandlerAuxThreadProc(
    LPVOID lpParameter   // thread data
)
{
    
    IPCFuncCallHandler * pHandler = (IPCFuncCallHandler *) lpParameter;
    HANDLER_CALLBACK pfnCallback = pHandler->m_pfnCallback;
    
    DWORD dwErr = 0;
    DWORD dwWaitRet; 
    
    HANDLE lpHandles[] = {pHandler->m_hShutdownThread, pHandler->m_hStartEnum};
    DWORD dwHandleCount = 2;

    __try 
    {
    
        do {
            dwWaitRet = WaitForMultipleObjects(dwHandleCount, lpHandles, FALSE /*Wait Any*/, INFINITE);
            dwErr = GetLastError();
    
            // If we are in terminate mode then exit this helper thread.
            if (pHandler->m_fShutdownAuxThread)
                break;
            
            // Keep the 0th index for the terminate thread so that we never miss it
            // in case of multiple events. note that the ShutdownAuxThread flag above it purely 
            // to protect us against some bug in waitForMultipleObjects.
            if ((dwWaitRet-WAIT_OBJECT_0) == 0)
                break;

            // execute callback if wait succeeded
            if ((dwWaitRet-WAIT_OBJECT_0) == 1)
            {           
                (*pfnCallback)();
                            
                BOOL fSetOK = SetEvent(pHandler->m_hDoneEnum);
                _ASSERTE(fSetOK);
                dwErr = GetLastError();
            }
        } while (dwWaitRet != WAIT_FAILED);

    }

    __finally
    {
        if (!SetEvent (pHandler->m_hAuxThreadShutdown))
        {
            dwErr = GetLastError();
            _ASSERTE (!"HandlerAuxTHreadProc: SetEvent(m_hAuxThreadShutdown) failed");
        }
        FreeLibraryAndExitThread (pHandler->m_hCallbackModule, 0);
        // Above call doesn't return
    }
}
 


//-----------------------------------------------------------------------------
// Receieves the call. This should be in a different process than the source
//-----------------------------------------------------------------------------
HRESULT IPCFuncCallHandler::InitFCHandler(HANDLER_CALLBACK pfnCallback)
{
    m_pfnCallback = pfnCallback;

    HRESULT hr = NOERROR;
    DWORD dwThreadId;
    DWORD dwErr = 0;
    
    SetLastError(0);

    // Grab the SA
    DWORD dwPid = 0;
    SECURITY_ATTRIBUTES *pSA = NULL;

    dwPid = GetCurrentProcessId();
    hr = IPCShared::CreateWinNTDescriptor(dwPid, FALSE, &pSA);

    if (FAILED(hr))
        goto errExit;;

    // Create the StartEnum Event
    if (RunningOnWinNT5())
    {
        m_hStartEnum = WszCreateEvent(pSA,
                                      FALSE,
                                      FALSE,
                                      L"Global\\" StartEnumEventName);
    }
    else
    {
        m_hStartEnum = WszCreateEvent(pSA,
                                      FALSE,
                                      FALSE,
                                      StartEnumEventName);
    }
    
    dwErr = GetLastError();
    if (m_hStartEnum == NULL)
    {
        hr = HRESULT_FROM_WIN32(dwErr); 
        goto errExit;
    }

    // Create the EndEnumEvent
    if (RunningOnWinNT5())
    {
        m_hDoneEnum = WszCreateEvent(pSA,
                                     FALSE,  
                                     FALSE,
                                     L"Global\\" DoneEnumEventName);
    }
    else
    {
        m_hDoneEnum = WszCreateEvent(pSA,
                                     FALSE,  
                                     FALSE,
                                     DoneEnumEventName);
    }
    
    dwErr = GetLastError();
    if (m_hDoneEnum == NULL) 
    {
        hr = HRESULT_FROM_WIN32(dwErr); 
        goto errExit;
    }

    // Create the ShutdownThread Event
    m_hShutdownThread = WszCreateEvent(pSA,
                                       TRUE, /* Manual Reset */
                                       FALSE, /* Initial state not signalled */
                                       NULL);
    
    dwErr = GetLastError();
    if (m_hShutdownThread == NULL)
    {
        hr = HRESULT_FROM_WIN32(dwErr); 
        goto errExit;
    }

    // Create the AuxThreadShutdown Event
    m_hAuxThreadShutdown = WszCreateEvent(pSA,
                                          TRUE, /* Manual Reset */
                                          FALSE,
                                          NULL);
    
    dwErr = GetLastError();
    if (m_hAuxThreadShutdown == NULL)
    {
        hr = HRESULT_FROM_WIN32(dwErr); 
        goto errExit;
    }

    // The thread that we are about to create should always 
    // find the code in memory. So we take a ref on the DLL. 
    // and do a free library at the end of the thread's start function
    m_hCallbackModule = WszLoadLibrary (L"CorPerfmonExt.dll");

    dwErr = GetLastError();
    if (m_hCallbackModule == NULL)
    {
        hr = HRESULT_FROM_WIN32(dwErr); 
        goto errExit;
    }

    // Create thread
    m_hAuxThread = CreateThread(
        NULL,
        0,
        HandlerAuxThreadProc,
        this,
        0,
        &dwThreadId 
    );
    dwErr = GetLastError();
    if (m_hAuxThread == NULL)
    {
        hr = HRESULT_FROM_WIN32(dwErr); 

        // In case of an error free this library here otherwise
        // the thread's exit would take care of it.
        if (m_hCallbackModule)
            FreeLibrary (m_hCallbackModule);
        goto errExit;
    }

errExit:
    if (!SUCCEEDED(hr)) 
    {
        TerminateFCHandler();
    }
    return hr;
 
}

//-----------------------------------------------------------------------------
// Close all our handles
//-----------------------------------------------------------------------------
void IPCFuncCallHandler::TerminateFCHandler()
{
    if ((m_hStartEnum == NULL) &&
        (m_hDoneEnum == NULL) &&
        (m_hAuxThread == NULL) &&
        (m_pfnCallback == NULL))
    {
        return;
    }

    // First make sure that we make the aux thread gracefully exit
    m_fShutdownAuxThread = TRUE;

    // Hope that this set event makes the thread quit.
    if (!SetEvent (m_hShutdownThread))
    {
        DWORD dwErr = GetLastError();
        _ASSERTE (!"TerminateFCHandler: SetEvent(m_hShutdownThread) failed");
    }
    else
    {
        // Wait for the aux thread to tell us that its not in the callback
        // and is about to terminate
        // wait here till the Aux thread exits
        DWORD AUX_THREAD_WAIT_TIMEOUT = 60 * 1000; // 1 minute

        HANDLE lpHandles[] = {m_hAuxThreadShutdown, m_hAuxThread};
        DWORD dwHandleCount = 2;

        BOOL doWait = TRUE;
        while (doWait)
        {
            DWORD dwWaitRet = WaitForMultipleObjects(dwHandleCount, lpHandles, FALSE /*waitany*/, AUX_THREAD_WAIT_TIMEOUT);
            if (dwWaitRet == WAIT_OBJECT_0 || dwWaitRet == WAIT_OBJECT_0+1)
            {
                doWait = FALSE;
                // Not really necessary but cleanup after ourselves
                ResetEvent(m_hAuxThreadShutdown);
            }
            else if (dwWaitRet == WAIT_TIMEOUT)
            {
                // Make sure that the aux thread is still alive
                DWORD dwThreadState = WaitForSingleObject(m_hAuxThread, 0);
                if ((dwThreadState == WAIT_FAILED) || (dwThreadState == WAIT_OBJECT_0))
                    doWait = FALSE;
            }
            else
            {
                // We failed for some reason. Bail on the aux thread.
                _ASSERTE(!"WaitForSingleObject failed while waiting for aux thread");
                doWait = FALSE;
            }
        }
    }


    if (m_hStartEnum != NULL)
    {
        CloseHandle(m_hStartEnum);
        m_hStartEnum = NULL;
    }

    if (m_hDoneEnum != NULL)
    {
        CloseHandle(m_hDoneEnum);
        m_hDoneEnum = NULL;
    }

    if (m_hAuxThread != NULL)
    {
        CloseHandle(m_hAuxThread);
        m_hAuxThread = NULL;
    }

    if (m_hAuxThreadShutdown != NULL) 
    {
        CloseHandle(m_hAuxThreadShutdown);
        m_hAuxThreadShutdown = NULL;
    }

    m_pfnCallback = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\ipcman\ipcheader.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: IPCHeader.h
//
// Define the private header format for COM+ memory mapped files. Everyone
// outside of IPCMan.lib will use the public header, IPCManagerInterface.h
//
//*****************************************************************************

#ifndef _IPCManagerPriv_h_
#define _IPCManagerPriv_h_


//-----------------------------------------------------------------------------
// We must pull in the headers of all client blocks
// @todo - resolve these directory links
//-----------------------------------------------------------------------------
#include "..\Debug\Inc\DbgIPCEvents.h"
#include "corsvcpriv.h"
#include "PerfCounterDefs.h"
#include "minidumppriv.h"
#include <dump-tables.h>

//-----------------------------------------------------------------------------
// Each IPC client for a private block (debugging, perf counters, etc) 
// has one entry
//-----------------------------------------------------------------------------
enum EPrivateIPCClient
{
	ePrivIPC_PerfCounters = 0,
	ePrivIPC_Debugger,
	ePrivIPC_AppDomain,
    ePrivIPC_Service,
    ePrivIPC_ClassDump,
    ePrivIPC_MiniDump,

// MAX used for arrays, insert above this.
	ePrivIPC_MAX
};

//-----------------------------------------------------------------------------
// Entry in the IPC Directory. Ensure binary compatibility across versions
// if we add (or remove) entries.
// If we remove an block, the entry should be EMPTY_ENTRY_OFFSET
//-----------------------------------------------------------------------------

// Since offset is from end of directory, first offset is 0, so we can't
// use that to indicate empty. However, Size can still be 0.
const DWORD EMPTY_ENTRY_OFFSET	= 0xFFFFFFFF;
const DWORD EMPTY_ENTRY_SIZE	= 0;

struct IPCEntry
{	
	DWORD m_Offset;	// offset of the IPC Block from the end of the directory
	DWORD m_Size;		// size (in bytes) of the block
};


//-----------------------------------------------------------------------------
// Private header - put in its own structure so we can easily get the 
// size of the header. It will compile to the same thing either way.
//-----------------------------------------------------------------------------
struct PrivateIPCHeader
{
// header
	DWORD		m_dwVersion;	// version of the IPC Block
    DWORD       m_blockSize;    // Size of the entire shared memory block
	HINSTANCE	m_hInstance;	// instance of module that created this header
	USHORT		m_BuildYear;	// stamp for year built
	USHORT		m_BuildNumber;	// stamp for Month/Day built
	DWORD		m_numEntries;	// Number of entries in the table
};

//-----------------------------------------------------------------------------
// Private (per process) IPC Block for COM+ apps
//-----------------------------------------------------------------------------
struct PrivateIPCControlBlock
{
// Header
	struct PrivateIPCHeader				m_header;

// Directory
	IPCEntry m_table[ePrivIPC_MAX];	// entry describing each client's block

// Client blocks
	struct PerfCounterIPCControlBlock	m_perf;
	struct DebuggerIPCControlBlock		m_dbg;
	struct AppDomainEnumerationIPCBlock m_appdomain;
    struct ServiceIPCControlBlock       m_svc;
    struct ClassDumpTableBlock  m_dump;

    //
    // ***NOTE***
    //
    // This should ALWAYS be the last entry in the IPC block, since the
    // mscordmp tool relies on the first two entries of the IPC block being
    // the version and IPC block size and the last MAX_PATH * sizeof(WCHAR)
    // bytes of the IPC block being the COR path.
    struct MiniDumpBlock                m_minidump;
};

//=============================================================================
// Internal Helpers: Encapsulate any error-prone math / comparisons.
// The helpers are very streamlined and don't handle error conditions.
// Also, Table access functions use DWORD instead of typesafe Enums
// so they can be more flexible (not just for private blocks).
//=============================================================================


//-----------------------------------------------------------------------------
// Internal helper. Enforces a formal definition for an "empty" entry
// Returns true if the entry is empty and false if the entry is usable.
//-----------------------------------------------------------------------------
inline bool Internal_CheckEntryEmpty(	
	const PrivateIPCControlBlock & block,	// ipc block
	DWORD Id								// id of block we want
)
{
// Directory has offset in bytes of block
	const DWORD offset = block.m_table[Id].m_Offset;

	return (EMPTY_ENTRY_OFFSET == offset);
}


//-----------------------------------------------------------------------------
// Internal helper: Encapsulate error-prone math
// Helper that returns a BYTE* to a block within a header.
//-----------------------------------------------------------------------------
inline BYTE* Internal_GetBlock(
	const PrivateIPCControlBlock & block,	// ipc block
	DWORD Id								// id of block we want
)
{
// Directory has offset in bytes of block
	const DWORD offset = block.m_table[Id].m_Offset;

// This block has been removed. Callee should have caught that and not called us.
	_ASSERTE(!Internal_CheckEntryEmpty(block, Id));

	return 
		((BYTE*) &block)					// base pointer to start of block
		+ sizeof(PrivateIPCHeader)			// skip over the header (constant size)
		+ block.m_header. m_numEntries 
			* sizeof(IPCEntry)				// skip over directory (variable size)
		+offset;							// jump to block
}



#endif // _IPCManagerPriv_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\ipcman\ipcmanagerimpl.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: IPCManagerImpl.h
//
// Defines Classes to implement InterProcess Communication Manager for a COM+
//
//*****************************************************************************

#ifndef _IPCManagerImpl_H_
#define _IPCManagerImpl_H_

#include <aclapi.h>


enum EPrivateIPCClient;

struct PrivateIPCControlBlock;


// Version of the IPC Block that this lib was compiled for.
const int VER_IPC_BLOCK = 2;


//-----------------------------------------------------------------------------
// Implementation for the IPCManager for COM+.
//-----------------------------------------------------------------------------
class IPCWriterImpl
{
public:
    IPCWriterImpl();
    ~IPCWriterImpl();

    // All interface functions should be provided in a derived class

protected:
    // Helpers
    HRESULT CreateWinNTDescriptor(DWORD pid, SECURITY_ATTRIBUTES **ppSA);

    void CloseGenericIPCBlock(HANDLE & hMemFile, void * & pBlock);
    HRESULT CreateNewPrivateIPCBlock();
    
    void WriteEntryHelper(EPrivateIPCClient eClient, DWORD size);
    void CreatePrivateIPCHeader();
    void OpenPrivateIPCHeader();

    bool IsPrivateBlockOpen() const;

    // Cache pointers to each section
    struct PerfCounterIPCControlBlock   *m_pPerf;
    struct DebuggerIPCControlBlock      *m_pDebug;
    struct AppDomainEnumerationIPCBlock *m_pAppDomain;
    struct ServiceIPCControlBlock       *m_pService;
    struct MiniDumpBlock                *m_pMiniDump;

    // Stats on MemoryMapped file for the given pid 
    HANDLE                               m_handlePrivateBlock;
    PrivateIPCControlBlock              *m_ptrPrivateBlock;

    // Security attributes cached for the current process.
    SECURITY_ATTRIBUTES                 *m_pSA;
};


//-----------------------------------------------------------------------------
// IPCReader class connects to a COM+ IPC block and reads from it
// @todo - make global & private readers
//-----------------------------------------------------------------------------
class IPCReaderImpl
{
public:
    IPCReaderImpl();
    ~IPCReaderImpl();

protected:

    HANDLE  m_handlePrivateBlock;
    PrivateIPCControlBlock * m_ptrPrivateBlock;
};



//-----------------------------------------------------------------------------
// Return true if our Private block is available.
//-----------------------------------------------------------------------------
inline bool IPCWriterImpl::IsPrivateBlockOpen() const
{
    return m_ptrPrivateBlock != NULL;
}



#endif _IPCManagerImpl_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\ipcman\ipcreaderimpl.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: IPCReaderImpl.cpp
//
// Read a COM+ memory mapped file
//
//*****************************************************************************

#include "stdafx.h"

#include "IPCManagerInterface.h"
#include "IPCHeader.h"
#include "IPCShared.h"

//-----------------------------------------------------------------------------
// Ctor sets members
//-----------------------------------------------------------------------------
IPCReaderImpl::IPCReaderImpl()
{
	m_handlePrivateBlock = NULL;
	m_ptrPrivateBlock = NULL;
}

//-----------------------------------------------------------------------------
// dtor
//-----------------------------------------------------------------------------
IPCReaderImpl::~IPCReaderImpl()
{

}

//-----------------------------------------------------------------------------
// Close whatever block we opened
//-----------------------------------------------------------------------------
void IPCReaderInterface::ClosePrivateBlock()
{
	IPCShared::CloseGenericIPCBlock(
		m_handlePrivateBlock, 
		(void * &) m_ptrPrivateBlock
	);
}

//-----------------------------------------------------------------------------
// Open our private block
//-----------------------------------------------------------------------------
HRESULT IPCReaderInterface::OpenPrivateBlockOnPid(DWORD pid, DWORD dwDesiredAccess)
{
	HRESULT hr	= NO_ERROR;
	DWORD dwErr = 0;

	

	WCHAR szMemFileName[100];
	IPCShared::GenerateName(pid, szMemFileName, 100);

// Note, PID != GetCurrentProcessId(), b/c we're expected to be opening
// someone else's IPCBlock, not our own. If this isn't the case, just remove
// this assert

// exception: if we're enumerating provesses, we'll hit our own
//	_ASSERTE(pid != GetCurrentProcessId());

// Note: if our private block is open, we shouldn't be attaching to a new one.
	_ASSERTE(!IsPrivateBlockOpen());
	if (IsPrivateBlockOpen()) 
	{
		return ERROR_ALREADY_EXISTS;
	}

	m_handlePrivateBlock = WszOpenFileMapping(dwDesiredAccess,
                                              FALSE,
                                              szMemFileName);
    
	dwErr = GetLastError();
    if (m_handlePrivateBlock == NULL)
    {
        hr = HRESULT_FROM_WIN32(dwErr);
        goto errExit;
    }

    
	m_ptrPrivateBlock = (PrivateIPCControlBlock*) MapViewOfFile(
		m_handlePrivateBlock,
		dwDesiredAccess,
		0, 0, 0);

	dwErr = GetLastError();
    if (m_ptrPrivateBlock== NULL)
    {
        hr = HRESULT_FROM_WIN32(dwErr);
        goto errExit;
    }

// Client must connect their pointers by calling GetXXXBlock() functions

errExit:
	if (!SUCCEEDED(hr))
	{
		ClosePrivateBlock();	
	}

	return hr;
}

//-----------------------------------------------------------------------------
// Open our private block for all access
//-----------------------------------------------------------------------------
HRESULT IPCReaderInterface::OpenPrivateBlockOnPid(DWORD pid)
{
    return (OpenPrivateBlockOnPid(pid, FILE_MAP_ALL_ACCESS));
}

//-----------------------------------------------------------------------------
// Open our private block for read/write access
//-----------------------------------------------------------------------------
HRESULT IPCReaderInterface::OpenPrivateBlockOnPidReadWrite(DWORD pid)
{
    return (OpenPrivateBlockOnPid(pid, FILE_MAP_READ | FILE_MAP_WRITE));
}

//-----------------------------------------------------------------------------
// Open our private block for read only access
//-----------------------------------------------------------------------------
HRESULT IPCReaderInterface::OpenPrivateBlockOnPidReadOnly(DWORD pid)
{
    return (OpenPrivateBlockOnPid(pid, FILE_MAP_READ));
}

//-----------------------------------------------------------------------------
// Get a client's private block based on enum
// This is a robust function.
// It will return NULL if: 
//	* the IPC block is closed (also ASSERT), 
//  * the eClient is out of range (From version mismatch)
//  * the request block is removed (probably version mismatch)
// Else it will return a pointer to the requested block
//-----------------------------------------------------------------------------
void * IPCReaderInterface::GetPrivateBlock(EPrivateIPCClient eClient)
{
	_ASSERTE(IsPrivateBlockOpen());

// This block doesn't exist if we're closed or out of the table's range
	if (!IsPrivateBlockOpen() || (DWORD) eClient >= m_ptrPrivateBlock->m_header.m_numEntries) 
	{
		return NULL;
	}

	if (Internal_CheckEntryEmpty(*m_ptrPrivateBlock, eClient)) 
	{
		return NULL;
	}

	return Internal_GetBlock(*m_ptrPrivateBlock, eClient);
}

//-----------------------------------------------------------------------------
// Is our private block open?
//-----------------------------------------------------------------------------
bool IPCReaderInterface::IsPrivateBlockOpen() const
{
	return m_ptrPrivateBlock != NULL;
}

PerfCounterIPCControlBlock *	IPCReaderInterface::GetPerfBlock()
{
	return (PerfCounterIPCControlBlock*) GetPrivateBlock(ePrivIPC_PerfCounters);
}

DebuggerIPCControlBlock * IPCReaderInterface::GetDebugBlock()
{
	return (DebuggerIPCControlBlock*) GetPrivateBlock(ePrivIPC_Debugger);
}

AppDomainEnumerationIPCBlock * IPCReaderInterface::GetAppDomainBlock()
{
	return (AppDomainEnumerationIPCBlock*) GetPrivateBlock(ePrivIPC_AppDomain);
}

ServiceIPCControlBlock * IPCReaderInterface::GetServiceBlock()
{
	return (ServiceIPCControlBlock*) GetPrivateBlock(ePrivIPC_Service);
}

MiniDumpBlock * IPCReaderInterface::GetMiniDumpBlock()
{
	return (MiniDumpBlock*) GetPrivateBlock(ePrivIPC_MiniDump);
}

ClassDumpTableBlock* IPCReaderInterface::GetClassDumpTableBlock()
{
	return (ClassDumpTableBlock*) GetPrivateBlock(ePrivIPC_ClassDump);
}

//-----------------------------------------------------------------------------
// Check if the block is valid. Current checks include:
// * Check Directory structure
//-----------------------------------------------------------------------------
bool IPCReaderInterface::IsValid()
{
// Check the directory structure. Offset(n) = offset(n-1) + size(n-1)
	DWORD offsetExpected = 0, size = 0;
	DWORD nId = 0;
	DWORD offsetActual;
	
	for(nId = 0; nId < m_ptrPrivateBlock->m_header.m_numEntries; nId ++)
	{
		if (!Internal_CheckEntryEmpty(*m_ptrPrivateBlock, nId))
		{
			offsetActual = m_ptrPrivateBlock->m_table[nId].m_Offset;
			if (offsetExpected != offsetActual)
			{
				_ASSERTE(0 && "Invalid IPCBlock Directory Table");
				return false;
			}
			offsetExpected += m_ptrPrivateBlock->m_table[nId].m_Size;		
		} else {
			if (m_ptrPrivateBlock->m_table[nId].m_Size != EMPTY_ENTRY_SIZE)
			{
				_ASSERTE(0 && "Invalid IPCBlock: Empty Block with non-zero size");
				return false;
			}
		}
	}


	return true;
}


DWORD IPCReaderInterface::GetBlockVersion()
{
	_ASSERTE(IsPrivateBlockOpen());
	return m_ptrPrivateBlock->m_header.m_dwVersion;
}

DWORD IPCReaderInterface::GetBlockSize()
{
    _ASSERTE(IsPrivateBlockOpen());
    return m_ptrPrivateBlock->m_header.m_blockSize;
}

HINSTANCE IPCReaderInterface::GetInstance()
{
	_ASSERTE(IsPrivateBlockOpen());
	return m_ptrPrivateBlock->m_header.m_hInstance;
}

USHORT IPCReaderInterface::GetBuildYear()
{
	_ASSERTE(IsPrivateBlockOpen());
	return m_ptrPrivateBlock->m_header.m_BuildYear;
}

USHORT IPCReaderInterface::GetBuildNumber()
{
	_ASSERTE(IsPrivateBlockOpen());
	return m_ptrPrivateBlock->m_header.m_BuildNumber;
}

PVOID IPCReaderInterface::GetBlockStart()
{
    return (PVOID) m_ptrPrivateBlock;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\ipcman\ipcsharedsrc.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: IPCSharedSrc.cpp
//
// Shared source for COM+ IPC Reader & Writer classes
//
//*****************************************************************************

#include "stdafx.h"
#include "IPCShared.h"

#ifndef SM_REMOTESESSION
#define SM_REMOTESESSION 0x1000
#endif

// Name of the Private (per-process) block. %d resolved to a PID
#define CorPrivateIPCBlock      L"Cor_Private_IPCBlock_%d"

//-----------------------------------------------------------------------------
// Close a handle and pointer to any memory mapped file
//-----------------------------------------------------------------------------
void IPCShared::CloseGenericIPCBlock(HANDLE & hMemFile, void * & pBlock)
{
	if (pBlock != NULL) {
		if (!UnmapViewOfFile(pBlock))
            _ASSERTE(!"UnmapViewOfFile failed");
		pBlock = NULL;
	}

	if (hMemFile != NULL) {
		CloseHandle(hMemFile);
		hMemFile = NULL;
	}
}

//-----------------------------------------------------------------------------
// Based on the pid, write a unique name for a memory mapped file
//-----------------------------------------------------------------------------
void IPCShared::GenerateName(DWORD pid, WCHAR* pszBuffer, int len)
{
    // Must be large enough to hold our string 
	_ASSERTE(len >= (sizeof(CorPrivateIPCBlock) / sizeof(WCHAR)) + 16);

    // Buffer size must be large enough.
    if (RunningOnWinNT5())
        swprintf(pszBuffer, L"Global\\" CorPrivateIPCBlock, pid);
    else
        swprintf(pszBuffer, CorPrivateIPCBlock, pid);

}


//-----------------------------------------------------------------------------
// Setup a security descriptor for the named kernel objects if we're on NT.
//-----------------------------------------------------------------------------
HRESULT IPCShared::CreateWinNTDescriptor(DWORD pid, BOOL bRestrictiveACL, SECURITY_ATTRIBUTES **ppSA)
{
    // Gotta have a place to stick the new SA...
    if (ppSA == NULL)
    {
        _ASSERTE(!"Caller must supply ppSA");
        return E_INVALIDARG;
    }

    if (ppSA)
        *ppSA = NULL;

    // Must be on NT... none of this works on Win9x.
    if (!RunningOnWinNT())
    {
        return NO_ERROR;
    }

    HRESULT hr = NO_ERROR;

    ACL *pACL = NULL;
    SECURITY_DESCRIPTOR *pSD = NULL;
    SECURITY_ATTRIBUTES *pSA = NULL;

    // Allocate a SD.
    pSD = (SECURITY_DESCRIPTOR*) malloc(SECURITY_DESCRIPTOR_MIN_LENGTH);

    if (pSD == NULL)
    {    
        hr = E_OUTOFMEMORY;
        goto errExit;
    }

    // Do basic SD initialization
    if (!InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto errExit;
    }

    // Grab the ACL for the IPC block for the given process
    if (!InitializeGenericIPCAcl(pid, bRestrictiveACL, &pACL))
    {
        hr = E_FAIL;
        goto errExit;
    }

    // Add the ACL as the DACL for the SD.
    if (!SetSecurityDescriptorDacl(pSD, TRUE, pACL, FALSE))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto errExit;
    }

    // Allocate a SA.
    pSA = (SECURITY_ATTRIBUTES*) malloc(sizeof(SECURITY_ATTRIBUTES));

    if (pSA == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto errExit;
    }

    // Pass out the new SA.
    *ppSA = pSA;
    
    pSA->nLength = sizeof(SECURITY_ATTRIBUTES);
    pSA->lpSecurityDescriptor = pSD;
    pSA->bInheritHandle = FALSE;

    // uncomment this line if you want to see the DACL being generated.
    //DumpSD(pSD);

errExit:
    if (FAILED(hr))
    {
        if (pACL != NULL)
        {
            for(int i = 0; i < pACL->AceCount; i++)
                DeleteAce(pACL, i);

            delete [] pACL;
        }

        if (pSD != NULL)
            free(pSD);
    }
    
    return hr;
}

//-----------------------------------------------------------------------------
// Given a PID, grab the SID for the owner of the process.
//
// NOTE:: Caller has to free *ppBufferToFreeByCaller.
// This buffer is allocated to hold the PSID return by GetPrcoessTokenInformation.
// The tkOwner field may contain a poniter into this allocated buffer. So we cannot free
// the buffer in GetSidForProcess.
//
//-----------------------------------------------------------------------------
HRESULT IPCShared::GetSidForProcess(HINSTANCE hDll, DWORD pid, PSID *ppSID, char **ppBufferToFreeByCaller)
{
    HRESULT hr = S_OK;
    HANDLE hProc = NULL;
    HANDLE hToken = NULL;
    PSID_IDENTIFIER_AUTHORITY pSID = NULL;
    TOKEN_OWNER *ptkOwner = NULL;
    DWORD dwRetLength;

    LOG((LF_CORDB, LL_INFO10, "IPCWI::GSFP: GetSidForProcess 0x%x (%d)", pid, pid));
        
    // Grab a handle to the target process.
    hProc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);

    *ppBufferToFreeByCaller = NULL;

    if (hProc == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());

        LOG((LF_CORDB, LL_INFO10,
             "IPCWI::GSFP: Unable to get SID for process. "
             "OpenProcess(%d) failed: 0x%08x\n", pid, hr));
        
        goto ErrorExit;
    }
    
    // Get the pointer to the requested function
    FARPROC pProcAddr = GetProcAddress(hDll, "OpenProcessToken");

    // If the proc address was not found, return error
    if (pProcAddr == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());

        LOG((LF_CORDB, LL_INFO10,
             "IPCWI::GSFP: Unable to get SID for process. "
             "GetProcAddr (OpenProcessToken) failed: 0x%08x\n", hr));

        goto ErrorExit;
    }

    typedef BOOL WINAPI OPENPROCESSTOKEN(HANDLE, DWORD, PHANDLE);
    
    // Retrieve a handle of the access token
    if (!((OPENPROCESSTOKEN *)pProcAddr)(hProc, TOKEN_QUERY, &hToken))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());

        LOG((LF_CORDB, LL_INFO100,
             "IPCWI::GSFP: OpenProcessToken() failed: 0x%08x\n", hr));

        goto ErrorExit;
    }
            
    // Get the pointer to the requested function
    pProcAddr = GetProcAddress(hDll, "GetTokenInformation");

    // If the proc address was not found, return error
    if (pProcAddr == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());

        LOG((LF_CORDB, LL_INFO10,
             "IPCWI::GSFP: Unable to get SID for process. "
             "GetProcAddr (GetTokenInformation) failed: 0x%08x\n", hr));

        goto ErrorExit;
    }

    typedef BOOL GETTOKENINFORMATION(HANDLE, TOKEN_INFORMATION_CLASS, LPVOID,
                                     DWORD, PDWORD);

    // get the required size of buffer 
    ((GETTOKENINFORMATION *)pProcAddr) (hToken, TokenOwner, NULL, 
    				0, &dwRetLength);
                                        
    _ASSERTE (dwRetLength);

    *ppBufferToFreeByCaller = new char [dwRetLength];
    if ((ptkOwner = (TOKEN_OWNER *) *ppBufferToFreeByCaller) == NULL)
    {
        LOG((LF_CORDB, LL_INFO10,
             "IPCWI::GSFP: OutOfMemory... "
             "GetTokenInformation() failed.\n"));

        goto ErrorExit;
    }

    if (!((GETTOKENINFORMATION *)pProcAddr) (hToken, TokenOwner, (LPVOID)ptkOwner, 
                                            dwRetLength, &dwRetLength))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());

        LOG((LF_CORDB, LL_INFO10,
             "IPCWI::GSFP: Unable to get SID for process. "
             "GetTokenInformation() failed: 0x%08x\n", hr));

        goto ErrorExit;
    }

    *ppSID = ptkOwner->Owner;

ErrorExit:
    if (hProc != NULL)
        CloseHandle(hProc);

    if (hToken != NULL)
        CloseHandle(hToken);

    return hr;
}

//-----------------------------------------------------------------------------
// This function will initialize the Access Control List with three
// Access Control Entries:
// The first ACE entry grants all permissions to "Administrators".
// The second ACE grants all permissions to the "ASPNET" user (for perfcounters).
// The third ACE grants all permissions to "Owner" of the target process.
//-----------------------------------------------------------------------------
BOOL IPCShared::InitializeGenericIPCAcl(DWORD pid, BOOL bRestrictiveACL, PACL *ppACL)
{
#define NUM_ACE_ENTRIES     4

    PermissionStruct PermStruct[NUM_ACE_ENTRIES];
    SID_IDENTIFIER_AUTHORITY SIDAuthNT = SECURITY_NT_AUTHORITY;
    HRESULT hr = S_OK;
    DWORD dwAclSize;
    BOOL returnCode = false;
    *ppACL = NULL;
    DWORD i;
    DWORD cActualACECount = 0;
    char *pBufferToFreeByCaller = NULL;
    int iSIDforAdmin = -1;
    int iSIDforUsers = -1;
        

    PermStruct[0].rgPSID = NULL;
    
    HINSTANCE hDll = WszGetModuleHandle(L"advapi32");

    if (hDll == NULL)
    {
        LOG((LF_CORDB, LL_INFO10, "IPCWI::IGIPCA: Unable to generate ACL for IPC. LoadLibrary (advapi32) failed.\n"));
        return false;
    }
    _ASSERTE(hDll != NULL);

    // Get the pointer to the requested function
    FARPROC pProcAddr = GetProcAddress(hDll, "AllocateAndInitializeSid");

    // If the proc address was not found, return error
    if (pProcAddr == NULL)
    {
        LOG((LF_CORDB, LL_INFO10,
             "IPCWI::IGIPCA: Unable to generate ACL for IPC. "
             "GetProcAddr (AllocateAndInitializeSid) failed.\n"));
        goto ErrorExit;
    }

    typedef BOOL ALLOCATEANDINITIALIZESID(PSID_IDENTIFIER_AUTHORITY,
                            BYTE, DWORD, DWORD, DWORD, DWORD,
                            DWORD, DWORD, DWORD, DWORD, PSID *);


    // Create a SID for the BUILTIN\Administrators group.
    // SECURITY_BUILTIN_DOMAIN_RID + DOMAIN_ALIAS_RID_ADMINS = all Administrators. This translates to (A;;GA;;;BA).
    if (!((ALLOCATEANDINITIALIZESID *) pProcAddr)(&SIDAuthNT,
                                                  2,
                                                  SECURITY_BUILTIN_DOMAIN_RID,
                                                  DOMAIN_ALIAS_RID_ADMINS,
                                                  0, 0, 0, 0, 0, 0,
                                                  &PermStruct[0].rgPSID)) 
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        _ASSERTE(SUCCEEDED(hr));
        
        LOG((LF_CORDB, LL_INFO10,
             "IPCWI::IGIPCA: failed to allocate AdminSid: 0x%08x\n", hr));

        goto ErrorExit;
    }
    // GENERIC_ALL access for Administrators
    PermStruct[cActualACECount].rgAccessFlags = GENERIC_ALL;

    iSIDforAdmin = cActualACECount;
    cActualACECount++;

    if (!bRestrictiveACL)
    {
        // Create a SID for "Users".  Use bRestrictiveACL with caution!
        if (!((ALLOCATEANDINITIALIZESID *) pProcAddr)(&SIDAuthNT,
                                                      2,
                                                      SECURITY_BUILTIN_DOMAIN_RID,
                                                      DOMAIN_ALIAS_RID_USERS,
                                                      0, 0, 0, 0, 0, 0,
                                                      &PermStruct[cActualACECount].rgPSID)) 
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            _ASSERTE(SUCCEEDED(hr));
            
            LOG((LF_CORDB, LL_INFO10,
                 "IPCWI::IGIPCA: failed to allocate Users Sid: 0x%08x\n", hr));

            goto ErrorExit;
        }

        // "Users" shouldn't be able to delete object, change DACLs, or change ownership
        PermStruct[cActualACECount].rgAccessFlags = SPECIFIC_RIGHTS_ALL & ~WRITE_DAC & ~WRITE_OWNER & ~DELETE;

        iSIDforUsers = cActualACECount;
        cActualACECount++;
    }
    
    // Finally, we get the SID for the owner of the current process.
    hr = GetSidForProcess(hDll, GetCurrentProcessId(), &(PermStruct[cActualACECount].rgPSID), &pBufferToFreeByCaller);

    PermStruct[cActualACECount].rgAccessFlags = GENERIC_ALL;

    // Don't fail out if we cannot get the SID for the owner of the current process. In this case, the 
    // share memory block will be created with only Admin (and optionall "Users") permissions.
    // Currently we discovered the anonymous user doesn't have privilege to call OpenProcess. Without OpenProcess,
    // we cannot get the SID...
    //
    if (SUCCEEDED(hr))
    {
        cActualACECount++;
    }
#if _DEBUG
    else
        LOG((LF_CORDB, LL_INFO100, "IPCWI::IGIPCA: GetSidForProcess() failed: 0x%08x\n", hr));        
#endif _DEBUG 

    // Now, create an Initialize an ACL and add the ACE entries to it.  NOTE: We're not using "SetEntriesInAcl" because
    // it loads a bunch of other dlls which can be avoided by using this roundabout way!!

    // Get the pointer to the requested function
    pProcAddr = GetProcAddress(hDll, "InitializeAcl");

    // If the proc address was not found, return error
    if (pProcAddr == NULL)
    {
        LOG((LF_CORDB, LL_INFO10,
             "IPCWI::IGIPCA: Unable to generate ACL for IPC. "
             "GetProcAddr (InitializeAcl) failed.\n"));
        goto ErrorExit;
    }

    // Also calculate the memory required for ACE entries in the ACL using the 
    // following method:
    // "sizeof (ACCESS_ALLOWED_ACE) - sizeof (ACCESS_ALLOWED_ACE.SidStart) + GetLengthSid (pAceSid);"

    dwAclSize = sizeof (ACL) + (sizeof (ACCESS_ALLOWED_ACE) - sizeof (DWORD)) * cActualACECount;

    for (i = 0; i < cActualACECount; i++)
    {
        dwAclSize += GetLengthSid(PermStruct[i].rgPSID);
    }

    // now allocate memory
    if ((*ppACL = (PACL) new char[dwAclSize]) == NULL)
    {
        LOG((LF_CORDB, LL_INFO10, "IPCWI::IGIPCA: OutOfMemory... 'new Acl' failed.\n"));

        goto ErrorExit;
    }

    typedef BOOL INITIALIZEACL(PACL, DWORD, DWORD);

    if (!((INITIALIZEACL *)pProcAddr)(*ppACL, dwAclSize, ACL_REVISION))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());

        LOG((LF_CORDB, LL_INFO100,
             "IPCWI::IGIPCA: InitializeACL() failed: 0x%08x\n", hr));

        goto ErrorExit;
    }

    // Get the pointer to the requested function
    pProcAddr = GetProcAddress(hDll, "AddAccessAllowedAce");

    // If the proc address was not found, return error
    if (pProcAddr == NULL)
    {
        LOG((LF_CORDB, LL_INFO10,
             "IPCWI::IGIPCA: Unable to generate ACL for IPC. "
             "GetProcAddr (AddAccessAllowedAce) failed.\n"));
        goto ErrorExit;
    }

    typedef BOOL ADDACCESSALLOWEDACE(PACL, DWORD, DWORD, PSID);

    for (i=0; i < cActualACECount; i++)
    {
        if (!((ADDACCESSALLOWEDACE *)pProcAddr)(*ppACL, 
                                                ACL_REVISION,
                                                PermStruct[i].rgAccessFlags,
                                                PermStruct[i].rgPSID))

        {
            hr = HRESULT_FROM_WIN32(GetLastError());

            LOG((LF_CORDB, LL_INFO100,
                 "IPCWI::IGIPCA: AddAccessAllowedAce() failed: 0x%08x\n", hr));
            goto ErrorExit;
        }
    }

    returnCode = true;
    goto NormalExit;


ErrorExit:
    returnCode = FALSE;

    if (*ppACL)
    {
        delete [] (*ppACL);
        *ppACL = NULL;
    }

NormalExit:

    if (pBufferToFreeByCaller != NULL)
        delete [] pBufferToFreeByCaller;

    // Get the pointer to the requested function
    pProcAddr = GetProcAddress(hDll, "FreeSid");

    // If the proc address was not found, return error
    if (pProcAddr == NULL)
    {
        LOG((LF_CORDB, LL_INFO10,
             "IPCWI::IGIPCA: Unable to generate ACL for IPC. "
             "GetProcAddr (FreeSid) failed.\n"));
        return false;
    }

    typedef BOOL FREESID(PSID);

    _ASSERTE(iSIDforAdmin != -1);
    
    // Free the SID created earlier. Function does not return a value.
    ((FREESID *) pProcAddr)(PermStruct[iSIDforAdmin].rgPSID);

    // free the SID for "Users"
    if (iSIDforUsers != -1)
        ((FREESID *) pProcAddr)(PermStruct[iSIDforUsers].rgPSID);

    return returnCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\ipcman\stdafx.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\ipcman\ipcshared.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: IPCShared.h
//
// Shared private utility functions for COM+ IPC operations
//
//*****************************************************************************

#ifndef _IPCSHARED_H_
#define _IPCSHARED_H_

struct PermissionStruct
{
    PSID        rgPSID;
    DWORD   rgAccessFlags;
};

class IPCShared
{
public:
// Close a handle and pointer to any memory mapped file
	static void CloseGenericIPCBlock(HANDLE & hMemFile, void * & pBlock);

// Based on the pid, write a unique name for a memory mapped file
	static void GenerateName(DWORD pid, WCHAR* pszBuffer, int len);

    static HRESULT CreateWinNTDescriptor(DWORD pid, BOOL bRestrictiveACL, SECURITY_ATTRIBUTES **ppSA);

private:    
    static BOOL InitializeGenericIPCAcl(DWORD pid, BOOL bRestrictiveACL, PACL *ppACL);
    static HRESULT GetSidForProcess(HINSTANCE hDll, DWORD pid, PSID *ppSID, char **ppBufferToFreeByCaller);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\ipcman\stdafx.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: src\IPCMan\StdAfx.h
//
// Precompiled header for COM+ IPC Manager
//
//*****************************************************************************

#include <WinWrap.h>
#include <windows.h>
#include <stdlib.h>
#include <objbase.h>
#include <stddef.h>
#include <float.h>
#include <limits.h>
#include "DbgAlloc.h"
#include "utilcode.h"
#include "corpriv.h"
#include "WarningControl.h"
#include "log.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\ipcman\ipcwriterimpl.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: IPCWriterImpl.cpp
//
// Implementation for COM+ memory mapped file writing
//
//*****************************************************************************

#include "stdafx.h"

#include "IPCManagerInterface.h"
#include "IPCHeader.h"
#include "IPCShared.h"
#include <windows.h>

#include <sddl.h>

// Get version numbers for IPCHeader stamp
#include "__official__.ver"

// leading 0 interpretted as octal, so stick a 1 on and subtract it.
#ifndef OCTAL_MASH
#define OCTAL_MASH(x) 1 ## x
#endif

const USHORT BuildYear = OCTAL_MASH(COR_BUILD_YEAR) - 10000;
const USHORT BuildNumber = OCTAL_MASH(COR_OFFICIAL_BUILD_NUMBER) - 10000;


// Import from mscoree.obj
HINSTANCE GetModuleInst();

#if _DEBUG
static void DumpSD(PSECURITY_DESCRIPTOR sd)
{
    HINSTANCE  hDll = WszGetModuleHandle(L"advapi32");
    
    // Get the pointer to the requested function
    FARPROC pProcAddr = GetProcAddress(hDll, "ConvertSecurityDescriptorToStringSecurityDescriptorW");

    // If the proc address was not found, return error
    if (pProcAddr == NULL)
    {
        LOG((LF_CORDB, LL_INFO10,
             "IPCWI::DumpSD: GetProcAddr (ConvertSecurityDescriptorToStringSecurityDescriptorW) failed.\n"));
        goto ErrorExit;
    }

    typedef BOOL WINAPI SDTOSTR(PSECURITY_DESCRIPTOR, DWORD, SECURITY_INFORMATION, LPSTR *, PULONG);

    LPSTR str = NULL;
    
    if (!((SDTOSTR*)pProcAddr)(sd, SDDL_REVISION_1, 0xF, &str, NULL))
    {
        LOG((LF_CORDB, LL_INFO10,
             "IPCWI::DumpSD: ConvertSecurityDescriptorToStringSecurityDescriptorW failed %d\n",
             GetLastError()));
        goto ErrorExit;
    }

    fprintf(stderr, "SD for IPC: %S\n", str);
    LOG((LF_CORDB, LL_INFO10, "IPCWI::DumpSD: SD for IPC: %s\n", str));

    LocalFree(str);

ErrorExit:
    return;
}    
#endif _DEBUG

//-----------------------------------------------------------------------------
// Generic init
//-----------------------------------------------------------------------------
HRESULT IPCWriterInterface::Init() 
{
    // Nothing to do anymore in here...
    return S_OK;
}

//-----------------------------------------------------------------------------
// Generic terminate
//-----------------------------------------------------------------------------
void IPCWriterInterface::Terminate() 
{
    IPCShared::CloseGenericIPCBlock(m_handlePrivateBlock, (void*&) m_ptrPrivateBlock);

    // If we have a cached SA for this process, go ahead and clean it up.
    if (m_pSA != NULL)
    {
        // DestroySecurityAttributes won't destroy our cached SA, so save the ptr to the SA and clear the cached value
        // before calling it.
        SECURITY_ATTRIBUTES *pSA = m_pSA;
        m_pSA = NULL;
        DestroySecurityAttributes(pSA);
    }
}


//-----------------------------------------------------------------------------
// Open our Private IPC block on the given pid.
//-----------------------------------------------------------------------------
HRESULT IPCWriterInterface::CreatePrivateBlockOnPid(DWORD pid, BOOL inService, HINSTANCE *phInstIPCBlockOwner) 
{
    // Note: if PID != GetCurrentProcessId(), we're expected to be opening
    // someone else's IPCBlock, so if it doesn't exist, we should assert.
    HRESULT hr = NO_ERROR;

    // Init the IPC block owner HINSTANCE to 0.
    *phInstIPCBlockOwner = 0;

    // Note: if our private block is open, we shouldn't be creating it again.
    _ASSERTE(!IsPrivateBlockOpen());
    
    if (IsPrivateBlockOpen()) 
    {
        // if we goto errExit, it will close the file. We don't want that.
        return ERROR_ALREADY_EXISTS;
    }

    // Grab the SA
    SECURITY_ATTRIBUTES *pSA = NULL;

    hr = CreateWinNTDescriptor(pid, &pSA);

    if (FAILED(hr))
        return hr;

    // Raw creation
    WCHAR szMemFileName[100];

    IPCShared::GenerateName(pid, szMemFileName, 100);

    // Connect the handle   
    m_handlePrivateBlock = WszCreateFileMapping(INVALID_HANDLE_VALUE,
                                                pSA,
                                                PAGE_READWRITE,
                                                0,
                                                sizeof(PrivateIPCControlBlock),
                                                szMemFileName);
    
    DWORD dwFileMapErr = GetLastError();

    LOG((LF_CORDB, LL_INFO10, "IPCWI::CPBOP: Writer: CreateFileMapping = 0x%08x, GetLastError=%d\n",
         m_handlePrivateBlock, GetLastError()));

    // If unsuccessful, bail
    if (m_handlePrivateBlock == NULL)
    {
        hr = HRESULT_FROM_WIN32(dwFileMapErr);
        goto errExit;
    }

    // We may get here with handle with non-null. This can happen if someone
    // precreate our IPC block with matchin SA.
    //
    if (dwFileMapErr == ERROR_ALREADY_EXISTS)
    {
        _ASSERTE(!"This should not happen often unless we are being attacked or previous section hang around and PID is recycled!");
        // someone beat us to create the section. It is bad. We will just fail out here.
        hr = HRESULT_FROM_WIN32(dwFileMapErr);
        goto errExit;        
    }

    _ASSERTE(m_handlePrivateBlock);
    
    // Get the pointer - must get it even if dwFileMapErr == ERROR_ALREADY_EXISTS,
    // since the IPC block is allowed to already exist if the URT service created it.
    m_ptrPrivateBlock = (PrivateIPCControlBlock *) MapViewOfFile(m_handlePrivateBlock,
                                                                 FILE_MAP_ALL_ACCESS,
                                                                     0, 0, 0);

    // If the map failed, bail
    if (m_ptrPrivateBlock == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto errExit;
    }

    // Hook up each sections' pointers
    CreatePrivateIPCHeader();

errExit:
    if (!SUCCEEDED(hr)) 
    {
        IPCShared::CloseGenericIPCBlock(m_handlePrivateBlock, (void*&)m_ptrPrivateBlock);
    }

    DestroySecurityAttributes(pSA);

    return hr;

}

//-----------------------------------------------------------------------------
// Accessors to get each clients' blocks
//-----------------------------------------------------------------------------
struct PerfCounterIPCControlBlock * IPCWriterInterface::GetPerfBlock() 
{
    return m_pPerf;
}

struct DebuggerIPCControlBlock * IPCWriterInterface::GetDebugBlock() 
{
    return m_pDebug;
}   

struct AppDomainEnumerationIPCBlock * IPCWriterInterface::GetAppDomainBlock() 
{
    return m_pAppDomain;
}   

struct ServiceIPCControlBlock * IPCWriterInterface::GetServiceBlock() 
{
    return m_pService;
}   

struct MiniDumpBlock * IPCWriterInterface::GetMiniDumpBlock() 
{
    return m_pMiniDump;
}   

ClassDumpTableBlock* IPCWriterInterface::GetClassDumpTableBlock()
{
  return &m_ptrPrivateBlock->m_dump;
}

//-----------------------------------------------------------------------------
// Return the security attributes for the shared memory for a given process.
//-----------------------------------------------------------------------------
HRESULT IPCWriterInterface::GetSecurityAttributes(DWORD pid, SECURITY_ATTRIBUTES **ppSA)
{
    return CreateWinNTDescriptor(pid, ppSA);
}

//-----------------------------------------------------------------------------
// Helper to destroy the security attributes for the shared memory for a given
// process.
//-----------------------------------------------------------------------------
void IPCWriterInterface::DestroySecurityAttributes(SECURITY_ATTRIBUTES *pSA)
{
    // We'll take a NULL param just to be nice.
    if (pSA == NULL)
        return;

    // Don't destroy our cached SA!
    if (pSA == m_pSA)
        return;
    
    // Cleanup the DACL in the SD.
    SECURITY_DESCRIPTOR *pSD = (SECURITY_DESCRIPTOR*) pSA->lpSecurityDescriptor;

    if (pSD != NULL)
    {
        // Grab the DACL
        BOOL isDACLPresent = FALSE;
        BOOL isDefaultDACL = FALSE;
        ACL *pACL = NULL;
        
        BOOL res = GetSecurityDescriptorDacl(pSD, &isDACLPresent, &pACL, &isDefaultDACL);

        // If we got the DACL, then free the stuff inside of it.
        if (res && isDACLPresent && (pACL != NULL) && !isDefaultDACL)
        {
            for(int i = 0; i < pACL->AceCount; i++)
                DeleteAce(pACL, i);
                
            delete [] pACL;
        }

        // Free the SD from within the SA.
        free(pSD);
    }

    // Finally, free the SA.
    free(pSA);

    return;
}

//-----------------------------------------------------------------------------
// Have ctor zero everything out
//-----------------------------------------------------------------------------
IPCWriterImpl::IPCWriterImpl()
{
    // Cache pointers to sections
    m_pPerf      = NULL;
    m_pDebug     = NULL;
    m_pAppDomain = NULL;
    m_pService   = NULL;
    m_pMiniDump  = NULL;

    // Mem-Mapped file for Private Block
    m_handlePrivateBlock    = NULL;
    m_ptrPrivateBlock       = NULL;

    // Security
    m_pSA                   = NULL;
}

//-----------------------------------------------------------------------------
// Assert that everything was already shutdown by a call to terminate.
// Shouldn't be anything left to do in the dtor
//-----------------------------------------------------------------------------
IPCWriterImpl::~IPCWriterImpl()
{
    _ASSERTE(!IsPrivateBlockOpen());
}

//-----------------------------------------------------------------------------
// Creation / Destruction
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// Setup a security descriptor for the named kernel objects if we're on NT.
//-----------------------------------------------------------------------------
HRESULT IPCWriterImpl::CreateWinNTDescriptor(DWORD pid, SECURITY_ATTRIBUTES **ppSA)
{
    HRESULT hr = NO_ERROR;
    
    *ppSA = NULL;

    // Have we already created a SA for the current process? This is a common operation, so we cache that one SA and
    // return it here if we have it.
    if ((m_pSA != NULL) && (pid == GetCurrentProcessId()))
    {
        *ppSA = m_pSA;
    }
    else
    {
        hr = IPCShared::CreateWinNTDescriptor(pid, TRUE, ppSA);

        // Cache the SA for the current process
        if (pid == GetCurrentProcessId())
            m_pSA = *ppSA;
    }

    return hr;
}

//-----------------------------------------------------------------------------
// Helper: Open the private block. We expect that our members have been set
// by this point.
// Note that the private block is only created once, so it fails on 
// Already Exists.
// The private block is used by DebuggerRCThread::Init and PerfCounters::Init.
//-----------------------------------------------------------------------------



void IPCWriterImpl::WriteEntryHelper(EPrivateIPCClient eClient, DWORD size)
{
    // Don't use this helper on the first entry, since it looks at the entry before it
    _ASSERTE(eClient != 0);

    EPrivateIPCClient ePrev = (EPrivateIPCClient) ((DWORD) eClient - 1);

    m_ptrPrivateBlock->m_table[eClient].m_Offset = 
        m_ptrPrivateBlock->m_table[ePrev].m_Offset + 
        m_ptrPrivateBlock->m_table[ePrev].m_Size;

    m_ptrPrivateBlock->m_table[eClient].m_Size  = size;
}


//-----------------------------------------------------------------------------
// Initialize the header for our private IPC block
//-----------------------------------------------------------------------------
void IPCWriterImpl::CreatePrivateIPCHeader()
{
    // Stamp the IPC block with the version
    m_ptrPrivateBlock->m_header.m_dwVersion = VER_IPC_BLOCK;
    m_ptrPrivateBlock->m_header.m_blockSize = sizeof(PrivateIPCControlBlock);

    m_ptrPrivateBlock->m_header.m_hInstance = GetModuleInst();

    m_ptrPrivateBlock->m_header.m_BuildYear = BuildYear;
    m_ptrPrivateBlock->m_header.m_BuildNumber = BuildNumber;

    m_ptrPrivateBlock->m_header.m_numEntries = ePrivIPC_MAX;

    // Fill out directory (offset and size of each block)
    // @todo - find more efficient way to write this table. We have all knowledge at compile time.
    m_ptrPrivateBlock->m_table[ePrivIPC_PerfCounters].m_Offset = 0;
    m_ptrPrivateBlock->m_table[ePrivIPC_PerfCounters].m_Size    = sizeof(PerfCounterIPCControlBlock);

    // NOTE: these must appear in the exact order they are listed in PrivateIPCControlBlock or
    //       VERY bad things will happen.
    WriteEntryHelper(ePrivIPC_Debugger, sizeof(DebuggerIPCControlBlock));
    WriteEntryHelper(ePrivIPC_AppDomain, sizeof(AppDomainEnumerationIPCBlock));
    WriteEntryHelper(ePrivIPC_Service, sizeof(ServiceIPCControlBlock));
    WriteEntryHelper(ePrivIPC_ClassDump, sizeof(ClassDumpTableBlock));
    WriteEntryHelper(ePrivIPC_MiniDump, sizeof(MiniDumpBlock));

    // Cache our client pointers
    m_pPerf     = &(m_ptrPrivateBlock->m_perf);
    m_pDebug    = &(m_ptrPrivateBlock->m_dbg);
    m_pAppDomain= &(m_ptrPrivateBlock->m_appdomain);
    m_pService  = &(m_ptrPrivateBlock->m_svc);
    m_pMiniDump = &(m_ptrPrivateBlock->m_minidump);
}

//-----------------------------------------------------------------------------
// Initialize the header for our private IPC block
//-----------------------------------------------------------------------------
void IPCWriterImpl::OpenPrivateIPCHeader()
{
    // Cache our client pointers
    m_pPerf     = &(m_ptrPrivateBlock->m_perf);
    m_pDebug    = &(m_ptrPrivateBlock->m_dbg);
    m_pAppDomain= &(m_ptrPrivateBlock->m_appdomain);
    m_pService  = &(m_ptrPrivateBlock->m_svc);
    m_pMiniDump = &(m_ptrPrivateBlock->m_minidump);
}

DWORD IPCWriterInterface::GetBlockVersion()
{
    _ASSERTE(IsPrivateBlockOpen());
    return m_ptrPrivateBlock->m_header.m_dwVersion;
}

DWORD IPCWriterInterface::GetBlockSize()
{
    _ASSERTE(IsPrivateBlockOpen());
    return m_ptrPrivateBlock->m_header.m_blockSize;
}

HINSTANCE IPCWriterInterface::GetInstance()
{
    _ASSERTE(IsPrivateBlockOpen());
    return m_ptrPrivateBlock->m_header.m_hInstance;
}

USHORT IPCWriterInterface::GetBuildYear()
{
    _ASSERTE(IsPrivateBlockOpen());
    return m_ptrPrivateBlock->m_header.m_BuildYear;
}

USHORT IPCWriterInterface::GetBuildNumber()
{
    _ASSERTE(IsPrivateBlockOpen());
    return m_ptrPrivateBlock->m_header.m_BuildNumber;
}

PVOID IPCWriterInterface::GetBlockStart()
{
    return (PVOID) m_ptrPrivateBlock;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\ia64\alloc.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/
#ifndef _ALLOC_H_
#define _ALLOC_H_
/*****************************************************************************/
#ifndef _ERROR_H_
#include "error.h"
#endif
/*****************************************************************************/
#ifndef _HOST_H_
#ifndef BIRCH_SP2
#include"host.h"
#endif
#endif
/*****************************************************************************/

#pragma warning(disable:4200)

/*****************************************************************************/
#ifdef  NOT_JITC
/*****************************************************************************/

extern  void *    (__stdcall *JITgetmemFnc)(size_t size);
extern  void      (__stdcall *JITrlsmemFnc)(void *block);

inline
void *  __stdcall   VirtualAlloc(LPVOID addr, DWORD size,
                                              DWORD allocType,
                                              DWORD protect)
{
    assert(addr      == 0);
    assert(allocType == MEM_COMMIT);
    assert(protect   == PAGE_READWRITE);

    return  JITgetmemFnc(size);
}

inline
BOOL    __stdcall   VirtualFree (LPVOID addr, DWORD size,
                                              DWORD freeType)
{
    assert(size     == 0);
    assert(freeType == MEM_RELEASE);

    JITrlsmemFnc(addr);

    return FALSE;
}

/*****************************************************************************/
#else//!NOT_JITC
/*****************************************************************************/

#if OE_MAC

inline
void *  _cdecl      VirtualAlloc(LPVOID addr, DWORD size,
                                              DWORD allocType,
                                              DWORD protect)
{
    assert(addr      == 0);
    assert(allocType == MEM_COMMIT);
    assert(protect   == PAGE_READWRITE);

    return  MemAlloc(size);
}

inline
BOOL    _cdecl      VirtualFree (LPVOID addr, DWORD size,
                                              DWORD freeType)
{
    assert(size     == 0);
    assert(freeType == MEM_RELEASE);

    MemFree(addr);

    return FALSE;
}

#define _OS_COMMIT_ALLOC    0

#else

#define _OS_COMMIT_ALLOC    1

#endif

/*****************************************************************************/

struct commitAllocator
{
    void            cmaInit (size_t iniSize, size_t incSize, size_t maxSize);
    bool            cmaInitT(size_t iniSize, size_t incSize, size_t maxSize);

    void            cmaFree(void);
    void            cmaDone(void);

    void    *       cmaGetm(size_t sz)
    {
        void    *   temp = cmaNext;

        assert((sz & (sizeof(int) - 1)) == 0);

        cmaNext += sz;

        if  (cmaNext > cmaLast)
            temp = cmaMore(sz);

        return  temp;
    }

    void    *       cmaGetBase(void) const { return (void *)cmaBase; }
    size_t          cmaGetSize(void) const { return cmaNext - cmaBase; }
#ifdef DEBUG
    size_t          cmaGetComm(void) const { return cmaLast - cmaBase; }
#endif

private:

    void    *       cmaMore(size_t sz);

    bool            cmaRetNull;         // OOM returns NULL (longjmp otherwise)

    size_t          cmaIncSize;
    size_t          cmaMaxSize;

    BYTE    *       cmaBase;
    BYTE    *       cmaNext;
    BYTE    *       cmaLast;
};

/*****************************************************************************/

struct fixed_allocator
{
    void            fxaInit(size_t blockSize, size_t initPageSize =   OS_page_size,
                                              size_t incrPageSize = 4*OS_page_size);
    void            fxaFree(void);
    void            fxaDone(void);

private:

    struct fixed_pagdesc
    {
        fixed_pagdesc * fxpPrevPage;
        BYTE            fxpContents[];
    };

    fixed_pagdesc * fxaLastPage;

    BYTE    *       fxaFreeNext;    // these two (when non-zero) will
    BYTE    *       fxaFreeLast;    // always point into 'fxaLastPage'

    void    *       fxaFreeList;

    size_t          fxaBlockSize;

    size_t          fxaInitPageSize;
    size_t          fxaIncrPageSize;

    void    *       fxaAllocNewPage(void);
    void    *       fxaGetFree(size_t size);

public:

    void    *       fxaGetMem(size_t size)
    {
        void    *   block;

        assert(size == fxaBlockSize);

        block = fxaFreeNext;
                fxaFreeNext += size;

        if  (fxaFreeNext > fxaFreeLast)
            block = fxaGetFree(size);

        return  block;
    }

    void            fxaRlsMem(void *block)
    {
        *(void **)block = fxaFreeList;
                          fxaFreeList = block;
    }
};

/*****************************************************************************/
#endif//!NOT_JITC
/*****************************************************************************/

struct nraMarkDsc
{
    void    *       nmPage;
    BYTE    *       nmNext;
    BYTE    *       nmLast;
};

struct norls_allocator
{
    bool            nraInit (size_t pageSize = 0, int preAlloc = 0);
    bool            nraStart(size_t initSize,
                             size_t pageSize = 0);

    void            nraFree (void);
    void            nraDone (void);

private:

    struct norls_pagdesc
    {
        norls_pagdesc * nrpNextPage;
        norls_pagdesc * nrpPrevPage;
#ifndef NDEBUG
        void    *       nrpSelfPtr;
#endif
        size_t          nrpPageSize;    // # of bytes allocated
        size_t          nrpUsedSize;    // # of bytes actually used
        BYTE            nrpContents[];
    };

    norls_pagdesc * nraPageList;
    norls_pagdesc * nraPageLast;

    bool            nraRetNull;         // OOM returns NULL (longjmp otherwise)

    BYTE    *       nraFreeNext;        // these two (when non-zero) will
    BYTE    *       nraFreeLast;        // always point into 'nraPageLast'

    size_t          nraPageSize;

    void    *       nraAllocNewPage(size_t sz);

public:

    void    *       nraAlloc(size_t sz);

    /* The following used for mark/release operation */

    void            nraMark(nraMarkDsc &mark)
    {
        mark.nmPage = nraPageLast;
        mark.nmNext = nraFreeNext;
        mark.nmLast = nraFreeLast;
    }

private:

    void            nraToss(nraMarkDsc &mark);

public:

    void            nraRlsm(nraMarkDsc &mark)
    {
        if (nraPageLast != mark.nmPage)
        {
            nraToss(mark);
        }
        else
        {
            nraFreeNext = mark.nmNext;
            nraFreeLast = mark.nmLast;
        }
    }

    size_t          nraTotalSizeAlloc();
    size_t          nraTotalSizeUsed ();

    /* The following used to visit all of the allocated pages */

    void    *       nraPageWalkerStart();
    void    *       nraPageWalkerNext (void *page);

    void    *       nraPageGetData(void *page);
    size_t          nraPageGetSize(void *page);
};

#if !defined(DEBUG) && !defined(BIRCH_SP2)

inline
void    *           norls_allocator::nraAlloc(size_t sz)
{
    void    *   block;

    block = nraFreeNext;
            nraFreeNext += sz;

    if  (nraFreeNext > nraFreeLast)
        block = nraAllocNewPage(sz);

    return  block;
}

#endif

/*****************************************************************************/
#ifndef NOT_JITC
/*****************************************************************************
 *
 *  Blocks no larger than the value of "small_block_max_size" are
 *  allocated from the small block allocator (they are all fixed
 *  size). This consists merely of a set of pages with fixed-size
 *  blocks, and uses a singly-linked list of free blocks. All used
 *  blocks have an offset to the containing page at their base to
 *  quickly locate the page they live in when they are freed.
 */

struct block_allocator;

const size_t        small_block_max_size = 4*sizeof(void*) - sizeof(short);

struct small_block_allocator
{
    friend  struct  block_allocator;

private:

    #pragma pack(push, 2)

    struct small_blkdesc
    {
        union
        {
            struct
            {
                unsigned short  sbdOffs;
                BYTE            sbdCont[];
            }
                    sbdUsed;

            struct
            {
                unsigned short  sbdOffs;
                small_blkdesc * sbdNext;
            }
                    sbdFree;
        };
    };

    #pragma pack(pop)

    size_t          sbaBlockSize;

    struct small_pagdesc
    {
        small_pagdesc *     spdNext;
        unsigned            spdSize;
        small_blkdesc *     spdFree;
#ifndef NDEBUG
        small_pagdesc *     spdThis;        // points to itself
#endif
        small_blkdesc       spdCont[];
    };

    size_t          sbaPageSize;
    small_pagdesc * sbaPageList;

    char    *       sbaFreeNext;
    char    *       sbaFreeLast;

    void    *       sbaAllocBlock(void);

    void            sbaInitPageDesc(small_pagdesc *page);

    unsigned        sbaInitLvl;

    unsigned        sbaIdMask;

public:

#ifdef DEBUG
    size_t          sizeAllocated;          // to track memory consumption
    size_t          pageAllocated;          // to track memory consumption
#endif

    bool            sbaIsMyBlock(void *block)
    {
        assert(offsetof(small_blkdesc, sbdUsed.sbdOffs) + sizeof(short) ==
               offsetof(small_blkdesc, sbdUsed.sbdCont));

        return  (bool)(((((unsigned short *)block)[-1]) & 3U) == sbaIdMask);
    }

    small_block_allocator()
    {
        sbaInitLvl = 0;
    }

    void            sbaInit (unsigned    idMask,
                             size_t      blockSize,
                             size_t       pageSize = OS_page_size);
    void            sbaDone (void);

    void    *       sbaAlloc(void);
    void            sbaFree (void *block);
};

/*---------------------------------------------------------------------------*/

inline
void    *           small_block_allocator::sbaAlloc(void)
{
    small_blkdesc * block;

#ifdef DEBUG
    sizeAllocated = sbaBlockSize;
#endif

    block = (small_blkdesc *)sbaFreeNext;
                             sbaFreeNext += sbaBlockSize;

    if  (sbaFreeNext <= sbaFreeLast)
    {
        block->sbdUsed.sbdOffs = ((char *)block - (char *)sbaPageList) | sbaIdMask;

        return  block->sbdUsed.sbdCont;
    }
    else
        return  sbaAllocBlock();
}

inline
void                small_block_allocator::sbaFree(void *block)
{
    small_blkdesc * blockPtr;
    small_pagdesc *  pagePtr;

    assert(sbaInitLvl);

    /* Compute the real address of the block and page descriptor */

    blockPtr = (small_blkdesc *)((char *)block - offsetof(small_blkdesc, sbdUsed.sbdCont));
     pagePtr = (small_pagdesc *)((char *)blockPtr - (blockPtr->sbdUsed.sbdOffs & ~3));

    /* Make sure we're working with a reasonable pointer */

    assert(pagePtr->spdThis == pagePtr);

    /* Now insert this block in the free list */

    blockPtr->sbdFree.sbdNext = pagePtr->spdFree;
                    pagePtr->spdFree = blockPtr;
}

/*---------------------------------------------------------------------------*/

typedef struct small_block_allocator   small_allocator;

/*****************************************************************************
 *
 *  Blocks larger than the value of "small_block_max_size" are
 *  allocated from the large block allocator. This is a pretty
 *  vanilla allocator where each block contains a 'short' field
 *  that gives its offset from the page the block lives in. In
 *  addition, there is always an 'unsigned short' size field,
 *  with the lowest bit set for used blocks. Note that all of
 *  the page offset fields for large blocks have the lowest bit
 *  set, so that we can distinguish between 'small' and 'large'
 *  allocations (when random-sized blocks are freed via the
 *  generic 'block_allocator'). For this to work, the 'offset'
 *  field must also be right before the client area of every
 *  used block.
 *
 *  All free blocks are linked together on a linked list.
 */

struct large_block_allocator
{
    friend  struct  block_allocator;

    /* Every allocation will be a multiple of 'LBA_SIZE_INC' */

#define LBA_SIZE_INC    16

private:

    struct large_blkdesc
    {
        union
        {
            struct
            {
                unsigned int    lbdSize;
                unsigned short  lbdOffsHi;
                unsigned short  lbdOffsLo;
                BYTE            lbdCont[];
            }
                    lbdUsed;

            struct
            {
                unsigned int    lbdSize;
                unsigned short  lbdOffsHi;
                unsigned short  lbdOffsLo;
                large_blkdesc * lbdNext;
            }
                    lbdFree;
        };
    };

#define LBA_OVERHEAD    (offsetof(large_blkdesc, lbdUsed.lbdCont))

    static
    inline  size_t  lbaTrueBlockSize(size_t sz)
    {
        return  (sz + LBA_OVERHEAD + LBA_SIZE_INC - 1) & ~(LBA_SIZE_INC - 1);
    }

    struct large_pagdesc
    {
        large_pagdesc * lpdNext;
        large_pagdesc * lpdPrev;
#ifndef NDEBUG
        large_pagdesc * lpdThis;    // points to itself
#endif
        size_t          lpdPageSize;
        large_blkdesc * lpdFreeList;
        size_t          lpdFreeSize;

        unsigned short  lpdUsedBlocks;
        unsigned char   lpdCouldMerge;

        large_blkdesc   lpdCont[];
    };

    size_t          lbaPageSize;
    large_pagdesc * lbaPageList;
    large_pagdesc * lbaPageLast;

    char    *       lbaFreeNext;
    char    *       lbaFreeLast;

    unsigned        lbaInitLvl;

    /* Used blocks are marked by setting the low bit in the size field */

    static
    void            markBlockUsed(large_blkdesc *block)
    {
        block->lbdUsed.lbdSize |= 1;
    }

    static
    void            markBlockFree(large_blkdesc *block)
    {
        block->lbdUsed.lbdSize &= ~1;
    }

    static
    size_t          blockSizeFree(large_blkdesc *block)
    {
        assert(isBlockUsed(block) == false);

        return  block->lbdUsed.lbdSize;
    }

    static
    bool          isBlockUsed(large_blkdesc *block)
    {
        return  ((bool)(block->lbdUsed.lbdSize & 1));
    }

    static
    size_t          blockSizeUsed(large_blkdesc *block)
    {
        assert(isBlockUsed(block) == true);

        return  block->lbdUsed.lbdSize & ~1;
    }

    void            lbaAddFreeBlock(void *          p,
                                    size_t          sz,
                                    large_pagdesc * page);

    bool            lbaIsMyBlock(void *block)
    {
        assert(offsetof(large_blkdesc, lbdUsed.lbdOffsLo) + sizeof(short) ==
               offsetof(large_blkdesc, lbdUsed.lbdCont));

        return  (bool)((((short *)block)[-1] & 3) == 0);
    }

    static
    large_pagdesc * lbaBlockToPage(large_blkdesc *block)
    {
#ifdef DEBUG
        large_pagdesc * page = (large_pagdesc *)((char *)block - block->lbdUsed.lbdOffsLo - (block->lbdUsed.lbdOffsHi << 16) + 1);

        assert(page->lpdThis == page);

        return  page;
#else
        return  (large_pagdesc *)((char *)block - block->lbdUsed.lbdOffsLo - (block->lbdUsed.lbdOffsHi << 16) + 1);
#endif
    }

#ifdef DEBUG
    size_t          sizeAllocated;      // to track memory consumption
    size_t          pageAllocated;      // to track memory consumption
#endif

public:

    large_block_allocator()
    {
        lbaInitLvl = 0;
    }

    void            lbaInit(size_t pageSize = 4*OS_page_size);

    void            lbaDone(void)
    {
        large_pagdesc * page;
        large_pagdesc * temp;

//      printf("=======================lbaDone(%u -> %u)\n", lbaInitLvl, lbaInitLvl-1);

        assert((int)lbaInitLvl > 0);

        if  (--lbaInitLvl)
            return;

        page = lbaPageList;

        while   (page)
        {
            temp = page;
                   page = page->lpdNext;

            VirtualFree(temp, 0, MEM_RELEASE);
        }

        lbaPageList =
        lbaPageLast = 0;

        lbaFreeNext =
        lbaFreeLast = 0;
    }

    void    *       lbaAlloc (size_t sz);
    void            lbaFree  (void *block);
    bool            lbaShrink(void *block, size_t sz);

private:

    void    *       lbaAllocMore(size_t sz);
};

/*---------------------------------------------------------------------------*/

typedef struct large_block_allocator   large_allocator;

/*****************************************************************************
 *
 *  This is a generic block allocator. It's a simple wrapper around
 *  the 'small' and 'large' block allocators, and it delegates all
 *  requests to these allocators as appropriate.
 */

#if 1
#define SMALL_MAX_SIZE_1    ( 4 * sizeof(int) - sizeof(short))
#define SMALL_MAX_SIZE_2    ( 6 * sizeof(int) - sizeof(short))
#define SMALL_MAX_SIZE_3    ( 8 * sizeof(int) - sizeof(short))
#else
#define SMALL_MAX_SIZE_1    ( 4 * sizeof(int) - sizeof(short))
#define SMALL_MAX_SIZE_2    ( 8 * sizeof(int) - sizeof(short))
#define SMALL_MAX_SIZE_3    (16 * sizeof(int) - sizeof(short))
#endif

struct block_allocator
{
    small_allocator baSmall[3];
    large_allocator baLarge;

#ifdef DEBUG
    unsigned        totalCount;
    unsigned        sizeCounts[100];
    unsigned        sizeLarger;
    unsigned        smallCnt0;
    unsigned        smallCnt1;
    unsigned        smallCnt2;
    unsigned        largeCnt;
    size_t          sizeAlloc;
    size_t          pageAlloc;
    size_t          sizeTotal;
#endif

    void            baInit(size_t smallPageSize =  4*OS_page_size,
                           size_t largePageSize = 16*OS_page_size,
                           size_t largeBuckSize =  0*64);
    void            baDone(void);

private:

    void    *       baGetM(size_t size);        // out of memory -> calls longjmp
    void    *       baGet0(size_t size);        // out of memory -> returns NULL

    void            baRlsM(void *block);

public:

    void    *       baAlloc      (size_t size);
    void    *       baAllocOrNull(size_t size);
    void            baFree       (void *block);

#ifdef DEBUG
    void            baDispAllocStats(void);
#endif

    bool            baShrink(void *block, size_t sz);
};

/*---------------------------------------------------------------------------*/

inline
void                block_allocator::baInit(size_t smallPageSize,
                                            size_t largePageSize,
                                            size_t largeBuckSize)
{
    baSmall[0].sbaInit(1, SMALL_MAX_SIZE_1, smallPageSize);
    baSmall[1].sbaInit(2, SMALL_MAX_SIZE_2, smallPageSize);
    baSmall[2].sbaInit(3, SMALL_MAX_SIZE_3, smallPageSize);

#ifdef DEBUG
    memset(&sizeCounts, 0, sizeof(sizeCounts));
    totalCount = 0;
    sizeLarger = 0;
    smallCnt0  = 0;
    smallCnt1  = 0;
    smallCnt2  = 0;
    largeCnt   = 0;
    sizeAlloc  = 0;
    pageAlloc  = 0;
    sizeTotal  = 0;
#endif

    baLarge.lbaInit(largePageSize);
}

inline
void                block_allocator::baDone(void)
{
    baSmall[0].sbaDone();
    baSmall[1].sbaDone();
    baSmall[2].sbaDone();
    baLarge   .lbaDone();
}

inline
bool                block_allocator::baShrink(void *block, size_t sz)
{
    assert((int)baSmall[0].sbaIsMyBlock(block) != 0 +
           (int)baSmall[1].sbaIsMyBlock(block) != 0 +
           (int)baSmall[2].sbaIsMyBlock(block) != 0 +
           (int)baLarge   .lbaIsMyBlock(block) != 0 == 1);

    if  (baLarge.lbaIsMyBlock(block))
        return  baLarge.lbaShrink(block, sz);
    else
        return  false;
}

/*---------------------------------------------------------------------------*/
#ifdef DEBUG

extern
void                checkForMemoryLeaks();

#else

/* The non-debug case: map into calls of the non-debug routines */

inline
void    *           block_allocator::baAlloc      (size_t size)
{
    return baGetM(size);
}

inline
void    *           block_allocator::baAllocOrNull(size_t size)
{
    return baGet0(size);
}

inline
void                block_allocator::baFree       (void *block)
{
    baRlsM(block);
}

#endif

/*****************************************************************************/
#endif//!NOT_JITC
/*****************************************************************************
 * If most uses of the norls_alloctor are going to be non-simultaneous,
 * we keep a single instance handy and preallocate 1 page.
 * Then if most uses wont need to call VirtualAlloc() for the first page.
 */

void                nraInitTheAllocator();  // One-time initialization
void                nraTheAllocatorDone();  // One-time completion code

// returns NULL if the single instance is already in use.
// User will need to allocate a new instance of the norls_allocator

norls_allocator *   nraGetTheAllocator();

// Should be called after we are done with the current use, so that the
// next user can reuse it, instead of allocating a new instance

void                nraFreeTheAllocator();

/*****************************************************************************/
#endif
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\ia64\alloc.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/

#include "jitpch.h"
#pragma hdrstop

/*****************************************************************************/

#include "alloc.h"

/*****************************************************************************/
void                allocatorCodeSizeBeg(){}
/*****************************************************************************/
#ifdef  DEBUG
/*****************************************************************************/

void    __cdecl     debugStop(const char *why, ...)
{
    va_list     args; va_start(args, why);

#ifndef _WIN32_WCE

    printf("NOTIFICATION: ");
    if  (why)
        vprintf(why, args);
    else
        printf("debugStop(0)");

    printf("\n");

#endif

    BreakIfDebuggerPresent();
}

/*****************************************************************************/

static  unsigned    blockStop    = 99999999;

/*****************************************************************************/
#endif//DEBUG
/*****************************************************************************/
#ifndef NOT_JITC
/*****************************************************************************/
#ifdef  DEBUG
/*****************************************************************************/

static  unsigned    allocCounter;
extern  unsigned    allocCntStop = 99999999;

/*---------------------------------------------------------------------------*/

struct  allocTab
{
    allocTab *      atNext;
    void    *       atAlloc;
};

static  allocTab *  allocatorTable;

static  allocTab *  getAllocatorEntry(void *alloc)
{
    allocTab *  temp;

    for (temp = allocatorTable; temp; temp = temp->atNext)
    {
        if  (temp->atAlloc == alloc)
            return  temp;
    }

    temp = (allocTab *)malloc(sizeof(*temp));   // it's OK, don't worry ...

    temp->atAlloc = alloc;
    temp->atNext  = allocatorTable;
                    allocatorTable = temp;

    return  temp;
}

/*---------------------------------------------------------------------------*/

struct  blkEntry
{
    blkEntry    *   beNext;
    void        *   beAddr;
    allocTab    *   beAlloc;
    size_t          beSize;
    unsigned        beTime;
};

#define BLOCK_HASH_SIZE (16*1024)

static  blkEntry *      blockHash[BLOCK_HASH_SIZE];
static  blkEntry *      blockFree;
static  fixed_allocator blockTabAlloc;

static  struct  initAllocTables
{
    initAllocTables()
    {
        memset(blockHash, 0, sizeof(blockHash));
        blockFree = 0;
        blockTabAlloc.fxaInit(sizeof(blkEntry));

        allocCounter = 0;
    }
}
    initAllocTables;

/*---------------------------------------------------------------------------*/

static  unsigned    blockHashFunc(void *block)
{
    return  (((unsigned)block & 0xFFFF) * ((unsigned)block >> 16));
}

/*---------------------------------------------------------------------------*/

static  size_t      registerMemAlloc(allocTab *alloc,
                                     void     *addr,
                                     size_t    size)
{
    unsigned    hashVal = blockHashFunc(addr) % BLOCK_HASH_SIZE;

    blkEntry ** hashLast;
    blkEntry *  hashThis;

    hashLast = blockHash + hashVal;

    for (;;)
    {
        hashThis = *hashLast;
        if  (!hashThis)
            break;

        if  (hashThis->beAddr == addr)
        {
            /* Matching address -- are we adding or removing? */

            if  (size)
                assert(!"two allocations at the same address!");

            /* Save the size so that we can return it */

            size = hashThis->beSize;

            /* Unlink this block entry from the hash table */

            *hashLast = hashThis->beNext;

            /* Add the freed up entry to the free list */

            hashThis->beNext = blockFree;
                               blockFree = hashThis;

            /* Return the block size to the caller */

            return  size;
        }

        hashLast = &hashThis->beNext;
    }

    /* Entry not found -- this better be a new allocation */

    if  (!size)
    {
        printf("Free bogus block at %08X\n", addr);
        assert(!"freed block not found in block table");
    }

    /* Grab a new block entry */

    if  (blockFree)
    {
        hashThis = blockFree;
                   blockFree = hashThis->beNext;
    }
    else
    {
        hashThis = (blkEntry *)blockTabAlloc.fxaGetMem(sizeof(*hashThis));
    }

    /* Fill in the block descriptor */

    hashThis->beAlloc = alloc;
    hashThis->beAddr  = addr;
    hashThis->beSize  = size;
    hashThis->beTime  = allocCounter;

    /* Insert this entry into the hash table */

    hashThis->beNext  = blockHash[hashVal];
                        blockHash[hashVal] = hashThis;

    return  0;
}

/*---------------------------------------------------------------------------*/

block_allocator     GlobalAllocator; // TODO : Was this used by jvc.

static  void        recordBlockAlloc(void     *alloc,
                                     void     *addr,
                                     size_t    size)
{
    allocTab *  adesc;

    /* Bail if we're not monitoring the allocators */

    if  (!memChecks)
        return;

    /* Only the global allocator is interesting */

    if  (alloc != &GlobalAllocator)
        return;

    /* Count this as an allocator event */

    if  (++allocCounter == allocCntStop) debugStop("allocation event");

    /* Locate/create the appropriate allocator entry */

    adesc = getAllocatorEntry(alloc); assert(adesc);

    /* Add this block to the allocation table */

    registerMemAlloc(adesc, addr, size);
}

static  void        recordBlockFree (void * alloc,
                                     void * addr)
{
    allocTab *  adesc;
    size_t      size;

    /* Bail if we're not monitoring the allocators */

    if  (!memChecks)
        return;

    /* Only the global allocator is interesting */

    if  (alloc != &GlobalAllocator)
        return;

    /* Count this as an allocator event */

    if  (++allocCounter == allocCntStop) debugStop("allocation event");

    /* Locate/create the appropriate allocator entry */

    adesc = getAllocatorEntry(alloc); assert(adesc);

    /* Get the block size and verify the block */

    size  = registerMemAlloc(adesc, addr, 0);
}

/*---------------------------------------------------------------------------*/

void            checkForMemoryLeaks()
{
    unsigned    hashVal;
    bool        hadLeaks = false;

    for (hashVal = 0; hashVal < BLOCK_HASH_SIZE; hashVal++)
    {
        blkEntry *      hashLst;

        for (hashLst = blockHash[hashVal];
             hashLst;
             hashLst = hashLst->beNext)
        {
            printf("Leak @ %6u from ", hashLst->beTime);

            printf("[%08X] ");

            printf(": %4u bytes at %08X\n", hashLst->beSize,
                                            hashLst->beAddr);

            hadLeaks = true;
        }
    }

    if  (hadLeaks)
        assert(!"memory leaked!");
}

/*****************************************************************************/
#endif
/*****************************************************************************
 *
 *  Initialize a committing allocator. If uncommitted (win32-style) memory
 *  management is supported by our host OS, the parameters have the following
 *  meaning:
 *
 *      iniSize ... ignored
 *
 *      incSize ... how much more memory to commit each time we run
 *                  out of space (0 --> use a reasonable default)
 *
 *      maxSize ... gives the max. size we'll ever need to allocate
 *
 *  If the host OS doesn't support uncommitted memory allocation (e.g. we're
 *  on the MAC), the parameters are interpreted as follows:
 *
 *      iniSize ... initial allocation (0 --> use a reasonable default)
 *
 *      incSize ... if non-zero, indicates how much to grow the allocation
 *                  when we run out of space; if 0, allocation will double
 *                  whenever space is exhausted
 *
 *      maxSize ... ignored
 */

bool        commitAllocator::cmaInitT(size_t iniSize,
                                      size_t incSize,
                                      size_t maxSize)
{
    cmaRetNull = true;

#if _OS_COMMIT_ALLOC

    assert(maxSize);

    maxSize +=  (OS_page_size - 1);
    maxSize &= ~(OS_page_size - 1);

    cmaMaxSize = maxSize;
    cmaIncSize = incSize ? incSize
                         : 2*OS_page_size;

    /* Grab max. logical space but don't commit anything yet */

    cmaBase =
    cmaNext =
    cmaLast = (BYTE *)VirtualAlloc(0, maxSize, MEM_RESERVE, PAGE_READWRITE);
    if  (!cmaBase)
        return true;

#else

    cmaIncSize = incSize;

    /* Make sure the initial size is reasonable */

    if  (iniSize)
    {
        iniSize +=  (OS_page_size - 1);
        iniSize &= ~(OS_page_size - 1);
    }
    else
    {
        iniSize = OS_page_size;
    }

    cmaBase =
    cmaNext = (BYTE *)VirtualAlloc(0, iniSize, MEM_COMMIT , PAGE_READWRITE);
    if  (!cmaBase)
        return true;

    cmaLast = cmaBase + iniSize;

#endif

    return false;
}

void        commitAllocator::cmaInit(size_t iniSize,
                                     size_t incSize,
                                     size_t maxSize)
{
    if  (cmaInitT(iniSize, incSize, maxSize))
        error(ERRnoMemory);

    cmaRetNull = false;
}

/*****************************************************************************
 *
 *  This function gets called by caAlloc when it runs out of space. It
 *  keeps committing more memory until we have enough room for the
 *  attempted allocation.
 */

void    *   commitAllocator::cmaMore(size_t sz)
{
    /* Undo the increment done in caGetm() */

    cmaNext -= sz;

#if _OS_COMMIT_ALLOC

    /* Keep grabbing more memory until we succeed */

    for (;;)
    {
        size_t      sizeInc;
        size_t      sizeCur = cmaLast - cmaBase;

        /* Figure out how much more memory to commit */

        sizeInc = cmaIncSize;
        if  (sizeCur + sizeInc > cmaMaxSize)
            sizeInc = cmaMaxSize - sizeCur;

        assert(sizeInc);

        /* Commit a few more memory pages */

        if  (!VirtualAlloc(cmaLast, sizeInc, MEM_COMMIT, PAGE_READWRITE))
        {
            if  (cmaRetNull)
                return 0;

            error(ERRnoMemory);
        }

#ifdef DEBUG
        memset(cmaLast, 0xDD, sizeInc);
#endif

        /* Bump the last available byte pointer */

        cmaLast += sizeInc;

        /* Do we have enough room now? */

        if  (cmaNext + sz <= cmaLast)
        {
            void    *   temp;

            temp = cmaNext;
                   cmaNext += sz;

            return  temp;
        }
    }

#else

    /* Figure out how much more memory to allocate */

    BYTE    *   baseNew;
    size_t      sizeNew;
#ifdef DEBUG
    size_t      sizeInc;
#endif
    size_t      sizeCur = cmaLast - cmaBase;

    sizeNew = cmaIncSize;
    if  (!sizeNew)
        sizeNew = sizeCur;
#ifdef DEBUG
    sizeInc  = sizeNew;             // remember how much more we're grabbing
#endif
    sizeNew += sizeCur;

    /* Allocate the new, larger block */

    baseNew = (BYTE *)VirtualAlloc(0, sizeNew, MEM_COMMIT, PAGE_READWRITE);
    if  (!baseNew)
        error(ERRnoMemory);

    /* Copy the old block to the new one */

    memcpy(baseNew, cmaBase, sizeCur);

    /* Release the old block, it's no longer needed */

    VirtualFree(cmaBase, 0, MEM_RELEASE);

    /* Update the various pointers */

    cmaNext += baseNew - cmaBase;
    cmaBase  = baseNew;
    cmaLast  = baseNew + sizeNew;

#ifdef DEBUG
    memset(cmaNext, 0xDD, sizeInc);
#endif

    return  cmaGetm(sz);

#endif

}

void        commitAllocator::cmaDone(void)
{

#if _OS_COMMIT_ALLOC

    /* Decommit any extra memory we've allocated */

#if 0

    printf("Unused committed space: %u bytes\n", cmaLast - cmaNext);

    if  (cmaLast != cmaBase)
        VirtualAlloc(0, cmaLast - cmaBase, MEM_DECOMMIT, 0);

#endif

#else

    // ISSUE: is it worth shrinking the block? Not likely .....

#endif

}

void        commitAllocator::cmaFree(void)
{
    VirtualFree(cmaBase, 0, MEM_RELEASE);

    cmaBase =
    cmaNext =
    cmaLast = 0;
}

/*****************************************************************************/

void        fixed_allocator::fxaInit(size_t blockSize, size_t initPageSize,
                                                       size_t incrPageSize)
{
    assert((blockSize & (sizeof(int) - 1)) == 0);
    assert(blockSize <= initPageSize - offsetof(fixed_pagdesc, fxpContents));
    assert(initPageSize <= incrPageSize);

    fxaBlockSize    = blockSize;

    fxaInitPageSize = initPageSize;
    fxaIncrPageSize = incrPageSize;

    fxaLastPage     = 0;

    fxaFreeNext     =
    fxaFreeLast     = 0;

    fxaFreeList     = 0;
}

#if 0

void        fixed_allocator::fxaDone(void)
{
    if  (fxaLastPage)
    {
        while   (fxaLastPage->fxpPrevPage)
        {
            fixed_pagdesc * temp;

            temp = fxaLastPage;
                   fxaLastPage = temp->fxpPrevPage;

            assert(!"UNDONE: remove free list entries that belong to this page");

            VirtualFree(temp, 0, MEM_RELEASE);
        }

        /* We're back to only having the initial page */

        fxaFreeNext  = fxaLastPage->fxpContents;
        fxaFreeLast  = (BYTE *)fxaLastPage + fxaInitPageSize;
    }
}

#endif

void    *   fixed_allocator::fxaGetFree(size_t size)
{
    void *  block;

    /* Undo the "+=" done in fxaGetMem() */

    fxaFreeNext -= size;

    if  (fxaFreeList)
    {
        block = fxaFreeList;
                fxaFreeList = *(void **)block;
    }
    else
    {
        block = fxaAllocNewPage();
    }

    return  block;
}

void        fixed_allocator::fxaFree(void)
{
    while   (fxaLastPage)
    {
        fixed_pagdesc * temp;

        temp = fxaLastPage;
               fxaLastPage = temp->fxpPrevPage;

        VirtualFree(temp, 0, MEM_RELEASE);
    }
}

void    *   fixed_allocator::fxaAllocNewPage(void)
{
    size_t      newSize;
    fixed_pagdesc * newPage;

    /* First page is 'initPageSize' bytes, later ones are 'incrPageSize' bytes */

    newSize = fxaLastPage ? fxaIncrPageSize
                          : fxaInitPageSize;

    newPage = (fixed_pagdesc *)VirtualAlloc(0, newSize, MEM_COMMIT, PAGE_READWRITE);
    if  (!newPage)
        error(ERRnoMemory);


    newPage->fxpPrevPage = fxaLastPage;
                           fxaLastPage = newPage;

    fxaFreeNext  = newPage->fxpContents + fxaBlockSize;
    fxaFreeLast  = (BYTE *)newPage + newSize;

    return  newPage->fxpContents;
}

/*****************************************************************************/
#endif//!NOT_JITC
/*****************************************************************************/

bool        norls_allocator::nraInit(size_t pageSize, int preAlloc)
{
    bool    result = false;

    nraRetNull   = true;

    nraPageList  =
    nraPageLast  = 0;

    nraFreeNext  =
    nraFreeLast  = 0;

    nraPageSize  = pageSize ? pageSize
                            : 4*OS_page_size;

    if  (preAlloc)
    {
        /* Grab the initial page(s) */

        setErrorTrap()  // ERROR TRAP: Start normal block
        {
            nraAllocNewPage(0);
        }
        impJitErrorTrap()  // ERROR TRAP: The following block handles errors
        {
            result = true;
        }
        endErrorTrap()  // ERROR TRAP: End
    }

    return  result;
}

bool        norls_allocator::nraStart(size_t initSize, size_t pageSize)
{
    /* Add the page descriptor overhead to the required size */

    initSize += offsetof(norls_pagdesc, nrpContents);

    /* Round the initial size to a OS page multiple */

    initSize +=  (OS_page_size - 1);
    initSize &= ~(OS_page_size - 1);

    /* Initialize the allocator by allocating one big page */

    if  (nraInit(initSize))
        return  true;

    /* Now go back to the 'true' page size */

    nraPageSize  = pageSize ? pageSize
                            : 4*OS_page_size;

    return  false;
}

/*---------------------------------------------------------------------------*/

void    *   norls_allocator::nraAllocNewPage(size_t sz)
{
    norls_pagdesc * newPage;
    size_t          sizPage;

    /* Do we have a page that's now full? */

    if  (nraPageLast)
    {
        /* Undo the "+=" done in nraAlloc() */

        nraFreeNext -= sz;

        /* Save the actual used size of the page */

        nraPageLast->nrpUsedSize = nraFreeNext - nraPageLast->nrpContents;
    }

    /* Make sure we grab enough to satisfy the allocation request */

    sizPage = nraPageSize;

    if  (sizPage < sz + sizeof(norls_pagdesc))
    {
        /* The allocation doesn't fit in a default-sized page */

#ifdef  DEBUG
//      if  (nraPageLast) printf("NOTE: wasted %u bytes in last page\n", nraPageLast->nrpPageSize - nraPageLast->nrpUsedSize);
#endif

        sizPage = sz + sizeof(norls_pagdesc);
    }

    /* Round to the nearest multiple of OS page size */

    sizPage +=  (OS_page_size - 1);
    sizPage &= ~(OS_page_size - 1);

    /* Allocate the new page */

    newPage = (norls_pagdesc *)VirtualAlloc(0, sizPage, MEM_COMMIT, PAGE_READWRITE);
    if  (!newPage)
        NOMEM();

#if 0
#ifdef DEBUG

    if  (this == &stmt_cmp::scAlloc)
        printf("StmtCmp");
    else if (this == &stmtExpr::sxAlloc)
        printf("StmtExp");
    else
        printf("Other  ");

    printf(": get  page at %08X (%u bytes)\n", newPage, nraPageSize);

#endif
#endif

#ifndef NDEBUG
    newPage->nrpSelfPtr = newPage;
#endif

    /* Append the new page to the end of the list */

    newPage->nrpNextPage = 0;
    newPage->nrpPageSize = sizPage;
    newPage->nrpPrevPage = nraPageLast;

    if  (nraPageLast)
        nraPageLast->nrpNextPage = newPage;
    else
        nraPageList              = newPage;
    nraPageLast = newPage;

    /* Set up the 'next' and 'last' pointers */

    nraFreeNext = newPage->nrpContents + sz;
    nraFreeLast = newPage->nrpPageSize + (BYTE *)newPage;

    assert(nraFreeNext <= nraFreeLast);

    return  newPage->nrpContents;
}

void        norls_allocator::nraDone(void)
{
    /* Do nothing if we have no pages at all */

    if  (!nraPageList)
        return;

    /* We'll release all but the very first page */

    for (;;)
    {
        norls_pagdesc * temp;

        /* Get the next page, and stop if there aren't any more */

        temp = nraPageList->nrpNextPage;
        if  (!temp)
            break;

        /* Remove the next page from the list */

        nraPageList->nrpNextPage = temp->nrpNextPage;

#if 0
#ifdef DEBUG

        if  (this == &stmt_cmp::scAlloc)
            printf("StmtCmp");
        else if (this == &stmtExpr::sxAlloc)
            printf("StmtExp");
        else
            printf("Unknown");

        printf(": done page at %08X\n", temp);

#endif
#endif


        VirtualFree(temp, 0, MEM_RELEASE);
    }

    /* We now have exactly one page */

    nraPageLast = nraPageList;

    assert(nraPageList->nrpPrevPage == 0);
    assert(nraPageList->nrpNextPage == 0);

    /* Reset the pointers, the whole page is free now */

    nraFreeNext  = nraPageList->nrpContents;
    nraFreeLast  = nraPageList->nrpPageSize + (BYTE *)nraPageList;

#ifdef DEBUG
    memset(nraFreeNext, 0xDD, nraFreeLast - nraFreeNext);
#endif
}

void        norls_allocator::nraFree(void)
{
    /* Free all of the allocated pages */

    while   (nraPageList)
    {
        norls_pagdesc * temp;

        temp = nraPageList;
               nraPageList = temp->nrpNextPage;

#if 0
#ifdef DEBUG

        if  (this == &stmt_cmp::scAlloc)
            printf("StmtCmp");
        else if (this == &stmtExpr::sxAlloc)
            printf("StmtExp");
        else
            printf("Unknown");

        printf(": free page at %08X\n", temp);

#endif
#endif


        VirtualFree(temp, 0, MEM_RELEASE);
    }
}

#ifdef DEBUG
static
unsigned maxSize = 0;
#endif
void        norls_allocator::nraToss(nraMarkDsc &mark)
{
    void    *   last = mark.nmPage;
#ifdef DEBUG
    unsigned tossSize = 0;
#endif

    if  (!last)
    {
        if  (!nraPageList)
            return;

        nraFreeNext  = nraPageList->nrpContents;
        nraFreeLast  = nraPageList->nrpPageSize + (BYTE *)nraPageList;

        return;
    }

    /* Free up all the new pages we've added at the end of the list */

    while (nraPageLast != last)
    {
        norls_pagdesc * temp;

        /* Remove the last page from the end of the list */

        temp = nraPageLast;
               nraPageLast = temp->nrpPrevPage;

        /* The new last page has no 'next' page */

        nraPageLast->nrpNextPage = 0;

#if 0
#ifdef DEBUG
        tossSize += temp->nrpPageSize;
        if (nraPageLast == last)
            printf("%4X\n", tossSize);

        if  (this == &stmt_cmp::scAlloc)
            printf("StmtCmp");
        else if (this == &stmtExpr::sxAlloc)
            printf("StmtExp");
        else
            printf("Unknown");

        printf(": toss page at %08X\n", temp);

#endif
#endif

        VirtualFree(temp, 0, MEM_RELEASE);
    }

    nraFreeNext = mark.nmNext;
    nraFreeLast = mark.nmLast;
}

/*****************************************************************************/
#ifdef DEBUG
/*****************************************************************************/

void    *           norls_allocator::nraAlloc(size_t sz)
{
    void    *   block;

    assert((sz & (sizeof(int) - 1)) == 0);

    block = nraFreeNext;
            nraFreeNext += sz;

    if  ((unsigned)block == blockStop) debugStop("Block at %08X allocated", block);

    if  (nraFreeNext > nraFreeLast)
        block = nraAllocNewPage(sz);

#ifdef DEBUG
    memset(block, 0xDD, sz);
#endif

    return  block;
}

/*****************************************************************************/
#endif
/*****************************************************************************/

size_t              norls_allocator::nraTotalSizeAlloc()
{
    norls_pagdesc * page;
    size_t          size = 0;

    for (page = nraPageList; page; page = page->nrpNextPage)
        size += page->nrpPageSize;

    return  size;
}

size_t              norls_allocator::nraTotalSizeUsed()
{
    norls_pagdesc * page;
    size_t          size = 0;

    if  (nraPageLast)
        nraPageLast->nrpUsedSize = nraFreeNext - nraPageLast->nrpContents;

    for (page = nraPageList; page; page = page->nrpNextPage)
        size += page->nrpUsedSize;

    return  size;
}

/*****************************************************************************/
#ifndef NOT_JITC
/*****************************************************************************/

void    *   norls_allocator::nraPageWalkerStart()
{
    /* Make sure the actual used size for the current page is recorded */

    if  (nraPageLast)
        nraPageLast->nrpUsedSize = nraFreeNext - nraPageList->nrpContents;

    /* Return the first page */

    return  nraPageList;
}

void    *   norls_allocator::nraPageWalkerNext(void *page)
{
    norls_pagdesc * temp = (norls_pagdesc *)page;

#ifndef NDEBUG
    assert(temp);
    assert(temp->nrpSelfPtr == temp);
#endif

    return  temp->nrpNextPage;
}

void    *   norls_allocator::nraPageGetData(void *page)
{
    norls_pagdesc * temp = (norls_pagdesc *)page;

#ifndef NDEBUG
    assert(temp);
    assert(temp->nrpSelfPtr == temp);
#endif

    return  temp->nrpContents;
}

size_t      norls_allocator::nraPageGetSize(void *page)
{
    norls_pagdesc * temp = (norls_pagdesc *)page;

#ifndef NDEBUG
    assert(temp);
    assert(temp->nrpSelfPtr == temp);
#endif

    return  temp->nrpUsedSize;
}

/*****************************************************************************/
#ifdef DEBUG

void        block_allocator::baDispAllocStats(void)
{
    printf("\n");
    printf("Allocator summary:\n");
    printf("\n");
    printf("A total of %6u blocks allocated.\n", totalCount);
    printf("A total of %7u bytes  requested.\n", sizeTotal);
    printf("A total of %7u bytes  allocated.\n", sizeAlloc);
    printf("A total of %7u bytes  grabbed from OS.\n", pageAlloc);
    printf("\n");
    if  (sizeTotal && sizeTotal < sizeAlloc)
        printf("Relative waste: %u%%\n", 100 * (sizeAlloc - sizeTotal) / sizeTotal);
    if  (sizeTotal && sizeTotal < pageAlloc)
        printf("Absolute waste: %u%%\n", 100 * (pageAlloc - sizeTotal) / sizeTotal);
    printf("\n");

    printf("Small[0] allocator used for blocks %2u to %2u bytes.\n",                    2, SMALL_MAX_SIZE_1);
    printf("Small[1] allocator used for blocks %2u to %2u bytes.\n", SMALL_MAX_SIZE_1 + 2, SMALL_MAX_SIZE_2);
    printf("Small[2] allocator used for blocks %2u to %2u bytes.\n", SMALL_MAX_SIZE_2 + 2, SMALL_MAX_SIZE_3);
    printf("Large    allocator used for blocks %2u       bytes and larger.  \n", SMALL_MAX_SIZE_3 + 2);
    printf("\n");

    printf("A total of %6u blocks allocated via small[0] allocator\n", smallCnt0);
    printf("A total of %6u blocks allocated via small[1] allocator\n", smallCnt1);
    printf("A total of %6u blocks allocated via small[2] allocator\n", smallCnt2);
    printf("A total of %6u blocks allocated via large    allocator\n", largeCnt );
    printf("\n");
}

#endif
/*****************************************************************************/

void        small_block_allocator::sbaInit(unsigned idMask,
                                           size_t   blockSize,
                                           size_t    pageSize)
{
    /* Ignore if we're already initialized */

    if  (sbaInitLvl)
        return;
    sbaInitLvl++;

#ifdef DEBUG
    pageAllocated = 0;
#endif

    /* Add the used block overhead to the size */

    blockSize += offsetof(small_blkdesc, sbdUsed.sbdCont);

    /* Make sure something's not messed up */

    assert(sizeof(small_blkdesc) <= blockSize);
    assert((blockSize % sizeof(void *)) == 0);

    /* Save off the block size and the identification mask */

    sbaIdMask    = idMask;
    sbaBlockSize = blockSize;

    /* Save the page size (properly rounded up) */

    sbaPageSize  = (pageSize + OS_page_size - 1) & ~(OS_page_size - 1);

    sbaPageList  = 0;

    sbaFreeNext  =
    sbaFreeLast  = 0;
}

void        small_block_allocator::sbaDone(void)
{
    assert((int)sbaInitLvl > 0);
    if  (--sbaInitLvl)
        return;

    while   (sbaPageList)
    {
        small_pagdesc * temp;

        temp = sbaPageList;
               sbaPageList = sbaPageList->spdNext;

        VirtualFree(temp, 0, MEM_RELEASE);
    }
}

void        small_block_allocator::sbaInitPageDesc(small_pagdesc *pagePtr)
{
    pagePtr->spdFree = 0;

    /* For debugging purposes, point the page at itself */

#ifndef NDEBUG
    pagePtr->spdThis = pagePtr;
#endif

    sbaFreeNext = (char *)&pagePtr->spdCont;
    sbaFreeLast = (char *)pagePtr + sbaPageSize;
}

void    *   small_block_allocator::sbaAllocBlock(void)
{
    small_pagdesc * page;

    /* Make sure we keep the page marked as full */

    sbaFreeNext =
    sbaFreeLast = 0;

    /* Try the free lists in all the pages */

    for (page = sbaPageList; page; page = page->spdNext)
    {
        small_blkdesc * block = page->spdFree;

        if  (block)
        {
            /* Remove the block from the free list */

            page->spdFree = block->sbdFree.sbdNext;

            /* Return pointer to the client area */

            return  &block->sbdUsed.sbdCont;
        }
    }

    /* Allocate a new page */

    page = (small_pagdesc *)VirtualAlloc(0, sbaPageSize, MEM_COMMIT, PAGE_READWRITE);

#ifdef DEBUG
    pageAllocated = sbaPageSize;
#endif

    /* Add the page to the list */

    page->spdNext = sbaPageList;
                    sbaPageList = page;
    page->spdSize = sbaPageSize;

    /* Initialize the free block info for the page */

    sbaInitPageDesc(page);

    /* Now retry the allocation (and it better work this time) */

    return  sbaAlloc();
}

/*****************************************************************************/

void                large_block_allocator::lbaInit(size_t pageSize)
{

//  printf("=======================lbaInit(%u -> %u)\n", lbaInitLvl, lbaInitLvl+1);

    if  (lbaInitLvl++)
        return;

#ifdef DEBUG
    pageAllocated = 0;
#endif

    /* Make sure our sizes aren't messed up */

//  assert((LBA_SIZE_INC >= small_block_max_size + LBA_OVERHEAD));
    assert((LBA_SIZE_INC >= sizeof(large_blkdesc)));
    assert((LBA_SIZE_INC % sizeof(void*)) == 0);

    /* Check and record the page size */

    lbaPageSize = pageSize & ~(LBA_SIZE_INC - 1);

    /* We have no pages allocated */

    lbaPageList =
    lbaPageLast = 0;

    lbaFreeNext =
    lbaFreeLast = 0;
}

/*****************************************************************************/

void                large_block_allocator::lbaFree(void *p)
{
    large_blkdesc * block;
    large_pagdesc * page;

    assert(lbaInitLvl);

    /* Compute the real address of the block and page descriptor */

    block = (large_blkdesc *)((char *)p     - offsetof(large_blkdesc, lbdUsed.lbdCont));
     page = (large_pagdesc *)((char *)block - block->lbdUsed.lbdOffsLo - (block->lbdUsed.lbdOffsHi << 16));

    /* Make sure we've been passed a reasonable pointer */

    assert(page->lpdThis == page);
    assert(isBlockUsed(block));

    /* Is this the last used block in this page? */

    if  (--page->lpdUsedBlocks == 0)
    {
        large_pagdesc * prev = page->lpdPrev;
        large_pagdesc * next = page->lpdNext;

        /* Is this the current page? */

        if  (page == lbaPageList)
        {
            /* Don't free if there is unallocated space available */

            if  (lbaFreeLast - lbaFreeNext >= LBA_SIZE_INC)
                goto DONT_FREE;

            lbaPageList = next;
        }

        if  (page == lbaPageLast)
            lbaPageLast = prev;

        /* Remove the page from the page list */

        if  (prev) prev->lpdNext = next;
        if  (next) next->lpdPrev = prev;

        /* Free the page */

        VirtualFree(page, 0, MEM_RELEASE);

        return;
    }

DONT_FREE:

    /* Insert the block in the free list */

    block->lbdFree.lbdNext = page->lpdFreeList;
                             page->lpdFreeList = block;

    /* The block is no longer used */

    markBlockFree(block);

    /* Add the free block's size to the total free space in the page */

    page->lpdFreeSize += block->lbdUsed.lbdSize;
}

/*****************************************************************************/

void                large_block_allocator::lbaAddFreeBlock(void *           p,
                                                           size_t           sz,
                                                           large_pagdesc *  page)
{
    unsigned    blockOfs;
    large_blkdesc * block = (large_blkdesc *)p;

    assert((char *)p      >= (char *)page->lpdCont);
    assert((char *)p + sz <= (char *)page + page->lpdPageSize);

    /* The caller is responsible for rounding, so check up on him */

    assert(sz % LBA_SIZE_INC == 0);

    /* Store the page offset and block size in the block */

    blockOfs = (char *)block - (char *)page;

    block->lbdFree.lbdSize   = sz;
    block->lbdFree.lbdOffsLo = blockOfs;
    block->lbdFree.lbdOffsHi = blockOfs >> 16;

    /* Add this block to the free block list */

    block->lbdFree.lbdNext   = page->lpdFreeList;
                               page->lpdFreeList = block;

    /* Add the free block's size to the total free space in the page */

    page->lpdFreeSize += sz;
}

bool                large_block_allocator::lbaShrink(void *p, size_t sz)
{
    large_blkdesc * block;
    large_pagdesc * page;

    size_t       oldSize;
    size_t      freeSize;

    assert(lbaInitLvl);

    /* Add block overhead, and round up the block size */

    sz = lbaTrueBlockSize(sz);

    /* Compute the real address of the block and page descriptor */

    block = (large_blkdesc *)((char *)p     - offsetof(large_blkdesc, lbdUsed.lbdCont));
     page = (large_pagdesc *)((char *)block - block->lbdUsed.lbdOffsLo - (block->lbdUsed.lbdOffsHi << 16));

    /* Make sure we've been passed a reasonable block and size */

    assert(page->lpdThis == page);
    assert(isBlockUsed(block));

    /* Figure out if it's worth our time to shrink the block */

     oldSize = blockSizeUsed(block); assert(oldSize >= sz);
    freeSize = oldSize - sz;

    if  (freeSize < LBA_SIZE_INC)
    {
        /* Makes you wonder -- why did they bother calling? */

        return  false;
    }

    /* Shrink the used block to the new size */

    block->lbdUsed.lbdSize -= freeSize;

    /* Make the unused (tail) end of the block into a free block */

    lbaAddFreeBlock((char *)block + sz, freeSize, page);

    return  true;
}

/*****************************************************************************/

void    *           large_block_allocator::lbaAllocMore(size_t sz)
{
    large_pagdesc * page;
    large_pagdesc * pageWithFit;
    large_blkdesc * block;

    bool        shouldMerge;

    assert(lbaInitLvl);

    /* First undo the increment done in lbaAlloc() */

    lbaFreeNext -= sz;

    /* Is there is any room at the top of the current page? */

    if  (lbaFreeLast - lbaFreeNext >= LBA_SIZE_INC)
    {
        size_t      freeSize;

        /* Make sure we've got the right page */

        assert(lbaFreeNext >= (char *)lbaPageList->lpdCont);
        assert(lbaFreeNext <= (char *)lbaPageList + lbaPageList->lpdPageSize);

        /* We'll make the rest of the page into a free block */

        block = (large_blkdesc *)lbaFreeNext;

        /* Compute the size (and round it down to be the right multiple) */

        freeSize = (lbaFreeLast - lbaFreeNext) & ~(LBA_SIZE_INC - 1);

        /* Prevent anyone from using the end of this page again */

        lbaFreeNext =
        lbaFreeLast = 0;

        /* Now add the free block */

        lbaAddFreeBlock(block, freeSize, lbaPageList);
    }

    /*
        First we'll look for a perfect fit in all the pages.

        While we're walking the pages, we mark which ones have any
        larger and/or adjacent free blocks, so that we'll know if
        it's worth going back and looking for an 'OK fit' and/or
        to merge free blocks (in the hope that we'll produce a
        free block that's large enough).
     */

    pageWithFit  = 0;
    shouldMerge  = false;

    for (page = lbaPageList; page; page = page->lpdNext)
    {
        large_blkdesc **blockLast;

        /* Assume this page is no good */

        page->lpdCouldMerge = false;

        /* If this page doesn't have enough room even in theory, skip it */

        if  (page->lpdFreeSize < sz)
            continue;

        /* Walk the free blocks, looking for a perfect fit */

        blockLast = &page->lpdFreeList;

        for (;;)
        {
            void    *   p;

            block = *blockLast;
            if  (!block)
                break;

            /* Does this block have an adjacent free one? */

            if  (0)
            {
                page->lpdCouldMerge = shouldMerge = true;
            }

            /* Is this block too small? */

            if  (block->lbdFree.lbdSize < sz)
                goto NEXT_BLK;

            /* If not a perfect fit, it'll definitely make an OK fit */

            if  (block->lbdFree.lbdSize > sz)
            {
                if  (!pageWithFit)
                    pageWithFit = page;

                goto NEXT_BLK;
            }

        PERFECT_FIT:

            /* Remove the block from the free list */

            *blockLast = block->lbdFree.lbdNext;

            /* Make the block into a used one */

            markBlockUsed(block); page->lpdUsedBlocks++;

            /* Return a pointer to the client area of the block */

            p = block->lbdUsed.lbdCont;
            memset(p, 0, sz - LBA_OVERHEAD);
            return  p;

        NEXT_BLK:

            blockLast = &block->lbdFree.lbdNext;
        }
    }

    if  (pageWithFit)
    {
        page = pageWithFit;

        /* Walk the free blocks, looking for a good-enough fit */

        for (block = page->lpdFreeList; block; block = block->lbdFree.lbdNext)
        {
            void    *   p;
            size_t      extra;
            unsigned    blockOfs;

            /* Is this block big enough? */

            if  (block->lbdFree.lbdSize < sz)
                continue;

            /* Figure out how much will be left over */

            extra = block->lbdFree.lbdSize - sz; assert((extra % LBA_SIZE_INC) == 0);

            /* Only bother with the left-over if it's big enough */

            if  (extra < LBA_SIZE_INC)
                goto PERFECT_FIT;

            /* Compute how much we will really allocate */

            assert(block->lbdFree.lbdSize == sz + extra);

            /* Reduce the size of the free block */

            block->lbdFree.lbdSize = extra;

            /* Also update the total free space in the page */

            page->lpdFreeSize    -= sz;

#ifdef DEBUG
//          printf("Stole %u bytes from page at %08X, %5u free bytes left\n", nsize, page, page->lpdFreeSize);
#endif

            /* The used block will take the tail end */

            block = (large_blkdesc *)((char *)block + extra);

            /* Make the block into a used block */

            blockOfs = (char *)block - (char *)page;

            block->lbdUsed.lbdSize   = sz + 1;
            block->lbdFree.lbdOffsLo = blockOfs;
            block->lbdFree.lbdOffsHi = blockOfs >> 16;

            page->lpdUsedBlocks++;

            /* Return a pointer to the client area of the block */

            p = block->lbdUsed.lbdCont;
            memset(p, 0, sz - LBA_OVERHEAD);
            return  p;
        }
    }

    if  (shouldMerge)
    {
        assert(!"try merging free blocks");
    }

    /* Nothing worked, we'll have to allocate a new page */

    size_t      size = lbaPageSize;

    /* Make sure we allocate a page that is large enough */

    size_t      mins = sz + offsetof(large_pagdesc, lpdCont);

    if  (size < mins)
    {
        size = (mins + OS_page_size - 1) & ~(OS_page_size - 1);
    }

//  printf("Alloc %6u bytes.\n", size);

    page = (large_pagdesc *)VirtualAlloc(0, size, MEM_COMMIT, PAGE_READWRITE);

#ifdef DEBUG
    pageAllocated = size;
#endif

    /* Add the page to the page list */

    if  (lbaPageList)
    {
        lbaPageList->lpdPrev = page;
                               page->lpdNext = lbaPageList;
    }
    else
    {
        page->lpdNext =
        page->lpdPrev = 0;

        lbaPageLast   = page;
    }

    lbaPageList = page;

    /* Fill in the rest of the page descriptor */

    page->lpdPageSize  = size;
#ifndef NDEBUG
    page->lpdThis      = page;
#endif

    /* Make the whole page available for allocations */

    lbaFreeNext = (char *)&page->lpdCont;
    lbaFreeLast = (char *)page + size;

    /* For now there are no free blocks in this page */

    page->lpdFreeList = 0;
    page->lpdFreeSize = 0;

    /* Now we can allocate the block 'the easy way' */

    block = (large_blkdesc *)lbaFreeNext;
                             lbaFreeNext += sz;

    assert(lbaFreeNext <= lbaFreeLast);

    block->lbdUsed.lbdSize   = sz + 1;
    block->lbdUsed.lbdOffsLo = ((char *)block - (char *)page);
    block->lbdUsed.lbdOffsHi = ((char *)block - (char *)page) >> 16;

    page->lpdUsedBlocks = 1;

    return  block->lbdUsed.lbdCont;
}

void    *           large_block_allocator::lbaAlloc(size_t sz)
{
    large_blkdesc * block;

    /* Add block overhead, and round up the block size */

    sz = lbaTrueBlockSize(sz);

#ifdef DEBUG
    sizeAllocated = sz;
#endif

    /* See if there is room in the current page */

    block = (large_blkdesc *)lbaFreeNext;
                             lbaFreeNext += sz;

    if  (lbaFreeNext <= lbaFreeLast)
    {
        unsigned    blockOffs = (char *)block - (char *)lbaPageList;

        assert(lbaFreeNext >= (char *)lbaPageList->lpdCont);
        assert(lbaFreeNext <= (char *)lbaPageList + lbaPageList->lpdPageSize);

        lbaPageList->lpdUsedBlocks++;

        block->lbdUsed.lbdSize   = sz + 1;
        block->lbdUsed.lbdOffsLo = blockOffs;
        block->lbdUsed.lbdOffsHi = blockOffs >> 16;

        return  block->lbdUsed.lbdCont;
    }
    else
        return  lbaAllocMore(sz);
}

/*****************************************************************************/

void    *   block_allocator::baGetM(size_t sz)
{
    void    *   block;

    assert((sz & (sizeof(int) - 1)) == 0);

#ifdef DEBUG

    totalCount++;

    if  (sz < sizeof(sizeCounts)/sizeof(sizeCounts[0]))
        sizeCounts[sz]++;
    else
        sizeLarger++;

    sizeTotal += sz;

#endif

    if  (sz <= SMALL_MAX_SIZE_1)
    {
        block = baSmall[0].sbaAlloc();

#ifdef DEBUG
        smallCnt0++;
        sizeAlloc += baSmall[0].sizeAllocated; baSmall[0].sizeAllocated = 0;
        pageAlloc += baSmall[0].pageAllocated; baSmall[0].pageAllocated = 0;
#endif

        /* Make sure we'll recognize the block when freed */

        assert(baSmall[0].sbaIsMyBlock(block) != 0);
        assert(baSmall[1].sbaIsMyBlock(block) == 0);
        assert(baSmall[2].sbaIsMyBlock(block) == 0);
        assert(baLarge   .lbaIsMyBlock(block) == 0);
    }
    else if (sz <= SMALL_MAX_SIZE_2)
    {
        block = baSmall[1].sbaAlloc();

#ifdef DEBUG
        smallCnt1++;
        sizeAlloc += baSmall[1].sizeAllocated; baSmall[1].sizeAllocated = 0;
        pageAlloc += baSmall[1].pageAllocated; baSmall[1].pageAllocated = 0;
#endif

        /* Make sure we'll recognize the block when freed */

        assert(baSmall[0].sbaIsMyBlock(block) == 0);
        assert(baSmall[1].sbaIsMyBlock(block) != 0);
        assert(baSmall[2].sbaIsMyBlock(block) == 0);
        assert(baLarge   .lbaIsMyBlock(block) == 0);
    }
    else if (sz <= SMALL_MAX_SIZE_3)
    {
        block = baSmall[2].sbaAlloc();

#ifdef DEBUG
        smallCnt2++;
        sizeAlloc += baSmall[2].sizeAllocated; baSmall[2].sizeAllocated = 0;
        pageAlloc += baSmall[2].pageAllocated; baSmall[2].pageAllocated = 0;
#endif

        /* Make sure we'll recognize the block when freed */

        assert(baSmall[0].sbaIsMyBlock(block) == 0);
        assert(baSmall[1].sbaIsMyBlock(block) == 0);
        assert(baSmall[2].sbaIsMyBlock(block) != 0);
        assert(baLarge   .lbaIsMyBlock(block) == 0);
    }
    else
    {
        block = baLarge.lbaAlloc(sz);

#ifdef DEBUG
        largeCnt++;
        sizeAlloc += baLarge   .sizeAllocated; baLarge   .sizeAllocated = 0;
        pageAlloc += baLarge   .pageAllocated; baLarge   .pageAllocated = 0;
#endif

        /* Make sure we'll recognize the block when freed */

        assert(baSmall[0].sbaIsMyBlock(block) == 0);
        assert(baSmall[1].sbaIsMyBlock(block) == 0);
        assert(baSmall[2].sbaIsMyBlock(block) == 0);
        assert(baLarge   .lbaIsMyBlock(block) != 0);
    }

    return  block;
}

void    *   block_allocator::baGet0(size_t sz)
{
    void    *   block;

    /* Set a trap for an out-of-memory error */

    setErrorTrap()  // ERROR TRAP: Start normal block
    {
        /* Try to allocate the block */

        block = baGetM(sz);
    }
    impJitErrorTrap()  // ERROR TRAP: The following block handles errors
    {
        /* We come here only in case of an error */

        block = 0;
    }
    endErrorTrap()  // ERROR TRAP: End

    return  block;
}

void        block_allocator::baRlsM(void *block)
{
    assert(block);          // caller should check for NULL

    assert((int)(baSmall[0].sbaIsMyBlock(block) != 0) +
           (int)(baSmall[1].sbaIsMyBlock(block) != 0) +
           (int)(baSmall[2].sbaIsMyBlock(block) != 0) +
           (int)(baLarge   .lbaIsMyBlock(block) != 0) == 1);

    if  (baSmall[0].sbaIsMyBlock(block))
    {
        baSmall[0].sbaFree(block);
    }
    else if (baSmall[1].sbaIsMyBlock(block))
    {
        baSmall[1].sbaFree(block);
    }
    else if (baSmall[2].sbaIsMyBlock(block))
    {
        baSmall[2].sbaFree(block);
    }
    else
        baLarge.   lbaFree(block);
}

/*****************************************************************************/
#ifdef DEBUG
/*****************************************************************************
 *
 *  The following are the debug versions of the general memory allocator
 *  routines. They (optionally) log information about each allocation to
 *  make it easier to track down things like memory consumption, leaks,
 *  and so on.
 *
 */

void    *           block_allocator::baAlloc      (size_t size)
{
    void    *       block;
    unsigned long   tsize;

    assert((size & (sizeof(int) - 1)) == 0);

    tsize = sizeAlloc;
    block = baGetM(size);
    tsize = sizeAlloc - tsize;

    if  ((unsigned)block == blockStop) debugStop("Block at %08X allocated", block);

    recordBlockAlloc(this, block, tsize);

    return  block;
}

void    *           block_allocator::baAllocOrNull(size_t size)
{
    void    *       block;
    unsigned long   tsize;

    assert((size & (sizeof(int) - 1)) == 0);

    tsize = sizeAlloc;
    block = baGet0(size);
    tsize = sizeAlloc - tsize;

    if  (block == NULL)
        return  block;

    if  ((unsigned)block == blockStop) debugStop("Block at %08X allocated", block);

    recordBlockAlloc(this, block, tsize);

    return  block;
}

void                block_allocator::baFree       (void *block)
{
    recordBlockFree (this, block);

    if  ((unsigned)block == blockStop) debugStop("Block at %08X freed", block);

    baRlsM(block);
}

/*****************************************************************************/
#endif// DEBUG
/*****************************************************************************/
#endif//!NOT_JITC
/*****************************************************************************
 * We try to use this allocator instance as much as possible. It will always
 * keep a page handy so small methods wont have to call VirtualAlloc()
 * But we may not be able to use it if another thread/reentrant call
 * is already using it
 */

static norls_allocator *nraTheAllocator;
static nraMarkDsc       nraTheAllocatorMark;
static LONG             nraTheAllocatorIsInUse = 0;

// The static instance which we try to reuse for all non-simultaneous requests

static norls_allocator  theAllocator;

/*****************************************************************************/

void                nraInitTheAllocator()
{
    bool res = theAllocator.nraInit(3*OS_page_size - 32, 1);

    if (res)
    {
        nraTheAllocator = NULL;
    }
    else
    {
        nraTheAllocator = &theAllocator;
    }
}

void                nraTheAllocatorDone()
{
    if (nraTheAllocator)
        nraTheAllocator->nraFree();
}

/*****************************************************************************/

norls_allocator *   nraGetTheAllocator()
{
    if (nraTheAllocator == NULL)
    {
        // If we failed to initialize nraTheAllocator in nraInitTheAllocator()
        return NULL;
    }

    if (InterlockedExchange(&nraTheAllocatorIsInUse, 1))
    {
        // Its being used by another Compiler instance
        return NULL;
    }
    else
    {
        nraTheAllocator->nraMark(nraTheAllocatorMark);
        return nraTheAllocator;
    }
}


void                nraFreeTheAllocator()
{
    if (nraTheAllocator == NULL)
    {
        // If we failed to initialize nraTheAllocator in nraInitTheAllocator()
        return;
    }

    assert(nraTheAllocatorIsInUse == 1);
    nraTheAllocator->nraRlsm(nraTheAllocatorMark);
    InterlockedExchange(&nraTheAllocatorIsInUse, 0);
}


/*****************************************************************************/
void                allocatorCodeSizeEnd(){}
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\ia64\attrs.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\ia64\bitvect.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/
#ifndef _BITVECT_H_
#define _BITVECT_H_
/*****************************************************************************/

struct bitVect;
struct bitVectVars;
struct bitVectBlks;

/*****************************************************************************
 *
 *  The square bitmap is used for the variable interference graph.
 */

struct bitMatrix
{
private:
    size_t          bmxSize;
    size_t          bmxRowSz;
    BYTE *          bmxMatrix;
    unsigned      * bmxCounts;

    size_t          bmxNmax;            // max. number of registers
    bool            bmxIsCns;           // constrained nodes present?

public:
    void            bmxInit(size_t sz, NatUns mc);
    void            bmxDone();

    void            bmxClear();

    void            bmxSetBit(NatUns x, NatUns y);
    void            bmxClrBit(NatUns x, NatUns y);
    bool            bmxTstBit(NatUns x, NatUns y);

    bool            bmxAnyConstrained()
    {
        return  bmxIsCns;
    }

    unsigned *      bmxNeighborCnts()
    {
        return  bmxCounts;
    }

private:
    void            bmxMarkV4(NatUns x, NatUns m, NatUns b);

    void            bmxMarkBS(NatUns x, bitVectVars &vset, bvInfoBlk &info);
public:
    void            bmxMarkVS(NatUns x, bitVectVars &vset, bvInfoBlk &info);

private:

public:
    void            bmxMarkRegIntf (NatUns num, NatUns reg);
    NatUns          bmxChkIntfPrefs(NatUns num, NatUns reg);
};

/*****************************************************************************/

typedef unsigned __int64    BVinlBitSetTP;

extern  unsigned __int64    bitset64masks[64];
inline  unsigned __int64    bitnum64toMask(unsigned index)
{
    assert(index < 64);
    return  bitset64masks[index];
}

/*****************************************************************************/

const
unsigned            maxBitVectInlineSize = NatBits - 1;

struct bitVect
{
    friend
    void            bitMatrix::bmxMarkVS(NatUns x, bitVectVars &vset, bvInfoBlk &info);

    union
    {
        BVinlBitSetTP    inlMap;                // used for small bitsets (bit0=1)

        BYTE    *       byteMap;                // heap-based bitmap for large sets
        NatUns  *       uintMap;
    };

private:

    void            bvFindB   (bvInfoBlk &info);

    void            bvCreateB (bvInfoBlk &info);
    void            bvCrFromB (bvInfoBlk &info, bitVect & from);
    void            bvDestroyB(bvInfoBlk &info);
    void            bvCopyB   (bvInfoBlk &info, bitVect & from);
    bool            bvChangeB (bvInfoBlk &info, bitVect & from);
    void            bvClearB  (bvInfoBlk &info);
    bool            bvTstBitB (bvInfoBlk &info, NatUns index);
    void            bvClrBitB (bvInfoBlk &info, NatUns index);
    void            bvSetBitB (bvInfoBlk &info, NatUns index);
    void            bvIorB    (bvInfoBlk &info, bitVect & with);
    void            bvUnInCmB (bvInfoBlk &info, bitVect & set1, bitVect & set2, bitVect & set3);
    bool            bvIsEmptyB(bvInfoBlk &info);

#ifdef  DEBUG
    unsigned        bvCheck;
#endif

protected:

    void            bvCreate   (bvInfoBlk &info)
    {
#ifdef  DEBUG
        assert(bvCheck != 0xBEEF); bvCheck = 0xBEEF;
#endif

        if  (info.bvInfoSize < maxBitVectInlineSize)
            inlMap = 1;
        else
            bvCreateB(info);
    }

    void            bvCrFrom   (bvInfoBlk &info, bitVect & from)
    {
#ifdef  DEBUG
        assert(bvCheck != 0xBEEF && from.bvCheck == 0xBEEF); bvCheck = 0xBEEF;
#endif

        if  (from.inlMap & 1)
        {
            assert(info.bvInfoSize < maxBitVectInlineSize);

            inlMap = from.inlMap;
        }
        else
            bvCrFromB(info, from);
    }

    void            bvDestroy  (bvInfoBlk &info)
    {
#ifdef  DEBUG
        assert(bvCheck == 0xBEEF); bvCheck = 0xCAFE;
#endif

        if  (!(inlMap & 1))
            bvDestroyB(info);
    }

    void            bvCopy    (bvInfoBlk &info, bitVect & from)
    {
        assert(bvCheck == 0xBEEF && from.bvCheck == 0xBEEF);

        if  (inlMap & 1)
            inlMap = from.inlMap;
        else
            bvCopyB(info, from);
    }

    bool            bvChange  (bvInfoBlk &info, bitVect & from)
    {
        assert(bvCheck == 0xBEEF && from.bvCheck == 0xBEEF);

        if  (inlMap & 1)
        {
            BVinlBitSetTP   old = inlMap;
            return  (old != (inlMap = from.inlMap));
        }
        else
            return  bvChangeB(info, from);
    }

    void            bvClear    (bvInfoBlk &info)
    {
        assert(bvCheck == 0xBEEF);

        if  (inlMap & 1)
             inlMap = 1;
        else
            bvClearB(info);
    }

    bool            bvTstBit   (bvInfoBlk &info, NatUns index)
    {
        assert(bvCheck == 0xBEEF);

        assert(index > 0 && index <= info.bvInfoSize);

        if  (inlMap & 1)
            return  (inlMap & bitnum64toMask(index)) != 0;
        else
            return  bvTstBitB(info, index);
    }

    void            bvClrBit   (bvInfoBlk &info, NatUns index)
    {
        assert(bvCheck == 0xBEEF);

        assert(index > 0 && index <= info.bvInfoSize);

        if  (inlMap & 1)
             inlMap &= ~bitnum64toMask(index);
        else
            bvClrBitB(info, index);
    }

    void            bvSetBit   (bvInfoBlk &info, NatUns index)
    {
        assert(bvCheck == 0xBEEF);

        assert(index > 0 && index <= info.bvInfoSize);

        if  (inlMap & 1)
             inlMap |=  bitnum64toMask(index);
        else
            bvSetBitB(info, index);
    }

    void            bvIor      (bvInfoBlk &info, bitVect & with)
    {
        assert(bvCheck == 0xBEEF && with.bvCheck == 0xBEEF);

        if  (inlMap & 1)
             inlMap |=  with.inlMap;
        else
            bvIorB(info, with);
    }

    void            bvUnInCm   (bvInfoBlk &info, bitVect & set1, bitVect & set2, bitVect & set3)
    {
        assert(     bvCheck == 0xBEEF);
        assert(set1.bvCheck == 0xBEEF);
        assert(set2.bvCheck == 0xBEEF);
        assert(set3.bvCheck == 0xBEEF);

        if  (inlMap & 1)
        {
            assert(info.bvInfoSize < maxBitVectInlineSize);

            inlMap = set1.inlMap | (set2.inlMap & ~set3.inlMap);
        }
        else
            bvUnInCmB(info, set1, set2, set3);
    }

    bool            bvIsEmpty  (bvInfoBlk &info)
    {
        assert(bvCheck == 0xBEEF);

        if  (inlMap & 1)
            return  (inlMap == 1);
        else
            return  bvIsEmptyB(info);
    }
};

struct bitVectBlks : bitVect
{
public:
    void            bvCreate (Compiler *comp)
    {
        bitVect::bvCreate (comp->bvInfoBlks);
    }
    void            bvCrFrom (Compiler *comp, bitVect & from)
    {
        bitVect::bvCrFrom (comp->bvInfoBlks, from);
    }
    void            bvDestroy(Compiler *comp)
    {
        bitVect::bvDestroy(comp->bvInfoBlks);
    }
#ifdef  DEBUG
    void            bvDisp   (Compiler *comp);
#endif
    void            bvCopy   (Compiler *comp, bitVect & from)
    {
        bitVect::bvCopy   (comp->bvInfoBlks, from);
    }
    bool            bvChange (Compiler *comp, bitVect & from)
    {
        return
        bitVect::bvChange (comp->bvInfoBlks, from);
    }
    void            bvClear  (Compiler *comp)
    {
        bitVect::bvClear  (comp->bvInfoBlks);
    }
    bool            bvTstBit (Compiler *comp, NatUns index)
    {
        return
        bitVect::bvTstBit (comp->bvInfoBlks, index);
    }
    void            bvClrBit (Compiler *comp, NatUns index)
    {
        bitVect::bvClrBit (comp->bvInfoBlks, index);
    }
    void            bvSetBit (Compiler *comp, NatUns index)
    {
        bitVect::bvSetBit (comp->bvInfoBlks, index);
    }
    void            bvIor    (Compiler *comp, bitVect & with)
    {
        bitVect::bvIor    (comp->bvInfoBlks, with);
    }
    void            bvUnInCm (Compiler *comp, bitVect & set1, bitVect & set2, bitVect & set3)
    {
        bitVect::bvUnInCm (comp->bvInfoBlks, set1, set2, set3);
    }
    bool            bvIsEmpty(Compiler *comp)
    {
        return
        bitVect::bvIsEmpty(comp->bvInfoBlks);
    }
};

struct bitVectVars : bitVect
{
public:
    void            bvCreate (Compiler *comp)
    {
        bitVect::bvCreate (comp->bvInfoVars);
    }
    void            bvCrFrom (Compiler *comp, bitVect & from)
    {
        bitVect::bvCrFrom (comp->bvInfoVars, from);
    }
    void            bvDestroy(Compiler *comp)
    {
        bitVect::bvDestroy(comp->bvInfoVars);
    }
#ifdef  DEBUG
    void            bvDisp   (Compiler *comp);
#endif
    void            bvCopy   (Compiler *comp, bitVect & from)
    {
        bitVect::bvCopy   (comp->bvInfoVars, from);
    }
    bool            bvChange (Compiler *comp, bitVect & from)
    {
        return
        bitVect::bvChange (comp->bvInfoVars, from);
    }
    void            bvClear  (Compiler *comp)
    {
        bitVect::bvClear  (comp->bvInfoVars);
    }
    bool            bvTstBit (Compiler *comp, NatUns index)
    {
        return
        bitVect::bvTstBit (comp->bvInfoVars, index);
    }
    void            bvClrBit (Compiler *comp, NatUns index)
    {
        bitVect::bvClrBit (comp->bvInfoVars, index);
    }
    void            bvSetBit (Compiler *comp, NatUns index)
    {
        bitVect::bvSetBit (comp->bvInfoVars, index);
    }
    void            bvIor    (Compiler *comp, bitVect & with)
    {
        bitVect::bvIor    (comp->bvInfoVars, with);
    }
    void            bvUnInCm (Compiler *comp, bitVect & set1, bitVect & set2, bitVect & set3)
    {
        bitVect::bvUnInCm (comp->bvInfoVars, set1, set2, set3);
    }
    bool            bvIsEmpty(Compiler *comp)
    {
        return
        bitVect::bvIsEmpty(comp->bvInfoVars);
    }
};

#define bvCreate()          bvCreate (this)
#define bvCrFrom(f)         bvCrFrom (this,f)
#define bvDestroy()         bvDestroy(this)
#define bvDisp()            bvDisp   (this)
#define bvCopy(f)           bvCopy   (this,f)
#define bvChange(f)         bvChange (this,f)
#define bvClear()           bvClear  (this)
#define bvTstBit(x)         bvTstBit (this,x)
#define bvClrBit(x)         bvClrBit (this,x)
#define bvSetBit(x)         bvSetBit (this,x)
#define bvIor(w)            bvIor    (this,w)
#define bvUnInCm(a,b,c)     bvUnInCm (this,a,b,c)
#define bvIsEmpty()         bvIsEmpty(this)

/*****************************************************************************/

inline
void                bitMatrix::bmxMarkVS(NatUns x, bitVectVars &vset,
                                                   bvInfoBlk   &info)
{
    BVinlBitSetTP   smap = vset.inlMap;

//  printf("Mark interference for var #%u\n", varNum);

    if  (smap & 1)
    {
        smap >>= 1; bmxMarkV4(x, (unsigned)smap,  1);
        smap >>= 4; bmxMarkV4(x, (unsigned)smap,  5);
        smap >>= 4; bmxMarkV4(x, (unsigned)smap,  9);
        smap >>= 4; bmxMarkV4(x, (unsigned)smap, 13);
        smap >>= 4; bmxMarkV4(x, (unsigned)smap, 17);
        smap >>= 4; bmxMarkV4(x, (unsigned)smap, 21);
        smap >>= 4; bmxMarkV4(x, (unsigned)smap, 25);
        smap >>= 4; bmxMarkV4(x, (unsigned)smap, 29);
    }
    else
    {
        bmxMarkBS(x, vset, info);
    }
}

/*****************************************************************************/
#endif//_BITVECT_H_
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\ia64\cgia64.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                        Code generator for IA64                            XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

#include "jitpch.h"
#pragma hdrstop

#include <sys\stat.h>

#include "PEwrite.h"
#include "loginstr.h"

#include "pdb.h"

/*****************************************************************************/

#ifdef  DEBUG
#define shouldShowLivenessForBlock(b) (b->igNum == -1)
#endif

/*****************************************************************************/

#define DEBUG_LIVENESS      0

/*****************************************************************************/

#define ASSERT              _ASSERTE

/*****************************************************************************/

// Horrible hack: hardwire names of EXE/PDB files.

#define HACK_EXE_NAME       "J64.exe"
#define HACK_PDB_NAME       "J64.pdb"

/*****************************************************************************/
#if     TGT_IA64
/*****************************************************************************/

#if     1           //  .... temporarily enabled for all builds .... #ifdef  DEBUG
Compiler    *       TheCompiler;
#endif

/*****************************************************************************/
#ifdef  DEBUG
#define DISP_TEMPLATES  0           // set to 1 to see template details
#else
#define DISP_TEMPLATES  0           // leave set to 0 for non-DEBUG
#endif
/*****************************************************************************
 *
 *  The following should really go into some header file.
 */

const   NatUns      TRACKED_INT_REG_CNT = 128;

typedef bitset128   genIntRegMaskTP;

const   NatUns      TRACKED_FLT_REG_CNT = 128;

typedef bitset128   genFltRegMaskTP;

const   NatUns      TRACKED_SPC_REG_CNT = 32;

typedef
unsigned __int32    genSpcRegMaskTP;

/*****************************************************************************
 *
 *  The following should be instance members of 'Compiler', of course.
 */

static
genIntRegMaskTP     genFreeIntRegs;
static
genFltRegMaskTP     genFreeFltRegs;
static
genSpcRegMaskTP     genFreeSpcRegs;

static
genIntRegMaskTP     genCallIntRegs;
static
genFltRegMaskTP     genCallFltRegs;
static
genSpcRegMaskTP     genCallSpcRegs;

/*****************************************************************************/

static
bool                genNonLeafFunc;
static
bool                genExtFuncCall;

/*****************************************************************************/

static
NatInt              genPrologSvPfs;
static
regNumber           genPrologSrPfs;
static
NatInt              genPrologSvRP;
static
regNumber           genPrologSrRP;
static
NatInt              genPrologSvGP;
regNumber           genPrologSrGP;
regNumber           genPrologSrLC;
static
NatInt              genPrologMstk;
static
NatInt              genPrologEnd;

/*****************************************************************************/
#ifdef  DEBUG

static
NatUns              genInsCnt;
static
NatUns              genNopCnt;

#endif
/*****************************************************************************/

// The following variable temporarily referenced from sched.cpp
NatUns              cntTmpIntReg;
// The following variable temporarily referenced from sched.cpp
NatUns              cntTmpFltReg;

static
bool                genTmpAlloc;
// The following variable temporarily referenced from sched.cpp
regNumber   *       genTmpIntRegMap;
// The following variable temporarily referenced from sched.cpp
regNumber   *       genTmpFltRegMap;

/*****************************************************************************/

static
NatUns              minOutArgIntReg;
static
NatUns              maxOutArgIntReg;
static
NatUns              begOutArgIntReg;

static
NatUns              minOutArgFltReg;
static
NatUns              maxOutArgFltReg;

static
NatUns              genMaxIntArgReg;
static
NatUns              genMaxFltArgReg;

static
NatUns              maxOutArgStk;

static
NatUns              lastIntStkReg;

static
NatUns              minRsvdIntStkReg;
static
NatUns              maxRsvdIntStkReg;

static
NatUns              minPrSvIntStkReg;
static
NatUns              maxPrSvIntStkReg;

/*****************************************************************************
 *
 *  The following lists the caller-saved register numbers - integer.
 */

static
BYTE                regsIntScr[] =
{
                                        REG_r014,REG_r015,REG_r016,REG_r017,REG_r018,REG_r019,
    REG_r020,REG_r021,REG_r022,REG_r023,REG_r024,REG_r025,REG_r026,REG_r027,REG_r028,REG_r029,
    REG_r030,REG_r031,

    REG_r008,
    REG_r009,
    REG_r010,
    REG_r011,

    REG_NA
};

/*****************************************************************************
 *
 *  The following lists the callee-saved register numbers - integer.
 */

static
BYTE                regsIntStk[] =
{
                      REG_r032,REG_r033,REG_r034,REG_r035,REG_r036,REG_r037,REG_r038,REG_r039,
    REG_r040,REG_r041,REG_r042,REG_r043,REG_r044,REG_r045,REG_r046,REG_r047,REG_r048,REG_r049,
    REG_r050,REG_r051,REG_r052,REG_r053,REG_r054,REG_r055,REG_r056,REG_r057,REG_r058,REG_r059,
    REG_r060,REG_r061,REG_r062,REG_r063,REG_r064,REG_r065,REG_r066,REG_r067,REG_r068,REG_r069,
    REG_r070,REG_r071,REG_r072,REG_r073,REG_r074,REG_r075,REG_r076,REG_r077,REG_r078,REG_r079,
    REG_r090,REG_r091,REG_r092,REG_r093,REG_r094,REG_r095,REG_r096,REG_r097,REG_r098,REG_r099,
    REG_r100,REG_r101,REG_r102,REG_r103,REG_r104,REG_r105,REG_r106,REG_r107,REG_r108,REG_r109,
    REG_r110,REG_r111,REG_r112,REG_r113,REG_r114,REG_r115,REG_r116,REG_r117,REG_r118,REG_r119,
    REG_r120,REG_r121,REG_r122,REG_r123,REG_r124,REG_r125,REG_r126,REG_r127,

    REG_r004,
    REG_r005,
    REG_r006,
    REG_r007,

    REG_NA
};

/*****************************************************************************
 *
 *  The following lists the caller-saved register numbers - floating point.
 */

static
BYTE                regsFltScr[] =
{
                      REG_f032,REG_f033,REG_f034,REG_f035,REG_f036,REG_f037,REG_f038,REG_f039,
    REG_f040,REG_f041,REG_f042,REG_f043,REG_f044,REG_f045,REG_f046,REG_f047,REG_f048,REG_f049,
    REG_f050,REG_f051,REG_f052,REG_f053,REG_f054,REG_f055,REG_f056,REG_f057,REG_f058,REG_f059,
    REG_f060,REG_f061,REG_f062,REG_f063,REG_f064,REG_f065,REG_f066,REG_f067,REG_f068,REG_f069,
    REG_f070,REG_f071,REG_f072,REG_f073,REG_f074,REG_f075,REG_f076,REG_f077,REG_f078,REG_f079,
    REG_f090,REG_f091,REG_f092,REG_f093,REG_f094,REG_f095,REG_f096,REG_f097,REG_f098,REG_f099,
    REG_f100,REG_f101,REG_f102,REG_f103,REG_f104,REG_f105,REG_f106,REG_f107,REG_f108,REG_f109,
    REG_f110,REG_f111,REG_f112,REG_f113,REG_f114,REG_f115,REG_f116,REG_f117,REG_f118,REG_f119,
    REG_f120,REG_f121,REG_f122,REG_f123,REG_f124,REG_f125,REG_f126,//G_f127,

    REG_f006,
    REG_f007,

    REG_f008,
    REG_f009,
    REG_f010,
    REG_f011,
    REG_f012,
    REG_f013,
    REG_f014,
    REG_f015,

    REG_NA
};

/*****************************************************************************
 *
 *  The following lists the callee-saved register numbers - floating point.
 */

static
BYTE                regsFltSav[] =
{
                                                          REG_f016,REG_f017,REG_f018,REG_f019,
    REG_f020,REG_f021,REG_f022,REG_f023,REG_f024,REG_f025,REG_f026,REG_f027,REG_f028,REG_f029,
    REG_f030,REG_f031,

    REG_NA
};

/*****************************************************************************
 *
 *  The following keeps track of how far into the above tables we've made it
 *  so far (i.e. it indicates what registers we've already reserved).
 */

static
BYTE    *           nxtIntStkRegAddr;
static
BYTE    *           nxtIntScrRegAddr;
static
BYTE    *           nxtFltSavRegAddr;
static
BYTE    *           nxtFltScrRegAddr;

/*****************************************************************************
 *
 *  Initialized once (and read-only after that), these hold the bitset of
 *  all the caller-saved registers.
 */

static
bitset128           callerSavedRegsInt;
static
bitset128           callerSavedRegsFlt;

/*****************************************************************************
 *
 *  Helpers for medium-sized bitmaps.
 */

unsigned __int64    bitset64masks[64] =
{
    //----
    //    ----
    //        ----
    //            ----
    0x0000000000000001UL,
    0x0000000000000002UL,
    0x0000000000000004UL,
    0x0000000000000008UL,
    0x0000000000000010UL,
    0x0000000000000020UL,
    0x0000000000000040UL,
    0x0000000000000080UL,
    0x0000000000000100UL,
    0x0000000000000200UL,
    0x0000000000000400UL,
    0x0000000000000800UL,
    0x0000000000001000UL,
    0x0000000000002000UL,
    0x0000000000004000UL,
    0x0000000000008000UL,
    0x0000000000010000UL,
    0x0000000000020000UL,
    0x0000000000040000UL,
    0x0000000000080000UL,
    0x0000000000100000UL,
    0x0000000000200000UL,
    0x0000000000400000UL,
    0x0000000000800000UL,
    0x0000000001000000UL,
    0x0000000002000000UL,
    0x0000000004000000UL,
    0x0000000008000000UL,
    0x0000000010000000UL,
    0x0000000020000000UL,
    0x0000000040000000UL,
    0x0000000080000000UL,
    0x0000000100000000UL,
    0x0000000200000000UL,
    0x0000000400000000UL,
    0x0000000800000000UL,
    0x0000001000000000UL,
    0x0000002000000000UL,
    0x0000004000000000UL,
    0x0000008000000000UL,
    0x0000010000000000UL,
    0x0000020000000000UL,
    0x0000040000000000UL,
    0x0000080000000000UL,
    0x0000100000000000UL,
    0x0000200000000000UL,
    0x0000400000000000UL,
    0x0000800000000000UL,
    0x0001000000000000UL,
    0x0002000000000000UL,
    0x0004000000000000UL,
    0x0008000000000000UL,
    0x0010000000000000UL,
    0x0020000000000000UL,
    0x0040000000000000UL,
    0x0080000000000000UL,
    0x0100000000000000UL,
    0x0200000000000000UL,
    0x0400000000000000UL,
    0x0800000000000000UL,
    0x1000000000000000UL,
    0x2000000000000000UL,
    0x4000000000000000UL,
    0x8000000000000000UL,
};

NatUns              bitset128lowest0(bitset128  mask)
{
    UNIMPL("bitset128lowest0"); return 0;
}

NatUns              bitset128lowest1(bitset128  mask)
{
    _uint64         temp;
    NatUns          bias;

    if  (mask.longs[0])
    {
        bias = 0;
        temp = genFindLowestBit(mask.longs[0]);
    }
    else
    {
        bias = 64;
        temp = genFindLowestBit(mask.longs[1]);
    }

    assert(temp);

    return  genVarBitToIndex(temp) + bias;
}

void                bitset128set    (bitset128 *mask, NatUns bitnum, NatInt newval)
{
    UNIMPL("bitset128set(1,2)");
}

void                bitset128set    (bitset128 *mask, NatUns bitnum)
{
    assert(bitnum < 128);

    if  (bitnum < 64)
    {
        mask->longs[0] |= bitset64masks[bitnum];
    }
    else
    {
        mask->longs[1] |= bitset64masks[bitnum - 64];
    }
}

void                bitset128clr    (bitset128 *mask, NatUns bitnum)
{
    assert(bitnum < 128);

    if  (bitnum < 64)
    {
        mask->longs[0] &= ~bitset64masks[bitnum];
    }
    else
    {
        mask->longs[1] &= ~bitset64masks[bitnum - 64];
    }
}

bool                bitset128test   (bitset128  mask, NatUns bitnum)
{
    assert(bitnum < 128);

    if  (bitnum < 64)
    {
        return  ((mask.longs[0] & bitset64masks[bitnum     ]) != 0);
    }
    else
    {
        return  ((mask.longs[1] & bitset64masks[bitnum - 64]) != 0);
    }
}

static
_uint64             bitset128xtr    (bitset128 *srcv,  NatUns bitPos,
                                                       NatUns bitLen)
{
    _uint64         mask;

    assert(bitLen && bitLen <= 64 && bitPos + bitLen <= 128);

    mask = bitset64masks[bitLen] - 1;

    /* Check for the easy cases */

    if  (bitPos + bitLen < 64)
        return  (srcv->longs[0] >>  bitPos      ) & mask;

    if  (bitPos >= 64)
        return  (srcv->longs[1] >> (bitPos - 64)) & mask;

    NatUns          bitHi = 64     - bitPos; assert(bitHi && bitHi <= 64);
    NatUns          bitLo = bitLen - bitHi ; assert(bitLo && bitLo <= 64);

    _uint64         mask1 = bitset64masks[bitHi] - 1;
    _uint64         mask2 = bitset64masks[bitLo] - 1;

    return  (((srcv->longs[0] >> bitPos) & mask1)         ) |
            (((srcv->longs[1]          ) & mask2) << bitHi);
}

static
void                bitset128ins    (bitset128 *dest, NatUns bitPos,
                                                      NatUns bitLen, _uint64 val)
{
    _uint64         mask;

    assert(bitLen && bitLen <= 64 && bitPos + bitLen <= 128);

    mask = bitset64masks[bitLen] - 1;

//  printf("bit insert 0x%I64X into (%u,%u): mask=0x%I64X\n", val, bitPos, bitLen, mask);

    if  (bitPos + bitLen <= 64)
    {
        dest->longs[0] &= ~(mask << bitPos);
        dest->longs[0] |=  (val  << bitPos);
    }
    else if (bitPos >= 64)
    {
        bitPos -= 64;

        dest->longs[1] &= ~(mask << bitPos);
        dest->longs[1] |=  (val  << bitPos);
    }
    else
    {
        NatUns          lowLen = 64 - bitPos;

        assert(bitPos < 64 && bitPos + bitLen > 64);

        mask = bitset64masks[lowLen] - 1;

        dest->longs[0] &= ~((      mask) << bitPos);
        dest->longs[0] |=  ((val & mask) << bitPos);

        mask = bitset64masks[bitLen - lowLen] - 1;

        dest->longs[1] &= ~ (                  mask);
        dest->longs[1] |=   ((val >> lowLen) & mask);
    }
}

/*****************************************************************************
 *
 *  Return a bit mask that will contain the specified number of "1" bits at
 *  the given bit position.
 */

inline
_uint64             formBitMask(NatUns bitPos, NatUns bitLen)
{
    assert(bitLen && bitLen <= 64 && bitPos + bitLen <= 64);

    return  (bitset64masks[bitLen] - 1) << bitPos;
}

/*****************************************************************************/

#define IREF_DSP_FMT    "I%03u"             // used in dumps to show instruction refs
#define IBLK_DSP_FMT    "IB_%03u_%02u"      // used in dumps to show ins. block  refs

/*****************************************************************************/
#ifdef  DEBUG

extern  Compiler *  TheCompiler;

static  NatUns      CompiledFncCnt;

#endif
/*****************************************************************************
 *
 *  The following should be instance data / inline method.
 */

static
NatUns              genPrologInsCnt;

inline
void                genMarkPrologIns(insPtr ins)
{
    ins->idFlags |= IF_FNDESCR;
    genPrologInsCnt++;
}

/*****************************************************************************/

void                Compiler::raInit()
{
    BYTE    *       regPtr;
    bitset128       regSet;

    // This is a bizarre place for this, but ...

    for (regPtr = regsIntScr, bitset128clear(&regSet);;)
    {
        NatUns          reg = *regPtr++;

        if  (reg == REG_NA)
            break;

        bitset128set(&regSet, reg - REG_r000);
    }

    callerSavedRegsInt = regSet;

    for (regPtr = regsFltScr, bitset128clear(&regSet);;)
    {
        NatUns          reg = *regPtr++;

        if  (reg == REG_NA)
            break;

        bitset128set(&regSet, reg - REG_f000);
    }

    callerSavedRegsFlt = regSet;
}

/*****************************************************************************/

static
norls_allocator     insAllocator;

// referenced from flowgraph.cpp
writePE *           genPEwriter;

static
NatUns              genCurCodeOffs;

static
NatUns              genCurFuncOffs;
static
NatInt              genCurDescOffs;

inline
NatUns              emitIA64curCodeOffs()
{
    return  genCurCodeOffs;
}

inline
void    *           insAllocMem(size_t sz)
{
    assert(sz % sizeof(NatInt) == 0);
    return  insAllocator.nraAlloc(sz);
}

/*****************************************************************************
 *
 *  This is temporarily copied here from emit.h.
 */

BYTE                emitter::emitSizeEnc[] =
{
    0,      // 1
    1,      // 2
   -1,
    2,      // 4
   -1,
   -1,
   -1,
    3       // 8
};

BYTE                emitter::emitSizeDec[] =
{
    1,
    2,
    4,
    8
};

/*****************************************************************************
 *
 *  UNDONE: rename and move this stuff.
 */

static PDB *s_ppdb;           // handle to   PDB
static DBI *s_pdbi;           // handle to a DBI
static Mod *s_pmod;           // handle to a Mod
static TPI *s_ptpi;           // handle to a type server

#if 0
static Dbg *s_pdbgFpo;        // handle to a Dbg interface (FPO_DATA)
static Dbg *s_pdbgFunc;       // handle to a Dbg interface (IMAGE_FUNCTION_ENTRY)
#endif

/*****************************************************************************
 *
 *  Initialize PDB (debug info) logic, called once per generated exe/dll.
 */

static
void                genInitDebugGen()
{
    HMODULE         pdbHnd;

    EC              errCode;
    char            errBuff[cbErrMax];

    PfnPDBExportValidateInterface   exportFN;
    PfnPDBOpen                        openFN;

    /* First load the DLL */

    pdbHnd = LoadLibrary("MSPDB60.DLL");
//  pdbHnd = LoadLibrary("X:\\dbgIA64\\MSPDB60.DLL");
//  pdbHnd = LoadLibrary("X:\\DEV\\JIT64\\PDB\\MSPDB60.DLL");
    if  (!pdbHnd)
        fatal(ERRloadPDB);

    /* Find the export validate interface */

    exportFN = PfnPDBExportValidateInterface(GetProcAddress(pdbHnd, "PDBExportValidateInterface"));
    if (!exportFN)
        fatal(ERRwithPDB, "Could not find 'PDBExportValidateInterface' entry point");

    openFN = PfnPDBOpen(GetProcAddress(pdbHnd, "PDBOpen"));
    if (!openFN)
        fatal(ERRwithPDB, "Could not find 'PDBOpen' entry point");

    if (!exportFN(PDBIntv50))
        fatal(ERRwithPDB, "DBI mismatch or something");

    // HACK beg: kill the file so that MSPDB60.DLL doesn't try to reuse it
    struct  _stat   fileInfo; if (!_stat(HACK_PDB_NAME, &fileInfo)) remove(HACK_PDB_NAME);
    // HACK end

    errBuff[0] = 0;

    if  (!openFN(HACK_PDB_NAME, pdbWrite pdbFullBuild, 0, &errCode, errBuff, &s_ppdb))
    {
        char            temp[128];

        sprintf(temp, "PDB open error code: %u %s", errCode, errBuff);

        fatal(ERRwithPDB, temp);
    }

    /* Create the DBI and associate it with the exe/dll */

    if (!s_ppdb->CreateDBI(HACK_EXE_NAME, &s_pdbi))
        fatal(ERRwithPDB, "Could not create DBI");

    assert(s_pdbi);

    /* Create one module for our exe/dll */

    if (!s_pdbi->OpenMod("J64", "J64", &s_pmod))
        fatal(ERRwithPDB, "Could not create DBI module");

    assert(s_pmod);
}

/*****************************************************************************
 *
 *  Report the module's contribution to the given section to the PDB.
 */

static
void                genDbgModContrib(NatUns         sectNum,
                                     WPEstdSects    sectId,
                                     NatUns         flags)
{
    NatUns          size = genPEwriter->WPEsecNextOffs(sectId);

    if  (!size)
        return;

    assert(s_pmod);

    // ISSUE: hard-wired offset of 0, is this kosher ???

    if  (!s_pmod->AddSecContribEx((WORD)sectNum, 0, size - 1, flags, NULL, 0))
        fatal(ERRwithPDB, "Could not add module contribution info");
}

/*****************************************************************************
 *
 *  Add a DBI entry for the given section.
 */

static
void                genDbgAddDBIsect(NatUns         sectNum,
                                     WPEstdSects    sectId,
                                     NatUns         flags)
{
    NatUns          size;

    assert(s_pmod);

    if  (sectId == PE_SECT_count)
        size = -1;
    else
        size = genPEwriter->WPEsecNextOffs(sectId);

    /* Report the contributions of this module to the exe/dll */

    if  (!s_pdbi->AddSec((WORD)sectNum, (WORD)flags, 0, size))
        fatal(ERRwithPDB, "Could not add DBI section entry");
}

/*****************************************************************************
 *
 *  The following keeps track of line# information.
 */

#pragma pack(push, 2)

struct  srcLineDsc
{
    unsigned __int32    slOffs;
    unsigned __int16    slLine;
};

#pragma pack(pop)

static
srcLineDsc *        genSrcLineTab;
static
srcLineDsc *        genSrcLineNxt;
static
NatUns              genSrcLineCnt;
static
NatUns              genSrcLineMax;
static
NatUns              genSrcLineMin;

/*****************************************************************************
 *
 *  Expand the line# table.
 */

static
void                genSrcLineGrow()
{
    NatUns          newCnt = genSrcLineMax * 2;
    srcLineDsc *    newTab = (srcLineDsc *)insAllocMem(newCnt * sizeof(*newTab));

    memcpy(newTab, genSrcLineTab, genSrcLineCnt * sizeof(*newTab));

    genSrcLineMax = newCnt;
    genSrcLineTab = newTab;
    genSrcLineNxt = newTab + genSrcLineCnt;
}

/*****************************************************************************
 *
 *  Record a line# / code offset pair for debug info generation.
 */

inline
void                genSrcLineAdd(NatUns line, NatUns offs)
{
    if  (genSrcLineCnt >= genSrcLineMax)
        genSrcLineGrow();

    assert(genSrcLineCnt < genSrcLineMax);

    if  (genSrcLineMin > line)
         genSrcLineMin = line;

//  printf("Source line %u at %04X\n", line, offs);

    genSrcLineNxt->slOffs = (unsigned __int32)offs;
    genSrcLineNxt->slLine = (unsigned __int16)line;

    genSrcLineNxt++;
    genSrcLineCnt++;
}

/*****************************************************************************
 *
 *  Prepare to record line# information.
 */

static
void                genSrcLineInit(NatUns count)
{
    genSrcLineCnt = 0;
    genSrcLineNxt = genSrcLineTab;
    genSrcLineMin = UINT_MAX;

    assert(sizeof(srcLineDsc) == 6 && "doesn't match a COFF line# descriptor");

    if  (count > genSrcLineMax)
    {
        genSrcLineMax = count;

        genSrcLineTab =
        genSrcLineNxt = (srcLineDsc *)insAllocMem(count * sizeof(*genSrcLineTab));
    }

//  genSrcLineAdd(0, 0);
}

/*****************************************************************************
 *
 *  Add an entry for the function we've just compiled to the PDB.
 */

static
void                genDbgAddFunc(const char *name)
{
    if (!s_pmod->AddPublic(name, 1, genCurFuncOffs))
        fatal(ERRwithPDB, "Could not add function definition");
}

static
void                genDbgEndFunc()
{
    if  (genSrcLineCnt)
    {
        const   char *  fname;

#ifdef  DEBUG
        fname = TheCompiler->compGetSrcFileName();
#else
        fname = "<N/A>";
#endif

        printf("Function [%04X..%04X] is lines %3u .. %3u of %s\n",  genCurFuncOffs,
                                                                     genCurCodeOffs,
                                                                     genSrcLineMin,
                                                                     genSrcLineTab[genSrcLineCnt-1].slLine,
                                                                     fname);

        if  (!s_pmod->AddLines(fname,
                               1,                   // NOTE: .text assumed to be 1
                               genCurFuncOffs,
                               genCurCodeOffs - genCurFuncOffs,
                               0,
                               (WORD)genSrcLineMin,
                               (BYTE *)genSrcLineTab,
                               sizeof(*genSrcLineTab) * genSrcLineCnt))
        {
            fatal(ERRwithPDB, "Could not add line# info");
        }
    }
}

/*****************************************************************************
 *
 *  Finish writing the module to the PDB (debug info) file; called just before
 *  we close the output file and stop.
 */

static
NB10I               PDBsignature = {'01BN', 0, 0};

static
const   char *      genDoneDebugGen(bool errors)
{
    if  (!s_pmod)
        return  NULL;

    /* Report the contributions of this module to the exe/dll */

    // UNDONE: passing in hard-wired section # and characteristics is a hack!!!

    genDbgModContrib(1, PE_SECT_text , 0x60600020);
    genDbgModContrib(2, PE_SECT_pdata, 0x40300040);
    genDbgModContrib(3, PE_SECT_rdata, 0x40400040);
    genDbgModContrib(4, PE_SECT_sdata, 0x00308040);

    // UNDONE: the following should be done in PEwrite not here !!!!

    genDbgAddDBIsect(1, PE_SECT_text , 0x10D);
    genDbgAddDBIsect(2, PE_SECT_pdata, 0x109);
    genDbgAddDBIsect(3, PE_SECT_rdata, 0x109);
    genDbgAddDBIsect(4, PE_SECT_sdata, 0x10B);
    genDbgAddDBIsect(4, PE_SECT_count, 0    );

    /* Close the module */

    if  (!s_pmod->Close())
        fatal(ERRwithPDB, "Could not close module");

    s_pmod = NULL;

    /* Commit/close the DBI and PDB interfaces */

    if  (s_pdbi)
    {
        if  (s_pdbi->Close())
            s_pdbi = NULL;
        else
            fatal(ERRwithPDB, "Could not close DBI");
    }

    if  (s_ppdb)
    {
        PDBsignature.sig = s_ppdb->QuerySignature();
        PDBsignature.age = s_ppdb->QueryAge();

        if  (s_ppdb->Commit())
        {
            if  (s_ppdb->Close())
                s_ppdb = NULL;
            else
                fatal(ERRwithPDB, "Could not close PDB file");
        }
        else
            fatal(ERRwithPDB, "Could not commit PDB file");
    }

    return  HACK_PDB_NAME;
}

/*****************************************************************************
 *
 *  Initialize/shutdown the code generator - called once per compiler run.
 */

static
NatUns              genPdataSect;
static
NatUns              genRdataSect;

static
NatUns              genEntryOffs;

void                Compiler::genStartup()
{
    genPEwriter    = new writePE; ASSERT(genPEwriter);
    genPEwriter->WPEinit(NULL, &insAllocator);

    genPdataSect   =
    genRdataSect   = 0;

    genCurCodeOffs = 0;

    genEntryOffs   = -1;

#ifdef  DEBUG
    if  (dspCode) printf(".section    .text   ,\"ax\" ,\"progbits\"\n");
#endif

    if  (debugInfo)
        genInitDebugGen();
}

static
bool                genAddedData;

void                Compiler::genAddSourceData(const char *fileName)
{
    if  (!genAddedData)
    {
        genPEwriter->WPEaddFileData(fileName); genAddedData = true;
    }
}

void                Compiler::genShutdown(const char *fileName)
{
    const   char *  PDBname = NULL;

    genPEwriter->WPEsetOutputFileName(fileName);

    if  ((int)genEntryOffs == -1 && !ErrorCount)
        printf("// WARNING: 'main' not found, EXE has no entry point\n");

    if  (debugInfo)
        PDBname = genDoneDebugGen(false);

    genPEwriter->WPEdone(false, genEntryOffs, PDBname, &PDBsignature);
}

/*****************************************************************************
 *
 *  Initialize the code generator - called once per function body compiled.
 */

void                Compiler::genInit()
{
#ifdef  DEBUG
    TheCompiler = this;
#endif
}

/*****************************************************************************
 *
 *  Map instruction value to its kind.
 */

unsigned char       ins2kindTab[INS_count] =
{
    #undef  CONST
    #define INST1(id, sn, ik, rf, wf, xu, fu, ex, ev) IK_##ik,
    #include "instrIA64.h"
    #undef  INST1
};

/*****************************************************************************
 *
 *  Map instruction value to the execution unit that can handle it.
 */

unsigned char       genInsXUs[INS_count] =
{
    #define INST1(id, sn, ik, rf, wf, xu, fu, ex, ev) XU_##xu,
    #include "instrIA64.h"
    #undef  INST1
};

/*****************************************************************************
 *
 *  Map instruction value to its functional class.
 */

unsigned char       genInsFUs[INS_count] =
{
    #define INST1(id, sn, ik, rf, wf, xu, fu, ex, ev) FU_##fu,
    #include "instrIA64.h"
    #undef  INST1
};

/*****************************************************************************
 *
 *  Map instruction value to its encoding index / value.
 */

unsigned char       genInsEncIdxTab[] =
{
    #define INST1(id, sn, ik, rf, wf, xu, fu, ex, ev) ex,
    #include "instrIA64.h"
    #undef  INST1
};

NatUns              genInsEncValTab[] =
{
    #define INST1(id, sn, ik, rf, wf, xu, fu, ex, ev) ev,
    #include "instrIA64.h"
    #undef  INST1
};

/*****************************************************************************
 *
 *  Map instruction operator to instruction name string.
 */

#ifdef  DEBUG

const char *        ins2nameTab[INS_count] =
{
    #define INST1(id, sn, ik, rf, wf, xu, fu, ex, ev) sn,
    #include "instrIA64.h"
    #undef  INST1
};

#endif

/*****************************************************************************
 *
 *  Form a name acceptable to the IA64 assembler.
 */

#ifdef  DEBUG

static
const   char *      genMakeAsmName(const char *className, const char *methName)
{
    static
    char            buff[256];

    char    *       temp;

    buff[0] = 0;

    if  (className && strcmp(className, "<Module>"))
    {
        strcpy(buff, className);
        strcat(buff, dspAsmCode ? "_" : ".");
    }

    strcat(buff, methName);

    temp = strstr(buff, ", ...");
    if  (temp)
        strcpy(temp, ", $v)");

    if  (dspAsmCode)
    {
        static
        char            bashTab[] = ".(,): ";
        const char  *   bashNxt;

        for (bashNxt = bashTab; *bashNxt; bashNxt++)
        {
            int             bash = *bashNxt;

            for (;;)
            {
                char    *       temp;

                temp = strchr(buff, bash);
                if  (!temp)
                    break;

                *temp = '_';
            }
        }
    }

    return  buff;
}

#endif

/*****************************************************************************
 *
 *  Returns non-zero if the signed/unsigned value "i" fits in "c" bits (plus
 *  a more efficient version for the special case of 8 bits).
 */

inline
bool                  signed32IntFitsInBits(__int32 i, NatUns c)
{
    return  (((__int32)(i)) == (((__int32)(i) << (32-c)) >> (32-c)));
}

inline
bool                  signed64IntFitsInBits(__int64 i, NatUns c)
{
    return  (((__int64)(i)) == (((__int64)(i) << (64-c)) >> (64-c)));
}

inline
bool                unsigned32IntFitsInBits(__int32 i, NatUns c)
{
    return  (((_uint32)(i)) == (((_uint32)(i) << (32-c)) >> (32-c)));
}

inline
bool                unsigned64IntFitsInBits(__int64 i, NatUns c)
{
    return  (((_uint64)(i)) == (((_uint64)(i) << (64-c)) >> (64-c)));
}

#define   signedIntFitsIn8bit(i)    ((i) == (  signed __int8)(i))
#define unsignedIntFitsIn8bit(i)    ((i) == (unsigned __int8)(i))

/*****************************************************************************
 *
 *  Temp hack to bind some local function calls.
 */

static
const   char *      genFullMethodName(const char *name)
{
    if  (!memcmp(name, "Globals." , 8)) return name + 8;
    if  (!memcmp(name, "<Module>.", 9)) return name + 9;

    return  name;
}

struct  methAddr
{
    methAddr *      maNext;
    const char *    maName;
    NatUns          maCode;
    NatInt          maDesc;
};

static
methAddr *          genMethListHack;

static
void                genNoteFunctionBody(const char *name, NatUns  codeOffs,
                                                          NatInt  descOffs)
{
    methAddr *      meth = new methAddr;
    char    *       svnm = new char[strlen(name)+1]; strcpy(svnm, name);

//  printf("Function body [code=%04X,desc=%04X]: '%s'\n", codeOffs, descOffs, name);

#ifdef  DEBUG

    if  (dspCode)
    {
        const   char *  asmn = genMakeAsmName(NULL, name);

        printf("\n");
        printf("            .type   %s ,@function\n", asmn);
        printf("            .global %s\n", asmn);
    }

#endif

    if  ((descOffs != -1) && 
        (!memcmp(name, "main(", 5) || 
          strstr(name, ".Main("  )))
    {
        genEntryOffs = descOffs;
    }

    meth->maName = svnm;
    meth->maCode = codeOffs;
    meth->maDesc = descOffs;
    meth->maNext = genMethListHack;
                   genMethListHack = meth;

    /* Create an entry for the function in the PDB file if necessary */

    if  (debugInfo)
        genDbgAddFunc(name);
}

// called from the importer [temp hack]

bool                genFindFunctionBody(const char *name, NatUns *offsPtr)
{
    methAddr *      meth;
    const   char *  dpos;
    size_t          dch1;

    static
    bool            stop = false;

    if  (strlen(name) > 12)
    {
        if  (!memcmp(name, "<Module>.", 9)) name += 9;
        if  (!memcmp(name, "<Global>.", 9)) name += 9;
    }

    dpos = strstr(name, ", ...");
    if  (dpos)
        dch1 = dpos - name;

    for (meth = genMethListHack; meth; meth = meth->maNext)
    {
        const   char *  mnam = meth->maName;

        if  (!strcmp(mnam, name))
        {
        MATCH:
            *offsPtr = meth->maCode;
            return  true;
        }

        if  (dpos)
        {
            const   char *  mdot = strstr(mnam, ", ...");

            if  (mdot)
            {
                size_t          dch2 = mdot - mnam;

                if  (!memcmp(mnam, name, min(dch1, dch2)))
                    goto MATCH;
            }
        }
    }

    if  (TheCompiler->genWillCompileFunction(name))
    {
        *offsPtr = -1;
        return  true;
    }

    // The following function bodies missing as of 5/1/2000:
    //
    //      @addrArrStore
    //      @dblDiv
    //      @doubleToInt
    //      @doubleToLong
    //      @doubleToUInt
    //      @doubleToULong
    //      @endcatch
    //      @fltDiv
    //      @GetRefAny
    //      @longDiv
    //      @longMod
    //      @newObjArrayDirect
    //      @stringCns
    //      @ulongDiv
    //      @ulongMod
    //
    //      compiler.cmpDeclClass(long,long,boolean)
    //
    //      System..ctor(struct,long)
    //      System.End()
    //      System.get_Chars(int):char
    //      System.get_Length():int
    //      System.GetNextArg():struct
    //      System.Runtime.InteropServices.GetExceptionCode(ref):int

    return  false;
}

/*****************************************************************************
 *
 *  The following is just a temp hack to allocate space for instructions and
 *  so on; all of this stuff should move into class compiler when it settles
 *  a bit.
 */

static
insBlk              insBlockList;
static
insBlk              insBlockLast;

static
insPtr              insBuildList;
static
insPtr              insBuildLast;

static
NatUns              insBuildIcnt;
static
NatUns              insBuildImax;

static
insPtr              insExitList;

#ifdef  DEBUG

static
NatUns              insBuildCount;
static
NatUns              insBlockPatch;

#endif

static
NatUns              insBlockCount;

static
insPtr              insBuildHead;          // reused to start each list

/*****************************************************************************
 *
 *  Debug routines to display instructions (and blocks of them).
 */

#ifdef  DEBUG

static
BYTE    *           insDispTemplatePtr;     // rude hack

static
char *              insDispAddString(char *dest, const char *str)
{
    size_t          len = strlen(str);

    memcpy(dest, str, len);
    return dest   +   len;
}

static
char *              insDispAddSigned(char *dest, __int64 val)
{
    return  dest + sprintf(dest, "%I64d", val);
}

static
char *              insDispAddRegNam(char *dest, regNumber reg)
{
    NatInt          rch;

    assert(reg < REG_COUNT);

    if (reg >= REG_INT_FIRST && reg <= REG_INT_LAST)
    {
        rch = 'r';
        reg = (regNumber)(reg - REG_INT_FIRST);
    }
    else
    {
        assert(reg >= REG_FLT_FIRST && reg <= REG_FLT_LAST);

        rch = 'f';
        reg = (regNumber)(reg - REG_FLT_FIRST);
    }

    return  dest + sprintf(dest, "%c%u", rch, reg);
}

static
char *              insDispAddTmpOp (char *dest, insPtr op)
{
    NatUns          reg;

    assert(op && (__int32)op != 0xDDDDDDDD && op->idTemp);

    /* Check whether we've performed register allocation yet */

    if  (varTypeIsFloating(op->idType) && genTmpFltRegMap)
    {
        assert(op->idTemp <= cntTmpFltReg);

        reg = genTmpFltRegMap[op->idTemp - 1];

//      printf("temp %u -> reg %u\n", op->idTemp, reg);

        return  insDispAddRegNam(dest, (regNumber)reg);
    }

    if  (genTmpIntRegMap)
    {
        assert(op->idTemp <= cntTmpIntReg);

        reg = genTmpIntRegMap[op->idTemp - 1];

//      printf("temp %u -> reg %u\n", op->idTemp, reg);

        return  insDispAddRegNam(dest, (regNumber)reg);
    }

    return  dest + sprintf(dest, "T%02u", op->idTemp);
}

static
char *              insDispAddRegOp (char *dest, insPtr op)
{
    assert(op && (__int32)op != 0xDDDDDDDD);

    switch (op->idIns)
    {
        NatUns              varNum;
        Compiler::LclVarDsc*varDsc;

        regNumber           reg;
        NatUns              rch;

    case INS_ADDROF:
    case INS_LCLVAR:

        varNum = op->idLcl.iVar;
        assert(varNum < TheCompiler->lvaCount);
        varDsc = TheCompiler->lvaTable + varNum;

        if  (varDsc->lvRegister)
        {
            assert(op->idIns == INS_LCLVAR);
            return  insDispAddRegNam(dest, varDsc->lvRegNum);
        }

        if  (TheCompiler->lvaDoneFrameLayout)
        {
            if  (dspAsmCode)
                return  dest + sprintf(dest, "0x%X", TheCompiler->lvaFrameAddress(varNum));

            dest += sprintf(dest, "{0x%X} ", TheCompiler->lvaFrameAddress(varNum));
        }

        if  (op->idIns == INS_ADDROF)
        {
            if  (TheCompiler->lvaDoneFrameLayout && !dspAsmCode)
                dest += sprintf(dest, "{0x%X} ", TheCompiler->lvaFrameAddress(varNum));

            dest += sprintf(dest, "&");
        }

        return  dest + sprintf(dest, "V%u", op->idLcl.iVar);

    case INS_PHYSREG:

        reg = (regNumber)op->idReg;

        if  (varTypeIsFloating(op->idType))
        {
            assert(reg >= REG_FLT_FIRST && reg <= REG_FLT_LAST);

            rch = 'f';
            reg = (regNumber)(reg - REG_FLT_FIRST);
        }
        else
        {
            if  (reg == REG_sp) return  dest + sprintf(dest, "sp");
            if  (reg == REG_gp) return  dest + sprintf(dest, "gp");

            if  ((unsigned)reg >= minOutArgIntReg &&
                 (unsigned)reg <= maxOutArgIntReg)
            {
                if  (!dspAsmCode)
                    dest += sprintf(dest, "/*o%u*/", reg - minOutArgIntReg);

                return  dest + sprintf(dest,  "r%u", reg - minOutArgIntReg + begOutArgIntReg);

//              reg = (regNumber)(reg - minOutArgIntReg + begOutArgIntReg);
//              rch = 'r';
            }
            else
            {
                if  ((BYTE)reg == 0xFF)
                    reg = genPrologSrGP;

                rch = 'R';
            }
        }

        return  dest + sprintf(dest, "%c%u", rch, reg);

    default:
        return  insDispAddTmpOp(dest, op);
    }
}

static
char *              insDispAddCnsOp (char *dest, insPtr op)
{
    assert(op && (__int32)op != 0xDDDDDDDD);

    if  (op->idIns == INS_ADDROF)
        return  insDispAddRegOp(dest, op);

    if  (op->idIns == INS_CNS_INT)
        return  dest + sprintf(dest, "%I64d", op->idConst.iInt);

    assert(op->idIns == INS_FRMVAR);

    if  (TheCompiler->lvaDoneFrameLayout && dspAsmCode)
        return  dest + sprintf(dest, "0x%X", TheCompiler->lvaTable[op->idFvar.iVnum].lvStkOffs);
    else
        return  dest + sprintf(dest, "frmoffs[%u]", op->idFvar.iVnum);
}

static
char *              insDispAddInsOp (char *dest, insPtr op)
{
    assert(op && (__int32)op != 0xDDDDDDDD);

AGAIN:

    switch (op->idIns)
    {
    case INS_LCLVAR:
        return  insDispAddRegOp(dest, op);

    case INS_ADDROF:
    case INS_CNS_INT:
    case INS_FRMVAR:
        return  insDispAddCnsOp(dest, op);

    case INS_PHYSREG:
        return  insDispAddRegOp(dest, op);

    case INS_GLOBVAR:
        if      (op->idFlags & IF_GLB_IMPORT)
            return  dest + sprintf(dest, "0x%08X", genPEwriter->WPEimportNum(op->idGlob.iImport));
        else if (op->idFlags & IF_GLB_SWTTAB)
            return  dest + sprintf(dest, "$J%08X", op->idGlob.iOffs);
        else
            return  dest + sprintf(dest, "0x%08X", op->idGlob.iOffs);

    case INS_br_call_IP:
    case INS_br_call_BR:
        op = op->idRes;
        goto AGAIN;

    default:
        return  insDispAddTmpOp(dest, op);
    }
}

static
char *              insDispAddDest  (char *dest, insPtr op)
{
    assert(op && (__int32)op != 0xDDDDDDDD);

    if  (op->idRes)
        return  insDispAddRegOp(dest, op->idRes);
    else
        return  insDispAddTmpOp(dest, op);
}

void                insDisp(insPtr ins, bool detail   = false,
                                        bool codelike = false,
                                        bool nocrlf   = false)
{
    const   char *  name;

    if  (ins->idFlags & IF_NO_CODE)
    {
        if  (codelike)
            return;
    }
    else
    {
        if  (ins->idIns != INS_PROLOG &&
             ins->idIns != INS_EPILOG)
        {
            if  (ins->idSrcTab == NULL || ins->idSrcTab == UNINIT_DEP_TAB)
                printf("!!!!src dep info not set!!!!");
            if  (ins->idDstTab == NULL || ins->idDstTab == UNINIT_DEP_TAB)
                printf("!!!!dst dep info not set!!!!");
        }
    }

    if  (detail)
        printf("  #%3u", ins->idNum);

    if  (detail)
        printf(" [%08X]", ins);

    if  (detail || !codelike)
        printf(": ");

//  printf("%c", (ins->idFlags & IF_ASG_TGT  ) ? 'A' : ' ');
    printf("%c", (ins->idFlags & IF_NO_CODE  ) ? 'N' : ' ');

    if  (ins->idIns == INS_LCLVAR)
    {
        printf("%c", (ins->idFlags & IF_VAR_BIRTH) ? 'B' : ' ');
        printf("%c", (ins->idFlags & IF_VAR_DEATH) ? 'D' : ' ');
    }
    else
        printf("  ");

    if  (!codelike)
    {
        if  (ins->idTemp)
            printf("T%02u", ins->idTemp);
        else
            printf("   ");
    }

    if  (ins->idPred)
        printf("(p%02u) ", ins->idPred);
    else
        printf("      ");

    name = ins2name(ins->idIns);

    if  (codelike)
    {
        char            operBuff[128];
        char    *       operNext = operBuff;

        char            modsBuff[128];
        char    *       modsNext = modsBuff;

        size_t          len;

        /* Check for special cases */

        switch (ins->idIns)
        {
            char            buff[16];
            const   char *  op;

            const char *    className;
            const char *     methName;

        case INS_fmov:
        case INS_fneg:

        case INS_zxt1:
        case INS_zxt2:
        case INS_zxt4:

        case INS_sxt1:
        case INS_sxt2:
        case INS_sxt4:

        case INS_sub_reg_reg:
        case INS_add_reg_reg:
        case INS_and_reg_reg:
        case INS_ior_reg_reg:
        case INS_xor_reg_reg:

        case INS_shl_reg_reg:
        case INS_shr_reg_reg:
        case INS_sar_reg_reg:

        case INS_shl_reg_imm:
        case INS_sar_reg_imm:
        case INS_shr_reg_imm:

            operNext = insDispAddDest  (operNext, ins);
            operNext = insDispAddString(operNext, "=");
            if  (ins->idOp.iOp1)
            {
            operNext = insDispAddInsOp (operNext, ins->idOp.iOp1);
            operNext = insDispAddString(operNext, ",");
            }
            operNext = insDispAddInsOp (operNext, ins->idOp.iOp2);
            break;

        case INS_add_reg_i14:

        case INS_and_reg_imm:
        case INS_ior_reg_imm:
        case INS_xor_reg_imm:

            operNext = insDispAddDest  (operNext, ins);
            operNext = insDispAddString(operNext, "=");
            operNext = insDispAddInsOp (operNext, ins->idOp.iOp2);
            operNext = insDispAddString(operNext, ",");
            operNext = insDispAddInsOp (operNext, ins->idOp.iOp1);
            break;

        case INS_fcvt_xf:
        case INS_fcvt_xuf_s:
        case INS_fcvt_xuf_d:

        case INS_getf_sig:
        case INS_setf_sig:

        case INS_getf_s:
        case INS_getf_d:

            operNext = insDispAddDest  (operNext, ins);
            operNext = insDispAddString(operNext, "=");
            operNext = insDispAddInsOp (operNext, ins->idOp.iOp1);
            break;

        case INS_mov_reg:
        case INS_mov_reg_i22:
        case INS_mov_reg_i64:
            operNext = insDispAddDest  (operNext, ins);
            operNext = insDispAddString(operNext, "=");
            operNext = insDispAddInsOp (operNext, ins->idOp.iOp2);
            break;

        case INS_mov_reg_brr:
            operNext = insDispAddDest  (operNext, ins);
            operNext = insDispAddString(operNext, "=b");
            operNext = insDispAddCnsOp (operNext, ins->idOp.iOp2);
            break;

        case INS_mov_brr_reg:
            operNext = insDispAddString(operNext, "b");
            operNext = insDispAddCnsOp (operNext, ins->idRes);
            operNext = insDispAddString(operNext, "=");
            operNext = insDispAddRegOp (operNext, ins->idOp.iOp2);
            break;

        case INS_mov_arr_reg:
        case INS_mov_arr_imm:

            operNext = insDispAddString(operNext, "ar.");

            assert(ins->idRes && ins->idRes->idIns == INS_CNS_INT);

            switch (ins->idRes->idConst.iInt)
            {
            case 64: op = "pfs"; break;
            case 65: op = "lc" ; break;
            default: op = buff; sprintf(buff, "?%u?", ins->idRes->idConst.iInt); break;
            }

            operNext = insDispAddString(operNext, op);
            operNext = insDispAddString(operNext, "=");

            if  (ins->idIns == INS_mov_arr_imm)
                operNext = insDispAddInsOp (operNext, ins->idOp.iOp2);
            else
                operNext = insDispAddRegOp (operNext, ins->idOp.iOp2);
            break;

        case INS_mov_reg_arr:
            operNext = insDispAddRegOp (operNext, ins->idRes);

            operNext = insDispAddString(operNext, "=");
            operNext = insDispAddString(operNext, "ar.");

            assert(ins->idOp.iOp2 && ins->idOp.iOp2->idIns == INS_CNS_INT);

            switch (ins->idOp.iOp2->idConst.iInt)
            {
            case 64: op = "pfs"; break;
            case 65: op = "lc" ; break;
            default: op = buff; sprintf(buff, "?%u?", ins->idOp.iOp2->idConst.iInt); break;
            }

            operNext = insDispAddString(operNext, op);
            break;

        case INS_mov_reg_ip:
            operNext = insDispAddDest  (operNext, ins);
            operNext = insDispAddString(operNext, "=ip");
            break;

        case INS_br:
        case INS_br_cond:
        case INS_br_cloop:
            assert(ins->idJump.iDest);
            operNext += sprintf(operNext, IBLK_DSP_FMT, CompiledFncCnt, ins->idJump.iDest->igNum);

            modsNext += sprintf(modsNext, (ins->idFlags & IF_BR_DPNT) ? ".dpnt" : ".spnt");
            modsNext += sprintf(modsNext, (ins->idFlags & IF_BR_FEW ) ? ".few"  : ".many");
            break;

        case INS_st1_ind:
        case INS_st2_ind:
        case INS_st4_ind:
        case INS_st8_ind:

        case INS_stf_s:
        case INS_stf_d:

            operNext = insDispAddString(operNext, "[");
            operNext = insDispAddRegOp (operNext, ins->idOp.iOp1);
            operNext = insDispAddString(operNext, "]=");
            operNext = insDispAddRegOp (operNext, ins->idOp.iOp2);
            break;

        case INS_ld1_ind:
        case INS_ld2_ind:
        case INS_ld4_ind:
        case INS_ld8_ind:

        case INS_ldf_s:
        case INS_ldf_d:

            operNext = insDispAddDest  (operNext, ins);
            operNext = insDispAddString(operNext, "=[");
            operNext = insDispAddRegOp (operNext, ins->idOp.iOp1);
            operNext = insDispAddString(operNext, "]");

            if  (ins->idFlags & IF_LDIND_NTA)
                modsNext+= sprintf(modsNext, ".nta");

            break;

        case INS_ld1_ind_imm:
        case INS_ld2_ind_imm:
        case INS_ld4_ind_imm:
        case INS_ld8_ind_imm:
            operNext = insDispAddDest  (operNext, ins);
            operNext = insDispAddString(operNext, "=[");
            operNext = insDispAddRegOp (operNext, ins->idOp.iOp1);
            operNext = insDispAddString(operNext, "],");
            operNext = insDispAddCnsOp (operNext, ins->idOp.iOp2);

            if  (ins->idFlags & IF_LDIND_NTA)
                modsNext+= sprintf(modsNext, ".nta");

            break;

        case INS_st1_ind_imm:
        case INS_st2_ind_imm:
        case INS_st4_ind_imm:
        case INS_st8_ind_imm:
            operNext = insDispAddString(operNext, "[");
            operNext = insDispAddDest  (operNext, ins);
            operNext = insDispAddString(operNext, "]=");
            operNext = insDispAddRegOp (operNext, ins->idOp.iOp1);
            operNext = insDispAddString(operNext, ",");
            operNext = insDispAddCnsOp (operNext, ins->idOp.iOp2);
            break;

        case INS_cmp8_reg_eq:
        case INS_cmp8_reg_ne:

        case INS_cmp8_reg_lt:
        case INS_cmp8_reg_le:
        case INS_cmp8_reg_ge:
        case INS_cmp8_reg_gt:

        case INS_cmp8_imm_eq:
        case INS_cmp8_imm_ne:

        case INS_cmp8_imm_lt:
        case INS_cmp8_imm_le:
        case INS_cmp8_imm_ge:
        case INS_cmp8_imm_gt:

        case INS_cmp8_reg_lt_u:
        case INS_cmp8_reg_le_u:
        case INS_cmp8_reg_ge_u:
        case INS_cmp8_reg_gt_u:

        case INS_cmp8_imm_lt_u:
        case INS_cmp8_imm_le_u:
        case INS_cmp8_imm_ge_u:
        case INS_cmp8_imm_gt_u:

        case INS_cmp4_reg_eq:
        case INS_cmp4_reg_ne:

        case INS_cmp4_reg_lt:
        case INS_cmp4_reg_le:
        case INS_cmp4_reg_ge:
        case INS_cmp4_reg_gt:

        case INS_cmp4_imm_eq:
        case INS_cmp4_imm_ne:

        case INS_cmp4_imm_lt:
        case INS_cmp4_imm_le:
        case INS_cmp4_imm_ge:
        case INS_cmp4_imm_gt:

        case INS_cmp4_reg_lt_u:
        case INS_cmp4_reg_le_u:
        case INS_cmp4_reg_ge_u:
        case INS_cmp4_reg_gt_u:

        case INS_cmp4_imm_lt_u:
        case INS_cmp4_imm_le_u:
        case INS_cmp4_imm_ge_u:
        case INS_cmp4_imm_gt_u:

        case INS_fcmp_eq:
        case INS_fcmp_ne:
        case INS_fcmp_lt:
        case INS_fcmp_le:
        case INS_fcmp_ge:
        case INS_fcmp_gt:

            operNext = insDispAddString(operNext, "p");
            operNext = insDispAddSigned(operNext, ins->idComp.iPredT);
            operNext = insDispAddString(operNext, ",");
            operNext = insDispAddString(operNext, "p");
            operNext = insDispAddSigned(operNext, ins->idComp.iPredF);
            operNext = insDispAddString(operNext, "=");

            operNext = insDispAddInsOp (operNext, ins->idComp.iCmp1);
            operNext = insDispAddString(operNext, ",");
            operNext = insDispAddInsOp (operNext, ins->idComp.iCmp2);
            break;

        case INS_alloc:
            operNext = insDispAddRegNam(operNext, (regNumber)ins->idReg);
            operNext = insDispAddString(operNext, "=");
            operNext = insDispAddSigned(operNext, ins->idProlog.iInp);
            operNext = insDispAddString(operNext, ",");
            operNext = insDispAddSigned(operNext, ins->idProlog.iLcl);
            operNext = insDispAddString(operNext, ",");
            operNext = insDispAddSigned(operNext, ins->idProlog.iOut);
            operNext = insDispAddString(operNext, ",");
            operNext = insDispAddSigned(operNext, 0);
            break;

        case INS_br_ret:
            modsNext+= sprintf(modsNext, ".sptk.few");     // hack
            operNext = insDispAddString(operNext, "b0");
            break;

        case INS_br_call_IP:
        case INS_br_call_BR:
            if  (ins->idCall.iMethHnd)
            {
                className = NULL;

                if  ((int)ins->idCall.iMethHnd < 0 && -(int)ins->idCall.iMethHnd <= CPX_HIGHEST)
                    methName = TheCompiler->eeHelperMethodName(-(int)ins->idCall.iMethHnd);
                else
                    methName = TheCompiler->eeGetMethodFullName(ins->idCall.iMethHnd);

                if  (!memcmp(methName, "<Module>.", 9))
                    methName += 9;
            }
            else
            {
                 methName = "<pointer>";
                className = NULL;
            }

            modsNext+= sprintf(modsNext, ".sptk.few");     // hack
            operNext = insDispAddString(operNext, "b0=");

            if  (ins->idIns == INS_br_call_BR)
            {
                operNext += sprintf(operNext, "b%u", ins->idCall.iBrReg);
                if  (dspAsmCode)
                    break;

                operNext += sprintf(operNext, " // ");
            }

            operNext = insDispAddString(operNext, genMakeAsmName(className, methName));
            break;

        case INS_br_cond_BR:
            modsNext+= sprintf(modsNext, ".sptk.few");     // hack
            operNext = insDispAddString(operNext, "b");
            operNext = insDispAddSigned(operNext, ins->idIjmp.iBrReg);
            break;

        case INS_fma_s:
        case INS_fma_d:
        case INS_fms_s:
        case INS_fms_d:

            if  (ins->idFlags & IF_FMA_S1)
                modsNext += sprintf(modsNext, ".s1");
            else
                modsNext += sprintf(modsNext, ".s0");

            // Fall through ...

        case INS_shladd:

            operNext = insDispAddDest  (operNext, ins);
            operNext = insDispAddString(operNext, "=");
            operNext = insDispAddInsOp (operNext, ins->idOp3.iOp1);
            operNext = insDispAddString(operNext, ",");
            operNext = insDispAddInsOp (operNext, ins->idOp3.iOp2);
            operNext = insDispAddString(operNext, ",");
            operNext = insDispAddInsOp (operNext, ins->idOp3.iOp3);
            break;

        case INS_xma_l:

            operNext = insDispAddDest  (operNext, ins);
            operNext = insDispAddString(operNext, "=");
            operNext = insDispAddInsOp (operNext, ins->idOp3.iOp2);
            operNext = insDispAddString(operNext, ",");
            operNext = insDispAddInsOp (operNext, ins->idOp3.iOp3);
            operNext = insDispAddString(operNext, ",");
            operNext = insDispAddInsOp (operNext, ins->idOp3.iOp1);
            break;

        case INS_fadd_s:
        case INS_fadd_d:
        case INS_fsub_s:
        case INS_fsub_d:

            operNext = insDispAddDest  (operNext, ins);
            operNext = insDispAddString(operNext, "=");
            operNext = insDispAddInsOp (operNext, ins->idOp3.iOp1);
            operNext = insDispAddString(operNext, ",");
            operNext = insDispAddInsOp (operNext, ins->idOp3.iOp3);
            break;

        case INS_fmpy_s:
        case INS_fmpy_d:

            operNext = insDispAddDest  (operNext, ins);
            operNext = insDispAddString(operNext, "=");
            operNext = insDispAddInsOp (operNext, ins->idOp3.iOp1);
            operNext = insDispAddString(operNext, ",");
            operNext = insDispAddInsOp (operNext, ins->idOp3.iOp2);
            break;

        case INS_nop_m:
        case INS_nop_b:
        case INS_nop_i:
        case INS_nop_f:
            operNext = insDispAddString(operNext, "0");
            break;

        case INS_ARG:

        case INS_PROLOG:
        case INS_EPILOG:
            break;

        default:
            operNext += sprintf(operNext, "<????>");
            break;
        }

        printf("       %s", name);

        *modsNext = 0; printf("%s", modsBuff);

        len = strlen(name) + strlen(modsBuff);
        if  (len < 20)
            printf("%*c", 20 - len, ' ');

        len = 0;

        if  (operNext != operBuff)
        {
            printf("  ");

            *operNext = 0; printf("%s", operBuff);

            len += 4 + strlen(operBuff);
        }

        if  (insDispTemplatePtr)
        {
            IA64execUnits   xi = genInsXU(ins->idIns);
            IA64execUnits   xu = (IA64execUnits)*insDispTemplatePtr++;

            assert(dspCode);

            assert(xu == xi || (xi == XU_A && (xu == XU_I || xu == XU_M)));

            if  (*insDispTemplatePtr == XU_P)
            {
                printf(" ;;"); len += 3;

                insDispTemplatePtr++;
            }
        }

        if  (nocrlf)
        {
            if  (len < 32)
                printf("%*c", 32 - len, ' ');
        }
        else
            printf("\n");

        return;
    }

    printf(" %-6s %-10s", varTypeName(ins->idType), name);

    assert(ins->idKind == ins2kind(ins->idIns));

    switch (ins->idKind)
    {
        const   char *  name;

    case IK_NONE:
    case IK_LEAF:

    case IK_PROLOG:
    case IK_EPILOG:
        break;

    case IK_REG:
        printf("reg %2u", ins->idReg);
        break;

    case IK_CONST:
        switch (ins->idIns)
        {
        case INS_CNS_INT: printf("%I64d", ins->idConst.iInt); break;
        default:          printf("!!!ERROR!!!");             break;
        }
        break;

    case IK_VAR:

        printf("#%2u", ins->idLcl.iVar);

        name = TheCompiler->findVarName(ins->idLcl.iVar, ins->idLcl.iRef);
        if  (name)
            printf(" '%s'", name);

        break;

    case IK_UNOP:
    case IK_BINOP:

        printf("(");
        if  (ins->idOp.iOp1)
            printf(    IREF_DSP_FMT, ins->idOp.iOp1->idNum);
        else
            printf("NULL");
        if  (ins->idOp.iOp2)
            printf("," IREF_DSP_FMT, ins->idOp.iOp2->idNum);
        printf(")");

        break;

    case IK_TERNARY:

        printf("(");

        if  (ins->idOp3.iOp1)
            printf(    IREF_DSP_FMT, ins->idOp3.iOp1->idNum);
        else
            printf("NULL");

        if  (ins->idOp3.iOp2)
            printf("," IREF_DSP_FMT, ins->idOp3.iOp2->idNum);
        else
            printf("NULL");

        if  (ins->idOp3.iOp3)
            printf("," IREF_DSP_FMT, ins->idOp3.iOp3->idNum);

        printf(")");
        break;

    case IK_COMP:

        printf("p%02u,", ins->idComp.iPredT);
        printf("p%02u=", ins->idComp.iPredF);
        printf(       IREF_DSP_FMT, ins->idComp.iCmp1->idNum);
        printf(","    IREF_DSP_FMT, ins->idComp.iCmp2->idNum);
        printf(" => " IREF_DSP_FMT, ins->idComp.iUser->idNum);

        if  (ins->idFlags & IF_CMP_UNS)
            printf(" [uns]");

        break;

    case IK_JUMP:
        if  (ins->idJump.iCond)
            printf("iftrue(" IREF_DSP_FMT ") -> ", ins->idJump.iCond->idNum);

        printf(IBLK_DSP_FMT, CompiledFncCnt, ins->idJump.iDest->igNum);
        break;

    case IK_CALL  : printf("<display CALL>"  ); break;
    case IK_SWITCH: printf("<display SWITCH>"); break;

    default:        printf("!!!ERROR!!!"); break;
    }

DONE_INS:

    printf("\n");
}

static
void                insDispBlocks(bool codeOnly)
{
    insBlk          block;

    NatUns          bcnt = 0;
    NatUns          icnt = 0;

    for (block = insBlockList; block; block = block->igNext)
    {
        insPtr          last;
        insPtr          ins;

        assert(block->igNext || block == insBlockLast);

//      assert(block->igList);
//      assert(block->igLast);

        printf("Instruction block " IBLK_DSP_FMT " [%08X]:\n", CompiledFncCnt, block->igNum, block);

        bcnt++; assert(block->igNum == bcnt);

        for (last = NULL, ins = block->igList;
             ins;
             last = ins, ins = ins->idNext, icnt++)
        {
//          printf("{%3u} ", icnt);
            insDisp(ins, verbose, codeOnly);

            assert(ins->idPrev == last);
            assert(ins->idNum  == icnt);
        }

        printf("\n");
    }

    printf("\n");
}

static
void                genRenInstructions()
{
    insBlk          block;

    NatUns          icnt = 0;

    for (block = insBlockList; block; block = block->igNext)
    {
        insPtr          ins;

        for (ins = block->igList; ins; ins = ins->idNext, icnt++)
        {
            ins->idNum = icnt;
        }
    }
}

void                emitter::emitDispIns(instrDesc *id, bool isNew,
                                                        bool doffs,
                                                        bool asmfm, unsigned offs)
{
    if (isNew)
        printf("[%04X] ", offs);

    insDisp(id, asmfm, true);
}

const   char *      emitter::emitRegName(emitRegs reg)
{
    static char     buff[8];

    sprintf(buff, "r%u", reg);

    return  buff;
}

#endif
/*****************************************************************************
 *
 *  Used to detect uninitialized dependency info.
 */

#ifdef  DEBUG
insDep  *           insDepNone;
#endif

/*****************************************************************************
 *
 *  Helpers to extract operands of instructions.
 */

static
regNumber           insOpTmp(insPtr ins)
{
    NatUns          reg;

    assert(ins && ins->idTemp);

    if  (varTypeIsFloating(ins->idType))
    {
        assert(genTmpFltRegMap);

        reg = genTmpFltRegMap[ins->idTemp - 1];

        assert(reg >= REG_FLT_FIRST && reg <= REG_FLT_LAST);
    }
    else
    {
        assert(genTmpIntRegMap);

        reg = genTmpIntRegMap[ins->idTemp - 1];

        assert(reg >= REG_INT_FIRST && reg <= REG_INT_LAST);
    }

    return  (regNumber)reg;
}

regNumber           insOpReg(insPtr ins)
{
    assert(ins && (__int32)ins != 0xDDDDDDDD);

AGAIN:

    switch (ins->idIns)
    {
        NatUns              varNum;
        Compiler::LclVarDsc*varDsc;

        NatUns              reg;

    case INS_LCLVAR:

        assert(ins->idLcl.iVar < TheCompiler->lvaCount);

        varDsc = TheCompiler->lvaTable + ins->idLcl.iVar;

        assert(varDsc->lvRegister);

        return  varDsc->lvRegNum;

    case INS_PHYSREG:

        reg = ins->idReg;

//      if  (reg >= minOutArgIntReg && reg <= maxOutArgIntReg) printf("outgoing argument reg = %u -> %u\n", reg, reg - minOutArgIntReg + begOutArgIntReg);

        if  (reg >= minOutArgIntReg && reg <= maxOutArgIntReg)
            reg = reg - minOutArgIntReg + begOutArgIntReg;

        return  (regNumber)reg;

    case INS_br_call_IP:
    case INS_br_call_BR:

        ins = ins->idRes;
        goto AGAIN;

    default:
        return  insOpTmp(ins);
    }
}

regNumber           insOpDest (insPtr ins)
{
    assert(ins && (__int32)ins != 0xDDDDDDDD);

    if  (ins->idRes)
        return  insOpReg(ins->idRes);
    else
        return  insOpReg(ins);
}

static
NatInt              insOpCns32(insPtr ins)
{
    assert(ins && (__int32)ins != 0xDDDDDDDD);

    if  (ins->idIns == INS_ADDROF)
        return  TheCompiler->lvaFrameAddress(ins->idLcl.iVar);

    assert(ins);

    if  (ins->idIns == INS_CNS_INT)
        return  (NatInt)ins->idConst.iInt;

    assert(ins->idIns == INS_FRMVAR);

    return  (NatInt)TheCompiler->lvaTable[ins->idFvar.iVnum].lvStkOffs;
}

static
__int64             insOpCns64(insPtr ins)
{
    assert(ins && ins->idIns == INS_CNS_INT);

    return  (__int64)ins->idConst.iInt;
}

inline
regNumber           insIntRegNum(regNumber reg)
{
    assert(reg >= REG_INT_FIRST && reg <= REG_INT_LAST);

    return  (regNumber)(reg - REG_INT_FIRST);
}

inline
regNumber           insFltRegNum(regNumber reg)
{
    assert(reg >= REG_FLT_FIRST && reg <= REG_FLT_LAST);

    return  (regNumber)(reg - REG_FLT_FIRST);
}

/*****************************************************************************
 *
 *  Allocate a instruction of the given flavor.
 */

static
unsigned char       insSizes[] =
{
    ins_size_base,      // IK_NONE

    ins_size_base,      // IK_LEAF
    ins_size_const,     // IK_CONST
    ins_size_glob,      // IK_GLOB
    ins_size_fvar,      // IK_FVAR
    ins_size_var,       // IK_VAR
    ins_size_reg,       // IK_REG
    ins_size_movip,     // IK_MOVIP

    ins_size_arg,       // IK_ARG
    ins_size_op,        // IK_UNOP
    ins_size_op,        // IK_BINOP
    ins_size_op,        // IK_ASSIGN
    ins_size_op3,       // IK_TERNARY

    ins_size_comp,      // IK_COMP

    ins_size_jump,      // IK_JUMP
    ins_size_call,      // IK_CALL
    ins_size_ijmp,      // IK_IJMP

    0,                  // IK_SWITCH

    ins_size_prolog,    // IK_PROLOG
    ins_size_epilog,    // IK_EPILOG

    ins_size_srcline,   // IK_SRCLINE
};

static
insPtr              insAllocRaw(instruction ins, varType_t tp)
{
    size_t          insSize;
    insKinds        insKind;
    insPtr          insDesc;

    assert(insSizes[IK_NONE   ] == ins_size_base   );
    assert(insSizes[IK_LEAF   ] == ins_size_base   );
    assert(insSizes[IK_CONST  ] == ins_size_const  );
    assert(insSizes[IK_GLOB   ] == ins_size_glob   );
    assert(insSizes[IK_FVAR   ] == ins_size_fvar   );
    assert(insSizes[IK_VAR    ] == ins_size_var    );
    assert(insSizes[IK_REG    ] == ins_size_reg    );
    assert(insSizes[IK_UNOP   ] == ins_size_op     );
    assert(insSizes[IK_BINOP  ] == ins_size_op     );
    assert(insSizes[IK_ASSIGN ] == ins_size_op     );
    assert(insSizes[IK_TERNARY] == ins_size_op3    );
    assert(insSizes[IK_COMP   ] == ins_size_comp   );
    assert(insSizes[IK_JUMP   ] == ins_size_jump   );
    assert(insSizes[IK_CALL   ] == ins_size_call   );
    assert(insSizes[IK_SWITCH ] == 0               );
    assert(insSizes[IK_PROLOG ] == ins_size_prolog );
    assert(insSizes[IK_EPILOG ] == ins_size_epilog );
    assert(insSizes[IK_SRCLINE] == ins_size_srcline);

    insKind = ins2kind(ins);
    insSize = insSizes[insKind]; assert(insSize);
    insDesc = (insPtr)insAllocMem(insSize); assert(insDesc);

    insDesc->idIns   = ins;
    insDesc->idType  = tp;
    insDesc->idKind  = insKind;
    insDesc->idFlags = 0;
    insDesc->idTemp  = 0;
    insDesc->idRes   = NULL;
    insDesc->idPred  = 0;

    insDesc->idSrcCnt = 0;
    insDesc->idDstCnt = 0;

#ifdef  DEBUG
    insDesc->idSrcTab =
    insDesc->idDstTab = UNINIT_DEP_TAB;
#endif

    insBuildIcnt++;

#if 0
    if ((int)insDesc == 0x02d51e10) BreakIfDebuggerPresent();
#endif

//  if  ((int)insDesc == 0x02c43934 && ins == INS_mov_reg && insBuildCount == 90) __asm int 3

    return  insDesc;
}

inline
insPtr              insAlloc(instruction ins, varType_t tp)
{
    insPtr          insDesc = insAllocRaw(ins, tp);

    /* Append the new instruction to the current instruction block */

    assert(insBuildList);
    assert(insBuildLast);

    insDesc->idPrev = insBuildLast;
                      insBuildLast->idNext = insDesc;
                      insBuildLast         = insDesc;

#ifdef  DEBUG

    insDesc->idNum  = insBuildCount++;

#if 0
    if (insDesc->idNum == 31) BreakIfDebuggerPresent();
#endif

#endif

    return  insDesc;
}

inline
insPtr              insAllocNX(instruction ins, varType_t tp)
{
    insPtr          insDesc = insAllocRaw(ins, tp);

    insDesc->idPrev  =
    insDesc->idNext  = NULL;
    insDesc->idFlags = IF_NO_CODE;

#ifdef  DEBUG
    insDesc->idNum   = 0;
#endif

#if 0
    if (insDesc->idNum == 78) BreakIfDebuggerPresent();
#endif

    return  insDesc;
}

insPtr              insAllocIns(instruction ins, varType_t tp, insPtr prev,
                                                               insPtr next)
{
    insPtr          insDesc = insAllocRaw(ins, tp);

    assert(prev != NULL && prev->idNext == next);
    assert(next == NULL || next->idPrev == prev);

    insDesc->idNext = next;
    insDesc->idPrev = prev;
                      prev->idNext = insDesc;

    if  (next)
        next->idPrev = insDesc;

#ifdef  DEBUG
    insDesc->idNum  = 0;
#endif

    return  insDesc;
}

inline
insDep  *           insAllocDep(NatUns size)
{
    return  (insDep*)insAllocMem(size * sizeof(insDep));
}

insDep  *           insMakeDepTab1(insDepKinds kind, NatUns num)
{
    insDep  *       dep = insAllocDep(1);

    dep[0].idepKind = kind;
    dep[0].idepNum  = num;

    return  dep;
}

insDep  *           insMakeDepTab2(insDepKinds kind1, NatUns num1,
                                   insDepKinds kind2, NatUns num2)
{
    insDep  *       dep = insAllocDep(2);

    dep[0].idepKind = kind1;
    dep[0].idepNum  = num1;

    dep[1].idepKind = kind2;
    dep[1].idepNum  = num2;

    return  dep;
}

inline
void                insMarkDepS0D0(insPtr ins)
{
    assert(ins->idSrcTab == UNINIT_DEP_TAB);
    assert(ins->idDstTab == UNINIT_DEP_TAB);

#ifdef  DEBUG
    ins->idSrcTab = insDepNone;
    ins->idDstTab = insDepNone;
#endif

}

inline
void                insMarkDepS1D0(insPtr ins, insDepKinds srcKind1,
                                               NatUns      srcNumb1)
{
    assert(ins->idSrcTab == UNINIT_DEP_TAB);
    assert(ins->idDstTab == UNINIT_DEP_TAB);

#ifdef  DEBUG
    ins->idDstTab = insDepNone;
#endif

    ins->idSrcCnt = 1;
    ins->idSrcTab = insMakeDepTab1(srcKind1, srcNumb1);
}

inline
void                insMarkDepS0D1(insPtr ins, insDepKinds dstKind1,
                                               NatUns      dstNumb1)
{
    assert(ins->idSrcTab == UNINIT_DEP_TAB);
    assert(ins->idDstTab == UNINIT_DEP_TAB);

#ifdef  DEBUG
    ins->idSrcTab = insDepNone;
#endif

    ins->idDstCnt = 1;
    ins->idDstTab = insMakeDepTab1(dstKind1, dstNumb1);
}

inline
void                insMarkDepS1D1(insPtr ins, insDepKinds srcKind1,
                                               NatUns      srcNumb1,
                                               insDepKinds dstKind1,
                                               NatUns      dstNumb1)
{
    assert(ins->idSrcTab == UNINIT_DEP_TAB);
    assert(ins->idDstTab == UNINIT_DEP_TAB);

    ins->idSrcCnt = 1;
    ins->idSrcTab = insMakeDepTab1(srcKind1, srcNumb1);

    ins->idDstCnt = 1;
    ins->idDstTab = insMakeDepTab1(dstKind1, dstNumb1);
}

void                insMarkDepS2D1(insPtr ins, insDepKinds srcKind1,
                                               NatUns      srcNumb1,
                                               insDepKinds srcKind2,
                                               NatUns      srcNumb2,
                                               insDepKinds dstKind1,
                                               NatUns      dstNumb1)
{
    assert(ins->idSrcTab == UNINIT_DEP_TAB);
    assert(ins->idDstTab == UNINIT_DEP_TAB);

    ins->idSrcCnt = 2;
    ins->idSrcTab = insMakeDepTab2(srcKind1, srcNumb1,
                                   srcKind2, srcNumb2);

    ins->idDstCnt = 1;
    ins->idDstTab = insMakeDepTab1(dstKind1, dstNumb1);
}

/*****************************************************************************/

static
void                markGetOpDep(insPtr ins, insDep *dst)
{
    insDepKinds     kind;
    NatUns          numb;

    switch(ins->idIns)
    {
    case INS_LCLVAR:

        assert(ins->idLcl.iVar < TheCompiler->lvaCount);

        kind = IDK_LCLVAR;
        numb = ins->idLcl.iVar + 1;
        break;

    case INS_PHYSREG:
        kind = IDK_REG_INT;
        numb = ins->idReg;
        break;

//  case INS_br_call_IP:
//  case INS_br_call_BR:
//
//      ins = ins->idRes;
//      goto AGAIN;

    case INS_CNS_INT:

        // This is kind of lame but it makes some things simpler elsewhere ...

        kind = IDK_NONE;
        numb = 0;
        break;

    default:
        kind = varTypeIsFloating(ins->idType) ? IDK_TMP_FLT : IDK_TMP_INT;
        numb = ins->idTemp; assert(numb);
        break;
    }

    dst->idepKind = kind;
    dst->idepNum  = numb;
}

/*****************************************************************************/

inline
void                markDepSrcOp(insPtr ins)
{
    assert(ins->idSrcCnt == 0);
#ifdef  DEBUG
    ins->idSrcTab = insDepNone;
#endif
}

inline
void                markDepDstOp(insPtr ins)
{
    assert(ins->idDstCnt == 0);
#ifdef  DEBUG
    ins->idDstTab = insDepNone;
#endif
}

inline
void                markDepSrcOp(insPtr ins, insDepKinds srcKind,
                                             NatUns      srcNumb)
{
    insDep  *       dep;

    assert(ins->idSrcCnt == 0);

    ins->idSrcCnt = 1;
    ins->idSrcTab = insMakeDepTab1(srcKind, srcNumb);
}

inline
void                markDepDstOp(insPtr ins, insDepKinds dstKind,
                                             NatUns      dstNumb)
{
    insDep  *       dep;

    assert(ins->idDstCnt == 0);

    ins->idDstCnt = 1;
    ins->idDstTab = insMakeDepTab1(dstKind, dstNumb);
}

void                markDepSrcOp(insPtr ins, insPtr src)
{
    insDep  *       dep;

    assert(ins->idSrcCnt == 0);

    ins->idSrcCnt = 1;
    ins->idSrcTab = dep = insAllocDep(1);

    markGetOpDep(src, dep);
}

void                markDepSrcOp(insPtr ins, insPtr src1,
                                             insPtr src2)
{
    insDep  *       dep;

    assert(ins->idSrcCnt == 0);

    ins->idSrcCnt = 2;
    ins->idSrcTab = dep = insAllocDep(2);

    markGetOpDep(src1, dep);
    markGetOpDep(src2, dep+1);
}

inline
void                markDepDstOp(insPtr ins, insPtr dst)
{
    insDep  *       dep;

    assert(ins->idDstCnt == 0);

    ins->idDstCnt = 1;
    ins->idDstTab = dep = insAllocDep(1);

    markGetOpDep(dst, dep);
}

inline
void                markDepDstOp(insPtr ins, insPtr dst1,
                                             insPtr dst2)
{
    insDep  *       dep;

    assert(ins->idDstCnt == 0);

    ins->idDstCnt = 2;
    ins->idDstTab = dep = insAllocDep(2);

    markGetOpDep(dst1, dep);
    markGetOpDep(dst2, dep+1);
}

void                markDepSrcOp(insPtr ins, insPtr      srcIns1,
                                             insDepKinds srcKind2,
                                             NatUns      srcNumb2)
{
    insDep  *       dep;

    assert(ins->idSrcTab == UNINIT_DEP_TAB);

    ins->idSrcCnt = 2;
    ins->idSrcTab = dep = insAllocDep(2);

    markGetOpDep(srcIns1, dep);

    dep[1].idepKind = srcKind2;
    dep[1].idepNum  = srcNumb2;
}

void                markDepDstOp(insPtr ins, insPtr      dstIns1,
                                             insDepKinds dstKind2,
                                             NatUns      dstNumb2)
{
    insDep  *       dep;

    assert(ins->idDstTab == UNINIT_DEP_TAB);

    ins->idDstCnt = 2;
    ins->idDstTab = dep = insAllocDep(2);

    markGetOpDep(dstIns1, dep);

    dep[1].idepKind = dstKind2;
    dep[1].idepNum  = dstNumb2;
}

/*****************************************************************************
 *
 *  Finish the current instruction block.
 */

static
void                insBuildEndBlk(insBlk bnext)
{
    assert(insBlockList);
    assert(insBlockLast);

    insBlockLast->igNext = bnext;

    if  (insBuildList)
    {
        assert(insBuildList == insBuildHead);
        insBuildList = insBuildList->idNext;
        assert(insBuildList != insBuildHead);

        if  (!insBuildList || insBuildLast == insBuildHead)
        {
            printf("// ISSUE: why the heck did we create an empty block?\n");

            insBuildList =
            insBuildLast = NULL;
        }
        else
        {
            insBuildList->idPrev = NULL;
            insBuildLast->idNext = NULL;
        }
    }

    insBlockLast->igList   = insBuildList;
    insBlockLast->igLast   = insBuildLast;

    insBlockLast->igInsCnt = insBuildIcnt;

    if  (insBuildImax < insBuildIcnt)
         insBuildImax = insBuildIcnt;
}

/*****************************************************************************
 *
 *  Allocate a new instruction block.
 */

inline
insBlk              insAllocBlk()
{
    insBlk          block = (insBlk)insAllocMem(sizeof(*block));

    block->igPredCnt = 0;
    block->igSuccCnt = 0;

#ifdef  DEBUG

    block->igSelf    = block;

    block->igPredTab = (insBlk*)-1;
    block->igSuccTab = (insBlk*)-1;

//  if  ((int)block == 0x02c40978) __asm int 3

#endif

    return  block;
}

/*****************************************************************************
 *
 *  Start a new instruction block.
 */

static
insBlk              insBuildBegBlk(BasicBlock * oldbb = NULL)
{
    insBlk          block;

    /* Did we encounter any forward references to this block earlier ? */

    if  (oldbb && oldbb->bbInsBlk)
    {
        insBlk *        fwdref;
        insBlk          fwdnxt;

        block = (insBlk)oldbb->bbInsBlk; assert(block->igSelf == block);

        assert(block->igList == NULL);
        assert(block->igLast != NULL);

//      if  ((int)block == 0x02c40978) __asm int 3

        fwdref = (insBlk*)block->igLast;
        do
        {
            fwdnxt = *fwdref;
                     *fwdref = block;

#ifdef  DEBUG
            insBlockPatch--;
#endif

            fwdref = (insBlk*)fwdnxt;
        }
        while (fwdref);
    }
    else
    {
        block = insAllocBlk();
    }

    ++insBlockCount;

#ifdef  DEBUG
    block->igSelf = block;
    block->igNum  = insBlockCount;
#endif

    /* Code for this block has not yet been emitted */

    block->igOffs = -1;

    /* Record the "weight" of the block */

    block->igWeight = TheCompiler->compCurBB->bbWeight;

    /* Is there an open block? */

    if  (insBlockList)
    {
        insBuildEndBlk(block);
    }
    else
    {
        insBlockList = block;
    }

    insBlockLast = block;

    /* Make it clear that this block is being compiled to instructions */

    block->igList = insBuildHead;

    /* Start the list with a reusable fake entry */

    insBuildList =
    insBuildLast = insBuildHead; assert(insBuildHead);

    insBuildIcnt = 0;

    return block;
}

/*****************************************************************************
 *
 *  Return non-zero if the current code block is non-empty.
 */

inline
bool                insCurBlockNonEmpty()
{
    return  (insBuildLast == insBuildHead);
}

/*****************************************************************************
 *
 *  Create a nop instruction (taking care to keep it off any "real" lists).
 */

insPtr              scIA64nopCreate(IA64execUnits xu)
{
    insPtr          insDesc;

    insDesc = (insPtr)insAllocMem(ins_size_base); assert(insDesc);

    assert(INS_nop_m == INS_nop_m + (XU_M - XU_M));
    assert(INS_nop_i == INS_nop_m + (XU_I - XU_M));
    assert(INS_nop_b == INS_nop_m + (XU_B - XU_M));
    assert(INS_nop_f == INS_nop_m + (XU_F - XU_M));

    insDesc->idIns   = (instruction)(INS_nop_m + (xu - XU_M));
    insDesc->idType  = TYP_VOID;
    insDesc->idKind  = IK_LEAF;
    insDesc->idFlags = 0;
    insDesc->idTemp  = 0;
    insDesc->idRes   = NULL;
    insDesc->idPred  = 0;

#ifdef  DEBUG
    insDesc->idNum   = 0;
#endif

    return  insDesc;
}

/*****************************************************************************
 *
 *  Holds any NOP instructions we've created so far (should be instance var).
 */

insPtr              scIA64nopTab[XU_COUNT];

/*****************************************************************************
 *
 *  Prepare for collection of IA64 instructions.
 */

void                insBuildInit()
{
    insDsc          fake;

    insAllocator.nraStart(4096);

    insBuildList  =
    insBuildLast  = &fake;

    insBuildHead  = insAlloc(INS_ignore, TYP_UNDEF);

    insBlockList  =
    insBlockLast  = NULL;

    insBuildImax  = 0;

    insBlockCount = 0;

#ifdef  DEBUG

    insDepNone    = (insDep*)insAllocMem(sizeof(*insDepNone));

    insBuildCount = 0;
    insBlockPatch = 0;

    memset(scIA64nopTab, 0xFF, sizeof(scIA64nopTab));

#endif

    scIA64nopTab[XU_M] = scIA64nopCreate(XU_M);
    scIA64nopTab[XU_I] = scIA64nopCreate(XU_I);
    scIA64nopTab[XU_B] = scIA64nopCreate(XU_B);
    scIA64nopTab[XU_F] = scIA64nopCreate(XU_F);

//  scIA64nopTab[XU_L] = scIA64nopCreate(XU_L);
//  scIA64nopTab[XU_X] = scIA64nopCreate(XU_X);

    insBuildBegBlk();
}

/*****************************************************************************
 *
 *  Finish creating inss.
 */

static
void                insBuildDone()
{
    if  (insBlockList)
        insBuildEndBlk(NULL);

    assert(insBlockPatch == 0);
}

static
void                insResolveJmpTarget(BasicBlock * dest, insBlk * dref)
{
    insBlk          block;

    assert(dest->bbFlags & BBF_JMP_TARGET);

    block = (insBlk)dest->bbInsBlk;

    /* Do we already have a destination instruction block? */

    if  (block)
    {
        assert(block->igSelf == block);

        /* Has the destination instruction block been generated? */

        if  (block->igList)
        {
            /* Backward jump, that's easy */

            *dref = block;
            return;
        }
    }
    else
    {
        dest->bbInsBlk = block = insAllocBlk();

        /* Make it clear that this is not a "real" instruction block just yet */

        block->igList =
        block->igLast = NULL;
    }

#ifdef  DEBUG
    insBlockPatch++;
#endif

    /* We'll have to patch this reference later */

//  if  ((int)block == 0x02c40978) __asm int 3

    *dref = (insBlk)block->igLast;
                    block->igLast = (insPtr)dref;
}

/*****************************************************************************
 *
 *  This should obviously done by the time we get to this file - fix this!!!
 */

void                Compiler::genMarkBBlabels()
{
    BasicBlock *    lblk;
    BasicBlock *    block;

    for (lblk =     0, block = fgFirstBB;
                       block;
         lblk = block, block = block->bbNext)
    {
        block->bbInsBlk = NULL;

        if  (lblk == NULL)
        {
            /* Treat the initial block as a jump target */

            block->bbFlags |= BBF_JMP_TARGET|BBF_HAS_LABEL;
        }
        else if (fgBlockHasPred(block, lblk, fgFirstBB, fgLastBB))
        {
            /* Someone other than the previous block jumps to this block */

            block->bbFlags |= BBF_JMP_TARGET|BBF_HAS_LABEL;
        }
        else if (block->bbCatchTyp)
        {
            /* Catch handlers have implicit jumps to them */

            block->bbFlags |= BBF_JMP_TARGET|BBF_HAS_LABEL;
        }
        else if (block->bbJumpKind == BBJ_THROW && (block->bbFlags & BBF_INTERNAL))
        {
            /* This must be a "range check failed" or "overflow" block */

            block->bbFlags |= BBF_JMP_TARGET|BBF_HAS_LABEL;
        }

        switch (block->bbJumpKind)
        {
            GenTreePtr      test;

            BasicBlock * *  jmpTab;
            NatUns          jmpCnt;

        case BBJ_COND:

            /* Special case: long/FP compares generate two jumps */

            test = block->bbTreeList; assert(test);
            test = test->gtPrev;

            /* "test" should be the condition */

            assert(test);
            assert(test->gtNext == 0);
            assert(test->gtOper == GT_STMT);
            test = test->gtStmt.gtStmtExpr;
            assert(test->gtOper == GT_JTRUE);
            test = test->gtOp.gtOp1;

#if!CPU_HAS_FP_SUPPORT
            if  (test->OperIsCompare())
#endif
            {
                assert(test->OperIsCompare());
                test = test->gtOp.gtOp1;
            }

            switch (test->gtType)
            {
            case TYP_LONG:
            case TYP_FLOAT:
            case TYP_DOUBLE:

                block->bbNext->bbFlags |= BBF_JMP_TARGET|BBF_HAS_LABEL;
                break;
            }

            // Fall through ...

        case BBJ_ALWAYS:
            block->bbJumpDest->bbFlags |= BBF_JMP_TARGET|BBF_HAS_LABEL;
            break;

        case BBJ_SWITCH:

            jmpCnt = block->bbJumpSwt->bbsCount;
            jmpTab = block->bbJumpSwt->bbsDstTab;

            do
            {
                (*jmpTab)->bbFlags |= BBF_JMP_TARGET|BBF_HAS_LABEL;
            }
            while (++jmpTab, --jmpCnt);

            break;
        }
    }

    if  (TheCompiler->info.compXcptnsCount)
    {
        NatUns          XTnum;
        EHblkDsc *      HBtab;

        for (XTnum = 0, HBtab = compHndBBtab;
             XTnum < TheCompiler->info.compXcptnsCount;
             XTnum++  , HBtab++)
        {
            assert(HBtab->ebdTryBeg); HBtab->ebdTryBeg->bbFlags |= BBF_HAS_LABEL;
            if    (HBtab->ebdTryEnd)  HBtab->ebdTryEnd->bbFlags |= BBF_HAS_LABEL;

            assert(HBtab->ebdHndBeg); HBtab->ebdHndBeg->bbFlags |= BBF_HAS_LABEL;
            if    (HBtab->ebdHndEnd)  HBtab->ebdHndEnd->bbFlags |= BBF_HAS_LABEL;

            if    (HBtab->ebdFlags & JIT_EH_CLAUSE_FILTER)
            {assert(HBtab->ebdFilter);HBtab->ebdFilter->bbFlags |= BBF_HAS_LABEL; }
        }
    }
}

/*****************************************************************************
 *
 *  Converts a size in bytes into an index (1->0,2->1,4->2,8->3).
 */

static
NatUns              genInsSizeIncr(size_t size)
{
    static
    BYTE            sizeIncs[] =
    {
       -1,      // 0
        0,      // 1
        1,      // 2
       -1,
        2,      // 4
       -1,
       -1,
       -1,
        3       // 8
    };

    assert(size == 1 || size == 2 || size == 4 || size == 8);
    assert(sizeIncs[size] < 0xFF);

    return sizeIncs[size];
}

/*****************************************************************************
 *
 *  If the given instruction holds a temporary, free it up.
 */

static
void                insFreeTemp(insPtr ins)
{
    if  (genTmpAlloc)
        return;

    if  (ins->idTemp == 0)
        return;

    /* Is this an integer or float value? */

    if  (varTypeIsScalar(ins->idType))
    {
        assert(bitset128test( genFreeIntRegs, ins->idTemp-1) == 0);
               bitset128set (&genFreeIntRegs, ins->idTemp-1);
    }
    else
    {
        assert(varTypeIsFloating(ins->idType));

        assert(bitset128test( genFreeFltRegs, ins->idTemp-1) == 0);
               bitset128set (&genFreeFltRegs, ins->idTemp-1);
    }
}

/*****************************************************************************
 *
 *  Grab a temporary to hold the result of the given instruction; if 'keep' is
 *  non-zero we mark the temp as "in use".
 */

static
void                insFindTemp(insPtr ins, bool keep)
{
    NatUns          reg;

    assert(ins->idTemp == 0);

    if  (genTmpAlloc)
    {
        UNIMPL("grab temp symbol for 'smart' local/temp register allocator");
    }

    assert((ins->idFlags & IF_NO_CODE) == 0);

    /* Is this an integer or float value? */

    if  (varTypeIsScalar(ins->idType))
    {
        /* Simply grab the lowest available temp-reg */

        reg = bitset128lowest1(genFreeIntRegs);

        /* Mark the temp-reg as no longer free, if appropriate */

        if  (keep)
            bitset128clr(&genFreeIntRegs, reg);

        reg++;

        /* Remember the highest temp-reg we ever use */

        if  (cntTmpIntReg < reg)
             cntTmpIntReg = reg;
    }
    else
    {
        /* We assume that all values are either integral or floating-point */

        assert(varTypeIsFloating(ins->idType));

        /* Simply grab the lowest available temp-reg */

        reg = bitset128lowest1(genFreeFltRegs);

        /* Mark the temp-reg as no longer free, if appropriate */

        if  (keep)
            bitset128clr(&genFreeFltRegs, reg);

        reg++;

        /* Remember the highest temp-reg we ever use */

        if  (cntTmpFltReg < reg)
             cntTmpFltReg = reg;
    }

    /* Record the chosen temp number in the instruction */

    ins->idTemp = reg;
}

/*****************************************************************************
 *
 *  Record the fact that there is a call in the current function. Note that we
 *  keep track of the set of temps live across function calls so that we can
 *  properly assign them to register later.
 */

static
void                genMarkNonLeafFunc()
{
    genNonLeafFunc = true;

    bitset128nset(&genCallIntRegs,    genFreeIntRegs);
    bitset128nset(&genCallFltRegs,    genFreeFltRegs);
                   genCallSpcRegs &= ~genFreeSpcRegs;
}

/*****************************************************************************
 *
 *  Extract the integer constant value from a tree node.
 */

inline
__int64             genGetIconValue(GenTreePtr tree)
{
    assert(tree->OperIsConst());
    assert(varTypeIsScalar(tree->gtType));

    /* The value better not be an address / handle */

    assert((tree->gtFlags & GTF_ICON_HDL_MASK) != GTF_ICON_PTR_HDL);

    if  (tree->gtOper == GT_CNS_LNG)
        return  tree->gtLngCon.gtLconVal;

    assert(tree->gtOper == GT_CNS_INT);

    if  (varTypeIsUnsigned(tree->gtType))
        return  (unsigned __int32)tree->gtIntCon.gtIconVal;
    else
        return  (  signed __int32)tree->gtIntCon.gtIconVal;
}

/*****************************************************************************
 *
 *  Create an integer constant instruction.
 */

static
insPtr              genAllocInsIcon(__int64 ival, varType_t type = TYP_I_IMPL)
{
    insPtr          ins;

    ins               = insAllocNX(INS_CNS_INT, type);
    ins->idConst.iInt = ival;

    insMarkDepS0D0(ins);

    return  ins;
}

inline
insPtr              genAllocInsIcon(GenTreePtr tree)
{
    return  genAllocInsIcon(genGetIconValue(tree), tree->gtType);
}

/*****************************************************************************
 *
 *  Allocate an opcode that references a physical register.
 */

inline
insPtr              insPhysRegRef(regNumber reg, varType_t type, bool isdef)
{
    insPtr          ins;

    ins           = insAllocNX(INS_PHYSREG, type);
    ins->idReg    = reg;

    if  (isdef)
        insMarkDepS0D1(ins, IDK_REG_INT, reg);
    else
        insMarkDepS1D0(ins, IDK_REG_INT, reg);

    return  ins;
}

/*****************************************************************************
 *
 *  Create instruction(s) to set 'dest' (which is either a local variable/reg
 *  or NULL in which case a temp-reg is assumed) to the given constant value.
 */

static
insPtr              genAssignIcon(insPtr dest, GenTreePtr cnsx)
{
    __int64         ival;
    insPtr          icns;
    insPtr          ins;

    /* Special case: address of a global variable or function */

    if  (cnsx->gtOper == GT_CNS_INT)
    {
        switch (cnsx->gtFlags & GTF_ICON_HDL_MASK)
        {
            insPtr          reg;
            insPtr          adr;
            insPtr          ind;

            NatUns          indx;

            _uint64         offs;

        case GTF_ICON_PTR_HDL:

            /* Add a pointer to the variable to the small data section */

            genPEwriter->WPEsecAddFixup(PE_SECT_sdata,
                                        PE_SECT_data,
                                        genPEwriter->WPEsecNextOffs(PE_SECT_sdata),
                                        true);

            offs = genPEwriter->WPEsrcDataRef(cnsx->gtIntCon.gtIconVal);

            assert(sizeof(offs) == 8);

            offs = genPEwriter->WPEsecAddData(PE_SECT_sdata, (BYTE*)&offs, sizeof(offs));

            /* Create a "global variable" node */

            ins               = insAllocNX(INS_GLOBVAR, TYP_I_IMPL);
            ins->idGlob.iOffs = (NatUns)offs;

            insMarkDepS0D0(ins);

            reg               = insPhysRegRef(REG_gp, TYP_I_IMPL, false);

            adr               = insAlloc(INS_add_reg_i14, TYP_I_IMPL);
            adr->idOp.iOp1    = reg;
            adr->idOp.iOp2    = ins;

            insFindTemp(adr, true);

            insMarkDepS1D1(adr, IDK_REG_INT, REG_gp,
                                IDK_TMP_INT, adr->idTemp);

            /* Indirect through the address to get the pointer value */

            ind               = insAlloc(INS_ld8_ind, TYP_I_IMPL);
            ind->idOp.iOp1    = adr;
            ind->idOp.iOp2    = NULL;

            /* Record the appropriate dependencies for the instruction */

            indx = emitter::scIndDepIndex(ind);

            if  (dest)
            {
                markDepSrcOp(ind);
                markDepDstOp(ind, dest, IDK_IND, indx);
            }
            else
            {
                insFindTemp(ind, true);

                insMarkDepS2D1(ind, IDK_TMP_INT, adr->idTemp,
                                    IDK_IND    , indx,
                                    IDK_TMP_INT, ind->idTemp);
            }

            insFreeTemp(adr);

            return  ind;

    case GTF_ICON_FTN_ADDR:

            assert(dest == NULL);   // ISSUE: is this safe?

            /* Create a "global variable" node */

            ins               = insAllocNX(INS_GLOBVAR, TYP_I_IMPL);
            ins->idGlob.iOffs = (NatUns)cnsx->gtIntCon.gtIconVal;

            insMarkDepS0D0(ins);

            reg               = insPhysRegRef(REG_gp, TYP_I_IMPL, false);

            adr               = insAlloc(INS_add_reg_i14, TYP_I_IMPL);
            adr->idOp.iOp1    = reg;
            adr->idOp.iOp2    = ins;

            insFindTemp(adr, true);

            insMarkDepS1D1(adr, IDK_REG_INT, REG_gp,
                                IDK_TMP_INT, adr->idTemp);

            return  adr;
        }
    }

    /* Create an instruction for the constant value */

    icns = genAllocInsIcon(cnsx); assert(icns->idIns == INS_CNS_INT);
    ival = icns->idConst.iInt;

    /* Is the constant small enough or even zero ? */

    if      (ival == 0 && !dest)
    {
        return  insPhysRegRef(REG_r000, cnsx->gtType, false);
    }
    else if (signed64IntFitsInBits(ival, 22))
    {
        /* We can use "mov r1, imm22" */

        ins = insAlloc(INS_mov_reg_i22, cnsx->gtType);
    }
    else
    {
        /* We'll have to use "movl r1, icon" */

        ins = insAlloc(INS_mov_reg_i64, cnsx->gtType);
    }

    ins->idRes     = dest;
    ins->idOp.iOp1 = NULL;
    ins->idOp.iOp2 = icns;

    if  (dest)
    {
        markDepSrcOp  (ins);
        markDepDstOp  (ins, dest);
    }
    else
    {
        insFindTemp   (ins, true);
        insMarkDepS0D1(ins, IDK_TMP_INT, ins->idTemp);
    }

    return  ins;
}

/*****************************************************************************
 *
 *  Perform local temp register allocation for each basic block.
 */

void                Compiler::genAllocTmpRegs()
{
    NatUns          intTempCnt;
    NatUns          fltTempCnt;

    NatUns          intMaxStk = REG_INT_MAX_STK - genOutArgRegCnt;

    assert(lastIntStkReg >= REG_INT_MIN_STK &&
           lastIntStkReg <= REG_INT_MAX_STK);

    /* Initialize, in case we have no temps at all */

    genTmpFltRegMap  = NULL;
    genTmpIntRegMap  = NULL;

    /* See how many temps we need */

    intTempCnt = cntTmpIntReg;
    fltTempCnt = cntTmpFltReg;

    if  (!intTempCnt && !fltTempCnt)
        return;

    /* Allocate the temp-num -> register maps */

    if  (intTempCnt) genTmpIntRegMap = (regNumber*)insAllocMem(intTempCnt * sizeof(*genTmpIntRegMap));
    if  (fltTempCnt) genTmpFltRegMap = (regNumber*)insAllocMem(fltTempCnt * sizeof(*genTmpFltRegMap));

    if  (genTmpAlloc)
    {
        UNIMPL("smart temp-reg alloc");
    }
    else
    {
        NatUns          tempNum;
        regNumber   *   tempMap;
        regNumber       tempReg;

        /* Prepare to start grabbing registers from the various tables */

        BYTE        *   nxtIntStkReg = nxtIntStkRegAddr;
        BYTE        *   nxtIntScrReg = nxtIntScrRegAddr;
        BYTE        *   nxtFltSavReg = nxtFltSavRegAddr;
        BYTE        *   nxtFltScrReg = nxtFltScrRegAddr;

        /* Process all integer temps */

        for (tempNum = 0, tempMap = genTmpIntRegMap;
             tempNum < intTempCnt;
             tempNum++  , tempMap++)
        {
            /* Was this temp ever live across a call? */

            if  (bitset128test(genCallIntRegs, tempNum))
            {
                /* We have to use a stacked (callee-saved) register */

                do
                {
                    tempReg = (regNumber)*nxtIntStkReg++;
                }
                while ((unsigned)tempReg >= minRsvdIntStkReg &&
                       (unsigned)tempReg <= maxRsvdIntStkReg ||
                       (unsigned)tempReg >= intMaxStk);

                if  (tempReg == REG_NA)
                {
                    nxtIntStkReg--;
                    UNIMPL("ran out of stacked int regs for temps, now what?");
                }

                if  (lastIntStkReg <= (unsigned)tempReg)
                     lastIntStkReg  =           tempReg + 1;
            }
            else
            {
                tempReg = (regNumber)*nxtIntScrReg++;

                if  (tempReg == REG_NA)
                {
                    UNIMPL("ran out of scratch int regs for temps, now what?");
                }
            }

#ifdef  DEBUG
            if (dspCode) printf("// tmp #%03u assigned to r%03u\n", tempNum, insIntRegNum(tempReg));
#endif

            *tempMap = tempReg;
        }

        /* Process all FP temps */

        for (tempNum = 0, tempMap = genTmpFltRegMap;
             tempNum < fltTempCnt;
             tempNum++  , tempMap++)
        {
            /* Was this temp ever live across a call? */

            if  (bitset128test(genCallFltRegs, tempNum))
            {
                tempReg = (regNumber)*nxtFltSavReg++;

                if  (tempReg == REG_NA)
                {
                    UNIMPL("ran out of saved flt regs for temps, now what?");
                }
            }
            else
            {
                tempReg = (regNumber)*nxtFltScrReg++;

                if  (tempReg == REG_NA)
                {
                    UNIMPL("ran out of scratch flt regs for temps, now what?");
                }
            }

#ifdef  DEBUG
            if (dspCode) printf("// tmp #%02u assigned to f%03u\n", tempNum, insFltRegNum(tempReg));
#endif

            *tempMap = tempReg;
        }

        /* Tell everyone where we ended our register grab */

        nxtIntStkRegAddr = nxtIntStkReg;
        nxtIntScrRegAddr = nxtIntScrReg;
        nxtFltSavRegAddr = nxtFltSavReg;
        nxtFltScrRegAddr = nxtFltScrReg;
    }
}

/*****************************************************************************
 *
 *  Compute per-block dataflow info - kill/use/etc.
 */

void                Compiler::genComputeLocalDF()
{
    insBlk          block;

    bitVectVars     varDef; varDef.bvCreate();
    bitVectVars     varUse; varUse.bvCreate();

    /* Count the predecessors and successors of each block */

    for (block = insBlockList; block; block = block->igNext)
    {
        assert(block->igPredCnt == 0);
        assert(block->igSuccCnt == 0);
    }

    for (block = insBlockList; block; block = block->igNext)
    {
        insPtr          ins = block->igLast;

        /* Ignore empty blocks */

        if  (!ins)
            continue;

        /* Does the block end with a jump/switch/return? */

        switch (ins->idKind)
        {
        default:
            if  (!block->igNext)
                goto DONE1;

            break;

        case IK_JUMP:

            /* Visit the target of the jump */

            ins->idJump.iDest->igPredCnt++;
            block            ->igSuccCnt++;

            /* That's all there is, if it's an unconditional jump */

            if  (ins->idIns == INS_br)
                continue;

            /* Visit the fall-through block as well */

            break;

        case IK_SWITCH:
            UNIMPL("process switch");
        }

        /* Fall-through is possible, visit the next block */

        assert(block->igNext);

        block->igNext->igPredCnt++;
        block        ->igSuccCnt++;
    }

DONE1:

    /* Allocate the pred and succ tables in each block */

    for (block = insBlockList; block; block = block->igNext)
    {
        block->igPredTmp =
        block->igSuccTmp = 0;

        if  (block->igPredCnt)
             block->igPredTab = (insBlk*)insAllocMem(block->igPredCnt * sizeof(*block->igPredTab));

        if  (block->igSuccCnt)
             block->igSuccTab = (insBlk*)insAllocMem(block->igSuccCnt * sizeof(*block->igSuccTab));
    }

    /* Fill in the pred and succ tables for each block */

    for (block = insBlockList; block; block = block->igNext)
    {
        insBlk          jnext;

        insPtr          ins  = block->igLast;

        /* Ignore empty blocks */

        if  (!ins)
            continue;

        /* Does the block end with a jump/switch/return? */

        switch (ins->idKind)
        {
        default:
            if  (!block->igNext)
                goto DONE2;

            break;

        case IK_JUMP:

            /* Record the target of the jump */

            jnext = ins->idJump.iDest;

            jnext->igPredTab[jnext->igPredTmp++] = block;
            block->igSuccTab[block->igSuccTmp++] = jnext;

            /* That's all if it's an unconditional jump */

            if  (ins->idIns == INS_br)
                continue;

            /* Visit the fall-through block as well */

            break;

        case IK_SWITCH:
            UNIMPL("process switch");
        }

        /* Assume fall-through possible, visit the next block */

        jnext = block->igNext; assert(jnext);

        jnext->igPredTab[jnext->igPredTmp++] = block;
        block->igSuccTab[block->igSuccTmp++] = jnext;
    }

DONE2:

    /* Verify that we didn't mess up */

    for (block = insBlockList; block; block = block->igNext)
    {
        assert(block->igPredCnt == block->igPredTmp);
        assert(block->igSuccCnt == block->igSuccTmp);
    }

    /* Compute local use/def for each block */

    for (block = insBlockList; block; block = block->igNext)
    {
        insPtr          ins;

        /* Create the various other bitsets while we're at this */

        block->igVarLiveIn .bvCreate();
        block->igVarLiveOut.bvCreate();

//      block->igDominates .bvCreate();

        /* Clear the bitsets that hold the current def/use info */

        varDef.bvClear();
        varUse.bvClear();

        /* Walk the block backwards, computing the def/use info */

        for (ins = block->igLast; ins; ins = ins->idPrev)
        {
            assert(ins != insBuildHead);
            assert(ins->idKind == ins2kind(ins->idIns));

            switch (ins->idKind)
            {
                NatUns          depNum;
                insDep  *       depPtr;

            case IK_REG:
            case IK_VAR:
            case IK_NONE:
            case IK_LEAF:
            case IK_MOVIP:
            case IK_CONST:
            case IK_PROLOG:
            case IK_EPILOG:
                break;

            case IK_COMP:
            case IK_UNOP:
            case IK_BINOP:
            case IK_TERNARY:

                /* Process the targets of the operation */

                for (depNum = ins->idDstCnt, depPtr = ins->idDstTab;
                     depNum;
                     depNum--              , depPtr++)
                {
                    assert(depPtr->idepKind < IDK_COUNT);

                    switch (depPtr->idepKind)
                    {
                    case IDK_LCLVAR:
                        varDef.bvSetBit(depPtr->idepNum);
                        varUse.bvClrBit(depPtr->idepNum);
                        break;
                    }
                }

                /* Process the sources of the operation */

                for (depNum = ins->idSrcCnt, depPtr = ins->idSrcTab;
                     depNum;
                     depNum--              , depPtr++)
                {
                    assert(depPtr->idepKind < IDK_COUNT);

                    switch (depPtr->idepKind)
                    {
                    case IDK_LCLVAR:
                        varDef.bvClrBit(depPtr->idepNum);
                        varUse.bvSetBit(depPtr->idepNum);
                        break;

                    case IDK_IND:
                        // UNDONE: may kill all addr-taken locals, etc.
                        break;
                    }
                }

                break;

            case IK_JUMP:
            case IK_IJMP:
            case IK_CALL:
            case IK_SWITCH:
                break;

            default:
                NO_WAY(!"unexpected instruction kind");
            }
        }

#ifdef  DEBUG
        if  (verbose)
        {
            printf("Block #%u:\n", block->igNum);
            printf("    LclDef : "); varDef.bvDisp(); printf("\n");
            printf("    LclUse : "); varUse.bvDisp(); printf("\n");
            printf("\n");
        }
#endif

        /* Copy over the accumulated def/use info */

        block->igVarDef.bvCrFrom(varDef);
        block->igVarUse.bvCrFrom(varUse);
    }

    varDef.bvDestroy();
    varUse.bvDestroy();
}

void                Compiler::genComputeGlobalDF()
{
}

void                Compiler::genComputeLifetimes()
{
    insBlk          block;
    bool            change;

    bitVectVars     liveIn;
    bitVectVars     liveOut;

    /* Iteratively compute liveness info for the flowgraph */

    liveIn .bvCreate();
    liveOut.bvCreate();

#ifdef  DEBUG
    NatUns          iterCnt = 0;
#endif

    do
    {
        change = false;

#ifdef  DEBUG
        iterCnt++; assert(iterCnt < 100);
//      printf("\n\nIteration #%u:\n\n", iterCnt);
#endif

        for (block = insBlockList; block; block = block->igNext)
        {
            NatUns          blkc;
            NatUns          blkx;

            /* Compute liveOut = union(livein of all succ) */

            liveOut.bvClear();

#ifdef  DEBUG

if  (shouldShowLivenessForBlock(block))
{
    static int x;
    if (++x == 0) __asm int 3
    printf("[%u] ", x);
}

#endif

//          if  (block->igNum == 15 && iterCnt == 3) __asm int 3

#ifdef  DEBUG
            if  (shouldShowLivenessForBlock(block))
            {
                printf("\n");
                printf("out[%02u] == ", block->igNum);
                block->igVarLiveOut.bvDisp(); printf("\n");
            }
#endif

            for (blkx = 0, blkc = block->igSuccCnt; blkx < blkc; blkx++)
            {
#ifdef  DEBUG
                if  (shouldShowLivenessForBlock(block))
                {
                    printf(" | [%02u]    ", block->igSuccTab[blkx]->igNum); block->igSuccTab[blkx]->igVarLiveIn.bvDisp(); printf("\n");
                }
#endif
                liveOut.bvIor(block->igSuccTab[blkx]->igVarLiveIn);
            }

#ifdef  DEBUG
            if  (shouldShowLivenessForBlock(block))
            {
                bool            chg;

                printf("    -->    "); liveOut.bvDisp();
                chg = block->igVarLiveOut.bvChange(liveOut);
                printf(" %s\n", chg ? "CHANGE" : "=");

                assert(block->igVarLiveOut.bvChange(liveOut) == false);

                change |= chg;
            }
            else
#endif
            change |= block->igVarLiveOut.bvChange(liveOut);

            /* Compute liveIn = block.use | (liveOut & ~block.def) */

            liveIn.bvUnInCm(block->igVarUse, liveOut, block->igVarDef);

//          printf("[%2u] %08X | (%08X & ~%08X) -> %08X\n", block->igNum, block->igVarUse.inlMap, liveOut.inlMap, block->igVarDef.inlMap, liveIn.inlMap);

#ifdef  DEBUG
            if  (shouldShowLivenessForBlock(block))
            {
                bool            chg;

                printf("in [%02u] == ", block->igNum);
                block->igVarLiveIn .bvDisp(); printf("\n");
                printf("     |     "); block->igVarUse.bvDisp(); printf("\n");
                printf("     &~    "); block->igVarDef.bvDisp(); printf("\n");
                printf("    -->    "); liveIn .bvDisp();

                chg = block->igVarLiveIn.bvChange(liveIn);
                printf(" %s\n", chg ? "CHANGE" : "=");

                assert(block->igVarLiveIn.bvChange(liveIn) == false);

                change |= chg;

                printf("\n");
            }
            else
#endif
            change |= block->igVarLiveIn.bvChange(liveIn);
        }
    }
    while (change);

#ifdef  DEBUG

    if  (verbose)
    {
        for (block = insBlockList; block; block = block->igNext)
        {
            printf("Block #%u:\n", block->igNum);
            printf("    LiveIn  :"); block->igVarLiveIn .bvDisp(); printf("\n");
            printf("    LiveOut :"); block->igVarLiveOut.bvDisp(); printf("\n");
            printf("\n");
        }

        printf("NOTE: Needed %u iterations to compute liveness\n", iterCnt);
    }

#endif

    liveIn .bvDestroy();
    liveOut.bvDestroy();
}

/*****************************************************************************
 *
 *  Interference graph logic follows.
 */

void                bitMatrix::bmxInit(size_t sz, NatUns mc)
{
    size_t          byteSize;
    char    *       temp;

    /* Save the size of the matrix */

    bmxSize   = sz;

    /* Save the max. register count */

    bmxNmax   = mc;
    bmxIsCns  = false;

    /* Compute the size - in bytes - of each row */

    bmxRowSz  = (sz + 7) / 8;

    /* Allocate the matrix and clear it */

    byteSize  = roundUp(sz * bmxRowSz, sizeof(int));

    memset((bmxMatrix = (BYTE    *)insAllocMem(byteSize)), 0, byteSize);

    /* Allocate the row count array and clear it */

    byteSize  = sz * sizeof(*bmxCounts);

    memset((bmxCounts = (unsigned*)insAllocMem(byteSize)), 0, byteSize);
}

void                bitMatrix::bmxClear()
{
    memset(bmxMatrix, 0, bmxSize * bmxRowSz);
}

void                bitMatrix::bmxDone()
{
#ifdef  DEBUG
    bmxSize   = 0;
    bmxMatrix = NULL;
#endif
}

static
unsigned char       bitnum8tomask[8] =
{
    0x01,
    0x02,
    0x04,
    0x08,
    0x10,
    0x20,
    0x40,
    0x80,
};

void                bitMatrix::bmxSetBit(NatUns x, NatUns y)
{
    assert(x > 0 && x <= bmxSize); x--;
    assert(y > 0 && y <= bmxSize); y--;

//  if  (x == 0 && y == 5) BreakIfDebuggerPresent();

    NatUns          offs1 = x * bmxRowSz + y / 8;
    NatUns          mask1 = bitnum8tomask[y & 7];

    /* If the bit is already set, don't do anything */

    if  (!(bmxMatrix[offs1] & mask1))
    {
        NatUns          offs2 = y * bmxRowSz + x / 8;
        NatUns          mask2 = bitnum8tomask[x & 7];

        assert(bmxTstBit(x+1, y+1) == false);

        /* Set the "main" bit */

        bmxMatrix[offs1] |= mask1;

#ifdef  DEBUG
        if  (verbose||DEBUG_LIVENESS) if (x != y) printf("Interference: [%03u,%03u]\n", x, y);
#endif

        /* Is the bit for the other direction already set? */

        if  (!(bmxMatrix[offs2] & mask2))
        {
            /* Brand new interference -- mark the other direction as well */

            assert(x != y && bmxTstBit(y+1, x+1) == false);

            bmxMatrix[offs2] |= mask2;

            /* Bump the neighbor counts */

//          printf("Neighbor count increment: [%2u->%2u],[%2u->%2u]\n", x, bmxCounts[x]+1, y, bmxCounts[y]+1);

            if  (++bmxCounts[x] == bmxNmax) bmxIsCns = true;
            if  (++bmxCounts[y] == bmxNmax) bmxIsCns = true;
        }
    }
}

void                bitMatrix::bmxClrBit(NatUns x, NatUns y)
{
    assert(x > 0 && x <= bmxSize); x--;
    assert(y > 0 && y <= bmxSize); y--;

    bmxMatrix[x * bmxRowSz + y / 8] &= ~bitnum8tomask[y & 7];
}

bool                bitMatrix::bmxTstBit(NatUns x, NatUns y)
{
    assert(x > 0 && x <= bmxSize); x--;
    assert(y > 0 && y <= bmxSize); y--;

    return ((bmxMatrix[x * bmxRowSz + y / 8] & bitnum8tomask[y & 7]) != 0);
}

void                bitMatrix::bmxMarkV4(NatUns x, NatUns m, NatUns b)
{
    if  (m & 1) bmxSetBit(x, b+0);
    if  (m & 2) bmxSetBit(x, b+1);
    if  (m & 4) bmxSetBit(x, b+2);
    if  (m & 8) bmxSetBit(x, b+3);
}

void                bitMatrix::bmxMarkBS(NatUns x, bitVectVars &vset,
                                                   bvInfoBlk   &info)
{
    NatUns  *       src = vset.uintMap; assert(((NatUns)src & 1) == 0);
    size_t          cnt = info.bvInfoInts;
    NatUns          num = 1;

    assert(sizeof(*src) == 4 && "fix this when we make the compiler run on IA64");

    do
    {
        NatUns          val = *src++;

        if  (val)
        {
            bmxMarkV4(x, (unsigned)val, num +  0); val >>= 4;
            bmxMarkV4(x, (unsigned)val, num +  4); val >>= 4;
            bmxMarkV4(x, (unsigned)val, num +  8); val >>= 4;
            bmxMarkV4(x, (unsigned)val, num + 12); val >>= 4;
            bmxMarkV4(x, (unsigned)val, num + 16); val >>= 4;
            bmxMarkV4(x, (unsigned)val, num + 20); val >>= 4;
            bmxMarkV4(x, (unsigned)val, num + 24); val >>= 4;
            bmxMarkV4(x, (unsigned)val, num + 28);

            assert((val >>= 4) == 0);
        }

        num += 32;
    }
    while (--cnt);
}

void                bitMatrix::bmxMarkRegIntf(NatUns num, NatUns reg)
{
    assert(num > 0 && num <= bmxSize); num--;

    BYTE *              addr  = bmxMatrix + num * bmxRowSz;
    NatUns              count = bmxSize;
    Compiler::LclVarDsc*vdsc  = TheCompiler->lvaTable;

    do
    {
        /* Check the next entire byte worth of bits */

        if  (*addr)
        {
            NatUns          byte = *addr;
            NatUns          bits = min(count, 8);

            do
            {
                if  (byte & 1)
                {
#ifdef  DEBUG
                    if  (verbose&&0) printf("Mark intf of reg %u and var %u\n", reg, vdsc - TheCompiler->lvaTable);
#endif

                    bitset128set(&vdsc->lvRegForbidden, reg);
                }

                byte >>= 1;
                vdsc  += 1;
            }
            while (--bits);
        }
        else
        {
            vdsc += 8;
        }

        /* Move on to the next byte */

        addr  += 1;
        count -= 8;
    }
    while ((NatInt)count > 0);
}

NatUns              bitMatrix::bmxChkIntfPrefs(NatUns num, NatUns reg)
{
    BYTE *              addr  = bmxMatrix + num * bmxRowSz;
    NatUns              count = bmxSize;
    Compiler::LclVarDsc*vdsc  = TheCompiler->lvaTable;
    NatUns              maxc  = 0;

    assert(num > 0 && num <= bmxSize);

    do
    {
        /* Check the next entire byte worth of bits */

        if  (*addr)
        {
            NatUns          byte = *addr;
            NatUns          bits = min(count, 8);

            do
            {
                if  (byte & 1)
                {
                    regPrefList     pref;

                    /* This variable interferes, check its preferences */

                    for (pref = vdsc->lvPrefLst; pref; pref = pref->rplNext)
                    {
                        if  (pref->rplRegNum == reg)
                        {
//                          printf("Neighbor #%03u claims benefit of %u\n", vdsc - TheCompiler->lvaTable, pref->rplBenefit);

                            if  (maxc < pref->rplBenefit)
                                 maxc = pref->rplBenefit;
                        }
                    }

                    if  ((regNumber)vdsc->lvPrefReg == (regNumber)reg)
                    {
                        if  (maxc < 1)
                             maxc = 1;
                    }
                }

                byte >>= 1;
                vdsc  += 1;
            }
            while (--bits);
        }
        else
        {
            vdsc += 8;
        }

        /* Move on to the next byte */

        addr  += 1;
        count -= 8;
    }
    while ((NatInt)count > 0);

    return  maxc;
}

/*****************************************************************************
 *
 *  Build the variable lifetime interference graph and compute variable spill
 *  cost estimates.
 */

static
bitMatrix           genIntfGraph;       // UNDONE: move into compiler.h !!!!!

static
bitVectVars         genCallLive;        // UNDONE: move into compiler.h !!!!!

void                Compiler::genAddSpillCost(bitVectVars & needLoad,
                                              NatUns        curWeight)
{
    NatUns          varNum;
    LclVarDsc   *   varDsc;

    // ISSUE: The following is pretty lame

    for (varNum = 1, varDsc = lvaTable;
         varNum <= lvaCount;
         varNum++  , varDsc++)
    {
        if  (needLoad.bvTstBit(varNum))
            varDsc->lvUseCount += (USHORT)curWeight;
    }
}

bool                Compiler::genBuildIntfGraph()
{
    insBlk          block;

    bool            copies = false;

    bitVectVars     curLife;
    bitVectVars     needLoad;

//  CONSIDER: use a separate intf genIntfGraph for int vs. flt variables

    /* Clear the "live across calls" bitvector */

    genCallLive.bvClear();

    /* Create the "current life"     bitvector */

    curLife    .bvCreate();

    /* Create the "need to load"     bitvector */

    needLoad   .bvCreate();

    /* Walk all of the blocks and record interference */

    for (block = insBlockList; block; block = block->igNext)
    {
        NatUns          curWeight = block->igWeight;

        /* Set the current life to the block's outgoing liveness */

        curLife .bvCopy(block->igVarLiveOut);

        /* Clear the "need to load" bitset */

        needLoad.bvClear();

#ifdef  DEBUG
        if  (verbose||DEBUG_LIVENESS) printf("\nComputing interference within block #%u:\n", block->igNum);
#endif

//      unsigned v = 4; printf("Var %u is %s at end of block #%u\n", v, curLife.bvTstBit(v+1) ? "live" : "dead", block->igNum);

        /* Walk all instructions backwards, keeping track of life */

        for (insPtr ins = block->igLast; ins; ins = ins->idPrev)
        {
            assert(ins->idKind == ins2kind(ins->idIns));

//          if  (ins->idNum == 9) __asm int 3

            switch (ins->idKind)
            {
                NatUns          depNum;
                insDep  *       depPtr;

            case IK_BINOP:

                /* Check for variable/physical register copies */

                if  (ins->idIns == INS_mov_reg ||
                     ins->idIns == INS_fmov)
                {
                    insPtr          tmp;

                    regNumber       reg = REG_NA;
                    NatUns          var = 0;

                    /* Is the destination a variable or register? */

                    if  (ins->idRes)
                    {
                        tmp = ins->idRes;

                        switch (tmp->idIns)
                        {
                        case INS_LCLVAR:
                            var = tmp->idLcl.iVar + 1;
                            break;

                        case INS_PHYSREG:
                            reg = (regNumber)tmp->idReg;
                            break;

                        default:
                            goto NOT_COPY;
                        }
                    }
                    else
                    {
                        reg = insOpDest(ins);
                    }

                    /* Is the source a variable or register? */

                    tmp = ins->idOp.iOp2;

                    switch (tmp->idIns)
                    {
                    case INS_LCLVAR:
                        if  (var)
                        {
                            copies = true;
                            // ISSUE: should we mark the block?
                            goto NOT_COPY;
                        }
                        var = tmp->idLcl.iVar + 1;
                        break;

                    case INS_PHYSREG:
                        if  (reg != REG_NA)
                            goto NOT_COPY;
                        reg = (regNumber)tmp->idReg;
                        break;

                    default:

                        if  (!tmp->idTemp || reg)
                            goto NOT_COPY;

                        reg = insOpTmp(tmp);
                        break;
                    }

#if TARG_REG_ASSIGN
                    if  (var && reg != REG_NA)
                    {
                        assert(var > 0 && var <= lvaCount);

                        lvaTable[var - 1].lvPrefReg = (regNumberSmall)reg;
                    }
#endif

                }

            NOT_COPY:

            case IK_COMP:
            case IK_UNOP:
            case IK_TERNARY:

                /* Process the targets of the operation */

                for (depNum = ins->idDstCnt, depPtr = ins->idDstTab;
                     depNum;
                     depNum--              , depPtr++)
                {
                    assert(depPtr->idepKind < IDK_COUNT);

                    switch (depPtr->idepKind)
                    {
                        NatUns          varNum;
                        LclVarDsc   *   varDsc;

                    case IDK_LCLVAR:

                        /* We have a definition of a variable */

                        varNum = depPtr->idepNum; assert(varNum && varNum <= lvaCount);
                        varDsc = lvaTable + varNum - 1;

//                      if  (block->igNum == 9 && varNum == 5) printf("Process intf of var #%u\n", varNum - 1);

                        /* Is the variable needed after this point? */

                        if  (needLoad.bvTstBit(varNum))
                        {
                             needLoad.bvClrBit(varNum);

                            // UNDONE: do the mustSpill thing
                        }

                        /* Is the variable live after this point? */

                        if  (curLife.bvTstBit(varNum))
                        {
                            /* Mark all live variables as interfering */

                            genIntfGraph.bmxMarkVS(varNum, curLife, bvInfoVars);
                        }

                        /* Count the store into the variable */

                        varDsc->lvDefCount += (USHORT)curWeight;

                        /* Mark the variable as dead prior to this point */

                        curLife.bvClrBit(varNum);
                        break;
                    }
                }

                /* Process the sources of the operation - pass 1 */

                for (depNum = ins->idSrcCnt, depPtr = ins->idSrcTab;
                     depNum;
                     depNum--              , depPtr++)
                {
                    assert(depPtr->idepKind < IDK_COUNT);

                    switch (depPtr->idepKind)
                    {
                        NatUns          varNum;

                    case IDK_LCLVAR:

                        varNum = depPtr->idepNum;

                        if  (!curLife.bvTstBit(varNum))
                            genAddSpillCost(needLoad, curWeight);

                        break;
                    }
                }

                /* Process the sources of the operation - pass 2 */

                for (depNum = ins->idSrcCnt, depPtr = ins->idSrcTab;
                     depNum;
                     depNum--              , depPtr++)
                {
                    assert(depPtr->idepKind < IDK_COUNT);

                    switch (depPtr->idepKind)
                    {
                        NatUns          varNum;

                    case IDK_LCLVAR:

                        varNum = depPtr->idepNum;

                        curLife .bvSetBit(varNum);
                        needLoad.bvSetBit(varNum);
                        break;

                    case IDK_IND:
                        // UNDONE: check addr-taken locals, etc.
                        break;
                    }
                }

                break;

            case IK_CALL:

                /* Remember all variables live across calls */

                genCallLive.bvIor(curLife);
                break;

            case IK_REG:
            case IK_VAR:
            case IK_NONE:
            case IK_LEAF:
            case IK_CONST:
            case IK_MOVIP:

            case IK_PROLOG:
            case IK_EPILOG:

            case IK_JUMP:
            case IK_IJMP:
            case IK_SWITCH:
                break;

            default:
                NO_WAY(!"unexpected instruction kind");
            }
        }

        if  (block == insBlockList)
        {
            NatUns          varNum;
            LclVarDsc   *   varDsc;

            /* This is the function entry block, mark all incoming arguments */

            for (varNum = 0, varDsc = lvaTable;
                 varNum < lvaCount;
                 varNum++  , varDsc++)
            {
                if  (varDsc->lvIsParam  == false)
                    break;
                if  (varDsc->lvIsRegArg == false)
                    continue;
                if  (varDsc->lvRefCnt == 0)
                    continue;
                if  (varDsc->lvOnFrame)
                    continue;

                /* Is the argument live on entry? */

                if  (curLife.bvTstBit(varNum+1))
                {
                    /* Mark all live variables as interfering */

//                  printf("Arg %u is live on entry\n", varNum);

                    genIntfGraph.bmxMarkVS(varNum+1, curLife, bvInfoVars);
                }
            }
        }

        genAddSpillCost(needLoad, curWeight);
    }

     curLife.bvDestroy();
    needLoad.bvDestroy();

    /* Were any variables live across calls? */

    if  (!genCallLive.bvIsEmpty())
    {
        bitset128       callerSavedInt  = callerSavedRegsInt;
        bitset128       callerSavedFlt  = callerSavedRegsFlt;

        bitVectVars     callerSavedVars = genCallLive;

        LclVarDsc   *   varDsc;
        NatUns          varNum;

        /*
            Prevent variables live across calls from being assigned
            to caller-saved registers.
         */

        for (varNum = 1, varDsc = lvaTable; varNum <= lvaCount; varNum++, varDsc++)
        {
            if  (callerSavedVars.bvTstBit(varNum))
            {
                if  (varTypeIsFloating(varDsc->TypeGet()))
                    bitset128or(&varDsc->lvRegForbidden, callerSavedFlt);
                else
                    bitset128or(&varDsc->lvRegForbidden, callerSavedInt);

//              printf("Variable %u live across call(s)\n", varNum - 1);
            }
        }
    }

    return  copies;
}

void                Compiler::genVarCoalesce()
{
//  printf("// UNDONE: coalesce variables\n");
}

#if 0

void                Compiler::genSpillAndSplitVars()
{
    unsigned *      counts = genIntfGraph.bmxNeighborCnts();

    UNIMPL("need to spill some variables");
}

#endif

/*****************************************************************************
 *
 *  Compare function passed to qsort() by genColorIntfGraph.
 */

struct  varSpillDsc
{
    Compiler::LclVarDsc*vsdDesc;
    NatUns              vsdCost;
};

int __cdecl         Compiler::genSpillCostCmp(const void *op1, const void *op2)
{
    varSpillDsc *   dsc1 = (varSpillDsc *)op1;
    varSpillDsc *   dsc2 = (varSpillDsc *)op2;

    return  dsc1->vsdCost - dsc2->vsdCost;
}

void                Compiler::genColorIntfGraph()
{
    LclVarDsc   *   varDsc;
    NatUns          varNum;

    varSpillDsc *   varTab;
    varSpillDsc *   varPtr;

    unsigned *      counts;

    bool            spills;

    BYTE        *   lowIntStkReg = nxtIntStkRegAddr;
    BYTE        *   lstIntStkReg = nxtIntStkRegAddr;
    BYTE        *   lowIntScrReg = nxtIntScrRegAddr;
    BYTE        *   lstIntScrReg = nxtIntScrRegAddr;
    BYTE        *   lowFltSavReg = nxtFltSavRegAddr;
    BYTE        *   lstFltSavReg = nxtFltSavRegAddr;
    BYTE        *   lowFltScrReg = nxtFltScrRegAddr;
    BYTE        *   lstFltScrReg = nxtFltScrRegAddr;

    NatUns          minVarReg = 0;

    NatUns          intMaxStk = REG_INT_MAX_STK -  genOutArgRegCnt
                                                + !genOutArgRegCnt;

    assert(lvaCount);

AGAIN:

    /* Construct the interference graph */

    if  (genBuildIntfGraph())
    {
        /* We've noticed variable copies, perform coalescing */

        genVarCoalesce();
    }

    /* Allocate the variable + spill cost table */

    varTab = (varSpillDsc*)insAllocMem(lvaCount * sizeof(*varTab));

    /* Fill in the tables so that the variables can be sorted */

    for (varNum = 0, varDsc = lvaTable, varPtr = varTab;
         varNum < lvaCount;
         varNum++  , varDsc++         , varPtr++)
    {
        varPtr->vsdDesc = NULL;
        varPtr->vsdCost = 0;

        if  (varDsc->lvRefCnt == 0)
            continue;

        if  (varDsc->lvOnFrame)
            continue;

        assert(varDsc->lvVolatile  == false);
        assert(varDsc->lvAddrTaken == false);

        /* If we're here we better have noticed some uses/defs */

        assert(varDsc->lvRefCnt + varDsc->lvDefCount);

#ifdef  DEBUG

        if  (verbose||0)
        {
            printf("Var %02u refcnt = %3u / %3u , def = %3u , use = %3u\n",
                varNum,
                varDsc->lvRefCnt,
                varDsc->lvRefCntWtd,
                varDsc->lvDefCount,
                varDsc->lvUseCount);
        }

#endif

        varPtr->vsdDesc = varDsc;
        varPtr->vsdCost = varDsc->lvDefCount + varDsc->lvUseCount;
    }

    /* Sort the table by spill cost */

    qsort(varTab, lvaCount, sizeof(*varTab), genSpillCostCmp);

    /* Get hold of the neighbor count table */

    counts = genIntfGraph.bmxNeighborCnts();

#ifdef  DEBUG

    if  (verbose||0)
    {
        printf("\n\n");

        for (varNum = 0, varPtr = varTab;
             varNum < lvaCount;
             varNum++  , varPtr++)
        {
            NatUns          varx;

            varDsc = varPtr->vsdDesc;
            if  (!varDsc)
                continue;

            varx = varDsc - lvaTable;

            printf("Var %02u refcnt = %3u / %3u , def = %3u , use = %3u , cost = %3u , neighbors = %u\n",
                varx,
                varDsc->lvRefCnt,
                varDsc->lvRefCntWtd,
                varDsc->lvDefCount,
                varDsc->lvUseCount,
                varPtr->vsdCost,
                counts[varx]);
        }

        printf("\n");
    }

#endif

//  printf("minRsvdIntStkReg = %u\n", minRsvdIntStkReg);
//  printf("maxRsvdIntStkReg = %u\n", maxRsvdIntStkReg);
//  printf("       minVarReg = %u\n",        minVarReg);

    /* Visit variables in order of decreasing spill cost and assign registers */

    spills = false;

    varPtr = varTab + lvaCount;
    do
    {
        bitset128       intf;

        bool            isFP;
        NatUns          vreg;
        NatUns          preg;

        regPrefList     pref;

        NatUns          bestCost;
        NatUns          bestPreg;
        NatUns          bestReg;

        varDsc = (--varPtr)->vsdDesc;
        if  (!varDsc)
            break;

        assert(varTypeIsScalar  (varDsc->TypeGet()) ||
               varTypeIsFloating(varDsc->TypeGet()));

        varNum = (unsigned)(varDsc - lvaTable);

        bitset128mkOr(&intf, varDsc->lvRegInterfere,
                             varDsc->lvRegForbidden);

#ifdef  DEBUG

        if  (verbose||0)
        {
            printf("Var %02u refcnt = %3u / %3u , def = %3u , use = %3u , cost = %3u , degree = %u , intf = %08X\n",
                varNum,
                varDsc->lvRefCnt,
                varDsc->lvRefCntWtd,
                varDsc->lvDefCount,
                varDsc->lvUseCount,
                varPtr->vsdCost,
                counts[varNum],
                (int)intf.longs[0]);
        }

#endif

        if  (varDsc->lvIsRegArg)
            lvaAddPrefReg(varDsc, varDsc->lvArgReg, 1);

        isFP = varTypeIsFloating(varDsc->TypeGet());

        /* Does the variable want to live in a particular register? */

        pref = varDsc->lvPrefLst;

        for (bestCost = 0, bestReg = 0;;)
        {
            NatUns          cost;

            if  (pref)
            {
                cost = pref->rplBenefit;     // cost, benefit - what's the difference?
                vreg = pref->rplRegNum;
                pref = pref->rplNext;
            }
            else
            {
                cost = 1;
                vreg = varDsc->lvPrefReg;
                       varDsc->lvPrefReg = REG_r000;

                if  (vreg == REG_r000)
                    break;
            }

//          printf("pref reg for %s #%2u is %d\n", varDsc->lvIsRegArg ? "arg" : "var", varDsc - lvaTable, vreg);

            /* If the benefit is less than the best so far, forget it */

            if  (cost <= bestCost)
                continue;

            /* Is the variable integer or floating-point ? */

            if  (isFP)
            {
                preg = vreg - REG_f000;
            }
            else
            {
                preg = vreg - REG_r000;

                if  ((NatUns)vreg >= minOutArgIntReg &&
                     (NatUns)vreg >= maxOutArgIntReg)
                {
                    /*
                        Unfortunately, we don't know yet which registers
                        each outgoing argument will land, so we have to
                        ignore this preference.
                     */

                    continue;
                }

                if  ((unsigned)vreg >= minPrSvIntStkReg &&
                     (unsigned)vreg <= maxPrSvIntStkReg ||
                     (unsigned)vreg >=        intMaxStk)
                {
                    /* Not allowed to use this register at all */

                    continue;
                }
            }

            /* Can we use the preferred register? */

            if  (!bitset128test(intf, preg))
            {
                bestReg  = vreg;
                bestPreg = preg;
                bestCost = cost;
            }
        }

        /* Did any of the preferred registers work out ? */

        if  (!bestReg)
        {
            /* No register found yet - simply grab any available one */

            BYTE        *   nxtIntStkReg = lowIntStkReg;
            BYTE        *   nxtIntScrReg = lowIntScrReg;
            BYTE        *   nxtFltSavReg = lowFltSavReg;
            BYTE        *   nxtFltScrReg = lowFltScrReg;

            BYTE        *   bestTptr;

            bestReg  = 0;
            bestCost = UINT_MAX;

            if  (isFP)
            {
                do
                {
                    bestReg = *nxtFltSavReg++;

                    if  (bestReg == REG_NA)
                    {
                        spills = true;
#ifdef  DEBUG
                        if (dspCode) printf("// var #%03u will have to be spilled\n", varNum);
#endif
                        goto NXT_VAR;
                    }

                    bestPreg = bestReg - REG_f000;
                }
                while (bitset128test(intf, bestPreg));

                if  (lstFltSavReg < nxtFltSavReg)
                     lstFltSavReg = nxtFltSavReg;
            }
            else
            {
                for (;;)
                {
                    NatUns      tempPreg;
                    NatUns      tempCost;
                    NatUns      tempReg;

                    /* Grab the next register and see if we can use it */

                    tempReg = *nxtIntStkReg;

                    if  (tempReg == REG_NA)
                    {
                        if  (bestReg)
                            break;

                        spills = true;
#ifdef  DEBUG
                        if (dspCode) printf("// var #%03u will have to be spilled\n", varNum);
#endif
                        goto NXT_VAR;
                    }

                    nxtIntStkReg++;

                    if  ((unsigned)tempReg >= minPrSvIntStkReg &&
                         (unsigned)tempReg <= maxPrSvIntStkReg)
                        continue;

                    if  ((unsigned)tempReg >= intMaxStk)
                        continue;

                    tempPreg = tempReg - REG_r000;

                    if  (bitset128test(intf, tempPreg))
                        continue;

                    /* Looks like a candidate, check its neighbors */

                    tempCost = genIntfGraph.bmxChkIntfPrefs(varNum+1, tempPreg);

                    if  (bestCost > tempCost)
                    {
//                      printf("New low cost of %u\n", tempCost);

                        bestTptr = nxtIntStkReg;
                        bestCost = tempCost;
                        bestReg  = tempReg;

                        if  (!tempCost)
                            break;
                    }
                }

                /* We'll use the best register we've found */

                bestPreg = bestReg - REG_r000;

                /* Remember the highest position we've actually used */

                if  (lstIntStkReg < bestTptr)
                     lstIntStkReg = bestTptr;
            }
        }

        if  (lastIntStkReg <= (unsigned)bestReg && !isFP)
             lastIntStkReg  =           bestReg + 1;

        /* Record the register we've picked for the variable */

        varDsc->lvRegNum   = (regNumberSmall)bestReg;
        varDsc->lvRegister = true;

#ifdef  DEBUG
        if (dspCode) printf("// var #%03u assigned to %s%03u\n", varNum,
                                                                 isFP ? "f" : "r",
                                                                 bestPreg);
#endif

        /* Interfering variables can't live in the same register */

        genIntfGraph.bmxMarkRegIntf(varNum+1, bestPreg);

    NXT_VAR:;

    }
    while (varPtr > varTab);

    if  (spills)
    {
        assert(!"sorry, have to spill some variables and re-color, this is NYI");
        goto AGAIN;
    }

    nxtIntStkRegAddr = lstIntStkReg;
    nxtIntScrRegAddr = lstIntScrReg;
    nxtFltSavRegAddr = lstFltSavReg;
    nxtFltScrRegAddr = lstFltScrReg;
}

/*****************************************************************************
 *
 *  Allocate "real" local variables to registers; this is done immediately
 *  after the temp register allocator has run.
 */

void                Compiler::genAllocVarRegs()
{
    LclVarDsc   *   varDsc;
    NatUns          varNum;

    bool            stackVars = false;

    if  (!lvaCount)
        return;

    /* Prepare to allocate the various bit vectors */

    assert(NatBits == 8 * sizeof(NatUns));

    bvInfoBlks.bvInfoSize =   insBlockCount;
    bvInfoBlks.bvInfoBtSz = ((insBlockCount + NatBits - 1) & ~(NatBits - 1)) / 8;
    bvInfoBlks.bvInfoInts = bvInfoBlks.bvInfoBtSz / (sizeof(NatUns)/sizeof(BYTE));
    bvInfoBlks.bvInfoFree = NULL;
    bvInfoBlks.bvInfoComp = this;

    bvInfoVars.bvInfoSize =   lvaCount;
    bvInfoVars.bvInfoBtSz = ((lvaCount      + NatBits - 1) & ~(NatBits - 1)) / 8;
    bvInfoVars.bvInfoInts = bvInfoVars.bvInfoBtSz / (sizeof(NatUns)/sizeof(BYTE));
    bvInfoVars.bvInfoFree = NULL;
    bvInfoVars.bvInfoComp = this;

//  printf("Basic block count = %u\n", insBlockCount);
//  printf("Variable    count = %u\n", lvaCount);

    /* Compute kill/def/etc dataflow info */

    genComputeLocalDF();
    genComputeGlobalDF();

    /* Compute liveness for all variables */

    genComputeLifetimes();

    /* Create the bitvector used (and reused) while graph building */

    genCallLive.bvCreate();

    /* Allocate and clear the interference graph */

    genIntfGraph.bmxInit(lvaCount, 90);     // HACK!!!!!

#if 0

    for (;;)
    {
        /* Construct the interference graph */

        if  (genBuildIntfGraph())
        {
            /* We've noticed variable copies, perform coalescing */

            genVarCoalesce();
        }

        /* Are there any constrained nodes in the graph? */

        if  (!genIntfGraph.bmxAnyConstrained())
            break;

        /* Spill/split variables that can't be colored */

        genSpillAndSplitVars();

        /* Clear the graph, we'll have to re-create it */

        genIntfGraph.bmxClear();
    }

    /* Figure out the best coloring */

    genColorIntfGraph();

#else

    /* Figure out the best coloring */

    genColorIntfGraph();

#endif

    /* Throw away the graph */

    genIntfGraph.bmxDone();

    /* Throw away the temporary bitvector used for graph building */

    genCallLive.bvDestroy();

#if 0

    BYTE        *   nxtIntStkReg = nxtIntStkRegAddr;
    BYTE        *   nxtIntScrReg = nxtIntScrRegAddr;
    BYTE        *   nxtFltSavReg = nxtFltSavRegAddr;
    BYTE        *   nxtFltScrReg = nxtFltScrRegAddr;

    NatUns          minVarReg = 0;

    NatUns          intMaxStk = REG_INT_MAX_STK -  genOutArgRegCnt
                                                + !genOutArgRegCnt;

    for (varNum = 0, varDsc = lvaTable;
         varNum < lvaCount;
         varNum++  , varDsc++)
    {
        regNumber       varReg;

        // Ignore the incoming register for now ....

        if  (varDsc->lvIsRegArg)
        {
            if  (varTypeIsScalar  (varDsc->TypeGet()) ||
                 varTypeIsFloating(varDsc->TypeGet()))
            {
                if  (varDsc->lvOnFrame)
                {
                    stackVars = true;
                }
                else
                {
                    varDsc->lvRegNum   = varDsc->lvArgReg;
                    varDsc->lvRegister = true;

                    if  (minVarReg < (unsigned)varDsc->lvArgReg)
                         minVarReg = (unsigned)varDsc->lvArgReg;

//                  printf("arg #%02u assigned to integer reg %u\n", varNum, varDsc->lvRegNum);
                }
            }
            else
            {
                printf("// WARNING: need to handle incoming struct arg\n");
            }

            continue;
        }

        if  (varDsc->lvRefCnt == 0)
            continue;

        if  (varDsc->lvOnFrame)
        {
            if  (varTypeIsScalar  (varDsc->TypeGet()) ||
                 varTypeIsFloating(varDsc->TypeGet()))
            {
                stackVars = true;
            }

            continue;
        }

        switch (varDsc->lvType)
        {
        case TYP_BOOL:
        case TYP_BYTE:
        case TYP_UBYTE:
        case TYP_SHORT:
        case TYP_CHAR:
        case TYP_INT:
        case TYP_UINT:
        case TYP_REF:
        case TYP_BYREF:
        case TYP_ARRAY:
        case TYP_FNC:
        case TYP_PTR:
        case TYP_LONG:
        case TYP_ULONG:

            /*
                HACK: simply grab the next register, avoiding any registers
                used in the prolog (or used by incoming register arguments).
             */

            do
            {
                varReg = (regNumber)*nxtIntStkReg;

                if  (varReg == REG_NA)
                {
                    printf("// UNDONE: ran out of stacked int regs for vars, now what?\n");

                    varDsc->lvOnFrame = true;
assert(varDsc->lvRegister == false);
                    stackVars = true;

                    goto DONE_INT;
                }

                nxtIntStkReg++;
            }
            while ((unsigned)varReg >= minRsvdIntStkReg &&
                   (unsigned)varReg <= maxRsvdIntStkReg ||
                   (unsigned)varReg <=        minVarReg ||
                   (unsigned)varReg >=        intMaxStk);

            if  (lastIntStkReg <= (unsigned)varReg)
                 lastIntStkReg  =           varReg + 1;

            varDsc->lvRegNum   = (regNumberSmall)varReg;
            varDsc->lvRegister = true;

#ifdef  DEBUG
            if (dspCode) printf("// var #%03u assigned to r%03u\n", varNum, insIntRegNum(varReg));
#endif

        DONE_INT:
            break;

        case TYP_FLOAT:
        case TYP_DOUBLE:

            /* HACK: simply grab the next register */

            varReg = (regNumber)*nxtFltSavReg++;

            if  (varReg == REG_NA)
            {
                UNIMPL("ran out of stacked flt regs for vars, now what?");
            }

            varDsc->lvRegNum   = (regNumberSmall)varReg;
            varDsc->lvRegister = true;

#ifdef  DEBUG
            if (dspCode) printf("// var #%03u assigned to f%03u\n", varNum, insFltRegNum(varReg));
#endif
            break;

        default:
            UNIMPL("alloc reg for non-int64 var");
        }

        assert(lastIntStkReg <= REG_INT_MAX_STK - genOutArgRegCnt + !genOutArgRegCnt);
    }

    nxtIntStkRegAddr = nxtIntStkReg;
    nxtIntScrRegAddr = nxtIntScrReg;
    nxtFltSavRegAddr = nxtFltSavReg;
    nxtFltScrRegAddr = nxtFltScrReg;

#endif

    /* Did we have any scalars that were not allocated to a register? */

    if  (stackVars)
    {
        printf("// ISSUE: some locals are on the stack, do we need to redo temp-reg alloc?\n");
    }
}

/*****************************************************************************
 *
 *  Generate a conditional jump.
 */

insPtr             Compiler::genCondJump(GenTreePtr cond, BasicBlock * dest)
{
    GenTreePtr      op1  = cond->gtOp.gtOp1;
    GenTreePtr      op2  = cond->gtOp.gtOp2;
    genTreeOps      cmp  = cond->OperGet();

    var_types       type = op1->TypeGet();

    bool            cns  = false;
    bool            uns  = false;

    insPtr          ins1;
    insPtr          ins2;

    insPtr          comp;
    insPtr          jump;

    instruction     icmp;

    NatUns          prrF;
    NatUns          prrT;

    assert(cond->OperIsCompare());

    /* Is this a floating-point compare? */

    if  (varTypeIsFloating(op1->TypeGet()))
    {
        ins2 = genCodeForTreeFlt(op2, true);
        ins1 = genCodeForTreeFlt(op1, true);

        assert(INS_fcmp_eq - INS_fcmp_eq == GT_EQ - GT_EQ);
        assert(INS_fcmp_ne - INS_fcmp_eq == GT_NE - GT_EQ);
        assert(INS_fcmp_lt - INS_fcmp_eq == GT_LT - GT_EQ);
        assert(INS_fcmp_le - INS_fcmp_eq == GT_LE - GT_EQ);
        assert(INS_fcmp_ge - INS_fcmp_eq == GT_GE - GT_EQ);
        assert(INS_fcmp_gt - INS_fcmp_eq == GT_GT - GT_EQ);

        icmp = (instruction)(INS_fcmp_eq + (cmp - GT_EQ));

        goto DO_COMP;
    }

    /* Is this an unsigned integer compare? */

    if  (cond->gtFlags & GTF_UNSIGNED)
        uns = true;

    /* Make sure the more expensive operand is processed first */

    if  (cond->gtFlags & GTF_REVERSE_OPS)
    {
        assert(op1->OperIsConst() == false);
        assert(op2->OperIsConst() == false);

        ins2 = genCodeForTreeInt(op2, true);
        ins1 = genCodeForTreeInt(op1, true);
    }
    else
    {
        assert(op1->OperIsConst() == false);

        ins1 = genCodeForTreeInt(op1, true);

        /* Special case: compare against a small integer constant */

        if  (op2->OperIsConst())
        {
            __int64         ival = genGetIconValue(op2);

            /* Is the constant small enough ? */

            if  (signedIntFitsIn8bit(ival))
            {
                // UNDONE: check for "compare decrement" and adjust small range accordingly!!!!

                if  (ival != -128)  // for now we just avoid -128 as a hack
                {
                    /* We can use "cmp imm8, reg" */

                    ins2 = ins1;
                    ins1 = genAllocInsIcon(op2);
                    cns  = true;
                    goto DONE_OP2;
                }
            }
        }

        ins2 = genCodeForTreeInt(op2, true);
    }

DONE_OP2:

    /* Figure out which compare instruction to use */

    if  (uns && cmp != GT_EQ
             && cmp != GT_NE)
    {
        if  (cns)
        {
            assert(INS_cmp8_imm_lt_u - INS_cmp8_imm_lt_u == GT_LT - GT_LT);
            assert(INS_cmp8_imm_le_u - INS_cmp8_imm_lt_u == GT_LE - GT_LT);
            assert(INS_cmp8_imm_ge_u - INS_cmp8_imm_lt_u == GT_GE - GT_LT);
            assert(INS_cmp8_imm_gt_u - INS_cmp8_imm_lt_u == GT_GT - GT_LT);

             cmp = GenTree::SwapRelop(cmp);
            icmp = (instruction)(INS_cmp8_imm_lt_u + (cmp - GT_LT));
        }
        else
        {
            assert(INS_cmp8_reg_lt_u - INS_cmp8_reg_lt_u == GT_LT - GT_LT);
            assert(INS_cmp8_reg_le_u - INS_cmp8_reg_lt_u == GT_LE - GT_LT);
            assert(INS_cmp8_reg_ge_u - INS_cmp8_reg_lt_u == GT_GE - GT_LT);
            assert(INS_cmp8_reg_gt_u - INS_cmp8_reg_lt_u == GT_GT - GT_LT);

            icmp = (instruction)(INS_cmp8_reg_lt_u + (cmp - GT_LT));
        }
    }
    else
    {
        /*   Signed comparison - constant or register? */

    SGN_CMP:

        if  (cns)
        {
            assert(INS_cmp8_imm_eq - INS_cmp8_imm_eq == GT_EQ - GT_EQ);
            assert(INS_cmp8_imm_ne - INS_cmp8_imm_eq == GT_NE - GT_EQ);
            assert(INS_cmp8_imm_lt - INS_cmp8_imm_eq == GT_LT - GT_EQ);
            assert(INS_cmp8_imm_le - INS_cmp8_imm_eq == GT_LE - GT_EQ);
            assert(INS_cmp8_imm_ge - INS_cmp8_imm_eq == GT_GE - GT_EQ);
            assert(INS_cmp8_imm_gt - INS_cmp8_imm_eq == GT_GT - GT_EQ);

             cmp = GenTree::SwapRelop(cmp);
            icmp = (instruction)(INS_cmp8_imm_eq + (cmp - GT_EQ));
        }
        else
        {
            assert(INS_cmp8_reg_eq - INS_cmp8_reg_eq == GT_EQ - GT_EQ);
            assert(INS_cmp8_reg_ne - INS_cmp8_reg_eq == GT_NE - GT_EQ);
            assert(INS_cmp8_reg_lt - INS_cmp8_reg_eq == GT_LT - GT_EQ);
            assert(INS_cmp8_reg_le - INS_cmp8_reg_eq == GT_LE - GT_EQ);
            assert(INS_cmp8_reg_ge - INS_cmp8_reg_eq == GT_GE - GT_EQ);
            assert(INS_cmp8_reg_gt - INS_cmp8_reg_eq == GT_GT - GT_EQ);

            icmp = (instruction)(INS_cmp8_reg_eq + (cmp - GT_EQ));
        }
    }

    /* Modify the instruction if the size is small */

    if  (genTypeSize(type) < sizeof(__int64))
    {
        assert(INS_cmp8_reg_eq   + 20 == INS_cmp4_reg_eq  );
        assert(INS_cmp8_reg_ne   + 20 == INS_cmp4_reg_ne  );

        assert(INS_cmp8_reg_lt   + 20 == INS_cmp4_reg_lt  );
        assert(INS_cmp8_reg_le   + 20 == INS_cmp4_reg_le  );
        assert(INS_cmp8_reg_ge   + 20 == INS_cmp4_reg_ge  );
        assert(INS_cmp8_reg_gt   + 20 == INS_cmp4_reg_gt  );

        assert(INS_cmp8_imm_eq   + 20 == INS_cmp4_imm_eq  );
        assert(INS_cmp8_imm_ne   + 20 == INS_cmp4_imm_ne  );

        assert(INS_cmp8_imm_lt   + 20 == INS_cmp4_imm_lt  );
        assert(INS_cmp8_imm_le   + 20 == INS_cmp4_imm_le  );
        assert(INS_cmp8_imm_ge   + 20 == INS_cmp4_imm_ge  );
        assert(INS_cmp8_imm_gt   + 20 == INS_cmp4_imm_gt  );

        assert(INS_cmp8_reg_lt_u + 20 == INS_cmp4_reg_lt_u);
        assert(INS_cmp8_reg_le_u + 20 == INS_cmp4_reg_le_u);
        assert(INS_cmp8_reg_ge_u + 20 == INS_cmp4_reg_ge_u);
        assert(INS_cmp8_reg_gt_u + 20 == INS_cmp4_reg_gt_u);

        assert(INS_cmp8_imm_lt_u + 20 == INS_cmp4_imm_lt_u);
        assert(INS_cmp8_imm_le_u + 20 == INS_cmp4_imm_le_u);
        assert(INS_cmp8_imm_ge_u + 20 == INS_cmp4_imm_ge_u);
        assert(INS_cmp8_imm_gt_u + 20 == INS_cmp4_imm_gt_u);

        icmp = (instruction)(icmp + 20);
    }

DO_COMP:

    /* Create the compare instruction */

    comp = insAlloc(icmp, type);

    /* Create the conditional jump instruction */

    jump = insAlloc(INS_br_cond, TYP_VOID);
    insResolveJmpTarget(dest, &jump->idJump.iDest);

    /* Fill in the compare operands and connect the two instructions */

    jump->idJump.iCond  = comp;

    comp->idComp.iCmp1  = ins1;
    comp->idComp.iCmp2  = ins2;
    comp->idComp.iUser  = jump;

    /* Grab a predicate register for the condition */

    prrT = 13;                      // ugly hack
    prrF = 0;                       // ugly hack

    assert(REG_CND_LAST - REG_CND_FIRST <= TRACKED_PRR_CNT);

    comp->idComp.iPredT = (USHORT)prrT;
    comp->idComp.iPredF = (USHORT)prrF;

    jump->idPred        =         prrT;

    /* Record all the dependencies for the 2 instructions */

    assert(prrF == 0);              // ugly hack

    markDepSrcOp(comp, ins1, ins2);
    markDepDstOp(comp, IDK_REG_PRED, prrT);

    markDepSrcOp(jump, IDK_REG_PRED, prrT);
    markDepDstOp(jump);

    insFreeTemp(ins1);
    insFreeTemp(ins2);

    return  jump;
}

/*****************************************************************************
 *
 *  Horrible. 'nuff said ...
 */

extern  DWORD       pinvokeFlags;
extern  LPCSTR      pinvokeName;
extern  LPCSTR      pinvokeDLL;

/*****************************************************************************/

static  regNumber   genFltArgTmp;

/*****************************************************************************
 *
 *  Generate code for a call.
 */

insPtr              Compiler::genCodeForCall(GenTreePtr call, bool keep)
{
    insPtr          callIns;
    insPtr          callRet;
    insPtr          argLast;

    GenTreePtr      argList;
    GenTreePtr      argExpr;

    bool            restoreGP;

    regNumber       argIntReg;
    regNumber       argFltReg;
    size_t          argStkOfs;

    assert(call->gtOper == GT_CALL);

//  gtDispTree(call);

    /* Remember that this we're not a leaf function */

    genMarkNonLeafFunc();

    /* For now we use our own reg-param logic */

    assert(call->gtCall.gtCallRegArgs == NULL);

    /* Get hold of the first output argument register number */

    argIntReg = (regNumber)minOutArgIntReg; assert(argIntReg + genOutArgRegCnt - 1 == maxOutArgIntReg || genOutArgRegCnt == 0);
    argFltReg = (regNumber)minOutArgFltReg;

    argStkOfs = 16;

    for (argList = call->gtCall.gtCallArgs, argLast = NULL;
         argList;
         argList = argList->gtOp.gtOp2)
    {
        insPtr          argIns;
        insPtr          argNext;

        GenTreePtr      argTree = argList->gtOp.gtOp1;
        var_types       argType = argTree->TypeGet();
        size_t          argSize = genTypeSize(argType);

        /* Figure out the size of the argument value */

        if  (argType == TYP_STRUCT)
        {
            if  (argTree->gtOper == GT_MKREFANY)
            {
                argSize = 2 * 8;
            }
            else
            {
                assert(argTree->gtOper == GT_LDOBJ);

                if  (argTree->gtLdObj.gtClass == REFANY_CLASS_HANDLE)
                {
                    argSize = 2 * 8;
                }
                else
                {
                    argSize = eeGetClassSize(argTree->gtLdObj.gtClass);

                    // ISSUE: The following is a pretty gross hack!

                    if  (argSize == 8)
                    {
                        argTree->gtOper = GT_IND;
                        argTree->gtType = argType = TYP_I_IMPL;
                    }
                }
            }
        }

        if  (argSize <= 8 && (NatUns)argIntReg <= (NatUns)maxOutArgIntReg)
        {
            insPtr          regIns;
            insPtr          tmpIns;

            if  (varTypeIsFloating(argType))
            {
                tmpIns            = genCodeForTreeFlt(argTree, true);
                regIns            = insPhysRegRef(argFltReg, argType, true);

//              printf("Arg outgoing in f%u\n", insFltRegNum(argFltReg));

                argIns            = insAlloc(INS_fmov, argType);
                argIns->idRes     = regIns;
                argIns->idOp.iOp1 = NULL;
                argIns->idOp.iOp2 = tmpIns;

                markDepSrcOp(argIns, tmpIns);
                markDepDstOp(argIns, regIns);

                insFreeTemp(tmpIns);

                /* Special case: varargs call */

                if  (call->gtFlags & GTF_CALL_POP_ARGS)
                {
                    insPtr          fmaIns;

                    /* Move the value into a temp register using fma.d.s1 */

                    fmaIns             = insAlloc(INS_fma_d, TYP_DOUBLE);
                    fmaIns->idFlags   |= IF_FMA_S1;

                    fmaIns->idRes      = insPhysRegRef(genFltArgTmp, TYP_DOUBLE,  true);
                    fmaIns->idOp3.iOp1 = insPhysRegRef(argFltReg   , TYP_DOUBLE, false);
                    fmaIns->idOp3.iOp2 = insPhysRegRef(REG_f001    , TYP_DOUBLE, false);
                    fmaIns->idOp3.iOp3 = insPhysRegRef(REG_f000    , TYP_DOUBLE, false);

                    insMarkDepS1D1(fmaIns, IDK_REG_FLT, argFltReg,
                                           IDK_REG_FLT, genFltArgTmp);

                    /* Make a copy in an integer register via "getf" */

                    argIns             = insAlloc(INS_getf_d, TYP_LONG);
                    argIns->idRes      = insPhysRegRef(argIntReg   , TYP_LONG  ,  true);
                    argIns->idOp.iOp1  = insPhysRegRef(argFltReg   , TYP_DOUBLE, false);
                    argIns->idOp.iOp2  = NULL;

                    insMarkDepS1D1(argIns, IDK_REG_FLT, argFltReg,
                                           IDK_REG_INT, argIntReg);

                    /* Next time use a different temp to improve scheduling */

                    genFltArgTmp = (genFltArgTmp == REG_f032) ? REG_f033
                                                              : REG_f032;
                }

                argFltReg = (regNumber)(argFltReg + 1);
            }
            else
            {
//              printf("Arg outgoing in r%u\n", insIntRegNum(argIntReg));

                /* Special case: peep optimization for constants */

                if  (argTree->gtOper == GT_CNS_INT ||
                     argTree->gtOper == GT_CNS_LNG)
                {
                    if  (!(argTree->gtFlags & GTF_ICON_HDL_MASK))
                    {
                        regIns = insPhysRegRef(argIntReg, argType, true);
                        argIns = genAssignIcon(regIns, argTree);

                        goto DONE_REGARG;
                    }
                }

                tmpIns            = genCodeForTreeInt(argTree, true);
                regIns            = insPhysRegRef(argIntReg, argType, true);

                argIns            = insAlloc(INS_mov_reg, argType);
                argIns->idRes     = regIns;
                argIns->idOp.iOp1 = NULL;
                argIns->idOp.iOp2 = tmpIns;

                markDepSrcOp(argIns, tmpIns);
                markDepDstOp(argIns, regIns);

                insFreeTemp(tmpIns);
            }

        DONE_REGARG:

            // strange but true: consume integer register even for floats

            argIntReg = (regNumber)(argIntReg + 1);
        }
        else
        {
            insPtr          regSP;
            insPtr          argVal;
            insPtr          argDst;
            insPtr          argOfs;
            bool            argBig;
            NatUns          argTmp;

            if  (argType == TYP_STRUCT)
            {
                assert(argSize > 8 || (NatUns)argIntReg > (NatUns)maxOutArgIntReg);

//              if  ((NatUns)argIntReg <= (NatUns)maxOutArgIntReg) printf("// NOTE: %u reg(s) available to pass struct\n", maxOutArgIntReg - argIntReg);

                /* Compute the argument address into some register */

                if  (argTree->gtOper == GT_MKREFANY)
                {
                    printf("// UNDONE: create and push REFANY value as argument\n");
                }
                else
                {
                    assert(argTree->gtOper == GT_LDOBJ);

                    argVal = genCodeForTree(argTree->gtLdObj.gtOp1, true);

#if 0   // ISSUE: do we need to do anything special for REFANY argument values?

                    if  (argTree->gtLdObj.gtClass == REFANY_CLASS_HANDLE)
                    {
                        // This is any REFANY.  The top item is non-gc (a class pointer)
                        // the bottom is a byref (the data),

                        gtDispTree(argTree); printf("\n\n");
                    }
                    else
                    {
                    }

#endif

                }

                argBig = true;
            }
            else
            {
                assert(argSize <= 8 && (NatUns)argIntReg > (NatUns)maxOutArgIntReg);

                /* Compute the argument value into some register */

                argVal = genCodeForTree(argTree, true);
                argBig = false;
            }

            /* Add the stack offset to "sp" */

            regSP  = insPhysRegRef(REG_sp, TYP_I_IMPL, false);
            argOfs = genAllocInsIcon(argStkOfs);

            /* Compute the argument's stack address into a temp */

            argDst            = insAlloc(INS_add_reg_i14, TYP_I_IMPL);
            argDst->idOp.iOp1 = regSP;
            argDst->idOp.iOp2 = argOfs;

            if  (!argBig)
            {
                argDst->idFlags |= IF_ASG_TGT;

                insFindTemp (argDst, true);

                markDepDstOp(argDst, argDst);
            }

            markDepSrcOp(argDst, IDK_REG_INT, REG_sp);

            /* Store the argument into the stack */

            if  (argBig)
            {
                genCopyBlock(argVal, argDst, true, NULL, argSize);
            }
            else
            {
                assert(argSize <= sizeof(__int64));

                if  (varTypeIsFloating(argType))
                {
                    argIns        = insAlloc((argType == TYP_DOUBLE) ? INS_stf_d
                                                                     : INS_stf_s, argType);
                }
                else
                    argIns        = insAlloc(INS_st4_ind, TYP_I_IMPL);

                argIns->idOp.iOp1 = argDst;
                argIns->idOp.iOp2 = argVal;

                markDepSrcOp(argIns, argVal);
                markDepDstOp(argIns, argDst, IDK_IND, emitter::scIndDepIndex(argDst));

                insFreeTemp (argDst);
                insFreeTemp (argVal);
            }

            /* Update the current stack argument offset */

            argStkOfs += roundUp(argSize, 8);
        }

        /* Link the argument instructions together */

        assert(argIns);

        argNext              = insAllocNX(INS_ARG, TYP_VOID);

        argNext->idArg.iVal  = argIns;
        argNext->idArg.iPrev = argLast;
                               argLast = argNext;
    }

    restoreGP = false;

    /* Create the appropriate call instruction */

    if  (call->gtCall.gtCallType == CT_INDIRECT || (call->gtFlags & GTF_CALL_UNMANAGED))
    {
        void    *       import;

        insPtr          insAdr;
        insPtr          insImp;
        insPtr          insInd;
        insPtr          insReg;
        insPtr          insFNp;
        insPtr          insGPr;
        insPtr          insMov;

        if  (call->gtCall.gtCallType == CT_INDIRECT)
        {
            insInd = genCodeForTreeInt(call->gtCall.gtCallAddr, true);

            /* ISSUE: is the following really necessary? */

            call->gtCall.gtCallMethHnd = NULL;
        }
        else
        {
            /* Get hold of the pinvoke info for the import */

            TheCompiler->eeGetMethodAttribs(call->gtCall.gtCallMethHnd);

//          printf("NOTE: Unmanaged import call to %s:%s\n", pinvokeDLL, pinvokeName);

            /* Create an import entry for the target */

            import = genPEwriter->WPEimportAdd(pinvokeDLL, pinvokeName);

            /* Compute the address of the IAT entry address */

            insAdr                 = insAllocNX(INS_GLOBVAR, TYP_I_IMPL);
            insAdr->idGlob.iImport = import;
            insAdr->idFlags       |= IF_GLB_IMPORT;

            insReg                 = insPhysRegRef(REG_gp, TYP_I_IMPL, false);

            insImp                 = insAlloc(INS_add_reg_i14, TYP_I_IMPL);
            insImp->idOp.iOp1      = insReg;
            insImp->idOp.iOp2      = insAdr;

            insFindTemp (insImp, true);

            markDepSrcOp(insImp, IDK_REG_INT, REG_gp);
            markDepDstOp(insImp, insImp);

            /* Deref the temp to get the address of the IAT entry */

            insInd                 = insAlloc(INS_ld8_ind, TYP_I_IMPL);
            insInd->idOp.iOp1      = insImp;
            insInd->idOp.iOp2      = NULL;

            insFindTemp(insInd, true);

            markDepSrcOp(insInd, insImp);
            markDepDstOp(insInd, insInd);

            /* Free up the temp that held the address of the IAT address */

            insFreeTemp(insImp);
        }

        /* Fetch the function's address into another temp register */

        insFNp                 = insAlloc(INS_ld8_ind_imm, TYP_I_IMPL);
        insFNp->idOp.iOp1      = insInd;
        insFNp->idOp.iOp2      = genAllocInsIcon(8);

        insFindTemp(insFNp, true);

        markDepSrcOp(insFNp, insInd);
        markDepDstOp(insFNp, insFNp, insInd);

        /* Load the gp register from the next part of the IAT entry */

        insReg                 = insPhysRegRef(REG_gp, TYP_I_IMPL, false);
        insGPr                 = insAlloc(INS_ld8_ind, TYP_I_IMPL);
        insGPr->idRes          = insReg;
        insGPr->idOp.iOp1      = insInd;
        insGPr->idOp.iOp2      = NULL;

        markDepSrcOp(insGPr, insInd);
        markDepDstOp(insGPr, IDK_REG_INT, REG_gp);

        /* Free up the temp that held the IAT address */

        insFreeTemp(insInd);

        /* Move the function address into some branch register */

        insMov                 = insAlloc(INS_mov_brr_reg, TYP_I_IMPL);
        insMov->idRes          = genAllocInsIcon(6);
        insMov->idOp.iOp1      = NULL;
        insMov->idOp.iOp2      = insFNp;

        markDepSrcOp(insMov, insFNp);
        markDepDstOp(insMov, IDK_REG_BR, 6);

        /* Free up the temp that held the function pointer */

        insFreeTemp(insFNp);

//      printf("Unmanaged import call to %s:%s\n", pinvokeDLL, pinvokeName);

        callIns                = insAlloc(INS_br_call_BR, call->gtType);
        callIns->idCall.iBrReg = 6;

        insMarkDepS0D1(callIns, IDK_REG_BR, 6);

        /* Don't forget to restore GP after the call */

        restoreGP = genExtFuncCall = true;
    }
    else
    {
        callIns = insAlloc(INS_br_call_IP, call->gtType);
        insMarkDepS0D1(callIns, IDK_REG_BR, 0);
    }

    callIns->idCall.iArgs    = argLast;
    callIns->idCall.iMethHnd = call->gtCall.gtCallMethHnd;

//  printf("Call to handle %08X\n", call->gtCall.gtCallMethHnd);

    /* Free up any temps held by the arguments */

#if 0

    while (argLast)
    {
        insPtr          argExpr;

        assert(argLast->idIns == INS_ARG);

        argExpr = argLast->idArg.iVal;
        assert(argExpr);

        switch (argExpr->idIns)
        {
        case INS_fmov:
        case INS_mov_reg:
            insFreeTemp(argExpr->idOp.iOp2);
            break;

        case INS_mov_reg_i22:
            break;

        default:
            UNIMPL("unexpected argument instruction");
        }

        argLast = argLast->idArg.iPrev;
    }

#endif

    callRet = callIns;

    /* Do we need to restore GP after the call ? */

    if  (restoreGP)
    {
        insPtr          reg1;
        insPtr          reg2;
        insPtr          rest;

        // ISSUE: The following is redundant if GP is dead after this point!!!

        reg1            = insAllocNX(INS_PHYSREG, TYP_I_IMPL);
        reg1->idReg     = REG_gp;

        reg2            = insAllocNX(INS_PHYSREG, TYP_I_IMPL);
        reg2->idReg     = -1;
        reg2->idFlags  |= IF_REG_GPSAVE;

        rest            = insAlloc(INS_mov_reg, TYP_I_IMPL);
        rest->idRes     = reg1;
        rest->idOp.iOp1 = NULL;
        rest->idOp.iOp2 = reg2;

        markDepSrcOp(rest); // ISSUE: do we need to mark dep on the GP-save reg?
        markDepDstOp(rest, IDK_REG_INT, REG_gp);

        callRet = rest;
    }

    /* Do we need to hang on to the result of the call? */

    if  (keep)
    {
        insPtr          reg;
        insPtr          mov;

        regNumber       rsr;
        instruction     opc;

        var_types       type = call->TypeGet(); assert(type != TYP_VOID);

        /* HACK: hard-wired single integer return register number */

        if  (varTypeIsFloating(call->gtType))
        {
            rsr = REG_f008;
            opc = INS_fmov;
        }
        else
        {
            rsr = REG_r008;
            opc = INS_mov_reg;
        }

        callIns->idRes = reg = insPhysRegRef(rsr, type, true);

        /* Move the result of the call into a temp */

        mov            = insAlloc(opc, type);
        mov->idOp.iOp1 = NULL;
        mov->idOp.iOp2 = callIns;

        insFindTemp(mov, true);

        markDepSrcOp(mov, reg);
        markDepDstOp(mov, mov);

        /* Return the 'mov' instead of the call itself */

        callRet = mov;
    }

    return  callRet;
}

/*****************************************************************************
 *
 *  Map a static data member handle to an offset within the .data section.
 */

typedef
struct  globVarDsc *globVarPtr;
struct  globVarDsc
{
    globVarPtr          gvNext;
    FIELD_HANDLE        gvHndl;
    NatUns              gvOffs;     // offset of            variable in .data
    int                 gvSDPO;     // offset of pointer to variable in .sdata
};

static
globVarPtr          genGlobVarList;

NatUns              getGlobVarAddr(FIELD_HANDLE handle, NatUns *sdataPtr)
{
    globVarPtr      glob;
    size_t          offs;
    BYTE    *       addr;
    var_types       type;

    /* Look for an existing global variable entry */

    for (glob = genGlobVarList; glob; glob = glob->gvNext)
    {
        if  (glob->gvHndl == handle)
            goto GOTIT;
    }

    /* New global variable, create a new entry for it */

    glob         = (globVarPtr)insAllocMem(sizeof(*glob));
    glob->gvHndl = handle;
    glob->gvSDPO = -1;
    glob->gvNext = genGlobVarList;
                   genGlobVarList = glob;

    /* Does the variable have an RVA assigned already? */

    offs = TheCompiler->eeGetFieldAddress(handle);

    if  (offs)
    {
        offs = genPEwriter->WPEsrcDataRef(offs);
    }
    else
    {
        var_types       type = TheCompiler->eeGetFieldType   (handle, NULL);

        /* Reserve space in the data section for the variable */

        printf("type = %u\n", type);

        assert(!"need to get global variable size");

        offs = genPEwriter->WPEsecRsvData(PE_SECT_data, 4, 4, addr);
    }

    glob->gvOffs = offs;

GOTIT:

    /* Did the caller request a pointer within the .sdata section? */

    if  (sdataPtr)
    {
        if  (glob->gvSDPO == -1)
        {
            unsigned __int64    offs = glob->gvOffs;

            /* Add a pointer to the variable to the small data section */

            genPEwriter->WPEsecAddFixup(PE_SECT_sdata,
                                        PE_SECT_data,
                                        genPEwriter->WPEsecNextOffs(PE_SECT_sdata),
                                        true);

            assert(sizeof(offs) == 8);

            glob->gvSDPO = genPEwriter->WPEsecAddData(PE_SECT_sdata, (BYTE*)&offs, sizeof(offs));
        }

        *sdataPtr = glob->gvSDPO;
    }

    return  glob->gvOffs;
}

/*****************************************************************************
 *
 *  Generate a reference to a static data member.
 */

insPtr              Compiler::genStaticDataMem(GenTreePtr tree, insPtr asgVal,
                                                                bool   takeAddr)
{
    insPtr          ins;
    insPtr          glb;
    insPtr          reg;
    insPtr          adr;
    insPtr          ind;

    NatUns          offs;
    NatUns          indx;

    var_types       type = tree->TypeGet();

    size_t          iszi = genInsSizeIncr(genTypeSize(type));

    /* Get hold of the offset of the variable's address in .sdata */

    getGlobVarAddr(tree->gtClsVar.gtClsVarHnd, &offs);

    /* Create a "global variable" node */

    glb               = insAllocNX(INS_GLOBVAR, TYP_I_IMPL);
    glb->idGlob.iOffs = offs;

    insMarkDepS0D0(glb);

    reg               = insPhysRegRef(REG_gp, TYP_I_IMPL, false);

    adr               = insAlloc(INS_add_reg_i14, TYP_I_IMPL);
    adr->idOp.iOp1    = reg;
    adr->idOp.iOp2    = glb;

    insFindTemp(adr, true);

    insMarkDepS1D1(adr, IDK_REG_INT, REG_gp,
                        IDK_TMP_INT, adr->idTemp);

    /* Indirect through the address to get the pointer value */

    ind               = insAlloc(INS_ld8_ind, TYP_I_IMPL);
    ind->idOp.iOp1    = adr;
    ind->idOp.iOp2    = NULL;

    insFindTemp(ind, true);

    insMarkDepS2D1(ind, IDK_TMP_INT, adr->idTemp,
                        IDK_IND    , emitter::scIndDepIndex(ind),
                        IDK_TMP_INT, ind->idTemp);

    insFreeTemp(adr);

    if  (takeAddr)
        return  ind;

    /* Now load or store the actual variable value */

    if  (varTypeIsFloating(type))
    {
        UNIMPL("ld/st flt globvar");
    }
    else
    {
        if  (asgVal)
        {
            /* We're assigning to the global variable */

            ind->idFlags |= IF_ASG_TGT;

            assert(INS_st1_ind + genInsSizeIncr(1) == INS_st1_ind);
            assert(INS_st1_ind + genInsSizeIncr(2) == INS_st2_ind);
            assert(INS_st1_ind + genInsSizeIncr(4) == INS_st4_ind);
            assert(INS_st1_ind + genInsSizeIncr(8) == INS_st8_ind);

            ins = insAlloc((instruction)(INS_st1_ind + iszi), type);
            ins->idOp.iOp1 = ind;
            ins->idOp.iOp2 = asgVal;

            markDepSrcOp(ins, ind);
            markDepDstOp(ins, ind, IDK_IND, emitter::scIndDepIndex(ins));

            insFreeTemp(ind);
            insFreeTemp(asgVal);
        }
        else
        {
            /* We're fetching the global variable */

            assert(INS_ld1_ind + genInsSizeIncr(1) == INS_ld1_ind);
            assert(INS_ld1_ind + genInsSizeIncr(2) == INS_ld2_ind);
            assert(INS_ld1_ind + genInsSizeIncr(4) == INS_ld4_ind);
            assert(INS_ld1_ind + genInsSizeIncr(8) == INS_ld8_ind);

            ins = insAlloc((instruction)(INS_ld1_ind + iszi), type);
            ins->idOp.iOp1 = ind;
            ins->idOp.iOp2 = NULL;

            insFindTemp(ins, true);

            markDepSrcOp(ins, ind, IDK_IND, emitter::scIndDepIndex(ins));
            markDepDstOp(ins, ins);

            insFreeTemp(ind);
        }
    }

    return  ins;
}

/*****************************************************************************
 *
 *  Invent a new temp variable (i.e. it will have more than one use/def) and
 *  appends an assignment of the given value to the temp variable. Special
 *  case -- when "val" is NULL, "typ" should be set to the type of the temp,
 *  and an assignment target reference to the temp var is returned.
 */

insPtr              Compiler::genAssignNewTmpVar(insPtr     val,
                                                 var_types  typ,
                                                 NatUns     refs,
                                                 bool       noAsg, NatUns *varPtr)
{
    NatUns          varNum;
    LclVarDsc   *   varDsc;
    insPtr          varRef;
    insPtr          varAsg;

    assert(val == NULL || typ == val->idTypeGet());

    /* Append a variable entry to the end of the table */

    varNum = *varPtr = lvaGrabTemp();
    varDsc = lvaTable + varNum;

    memset(varDsc, 0, sizeof(*varDsc));

    varDsc->lvRefCnt    = (USHORT)refs;
    varDsc->lvRefCntWtd = refs * compCurBB->bbWeight;
    varDsc->lvType      = typ;

    /* Assign the value to the temp we've just created */

    varRef              = insAllocNX(INS_LCLVAR, typ);
    varRef->idFlags    |= IF_ASG_TGT;

    varRef->idLcl.iVar  = varNum;
#ifdef  DEBUG
    varRef->idLcl.iRef  = compCurBB;   // is this correct?
#endif

    if  (!val)
        return  varRef;

    if  (varTypeIsFloating(typ))
    {
        UNIMPL("store float temp");
    }
    else
    {
        if  (noAsg)
        {
            assert(val->idRes == NULL);

            varAsg            = val;
            varAsg->idRes     = varRef;
        }
        else
        {
            varAsg            = insAlloc(INS_mov_reg, typ);
            varAsg->idRes     = varRef;
            varAsg->idOp.iOp1 = NULL;
            varAsg->idOp.iOp2 = val;

            markDepSrcOp(varAsg, val);
        }

        markDepDstOp(varAsg, varRef);
    }

    insFreeTemp(val);

    return  NULL;
}

insPtr              Compiler::genRefTmpVar(NatUns vnum, var_types type)
{
    insPtr          varRef;

    varRef              = insAllocNX(INS_LCLVAR, type);
    varRef->idLcl.iVar  = vnum;
#ifdef  DEBUG
    varRef->idLcl.iRef  = compCurBB;   // is this correct?
#endif

    return  varRef;
}

/*****************************************************************************
 *
 *  Generate code for a switch statement.
 */

void                Compiler::genCodeForSwitch(GenTreePtr tree)
{
    NatUns          jumpCnt;
    BasicBlock * *  jumpTab;

    GenTreePtr      oper;
    insPtr          swtv;
    var_types       type;

    NatUns          tvar;
    instruction     icmp;
    insPtr          comp;
    insPtr          jump;

    insPtr          ins1;
    insPtr          ins2;

    NatUns          prrF;
    NatUns          prrT;

    insPtr          imov;

    insPtr          temp;
    insPtr          offs;
    insPtr          sadd;
    insPtr          tmpr;
    insPtr          addr;
    insPtr          dest;
    insPtr          mvbr;

    NatUns          data;

    assert(tree->gtOper == GT_SWITCH);
    oper = tree->gtOp.gtOp1;
    assert(oper->gtType <= TYP_LONG);

    /* Get hold of the jump table */

    assert(compCurBB->bbJumpKind == BBJ_SWITCH);

    jumpCnt = compCurBB->bbJumpSwt->bbsCount;
    jumpTab = compCurBB->bbJumpSwt->bbsDstTab;

    /* Compute the switch value into some register */

    type = oper->TypeGet();
    swtv = genCodeForTreeInt(oper, true);

    /* Save the switch value in a multi-use temp */

    genAssignNewTmpVar(swtv, type, 2, false, &tvar);

    /* Jump to "default" if the value is out of range */

    icmp = (genTypeSize(type) < sizeof(__int64)) ? INS_cmp4_imm_lt_u
                                                 : INS_cmp8_imm_lt_u;

    /* Create the compare instruction */

    comp = insAlloc(icmp, type);

    /* Create the conditional jump instruction */

    jump = insAlloc(INS_br_cond, TYP_VOID);
    insResolveJmpTarget(jumpTab[jumpCnt-1], &jump->idJump.iDest);

    /* Fill in the compare operands and connect the two instructions */

    ins1 = genAllocInsIcon(jumpCnt-2);
    ins2 = genRefTmpVar(tvar, type);

    comp->idComp.iCmp1  = ins1;
    comp->idComp.iCmp2  = ins2;
    comp->idComp.iUser  = jump;

    jump->idJump.iCond  = comp;

    /* Grab a predicate register for the condition */

    prrT = 14;                      // ugly hack
    prrF = 0;                       // ugly hack

    assert(REG_CND_LAST - REG_CND_FIRST <= TRACKED_PRR_CNT);

    comp->idComp.iPredT = (USHORT)prrT;
    comp->idComp.iPredF = (USHORT)prrF;

    jump->idPred        =         prrT;

    /* Record all the dependencies for the 2 instructions */

    assert(prrF == 0);              // ugly hack

    markDepSrcOp(comp, ins1, ins2);
    markDepDstOp(comp, IDK_REG_PRED, prrT);

    markDepSrcOp(jump, IDK_REG_PRED, prrT);
    markDepDstOp(jump);

    /* Generate the code to compute the target jump address */

    //
    //  The following is the "paired odd/even jump" approach used
    //  by UTC as of 7/27/00:
    //
    //          rXX := adjusted switch value
    //
    //  $L1:    // labels the bundle with the "mov r3=ip" in it
    //
    //          mov     r3=ip
    //          tbit.z  p6,p0=rXX, 0
    //          adds    r3=($L2-$L1), r3
    //          shladd  r3=rXX, 3, r3
    //          mov     b6=r3
    //          br.cond.sptk.few b6
    //
    //  $L2:    // labels the first paired jump bundle
    //
    //          ...paired jumps follow...
    //

    //  We currently use a simple "offset table" approach instead:
    //
    //          rt0 := adjusted switch value
    //
    //  $L1:    // labels the bundle with the "mov r3=ip" in it
    //
    //          mov     r3=ip
    //          add     rt1=jump_table,gp
    //          shladd  rt2=rt0, 2, rt1         [assume offsets are 32 bits]
    //          ld2     rt3=[rt2]
    //          add     r3=rt3,r3
    //          mov     bx=r3
    //          br.cond.sptk.few bx
    //
    //          .sdata
    //
    //  jump_table:
    //
    //          DD      case1 - $L1
    //          DD      case2 - $L1
    //
    //          ...
    //
    //          DD      caseN - $L1

    //  Alternative with the jump table inline with the code:
    //
    //          rt0 := adjusted switch value
    //
    //  $L1:    // labels the bundle with the "mov r3=ip" in it
    //
    //          mov     rt1=ip
    //          adds    rt2=jump_table - $L1, rt1
    //          shladd  rt3=rt0, 2, rt2         [assume offsets are 32 bits]
    //          ld2     rt4=[rt3]
    //          add     rt5=rt4,rt1
    //          mov     bx=rt5
    //          br.cond.sptk.few bx
    //
    //  jump_table:
    //
    //          DD      case1 - $L1
    //          DD      case2 - $L1
    //
    //          ...
    //
    //          DD      caseN - $L1

    /*
        We'll issue all the case entries later, for now just reserve
        space in the data section for the offset table.
     */

    data = genPEwriter->WPEsecRsvData(PE_SECT_sdata,
                                      4 * (jumpCnt - 1),
                                      4,
                                      compCurBB->bbJumpSwt->bbsTabAddr);

    /* Get hold of the current IP value via "mov r3=ip" */

    imov                = insAlloc(INS_mov_reg_ip, TYP_I_IMPL);
    imov->idFlags      |= IF_NOTE_EMIT;
    imov->idMovIP.iStmt = compCurBB;
    imov->idRes         = insPhysRegRef(REG_r003, TYP_I_IMPL, false);

    insMarkDepS0D1(imov, IDK_REG_INT, REG_r003);

    /* Compute the address of the jump offset table */

    temp                = insAllocNX(INS_GLOBVAR, TYP_I_IMPL);
//  temp->idFlags      |= IF_GLB_SWTTAB;
    temp->idGlob.iOffs  = data; // (NatUns)compCurBB;

    insMarkDepS0D0(temp);

    offs                = insAlloc(INS_add_reg_i14, TYP_I_IMPL);
    offs->idOp.iOp1     = insPhysRegRef(REG_gp, TYP_I_IMPL, false);
    offs->idOp.iOp2     = temp;

    insFindTemp(offs, true);

    insMarkDepS1D1(offs, IDK_REG_INT, REG_gp,
                         IDK_TMP_INT, offs->idTemp);

    /* Add the table address to the (shifted) switch value */

    temp                = genRefTmpVar(tvar, type);

    sadd                = insAlloc(INS_shladd, type);
    sadd->idOp3.iOp1    = temp;
    sadd->idOp3.iOp2    = genAllocInsIcon(2);
    sadd->idOp3.iOp3    = offs;

    insFindTemp (sadd, true);
    insFreeTemp (offs);

    markDepSrcOp(sadd, temp, offs);
    markDepDstOp(sadd, sadd);

    /* Fetch the offset value from the table */

    temp                = insAlloc(INS_ld2_ind, TYP_I_IMPL);
    temp->idOp.iOp1     = sadd;
    temp->idOp.iOp2     = NULL;

    insFindTemp (temp, true);
    insFreeTemp (sadd);

    markDepSrcOp(temp, sadd);
    markDepDstOp(temp, temp);

    /* Add the IP obtained earlier to the offset value */

    dest                = insPhysRegRef(REG_r003, TYP_I_IMPL, false);
    tmpr                = insPhysRegRef(REG_r003, TYP_I_IMPL, false);

    addr                = insAlloc(INS_add_reg_reg, type);
    addr->idRes         = dest;
    addr->idOp.iOp1     = tmpr;
    addr->idOp.iOp2     = temp;

    markDepSrcOp(addr, temp, tmpr);
    markDepDstOp(addr, dest);

    /* Move the address into a branch register and jump to it */

    const   NatUns      breg = 3;

    tmpr                = insPhysRegRef(REG_r003, TYP_I_IMPL, false);
    mvbr                = insAlloc(INS_mov_brr_reg, TYP_I_IMPL);
    mvbr->idRes         = genAllocInsIcon(breg);
    mvbr->idOp.iOp1     = NULL;
    mvbr->idOp.iOp2     = tmpr;

    markDepSrcOp(mvbr, tmpr);
    markDepDstOp(mvbr, IDK_REG_BR, breg);

    insFreeTemp(temp);

    jump                = insAlloc(INS_br_cond_BR, TYP_VOID);
    jump->idIjmp.iBrReg = breg;
//  jump->idIjmp.iStmt  = compCurBB;

    insMarkDepS0D1(jump, IDK_REG_BR, breg);

#ifdef  DEBUG

    compCurBB->bbJumpSwt->bbsIPmOffs = -1;

    do
    {
        BasicBlock *    dest = *jumpTab;

        assert(dest->bbFlags & BBF_JMP_TARGET);
        assert(dest->bbFlags & BBF_HAS_LABEL );
    }
    while (++jumpTab, --jumpCnt);

#endif

}

/*****************************************************************************
 *
 *  Copy a block from the address in 'tmp1' to the address in 'tmp2'.
 */

void            Compiler::genCopyBlock(insPtr tmp1,
                                       insPtr tmp2,
                                       bool  noAsg, GenTreePtr iexp,
                                                    __int64    ival)
{
    NatUns          tvn1;
    NatUns          tvn2;

//  src addr -> r27
//  dst addr -> r26


//  adds    r25=8, r27
//  adds    r29=8, r26

//  ld8     r28=[r27], 16
//  ld8     r25=[r25]
//  st8     [r26]=r28, 16
//  st8     [r29]=r25

//  ld4     r24=[r27]
//  st4     [r26]=r24

    genAssignNewTmpVar(tmp1, tmp1->idTypeGet(), 2, false, &tvn1);
    genAssignNewTmpVar(tmp2, tmp2->idTypeGet(), 2, noAsg, &tvn2);

    /* Are both structures correctly aligned? */

    if  (0)
    {
        UNIMPL("copy aligned struct");
    }
    else
    {
        /* Copy the structure one byte at a time */

        insBlk          loopBlk;

        insPtr          insReg1;
        insPtr          insReg2;
        insPtr          insMove;
        insPtr          insSize;

        instruction     opcMove;

        insPtr          insSrc;
        insPtr          insLd;

        insPtr          insDst;
        insPtr          insSt;

        insPtr          insJmp;

        /* Compute the trip count into "ar.lc" */

        insReg1               = insAllocNX(INS_CNS_INT, TYP_I_IMPL);
        insReg1->idConst.iInt = REG_APP_LC;

        if  (iexp == NULL)
        {
            if  (signedIntFitsIn8bit(ival))
            {
                /* Use the "mov ar=imm" flavor */

                insSize               = genAllocInsIcon(ival);

                insMove               = insAlloc(INS_mov_arr_imm, TYP_I_IMPL);
                insMove->idRes        = insReg1;
                insMove->idOp.iOp1    = NULL;
                insMove->idOp.iOp2    = insSize;

                goto GOT_CNT;
            }

            insSize = genAllocInsIcon(ival);
            opcMove = INS_mov_arr_imm;
        }
        else
        {
            insSize = genCodeForTreeInt(iexp, false);
            opcMove = INS_mov_arr_reg;
        }

        insMove               = insAlloc(opcMove, TYP_I_IMPL);
        insMove->idRes        = insReg1;
        insMove->idOp.iOp1    = NULL;
        insMove->idOp.iOp2    = insSize;

    GOT_CNT:

        insMarkDepS1D1(insMove, IDK_REG_INT, genPrologSrLC,
                                IDK_REG_APP, REG_APP_LC);

        /* Remember that we've used AR.LC */

        genUsesArLc = true;

        /* Start a new block for the loop body */

        loopBlk = insBuildBegBlk(NULL);

        /* Generate the body of the loop */

        insSrc                 = genRefTmpVar(tvn1, TYP_I_IMPL);

        insLd                  = insAlloc(INS_ld1_ind_imm, TYP_I_IMPL);
        insLd ->idOp.iOp1      = insSrc;
        insLd ->idOp.iOp2      = genAllocInsIcon(1);

        insFindTemp (insLd, true);

        markDepSrcOp(insLd, insSrc);
        markDepDstOp(insLd, insLd, insSrc);

        insDst                 = genRefTmpVar(tvn2, TYP_I_IMPL);

        insSt                  = insAlloc(INS_st1_ind_imm, TYP_I_IMPL);
        insSt ->idRes          = insDst;
        insSt ->idOp.iOp1      = insLd;
        insSt ->idOp.iOp2      = genAllocInsIcon(1);

        markDepSrcOp(insSt, insSrc, insDst);
        markDepDstOp(insSt, IDK_IND, 1);

        insFreeTemp (insLd);

        /* Repeat the loop the appropriate number of times */

        insJmp                 = insAlloc(INS_br_cloop, TYP_VOID);
        insJmp->idJump.iDest   = loopBlk;
        insJmp->idFlags       |= IF_BR_FEW; // UNDONE: set "sptk" !!!
#ifdef  DEBUG
        insJmp->idJump.iCond   = NULL;
#endif

        insMarkDepS0D0(insJmp);
    }
}

/*****************************************************************************
 *
 *  Map operand size to sign/zero extend opcode.
 */

static
BYTE                sxtOpcode[] =
{
    INS_sxt1,
    INS_sxt2,
    0,
    INS_sxt4,
};

static
BYTE                zxtOpcode[] =
{
    INS_zxt1,
    INS_zxt2,
    0,
    INS_zxt4,
};

/*****************************************************************************
 *
 *  Return non-zero if the variable lives on the stack frame.
 */

static
bool                genIsVarOnFrame(NatUns varNum)
{
    assert(varNum < TheCompiler->lvaCount);

    return  TheCompiler->lvaTable[varNum].lvOnFrame;
}

static
insPtr              genRefFrameVar(insPtr oldIns, GenTreePtr varExpr, bool isStore,
                                                                      bool bindOfs,
                                                                      bool keepVal)
{
    insPtr          rsp;
    insPtr          adr;
    insPtr          ofs;
    insPtr          ins;

    var_types       type = varExpr->TypeGet();

    NatUns          varNum;

    assert(varExpr->gtOper == GT_LCL_VAR);
    varNum = varExpr->gtLclVar.gtLclNum;
    assert(genIsVarOnFrame(varNum));

    rsp = insPhysRegRef(REG_sp, TYP_I_IMPL, false);

    if  (bindOfs)
    {
        NatUns          varOfs;

        /* Get hold of the variable's frame offset */

        varOfs = TheCompiler->lvaTable[varNum].lvStkOffs;
//      printf("Variable stack offset = %04X\n", varOfs);

        ofs = genAllocInsIcon(varOfs);
    }
    else
    {
        /* Don't know the frame offset yet, save the variable number */

        ofs               = insAllocNX(INS_FRMVAR, type);
        ofs->idFvar.iVnum = varNum;
    }

    insMarkDepS0D0(ofs);

    /* Compute the variable address into a temp */

    adr            = insAlloc(INS_add_reg_i14, TYP_I_IMPL);
    adr->idOp.iOp1 = rsp;
    adr->idOp.iOp2 = ofs;

    insFindTemp (adr, true);

    markDepSrcOp(adr, IDK_REG_INT, REG_sp);
    markDepDstOp(adr, adr);

    if  (isStore)
        return  adr;

    if  (varTypeIsFloating(varExpr->TypeGet()))
    {
        UNIMPL("gen ldf");
    }
    else
    {
        assert(INS_ld1_ind + genInsSizeIncr(1) == INS_ld1_ind);
        assert(INS_ld1_ind + genInsSizeIncr(2) == INS_ld2_ind);
        assert(INS_ld1_ind + genInsSizeIncr(4) == INS_ld4_ind);
        assert(INS_ld1_ind + genInsSizeIncr(8) == INS_ld8_ind);

        ins  = insAlloc((instruction)(INS_ld1_ind + genInsSizeIncr(genTypeSize(type))), type);
        ins->idOp.iOp1 = adr;
        ins->idOp.iOp2 = NULL;
    }

    insFindTemp (ins, keepVal);
    insFreeTemp (adr);

    markDepSrcOp(ins, adr, IDK_LCLVAR, varNum + 1);
    markDepDstOp(ins, ins);

    return  ins;
}

/*****************************************************************************
 *
 *  Generate code for a scalar/void expression (this is a recursive routine).
 */

insPtr              Compiler::genCodeForTreeInt(GenTreePtr tree, bool keep)
{
    var_types       type;
    genTreeOps      oper;
    NatUns          kind;
    insPtr          ins;

#ifdef  DEBUG
    ins = (insPtr)-3;
#endif

AGAIN:

    type = tree->TypeGet();

    // UNDONE: handle structs

    assert(varTypeIsScalar(type) || type == TYP_VOID);

    /* Figure out what kind of a node we have */

    oper = tree->OperGet();
    kind = tree->OperKind();

    /* Is this a constant node? */

    if  (kind & GTK_CONST)
    {
        ins = genAssignIcon(NULL, tree);
        if  (!keep && ins->idTemp)
            insFreeTemp(ins);
        goto DONE;
    }

    /* Is this a leaf node? */

    if  (kind & GTK_LEAF)
    {
        switch (oper)
        {
        case GT_LCL_VAR:

            /* Does the variable live on the stack frame? */

            if  (genIsVarOnFrame(tree->gtLclVar.gtLclNum))
            {
                ins = genRefFrameVar(NULL, tree, false, false, keep);
                break;
            }

            /* We assume that all other locals will be enregistered */

            ins               = insAllocNX(INS_LCLVAR, type);
            ins->idLcl.iVar   = tree->gtLclVar.gtLclNum;
#ifdef  DEBUG
            ins->idLcl.iRef   = compCurBB;   // should we save tree->gtLclVar.gtLclOffs instead ????
#endif
            break;

        case GT_CLS_VAR:
            ins = genStaticDataMem(tree);
            if  (!keep)
                insFreeTemp(ins);
            break;

        case GT_CATCH_ARG:

            /* Catch arguments get passed in the return register */

            ins = insPhysRegRef(REG_INTRET, type, false);
            break;

#ifdef  DEBUG
        default:
            gtDispTree(tree);
            assert(!"unexpected leaf");
#endif
        }

        goto DONE;
    }

//  if  ((int)tree == 0x02bc0bd4) __asm int 3

    /* Is it a 'simple' unary/binary operator? */

    if  (kind & GTK_SMPOP)
    {
        GenTreePtr      op1 = tree->gtOp.gtOp1;
        GenTreePtr      op2 = tree->gtOp.gtOp2;

        insPtr          ins1;
        insPtr          ins2;

#ifdef  DEBUG
        ins1 = (insPtr)-1;
        ins2 = (insPtr)-2;
#endif

        switch (oper)
        {
            NatUns          temp;
            var_types       dstt;

            insPtr          tmp1;
            insPtr          tmp2;

            size_t          size;
            bool            unsv;
            bool            zxtv;

            instruction     iopc;

        case GT_ASG:

            /* Is this a direct or indirect assignment? */

            switch (op1->gtOper)
            {
                insPtr          dest;

            case GT_LCL_VAR:

                /* Does the variable live on the stack frame? */

                if  (genIsVarOnFrame(op1->gtLclVar.gtLclNum))
                {
                    ins1 = genRefFrameVar(NULL, op1, true, false, false);
                    ins2 = genCodeForTreeInt(op2, true);

                    size = genInsSizeIncr(genTypeSize(type));

                    assert(INS_st1_ind + genInsSizeIncr(1) == INS_st1_ind);
                    assert(INS_st1_ind + genInsSizeIncr(2) == INS_st2_ind);
                    assert(INS_st1_ind + genInsSizeIncr(4) == INS_st4_ind);
                    assert(INS_st1_ind + genInsSizeIncr(8) == INS_st8_ind);

                    ins            = insAlloc((instruction)(INS_st1_ind + size), type);
                    ins->idOp.iOp1 = ins1;
                    ins->idOp.iOp2 = ins2;

                    markDepSrcOp(ins, ins1, ins2);
                    markDepDstOp(ins, ins1, IDK_LCLVAR, op1->gtLclVar.gtLclNum);

                    insFreeTemp(ins1);
                    insFreeTemp(ins2);

                    goto DONE;
                }

                /* Are we assigning a simple constant to the local variable? */

                if  (op2->OperIsConst() && (op2->gtOper != GT_CNS_INT ||
                                          !(op2->gtFlags & GTF_ICON_HDL_MASK)))
                {
                    ins1 = genCodeForTreeInt(op1, true);

                    /* Are we dealing with integer/pointer values? */

                    if  (varTypeIsScalar(type))
                    {
                        ins = genAssignIcon(ins1, op2);
                        goto DONE;
                    }
                    else
                    {
                        UNIMPL("assign float const");
                    }
                }
                else if (op2->gtOper == GT_ADD && varTypeIsScalar(type))
                {
                    ins1 = genCodeForTreeInt(op2->gtOp.gtOp1, true);
                    ins2 = genCodeForTreeInt(op2->gtOp.gtOp2, true);

                    dest = genCodeForTreeInt(op1, false);
                    dest->idFlags |= IF_ASG_TGT;

                    ins  = insAlloc(INS_add_reg_reg, type);
                    ins->idRes = dest;

                    markDepSrcOp(ins, ins1, ins2);
                    markDepDstOp(ins, dest);
                }
                else
                {
                    ins1 = NULL;
                    ins2 = genCodeForTreeInt(op2,  true);

                    dest = genCodeForTreeInt(op1, false);
                    dest->idFlags |= IF_ASG_TGT;

                    ins        = insAlloc(INS_mov_reg, type);
                    ins->idRes = dest;

                    markDepSrcOp(ins, ins2);
                    markDepDstOp(ins, dest);
                }

                break;

            case GT_IND:

                ins1 = genCodeForTreeInt(op1->gtOp.gtOp1, true);
                ins2 = genCodeForTreeInt(op2            , true);

                ins1->idFlags |= IF_ASG_TGT;

                assert(INS_st1_ind + genInsSizeIncr(1) == INS_st1_ind);
                assert(INS_st1_ind + genInsSizeIncr(2) == INS_st2_ind);
                assert(INS_st1_ind + genInsSizeIncr(4) == INS_st4_ind);
                assert(INS_st1_ind + genInsSizeIncr(8) == INS_st8_ind);

                temp = INS_st1_ind + genInsSizeIncr(genTypeSize(type));
                ins  = insAlloc((instruction)temp, type);

                markDepSrcOp(ins, ins2);
                markDepDstOp(ins, ins1, IDK_IND, emitter::scIndDepIndex(ins));
                break;

            case GT_CLS_VAR:
                ins = genStaticDataMem(op1, genCodeForTreeInt(op2, true));
                if  (!keep)
                    insFreeTemp(ins);
                goto DONE;

            default:
                UNIMPL("unexpected target of assignment");
            }

            break;

        case GT_IND:

            ins1 = genCodeForTreeInt(op1, true);
            ins2 = NULL;

            assert(INS_ld1_ind + genInsSizeIncr(1) == INS_ld1_ind);
            assert(INS_ld1_ind + genInsSizeIncr(2) == INS_ld2_ind);
            assert(INS_ld1_ind + genInsSizeIncr(4) == INS_ld4_ind);
            assert(INS_ld1_ind + genInsSizeIncr(8) == INS_ld8_ind);

            temp = INS_ld1_ind + genInsSizeIncr(genTypeSize(type));
            ins  = insAlloc((instruction)temp, type);

            insFindTemp (ins, keep);

            markDepSrcOp(ins, ins1, IDK_IND, emitter::scIndDepIndex(ins));
            markDepDstOp(ins, ins);
            break;

        case GT_MUL:

            ins1             = genCodeForTreeInt(op1, true);

            tmp1             = insAlloc(INS_setf_sig, TYP_DOUBLE);
            tmp1->idOp.iOp1  = ins1;
            tmp1->idOp.iOp2  = NULL;

            insFindTemp(tmp1, true);
            insFreeTemp(ins1);

            markDepSrcOp(tmp1, ins1);
            markDepDstOp(tmp1, tmp1);

            ins2             = genCodeForTreeInt(op2, true);

            tmp2             = insAlloc(INS_setf_sig, TYP_DOUBLE);
            tmp2->idOp.iOp1  = ins2;
            tmp2->idOp.iOp2  = NULL;

            insFindTemp(tmp2, true);
            insFreeTemp(ins2);

            markDepSrcOp(tmp2, ins2);
            markDepDstOp(tmp2, tmp2);

            ins2             = insAlloc(INS_xma_l   , TYP_DOUBLE);
            ins2->idOp3.iOp1 = insPhysRegRef(REG_f000, TYP_DOUBLE, false);
            ins2->idOp3.iOp2 = tmp1;
            ins2->idOp3.iOp3 = tmp2;

            insFindTemp(ins2, true);

            insFreeTemp(tmp1);
            insFreeTemp(tmp2);

            markDepSrcOp(ins2, tmp1, tmp2);
            markDepDstOp(ins2, ins2);

            ins              = insAlloc(INS_getf_sig, TYP_LONG);
            ins ->idOp.iOp1  = ins2;
            ins ->idOp.iOp2  = NULL;

            insFindTemp(ins , keep);

            insFreeTemp(ins2);

            markDepSrcOp(ins, ins2);
            markDepDstOp(ins, ins);

            goto DONE;

        case GT_DIV:
        case GT_MOD:
            UNIMPL("DIV/MOD should have been morphed to helper calls");

        case GT_ADD:

            /* Special case: see if we can use "shladd" */

            if  (op1->gtOper == GT_MUL)
            {
                GenTreePtr      mul2;

                /* Is there a multiply by 2/4/8/16 ? */

                mul2 = op1->gtOp.gtOp2;

                if  (mul2->gtOper == GT_CNS_INT ||
                     mul2->gtOper == GT_CNS_LNG)
                {
                    __int64         ival;

                    ival = (mul2->gtOper == GT_CNS_LNG) ? mul2->gtLngCon.gtLconVal
                                                        : mul2->gtIntCon.gtIconVal;

                    switch (ival)
                    {
                    case  2: temp = 1; goto SHLADD;
                    case  4: temp = 2; goto SHLADD;
                    case  8: temp = 3; goto SHLADD;
                    case 16: temp = 4; goto SHLADD;

                    SHLADD:

                        if  (tree->gtFlags & GTF_REVERSE_OPS)
                        {
                            ins2 = genCodeForTreeInt(op2            , true);
                            ins1 = genCodeForTreeInt(op1->gtOp.gtOp1, true);
                        }
                        else
                        {
                            ins1 = genCodeForTreeInt(op1->gtOp.gtOp1, true);
                            ins2 = genCodeForTreeInt(op2            , true);
                        }

                        ins             = insAlloc(INS_shladd, type);
                        ins->idOp3.iOp1 = ins1;
                        ins->idOp3.iOp2 = genAllocInsIcon(temp);
                        ins->idOp3.iOp3 = ins2;

                         insFindTemp(ins, keep);

                        markDepSrcOp(ins, ins1, ins2);
                        markDepDstOp(ins, ins);

                        insFreeTemp(ins1);
                        insFreeTemp(ins2);

                        goto DONE;

                    default:
                        break;
                    }
                }
            }

            if  (op1->gtOper == GT_LSH)
            {
                GenTreePtr      shfc = op1->gtOp.gtOp2;

                if  (shfc->gtOper == GT_CNS_INT ||
                     shfc->gtOper == GT_CNS_LNG)
                {
                    __int64         ival;

                    ival = (shfc->gtOper == GT_CNS_LNG) ? shfc->gtLngCon.gtLconVal
                                                        : shfc->gtIntCon.gtIconVal;


                    if  (ival >= 1 && ival <= 4)
                    {
                        temp = (NatUns)ival;
                        goto SHLADD;
                    }
                }
            }

            /* Process as a generic binary operator */

            iopc = INS_add_reg_reg;

        BIN_OPR:

            ins1 = genCodeForTreeInt(op1, true);

            /* Check for the special case of an immediate constant */

            if  ((op2->gtOper == GT_CNS_INT ||
                  op2->gtOper == GT_CNS_LNG) && ((op2->gtFlags & GTF_ICON_HDL_MASK) != GTF_ICON_PTR_HDL))
            {
                instruction     iimm;
                __int64         ival = genGetIconValue(op2);

                /* Is the constant small enough ? */

                switch (oper)
                {
                case GT_AND: iimm = INS_and_reg_imm; goto CHK_CNS_BINOP;
                case GT_OR:  iimm = INS_ior_reg_imm; goto CHK_CNS_BINOP;
                case GT_XOR: iimm = INS_xor_reg_imm; goto CHK_CNS_BINOP;

                CHK_CNS_BINOP:

                    /* Does the constant fit in 8  bits ? */

                    if  (signed64IntFitsInBits(ival,  8)) // ISSUE: sign of constant?????
                        goto CNS_BINOP;

                    break;

                case GT_LSH: iimm = INS_shl_reg_imm; goto CHK_SHF_BINOP;
                case GT_RSH: iimm = INS_sar_reg_imm; goto CHK_SHF_BINOP;
                case GT_RSZ: iimm = INS_shr_reg_imm; goto CHK_SHF_BINOP;

                CHK_SHF_BINOP:

                    assert(ival && "shifts of 0 bits should be morphed away");

                    /* Is the constant between 1 and 64 ? */

                    if  (ival > 0 && ival <= 64)        // ISSUE: sign of constant?????
                        goto CNS_BINOP;

                    break;

                case GT_SUB:

                    ival = -ival;

                case GT_ADD:

                    /* Does the constant fit in 14 bits ? */

                    if  (signed64IntFitsInBits(ival, 14))
                    {
                        /* We can use "add reg=r0,imm14" */

                        iimm = INS_add_reg_i14;

                    CNS_BINOP:

                        ins2 = genAllocInsIcon(ival, op2->TypeGet());
                        ins  = insAlloc(iimm, type);

                        goto BINOP;
                    }
                    break;

                default:
                    UNIMPL("unexpected operator");
                }
            }

            ins2 = genCodeForTreeInt(op2, true);
            ins  = insAlloc(iopc, type);

        BINOP:

            /*
                ISSUE:  Should we reuse one of the operand temps for the
                        result, or always grab a new temp ? For now, we
                        do the latter (grab a brand spanking new temp).
             */

             insFindTemp(ins, keep);

            markDepSrcOp(ins, ins1, ins2);
            markDepDstOp(ins, ins);
            break;

        case GT_SUB    : iopc = INS_sub_reg_reg; goto BIN_OPR;
        case GT_AND    : iopc = INS_and_reg_reg; goto BIN_OPR;
        case GT_OR     : iopc = INS_ior_reg_reg; goto BIN_OPR;
        case GT_XOR    : iopc = INS_xor_reg_reg; goto BIN_OPR;

        case GT_RSH    : iopc = INS_sar_reg_reg; goto BIN_OPR;
        case GT_RSZ    : iopc = INS_shr_reg_reg; goto BIN_OPR;

        case GT_LSH:

            /* Special case: shift by 1/2/3/4 is better done via shladd */

            if  (op2->gtOper == GT_CNS_INT ||
                 op2->gtOper == GT_CNS_LNG)
            {
                __int64         ival = genGetIconValue(op2);

                if  (ival >= 1 && ival <= 4)
                {
                    ins1 = genCodeForTreeInt(op1, true);
                    ins2 = insPhysRegRef(REG_r000, TYP_I_IMPL, false);

                    ins             = insAlloc(INS_shladd, type);
                    ins->idOp3.iOp1 = ins1;
                    ins->idOp3.iOp2 = genAllocInsIcon(ival);
                    ins->idOp3.iOp3 = ins2;

                     insFindTemp(ins, keep);
                     insFreeTemp(ins1);

                    markDepSrcOp(ins, ins1);
                    markDepDstOp(ins, ins);

                    goto DONE;
                }
            }

            iopc = INS_shl_reg_reg;
            goto BIN_OPR;

        case GT_ASG_ADD: iopc = INS_add_reg_reg; goto ASG_OP1;
        case GT_ASG_SUB: iopc = INS_sub_reg_reg; goto ASG_OP1;

        case GT_ASG_AND: iopc = INS_and_reg_reg; goto ASG_OP1;
        case GT_ASG_OR:  iopc = INS_ior_reg_reg; goto ASG_OP1;
        case GT_ASG_XOR: iopc = INS_xor_reg_reg; goto ASG_OP1;

        case GT_ASG_RSH: iopc = INS_sar_reg_reg; goto ASG_OP1;
        case GT_ASG_RSZ: iopc = INS_shr_reg_reg; goto ASG_OP1;
        case GT_ASG_LSH: iopc = INS_shl_reg_reg; goto ASG_OP1;

        ASG_OP1:

            /* Special case: check for various short-cuts */

            if  (op1->gtOper == GT_LCL_VAR)
            {
                insPtr          idst;

                switch (op2->gtOper)
                {
                    GenTreePtr      mulx;
                    __int64         ival;

                case GT_CNS_INT:
                case GT_CNS_LNG:

                    /* Is the constant small enough ? */

                    ival = genGetIconValue(op2);

                    switch (oper)
                    {
                    case GT_ASG_AND:
                    case GT_ASG_OR:
                    case GT_ASG_XOR:

                        /* Does the constant fit in 8  bits ? */

                        if  (signed64IntFitsInBits(ival,  8))
                        {
                            /* We can use "and/or/xor reg=imm14,reg" */

                            switch (oper)
                            {
                            case GT_ASG_AND: iopc = INS_and_reg_imm; break;
                            case GT_ASG_OR:  iopc = INS_ior_reg_imm; break;
                            case GT_ASG_XOR: iopc = INS_xor_reg_imm; break;

                            case GT_ASG_LSH: iopc = INS_shl_reg_imm; break;
                            case GT_ASG_RSH: iopc = INS_sar_reg_imm; break;
                            case GT_ASG_RSZ: iopc = INS_shr_reg_imm; break;

                            default:
                                NO_WAY("unexpected operator");
                            }

                            ins1 = genCodeForTreeInt(op1, true);
                            ins2 = genAllocInsIcon(op2);
                            ins  = insAlloc(iopc, type);
                            goto DONE_ASGOP;
                        }

                        break;

                    case GT_ASG_SUB:

                        ival = -ival;

                    case GT_ASG_ADD:

                        /* Does the constant fit in 14 bits ? */

                        if  (signed64IntFitsInBits(ival, 14))
                        {
                            /* We can use "add reg=r0,imm14" */

                            ins1 = genCodeForTreeInt(op1, true);
                            ins2 = genAllocInsIcon(op2);
                            ins  = insAlloc(INS_add_reg_i14, type);
                            goto DONE_ASGOP;
                        }
                        break;
                    }

                    /* Fall through, we'll have to materialize the constant */

                default:

                NORM_ASGOP:

                    ins1 = genCodeForTreeInt(op1, true);
                    ins2 = genCodeForTreeInt(op2, true);

                    ins  = insAlloc(iopc, type);
                    break;

                case GT_MUL:

                    if  (oper != GT_ASG_ADD)
                        goto NORM_ASGOP;

                    /* Check for "shladd" */

                    mulx = op2->gtOp.gtOp2;

                    if  (mulx->gtOper != GT_CNS_INT &&
                         mulx->gtOper != GT_CNS_LNG)
                    {
                        goto NORM_ASGOP;
                    }

                    ival = genGetIconValue(mulx);

                    switch (ival)
                    {
                        insPtr          dest;

                    case  2: temp = 1; goto ASG_SHLADD;
                    case  4: temp = 2; goto ASG_SHLADD;
                    case  8: temp = 3; goto ASG_SHLADD;
                    case 16: temp = 4; goto ASG_SHLADD;

                    ASG_SHLADD:

                        dest = genCodeForTreeInt(op1            , true);
                        ins1 = genCodeForTreeInt(op2->gtOp.gtOp1, true);
                        ins2 = genCodeForTreeInt(op1            , true);

                        ins             = insAlloc(INS_shladd, type);
                        ins->idRes      = dest;
                        ins->idOp3.iOp1 = ins1;
                        ins->idOp3.iOp2 = genAllocInsIcon(temp);
                        ins->idOp3.iOp3 = ins2;

                        markDepSrcOp(ins, ins1, ins2);
                        markDepDstOp(ins, dest);

                        insFreeTemp(ins1);
                        insFreeTemp(ins2);

                        goto DONE;
                    }

                    goto NORM_ASGOP;

                case GT_ADD:

                    ins1 = genCodeForTreeInt(op2->gtOp.gtOp1, true);
                    ins2 = genCodeForTreeInt(op2->gtOp.gtOp2, true);
                    ins  = insAlloc(INS_add_reg_reg, type);
                    break;
                }

            DONE_ASGOP:

                ins->idRes = genCodeForTreeInt(op1, false);

                markDepSrcOp(ins, ins1, ins2);
                markDepDstOp(ins, ins->idRes);
                break;
            }

            if  (op1->gtOper == GT_IND)
            {
                size_t          size;

                insPtr          oval;
                insPtr          nval;

                NatUns          tvar;
                var_types       adtp;

                /* The target is an indirection */

                ins1 = genCodeForTreeInt(op1->gtOp.gtOp1, true);

            ASG_IND:

                adtp = ins1->idTypeGet();

                /* Assign the address to a temp variable (we'll use it twice) */

                genAssignNewTmpVar(ins1, adtp, 2, false, &tvar);

                /* Evaluate the new value */

                ins2 = genCodeForTreeInt(op2, true);

                /* Load the old value into a temp register */

                ins1 = genRefTmpVar(tvar, adtp);

                size = genInsSizeIncr(genTypeSize(type));

                assert(INS_ld1_ind + genInsSizeIncr(1) == INS_ld1_ind);
                assert(INS_ld1_ind + genInsSizeIncr(2) == INS_ld2_ind);
                assert(INS_ld1_ind + genInsSizeIncr(4) == INS_ld4_ind);
                assert(INS_ld1_ind + genInsSizeIncr(8) == INS_ld8_ind);

                oval            = insAlloc((instruction)(INS_ld1_ind + size), type);
                oval->idOp.iOp1 = ins1;
                oval->idOp.iOp2 = NULL;

                insFindTemp (oval, true);

                markDepSrcOp(oval, ins1, IDK_IND, emitter::scIndDepIndex(ins1));
                markDepDstOp(oval, oval);

                /* Compute the new value into another temp register */

                nval            = insAlloc(iopc, type);
                nval->idOp.iOp1 = oval;
                nval->idOp.iOp2 = ins2;

                insFindTemp (nval, true);
                insFreeTemp (oval);
                insFreeTemp (ins2);

                markDepSrcOp(nval, oval, ins2);
                markDepDstOp(nval, nval);

                /* Store the new value in the target */

                ins1            = genRefTmpVar(tvar, ins1->idTypeGet());
                ins1->idFlags  |= IF_ASG_TGT;

                assert(INS_st1_ind + genInsSizeIncr(1) == INS_st1_ind);
                assert(INS_st1_ind + genInsSizeIncr(2) == INS_st2_ind);
                assert(INS_st1_ind + genInsSizeIncr(4) == INS_st4_ind);
                assert(INS_st1_ind + genInsSizeIncr(8) == INS_st8_ind);

                ins             = insAlloc((instruction)(INS_st1_ind + size), type);
                ins ->idOp.iOp1 = ins1;
                ins ->idOp.iOp2 = nval;

                markDepSrcOp(ins, nval);
                markDepDstOp(ins, ins1, IDK_IND, emitter::scIndDepIndex(ins));

                insFreeTemp(ins1);

                /* Is the result of the assignment used ? */

                if  (!keep)
                {
                    insFreeTemp(nval);
                    return  ins;
                }

                UNIMPL("need to keep the temp and possibly sign/zero extend it as well");
            }

            if  (op1->gtOper == GT_CLS_VAR)
            {
                ins1 = genStaticDataMem(op1, NULL, true);
                goto ASG_IND;
            }

            UNIMPL("gen code for op=");

        case GT_CAST:

            /* Constant casts should have been folded earlier */

            assert(op1->gtOper != GT_CNS_INT &&
                   op1->gtOper != GT_CNS_LNG &&
                   op1->gtOper != GT_CNS_FLT &&
                   op1->gtOper != GT_CNS_DBL || tree->gtOverflow());

            if  (tree->gtOverflow())
            {
                UNIMPL("cast with overflow check");
            }

            /* The second sub-operand yields the 'real' type */

            assert(op2);
            assert(op2->gtOper == GT_CNS_INT);

            dstt = (var_types)op2->gtIntCon.gtIconVal; assert(dstt != TYP_VOID);

            /* 'zxtv' will be set to true if we need to chop off high bits */

            zxtv = false;

            /* Is the operand an indirection? */

#if 0
            if  (op1->gtOper == GT_IND)
            {
                printf("// CONSIDER: should use ld1/ld2/ld4 for zero-extends\n");
            }
#endif

            /* Compute the operand */

            ins1 = NULL;
            ins2 = genCodeForTreeInt(op1, true);

            /* Is this a narrowing or widening cast? */

            if  (genTypeSize(op1->gtType) < genTypeSize(dstt))
            {
                // Widening cast

                size = genTypeSize(op1->gtType); assert(size == 1 || size == 2 || size == 4);

                unsv = true;

                if  (!varTypeIsUnsigned(op1->TypeGet()))
                {
                    /*
                        Special case: for a cast of byte to char we first
                        have to expand the byte (w/ sign extension), then
                        mask off the high bits -> 'sxt' followed by 'zxt'.
                    */

                    iopc = (instruction)sxtOpcode[size - 1];
                    zxtv = true;
                }
                else
                {
                    iopc = (instruction)zxtOpcode[size - 1];
                }
            }
            else
            {
                // Narrowing cast, or sign-changing cast

                assert(genTypeSize(op1->gtType) >= genTypeSize(dstt));

                size = genTypeSize(dstt); assert(size == 1 || size == 2 || size == 4);

                /* Is the type of the cast unsigned? */

                if  (varTypeIsUnsigned(dstt))
                {
                    unsv = true;
                    iopc = (instruction)zxtOpcode[size - 1];
                }
                else
                {
                    unsv = false;
                    iopc = (instruction)sxtOpcode[size - 1];
                }
            }

            /* Is the cast to a signed or unsigned value? */

            if  (unsv)
            {
                /* We'll copy and then blow the high bits away */

                zxtv = true;
            }

            /* Ready to generate the opcodes */

            ins = insAlloc(iopc, dstt);

            /* Mask off high bits for widening cast */

            if  (zxtv && genTypeSize(dstt) > genTypeSize(op1->gtType)
                      && genTypeSize(dstt) < 8)
            {
                ins->idOp.iOp1 = NULL;
                ins->idOp.iOp2 = ins2;

                insFindTemp (ins, true);

                markDepSrcOp(ins, ins2);
                markDepDstOp(ins, ins );

                insFreeTemp(ins2);

                ins2 = ins;
                ins  = insAlloc((instruction)zxtOpcode[size - 1], dstt);
            }

            insFindTemp (ins, keep);

            markDepSrcOp(ins, ins2);
            markDepDstOp(ins, ins );

            break;

        case GT_RETFILT:

            assert(tree->gtType == TYP_VOID || op1 != 0);

            /* This is "endfilter" or "endfinally" */

            if  (op1 == NULL)
                goto RET_EH;

            // Fall through ...

        case GT_RETURN:

            if  (op1)
            {
                insPtr          rval;
                insPtr          rreg;

                /* This is just a temp hack, of course */

                rval = genCodeForTreeInt(op1, true);
                rreg = insPhysRegRef(REG_r008, type, true);

                ins1            = insAlloc(INS_mov_reg, type);
                ins1->idRes     = rreg;
                ins1->idOp.iOp1 = NULL;
                ins1->idOp.iOp2 = rval;

                markDepSrcOp(ins1, rval);
                markDepDstOp(ins1, IDK_REG_INT, REG_r008);

                if  (!keep)
                    insFreeTemp(rval);

                if  (oper == GT_RETFILT)
                {
                    insPtr          iret;

                RET_EH:

                    assert(keep == false);

                    iret = insAlloc(INS_br_ret, TYP_VOID);

                    insMarkDepS1D0(iret, IDK_REG_BR, 0);

                    goto DONE;
                }
            }
            else
            {
                assert(oper == GT_RETURN);

                /* Things go badly when the epilog has no predecessor */

                ins1            = insAlloc(INS_ignore, TYP_VOID);
                ins1->idFlags  |= IF_NO_CODE;
            }

            ins  = insAlloc(INS_EPILOG, type);

            ins->idEpilog.iBlk  = insBlockLast;
            ins->idEpilog.iNxtX = insExitList;
                                  insExitList = ins;

            goto DONE;

        case GT_NEG:

            ins1 = insPhysRegRef(REG_r000, type, false);
            ins2 = genCodeForTreeInt(op1, true);

            ins  = insAlloc(INS_sub_reg_reg, type);
            goto BINOP;

        case GT_NOT:

            ins1 = genCodeForTreeInt(op1, true);
            ins2 = genAllocInsIcon(-1);

            ins  = insAlloc(INS_xor_reg_imm, type);
            goto BINOP;

        case GT_ADDR:

            if  (op1->gtOper == GT_LCL_VAR)
            {
                /* Create the "address of local" instruction */

                ins2               = insAllocNX(INS_ADDROF, TYP_U_IMPL);
                ins2->idLcl.iVar   = op1->gtLclVar.gtLclNum;
#ifdef  DEBUG
                ins2->idLcl.iRef   = compCurBB;   // should we save tree->gtLclVar.gtLclOffs instead ????
#endif

                /* Make sure the variable has been properly marked */

                assert(op1->gtLclVar.gtLclNum < TheCompiler->lvaCount);
                assert(TheCompiler->lvaTable[op1->gtLclVar.gtLclNum].lvAddrTaken);

                /* Form the address by adding "sp" and the frame offset */

                ins1 = insPhysRegRef(REG_sp, type, false);
                ins  = insAlloc(INS_add_reg_i14, type);

                insFindTemp(ins, keep);

                markDepSrcOp(ins, IDK_REG_INT, REG_sp);
                markDepDstOp(ins, ins);
            }
            else if (op1->gtOper == GT_CLS_VAR)
            {
                assert(keep);
                ins = genStaticDataMem(tree, NULL, true);
                goto DONE;
            }
            else
            {
                UNIMPL("unexpected operand of addrof");
            }
            break;

        case GT_COMMA:
            genCodeForTree(op1, false);
            tree = op2;
            goto AGAIN;

        case GT_NOP:
            tree = op1;
            if  (!tree)
            {
                assert(keep == false);
                return  NULL;
            }
            goto AGAIN;

        case GT_SWITCH:
            assert(keep == false);
            genCodeForSwitch(tree);
            return  NULL;

        case GT_COPYBLK:
            {
            GenTreePtr      iexp;
            __int64         ival;

            assert(op1->OperGet() == GT_LIST);

            tmp1 = genCodeForTreeInt(op1->gtOp.gtOp1, true);
            tmp2 = genCodeForTreeInt(op1->gtOp.gtOp2, true);

            /* Is the size a compile-time constant? */

            iexp = op2;

            if  (iexp->gtOper == GT_CNS_LNG ||
                 iexp->gtOper == GT_CNS_INT)
            {
                __int64         ival;

                if  ((iexp->gtFlags & GTF_ICON_HDL_MASK) == GTF_ICON_CLASS_HDL)
                {
                    CLASS_HANDLE    clsHnd = (CLASS_HANDLE)iexp->gtIntCon.gtIconVal;

                    ival = eeGetClassSize(clsHnd); assert(ival % 4 == 0);

                    printf("// ISSUE: need to check for embedded GC refs\n");
                }
                else
                {
                    ival = genGetIconValue(iexp);
                }

                iexp = NULL;
            }

            genCopyBlock(tmp1, tmp2, false, iexp, ival);
            }

            return  NULL;

#ifdef  DEBUG
        default:
            gtDispTree(tree);
            assert(!"unexpected unary/binary operator");
#endif
        }

        ins->idOp.iOp1 = ins1; if (ins1) insFreeTemp(ins1);
        ins->idOp.iOp2 = ins2; if (ins2) insFreeTemp(ins2);

        goto DONE;
    }

    /* See what kind of a special operator we have here */

    switch  (oper)
    {
    case GT_CALL:
        ins = genCodeForCall(tree, keep);
        goto DONE_NODSP;

    default:
#ifdef  DEBUG
        gtDispTree(tree);
#endif
        assert(!"unexpected operator");
    }

DONE:

#ifdef  DEBUG
    if  (verbose||0) insDisp(ins);
#endif

DONE_NODSP:

#if USE_OLD_LIFETIMES

    /* See if life has changed -- should only happen at variable nodes */

//  printf("%08X ", (int)tree->gtLiveSet); gtDispTree(tree, 0, true);

    if  (oper == GT_LCL_VAR)
    {
        if  (genCodeCurLife != tree->gtLiveSet)
        {
            VARSET_TP       change = genCodeCurLife ^ tree->gtLiveSet;

            if  (change)
            {
                NatUns          varNum;
                LclVarDsc   *   varDsc;
                VARSET_TP       varBit;

//              printf("Life changes: %08X -> %08X [diff = %08X]\n", (int)genCodeCurLife, (int)tree->gtLiveSet, (int)change);

                /* Only one variable can die or be born at one time */

                assert(genOneBitOnly(change));

                /* In fact, the variable affected should be the one referenced */

                assert(tree->gtLclVar.gtLclNum < lvaCount);
                assert(change == genVarIndexToBit(lvaTable[tree->gtLclVar.gtLclNum].lvVarIndex));

                /* Is this a birth or death of the given variable? */

                ins->idFlags |= (genCodeCurLife & change) ? IF_VAR_DEATH
                                                          : IF_VAR_BIRTH;
            }

            genCodeCurLife = tree->gtLiveSet;
        }
    }
    else
    {
        assert(genCodeCurLife == tree->gtLiveSet);
    }

#endif

    return  ins;
}

/*****************************************************************************
 *
 *  Generate code for the current function (from its tree-based flowgraph).
 */

void                Compiler::genGenerateCode(void * * codePtr,
                                              void * * consPtr,
                                              void * * dataPtr,
                                              void * * infoPtr,
                                              SIZE_T * nativeSizeOfCode)
{
    NatUns          reg;
    NatUns          bit;

    BasicBlock *    block;

    insPtr          insLast;
    insPtr          insNext;

    bool            hadSwitch    = false;

    bool            moveArgs2frm = false;

    NatUns          funcCodeOffs;

    insPtr          insFncProlog;

    NatUns          intArgRegCnt;
    NatUns          fltArgRegCnt;

    genIntRegMaskTP genAllIntRegs;
    genFltRegMaskTP genAllFltRegs;
    genSpcRegMaskTP genAllSpcRegs;

#ifdef  DEBUGGING_SUPPORT
    IL_OFFSET       lastILofs = BAD_IL_OFFSET;
#endif

    /* Make sure our reach doesn't exceed our grasp */

//  printf("Total tracked register count = %u (max=%u)\n", REG_COUNT, TRACKED_REG_CNT);
    assert(REG_COUNT <= TRACKED_REG_CNT);

    /* UNDONE: The following should be done elsewhere! */

    genMarkBBlabels();

    /* Prepare to generate instructions */

    insBuildInit();

    /* Prepare to record line# info, if necessary */

    if  (debugInfo)
        genSrcLineInit(info.compLineNumCount * 2); // the *2 is a horrid hack!!!!

    /* Assume everything is dead on arrival */

#if USE_OLD_LIFETIMES
    genCodeCurLife  = 0;
#endif

    /* We don't have any prolog instructions yet */

    genPrologInsCnt = 0;

    /* We haven't seen any calls to external functions yet */

    genExtFuncCall  = false;

    /* In debug mode we keep track of how many bundle slots we waste */

#ifdef  DEBUG
    genInsCnt       = 0;
    genNopCnt       = 0;
#endif

    /* Figure out how many registers are used by incoming arguments */

    intArgRegCnt    = 0;
    fltArgRegCnt    = 0;

    genMaxIntArgReg = 0;
    genMaxFltArgReg = 0;

#ifdef  DEBUG
    minOutArgIntReg = REG_r001;
    maxOutArgIntReg = REG_r000;
#endif

    genUsesArLc     = false;

    /*
        ISSUE: the following is a pretty horrible hack, the max. should be
        computed in lclvars.cpp and cached.
     */

    LclVarDsc   *   varDsc;
    NatUns          varNum;

    for (varNum = 0, varDsc = lvaTable;
         varNum < lvaCount;
         varNum++  , varDsc++)
    {
        if  (varDsc->lvIsRegArg)
        {
            if  (varTypeIsFloating(varDsc->TypeGet()))
            {
                fltArgRegCnt++;

                if  (genMaxFltArgReg < (unsigned)varDsc->lvArgReg)
                     genMaxFltArgReg = (unsigned)varDsc->lvArgReg;
            }
            else
            {
                if  (genMaxIntArgReg < (unsigned)varDsc->lvArgReg)
                     genMaxIntArgReg = (unsigned)varDsc->lvArgReg;
            }

            intArgRegCnt++;
        }

        if  (varDsc->lvVolatile || varDsc->lvAddrTaken)
        {
            varDsc->lvOnFrame = true;
assert(varDsc->lvRegister == false);
        }
    }

    if  (intArgRegCnt)
        genMaxIntArgReg = REG_INT_ARG_0 + intArgRegCnt - 1;

#ifdef  DEBUG
    if  (dspCode) printf("// Highest incoming argument reg: int=%u , flt=%u\n", genMaxIntArgReg, genMaxFltArgReg);
#endif

    /* Are we supposed to do "smart" temp register alloc ? */

    genTmpAlloc = ((opts.compFlags & CLFLG_TEMP_ALLOC) != 0);

    /* Figure out the "output" register range */

    minOutArgIntReg = REG_INT_LAST + 1;
    maxOutArgIntReg = 0;
    minOutArgFltReg = REG_FLT_LAST + 1;
    maxOutArgFltReg = 0;

    if  (genOutArgRegCnt)
    {
        /*
            The "true" integer output argument numbers won't be known until
            we've generated all the code and know how many stacked registers
            we'll need for temps and such. So we use the register numbers at
            the very end of the register file for now and we'll renumber all
            of them later.
         */

        maxOutArgIntReg = REG_INT_LAST;
        minOutArgIntReg = REG_INT_LAST - genOutArgRegCnt + 1;

        minOutArgFltReg = REG_FLT_ARG_0;
        maxOutArgFltReg = MAX_FLT_ARG_REG;
    }

    maxOutArgStk = 0;       // UNDONE: this needs to be pre-computed, right ?????

    /* Construct the sets of available temp registers */

    bitset128clear(&genAllIntRegs);
    bitset128clear(&genAllFltRegs);
                    genAllSpcRegs = 0;

    for (reg = REG_INT_FIRST; reg < REG_INT_LAST; reg++)
        bitset128set(&genAllIntRegs, reg - REG_INT_FIRST);
    for (reg = REG_FLT_FIRST; reg < REG_FLT_LAST; reg++)
        bitset128set(&genAllFltRegs, reg - REG_FLT_FIRST);

    for (reg = REG_INT_FIRST, bit = 1; reg < REG_INT_LAST; reg++, bit <<= 1)
        genAllSpcRegs |= bit;

    /* Round-robin allocate float argument temp regs */

    genFltArgTmp   = REG_f032;      // HORRIBLE HACK!!!!!!!!!!!!!!!!

    /* Initialize the register bitmaps */

    genFreeIntRegs = genAllIntRegs;
    genFreeFltRegs = genAllFltRegs;
    genFreeSpcRegs = genAllSpcRegs;

    /* No temps have been found to be live across calls */

    bitset128clear(&genCallIntRegs);
    bitset128clear(&genCallFltRegs);
                    genCallSpcRegs = 0;

    /* Instruction display depends on these always being set */

#ifdef  DEBUG
    genTmpFltRegMap  = NULL;
    genTmpIntRegMap  = NULL;
#endif

    /* The function is considered a "leaf" until proven otherwise */

    genNonLeafFunc = false;

    /* We'll create a linked list of exit points */

    insExitList    = NULL;

    /* Create the placeholder for the function prolog */

    insFncProlog   = insAlloc(INS_PROLOG, TYP_VOID);

    /* Walk the basic block list and generate instructions for each of them */

    for (block = fgFirstBB; block; block = block->bbNext)
    {
        VARSET_TP       life = block->bbLiveIn;
        BBjumpKinds     jump;
        GenTreePtr      tree;

#ifdef  DEBUG
        if (verbose) printf("Block #%2u [%08X] jumpKind = %u in '%s':\n", block->bbNum, block, block->bbJumpKind, TheCompiler->info.compFullName);
#endif

//      if  (block->bbNum == 14) BreakIfDebuggerPresent();

        /* Tell everyone which basic block we're working on */

        compCurBB = block;

        /* Note what the block ends with */

        jump = (BBjumpKinds)block->bbJumpKind;

//      if  ((int)block == 0x02c32658) __asm int 3

        /* Does any other block jump to this point ? */

        if  (block->bbFlags & BBF_JMP_TARGET)
        {
            /* Start a new block (unless this is the very start) */

            if  (block != fgFirstBB)
                insBuildBegBlk(block);

            /* Update the current life value */

#if USE_OLD_LIFETIMES
//          insBlockLast->igLiveIn =
            genCodeCurLife         = life;
#endif

            /* Record the mapping between the blocks */

            block->bbInsBlk = insBlockLast;
        }
#if USE_OLD_LIFETIMES
        else
        {
            assert(genCodeCurLife == life);
        }
#endif

        /* Generate code for each statement in the current block */

        for (tree = block->bbTreeList; tree; tree = tree->gtNext)
        {
            GenTreePtr      expr;

            assert(tree->gtOper == GT_STMT);

            /* Make sure all temp registers are free at statement boundaries */

#ifdef  DEBUG

            if  (!bitset128equal(genFreeIntRegs, genAllIntRegs))
            {
                for (NatUns it = 0; it < 128; it++)
                {
                    if  (bitset128test(genFreeIntRegs, it) !=
                         bitset128test( genAllIntRegs, it))
                    {
                        printf("FATAL: int temp #%u was not freed up!\n", it);
                    }
                }
            }

            if  (!bitset128equal(genFreeFltRegs, genAllFltRegs))
            {
                for (NatUns it = 0; it < 128; it++)
                {
                    if  (bitset128test(genFreeFltRegs, it) !=
                         bitset128test( genAllFltRegs, it))
                    {
                        printf("FATAL: flt temp #%u was not freed up!\n", it);
                    }
                }
            }

#endif

            assert(bitset128equal(genFreeIntRegs, genAllIntRegs));
            assert(bitset128equal(genFreeFltRegs, genAllFltRegs));

            assert(genFreeSpcRegs == genAllSpcRegs);

            /* Get hold of the statement tree */

            expr = tree->gtStmt.gtStmtExpr;

#ifdef  DEBUG
            if  (verbose) { printf("\nBB stmt:\n"); gtDispTree(expr); printf("\n"); }
#endif

#ifdef  DEBUGGING_SUPPORT

            /* Do we have a new IL-offset ? */

            assert(tree->gtStmtILoffs <= TheCompiler->info.compCodeSize ||
                   tree->gtStmtILoffs == BAD_IL_OFFSET);

            if  (tree->gtStmtILoffs != BAD_IL_OFFSET &&
                 tree->gtStmtILoffs != lastILofs)
            {
                lastILofs = tree->gtStmtILoffs;

                if  (debugInfo)
                {
                    insPtr          ins;

                    ins                = insAlloc(INS_SRCLINE, TYP_VOID);
                    ins->idFlags      |= IF_NO_CODE;
                    ins->idSrcln.iLine = TheCompiler->compLineNumForILoffs(lastILofs);

//                  printf("IL offs %04X -> line %u\n", lastILofs, ins->idSrcln.iLine);
                }
            }

#endif

            /* Is this the condition of a jump? */

            if  (jump == BBJ_COND && tree->gtNext == NULL)
                break;

            /* Generate code for the expression */

            genCodeForTree(expr, false);
        }

//      static int x; if (++x == 0) __asm int 3

        /* Do we need to generate anything (like a jump) after the block? */

        switch (jump)
        {
            insPtr          ins;

        case BBJ_NONE:
            break;

        case BBJ_COND:
            assert(tree);
            assert(tree->gtOper == GT_STMT ); tree = tree->gtStmt.gtStmtExpr;
            assert(tree->gtOper == GT_JTRUE); tree = tree->gtOp.gtOp1;
            ins = genCondJump(tree, block->bbJumpDest);
            assert(block->bbNext);
#if USE_OLD_LIFETIMES
            genCodeCurLife = block->bbNext->bbLiveIn;
            ins->idJump.iLife = genCodeCurLife;
#endif

            /* Kind of a hack: start a new block unless next block has a label */

            assert(block->bbNext);
            if  (!(block->bbNext->bbFlags & BBF_JMP_TARGET))
                insBuildBegBlk();

//          printf("Life at end of block (after jcc) is %08X\n", (int)genCodeCurLife);
            break;

        case BBJ_ALWAYS:

            ins = insAlloc(INS_br, TYP_VOID);
            ins->idJump.iCond = NULL;
            insMarkDepS0D0(ins);

            assert(block->bbNext == 0 || (block->bbNext->bbFlags & BBF_JMP_TARGET));

//          if  ((int)block == 0x02c23a08) __asm int 3

            insResolveJmpTarget(block->bbJumpDest, &ins->idJump.iDest);

#if USE_OLD_LIFETIMES

            if  (block->bbNext)
                genCodeCurLife = block->bbNext->bbLiveIn;
            else
                genCodeCurLife = 0;

            ins->idJump.iLife = genCodeCurLife;

//          printf("Life at end of block (after jmp) is %08X\n", (int)genCodeCurLife);

#endif
            break;

        case BBJ_RETURN:
            assert(block->bbNext == 0 || (block->bbNext->bbFlags & BBF_JMP_TARGET));

            /* Check for the special case of a compiler-added return block */

            if  (!block->bbTreeList)
            {
                insPtr          fake;
                insPtr          iret;

                assert(block == genReturnBB);
                assert(block->bbNext == NULL);
                assert(block->bbFlags & BBF_INTERNAL);

                fake                 = insAlloc(INS_ignore, TYP_VOID);
                fake->idFlags       |= IF_NO_CODE;

                iret                 = insAlloc(INS_EPILOG, TYP_VOID);

                iret->idEpilog.iBlk  = insBlockLast;
                iret->idEpilog.iNxtX = insExitList;
                                       insExitList = iret;
            }
            break;

        case BBJ_RET:
            break;

        case BBJ_SWITCH:
            hadSwitch = true;
            break;

        default:
            UNIMPL("unexpected jump kind");
        }

        /* Make sure all temp registers are free at statement boundaries */

#ifdef  DEBUG

        if  (!bitset128equal(genFreeIntRegs, genAllIntRegs))
        {
            for (NatUns it = 0; it < 128; it++)
            {
                if  (bitset128test(genFreeIntRegs, it) !=
                     bitset128test( genAllIntRegs, it))
                {
                    printf("FATAL: int temp #%u was not freed up!\n", it);
                }
            }
        }

        if  (!bitset128equal(genFreeFltRegs, genAllFltRegs))
        {
            for (NatUns it = 0; it < 128; it++)
            {
                if  (bitset128test(genFreeFltRegs, it) !=
                     bitset128test( genAllFltRegs, it))
                {
                    printf("FATAL: flt temp #%u was not freed up!\n", it);
                }
            }
        }

        assert(bitset128equal(genFreeIntRegs, genAllIntRegs));
        assert(bitset128equal(genFreeFltRegs, genAllFltRegs));

#endif

        assert(genFreeSpcRegs == genAllSpcRegs);
    }

    insBuildDone();

#ifdef  DEBUG

    if  (verbose||0)
    {
        printf("\n\nDetailed  instruction dump:\n\n"); insDispBlocks(false);
        printf("\n\nPre-alloc instruction dump:\n\n"); insDispBlocks( true);
    }

#endif

    /*
        Figure out the smallest register we can use for locals. in order to
        do that, we'll need to figure out what will go into the function's
        prolog and epilog.

        Here are some typical examples:

            Leaf procedure:

                alloc   r3=x, x, x, x   // note that 'r3' is thrown away
              [ mov.i   rTMP=ar.lc ]    // if 'lc' register used

                ...
                ...

              [ mov.i   ar.lc=rTMP ]    // if 'lc' register used
                br.ret.sptk.few b0


            Non-leaf procedure:

                alloc   r34=x, x, x, x
                mov     r33=b0
                mov     r35=gp

                adds    sp=-<size>, sp
                ld8.nta r3=[sp]

                ...
                ...

                adds    sp=<size>, sp

                mov     b0=r33
                mov     gp=r35
                mov.i   ar.pfs=r34
                br.ret.sptk.few b0
     */

    nxtIntStkRegAddr = regsIntStk;
    nxtIntScrRegAddr = regsIntScr;
    nxtFltSavRegAddr = regsFltSav;
    nxtFltScrRegAddr = regsFltScr;

    assert(*nxtIntStkRegAddr == REG_INT_MIN_STK);

    lastIntStkReg    = REG_INT_MIN_STK + intArgRegCnt;

    minRsvdIntStkReg = REG_INT_MIN_STK;
    maxRsvdIntStkReg = REG_INT_MIN_STK + intArgRegCnt - 1;

    minPrSvIntStkReg =
    maxPrSvIntStkReg = 0;

    if  (genNonLeafFunc)
    {
        minRsvdIntStkReg = genMaxIntArgReg ? genMaxIntArgReg
                                           : REG_INT_MIN_STK;

//      maxRsvdIntStkReg = maxRsvdIntStkReg - 1;

        /* Non-leaf functions need to save "pfs", "b0" and sometimes "gp" */

        minPrSvIntStkReg =
        genPrologSrPfs   = (regNumber)++maxRsvdIntStkReg;
        genPrologSrRP    = (regNumber)++maxRsvdIntStkReg;

        if  (genExtFuncCall)
        {
            maxPrSvIntStkReg =
            genPrologSrGP    = (regNumber)++maxRsvdIntStkReg;
        }
        else
        {
            maxPrSvIntStkReg = (regNumber)  maxRsvdIntStkReg;
            genPrologSrGP    = REG_NA;
        }

        if  (genUsesArLc)
        {
            maxPrSvIntStkReg =
            genPrologSrLC    = (regNumber)++maxRsvdIntStkReg;
        }
        else
        {
            maxPrSvIntStkReg = (regNumber)  maxRsvdIntStkReg;
            genPrologSrLC    = REG_NA;
        }

        if  (lastIntStkReg <= maxRsvdIntStkReg)
             lastIntStkReg =  maxRsvdIntStkReg+1;
    }

    /* Perform temp register allocation */

    genAllocTmpRegs();

    /* Start forming the prolog by bashing the 'prolog' opcode to 'alloc' */

    assert(insFncProlog && insFncProlog->idIns == INS_PROLOG);

    insFncProlog->idIns = INS_alloc;
    insFncProlog->idReg = REG_r003;

    /* We're ready to allocate variables to registers */

    genAllocVarRegs();

    /* Assign offsets to locals/temps and arguments that live on the stack */

    lvaAssignFrameOffsets(true);

    /* Figure out where the output argument registers really start */

    begOutArgIntReg = lastIntStkReg;

    /* We can now fill in the 'alloc' arguments (in the prolog) */

    insFncProlog->idProlog.iInp = (BYTE) intArgRegCnt;
    insFncProlog->idProlog.iLcl = (BYTE)(lastIntStkReg - intArgRegCnt - REG_INT_MIN_STK);
    insFncProlog->idProlog.iOut = (BYTE) genOutArgRegCnt;

#ifdef  DEBUG

    if  (dspCode)
    {
        printf("// stacked incoming args = %2u regs [start with r%03u]\n", insFncProlog->idProlog.iInp, 32);
        printf("// stacked local    vars = %2u regs [start with r%03u]\n", insFncProlog->idProlog.iLcl, lastIntStkReg);
        printf("// stacked outgoing args = %2u regs [start with r%03u]\n", insFncProlog->idProlog.iOut, begOutArgIntReg);
    }

    assert(insFncProlog->idProlog.iInp +
           insFncProlog->idProlog.iLcl +
           insFncProlog->idProlog.iOut < 96);

#endif

    /* Prepare to insert instructions in the prolog */

    insLast = insFncProlog;
    insNext = insFncProlog->idNext;

    /* Is this a non-leaf function? */

    if  (genNonLeafFunc)
    {
        insPtr          insReg1;
        insPtr          insReg2;

        /* Save the "pfs" state by changing the "alloc" instruction */

        insFncProlog->idReg   = genPrologSrPfs;

        genMarkPrologIns(insFncProlog);     // record where pfs is saved

        /* Save the "br0" register in the appropriate stacked local */

        insReg1               = insAllocNX (INS_PHYSREG    , TYP_I_IMPL);
        insReg1->idReg        = genPrologSrRP;

        insReg2               = insAllocNX (INS_CNS_INT    , TYP_I_IMPL);
        insReg2->idConst.iInt = 0;

        insLast               = insAllocIns(INS_mov_reg_brr, TYP_I_IMPL, insLast, insNext);
        insLast->idRes        = insReg1;
        insLast->idOp.iOp1    = NULL;
        insLast->idOp.iOp2    = insReg2;

        genMarkPrologIns(insLast);          // record where rp is saved

        insMarkDepS1D1(insLast, IDK_REG_BR , 0,
                                IDK_REG_INT, genPrologSrRP);

        /* Save the "gp" register in the last stacked local */

        if  (!genExtFuncCall)
            goto NO_SAVE_GP;

        insReg1               = insAllocNX (INS_PHYSREG    , TYP_I_IMPL);
        insReg1->idReg        = genPrologSrGP;

        insReg2               = insAllocNX (INS_PHYSREG    , TYP_I_IMPL);
        insReg2->idReg        = REG_gp;

        insLast               = insAllocIns(INS_mov_reg    , TYP_I_IMPL, insLast, insNext);
        insLast->idRes        = insReg1;
        insLast->idOp.iOp1    = NULL;
        insLast->idOp.iOp2    = insReg2;

        genMarkPrologIns(insLast);          // record where gp is saved

        insMarkDepS1D1(insLast, IDK_REG_INT, REG_gp,
                                IDK_REG_INT, genPrologSrGP);

    NO_SAVE_GP:

        /* Create the stack frame -- first generate any necessary probes */

        if  (compLclFrameSize >= 8192)      // hack: hard-wired OS page size
        {
            size_t          stkOffs = 8192;

//          printf("frame size = %d = 0x%04X\n", compLclFrameSize, compLclFrameSize);

            do
            {
                printf("// UNDONE: generate stack probe at [sp-0x%04X]\n", stkOffs);

//              genMarkPrologIns(insLast);  // mark stack probe

                stkOffs += 8192;            // hack: hard-wired OS page size
            }
            while (stkOffs < compLclFrameSize);
        }

        if  (signed32IntFitsInBits(-compLclFrameSize, 14))
        {
            insPtr          insTemp;

            /* Small frame size: append "add sp=-size,sp" */

            insReg1               = insAllocNX (INS_PHYSREG    , TYP_I_IMPL);
            insReg1->idReg        = REG_sp;

            insReg2               = insAllocNX (INS_CNS_INT    , TYP_I_IMPL);
            insReg2->idConst.iInt = -(NatInt)compLclFrameSize;

            insTemp               = insAllocNX (INS_PHYSREG    , TYP_I_IMPL);
            insTemp->idReg        = REG_sp;

            insLast               = insAllocIns(INS_add_reg_i14, TYP_I_IMPL, insLast, insNext);
            insLast->idRes        = insReg1;
            insLast->idOp.iOp1    = insTemp;
            insLast->idOp.iOp2    = insReg2;

            insMarkDepS1D1(insLast, IDK_REG_INT, REG_sp,
                                    IDK_REG_INT, REG_sp);

            genMarkPrologIns(insLast);      // record where frame is created
        }
        else
        {
            insPtr          insTemp;
            instruction     insMove;

            /* Large frame size: append "mov r3=-size" and "add sp=r3,sp" */

            insReg1               = insAllocNX (INS_PHYSREG    , TYP_I_IMPL);
            insReg1->idReg        = REG_r003;

            insReg2               = insAllocNX (INS_CNS_INT    , TYP_I_IMPL);
            insReg2->idConst.iInt = -(NatInt)compLclFrameSize;

            insMove = signed32IntFitsInBits(-compLclFrameSize, 22) ? INS_mov_reg_i22
                                                                   : INS_mov_reg_i64;

            insLast               = insAllocIns(insMove        , TYP_I_IMPL, insLast, insNext);
            insLast->idRes        = insReg1;
            insLast->idOp.iOp1    = NULL;
            insLast->idOp.iOp2    = insReg2;

            insMarkDepS0D1(insLast, IDK_REG_INT, REG_r003);

            insReg1               = insAllocNX (INS_PHYSREG    , TYP_I_IMPL);
            insReg1->idReg        = REG_sp;

            insReg2               = insAllocNX (INS_PHYSREG    , TYP_I_IMPL);
            insReg2->idReg        = REG_r003;

            insTemp               = insAllocNX (INS_PHYSREG    , TYP_I_IMPL);
            insTemp->idReg        = REG_sp;

            insLast               = insAllocIns(INS_add_reg_reg, TYP_I_IMPL, insLast, insNext);
            insLast->idRes        = insReg1;
            insLast->idOp.iOp1    = insReg2;
            insLast->idOp.iOp2    = insTemp;

            insMarkDepS2D1(insLast, IDK_REG_INT, REG_r003,
                                    IDK_REG_INT, REG_sp,
                                    IDK_REG_INT, REG_sp);

            genMarkPrologIns(insLast);      // record where frame is created
        }

        /* Probe at the very bottom of the stack frame */

        insReg1               = insAllocNX (INS_PHYSREG    , TYP_I_IMPL);
        insReg1->idReg        = REG_r003;

        insReg2               = insAllocNX (INS_PHYSREG    , TYP_I_IMPL);
        insReg2->idReg        = REG_sp;

        insLast               = insAllocIns(INS_ld8_ind    , TYP_I_IMPL, insLast, insNext);
        insLast->idRes        = insReg1;
        insLast->idOp.iOp1    = insReg2;
        insLast->idOp.iOp2    = NULL;
        insLast->idFlags     |= IF_LDIND_NTA;

        insMarkDepS2D1(insLast, IDK_REG_INT, REG_sp,
                                IDK_IND,     3,
                                IDK_REG_INT, REG_r003);

        genMarkPrologIns(insLast);          // record where prolog ends
    }
    else
    {
        /* Leaf function - do we have any stacked locals at all ? */

        if  (lastIntStkReg == REG_INT_MIN_STK && !intArgRegCnt && !genOutArgRegCnt)
        {
            insFncProlog->idIns    = INS_ignore;
            insFncProlog->idFlags |= IF_NO_CODE;
        }
    }

    /* Mark the dependency of the prolog opcode */

    insMarkDepS0D1(insFncProlog, IDK_REG_INT, insFncProlog->idReg);

    /* Do we need to preserve ar.lc ? */

    if  (genUsesArLc)
    {
        insPtr          insReg1;
        insPtr          insReg2;

        insReg1               = insAllocNX (INS_PHYSREG    , TYP_I_IMPL);
        insReg1->idReg        = genPrologSrLC;

        insReg2               = insAllocNX (INS_CNS_INT    , TYP_I_IMPL);
        insReg2->idConst.iInt = REG_APP_LC;

        insLast               = insAllocIns(INS_mov_reg_arr, TYP_I_IMPL, insLast, insNext);
        insLast->idRes        = insReg1;
        insLast->idOp.iOp1    = NULL;
        insLast->idOp.iOp2    = insReg2;

        insMarkDepS1D1(insLast, IDK_REG_APP, REG_APP_LC,
                                IDK_REG_INT, genPrologSrLC);
    }

    /* Copy any incoming arguments from their registers */

    if  (1)
    {
        insPtr          insReg1;
        insPtr          insReg2;

        /*
            Figure out min and max incoming argument registers, also
            save any arguments that come in registers but live on the
            stack frame within the function into their home locations.
         */

        NatUns          minArgReg = REG_r127;
        NatUns          maxArgReg = REG_r000;

        for (varNum = 0, varDsc = lvaTable;
             varNum < lvaCount;
             varNum++  , varDsc++)
        {
            if  (varDsc->lvRefCnt == 0)
                continue;
            if  (varDsc->lvIsParam == false)
                break;

            if  (varDsc->lvIsRegArg)
            {
                assert((varDsc->lvRegister == 0) != (varDsc->lvOnFrame == false));

                if  (varDsc->lvOnFrame)
                {
                    insPtr          insOffs;
                    insPtr          argAddr;
                    size_t          argSize;
                    insPtr          insArgR;

                    insPtr          insOfs;
                    insPtr          insSPr;
                    insPtr          insAdr;

                    var_types       argTyp = varDsc->TypeGet();
                    size_t          argOfs = varDsc->lvStkOffs;

                    /* Compute the sum of "sp" and the argument's frame offset */

                    insReg1               = insPhysRegRef(REG_sp, argTyp, false);

                    insOffs               = insAllocNX(INS_FRMVAR, argTyp);
                    insOffs->idFvar.iVnum = varNum;

                    argAddr               = insAllocIns(INS_add_reg_i14, TYP_I_IMPL, insLast, insNext);
                    argAddr->idOp.iOp1    = insReg1;
                    argAddr->idOp.iOp2    = insOffs;

                    insFindTemp   (argAddr, true);

                    markDepSrcOp  (argAddr, IDK_REG_INT, REG_sp);
                    markDepDstOp  (argAddr, IDK_TMP_INT, argAddr->idTemp);

                    /* Store the incoming argument into its home on the frame */

                    argSize = genInsSizeIncr(genTypeSize(argTyp));

                    assert(INS_st1_ind + genInsSizeIncr(1) == INS_st1_ind);
                    assert(INS_st1_ind + genInsSizeIncr(2) == INS_st2_ind);
                    assert(INS_st1_ind + genInsSizeIncr(4) == INS_st4_ind);
                    assert(INS_st1_ind + genInsSizeIncr(8) == INS_st8_ind);

                    insArgR            = insAllocNX(INS_PHYSREG, argTyp);
                    insArgR->idReg     = varDsc->lvArgReg;

                    insLast            = insAllocIns((instruction)(INS_st1_ind + argSize), argTyp, argAddr, insNext);
                    insLast->idOp.iOp1 = argAddr;
                    insLast->idOp.iOp2 = insArgR;

                    markDepSrcOp(insLast, argAddr, insArgR);
                    markDepDstOp(insLast, argAddr, IDK_LCLVAR, varNum+1);

                    insFreeTemp(argAddr);
                }
                else
                {
                    if  (minArgReg > varDsc->lvIsRegArg) minArgReg = varDsc->lvIsRegArg;
                    if  (maxArgReg < varDsc->lvIsRegArg) maxArgReg = varDsc->lvIsRegArg;
                }
            }
        }

        /* Move incoming arguments to their assigned locations */

        for (varNum = 0, varDsc = lvaTable;
             varNum < lvaCount;
             varNum++  , varDsc++)
        {
            if  (varDsc->lvIsRegArg && varDsc->lvRefCnt)
            {
                var_types       argTyp = varDsc->TypeGet();

//              printf("Incoming arg: %u -> %u\n", varDsc->lvArgReg, varDsc->lvRegNum);

                if  (varDsc->lvRegister)
                {
                    assert(varDsc->lvOnFrame == false);

                    if  (varDsc->lvRegNum != varDsc->lvArgReg)
                    {
                        instruction     imov;

                        if  (varTypeIsFloating(argTyp))
                        {
                            imov = INS_fmov;
                        }
                        else
                        {
                            imov = INS_mov_reg;

                            /* Check for potential shuffling conflict */

                            if  ((NatUns)varDsc->lvRegNum >= minArgReg &&
                                 (NatUns)varDsc->lvRegNum <= maxArgReg)
                            {
                                printf("UNDONE: potential arg conflict [%u..%u] and %u->%u\n", minArgReg,
                                                                                               maxArgReg,
                                                                                               varDsc->lvArgReg,
                                                                                               varDsc->lvRegNum);
                                UNIMPL("need to shuffle incoming args more carefully");
                            }
                        }

                        /* Copy the argument to its new home */

                        insReg1            = insAllocNX (INS_PHYSREG, argTyp);
                        insReg1->idReg     = varDsc->lvRegNum;

                        insReg2            = insAllocNX (INS_PHYSREG, argTyp);
                        insReg2->idReg     = varDsc->lvArgReg;

                        insLast            = insAllocIns(imov       , argTyp, insLast, insNext);
                        insLast->idRes     = insReg1;
                        insLast->idOp.iOp1 = NULL;
                        insLast->idOp.iOp2 = insReg2;

                        markDepSrcOp(insLast, insReg2);
                        markDepDstOp(insLast, insReg1);
                    }
                }
                else
                {
                    moveArgs2frm = true;
                }
            }
        }
    }

    /* Process all the 'epilog' opcodes we've generated */

    for (insPtr exitIns = insExitList; exitIns; exitIns = exitIns->idEpilog.iNxtX)
    {
        assert(exitIns->idIns == INS_EPILOG);

        if  (genNonLeafFunc)
        {
            insPtr          insReg1;
            insPtr          insReg2;

            insPtr          insNext = exitIns;
            insPtr          insLast = exitIns->idPrev; assert(insLast);

#if 0

            /* Restore the "gp" register */

            if  (!genExtFuncCall)
                goto NO_REST_GP;

            insReg1               = insAllocNX (INS_PHYSREG    , TYP_I_IMPL);
            insReg1->idReg        = REG_gp;

            insReg2               = insAllocNX (INS_PHYSREG    , TYP_I_IMPL);
            insReg2->idReg        = genPrologSrGP;

            insLast               = insAllocIns(INS_mov_reg    , TYP_I_IMPL, insLast, insNext);
            insLast->idRes        = insReg1;
            insLast->idOp.iOp1    = NULL;
            insLast->idOp.iOp2    = insReg2;

            insMarkDepS1D1(insLast, IDK_REG_INT, genPrologSrGP,
                                    IDK_REG_INT, REG_gp);

        NO_REST_GP:

#endif

            /* Restore the ar.lc if necessary */

            if  (genUsesArLc)
            {
                insPtr          insReg1;
                insPtr          insReg2;

                insReg1               = insAllocNX (INS_CNS_INT    , TYP_I_IMPL);
                insReg1->idConst.iInt = REG_APP_LC;

                insReg2               = insAllocNX (INS_PHYSREG    , TYP_I_IMPL);
                insReg2->idReg        = genPrologSrLC;

                insLast               = insAllocIns(INS_mov_arr_reg, TYP_I_IMPL, insLast, insNext);
                insLast->idRes        = insReg1;
                insLast->idOp.iOp1    = NULL;
                insLast->idOp.iOp2    = insReg2;

                insMarkDepS1D1(insLast, IDK_REG_INT, genPrologSrLC,
                                        IDK_REG_APP, REG_APP_LC);
            }

            /* Restore the "br0" register */

            insReg1               = insAllocNX (INS_CNS_INT    , TYP_I_IMPL);
            insReg1->idConst.iInt = 0;

            insReg2               = insAllocNX (INS_PHYSREG    , TYP_I_IMPL);
            insReg2->idReg        = genPrologSrRP;

            insLast               = insAllocIns(INS_mov_brr_reg, TYP_I_IMPL, insLast, insNext);
            insLast->idRes        = insReg1;
            insLast->idOp.iOp1    = NULL;
            insLast->idOp.iOp2    = insReg2;

            insMarkDepS1D1(insLast, IDK_REG_INT, genPrologSrRP,
                                    IDK_REG_BR , 0);

            /* Restore "pfs" from the saved registers */

            insReg1               = insAllocNX (INS_CNS_INT    , TYP_I_IMPL);
            insReg1->idConst.iInt = REG_APP_PFS;

            insReg2               = insAllocNX (INS_PHYSREG    , TYP_I_IMPL);
            insReg2->idReg        = genPrologSrPfs;

            insLast               = insAllocIns(INS_mov_arr_reg, TYP_I_IMPL, insLast, insNext);
            insLast->idRes        = insReg1;
            insLast->idOp.iOp1    = NULL;
            insLast->idOp.iOp2    = insReg2;

            insMarkDepS1D0(insLast, IDK_REG_INT, genPrologSrPfs);

            /* Now is the time to remove our stack frame */

            assert(compLclFrameSize);

            if  (signed32IntFitsInBits(-compLclFrameSize, 14))
            {
                insPtr          insTemp;

                /* Small frame size: add "add sp=size,sp" */

                insReg1               = insAllocNX (INS_PHYSREG    , TYP_I_IMPL);
                insReg1->idReg        = REG_sp;

                insReg2               = insAllocNX (INS_CNS_INT    , TYP_I_IMPL);
                insReg2->idConst.iInt = compLclFrameSize;

                insTemp               = insAllocNX (INS_PHYSREG    , TYP_I_IMPL);
                insTemp->idReg        = REG_sp;

                insLast               = insAllocIns(INS_add_reg_i14, TYP_I_IMPL, insLast, insNext);
                insLast->idRes        = insReg1;
                insLast->idOp.iOp1    = insTemp;
                insLast->idOp.iOp2    = insReg2;

                insMarkDepS1D1(insLast, IDK_REG_INT, REG_sp,
                                        IDK_REG_INT, REG_sp);
            }
            else
            {
                insPtr          insTemp;
                instruction     insMove;

                /* Large frame size: append "mov r3=size" and "add sp=r3,sp" */

                insReg1               = insAllocNX (INS_PHYSREG    , TYP_I_IMPL);
                insReg1->idReg        = REG_r003;

                insReg2               = insAllocNX (INS_CNS_INT    , TYP_I_IMPL);
                insReg2->idConst.iInt = compLclFrameSize;

                insMove = signed32IntFitsInBits(compLclFrameSize, 22) ? INS_mov_reg_i22
                                                                      : INS_mov_reg_i64;

                insLast               = insAllocIns(insMove        , TYP_I_IMPL, insLast, insNext);
                insLast->idRes        = insReg1;
                insLast->idOp.iOp1    = NULL;
                insLast->idOp.iOp2    = insReg2;

                insMarkDepS0D1(insLast, IDK_REG_INT, REG_r003);

                insReg1               = insAllocNX (INS_PHYSREG    , TYP_I_IMPL);
                insReg1->idReg        = REG_r003;

                insReg2               = insAllocNX (INS_PHYSREG    , TYP_I_IMPL);
                insReg2->idReg        = REG_sp;

                insTemp               = insAllocNX (INS_PHYSREG    , TYP_I_IMPL);
                insTemp->idReg        = REG_sp;

                insLast               = insAllocIns(INS_add_reg_reg, TYP_I_IMPL, insLast, insNext);
                insLast->idRes        = insReg1;
                insLast->idOp.iOp1    = insReg2;
                insLast->idOp.iOp2    = insTemp;

                insMarkDepS2D1(insLast, IDK_REG_INT, REG_sp,
                                        IDK_REG_INT, REG_r003,
                                        IDK_REG_INT, REG_r003);
            }
        }

        /* Bash the last/only epilog instruction to 'br.ret b0' */

        exitIns->idIns  = INS_br_ret;
        exitIns->idKind = ins2kind(INS_br_ret);

        insMarkDepS1D0(exitIns, IDK_REG_BR, 0);
    }

#ifdef  DEBUG

    if  (dspCode)
    {
        genRenInstructions();

        printf("\n\n");

        if  (genMaxIntArgReg)
            printf("// Arg-in    registers [int] used: r%03u .. r%03u\n", REG_INT_MIN_STK,
                                                                          genMaxIntArgReg);

#if 0

        if  (minVarIntReg != maxVarIntReg)
            printf("// Variable  registers [int] used: r%03u .. r%03u\n", minVarIntReg,
                                                                          maxVarIntReg - 1);
        if  (minTmpIntReg != maxTmpIntReg)
            printf("// Temporary registers [int] used: r%03u .. r%03u\n", minTmpIntReg,
                                                                          maxTmpIntReg - 1);

        if  (maxOutArgIntReg)
            printf("// Arg-out   registers [int] used: r%03u .. r%03u\n", maxTmpIntReg,
                                                                          maxOutArgIntReg- minOutArgIntReg + maxTmpIntReg);

#endif

        if  (verbose||0)
        {
            printf("\n\nReg-alloc instruction dump:\n\n"); insDispBlocks( true);
        }
    }

#endif

    /* Get the code offset of the function */

    genCurFuncOffs = emitIA64curCodeOffs();

    /* Create a descriptor if appropriate [ISSUE: when not to create one?] */

    _uint64         offs64  = genCurFuncOffs;
    _uint64         gpValue = 0;

    /* The descriptor is the address of the code followed by the GP value */

    assert(sizeof(offs64 ) == 8);

    genCurDescOffs = genPEwriter->WPEsecAddData(PE_SECT_rdata, (BYTE*)&offs64,
                                                                sizeof(offs64));

    genPEwriter->WPEsecAddFixup(PE_SECT_rdata, PE_SECT_text, genCurDescOffs     , true);

    assert(sizeof(gpValue) == 8);

                     genPEwriter->WPEsecAddData(PE_SECT_rdata, (BYTE*)&gpValue,
                                                                sizeof(gpValue));

    genPEwriter->WPEsecAddFixup(PE_SECT_rdata, PE_SECT_sdata, genCurDescOffs + 8, true);

#ifdef  DEBUG
    const   char *  methName = genFullMethodName(TheCompiler->info.compFullName);
#else
    const   char *  methName = "<method>";
#endif

    genNoteFunctionBody(methName, genCurFuncOffs,
                                  genCurDescOffs);

    genIssueCode();

    if  (hadSwitch)
    {
        for (block = fgFirstBB; block; block = block->bbNext)
        {
            BasicBlock * *  jmpTab;
            NatUns          jmpCnt;

            NatUns          IPoffs;
            BYTE *          tabPtr;

            if  (block->bbJumpKind != BBJ_SWITCH)
                continue;

            jmpCnt = block->bbJumpSwt->bbsCount - 1;
            jmpTab = block->bbJumpSwt->bbsDstTab;

            IPoffs = block->bbJumpSwt->bbsIPmOffs;
            tabPtr = block->bbJumpSwt->bbsTabAddr;

//          printf("Process switch whose mov reg=ip is at %04X:\n", IPoffs);

            do
            {
                BasicBlock *    cblk = *jmpTab;
                insBlk          eblk = (insBlk)cblk->bbInsBlk;

                assert(eblk && eblk->igSelf == eblk);

//              printf("    case offset = %04X / %04X\n", eblk->igOffs, eblk->igOffs - IPoffs);

                *(unsigned __int32*)tabPtr = eblk->igOffs - IPoffs; tabPtr += 4;
            }
            while (++jmpTab, --jmpCnt);
        }
    }

#ifdef  DEBUG
    CompiledFncCnt++;
#endif

    if  (debugInfo)
        genDbgEndFunc();
}

/*****************************************************************************
 *
 *  For each IA64 instruction template, describes the execution units in order
 *  of encoding. Each entry consists of a series of XU values, terminated by a
 *  XU_N value; ILP barriers are indicated by XU_P entries.
 */

static
BYTE                genTmplateTab[32][6] =
{
    { XU_M,       XU_I,       XU_I,       XU_N },   // 0x00
    { XU_M,       XU_I,       XU_I, XU_P, XU_N },   // 0x01
    { XU_M,       XU_I, XU_P, XU_I,       XU_N },   // 0x02
    { XU_M,       XU_I, XU_P, XU_I, XU_P, XU_N },   // 0x03
    { XU_M,       XU_L,                   XU_N },   // 0x04
    { XU_M,       XU_L,             XU_P, XU_N },   // 0x05
    {                                     XU_N },   // 0x06
    {                                     XU_N },   // 0x07
    { XU_M,       XU_M,       XU_I,       XU_N },   // 0x08
    { XU_M,       XU_M,       XU_I, XU_P, XU_N },   // 0x09
    { XU_M, XU_P, XU_M,       XU_I,       XU_N },   // 0x0A
    { XU_M, XU_P, XU_M,       XU_I, XU_P, XU_N },   // 0x0B
    { XU_M,       XU_F,       XU_I,       XU_N },   // 0x0C
    { XU_M,       XU_F,       XU_I, XU_P, XU_N },   // 0x0D
    { XU_M,       XU_M,       XU_F,       XU_N },   // 0x0E
    { XU_M,       XU_M,       XU_F, XU_P, XU_N },   // 0x0F

    { XU_M,       XU_I,       XU_B,       XU_N },   // 0x10
    { XU_M,       XU_I,       XU_B, XU_P, XU_N },   // 0x11
    { XU_M,       XU_B,       XU_B,       XU_N },   // 0x12
    { XU_M,       XU_B,       XU_B, XU_P, XU_N },   // 0x13
    {                                     XU_N },   // 0x14
    {                                     XU_N },   // 0x15
    { XU_B,       XU_B,       XU_B,       XU_N },   // 0x16
    { XU_B,       XU_B,       XU_B, XU_P, XU_N },   // 0x17
    { XU_M,       XU_M,       XU_B,       XU_N },   // 0x18
    { XU_M,       XU_M,       XU_B, XU_P, XU_N },   // 0x19
    {                                     XU_N },   // 0x1A
    {                                     XU_N },   // 0x1B
    { XU_M,       XU_F,       XU_B,       XU_N },   // 0x1C
    { XU_M,       XU_F,       XU_B, XU_P, XU_N },   // 0x1D
    {                                     XU_N },   // 0x1E
    {                                     XU_N },   // 0x1F
};

/*****************************************************************************
 *
 *  Locate the nearest instruction that generates code, starting with 'ins'.
 */

static
insPtr              genIssueNextIns(insPtr ins, IA64execUnits *xuPtr, insPtr *srcPtr)
{
    *srcPtr = NULL;

    while (ins)
    {
        if  (!(ins->idFlags & IF_NO_CODE))
        {
            *xuPtr = (IA64execUnits)genInsXU((instruction)ins->idIns);
            return  ins;
        }

        if  (ins->idIns == INS_SRCLINE)
            *srcPtr = ins;

        ins = ins->idNext;
    }

    return  ins;
}

#ifdef  DEBUG

const   char *      genXUname(IA64execUnits xu)
{
    static
    const   char *  names[] =
    {
        NULL,

        "A",
        "M",
        "I",
        "B",
        "F",

        "L",
        "X",

        "-",
    };

    assert(!strcmp(names[XU_A], "A"));
    assert(!strcmp(names[XU_M], "M"));
    assert(!strcmp(names[XU_I], "I"));
    assert(!strcmp(names[XU_B], "B"));
    assert(!strcmp(names[XU_L], "L"));
    assert(!strcmp(names[XU_X], "X"));
    assert(!strcmp(names[XU_F], "F"));
    assert(!strcmp(names[XU_P], "-"));

    assert((NatUns)xu < sizeof(names)/sizeof(names[0]));
    assert(names[xu]);

    return names[xu];
}

#endif

/*****************************************************************************
 *
 *  Return the bit position of the given instruction slot with an IA64 bundle.
 */

inline
NatUns              IA64insBitPos(NatUns slot)
{
    static
    BYTE            bpos[3] = { 5, 46, 87 };

    assert(slot < 3);

    return  bpos[slot];
}

/*****************************************************************************
 *
 *  Assign offsets to local variables / temps that live on the stack.
 */

void                Compiler::lvaAssignFrameOffsets(bool final)
{
    NatUns          lclNum;
    LclVarDsc   *   varDsc;

    NatUns          hasThis;
    ARG_LIST_HANDLE argLst;
    int             argOffs, firstStkArgOffs;

    assert(final);

#if USE_FASTCALL
    NatUns          argRegNum  = 0;
#endif

    lvaDoneFrameLayout = 2;

    /* Make sure we leave enough room for outgoing arguments */

    compLclFrameSize = 16;

    if  (genNonLeaf && maxOutArgStk)
        compLclFrameSize = (maxOutArgStk + 15) & 15;

#if SECURITY_CHECK

    /* If we need space for a security token, reserve it now */

    if  (opts.compNeedSecurityCheck)
    {
        /* Reserve space on the stack by bumping the frame size */

        compLclFrameSize += 8;
    }

#endif

    /*
        If we're supposed to track lifetimes of pointer temps, we'll
        assign frame offsets in the following order:

            non-pointer local variables (also untracked pointer variables)
                pointer local variables
                pointer temps
            non-pointer temps
     */

    bool    assignDone = false; // false in first pass, true in second
    bool    assignNptr = true;  // First pass,  assign offsets to non-ptr
    bool    assignPtrs = false; // Second pass, assign offsets to tracked ptrs
    bool    assignMore = false; // Are there any tracked ptrs (else 2nd pass not needed)

    /* We will use just one pass, and assign offsets to all variables */

    if  (opts.compDbgEnC)
        assignPtrs = true;

AGAIN1:

    for (lclNum = 0, varDsc = lvaTable;
         lclNum < lvaCount;
         lclNum++  , varDsc++)
    {
        /* Ignore variables that are not on the stack frame */

        if  (!varDsc->lvOnFrame)
        {
            /* For EnC, all variables have to be allocated space on the
               stack, even though they may actually be enregistered. This
               way, the frame layout can be directly inferred from the
               locals-sig.
             */

            if  (!opts.compDbgEnC)
                continue;
            if  (lclNum >= TheCompiler->info.compLocalsCount) // ignore temps for EnC
                continue;
        }

        if  (varDsc->lvIsParam)
        {
            /*  A register argument that is not enregistred ends up as
                a local variable which will need stack frame space,
             */

            if  (!varDsc->lvIsRegArg)
                continue;
        }

        /* Make sure the type is appropriate */

        if  (varTypeIsGC(varDsc->TypeGet()) && varDsc->lvTracked)
        {
            if  (!assignPtrs)
            {
                assignMore = true;
                continue;
            }
        }
        else
        {
            if  (!assignNptr)
            {
                assignMore = true;
                continue;
            }
        }

        /* Save the variable's stack offset, we'll figure out the rest later */

        varDsc->lvStkOffs = compLclFrameSize;

//      printf("Local var #%03u is at stack offset %04X\n", lclNum, compLclFrameSize);

        /* Reserve the stack space for this variable */

        compLclFrameSize += lvaLclSize(lclNum);
        assert(compLclFrameSize % sizeof(int) == 0);

#ifdef  DEBUG
        if  (final && verbose)
        {
            var_types       lclGCtype = TYP_VOID;

            if  (varTypeIsGC(varDsc->TypeGet()) && varDsc->lvTracked)
                lclGCtype = varDsc->TypeGet();

            printf("%s-ptr local #%3u located at sp offset ", varTypeGCstring(lclGCtype), lclNum);
            if  (varDsc->lvStkOffs)
                printf(varDsc->lvStkOffs < 0 ? "-" : "+");
            else
                printf(" ");

            printf("0x%04X (size=%u)\n", abs(varDsc->lvStkOffs), lvaLclSize(lclNum));
        }
#endif

    }

    /* If we've only assigned one type, go back and do the others now */

    if  (!assignDone && assignMore)
    {
        assignNptr = !assignNptr;
        assignPtrs = !assignPtrs;
        assignDone = true;

        goto AGAIN1;
    }

    /* Adjust the argument offsets by the size of the locals/temps */

    for (lclNum = 0, varDsc = lvaTable;
         lclNum < lvaCount;
         lclNum++  , varDsc++)
    {
        if  (varDsc->lvIsParam)
        {
#if USE_FASTCALL
            if  (varDsc->lvIsRegArg)
                continue;
#endif
            varDsc->lvStkOffs += (int)compLclFrameSize;
        }

        /* Are there any variables at very large offsets? */

        if  (varDsc->lvOnFrame)
        {
            if  (varDsc->lvStkOffs >= 0x4000)
            {
                printf("WARNING: large stack frame offset 0x%04X present, <add reg=imm14,sp> won't work!\n", varDsc->lvStkOffs);
            }
        }
    }

    /*-------------------------------------------------------------------------
     *
     * Debug output
     *
     *-------------------------------------------------------------------------
     */

#ifdef  DEBUG
#ifndef NOT_JITC

    if  (final&&verbose)
    {
        for (lclNum = 0, varDsc = lvaTable;
             lclNum < lvaCount;
             lclNum++  , varDsc++)
        {
            NatUns          sp = 16;

            const   char *  baseReg = "sp";

            if  (varDsc->lvIsParam)
            {
                printf("        arg ");
            }
            else
            {
                var_types lclGCtype = TYP_VOID;

                if  (varTypeIsGC(varDsc->TypeGet()) && varDsc->lvTracked)
                    lclGCtype = varDsc->TypeGet();

                printf("%s-ptr lcl ", varTypeGCstring(lclGCtype));
            }

            printf("#%3u located ", lclNum);

            /* Keep track of the number of characters printed */

            sp = 20;

            if  (varDsc->lvRegister)
            {
                const   char *  reg;

                sp -= printf("in ");

#if!TGT_IA64

                if  (isRegPairType((var_types)varDsc->lvType))
                {
                    if  (varDsc->lvOtherReg == REG_STK)
                    {
                        sp -= printf("[%s", baseReg);

                        if  (varDsc->lvStkOffs)
                        {
                            sp -= printf("%c0x%04X]", varDsc->lvStkOffs < 0 ? '-'
                                                                            : '+',
                                                      abs(varDsc->lvStkOffs));
                        }
                        else
                            sp -= printf("       ]");
                    }
                    else
                    {
                        reg = getRegName(varDsc->lvOtherReg);
                        sp -= printf("%s", reg);
                    }

                    sp -= printf(":");
                }

#endif

                reg = getRegName(varDsc->lvRegNum);
                sp -= printf("%s", reg);
            }
            else  if (varDsc->lvOnFrame)
            {
                sp -= printf("at [%s", baseReg);

                if  (varDsc->lvStkOffs)
                    sp -= printf(varDsc->lvStkOffs < 0 ? "-" : "+");
                else
                    sp -= printf(" ");

                sp -= printf("0x%04X]", abs(varDsc->lvStkOffs));
            }
            else
            {
                assert(varDsc->lvRefCnt == 0);
                sp -= printf("never used");
            }

            /* Pad to the desired fixed length */

            assert((int)sp >= 0);
            printf("%*c", -sp, ' ');

            printf(" (sz=%u)", genTypeSize((var_types)varDsc->lvType));
            printf("\n");
        }
    }

#endif
#endif

}

/*****************************************************************************
 *
 *  Initialize the IA64 machine code emission logic.
 */

struct  fwdJmpDsc
{
    fwdJmpDsc *     fjNext;
    insBlk          fjDest;

    NatUns          fjOffs:NatBits-2;
    NatUns          fjSlot:2;
};

static
fwdJmpDsc *         emitFwdJumpList;

static
void                emitIA64init()
{
    emitFwdJumpList = NULL;
}

static
void                emitIA64gen (const void *data, size_t size)
{
    NatUns          offs;

    /* This is a pretty lame hack: write each little piece individually */

    offs = genPEwriter->WPEsecAddData(PE_SECT_text, (BYTE*)data, size);

    assert(offs == genCurCodeOffs); genCurCodeOffs += size;
}

static
_uint64             emitIA64jump(NatUns slot, insBlk dest, _uint64 opcode)
{
    NatUns          offs = emitIA64curCodeOffs();

    if  (dest->igOffs == -1)
    {
        fwdJmpDsc *     jump = (fwdJmpDsc *)insAllocMem(sizeof(*jump));

        jump->fjDest = dest;
        jump->fjOffs = offs;
        jump->fjSlot = slot;
        jump->fjNext = emitFwdJumpList;
                       emitFwdJumpList = jump;
    }
    else
    {
        NatInt          dist = (dest->igOffs - (NatInt)offs)/16; assert(dist <= 0);

//      printf("BWD jump from %04X to %04X [distance=-0x%04X]\n", offs, dest->igOffs, -dist);

        /* Insert the relative distance into the opcode */

        opcode |=          (dist & formBitMask( 0,20)) <<      13;  // imm20b
        opcode |= (_uint64)(dist & formBitMask(20, 1)) << (36-20);  // sign
    }

    return  opcode;
}

static
void                emitIA64call(NatUns slot, insPtr call)
{
//  genPEwriter->WPEsecAddFixup(PE_SECT_text, fix->ILfixSect,
//                                            fix->ILfixOffs + ofs);
}

static
void                emitIA64done()
{
    fwdJmpDsc *     jump;

    for (jump = emitFwdJumpList; jump; jump = jump->fjNext)
    {
        insBlk          dest = jump->fjDest; assert(dest->igSelf == dest && dest->igOffs != -1);
        NatUns          offs = jump->fjOffs;
        NatInt          dist = (dest->igOffs - (NatInt)offs)/16;
        BYTE    *       addr;

        bitset128       bundle;

//      printf("Patch jump at %04X:%u [dist=0x%04X]\n", jump->fjOffs, jump->fjSlot, dist);

        addr = genPEwriter->WPEsecAdrData(PE_SECT_text, jump->fjOffs);

        /* We expect all jumps we process here to be forward */

        assert(dist > 0 && unsigned32IntFitsInBits(dist, 20));

        /* Get hold of the instruction bundle contents */

        memcpy(&bundle, addr, sizeof(bundle));

        /* Insert the distance into the opcode */

//      { printf("Bundle1 ="); for (NatUns i = 0; i < 16; i++) printf(" %02X", bundle.bytes[i]); printf("\n"); }
        bitset128ins(&bundle, IA64insBitPos(jump->fjSlot) + 13, 20, dist);
//      { printf("Bundle2 ="); for (NatUns i = 0; i < 16; i++) printf(" %02X", bundle.bytes[i]); printf("\n"); }

        /* Put the updated instruction bundle back */

        memcpy(addr, &bundle, sizeof(bundle));
    }

    genCurCodeOffs = genPEwriter->WPEsecAddData(PE_SECT_text, NULL, 0);
}

/*****************************************************************************
 *
 *  Create the unwind table for the current function.
 */

static
BYTE    *           unwindEncodeValue(BYTE *dest, NatUns val)
{
    if      (val < 0x100)
    {
        *dest++ = (BYTE)  val;
    }
    else if (val < 0x4000)  // is this correct?
    {
        *dest++ = (BYTE)((val & 0x7F) | 0x80);
        *dest++ = (BYTE)( val >> 7);
    }
    else
    {
        UNIMPL("encode really huge value");
    }

    return  dest;
}

void                Compiler::genUnwindTable()
{
    __int32         pdat[3];                // used for .pdata entry
    BYTE            rdat[64];               // big enough for largest .rdata table
    BYTE    *       next;
    size_t          size;

    /* Let's make sure we're working with reasonable values */

    assert(genPrologSvPfs >=  0 && genPrologSvPfs <= 0xFF);
    assert(genPrologSvRP  >=  0 && genPrologSvRP  <= 0xFF);
    assert(genPrologSvGP  == -1 || genPrologSvGP  <= 0xFF); // optional
    assert(genPrologMstk  == -1 || genPrologMstk  <= 0xFF); // optional
    assert(genPrologEnd   >=  0 && genPrologEnd   <= 0xFF);

    /* Add an entry to .pdata describing our function */

    pdat[0] = CODE_BASE_RVA + genCurFuncOffs;
    pdat[1] = CODE_BASE_RVA + genCurCodeOffs;
    pdat[2] = genPEwriter->WPEsecNextOffs(PE_SECT_rdata);

    genPEwriter->WPEsecAddData (PE_SECT_pdata, (BYTE*)&pdat, sizeof(pdat));

    genPEwriter->WPEsecAddFixup(PE_SECT_pdata,
                                PE_SECT_rdata,
                                genPEwriter->WPEsecNextOffs(PE_SECT_pdata) - 4);

    /* Start the unwind table with the initial signature */

    static
    BYTE            unwindMagic[] = { 2,0, 0,0, 3,0,0,0 };

    memcpy(rdat, unwindMagic, sizeof(unwindMagic));
    next = rdat       +       sizeof(unwindMagic);

    /* Add the prolog size entry */

    *next++ = (BYTE)genPrologEnd;

    /* Add the "PFS save" entry */

    *next++ = 0xE6;
    *next++ = (BYTE)genPrologSvPfs;
    *next++ = 0xB1;
    *next++ = (BYTE)genPrologSrPfs;

    /* Add the "RP save" entry */

    *next++ = 0xE4;
    *next++ = (BYTE)genPrologSvRP;
    *next++ = 0xB0;
    *next++ = (BYTE)genPrologSrRP;

    /* Add the "mem stack" entry */

    *next++ = 0xE0;
    *next++ = (BYTE)genPrologMstk;

    size = compLclFrameSize / 16;

    if      (size < 0x100)
    {
        *next++ = (BYTE)size;
    }
    else if (size < 0x4000)
    {
        next = unwindEncodeValue(next, size);
    }
    else
    {
        UNIMPL("encode huge frame size in unwind table");
    }

    /* Add the "body size" entry [UNDONE: what about multiple exit points?!?!?!? */

    size = 3 * (emitIA64curCodeOffs() - genCurFuncOffs) / 16 - genPrologEnd;

    if      (size <= 31)
    {
        *next++ = 0x20 | (BYTE)size;
    }
    else
    {
        *next++ = 0x61;
         next   = unwindEncodeValue(next, size);
    }

    /* Add the "label state" entry */

    *next++ = 0x81;

    /* Add the "EH count 0" entry */

    *next++ = 0xC0;
    *next++ = 0x02;

    /* Pad the table to a multiple of 16 */

    size = next - rdat;

    while (size & 15)
    {
        *next++ = 0;
         size++;
    }

    /* Add the table to the .rdata section */

    genPEwriter->WPEsecAddData(PE_SECT_rdata, rdat, size);
}

/*****************************************************************************
 *
 *  We keep these at the end of the file for now - easier to find this way.
 */

static
unsigned __int64    encodeIA64ins(insPtr ins, NatUns slotNum);

static
void                encodeIA64moveLong(bitset128 *bundlePtr, insPtr ins);

static
void                genSchedPrep (NatUns lclVarCnt);

static
void                genSchedBlock(insBlk block);

/*****************************************************************************
 *
 *  Temps and variables have been assigned to registers, now it's finally time
 *  to issue the actual machine code.
 */

void                Compiler::genIssueCode()
{
    insBlk          block;
    IA64sched *     sched;

    genPrologSvPfs =
    genPrologSvRP  =
    genPrologSvGP  =
    genPrologMstk  =
    genPrologEnd   = -1;

    emitIA64init();

    if  (opts.compSchedCode)
    {
        sched = new IA64sched; assert(sched);
        sched->scInit(this, insBuildImax);
        sched->scPrepare();
    }

    for (block = insBlockList; block; block = block->igNext)
    {
        insPtr          ins[3];
        insPtr          src[3];
        IA64execUnits   ixu[3];
        NatUns          icnt;

#ifdef  DEBUG
        if  (dspCode) printf("\n\n" IBLK_DSP_FMT ":\n", CompiledFncCnt, block->igNum);
#endif

        /* Record the code offset of the block */

        block->igOffs = emitIA64curCodeOffs();

        if  (opts.compSchedCode)
        {
            sched->scBlock(block);
            continue;
        }

        /* Grab hold of up to  2 instructions */

        ins[0] =          genIssueNextIns( block->igList, &ixu[0], &src[0]); assert(ins[0]);
        ins[1] =          genIssueNextIns(ins[0]->idNext, &ixu[1], &src[1]);
        ins[2] = ins[1] ? genIssueNextIns(ins[1]->idNext, &ixu[2], &src[2]) : NULL;

        /* The following is a bit lazy but it probably don't matter */

        icnt   = 1 + (NatUns)(ins[1] != 0) + (NatUns)(ins[2] != 0);

        while (icnt)
        {
            NatUns          tempNum;
            BYTE          (*tempTab)[6];

            NatUns          bestIndex;
            NatUns          bestCount;
            NatUns          bestXUcnt;
            insPtr          bestIns[3];

            bitset128       bundle;

//          instruction     op;

#ifndef NDEBUG

            IA64execUnits   toss1;
            insPtr          toss2;

            if      (ins[2])
            {
                assert(icnt == 3 && ins[0] && ins[1] && genIssueNextIns(ins[0]->idNext, &toss1, &toss2) == ins[1]
                                                     && genIssueNextIns(ins[1]->idNext, &toss1, &toss2) == ins[2]);
            }
            else if (ins[1])
            {
                assert(icnt == 2 && ins[0]           && genIssueNextIns(ins[0]->idNext, &toss1, &toss2) == ins[1]
                                                     && genIssueNextIns(ins[1]->idNext, &toss1, &toss2) == NULL);
            }
            else
            {
                assert(icnt == 1 && ins[0]           && genIssueNextIns(ins[0]->idNext, &toss1, &toss2) == NULL);
            }
#endif

            /*
                Brute force approach: try each template and see which one
                consumes the most instructions.
             */

            bestCount = 0;

#ifdef  DEBUG

            if  (verbose||DISP_TEMPLATES)
            {
                printf("Look for best template for:");

                for (NatUns bcnt = 0; bcnt < icnt; bcnt++)
                    printf("%s", genXUname(ixu[bcnt]));

                printf("\n");
            }

#endif

            // UNDONE:  In "dumb" mode, consider the templates in an optimized
            //          order (i.e. from the most useful to the least useful),
            //          and stop when 2 instructions have been placed (since 3
            //          instructions can never be bundled in dumb mode anyway).

            for (tempNum = 0, tempTab = genTmplateTab;
                 tempNum < sizeof(genTmplateTab)/sizeof(genTmplateTab[0]);
                 tempNum++  , tempTab++)
            {
                BYTE    *       tmpl = *tempTab;

                insPtr          insx[3];

                NatUns          xcnt;
                NatUns          mcnt;
                NatUns          bcnt;

                /* Ignore useless templates */

                if  (*tmpl == XU_N)
                    continue;

                /* In dumb mode, ignore templates that don't end in a barrier */

                if  (!(tempNum & 1))
                    continue;

#ifdef  DEBUG
                if  (verbose||DISP_TEMPLATES) printf("  Template %02X:", tempNum);
#endif

                /* Try to pack as many instructions into the bundle as possible */

                for (bcnt = mcnt = xcnt = 0; bcnt < icnt; bcnt++)
                {
                    IA64execUnits   ix = ixu[bcnt]; assert(ix != XU_N);

                    /* Look for a matching entry in the template */

                    for (;;)
                    {
                        IA64execUnits   tx = (IA64execUnits)*tmpl++;

                        if  (tx != ix)
                        {
                            if  (ix != XU_A || (tx != XU_I &&
                                                tx != XU_M))
                            {
                                if  (tx == XU_N)
                                {
                                    assert(xcnt == 3);
                                    goto FIN_TMP;
                                }

                                if  (tx != XU_P)
                                {
                                    /* If we've reached "L", all hope is lost */

                                    if  (tx == XU_L)
                                    {
                                        /* Make sure we've seen at least as good */

                                        assert(bestCount >= mcnt);

                                        goto FIN_TMP;
                                    }

                                    insx[xcnt++] = scIA64nopGet(tx);
                                }

                                continue;
                            }
                        }

                        /* We have a match, count it in */

                        mcnt++;

                        /* Record the instruction we've bundled */

                        insx[xcnt++] = ins[bcnt];

#ifdef  DEBUG
                        if  (verbose||DISP_TEMPLATES) printf("%s", genXUname(tx));
#endif

                        /* For now simply skip until the next ILP barrier */

                        for (;;)
                        {
                            IA64execUnits   tx = (IA64execUnits)*tmpl;

                            switch (tx)
                            {
                            case XU_P:
                                tmpl++;
#ifdef  DEBUG
                                if  (verbose||DISP_TEMPLATES) printf("|");
#endif
                                break;

                            case XU_B:

                                /*
                                    Special case: simple unconditional branches
                                    can be parallelized with anything else.
                                 */

                                if  (bcnt < icnt - 1)
                                {
                                    if  (ins[bcnt+1]->idIns == INS_br)
                                        break;
                                }

                                // Fall through ...

                            default:

                                /* If we've reached "L", all hope is lost */

                                if  (tx == XU_L)
                                {
                                    /* Make sure we've seen at least as good */

                                    assert(bestCount >= mcnt);

                                    goto FIN_TMP;
                                }

                                tmpl++;

                                insx[xcnt++] = scIA64nopGet(tx);
                                continue;

                            case XU_N:
                                goto FIN_TMP;

                            }
                            break;
                        }
                        break;
                    }
                }

                while (xcnt < 3)
                {
                    insx[xcnt++] = scIA64nopGet(XU_M);
                }

            FIN_TMP:

#ifdef  DEBUG
                if  (verbose||DISP_TEMPLATES) printf("=%u\n", mcnt);
#endif

                /* Did we find a better match than the current best ? */

                if  (bestCount < mcnt)
                {
                     bestCount = mcnt;
                     bestXUcnt = xcnt;
                     bestIndex = tempNum;

                     memcpy(bestIns, insx, sizeof(bestIns));
                }
            }

#ifdef  DEBUG

            if  (dspCode)
            {
                NatUns          i;
                BYTE    *       t;

                printf("{ ;; template 0x%02X:\n", bestIndex);

                for (i = 0, t = genTmplateTab[bestIndex]; i < bestXUcnt; i++)
                {
                    IA64execUnits   x1;
                    IA64execUnits   x2;

                    x1 = (IA64execUnits)*t;
                    x2 = genInsXU(bestIns[i]->idIns);

                    printf("    [%s]:", genXUname(x1));

                    insDisp(bestIns[i], false, true);

                    if  (x1 != x2)
                    {
                        if  (x2 != XU_A || (x1 != XU_I &&
                                            x1 != XU_M))
                        {
                            printf("ERROR: expected XU_%s, found XU_%s\n", genXUname(x1),
                                                                           genXUname(x2));
                            t = NULL;
                            break;
                        }
                    }

                    do
                    {
                        t++;
                    }
                    while (*t == XU_P);
                }

                if  (t && *t != XU_N)
                {
                    printf("ERROR: template didn't end as expected [t+%u]=XU_%s)\n",
                        t - genTmplateTab[bestIndex],
                        genXUname((IA64execUnits)*t));
                }

                printf("}\n");
            }

#endif

            /* Make sure we've found a useable template */

            assert(bestCount);

            if  (debugInfo)
            {
                NatUns          offs = emitIA64curCodeOffs();

                if  (                  src[0]) genSrcLineAdd(src[0]->idSrcln.iLine, offs  );
                if  (bestCount >= 2 && src[1]) genSrcLineAdd(src[1]->idSrcln.iLine, offs+1);
                if  (bestCount >= 3 && src[2]) genSrcLineAdd(src[2]->idSrcln.iLine, offs+2);
            }

            /* Ready to rrrumble.... */

            bitset128clear(&bundle);
            bitset128ins  (&bundle,  0,  5, bestIndex);
            bitset128ins  (&bundle,  5, 41, encodeIA64ins(bestIns[0], 0));
            bitset128ins  (&bundle, 46, 41, encodeIA64ins(bestIns[1], 1));
            bitset128ins  (&bundle, 87, 41, encodeIA64ins(bestIns[2], 2));

#ifdef  DEBUG

            genInsCnt++;

            if  (!memcmp(ins2name(bestIns[0]->idIns), "nop.", 4)) genNopCnt++;
            if  (!memcmp(ins2name(bestIns[1]->idIns), "nop.", 4)) genNopCnt++;
            if  (!memcmp(ins2name(bestIns[2]->idIns), "nop.", 4)) genNopCnt++;

            /* Display the instruction bundle if desired */

            if  (dspEmit)
            {
                printf("Bundle =");

                for (NatUns i = 0; i < 16; i++)
                    printf(" %02X", bundle.bytes[i]);

                printf("\n");
            }

#endif

            /* Append the instruction bundle to the code section */

            emitIA64gen(bundle.bytes, sizeof(bundle.bytes));

            /* We've consumed one or more instructions, shift forward */

            switch (bestCount)
            {
            case 1:

                ins[0] = ins[1]; ixu[0] = ixu[1]; src[0] = src[1];
                ins[1] = ins[2]; ixu[1] = ixu[2]; src[1] = src[2];

                if  (ins[1])
                {
                    ins[2] = genIssueNextIns(ins[1]->idNext, &ixu[2], &src[2]);

                    if  (ins[2] == 0)
                        icnt = 2;
                }
                else
                {
                    icnt = ins[0] ? 1 : 0;
                }

                break;

            case 2:

                ins[0] = ins[2]; ixu[0] = ixu[2]; src[0] = src[2];

                if  (ins[0])
                {
                    ins[1] = genIssueNextIns(ins[0]->idNext, &ixu[1], &src[1]);

                    if  (ins[1])
                    {
                        ins[2] = genIssueNextIns(ins[1]->idNext, &ixu[2], &src[2]);

                        if  (ins[2] == 0)
                            icnt = 2;
                    }
                    else
                    {
                        icnt = 1;
#ifdef  DEBUG
                        ins[1] = ins[2] = NULL;
#endif
                    }
                }
                else
                {
                    icnt = 0;
#ifdef  DEBUG
                    ins[1] = ins[2] = NULL;
#endif
                }

                break;

            default:
                UNIMPL("shift by 3 instructions - wow, this really happened?");
            }
        }

    NXT_BLK:;

    }

#ifdef  DEBUG

    if  (dspCode||1)
    {
        printf("// A total of %u bundles (%u instructions) issued", genInsCnt, 3*genInsCnt);
        if  (genNopCnt)
            printf(" (%3u / %2u%% slots wasted)", genNopCnt, 100*genNopCnt/(3*genInsCnt));
        printf("\n");

        genAllInsCnt += 3*genInsCnt;
        genNopInsCnt += genNopCnt;
    }

#endif

    emitIA64done();

    /* Do we need to generate a stack unwind table ? */

    if  (genNonLeafFunc)
        genUnwindTable();
}

inline
void                encodeIA64moveLong(bitset128 *bundlePtr, insPtr ins)
{
    __int64         cval = insOpCns64(ins->idOp.iOp2);

    bitset128ins(bundlePtr, 46, 41, cval >> 22);
    bitset128ins(bundlePtr, 87, 41, encodeIA64ins(ins, 2));

    return;
}

/*****************************************************************************
 *
 *  The scheduler has collected an instruction group, now emit it.
 */

void                IA64sched::scIssueBunch()
{
    scIssueDsc  *   nxtIns;
    NatUns          bndNum;
    NatUns          bndCnt;

    assert((scIssueCnt % 3) == 0);
    assert((scIssueTcc * 3) == scIssueCnt);

    for (bndCnt = scIssueTcc, bndNum = 0, nxtIns = scIssueTab;
         bndCnt;
         bndCnt--           , bndNum++)
    {
        bitset128       bundle;

        NatUns          tmpl = scIssueTmp[bndNum] - 1;
        insPtr          ins0 = (*nxtIns++).iidIns;
        insPtr          ins1 = (*nxtIns++).iidIns;
        insPtr          ins2 = (*nxtIns++).iidIns;

        assert(scIssueSwp[bndNum] == 0 || scIssueSwp[bndNum] == 1);

        if  (scIssueSwp[bndNum])
        {
            insPtr          temp;

            temp = ins1;
                   ins1 = ins2;
                          ins2 = temp;
        }

        /* If this is the last bundle, change the template number */

        if  (bndCnt == 1)
            tmpl++;

#ifdef  DEBUG

        insPtr          ins[3] = { ins0, ins1, ins2 };

        BYTE    *       tab = genTmplateTab[tmpl];
        NatUns          cnt;

        if  (dspCode)
        {
//          printf("// Template 0x%02X%s ", tmpl, scIssueSwp[bndNum] ? " [swap]" : "");
            printf("\n{  .");

            insDispTemplatePtr = tab;
        }

        for (cnt = 0;;)
        {
            IA64execUnits   xi;
            IA64execUnits   xu = (IA64execUnits)*tab++;

            if  (xu == XU_N)
                break;

            if  (xu == XU_P)
            {
//              if  (dspCode)
//                  printf("|");

                continue;
            }

            assert(cnt < 3 && "template didn't end on time ???");

            if  (dspCode)
                printf("%s", genXUname(xu));

            xi = genInsXU(ins[cnt]->idIns);

            if  (xu != xi)
            {
                if  (xi != XU_A || (xu != XU_M && xu != XU_I))
                    printf(" [ERROR: '%s' ins !!!]", genXUname(xi));
            }

            cnt++;

            if  (dspCode && xu == XU_L)
                printf("I");
        }

        assert((cnt == 3 || ins2 == NULL) && "unexpected template end");

        if  (dspCode)
            printf("\n");

#endif

        assert(ins1 != NULL && ins1->idIns != INS_alloc);
        assert(ins2 == NULL || ins2->idIns != INS_alloc);

        bitset128clear(&bundle);
        bitset128ins  (&bundle,  0,  5, tmpl);
        bitset128ins  (&bundle,  5, 41, encodeIA64ins(ins0, 0));
        if  (ins2 == NULL)
        {
            encodeIA64moveLong(&bundle, ins1);
            goto EENC;
        }
        bitset128ins  (&bundle, 46, 41, encodeIA64ins(ins1, 1));
        bitset128ins  (&bundle, 87, 41, encodeIA64ins(ins2, 2));

    EENC:

#ifdef  DEBUG

        insDispTemplatePtr = NULL;

        genInsCnt++;

        NatUns nops = genNopCnt;
        if  (        !memcmp(ins2name(ins0->idIns), "nop.", 4)) genNopCnt++;
        if  (        !memcmp(ins2name(ins1->idIns), "nop.", 4)) genNopCnt++;
        if  (ins2 && !memcmp(ins2name(ins2->idIns), "nop.", 4)) genNopCnt++;
        assert(nops + 3 != genNopCnt && "we're not making any progress, just adding nop's!");

        if  (dspCode)
            printf("}\n");

        /* Display the instruction bundle if desired */

        if  (dspEmit)
        {
            printf("\n//           ");

            for (NatUns i = 0; i < 16; i++)
                printf(" %02X", bundle.bytes[i]);

            printf("\n");
        }

#endif

        /* Append the instruction bundle to the code section */

        emitIA64gen(bundle.bytes, sizeof(bundle.bytes));
    }
}

/*****************************************************************************
 *
 *  Patch a call opcode that references an import through a GP-relative ref.
 */

void                Compiler::genPatchGPref(BYTE * addr, NatUns slot)
{
    NatUns          bpos1;
    NatUns          bpos2;

    NatUns          temp;
    NatUns          offs;

    bitset128   *   bundle = (bitset128*)addr;

    assert(slot < 3 && !((int)addr & 0xF));

    /* Figure out the bit positions of the two parts of the operand */

    bpos1 = IA64insBitPos(slot) + 13;
    bpos2 = bpos1 + 27          - 13;

    /* Extract the import cookie from the opcode */

    temp  = (NatUns)bitset128xtr(bundle, bpos1, 7) |
            (NatUns)bitset128xtr(bundle, bpos2, 6);

    /* Convert the import cookie to its IAT offset */

    offs = genPEwriter->WPEimportAddr(temp);

//  printf("Import index = %u, IAT offs = %04X\n", (int)temp, (int)offs);

    /* Patch the IAT offset in the opcode */

    bitset128ins(bundle, bpos1, 7, (offs & formBitMask(0,7))     ); // imm7b
    bitset128ins(bundle, bpos2, 6, (offs & formBitMask(7,6)) >> 7); // imm6d
}

/*****************************************************************************
 *
 *  Encode the given IA64 instruction and return the 41-bit machine code value.
 */

static
_uint64             encodeIA64ins(insPtr ins, NatUns slotNum)
{
    _uint64         opcode;

    instruction     instr  = ins->idInsGet();
    NatUns          encodx = genInsEncIdx(instr);

//  printf("Encode: "); insDisp(ins, false, true);

    switch (genInsXU((instruction)ins->idIns))
    {
        NatUns          temp;
        NatInt          ival;

        NatUns          prr1;
        NatUns          prr2;

        regNumber       reg1;
        regNumber       reg2;
        regNumber       reg3;
        regNumber       reg4;

    case XU_A:
        switch (encodx)
        {
            insPtr          ins2;

        case 1:

            assert(instr == INS_add_reg_reg ||
                   instr == INS_sub_reg_reg ||
                   instr == INS_and_reg_reg ||
                   instr == INS_ior_reg_reg ||
                   instr == INS_xor_reg_reg ||
                   instr == INS_mov_reg);

            // ISSUE: use "adds dest=0,reg1" instead of "add dest=r0,reg1" ? */

            reg2 = (instr == INS_mov_reg) ? REG_r000
                                          : insOpReg(ins->idOp.iOp1);

            reg1 = insOpDest(ins);

            /* Special case: register where GP is saved */

            ins2 = ins->idOp.iOp2; assert(ins2);

            if  (ins2->idIns == INS_PHYSREG && (ins2->idFlags & IF_REG_GPSAVE))
                reg3 = genPrologSrGP;
            else
                reg3 = insOpReg(ins2);

            opcode  = (_uint64)(8                       ) <<     37;// opcode

            opcode |=          (reg1                    ) <<      6;// dest reg
            opcode |=          (reg2                    ) <<     13;// src  reg1
            opcode |=          (reg3                    ) <<     20;// src  reg2

            switch (instr)
            {
            case INS_mov_reg:
            case INS_add_reg_reg:
                break;

            case INS_sub_reg_reg:
                opcode |= (1 << 29) | (1 << 27);                    // x4 and x2b
                break;

            case INS_and_reg_reg:
                opcode |= (3 << 29) | (0 << 27);                    // x4 and x2b
                break;

            case INS_ior_reg_reg:
                opcode |= (3 << 29) | (2 << 27);                    // x4 and x2b
                break;

            case INS_xor_reg_reg:
                opcode |= (3 << 29) | (3 << 27);                    // x4 and x2b
                break;

            default:
                UNIMPL("unexpected opcode");
            }

            break;

        case 2:

            assert(instr == INS_shladd);

            reg1 = insIntRegNum(insOpDest (ins));
            reg2 = insIntRegNum(insOpReg  (ins->idOp3.iOp1));
            temp =              insOpCns32(ins->idOp3.iOp2);
            reg3 = insIntRegNum(insOpReg  (ins->idOp3.iOp3));

            /* Start the encoding with the opcode */

            opcode  = (_uint64)(8                       ) <<     37;// opcode

            /* Insert the "x4" bit */

            opcode |= (_uint64)(4                       ) <<     29;// "x4" extension

            /* Insert the register operands and the shift count */

            opcode |=          (reg1                    ) <<      6;// dst  reg
            opcode |=          (reg2                    ) <<     13;// src  reg1
            opcode |=          (reg3                    ) <<     20;// src  reg2
            opcode |=          (temp - 1                ) <<     27;// shift count
            break;

        case 3:

            assert(instr == INS_and_reg_imm ||
                   instr == INS_ior_reg_imm ||
                   instr == INS_xor_reg_imm);

            reg1 = insOpDest (ins);
            reg2 = insOpReg  (ins->idOp.iOp1);
            temp = insOpCns32(ins->idOp.iOp2); assert(signed64IntFitsInBits((int)temp,  8));

            opcode  = (_uint64)(8                       ) <<     37;// opcode

            opcode |=          (reg1                    ) <<      6;// dest reg
            opcode |=          (reg2                    ) <<     20;// src  reg

            opcode |=          (temp & formBitMask( 0,7)) <<(13- 0);// imm7b
            opcode |=          (temp & formBitMask( 8,1)) <<(36- 8);// sign

            opcode |= (0xB << 29);                                  // x4

            switch (instr)
            {
            case INS_and_reg_imm:
                opcode |= (0 << 27);                                // x2b
                break;

            case INS_ior_reg_imm:
                opcode |= (2 << 27);                                // x2b
                break;

            case INS_xor_reg_imm:
                opcode |= (3 << 27);                                // x2b
                break;

            default:
                UNIMPL("unexpected opcode");
            }
            break;

        case 4:

            assert(instr == INS_add_reg_i14);

            reg1 = insOpDest (ins);
            reg2 = insOpReg  (ins->idOp.iOp1);

            ins2 = ins->idOp.iOp2; assert(ins2);

            if  (ins2->idIns == INS_GLOBVAR)
            {
                if  (ins2->idFlags & IF_GLB_IMPORT)
                {
                    /* The "true" offset won't be known until the very end */

                    temp = genPEwriter->WPEimportRef(ins2->idGlob.iImport,
                                                     emitIA64curCodeOffs(),
                                                     slotNum);
                }
                else if (ins2->idFlags & IF_GLB_SWTTAB)
                {
                    temp = 0; printf("UNDONE: fill in jump table distance\n");
                }
                else
                    temp = ins2->idGlob.iOffs;
            }
            else
                temp = insOpCns32(ins2);

            assert((NatInt)temp > -0x4000 &&
                   (NatInt)temp < +0x4000);

            opcode  = (_uint64)(8                       ) <<     37;// opcode

            opcode |=          (reg1                    ) <<      6;// dest reg
            opcode |=          (reg2                    ) <<     20;// src  reg

            opcode |=          (temp & formBitMask( 0,7)) <<(13- 0);// imm7b
            opcode |=          (temp & formBitMask( 7,6)) <<(27- 7);// imm6d
            opcode |=          (temp & formBitMask(13,1)) <<(36-13);// sign

            opcode |= (_uint64)(2                       ) <<     34;// extension
            break;

        case 5:

            assert(instr == INS_mov_reg_i22);

            reg1 = insOpDest (ins);
            temp = insOpCns32(ins->idOp.iOp2);

            opcode  = (_uint64)(9                       ) <<     37;// opcode

            // note: we assume that source register is 0

            opcode |=          (reg1                    ) <<      6;// dest reg
            opcode |=          (temp & formBitMask( 0,7)) <<(13- 0);// imm7b
            opcode |= (_uint64)(temp & formBitMask( 7,9)) <<(27- 7);// imm9d
            opcode |=          (temp & formBitMask(16,5)) <<(22-16);// imm5c
            opcode |=          (temp & formBitMask(22,1)) <<(36-22);// sign
            break;

        case 6:

            /* This is a reg-reg compare */

            temp = genInsEncVal(instr);

            prr1 = ins->idComp.iPredT;
            prr2 = ins->idComp.iPredF;

            reg2 = insOpReg(ins->idComp.iCmp1);
            reg3 = insOpReg(ins->idComp.iCmp2);

            /* Do we need to swap the register operands? */

            if  (temp & 0x1000)
            {
                regNumber       regt;

                regt = reg2;
                       reg2 = reg3;
                              reg3 = regt;
            }

            /* Do we need to swap the target predicate operands? */

            if  (temp & 0x2000)
            {
                NatUns          prrt;

                prrt = prr1;
                       prr1 = prr2;
                              prr2 = prrt;
            }

            /* We don't expect immediate operands here */

            assert((temp & 0x4000) == 0);

            /* Make sure the expected opcode is present */

            assert((temp & 0x00F0) == 0xC0 ||
                   (temp & 0x00F0) == 0xD0 ||
                   (temp & 0x00F0) == 0xE0);

            /* Start the encoding with the opcode + ta/tb/x2 bits */

            opcode  = (_uint64)(temp & 0x00FF           ) <<     33;// opcode + bits

            /* Insert the "c" (extension) bit */

            opcode |=          (temp & formBitMask( 9,1)) <<(12- 9);// "c"

            /* Insert the source regs and destination predicate regs */

            opcode |=          (reg2                    ) <<     13;// reg2
            opcode |=          (reg3                    ) <<     20;// reg3

            opcode |=          (prr1                    ) <<      6;// p1
            opcode |=          (prr2                    ) <<     27;// p2

//          printf("compare r%u,r%u -> p%u,p%u [encodeVal=0x%04X]\n", reg2, reg3, prr1, prr2, temp);

            break;

        case 8:

            /* Compare register and immediate value */

            temp = genInsEncVal(instr);

            prr1 = ins->idComp.iPredT;
            prr2 = ins->idComp.iPredF;

            ival = insOpCns32(ins->idComp.iCmp1);
            reg3 = insOpReg  (ins->idComp.iCmp2);

            /* We can't swap the register with the constant */

            assert((temp & 0x1000) == 0);

            /* Do we need to swap the target predicate operands? */

            if  (temp & 0x2000)
            {
                NatUns          prrt;

                prrt = prr1;
                       prr1 = prr2;
                              prr2 = prrt;
            }

            /* Do we need to decrement the immediate value? */

            if  (temp & 0x4000)
                ival--;

//          printf("compare #%d,r%u -> p%u,p%u [encodeVal=0x%04X]\n", ival, reg3, prr1, prr2, temp);

            /* Make sure the expected opcode is present */

            assert((temp & 0x00F0) == 0xC0 ||
                   (temp & 0x00F0) == 0xD0 ||
                   (temp & 0x00F0) == 0xE0);

            /* Start the encoding with the opcode + ta/tb/x2 bits */

            opcode  = (_uint64)(temp & 0x00FF           ) <<     33;// opcode + bits

            /* Insert the "c" (extension) bit */

            opcode |=          (temp & formBitMask( 9,1)) <<(12- 9);// "c"

            /* Insert the source reg + constant and destination predicate regs */

            opcode |=          (reg3                    ) <<     20;// reg3

            opcode |=          (ival & formBitMask( 0,7)) <<(13- 0);// imm7b
            opcode |=          (ival & formBitMask( 8,1)) <<(36- 8);// sign

            opcode |=          (prr1                    ) <<      6;// p1
            opcode |=          (prr2                    ) <<     27;// p2

            break;

        default:
            goto NO_ENC;
        }
        break;

    case XU_M:
        switch (encodx)
        {
            NatUns          sof;
            NatUns          sol;

        case 1:

            assert(instr == INS_ld1_ind ||
                   instr == INS_ld2_ind ||
                   instr == INS_ld4_ind ||
                   instr == INS_ld8_ind);

            assert(INS_ld1_ind + 0 == INS_ld1_ind);
            assert(INS_ld1_ind + 1 == INS_ld2_ind);
            assert(INS_ld1_ind + 2 == INS_ld4_ind);
            assert(INS_ld1_ind + 3 == INS_ld8_ind);

            reg1 = insOpDest(ins);
            reg3 = insOpReg (ins->idOp.iOp1);

            opcode  = (_uint64)(4                       ) <<     37;// opcode

            opcode |=          (reg1                    ) <<      6;// reg1
            opcode |=          (reg3                    ) <<     20;// reg3
            opcode |= (_uint64)(instr - INS_ld1_ind     ) <<     30;// extension

            if  (ins->idFlags & IF_LDIND_NTA)
                opcode |= 3 << 28;                                  // ldhint=nta
            break;

        case 3:

            assert(instr == INS_ld1_ind_imm ||
                   instr == INS_ld2_ind_imm ||
                   instr == INS_ld4_ind_imm ||
                   instr == INS_ld8_ind_imm);

            assert(INS_ld1_ind_imm + 0 == INS_ld1_ind_imm);
            assert(INS_ld1_ind_imm + 1 == INS_ld2_ind_imm);
            assert(INS_ld1_ind_imm + 2 == INS_ld4_ind_imm);
            assert(INS_ld1_ind_imm + 3 == INS_ld8_ind_imm);

            reg1 = insOpDest (ins);
            reg3 = insOpReg  (ins->idOp.iOp1);
            ival = insOpCns32(ins->idOp.iOp2); assert((NatUns)ival < 128);

            opcode  = (_uint64)(5                       ) <<     37;// opcode

            opcode |=          (reg1                    ) <<      6;// reg1
            opcode |=          (ival                    ) <<     13;// imm7b
            opcode |=          (reg3                    ) <<     20;// reg3
            opcode |= (_uint64)(instr - INS_ld1_ind_imm ) <<     30;// extension
            break;

        case 4:

            assert(instr == INS_st1_ind ||
                   instr == INS_st2_ind ||
                   instr == INS_st4_ind ||
                   instr == INS_st8_ind);

            assert(INS_st1_ind + 0 == INS_st1_ind);
            assert(INS_st1_ind + 1 == INS_st2_ind);
            assert(INS_st1_ind + 2 == INS_st4_ind);
            assert(INS_st1_ind + 3 == INS_st8_ind);

            temp = instr - INS_st1_ind + 0x30;

            reg3 = insOpReg (ins->idOp.iOp1);
            reg2 = insOpReg (ins->idOp.iOp2);

            opcode  = (_uint64)(4                       ) <<     37;// opcode

            opcode |=          (reg2                    ) <<     13;// reg2
            opcode |=          (reg3                    ) <<     20;// reg3
            opcode |= (_uint64)(temp                    ) <<     30;// extension
            break;

        case 5:

            assert(instr == INS_st1_ind_imm ||
                   instr == INS_st2_ind_imm ||
                   instr == INS_st4_ind_imm ||
                   instr == INS_st8_ind_imm);

            assert(INS_st1_ind_imm + 0 == INS_st1_ind_imm);
            assert(INS_st1_ind_imm + 1 == INS_st2_ind_imm);
            assert(INS_st1_ind_imm + 2 == INS_st4_ind_imm);
            assert(INS_st1_ind_imm + 3 == INS_st8_ind_imm);

            reg1 = insOpReg  (ins->idOp.iOp1);
            reg3 = insOpDest (ins);
            ival = insOpCns32(ins->idOp.iOp2); assert((NatUns)ival < 128);

            opcode  = (_uint64)(5                       ) <<     37;// opcode

//          0ac02402380  M            st1  [r36] = gp, 0x0e
//          0ac0241c040  M            st1  [r36] = r14, 0x1

            opcode |=          (ival                    ) <<      6;// imm7a
            opcode |=          (reg1                    ) <<     13;// reg1
            opcode |=          (reg3                    ) <<     20;// reg3
            opcode |= (_uint64)(instr-INS_st1_ind_imm+0x30) <<   30;// extension
            break;

        case 6:

            assert(instr == INS_ldf_s ||
                   instr == INS_ldf_d);

            reg1 = insFltRegNum(insOpDest(ins));
            reg2 =              insOpReg (ins->idOp.iOp1);

            temp = (instr == INS_ldf_s) ? 0x02 : 0x03;

            opcode  = (_uint64)(6                       ) <<     37;// opcode

            opcode |=          (reg1                    ) <<      6;// reg1
            opcode |=          (reg2                    ) <<     20;// reg2
            opcode |= (_uint64)(temp                    ) <<     30;// extension
            break;

        case 9:

            assert(instr == INS_stf_s ||
                   instr == INS_stf_d);

            reg1 =              insOpReg (ins->idOp.iOp1);
            reg2 = insFltRegNum(insOpReg (ins->idOp.iOp2));

            temp = (instr == INS_stf_s) ? 0x32 : 0x33;

            opcode  = (_uint64)(6                       ) <<     37;// opcode

            opcode |=          (reg2                    ) <<     13;// reg2
            opcode |=          (reg1                    ) <<     20;// reg1
            opcode |= (_uint64)(temp                    ) <<     30;// extension
            break;

        case 19:

            reg1 = insOpDest (ins);
            reg2 = insOpReg(ins->idOp.iOp1);

            if  (genInsFU(instr) == FU_TOFR)
            {
                assert(instr == INS_setf_s   ||
                       instr == INS_setf_d   ||
                       instr == INS_setf_sig ||
                       instr == INS_setf_exp);

                assert(reg2 >= REG_INT_FIRST && reg2 <= REG_INT_LAST);

                reg1 = insFltRegNum(reg1);
            }
            else
            {
                assert(genInsFU(instr) == FU_FRFR);

                assert(instr == INS_getf_s   ||
                       instr == INS_getf_d   ||
                       instr == INS_getf_sig ||
                       instr == INS_getf_exp);

                assert(reg1 >= REG_INT_FIRST && reg1 <= REG_INT_LAST);

                reg2 = insFltRegNum(reg2);
            }

            temp = genInsEncVal(instr);

            assert(temp >= 0x1C && temp <= 0x1F);

            if  (genInsFU(instr) == FU_FRFR)
                opcode  = (_uint64)(4                   ) <<     37;// opcode
            else
                opcode  = (_uint64)(6                   ) <<     37;// opcode

            opcode |=          (1                       ) <<     27;// "x"
            opcode |= (_uint64)(temp                    ) <<     30;// "x6"

            opcode |=          (reg1                    ) <<      6;// reg1
            opcode |=          (reg2                    ) <<     13;// reg2
            break;

        case 34:

            sof = ins->idProlog.iInp + ins->idProlog.iLcl + ins->idProlog.iOut;
            sol = ins->idProlog.iInp + ins->idProlog.iLcl;

            opcode  = (_uint64)(1                       ) << 37;    // opcode

            opcode |=          (ins->idReg              ) <<  6;    // dest reg
            opcode |=          (sof                     ) << 13;    // sof
            opcode |=          (sol                     ) << 20;    // sol
            opcode |= (_uint64)(6                       ) << 33;    // extension
            break;

        case 37:
            assert(instr == INS_nop_m);

            opcode  =          (1                       ) << 27;    // opcode
            break;

        default:
            goto NO_ENC;
        }
        break;

    case XU_I:
        switch (encodx)
        {
        case 5:

            assert(instr == INS_shr_reg_reg ||
                   instr == INS_sar_reg_reg);

            reg1 = insIntRegNum(insOpDest(ins));
            reg2 = insIntRegNum(insOpReg (ins->idOp.iOp1));
            reg3 = insIntRegNum(insOpReg (ins->idOp.iOp2));

            opcode  = (_uint64)(7                       ) <<     37;// opcode

            opcode |= (_uint64)(1                       ) <<     36;// "za"
            opcode |= (_uint64)(1                       ) <<     33;// "zb"

            if  (instr == INS_shr_reg_reg)
                opcode |= (_uint64)(2                   ) <<     28;// "x2b"

            opcode |=          (reg1                    ) <<      6;// dst  reg
            opcode |=          (reg2                    ) <<     13;// src  reg1
            opcode |=          (reg3                    ) <<     20;// src  reg2

            break;

        case 7:

            assert(instr == INS_shl_reg_reg);

            reg1 = insIntRegNum(insOpDest(ins));
            reg2 = insIntRegNum(insOpReg (ins->idOp.iOp1));
            reg3 = insIntRegNum(insOpReg (ins->idOp.iOp2));

            opcode  = (_uint64)(7                       ) <<     37;// opcode

            opcode |= (_uint64)(1                       ) <<     36;// "za"
            opcode |= (_uint64)(1                       ) <<     33;// "zb"
            opcode |= (_uint64)(1                       ) <<     30;// "x2c"

            opcode |=          (reg1                    ) <<      6;// dst  reg
            opcode |=          (reg2                    ) <<     13;// src  reg1
            opcode |=          (reg3                    ) <<     20;// src  reg2

            break;

        case 11:

            if  (instr == INS_shr_reg_imm || instr == INS_sar_reg_imm)
            {
                reg1 = insIntRegNum(insOpDest (ins));
                reg3 = insIntRegNum(insOpReg  (ins->idOp.iOp1));
                ival =              insOpCns32(ins->idOp.iOp2);

                assert(ival && (NatUns)ival <= 64);

                temp = 64 - ival;

                instr = (instr == INS_shr_reg_imm) ? INS_extr_u : INS_extr;
            }
            else
            {
                UNIMPL("what - someone actually generated an extr?");
            }

            opcode  = (_uint64)(5                       ) <<     37;// opcode
            opcode |= (_uint64)(1                       ) <<     34;// x2

            opcode |=          (reg1                    ) <<      6;// dest reg
            opcode |=          (reg3                    ) <<     20;// src  reg

            opcode |=          (ival                    ) <<     14;// pos6
            opcode |=          (temp                    ) <<     27;// len6

            if  (instr == INS_extr)
                opcode |=      (1                       ) <<     13;// "y"

            break;

        case 12:

            assert(instr == INS_shl_reg_imm);           // turns into dep.z

            reg1 = insIntRegNum(insOpDest (ins));
            reg2 = insIntRegNum(insOpReg  (ins->idOp.iOp1));
            ival =              insOpCns32(ins->idOp.iOp2);

            assert(ival && (NatUns)ival <= 64);

            temp = 64 - ival;

            opcode  = (_uint64)(5                       ) <<     37;// opcode
            opcode |= (_uint64)(1                       ) <<     34;// x2
            opcode |= (_uint64)(1                       ) <<     33;// x

            opcode |=          (reg1                    ) <<      6;// dest reg
            opcode |=          (reg2                    ) <<     13;// src  reg

            opcode |=          (ival                    ) <<     20;// pos6
            opcode |=          (temp                    ) <<     27;// len6

            break;

        case 19:
            assert(instr == INS_nop_i);

            opcode  =          (1                       ) <<     27;// opcode
            break;

        case 21:
            assert(instr == INS_mov_brr_reg);

            reg2 = insOpReg  (ins->idOp.iOp2);
            ival = insOpCns32(ins->idRes); assert((NatUns)ival < 8);

            opcode  = (_uint64)(0x07                    ) <<     33;// extension
            opcode |=          (ival                    ) <<      6;// br1
            opcode |=          (reg2                    ) <<     13;// reg2
            opcode |=          (1                       ) <<     20;// ISSUE: WHY?????????
            break;

        case 22:
            assert(instr == INS_mov_reg_brr);

            reg1 = insOpReg  (ins->idRes);
            ival = insOpCns32(ins->idOp.iOp2); assert((NatUns)ival < 8);

            opcode  = (_uint64)(0x31                    ) <<     27;// extension
            opcode |=          (reg1                    ) <<      6;// reg1
            opcode |=          (ival                    ) <<     13;// br2
            break;

        case 25:

            assert(instr == INS_mov_reg_ip);

            reg1 = insOpReg  (ins->idRes);

            opcode  = (_uint64)(0x30                    ) <<     27;// x6
            opcode |=          (reg1                    ) <<      6;// reg1

            /* Is this instruction part of a switch statement table-jump ? */

            if  (ins->idMovIP.iStmt)
            {
                BasicBlock  *       swt = (BasicBlock*)ins->idMovIP.iStmt;

                assert(swt->bbJumpKind == BBJ_SWITCH);

                /* Record the current code offset for later processing */

//              printf("mov reg=ip is at code offset %04X\n", genCurCodeOffs);

                swt->bbJumpSwt->bbsIPmOffs = genCurCodeOffs;
            }
            break;

        case 26:
            assert(instr == INS_mov_arr_reg);

            reg2 = insOpReg  (ins->idOp.iOp2);
            ival = insOpCns32(ins->idRes); assert((NatUns)ival < 128);

            opcode  = (_uint64)(0x2A                    ) <<     27;// extension
            opcode |=          (reg2                    ) <<     13;// reg2
            opcode |=          (ival                    ) <<     20;// ar3
            break;

        case 27:
            assert(instr == INS_mov_arr_imm);

            temp = insOpCns32(ins->idRes); assert(temp < 128);
            ival = insOpCns32(ins->idOp.iOp2);

            opcode  = (_uint64)(0x0A                    ) <<     27;// extension
            opcode |=          (ival & formBitMask( 0,7)) <<(13- 0);// imm7b
            opcode |=          (ival & formBitMask( 8,1)) <<(36- 8);// sign
            opcode |=          (temp                    ) <<     20;// ar3
            break;

        case 28:
            assert(instr == INS_mov_reg_arr);

            reg1 = insOpReg  (ins->idRes);
            ival = insOpCns32(ins->idOp.iOp2); assert((NatUns)ival < 128);

            opcode  = (_uint64)(0x32                    ) <<     27;// extension
            opcode |=          (reg1                    ) <<      6;// reg1
            opcode |=          (ival                    ) <<     20;// ar3
            break;

        case 29:

            assert(instr == INS_sxt1 || instr == INS_sxt2 || instr == INS_sxt4 ||
                   instr == INS_zxt1 || instr == INS_zxt2 || instr == INS_zxt4);

            reg1 = insIntRegNum(insOpDest(ins));
            reg3 = insIntRegNum(insOpReg (ins->idOp.iOp2));

            assert(INS_zxt1 - INS_zxt1 == 0);
            assert(INS_zxt2 - INS_zxt1 == 1);
            assert(INS_zxt4 - INS_zxt1 == 2);
            assert(INS_sxt1 - INS_zxt1 == 3);
            assert(INS_sxt2 - INS_zxt1 == 4);
            assert(INS_sxt4 - INS_zxt1 == 5);

            temp = instr - INS_zxt1;

            if  (instr >= INS_sxt1)
                temp++;

            opcode  = (_uint64)(temp + 0x10             ) <<     27;// extension
            opcode |=          (reg1                    ) <<      6;// reg1
            opcode |=          (reg3                    ) <<     20;// reg3
            break;

        default:
            goto NO_ENC;
        }
        break;

    case XU_B:
        switch (encodx)
        {
            const   char *  name;
            NatUns          offs;

        case 1:

            /* This is an IP-relative branch (conditional/unconditional) */

            assert((instr == INS_br      && ins->idPred == 0) ||
                   (instr == INS_br_cond && ins->idPred != 0));

            opcode  = (_uint64)(4                       ) << 37;    // opcode
            opcode |=          (1                       ) << 12;    // ph=many
            opcode |=          (1                       ) << 33;    // wh=spnt

            opcode  = emitIA64jump(slotNum, ins->idJump.iDest, opcode);
            break;

        case 2:

            /* This is a counted loop jump */

            assert(instr == INS_br_cloop);

            opcode  = (_uint64)(4                       ) << 37;    // opcode
            opcode |=          (5                       ) <<  6;    // btype
            opcode |=          (1                       ) << 12;    // ph=many
            opcode |=          (1                       ) << 33;    // wh=spnt

            opcode  = emitIA64jump(slotNum, ins->idJump.iDest, opcode);
            break;

        case 3:

            /* This is an IP-relative call */

            assert(instr == INS_br_call_IP);

            opcode  = (_uint64)(5                       ) << 37;    // opcode
//          opcode |=          (0                       ) << 12;    // ph=few
//          opcode |= (_uint64)(0                       ) << 33;    // wh=sptk

            // Terrible hack: look for a matching previously compiled method

#ifdef  DEBUG
            if  ((int)ins->idCall.iMethHnd < 0 && -(int)ins->idCall.iMethHnd <= CPX_HIGHEST)
                name = TheCompiler->eeHelperMethodName(-(int)ins->idCall.iMethHnd);
            else
//              name = genFullMethodName(TheCompiler->eeGetMethodFullName(ins->idCall.iMethHnd));
                name =                   TheCompiler->eeGetMethodFullName(ins->idCall.iMethHnd);
#else
            name = "<unknown>";
#endif

//          printf("Call to function at slot #%u: %s\n", slotNum, name);

            if  (!genFindFunctionBody(name, &offs))
            {
                printf("// DANGER: call to external/undefined function '%s'\n", name);
            }
            else
            {
                NatInt          dist = (offs - emitIA64curCodeOffs())/16;

                /* Insert the relative distance into the opcode */

//              printf("target offs = %08X\n", offs);
//              printf("source offs = %08X\n", emitIA64curCodeOffs());
//              printf("distance    = %08X\n", dist);

                opcode |=          (dist & formBitMask( 0,20)) <<      13;  // imm20b
                opcode |= (_uint64)(dist & formBitMask(20, 1)) << (36-20);  // sign
            }

            emitIA64call(slotNum, ins);
            break;

        case 4:

            assert(instr == INS_br_ret || instr == INS_br_cond_BR);

            if  (instr == INS_br_ret)
            {
                // assume branch reg is b0, "p" hint is "few", "wh" hint is "sptk"

                opcode =          0x04 <<  6 |                      // btype
                         (_uint64)0x21 << 27;                       // x6
            }
            else
            {
                opcode = (_uint64)0x20 << 27 |                      // x6
                         ins->idIjmp.iBrReg << 13;                  // br2
            }

            break;

        case 5:

            assert(instr == INS_br_call_BR);

            assert(genExtFuncCall);

            // assume return reg is b0, "p" hint is "few", "wh" hint is "sptk"

            opcode  = (_uint64)(1                       ) <<     37;// opcode
            opcode |=          (ins->idCall.iBrReg      ) <<     13;// br2

//          opcode |=          (0                       ) << 12;    // ph=few
//          opcode |= (_uint64)(0                       ) << 33;    // wh=sptk

            break;

        case 9:

            assert(instr == INS_nop_b);

            opcode  = (_uint64)(2                       ) <<     37;// opcode
            break;

        default:
            goto NO_ENC;
        }
        break;

    case XU_F:
        switch (encodx)
        {
        case 1:

            reg1 = insFltRegNum(insOpDest(ins));
            reg3 = insFltRegNum(insOpReg (ins->idOp3.iOp1));
            reg4 = insFltRegNum(insOpReg (ins->idOp3.iOp2));
            reg2 = insFltRegNum(insOpReg (ins->idOp3.iOp3));

            assert((ins->idType == TYP_FLOAT ) && (instr == INS_fadd_s ||
                                                   instr == INS_fsub_s ||
                                                   instr == INS_fma_s  ||
                                                   instr == INS_fms_s  ||
                                                   instr == INS_fmpy_s)
                           ||
                   (ins->idType == TYP_DOUBLE) && (instr == INS_fadd_d ||
                                                   instr == INS_fsub_d ||
                                                   instr == INS_fma_d  ||
                                                   instr == INS_fms_d  ||
                                                   instr == INS_fmpy_d));

            temp = genInsEncVal(instr);

            /* Insert the "opcode" and "x" fields */

            opcode  = (_uint64)((temp & 0x1F)           ) <<     36;// opcode and "x"

            opcode |=          (reg1                    ) <<      6;// dest reg
            opcode |=          (reg2                    ) <<     13;// src  reg1
            opcode |=          (reg3                    ) <<     20;// src  reg2
            opcode |= (_uint64)(reg4                    ) <<     27;// src  reg3

            if  (ins->idFlags & IF_FMA_S1)
                opcode |= (_uint64)(1                   ) <<     34;// sf

            break;

        case 2:

            assert(instr == INS_xma_l);

            reg1 = insFltRegNum(insOpDest(ins));
            reg2 = insFltRegNum(insOpReg (ins->idOp3.iOp1));
            reg3 = insFltRegNum(insOpReg (ins->idOp3.iOp2));
            reg4 = insFltRegNum(insOpReg (ins->idOp3.iOp3));

            /* Start the encoding with the opcode */

            opcode  = (_uint64)(0xE                     ) <<     37;// opcode

            /* Insert the "x" bit */

            opcode |= (_uint64)(1                       ) <<     36;// "x" extension

            /* Insert the register operands */

            opcode |=          (reg1                    ) <<      6;// dst  reg
            opcode |=          (reg2                    ) <<     13;// src  reg1
            opcode |=          (reg3                    ) <<     20;// src  reg2
            opcode |= (_uint64)(reg4                    ) <<     27;// src  reg3
            break;

        case 4:

            assert(instr == INS_fcmp_eq ||
                   instr == INS_fcmp_ne ||
                   instr == INS_fcmp_lt ||
                   instr == INS_fcmp_le ||
                   instr == INS_fcmp_ge ||
                   instr == INS_fcmp_gt);

            /* This is a reg-reg compare */

            temp = genInsEncVal(instr);

            prr1 = ins->idComp.iPredT;
            prr2 = ins->idComp.iPredF;

            reg2 = insFltRegNum(insOpReg(ins->idComp.iCmp1));
            reg3 = insFltRegNum(insOpReg(ins->idComp.iCmp2));

            /* Do we need to swap the register operands? */

            if  (temp & 0x1000)
            {
                regNumber       regt;

                regt = reg2;
                       reg2 = reg3;
                              reg3 = regt;
            }

            /* Do we need to swap the target predicate operands? */

            if  (temp & 0x2000)
            {
                NatUns          prrt;

                prrt = prr1;
                       prr1 = prr2;
                              prr2 = prrt;
            }

            /* Start the encoding with the opcode */

            opcode  = (_uint64)(4                       ) <<     37;// opcode

            /* Insert the other little opcodes bits */

            if  (temp & 0x01)
                opcode |= (_uint64)1                      <<     36;// "rb"
            if  (temp & 0x02)
                opcode |= (_uint64)1                      <<     33;// "ra"
            if  (temp & 0x04)
                opcode |= (_uint64)1                      <<     12;// "ta"

            /* Insert the source regs and destination predicate regs */

            opcode |=          (reg2                    ) <<     13;// reg2
            opcode |=          (reg3                    ) <<     20;// reg3

            opcode |=          (prr1                    ) <<      6;// p1
            opcode |=          (prr2                    ) <<     27;// p2

//          printf("compare f%u,f%u -> p%u,p%u [encodeVal=0x%04X]\n", reg2, reg3, prr1, prr2, temp);

            break;

        case 9:

            assert(instr == INS_fmov ||
                   instr == INS_fneg || instr == INS_fmerge
                                     || instr == INS_fmerge_ns);

            reg1 = insFltRegNum(insOpDest(ins));

            reg2 =
            reg3 = insFltRegNum(insOpReg (ins->idOp.iOp2));

            if  (ins->idOp.iOp1)
                reg3 = insFltRegNum(insOpReg(ins->idOp.iOp1));

            if  (instr == INS_fmov || instr == INS_fmerge)
                opcode  = (_uint64)(0x10                ) <<     27;// "x6"
            else
                opcode  = (_uint64)(0x11                ) <<     27;// "x6"

            opcode |=          (reg1                    ) <<      6;// dest reg
            opcode |=          (reg2                    ) <<     13;// src  reg1
            opcode |=          (reg3                    ) <<     20;// src  reg2
            break;

        case 11:

            assert(instr == INS_fcvt_xf);

            reg1 = insFltRegNum(insOpDest(ins));
            reg2 = insFltRegNum(insOpReg (ins->idOp.iOp1));

            opcode  = (_uint64)(0x1C                    ) <<     27;// "x6"

            opcode |=          (reg1                    ) <<      6;// dest reg
            opcode |=          (reg2                    ) <<     13;// src  reg1
            break;

        default:
            goto NO_ENC;
        }
        break;

    case XU_L:
        switch (encodx)
        {
            __int64         cval;

        case 2:

            assert(instr  == INS_mov_reg_i64);

            opcode  = (_uint64)(6                       ) <<     37;// opcode

            reg1 = insOpDest (ins);
            cval = insOpCns64(ins->idOp.iOp2);
            temp = (NatInt)cval;

            opcode |=          (reg1                    ) <<      6;// dest reg
            opcode |=          (temp & formBitMask( 0,7)) <<(13- 0);// imm7b
            opcode |= (_uint64)(temp & formBitMask( 7,9)) <<(27- 7);// imm9d
            opcode |=          (temp & formBitMask(16,5)) <<(22-16);// imm5c
            opcode |=          (cval & formBitMask(63,1)) <<(63-36);// sign

            break;

        default:
            goto NO_ENC;
        }
        break;

    default:
    NO_ENC:

#ifdef  DEBUG
        printf("Encode %s%u: ", genXUname(genInsXU((instruction)ins->idIns)), encodx); insDisp(ins, false, true);
#endif
        UNIMPL("encode");
        opcode = 0;
    }

    opcode |= ins->idPred;

#ifdef  DEBUG

    if  (dspCode)
    {
        insDisp(ins, false, true, dspEmit);

        if  (dspEmit)
            printf("//  0x%03X%08X\n", (int)(opcode >> 32), (int)opcode);
    }

#endif

    if  (ins->idFlags & IF_FNDESCR)
    {
        NatUns      offs = emitIA64curCodeOffs() - genCurFuncOffs;

        assert((offs & 15) == 0); offs = offs / 16 * 3 + slotNum;

        switch (ins->idIns)
        {
        case INS_alloc:
//          printf("**** Save pfs  at %04X\n", offs);
            genPrologSvPfs = offs;
            break;
            break;

        case INS_mov_reg:
            assert(ins->idOp.iOp2 && ins->idOp.iOp2->idIns == INS_PHYSREG
                                  && ins->idOp.iOp2->idReg == REG_gp);
//          printf("**** Save gp   at %04X\n", offs);
            genPrologSvGP  = offs;
            break;

        case INS_mov_reg_brr:
//          printf("**** Save rp   at %04X\n", offs);
            genPrologSvRP  = offs;
            break;

        case INS_add_reg_i14:
        case INS_add_reg_reg:
//          printf("**** Mem stack at %04X\n", offs);
            genPrologMstk  = offs;
            break;

        case INS_ld8_ind:
//          printf("**** stack probe\n", genPrologInsCnt);
            break;

        default:
            UNIMPL("unexpected prolog landmark instruction");
        }

        if  (--genPrologInsCnt == 0)
        {
//          printf("**** End ***** at %04X\n", offs);
            genPrologEnd = offs;
        }
    }

    return  opcode;
}

/*****************************************************************************
 *
 *  Schedule and issue the instructions in the given extended basic block.
 */

void                emitter::scBlock(insBlk block)
{
    insPtr          ins;
    insPtr          src;
    IA64execUnits   ixu;

    instrDesc  *  * scInsPtr;

    /* Use the following macro to mark the scheduling table as empty */

    #define clearSchedTable() scInsPtr = scInsTab;

    /* Prepare to accumulate schedulable instructions */

    clearSchedTable();

    ins = block->igList;

    while (ins)
    {
        ins = genIssueNextIns(ins, &ixu, &src);
        if  (!ins)
            break;

#ifdef  DEBUG
        if  (ins->idSrcTab == NULL || ins->idSrcTab == UNINIT_DEP_TAB)
            insDisp(ins, false, true);
#endif

        assert(ins->idSrcTab && ins->idSrcTab != UNINIT_DEP_TAB);

        /* Is this a schedulable instruction? */

        if  (scIsSchedulable(ins))
        {
            /* Is there any room left in the scheduling table? */

            if  (scInsPtr == scInsMax)
            {
                /* Schedule and issue the instructions in the table */

                scGroup(block, NULL, 0, scInsTab,
                                        scInsPtr, 0);

                /* The table is now empty */

                clearSchedTable();
            }

            /* Append this instruction to the table */

            assert(scInsPtr < scInsTab + emitMaxIGscdCnt);

            *scInsPtr++ = ins;
        }
        else
        {
            instrDesc  *    nsi[3];
            NatUns          nsc;

            /* "ins" is not schedulable - look for up to 2 more like that */

            nsc = 1; nsi[0] = ins; ins = ins->idNext;

            if  (ins && !scIsSchedulable(ins))
            {
                nsc++; nsi[1] = ins; ins = ins->idNext;

                if  (ins && !scIsSchedulable(ins))
                {
                    nsc++; nsi[2] = ins; ins = ins->idNext;
                }
            }

            scGroup(block, nsi, nsc, scInsTab,
                                     scInsPtr, 0);

            clearSchedTable();

            continue;
        }

        ins = ins->idNext;
    }

    /* Is the table non-empty? */

    if  (scInsPtr != scInsTab)
    {
        /* Issue whatever has been accumulated in the table */

        scGroup(block, NULL, 0, scInsTab,
                                scInsPtr, 0);
    }
}

/*****************************************************************************
 *
 *  Generate code for a floating-point expression (this is a recursive routine).
 */

insPtr             Compiler::genCodeForTreeFlt(GenTreePtr tree, bool keep)
{
    var_types       type;
    genTreeOps      oper;
    NatUns          kind;
    insPtr          ins;

#ifdef  DEBUG
    ins = (insPtr)-3;
#endif

AGAIN:

    type = tree->TypeGet();

    assert(varTypeIsFloating(type));

    /* Figure out what kind of a node we have */

    oper = tree->OperGet();
    kind = tree->OperKind();

    /* Is this a constant node? */

    if  (kind & GTK_CONST)
    {
        double          fval;

        assert(oper == GT_CNS_FLT ||
               oper == GT_CNS_DBL);

        fval = (oper == GT_CNS_FLT) ? tree->gtFltCon.gtFconVal
                                    : tree->gtDblCon.gtDconVal;

        /* Special cases: 0 and 1 */

        if  (fval == 0 || fval == 1)
        {
            ins = insPhysRegRef((regNumbers)(REG_f000 + (fval != 0)), type, false);
        }
        else
        {
            NatUns          offs;

            insPtr          cns;
            insPtr          reg;
            insPtr          adr;

            /* Add the float constant to the data section */

            offs = genPEwriter->WPEsecAddData(PE_SECT_sdata, (BYTE*)&fval, sizeof(fval));

            /* Compute the address into a temp register */

            cns               = insAllocNX(INS_GLOBVAR, TYP_I_IMPL);
            cns->idGlob.iOffs = (NatUns)offs;

            insMarkDepS0D0(cns);

            reg               = insPhysRegRef(REG_gp, TYP_I_IMPL, false);

            adr               = insAlloc(INS_add_reg_i14, TYP_I_IMPL);
            adr->idOp.iOp1    = reg;
            adr->idOp.iOp2    = cns;

            insFindTemp(adr, true);

            insMarkDepS1D1(adr, IDK_REG_INT, REG_gp,
                                IDK_TMP_INT, adr->idTemp);

            /* Indirect through the address to get the FP constant value */

            ins               = insAlloc(INS_ldf_d, TYP_DOUBLE);
            ins->idOp.iOp1    = adr;
            ins->idOp.iOp2    = NULL;

            insFindTemp(ins, keep);
            insFreeTemp(adr);

            insMarkDepS1D1(ins, IDK_TMP_INT, adr->idTemp,
                                IDK_TMP_FLT, ins->idTemp);
        }

        goto DONE;
    }

    /* Is this a leaf node? */

    if  (kind & GTK_LEAF)
    {
        switch (oper)
        {
        case GT_LCL_VAR:

            /* Does the variable live on the stack frame? */

            if  (genIsVarOnFrame(tree->gtLclVar.gtLclNum))
            {
                ins = genRefFrameVar(NULL, tree, false, false, keep);
                break;
            }

            /* We assume that all locals will be enregistered */

            ins               = insAllocNX(INS_LCLVAR, type);
            ins->idLcl.iVar   = tree->gtLclVar.gtLclNum;
#ifdef  DEBUG
            ins->idLcl.iRef   = compCurBB;   // should we save tree->gtLclVar.gtLclOffs instead ????
#endif
            break;

#ifdef  DEBUG
        default:
            gtDispTree(tree);
            assert(!"unexpected leaf");
#endif
        }

        goto DONE;
    }

    /* Is it a 'simple' unary/binary operator? */

    if  (kind & GTK_SMPOP)
    {
        GenTreePtr      op1 = tree->gtOp.gtOp1;
        GenTreePtr      op2 = tree->gtOp.gtOp2;

        insPtr          ins1;
        insPtr          ins2;

#ifdef  DEBUG
        ins1 = (insPtr)-1;
        ins2 = (insPtr)-2;
#endif

        switch (oper)
        {
            instruction     opc;

        case GT_ASG:

            /* Is this a direct or indirect assignment? */

            switch (op1->gtOper)
            {
                insPtr          dest;

            case GT_LCL_VAR:

                /* Does the variable live on the stack frame? */

                if  (genIsVarOnFrame(op1->gtLclVar.gtLclNum))
                {
                    ins1 = genRefFrameVar(NULL, op1, true, false, false);
                    ins1->idFlags |= IF_ASG_TGT;

                    ins2 = genCodeForTreeFlt(op2, true);

                    assert(INS_stf_s + 1 == INS_stf_d);

                    opc = (instruction)(INS_stf_s + (type == TYP_DOUBLE));
                    ins = insAlloc(opc, type);

                    markDepSrcOp(ins, ins2);
                    markDepDstOp(ins, ins1, IDK_LCLVAR, op1->gtLclVar.gtLclNum);
                }
                else
                {
                    ins1 = NULL;
                    ins2 = genCodeForTreeFlt(op2,  true);

                    dest = genCodeForTreeFlt(op1, false);
                    dest->idFlags |= IF_ASG_TGT;

                    ins        = insAlloc(INS_fmov, type);
                    ins->idRes = dest;

                    markDepSrcOp(ins, ins2);
                    markDepDstOp(ins, dest);
                }
                break;

            case GT_IND:

                if  (tree->gtFlags & GTF_REVERSE_OPS)
                {
                    ins2 = genCodeForTreeFlt(op2            , true);
                    ins1 = genCodeForTreeInt(op1->gtOp.gtOp1, true);
                }
                else
                {
                    ins1 = genCodeForTreeInt(op1->gtOp.gtOp1, true);
                    ins2 = genCodeForTreeFlt(op2            , true);
                }

                ins1->idFlags |= IF_ASG_TGT;

                assert(INS_stf_s + 1 == INS_stf_d);

                opc = (instruction)(INS_stf_s + (type == TYP_DOUBLE));
                ins = insAlloc(opc, type);

                markDepSrcOp(ins, ins2);
                markDepDstOp(ins, ins1, IDK_IND, emitter::scIndDepIndex(ins));

                break;

            default:
                UNIMPL("unexpected target of assignment");
            }

            break;

        case GT_ADD: opc = (type == TYP_FLOAT) ? INS_fadd_s : INS_fadd_d; goto FLT_BINOP;
        case GT_SUB: opc = (type == TYP_FLOAT) ? INS_fsub_s : INS_fsub_d; goto FLT_BINOP;
        case GT_MUL: opc = (type == TYP_FLOAT) ? INS_fmpy_s : INS_fmpy_d; goto FLT_BINOP;

        FLT_BINOP:

            ins1 = genCodeForTreeFlt(op1, true);
            ins2 = genCodeForTreeFlt(op2, true);

            ins  = insAlloc(opc, type);

            /*
                ISSUE:  Should we reuse one of the operand temps for the
                        result, or always grab a new temp ? For now, we
                        do the latter (grab a brand spanking new temp).
             */

             insFindTemp(ins, keep);

            markDepSrcOp(ins, ins1, ins2);
            markDepDstOp(ins, ins);

            if  (oper == GT_MUL)
            {
                ins->idOp3.iOp1 = ins1;
                ins->idOp3.iOp2 = ins2;
                ins->idOp3.iOp3 = insPhysRegRef(REG_f000, TYP_DOUBLE, false);
            }
            else
            {
                ins->idOp3.iOp1 = ins1;
                ins->idOp3.iOp2 = insPhysRegRef(REG_f001, TYP_DOUBLE, false);
                ins->idOp3.iOp3 = ins2;
            }

            insFreeTemp(ins1);
            insFreeTemp(ins2);

            goto DONE;

        case GT_ASG_ADD: opc = (type == TYP_FLOAT) ? INS_fadd_s : INS_fadd_d; goto FLT_ASGOP;
        case GT_ASG_SUB: opc = (type == TYP_FLOAT) ? INS_fsub_s : INS_fsub_d; goto FLT_ASGOP;
        case GT_ASG_MUL: opc = (type == TYP_FLOAT) ? INS_fmpy_s : INS_fmpy_d; goto FLT_ASGOP;

        FLT_ASGOP:

            switch (op1->gtOper)
            {
                insPtr          addr;
                insPtr          rslt;

                insPtr          ind;

            case GT_IND:

                /* Compute the address of the target and the RHS */

                if  (tree->gtFlags & GTF_REVERSE_OPS)
                {
                    ins2 = genCodeForTreeFlt(op2            , true);
                    addr = genCodeForTreeInt(op1->gtOp.gtOp1, true);
                }
                else
                {
                    addr = genCodeForTreeInt(op1->gtOp.gtOp1, true);
                    ins2 = genCodeForTreeFlt(op2            , true);
                }

                /* Load the old value of the target into a temp */

                assert(INS_ldf_s + 1 == INS_ldf_d);

                ind            = insAlloc((instruction)(INS_ldf_s + (type == TYP_DOUBLE)), type);
                ind->idOp.iOp1 = addr;
                ind->idOp.iOp2 = NULL;

                insFindTemp (ind, true);

                markDepSrcOp(ind, addr, IDK_IND, emitter::scIndDepIndex(ind));
                markDepDstOp(ind, ind);

                /* Compute the new value */

                rslt = insAlloc(opc, type);

                 insFindTemp(rslt, true);

                markDepSrcOp(rslt, ind, ins2);
                markDepDstOp(rslt, rslt);

                if  (oper == GT_ASG_MUL)
                {
                    rslt->idOp3.iOp1 = ind;
                    rslt->idOp3.iOp2 = ins2;
                    rslt->idOp3.iOp3 = insPhysRegRef(REG_f000, TYP_DOUBLE, false);
                }
                else
                {
                    rslt->idOp3.iOp1 = ind;
                    rslt->idOp3.iOp2 = insPhysRegRef(REG_f001, TYP_DOUBLE, false);
                    rslt->idOp3.iOp3 = ins2;
                }

                insFreeTemp(ind);
                insFreeTemp(ins2);

                /* Store the new value in the target */

                assert(INS_stf_s + 1 == INS_stf_d);

                ins            = insAlloc((instruction)(INS_stf_s + (type == TYP_DOUBLE)), type);
                ins->idOp.iOp1 = addr;
                ins->idOp.iOp2 = rslt;

                // ISSUE: We're using the value of a temp twice, is this OK????

                markDepSrcOp(ins, rslt);
                markDepDstOp(ins, addr, IDK_IND, emitter::scIndDepIndex(ins));

                if  (keep)
                {
                    UNIMPL("save op= new value in another temp?");
                }
                else
                {
                    insFreeTemp(rslt);
                }

                goto DONE;

            case GT_LCL_VAR:

                ins1 = genCodeForTreeFlt(op1, false);
                ins2 = genCodeForTreeFlt(op2,  true);

                rslt = genCodeForTreeFlt(op1, false);
                rslt->idFlags |= IF_ASG_TGT;

                ins            = insAlloc(opc, type);
                ins->idRes     = rslt;

                if  (oper == GT_MUL)
                {
                    ins->idOp3.iOp1 = ins1;
                    ins->idOp3.iOp2 = ins2;
                    ins->idOp3.iOp3 = insPhysRegRef(REG_f000, TYP_DOUBLE, false);
                }
                else
                {
                    ins->idOp3.iOp1 = ins1;
                    ins->idOp3.iOp2 = insPhysRegRef(REG_f001, TYP_DOUBLE, false);
                    ins->idOp3.iOp3 = ins2;
                }

                markDepSrcOp(ins, ins1, ins2);
                markDepDstOp(ins, rslt);

                insFreeTemp(ins2);

                goto DONE;

            default:
#ifdef  DEBUG
                gtDispTree(tree);
#endif
                UNIMPL("unexpected target of assignment operator");
            }

            ins1 = genCodeForTreeFlt(op1, true);
            ins2 = genCodeForTreeFlt(op2, true);

            ins = insAlloc(opc, type);

            /*
                ISSUE:  Should we reuse one of the operand temps for the
                        result, or always grab a new temp ? For now, we
                        do the latter (grab a brand spanking new temp).
             */

             insFindTemp(ins, keep);

            markDepSrcOp(ins, ins1, ins2);
            markDepDstOp(ins, ins);

            ins->idOp3.iOp1 = ins1; insFreeTemp(ins1);
            ins->idOp3.iOp2 = ins2; insFreeTemp(ins2);
            ins->idOp3.iOp3 = NULL;

            goto DONE;

        case GT_CAST:

            /* What are we casting from? */

            if  (varTypeIsScalar(op1->gtType))
            {
                insPtr          tmp1;
                insPtr          fcvt;

                /* Generate the value of the operand being converted */

                ins1 = genCodeForTreeInt(op1, true);

                // setf.sig fx=rx

                tmp1             = insAlloc(INS_setf_sig, type);
                tmp1->idOp.iOp1  = ins1;
                tmp1->idOp.iOp2  = NULL;

                insFindTemp(tmp1, true);
                insFreeTemp(ins1);

                markDepSrcOp(tmp1, ins1);
                markDepDstOp(tmp1, tmp1);

                /* Is the source operand signed or unsigned? */

                if  (varTypeIsUnsigned(op1->gtType))
                {
                    instruction     icvt = (type == TYP_DOUBLE) ? INS_fcvt_xuf_s
                                                                : INS_fcvt_xuf_d;

                    // fcvt.xuf fy=fx

                    fcvt             = insAlloc(icvt, type);
                    fcvt->idOp3.iOp1 = insPhysRegRef(REG_f000    , type, false);
                    fcvt->idOp3.iOp1 = tmp1;
                    fcvt->idOp3.iOp2 = insPhysRegRef(REG_f001    , type, false);
                }
                else
                {
                    // fcvt.xf  fy=fx

                    fcvt             = insAlloc(INS_fcvt_xf , type);
                    fcvt->idOp .iOp1 = tmp1;
                    fcvt->idOp .iOp2 = NULL;
                }

                insFindTemp(fcvt, true);
                insFreeTemp(tmp1);

                markDepSrcOp(fcvt, tmp1);
                markDepDstOp(fcvt, fcvt);

                // fma.<sz>.s1  fz=fy, f1, f0

                ins              = insAlloc((type == TYP_DOUBLE) ? INS_fma_d
                                                                 : INS_fma_s, type);
                ins->idFlags    |= IF_FMA_S1;

                ins->idOp3.iOp1  = fcvt;
                ins->idOp3.iOp2  = insPhysRegRef(REG_f001, type, false);
                ins->idOp3.iOp3  = insPhysRegRef(REG_f000, type, false);

                insFindTemp(ins, keep);
                insFreeTemp(fcvt);

                markDepSrcOp(ins , fcvt);
                markDepDstOp(ins , ins );

                goto DONE;
            }
            else
            {
                ins = genCodeForTreeFlt(op1, keep);
            }

            goto DONE;

        case GT_IND:

            ins1 = genCodeForTreeInt(op1, keep);
            ins2 = NULL;

            assert(INS_ldf_s + 1 == INS_ldf_d);

            opc = (instruction)(INS_ldf_s + (type == TYP_DOUBLE));
            ins = insAlloc(opc, type);

            insFindTemp(ins, keep);

            markDepSrcOp(ins, ins1, IDK_IND, emitter::scIndDepIndex(ins));
            markDepDstOp(ins, ins);

            break;

        case GT_NEG:

            ins1 = NULL;
            ins2 = genCodeForTreeFlt(op1, keep);

            ins  = insAlloc(INS_fneg, type);

            insFindTemp (ins, keep);

            markDepSrcOp(ins, ins2);
            markDepDstOp(ins, ins);

            break;

        case GT_RETURN:

            assert(op1);

            insPtr          rval;
            insPtr          rreg;

            /* This is just a temp hack, of course */

            rval = genCodeForTreeFlt(op1, false);
            rreg = insPhysRegRef(REG_f008, type, true);

            ins1            = insAlloc(INS_fmov, type);
            ins1->idRes     = rreg;
            ins1->idOp.iOp1 = NULL;
            ins1->idOp.iOp2 = rval;

            markDepSrcOp(ins1, rval);
            markDepDstOp(ins1, IDK_REG_FLT, REG_f008);

            ins  = insAlloc(INS_EPILOG, type);

            ins->idEpilog.iBlk  = insBlockLast;
            ins->idEpilog.iNxtX = insExitList;
                                  insExitList = ins;

            insBuildBegBlk();
            goto DONE;

#ifdef  DEBUG
        default:
            gtDispTree(tree);
            assert(!"unexpected unary/binary operator");
#endif
        }

        ins->idOp.iOp1 = ins1; if (ins1) insFreeTemp(ins1);
        ins->idOp.iOp2 = ins2; if (ins2) insFreeTemp(ins2);

        goto DONE;
    }

    /* See what kind of a special operator we have here */

    switch  (oper)
    {
    case GT_CALL:
        ins = genCodeForCall(tree, keep);
        goto DONE_NODSP;

    default:
#ifdef  DEBUG
        gtDispTree(tree);
#endif
        assert(!"unexpected operator");
    }

DONE:

#ifdef  DEBUG
    if  (verbose||0) insDisp(ins);
#endif

DONE_NODSP:

#if USE_OLD_LIFETIMES

    /* See if life has changed -- should only happen at variable nodes */

//  printf("%08X ", (int)tree->gtLiveSet); gtDispTree(tree, 0, true);

    if  (oper == GT_LCL_VAR)
    {
        if  (genCodeCurLife != tree->gtLiveSet)
        {
            VARSET_TP       change = genCodeCurLife ^ tree->gtLiveSet;

            if  (change)
            {
                NatUns          varNum;
                LclVarDsc   *   varDsc;
                VARSET_TP       varBit;

//              printf("Life changes: %08X -> %08X [diff = %08X]\n", (int)genCodeCurLife, (int)tree->gtLiveSet, (int)change);

                /* Only one variable can die or be born at one time */

                assert(genOneBitOnly(change));

                /* In fact, the variable affected should be the one referenced */

                assert(tree->gtLclVar.gtLclNum < lvaCount);
                assert(change == genVarIndexToBit(lvaTable[tree->gtLclVar.gtLclNum].lvVarIndex));

                /* Is this a birth or death of the given variable? */

                ins->idFlags |= (genCodeCurLife & change) ? IF_VAR_DEATH
                                                          : IF_VAR_BIRTH;
            }

            genCodeCurLife = tree->gtLiveSet;
        }
    }
    else
    {
        assert(genCodeCurLife == tree->gtLiveSet);
    }

#endif

    return  ins;
}

/*****************************************************************************/

static
unsigned char       bitset8masks[8] =
{
    0x01UL,
    0x02UL,
    0x04UL,
    0x08UL,
    0x10UL,
    0x20UL,
    0x40UL,
    0x80UL,
};

void                bitVect::bvFindB(bvInfoBlk &info)
{
    assert(info.bvInfoBtSz == ((info.bvInfoSize + NatBits - 1) & ~(NatBits - 1)) / 8);

    if  (info.bvInfoFree)
    {
        byteMap = (BYTE*)info.bvInfoFree;
                         info.bvInfoFree = *(void **)byteMap;
    }
    else
    {
        byteMap = (BYTE*)insAllocMem(info.bvInfoBtSz);
    }

#ifdef  DEBUG
    memset(byteMap, rand(), info.bvInfoBtSz);
#endif

    assert(((NatUns)byteMap & 1) == 0);
}

void                bitVect::bvCreateB(bvInfoBlk &info)
{
    bvFindB(info); memset(byteMap, 0, info.bvInfoBtSz);
}

void                bitVect::bvDestroyB(bvInfoBlk &info)
{
    assert(info.bvInfoBtSz >= sizeof(bitVect*));

    *castto(byteMap, void **) = info.bvInfoFree;
                                info.bvInfoFree = byteMap;

#ifdef  DEBUG
    byteMap = (BYTE*)-1;
#endif

}

void                bitVect::bvCopyB   (bvInfoBlk &info, bitVect & from)
{
    memcpy(byteMap, from.byteMap, info.bvInfoBtSz);
}

bool                bitVect::bvChangeB (bvInfoBlk &info, bitVect & from)
{
    bool            chg = false;

    NatUns  *       dst = this->uintMap;
    NatUns  *       src = from .uintMap;

    size_t          cnt = info .bvInfoInts;

    assert(cnt && info.bvInfoBtSz == cnt * sizeof(NatUns)/sizeof(BYTE));

    do
    {
        if  (*dst != *src)
            chg = true;

        *dst++ = *src++;
    }
    while (--cnt);

    return  chg;
}

void                bitVect::bvClearB(bvInfoBlk &info)
{
    assert(((NatUns)byteMap & 1) == 0);
    memset(byteMap, 0, info.bvInfoBtSz);
}

bool                bitVect::bvTstBitB(bvInfoBlk &info, NatUns index)
{
    assert(((NatUns)byteMap & 1) == 0);
    assert(index && index <= info.bvInfoSize);

    index--;

    return  (byteMap[index / 8] & bitset8masks[index % 8]) != 0;
}

void                bitVect::bvClrBitB(bvInfoBlk &info, NatUns index)
{
    assert(((NatUns)byteMap & 1) == 0);
    assert(index && index <= info.bvInfoSize);

    index--;

    byteMap[index / 8] &= ~bitset8masks[index % 8];
}

void                bitVect::bvSetBitB(bvInfoBlk &info, NatUns index)
{
    assert(((NatUns)byteMap & 1) == 0);
    assert(index && index <= info.bvInfoSize);

    index--;

    byteMap[index / 8] |=  bitset8masks[index % 8];
}

void                bitVect::bvCrFromB (bvInfoBlk &info, bitVect &from)
{
    bvFindB(info); memcpy(byteMap, from.byteMap, info.bvInfoBtSz);
}

void                bitVect::bvIorB    (bvInfoBlk &info, bitVect &with)
{
    NatUns  *       dst = this->uintMap;
    NatUns  *       src = with .uintMap;

    size_t          cnt = info .bvInfoInts;

    assert(cnt && info.bvInfoBtSz == cnt * sizeof(NatUns)/sizeof(BYTE));

    do
    {
        *dst++ |= *src++;
    }
    while (--cnt);
}

void                bitVect::bvUnInCmB (bvInfoBlk &info, bitVect & set1,
                                                         bitVect & set2,
                                                         bitVect & set3)
{
    NatUns  *       dst  = this->uintMap;
    NatUns  *       src1 = set1 .uintMap;
    NatUns  *       src2 = set2 .uintMap;
    NatUns  *       src3 = set3 .uintMap;

    size_t          cnt  = info .bvInfoInts;

    assert(cnt && info.bvInfoBtSz == cnt * sizeof(NatUns)/sizeof(BYTE));

    do
    {
        *dst++ = *src1++ | (*src2++ & ~*src3++);
    }
    while (--cnt);
}

bool                bitVect::bvIsEmptyB(bvInfoBlk &info)
{
    NatUns  *       src = this->uintMap;
    size_t          cnt = info.bvInfoInts;

    assert(cnt && info.bvInfoBtSz == cnt * sizeof(NatUns)/sizeof(BYTE));

    do
    {
        if  (*src)
            return  true;
    }
    while (--cnt);

    return  false;
}

/*****************************************************************************/
#ifdef  DEBUG
/*****************************************************************************/

#undef  bvDisp
#undef  bvTstBit

void                bitVectVars::bvDisp(Compiler *comp)
{
    bool            first = true;

    printf("{");

    for (NatUns varNum = 0; varNum < comp->lvaCount; varNum++)
    {
        if  (bvTstBit(comp, varNum+1))
        {
            if  (!first)
                printf(",");

            first = false;

            printf("%u", varNum);
        }
    }

    printf("}");
}

/*****************************************************************************/
#endif
/*****************************************************************************/
#endif//TGT_IA64
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\ia64\block.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                          BasicBlock                                       XX
XX                                                                           XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

/*****************************************************************************/
#ifndef _BLOCK_H_
#define _BLOCK_H_
/*****************************************************************************/

#include "vartype.h"    // For "var_types.h"

/*****************************************************************************/

typedef
unsigned  __int64   VARSET_TP;
#define             VARSET_SZ   64

#define             VARSET_NONE ((VARSET_TP)0-1)

/*****************************************************************************/

typedef
unsigned    int     EXPSET_TP;
#define             EXPSET_SZ   32

typedef
unsigned    int     RNGSET_TP;
#define             RNGSET_SZ   32

/*****************************************************************************
 *
 *  Type values are stored as unsigned shorts.
 */

typedef unsigned short  verTypeVal;

/*****************************************************************************
 *
 *  The following describes a stack contents (packed version).
 */

struct stackDesc
{
    unsigned            sdDepth;    // number of values on stack
    verTypeVal       *  sdTypes;    // types  of values on stack
};

/*****************************************************************************
 *
 *  Each basic block ends with a jump which is described be a value
 *  of the following enumeration.
 */

enum BBjumpKinds
{
    BBJ_RET,                        // block ends with 'endfinally' or 'endfilter'
    BBJ_THROW,                      // block ends with 'throw'
    BBJ_RETURN,                     // block ends with '[t]return'

    BBJ_NONE,                       // block flows into the next one (no jump)

    BBJ_ALWAYS,                     // block always        jumps to the target
    BBJ_CALL,                       // block always        calls    the target
    BBJ_COND,                       // block conditionally jumps to the target
    BBJ_SWITCH,                     // block ends with a switch statement
};

/*****************************************************************************
 *
 *  The values that represent types are as follows:
 *
 *      TYP_UNDEF               ....        uninitialized variable
 *      1 .. TYP_COUNT          ....        intrinsic type (e.g. TYP_INT)
 *      TYP_CODE_ADDR           ....        return address from 'jsr'
 *      TYP_LNG_HI              ....        upper part of a long   value
 *      TYP_DBL_HI              ....        upper part of a double value
 *      TYP_MIXED               ....        mixture of (incompatible) types
 *      TYP_USER + nnn          ....        user-defined type
 */

enum
{
    TYP_SKIP_THE_REAL_TYPES = TYP_COUNT-1,

    TYP_CODE_ADDR,
    TYP_LNG_HI,
    TYP_DBL_HI,
    TYP_MIXED,
    TYP_USER,
};

/*****************************************************************************
 *
 *  The following describes a switch block.
 */

struct  GenTree;
struct  BasicBlock;


struct  BBswtDesc
{
    unsigned            bbsCount;       // count of cases (includes 'default')
#if TGT_IA64
    unsigned            bbsIPmOffs;     // offset  of the "mov r3=ip" bundle
    BYTE *              bbsTabAddr;     // address of jump table in .sdata section
#endif
    BasicBlock  *   *   bbsDstTab;      // case label table address
};

/*****************************************************************************/

#if RNGCHK_OPT

struct flowList
{
    BasicBlock      *   flBlock;
    flowList        *   flNext;
};

typedef
unsigned  __int64       BLOCKSET_TP;

#define                 BLOCKSET_SZ   64

// Return the bit corresponding to a block with the given number.

inline
BLOCKSET_TP         genBlocknum2bit(unsigned index)
{
    assert(index && index <= BLOCKSET_SZ);

    return  ((BLOCKSET_TP)1 << (index-1));
}

#endif

/*****************************************************************************
 *
 *  The following structure describes a basic block.
 */

struct  BasicBlock
{
    BasicBlock  *       bbNext;     // next BB in ascending PC offset order

    unsigned short      bbNum;      // the block's number
#ifdef BIRCH_SP2
    short               bbRefs;     // id of the block that jumps here or negative for special flags
#else
    unsigned short      bbRefs;     // number of blocks that can jump here
#endif

    unsigned            bbFlags;    // see BBF_xxxx below

#define BBF_CHANGED     0x00000001  // input/output of this block has changed
#define BBF_IS_TRY      0x00000002  // BB starts a 'try' block
#define BBF_HAS_HANDLER 0x00000004  // the BB has an exception handler

#define BBF_LOOP_HEAD   0x00000010  // BB is the head of a loop
#define BBF_HAS_CALL    0x00000020  // BB contains a method call
#define BBF_NEEDS_GC    0x00000040  // BB needs an explicit GC check
#define BBF_NEW_ARRAY   0x00000080  // BB contains 'new' of an array

#define BBF_BB_COLON    0x00000100  // _: value is an output from the block
#define BBF_BB_QMARK    0x00000200  // _? value is an input  to   the block
#define BBF_COLON       0x00000300  //  : value is an output from the block
#define BBF_QC_MASK     0x00000300
#define isBBF_BB_COLON(flags) (((flags) & BBF_QC_MASK) == BBF_BB_COLON)
#define isBBF_BB_QMARK(flags) (((flags) & BBF_QC_MASK) == BBF_BB_QMARK)
#define isBBF_COLON(flags)    (((flags) & BBF_QC_MASK) == BBF_COLON   )

#define BBF_REMOVED     0x00000400  // BB has been removed from bb-list
#define BBF_DONT_REMOVE 0x00000800  // BB should not be removed during flow graph optimizations

#define BBF_HAS_POSTFIX 0x00001000  // BB contains postfix ++/-- expressions
#define BBF_HAS_INC     0x00002000  // BB contains increment     expressions
#define BBF_HAS_INDX    0x00004000  // BB contains simple index  expressions

#define BBF_IMPORTED    0x00008000  // BB byte-code has been imported

#define BBF_VISITED     0x00010000  // BB visited during optimizations
#define BBF_MARKED      0x00020000  // BB marked  during optimizations

#if RNGCHK_OPT
#define BBF_LOOP_CALL0  0x00040000  // BB starts a loop that sometimes won't call
#define BBF_LOOP_CALL1  0x00080000  // BB starts a loop that will always     call
#endif

#define BBF_INTERNAL    0x00100000  // BB has been added by the compiler

#define BBF_HAS_JMP     0x00200000  // BB executes a JMP or JMPI instruction (instead of return)

#define BBF_ENDFILTER   0x00400000  // BB is the end of a filter

#define BBF_JMP_TARGET  0x40000000  // BB is a target of an implicit/explicit jump
#define BBF_HAS_LABEL   0x80000000  // BB needs a label

    unsigned            bbCodeOffs; // starting PC offset
    unsigned            bbCodeSize; // # of bytes of code

    // Some non-zero value that will not colide with real tokens for bbCatchTyp
    #define BBCT_FAULT              0xFFFFFFFC
    #define BBCT_FINALLY            0xFFFFFFFD
    #define BBCT_FILTER             0xFFFFFFFE
    #define BBCT_FILTER_HANDLER     0xFFFFFFFF
    #define handlerGetsXcptnObj(hndTyp) \
        ((hndTyp) != 0 && (hndTyp) != BBCT_FAULT && (hndTyp) != BBCT_FINALLY)

    unsigned            bbCatchTyp; // catch type CP index if handler

#ifdef  FAST
    BYTE                bbJumpKind; // jump (if any) at the end
#else
    BBjumpKinds         bbJumpKind; // jump (if any) at the end
#endif

#ifdef  VERIFIER

    stackDesc           bbStackIn;  // stack descriptor for  input
    stackDesc           bbStackOut; // stack descriptor for output

    verTypeVal  *       bbTypesIn;  // list of variable types on  input
    verTypeVal  *       bbTypesOut; // list of variable types on output

#ifdef  DEF_USE_SETS
    verTypeVal  *       bbTypesUse; // table of local types    used by block
    verTypeVal  *       bbTypesDef; // table of local types defined by block
#endif

#endif

    GenTree *           bbTreeList; // the body of the block

#if TGT_IA64
    insBlk              bbInsBlk;   // corresponding logical instruction block
#endif

    unsigned short      bbStkDepth; // stack depth on entry
    unsigned short      bbStkTemps; // base# for input stack temps

#define NO_BASE_TMP     USHRT_MAX   // put it outside local var range

    unsigned short      bbTryIndex; // for raising exceptions
    unsigned short      bbWeight;   // to give refs inside loops more weight

#define MAX_LOOP_WEIGHT USHRT_MAX   // we're using a 'unsigned short' for the weight

    VARSET_TP           bbVarUse;   // variables used     by block
    VARSET_TP           bbVarDef;   // variables assigned by block
    VARSET_TP           bbVarTmp;   // TEMP: only used by FP enregistering code!

    VARSET_TP           bbLiveIn;   // variables live on entry
    VARSET_TP           bbLiveOut;  // variables live on exit
#ifdef DEBUGGING_SUPPORT
    VARSET_TP           bbScope;    // variables in scope over the block
#endif

#if RNGCHK_OPT || CSE

    /* The following are the standard bit sets for dataflow analisys
     * We perform     CSE and range-checks at the same time
     *                Const / Copy propagation at the same time
     * thus we can union them since the two operations are completely disjunct */

    union
    {
        EXPSET_TP           bbExpGen;        // exprs computed by block
        EXPSET_TP           bbConstAsgGen;   // constant assignments computed by block
    };

    union
    {
        EXPSET_TP           bbExpKill;       // exprs killed   by block
        EXPSET_TP           bbConstAsgKill;  // constant assignments killed   by block
    };

    union
    {
        EXPSET_TP           bbExpIn;         // exprs available on entry
        EXPSET_TP           bbConstAsgIn;    // constant assignments available on entry
    };

    union
    {
        EXPSET_TP           bbExpOut;        // exprs available on exit
        EXPSET_TP           bbConstAsgOut;   // constant assignments available on exit
    };

    union
    {
        RNGSET_TP           bbRngGen;        // range checks computed by block
        EXPSET_TP           bbCopyAsgGen;    // copy assignments computed by block
    };

    union
    {
        RNGSET_TP           bbRngKill;       // range checks killed   by block
        EXPSET_TP           bbCopyAsgKill;   // copy assignments killed   by block
    };

    union
    {
        RNGSET_TP           bbRngIn;         // range checks available on entry
        EXPSET_TP           bbCopyAsgIn;     // copy assignments available on entry
    };

    union
    {
        RNGSET_TP           bbRngOut;        // range checks available on exit
        EXPSET_TP           bbCopyAsgOut;    // copy assignments available on exit
    };

#endif

#if RNGCHK_OPT

    BLOCKSET_TP         bbDom;      // blocks dominating this one
    flowList   *        bbPreds;    // ptr to list of predecessors

#endif

    union
    {
        BasicBlock *        bbFilteredCatchHandler; // used in the importer
        void    *           bbEmitCookie;
    };

    /* The following fields used for loop detection */

    unsigned char       bbLoopNum;  // set to 'n' for a loop #n header
//  unsigned short      bbLoopMask; // set of loops this block is part of

#define MAX_LOOP_NUM    16          // we're using a 'short' for the mask
#define LOOP_MASK_TP    unsigned    // must be big enough for a mask

    /* The following union describes the jump target(s) of this block */

    union
    {
        unsigned            bbJumpOffs;         // PC offset (temporary only)
        BasicBlock  *       bbJumpDest;         // basic block
        BBswtDesc   *       bbJumpSwt;          // switch descriptor
    };

    //-------------------------------------------------------------------------

#if     MEASURE_BLOCK_SIZE
    static size_t       s_Size;
    static size_t       s_Count;
#endif

    BasicBlock *        FindJump(bool allowThrow = false);

    BasicBlock *        JumpTarget();

#ifdef  DEBUG
    static unsigned     s_nMaxTrees; // The max # of tree nodes in any BB
#endif

protected :

};

/*****************************************************************************/

extern  BasicBlock *    __cdecl verAllocBasicBlock();

#ifdef  DEBUG
extern  void            __cdecl verDispBasicBlocks();
#endif

/*****************************************************************************
 *
 *  The following call-backs supplied by the client; it's used by the code
 *  emitter to convert a basic block to its corresponding emitter cookie.
 */

void *  FASTCALL        emitCodeGetCookie(BasicBlock *block);

/*****************************************************************************/
#endif // _BLOCK_H_
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\ia64\codegen.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                           CodeGenerator                                   XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

#include "jitpch.h"
#pragma hdrstop

#include "GCInfo.h"
#include "emit.h"
#include "malloc.h"     // for alloca

/*****************************************************************************/

const BYTE              genTypeSizes[] =
{
    #define DEF_TP(tn,nm,jitType,sz,sze,asze,st,al,tf,howUsed) sz,
    #include "typelist.h"
    #undef  DEF_TP
};

const BYTE              genTypeStSzs[] =
{
    #define DEF_TP(tn,nm,jitType,sz,sze,asze,st,al,tf,howUsed) st,
    #include "typelist.h"
    #undef  DEF_TP
};

const BYTE              genActualTypes[] =
{
    #define DEF_TP(tn,nm,jitType,sz,sze,asze,st,al,tf,howUsed) jitType,
    #include "typelist.h"
    #undef  DEF_TP
};

/*****************************************************************************/
#ifndef TGT_IA64
/*****************************************************************************/

regMaskTP           genRegArgMasks[MAX_REG_ARG+1] =
{
    RBM_NONE,
    RBM_ARG_0,
#if MAX_REG_ARG >= 2
    RBM_ARG_0|RBM_ARG_1,
#if MAX_REG_ARG >= 3
    RBM_ARG_0|RBM_ARG_1|RBM_ARG_2,
#if MAX_REG_ARG >= 4
    RBM_ARG_0|RBM_ARG_1|RBM_ARG_2|RBM_ARG_3,
#if MAX_REG_ARG >= 5
    RBM_ARG_0|RBM_ARG_1|RBM_ARG_2|RBM_ARG_3|RBM_ARG_4,
#if MAX_REG_ARG >= 6
    RBM_ARG_0|RBM_ARG_1|RBM_ARG_2|RBM_ARG_3|RBM_ARG_4|RBM_ARG_5,
#if MAX_REG_ARG >= 7
    RBM_ARG_0|RBM_ARG_1|RBM_ARG_2|RBM_ARG_3|RBM_ARG_4|RBM_ARG_5|RBM_ARG_6,
#if MAX_REG_ARG >= 8
    RBM_ARG_0|RBM_ARG_1|RBM_ARG_2|RBM_ARG_3|RBM_ARG_4|RBM_ARG_5|RBM_ARG_6|RBM_ARG_7,
#if MAX_REG_ARG >= 9
#error Need to add more entries to genRegArgMasks.
#endif
#endif
#endif
#endif
#endif
#endif
#endif
#endif
};

/*****************************************************************************/
// Have to be defined for genTypeRegst[]

#if TGT_SH3

#define TYP_REGS_UNDEF      7
#define TYP_REGS_VOID       1

#define TYP_REGS_BOOL       1

#define TYP_REGS_BYTE       1
#define TYP_REGS_UBYTE      1

#define TYP_REGS_SHORT      1
#define TYP_REGS_CHAR       1

#define TYP_REGS_INT        1
#define TYP_REGS_LONG       2

#define TYP_REGS_FLOAT      1
#define TYP_REGS_DOUBLE     2

#define TYP_REGS_REF        1
#define TYP_REGS_BYREF      1
#define TYP_REGS_ARRAY      1
#define TYP_REGS_STRUCT     7
#define TYP_REGS_PTR        1
#define TYP_REGS_FNC        1

#define TYP_REGS_UINT       1
#define TYP_REGS_ULONG      2

#define TYP_REGS_UNKNOWN    0

#endif

/*****************************************************************************/

#if TGT_RISC

/* TYP_REGS_<type> for all the types should be defined appropriately for the
   required target */

BYTE                genTypeRegst[] =
{
    #define DEF_TP(tn,nm,jitType,sz,sze,asze,st,al,tf,howUsed) TYP_REGS_##tn,
    #include "typelist.h"
    #undef DEF_TP
};

#endif

/*****************************************************************************/

void            Compiler::genInit()
{
    rsInit  ();
    tmpInit ();
    instInit();
    gcInit  ();

#ifdef LATE_DISASM
    genDisAsm.disInit(this);
#endif

#ifdef  DEBUG
    genTempLiveChg          = true;
    genTrnslLocalVarCount   = 0;

    // Shouldnt be used before it is set in genFnProlog()
    compCalleeRegsPushed    = 0xDD;
#endif

    genFlagsEqualToNone();

#ifdef DEBUGGING_SUPPORT
    //  Initialize the IP-mapping logic.
    // if (opts.compDbgInfo)
    genIPmappingList        =
    genIPmappingLast        = 0;
#endif
}

/*****************************************************************************/

inline
bool                genShouldRoundFP()
{
    switch (getRoundFloatLevel())
    {
    case 1:
        /* Round values compared against constants */
        return  false;
    case 2:
        /* Round comparands */
        return  false;
    case 3:
        /* Round always */
        return   true;
    default:
        /* Round never */
        return  false;
    }
}

/*****************************************************************************
 *
 *  Initialize some global variables.
 */

void                Compiler::genPrepForCompiler()
{

    unsigned        varNum;
    LclVarDsc   *   varDsc;

    /* Figure out which non-register variables hold pointers */

    gcTrkStkPtrLcls = 0;

    /* Figure out which variables live in registers */

    genCodeCurRvm   = 0;

    for (varNum = 0, varDsc = lvaTable;
         varNum < lvaCount;
         varNum++  , varDsc++)
    {
        if  (varDsc->lvTracked)
        {
            if      (varDsc->lvRegister && varDsc->lvType != TYP_DOUBLE)
            {
                genCodeCurRvm |= genVarIndexToBit(varDsc->lvVarIndex);
            }
#if USE_FASTCALL
            else if (varTypeIsGC(varDsc->TypeGet())             &&
                     (!varDsc->lvIsParam || varDsc->lvIsRegArg)  )
#else
            else if (varTypeIsGC(varDsc->TypeGet()) && !varDsc->lvIsParam)
#endif
            {
                gcTrkStkPtrLcls |= genVarIndexToBit(varDsc->lvVarIndex);
            }
        }
    }

#if defined(DEBUG) && USE_FASTCALL && !NST_FASTCALL
    genCallInProgress = false;
#endif

}

/*****************************************************************************/

// This function should be called whenever genStackLevel is changed.

#if TGT_x86

inline
void                Compiler::genOnStackLevelChanged()
{
#ifdef DEBUGGING_SUPPORT
    if (opts.compScopeInfo && info.compLocalVarsCount>0)
        siStackLevelChanged();
#endif
}

inline
void                Compiler::genSinglePush(bool isRef)
{
    genStackLevel += sizeof(void*);
    genOnStackLevelChanged();
}

inline
void                Compiler::genSinglePop()
{
    genStackLevel -= sizeof(void*);
    genOnStackLevelChanged();
}

#else

inline
void                Compiler::genOnStackLevelChanged()  {}
inline
void                Compiler::genSinglePush(bool isRef) {}
inline
void                Compiler::genSinglePop()            {}

#endif

void                Compiler::genChangeLife(VARSET_TP newLife DEBUGARG(GenTreePtr tree))
{
    unsigned        varNum;
    LclVarDsc   *   varDsc;

    VARSET_TP       deadMask;

    VARSET_TP       lifeMask;
    VARSET_TP        chgMask;

    unsigned        begNum;
    unsigned        endNum;

#ifdef  DEBUG
    if (verbose&&0) printf("[%08X] Current life %s -> %s\n", tree, genVS2str(genCodeCurLife), genVS2str(newLife));
#endif

    /* The following isn't 100% correct but it works often enough to be useful */

    assert((int)newLife != 0xDDDDDDDD);

    /* We should only be called when the live set has actually changed */

    assert(genCodeCurLife != newLife);

    /* Figure out which variables are becoming live/dead at this point */

    deadMask = ( genCodeCurLife & ~newLife);
    lifeMask = (~genCodeCurLife &  newLife);

    /* Can't simultaneously become live and dead at the same time */

    assert((deadMask | lifeMask) != 0);
    assert((deadMask & lifeMask) == 0);

    /* Compute the new pointer stack variable mask */

    gcVarPtrSetCur = newLife & gcTrkStkPtrLcls;

    /* Compute the 'changing state' mask */

    chgMask  = (deadMask | lifeMask) & genCodeCurRvm;

    /* Assume we'll iterate through the entire variable table */

    begNum = 0;
    endNum = lvaCount;

#if 0

    /* If there are lots of variables to visit, try to limit the search */

    if  (endNum > 8)
    {
        /* Try to start with a higher variable# */

        if  (!(chgMask & 0xFF))
        {
            begNum = 8;

            if  (!(chgMask & 0xFFFF))
            {
                begNum = 16;

                if  (!(chgMask & 0xFFFFFF))
                {
                    begNum = 24;
                }
            }
        }
    }

#endif

    // CONSIDER: Why not simply store the set of register variables in
    // CONSIDER: each tree node, along with gtLiveSet. That way we can
    // CONSIDER: change this function to a single assignment.

    for (varNum = begNum, varDsc = lvaTable + begNum;
         varNum < endNum && chgMask;
         varNum++       , varDsc++)
    {
        VARSET_TP       varBit;
        unsigned        regBit;

        /* Ignore the variable if it's not being tracked or is not in a register */

        if  (!varDsc->lvTracked)
            continue;
        if  (!varDsc->lvRegister)
            continue;

        /* Ignore the variable if it's not changing state here */

        varBit = genVarIndexToBit(varDsc->lvVarIndex);
        if  (!(chgMask & varBit))
            continue;

        assert(varDsc->lvType != TYP_DOUBLE);

        /* Remove this variable from the 'interesting' bit set */

        chgMask &= ~varBit;

        /* Get hold of the appropriate register bit(s) */

        regBit = genRegMask(varDsc->lvRegNum);

        if  (isRegPairType(varDsc->lvType) && varDsc->lvOtherReg != REG_STK)
            regBit |= genRegMask(varDsc->lvOtherReg);

        /* Is the variable becoming live or dead? */

        if  (deadMask & varBit)
        {
#ifdef  DEBUG
            if  (verbose) printf("[%08X]: var #%2u[%2u] in reg %s is becoming dead\n", tree, varNum, varDsc->lvVarIndex, compRegVarName(varDsc->lvRegNum));
            //printf("[%08X]: var #[%2u] in reg %2u is becoming dead\n", varNum, varDsc->lvVarIndex, varDsc->lvRegNum);

#endif
            assert((rsMaskVars &  regBit) != 0);
                    rsMaskVars &=~regBit;
        }
        else
        {
#ifdef  DEBUG
            if  (verbose) printf("[%08X]: var #%2u[%2u] in reg %s is becoming live\n", tree, varNum, varDsc->lvVarIndex, compRegVarName(varDsc->lvRegNum));
            //printf("[%08X]: var #[%2u] in reg %2u is becoming live\n", varNum, varDsc->lvVarIndex, varDsc->lvRegNum);

#endif
            assert((rsMaskVars &  regBit) == 0);
                    rsMaskVars |= regBit;
        }
    }

    genCodeCurLife = newLife;

#ifdef DEBUGGING_SUPPORT
    if (opts.compScopeInfo && !opts.compDbgCode && info.compLocalVarsCount>0)
        siUpdate();
#endif
}

/*****************************************************************************
 *
 *  The variable found in the deadMask are dead, update the liveness globals
 *  genCodeCurLife, gcVarPtrSetCur, rsMaskVars, gcRegGCrefSetCur, gcRegByrefSetCur
 */

void                Compiler::genDyingVars(VARSET_TP  commonMask,
                                           GenTreePtr opNext)
{
    unsigned        varNum;
    LclVarDsc   *   varDsc;
    VARSET_TP       varBit;
    unsigned        regBit;
    VARSET_TP       deadMask = commonMask & ~opNext->gtLiveSet;

    if (!deadMask)
        return;

    //
    // Consider the case in which the opNext is a GT_LCL_VAR
    // The liveness set of opNext->gtLiveSet will not include
    // this local variable, so we must remove it from deadmask
    //

    // We don't expect any LCL to have been bashed into REG yet */
    assert(opNext->gtOper != GT_REG_VAR);

    if (opNext->gtOper == GT_LCL_VAR)
    {
        varNum = opNext->gtLclVar.gtLclNum;
        varDsc = lvaTable + varNum;

        // Is this an enregistered tracked local var
        if (varDsc->lvRegister && varDsc->lvTracked)
        {
            varBit = genVarIndexToBit(varDsc->lvVarIndex);

            /* Remove this variable from the 'deadMask' bit set */
            deadMask &= ~varBit;

            /* if deadmask is now empty then return */
            if (!deadMask)
                return;
        }
    }

    /* iterate through the variable table */

    unsigned  begNum  = 0;
    unsigned  endNum  = lvaCount;

    for (varNum = begNum, varDsc = lvaTable + begNum;
         varNum < endNum && deadMask;
         varNum++       , varDsc++)
    {
        /* Ignore the variable if it's not being tracked or is not in a register */

        if  (!varDsc->lvRegister || !varDsc->lvTracked)
            continue;

        /* Ignore the variable if it's not a dying var */

        varBit = genVarIndexToBit(varDsc->lvVarIndex);

        if  (!(deadMask & varBit))
            continue;

        assert(varDsc->lvType != TYP_DOUBLE);

        /* Remove this variable from the 'deadMask' bit set */

        deadMask &= ~varBit;

        /* Get hold of the appropriate register bit(s) */

        regBit = genRegMask(varDsc->lvRegNum);

        if  (isRegPairType(varDsc->lvType) && varDsc->lvOtherReg != REG_STK)
            regBit |= genRegMask(varDsc->lvOtherReg);

#ifdef  DEBUG
        if  (verbose) printf("var #%2u[%2u] in reg %s is a dyingVar\n",
                             varNum, varDsc->lvVarIndex, compRegVarName(varDsc->lvRegNum));
#endif
        assert((genCodeCurLife &  varBit) != 0);

        genCodeCurLife &=~varBit;

        assert(((gcTrkStkPtrLcls  &  varBit) == 0) ||
               ((gcVarPtrSetCur   &  varBit) != 0)    );

        gcVarPtrSetCur &=~varBit;

        assert((rsMaskVars &  regBit) != 0);

        rsMaskVars &=~regBit;

        gcMarkRegSetNpt(regBit);
     }
}

/*****************************************************************************
 *
 *  Change the given enregistered local variable node to a register variable node
 */

inline
void                Compiler::genBashLclVar(GenTreePtr tree, unsigned     varNum,
                                                             LclVarDsc *  varDsc)
{
    assert(tree->gtOper == GT_LCL_VAR);
    assert(varDsc->lvRegister);

    if  (isRegPairType(varDsc->lvType))
    {
        /* Check for the case of a variable narrowed to 'int' */

        if  (isRegPairType(tree->gtType))
        {
            tree->gtRegPair = gen2regs2pair(varDsc->lvRegNum, varDsc->lvOtherReg);
            tree->gtFlags  |= GTF_REG_VAL;

            return;
        }

        assert(tree->gtFlags & GTF_VAR_NARROWED);
        assert(tree->gtType == TYP_INT);
    }
    else
    {
        assert(isRegPairType(tree->gtType) == false);
    }

    /* Enregistered FP variables are marked elsewhere */

#ifdef  DEBUG
    if  (tree->gtType == TYP_DOUBLE)
        printf("ERROR: %08X not marked as REG_VAR [var #%u]\n", tree, varNum);
#endif

    assert(tree->gtType != TYP_DOUBLE);

    /* It's a register variable -- modify the node */

    tree->ChangeOper(GT_REG_VAR);
    tree->gtFlags             |= GTF_REG_VAL;
    tree->gtRegNum             =
    tree->gtRegVar.gtRegNum    = varDsc->lvRegNum;
    tree->gtRegVar.gtRegVar    = varNum;
}

/*****************************************************************************
 *
 *  Record the fact that the flags register has a value that reflects the
 *  contents of the given register.
 */

inline
void                Compiler::genFlagsEqualToReg(regNumber reg, bool allFlags)
{
    genFlagsEqBlk = genEmitter->emitCurBlock();
    genFlagsEqOfs = genEmitter->emitCurOffset();
    genFlagsEqAll = allFlags;
    genFlagsEqReg = reg;

    /* previous setting of flags by a var becomes invalid */

    genFlagsEqVar = 0xFFFFFFFF;
}

/*****************************************************************************
 *
 *  Record the fact that the flags register has a value that reflects the
 *  contents of the given local variable.
 */

inline
void                Compiler::genFlagsEqualToVar(unsigned  var, bool allFlags)
{
    genFlagsEqBlk = genEmitter->emitCurBlock();
    genFlagsEqOfs = genEmitter->emitCurOffset();
    genFlagsEqAll = allFlags;
    genFlagsEqVar = var;

    /* previous setting of flags by a register becomes invalid */

    genFlagsEqReg = REG_NA;
}

/*****************************************************************************
 *
 *  Return an indication of whether the flags register is set to the current
 *  value of the given register/variable. The return value is as follows:
 *
 *      0   ..  nothing
 *      1   ..  the zero flag is  set
 *      2   ..  all the flags are set
 */

inline
int                 Compiler::genFlagsAreReg(regNumber reg)
{
    if  (genFlagsEqBlk == genEmitter->emitCurBlock () &&
         genFlagsEqOfs == genEmitter->emitCurOffset())
    {
        if  (genFlagsEqReg == reg)
            return  1 + (int)genFlagsEqAll;
    }

    return  0;
}

inline
int                 Compiler::genFlagsAreVar(unsigned  var)
{
    if  (genFlagsEqBlk == genEmitter->emitCurBlock () &&
         genFlagsEqOfs == genEmitter->emitCurOffset())
    {
        if  (genFlagsEqVar == var)
            return  1 + (int)genFlagsEqAll;
    }

    return  0;
}

/*****************************************************************************
 *
 *  Generate code that will set the given register to the integer constant.
 */

void                Compiler::genSetRegToIcon(regNumber     reg,
                                              long          val,
                                              var_types     type)
{
    assert(!varTypeIsGC(type) || val==NULL);

    /* Does the reg already hold this constant? */

    if  (!rsIconIsInReg(val, reg))
    {
        rsTrackRegIntCns(reg, val);

#if     TGT_x86

        if  (val)
            inst_RV_IV(INS_mov, reg, val, type);
        else
            inst_RV_RV(INS_xor, reg, reg, type);

#else

        if  (val >= IMMED_INT_MIN && val <= IMMED_INT_MAX)
        {
            genEmitter->emitIns_R_I   (INS_mov_imm,
                                       emitTypeSize(type),
                                       (emitRegs)reg,
                                       val);
        }
        else
        {
            genEmitter->emitIns_R_LP_I((emitRegs)reg,
                                        emitTypeSize(type),
                                        val);
        }

#endif

    }

    gcMarkRegPtrVal(reg, type);
}

/*****************************************************************************/
#if     TGT_x86
/*****************************************************************************
 *
 *  Add the given constant to the specified register.
 */

void                Compiler::genIncRegBy(GenTreePtr    tree,
                                          regNumber     reg,
                                          long          ival,
                                          var_types     dstType,
                                          bool          ovfl)
{

    /* First check to see if we can generate inc or dec instruction(s) */
    if (!ovfl)
    {
        emitAttr    size = emitTypeSize(dstType);

        switch (ival)
        {
        case 2:
            inst_RV(INS_inc, reg, dstType, size);
        case 1:
            inst_RV(INS_inc, reg, dstType, size);

            tree->gtFlags |= GTF_ZF_SET;
            genFlagsEqualToReg(reg, false);
            goto UPDATE_LIVENESS;

        case -2:
            inst_RV(INS_dec, reg, dstType, size);
        case -1:
            inst_RV(INS_dec, reg, dstType, size);

            tree->gtFlags |= GTF_ZF_SET;
            genFlagsEqualToReg(reg, false);
            goto UPDATE_LIVENESS;
        }
    }

    inst_RV_IV(INS_add, reg, ival, dstType);

    // UNDONE, too late for IE4 tree->gtFlags |= GTF_CC_SET;

    genFlagsEqualToReg(reg, true);

UPDATE_LIVENESS:

    rsTrackRegTrash(reg);

    gcMarkRegSetNpt(genRegMask(reg));
    if (varTypeIsGC(tree->TypeGet()))
        gcMarkRegSetByref(genRegMask(reg));
}

/*****************************************************************************
 *
 *  Subtract the given constant from the specified register.
 *  Should only be used for unsigned sub with overflow. Else
 *  genIncRegBy() can be used using -ival. We shouldnt use genIncRegBy()
 *  for these cases as the flags are set differently, and the following
 *  check for overflow wont work correctly.
 */

void                Compiler::genDecRegBy(GenTreePtr    tree,
                                          regNumber     reg,
                                          long          ival)
{
    assert((tree->gtFlags & GTF_OVERFLOW) && (tree->gtFlags & GTF_UNSIGNED));
    assert(tree->gtType == TYP_INT);

    rsTrackRegTrash(reg);

    assert(!varTypeIsGC(tree->TypeGet()));
    gcMarkRegSetNpt(genRegMask(reg));

    inst_RV_IV(INS_sub, reg, ival, TYP_INT);

    // UNDONE, too late for IE4 tree->gtFlags |= GTF_CC_SET;

    genFlagsEqualToReg(reg, true);
}

/*****************************************************************************
 *
 *  Multiply the specified register by the given value.
 */

void                Compiler::genMulRegBy(GenTreePtr tree, regNumber reg, long ival, var_types dstType)
{
    assert(genActualType(dstType) == TYP_INT);

    rsTrackRegTrash(reg);

    if (dstType == TYP_INT)
    {
        switch (ival)
        {
        case 1:
            return;

        case 2:
            inst_RV_SH(INS_shl, reg, 1);
            tree->gtFlags |= GTF_ZF_SET;
            return;

        case 4:
            inst_RV_SH(INS_shl, reg, 2);
            tree->gtFlags |= GTF_ZF_SET;
            return;

        case 8:
            inst_RV_SH(INS_shl, reg, 3);
            tree->gtFlags |= GTF_ZF_SET;
            return;
        }
    }

    inst_RV_TT_IV(INS_imul, reg, tree, ival);
}

/*****************************************************************************
 *
 *  Adjust the stack pointer by the given value; assumes that this follows
 *  a call so only callee-saved registers (and registers that may hold a
 *  return value) are used at this point.
 */

void                Compiler::genAdjustSP(int delta)
{
    if  (delta == sizeof(int))
        inst_RV   (INS_pop, REG_ECX, TYP_INT);
    else
        inst_RV_IV(INS_add, REG_ESP, delta);
}

/*****************************************************************************/
#endif//TGT_x86
/*****************************************************************************/
#if     TGT_SH3
/*****************************************************************************
 *
 *  Add the given constant to the specified register.
 */

void                Compiler::genIncRegBy(GenTreePtr    tree,
                                          regNumber     reg,
                                          long          ival,
                                          var_types     dstType,
                                          bool          ovfl)
{
    assert(dstType == TYP_INT && "only allow ints for now");

    if  (ival >= IMMED_INT_MIN && ival <= IMMED_INT_MAX)
    {
        genEmitter->emitIns_R_I(INS_add_imm,
                                emitTypeSize(dstType),
                                (emitRegs)reg,
                                ival);
    }
    else
    {
        regNumber       rgt;

#if REDUNDANT_LOAD

        /* Is the constant already in some register? */

        rgt = rsIconIsInReg(ival);

        if  (rgt == REG_NA)
#endif
        {
            rgt = rsPickReg();

            genSetRegToIcon(rgt, ival, dstType);
        }

        genEmitter->emitIns_R_R(INS_add, emitTypeSize(dstType), (emitRegs)reg,
                                                                (emitRegs)rgt);
    }

    rsTrackRegTrash(reg);
}

/*****************************************************************************/

void                Compiler::genDecRegBy(GenTreePtr    tree,
                                          regNumber     reg,
                                          long          ival)
{
    assert(!"NYI for RISC");
}

/*****************************************************************************/
#endif//TGT_SH3
/*****************************************************************************
 *
 *  Compute the value 'tree' into a register that's in 'needReg' (or any free
 *  register if 'needReg' is 0). Note that 'needReg' is just a recommendation
 *  unless 'mustReg' is non-zero. If 'freeReg' is 0, we mark the register the
 *  value ends up in as being used.
 *
 *  The only way to guarantee that the result will end up in a register that
 *  is trashable is to pass zero for 'mustReg' and non-zero for 'freeOnly'.
 */

void                Compiler::genComputeReg(GenTreePtr    tree,
                                            unsigned      needReg,
                                            bool          mustReg,
                                            bool          freeReg,
                                            bool          freeOnly)
{
    regNumber       reg;
    regNumber       rg2;

    assert(tree->gtType != TYP_VOID);

#if CPU_HAS_FP_SUPPORT
    assert(genActualType(tree->gtType) == TYP_INT   ||
           genActualType(tree->gtType) == TYP_REF   ||
                         tree->gtType  == TYP_BYREF);
#else
    assert(genActualType(tree->gtType) == TYP_INT   ||
           genActualType(tree->gtType) == TYP_REF   ||
                         tree->gtType  == TYP_BYREF ||
           genActualType(tree->gtType) == TYP_FLOAT);
#endif

    /* Generate the value, hopefully into the right register */

    genCodeForTree(tree, needReg);
    assert(tree->gtFlags & GTF_REG_VAL);
    reg = tree->gtRegNum;

    /* Did the value end up in an acceptable register? */

    if  (mustReg && needReg && !(genRegMask(reg) & needReg))
    {
        /* Not good enough to satisfy the caller's orders */

        rg2 = rsGrabReg(needReg);
    }
    else
    {
        /* Do we have to end up with a free register? */

        if  (!freeOnly)
            goto REG_OK;

        /* Did we luck out and the value got computed into an unused reg? */

        if  (genRegMask(reg) & rsRegMaskFree())
            goto REG_OK;

        /* Register already in use, so spill previous value */

        if (mustReg && needReg && (genRegMask(reg) & needReg))
        {
            rg2 = rsGrabReg(needReg);
            if (rg2 == reg)
            {
                gcMarkRegPtrVal(reg, tree->TypeGet());
                tree->gtRegNum = reg;
                goto REG_OK;
            }
        }
        else
        {
            /* OK, let's find a trashable home for the value */

            rg2 = rsPickReg(needReg);
        }
    }

    assert(reg != rg2);

    /* Remember that the new register is being used */

#ifdef  SET_USED_REG_SET_DURING_CODEGEN
    tree->gtUsedRegs |= genRegMask(rg2);
#endif

    /* Update the value in the target register */

    rsTrackRegCopy(rg2, reg);

    // ISSUE: Could the 'rsPickReg()' call above ever spill 'reg' ?

#if TGT_x86

    inst_RV_RV(INS_mov, rg2, reg, tree->TypeGet());

#else

    genEmitter->emitIns_R_R(INS_mov, emitActualTypeSize(tree->TypeGet()),
                                     (emitRegs)rg2,
                                     (emitRegs)reg);

#endif

    /* The value has been transferred to 'reg' */

    gcMarkRegSetNpt(genRegMask(reg));
    gcMarkRegPtrVal(rg2, tree->TypeGet());

    /* The value is now in an appropriate register */

    tree->gtRegNum = reg = rg2;

REG_OK:

    /* Does the caller want us to mark the register as used? */

    if  (!freeReg)
    {
        /* In case we're computing a value into a register variable */

        genUpdateLife(tree);

        /* Mark the register as 'used' */

        rsMarkRegUsed(tree);
    }
}

/*****************************************************************************
 *
 *  Same as genComputeReg(), the only difference being that the result is
 *  guaranteed to end up in a trashable register.
 */

inline
void                Compiler::genCompIntoFreeReg(GenTreePtr   tree,
                                                 unsigned     needReg,
                                                 bool         freeReg)
{
    genComputeReg(tree, needReg, false, freeReg, true);
}

/*****************************************************************************
 *
 *  The value 'tree' was earlier computed into a register; free up that
 *  register (but also make sure the value is presently in a register).
 */

void                Compiler::genReleaseReg(GenTreePtr    tree)
{
    if  (tree->gtFlags & GTF_SPILLED)
    {
        /* The register has been spilled -- reload it */

        rsUnspillReg(tree, 0, false);
        return;
    }

    rsMarkRegFree(genRegMask(tree->gtRegNum));
}

/*****************************************************************************
 *
 *  The value 'tree' was earlier computed into a register. Check whether that
 *  register has been spilled (and reload it if so), and if 'keepReg' is 0,
 *  free the register.
 */

void                Compiler::genRecoverReg(GenTreePtr    tree,
                                            unsigned      needReg,
                                            bool          keepReg)
{
    if  (tree->gtFlags & GTF_SPILLED)
    {
        /* The register has been spilled -- reload it */

        rsUnspillReg(tree, needReg, keepReg);
        return;
    }

    /* Free the register if the caller desired so */

    if  (!keepReg)
    {
        rsMarkRegFree(genRegMask(tree->gtRegNum));
    }
    else
    {
        assert(rsMaskUsed & genRegMask(tree->gtRegNum));
    }
}


/*****************************************************************************
 *
 * Move one half of a register pair to it's new regPair(half).
 */

inline
void               Compiler::genMoveRegPairHalf(GenTreePtr  tree,
                                                regNumber   dst,
                                                regNumber   src,
                                                int         off)
{

#if TGT_x86

    if  (src == REG_STK)
    {
        assert(tree->gtOper == GT_LCL_VAR);
        inst_RV_TT(INS_mov, dst, tree, off);
    }
    else
    {
        rsTrackRegCopy     (dst, src);
        inst_RV_RV(INS_mov, dst, src, TYP_INT);
    }

#else

    if  (src == REG_STK)
    {
        assert(tree->gtOper == GT_LCL_VAR);
        assert(!"need non-x86 code to load reg pair half from frame");
    }
    else
    {
        rsTrackRegCopy     (dst, src);

        genEmitter->emitIns_R_R(INS_mov, EA_4BYTE, (emitRegs)dst,
                                                       (emitRegs)src);
    }

#endif

}

/*****************************************************************************
 *
 *  The given long value is in a register pair, but it's not an acceptable
 *  one. We have to move the value into a register pair in 'needReg' (if
 *  non-zero) or the pair 'newPair' (when 'newPair != REG_PAIR_NONE').
 *
 *  Important note: if 'needReg' is non-zero, we assume the current pair
 *  has not been marked as free. If, OTOH, 'newPair' is specified, we
 *  assume that the current register pair is marked as used and free it.
 */

void                Compiler::genMoveRegPair(GenTreePtr  tree,
                                             unsigned    needReg,
                                             regPairNo   newPair)
{
    regPairNo       oldPair;

    regNumber       oldLo;
    regNumber       oldHi;
    regNumber       newLo;
    regNumber       newHi;

    /* Either a target set or a specific pair may be requested */

    assert((needReg != 0) != (newPair != REG_PAIR_NONE));

    /* Get hold of the current pair */

    oldPair = tree->gtRegPair; assert(oldPair != newPair);

    /* Are we supposed to move to a specific pair? */

    if  (newPair != REG_PAIR_NONE)
    {
        unsigned        oldMask = genRegPairMask(oldPair);

        unsigned         loMask = genRegMask(genRegPairLo(newPair));
        unsigned         hiMask = genRegMask(genRegPairHi(newPair));

        unsigned        overlap = oldMask & (loMask|hiMask);

        /* First lock any registers that are in both pairs */

        assert((rsMaskUsed &  overlap) == overlap);
        assert((rsMaskLock &  overlap) == 0);
                rsMaskLock |= overlap;

        /* Make sure any additional registers we need are free */

        if  ((loMask & rsMaskUsed) != 0 &&
             (loMask & oldMask   ) == 0)
        {
            rsGrabReg(loMask);
        }

        if  ((hiMask & rsMaskUsed) != 0 &&
             (hiMask & oldMask   ) == 0)
        {
            rsGrabReg(hiMask);
        }

        /* Unlock those registers we have temporarily locked */

        assert((rsMaskUsed &  overlap) == overlap);
        assert((rsMaskLock &  overlap) == overlap);
                rsMaskLock -= overlap;

        /* We can now free the old pair */

        rsMarkRegFree(oldMask);
    }
    else
    {
        /* Pick the new pair based on the caller's stated preference */

        newPair = rsGrabRegPair(needReg);
    }

    /* Move the values from the old pair into the new one */

    oldLo = genRegPairLo(oldPair);
    oldHi = genRegPairHi(oldPair);
    newLo = genRegPairLo(newPair);
    newHi = genRegPairHi(newPair);

    assert(newLo != REG_STK && newHi != REG_STK);

    /* Careful - the register pairs might overlap */

    if  (newLo == oldLo)
    {
        /* The low registers are identical, just move the upper half */

        assert(newHi != oldHi);
        genMoveRegPairHalf(tree, newHi, oldHi, sizeof(int));
    }
    else
    {
        /* The low registers are different, are the upper ones the same? */

        if  (newHi == oldHi)
        {
            /* Just move the lower half, then */
            genMoveRegPairHalf(tree, newLo, oldLo, 0);
        }
        else
        {
            /* Both sets are different - is there an overlap? */

            if  (newLo == oldHi)
            {
                /* Are high and low simply swapped ? */

                if  (newHi == oldLo)
                {
                    rsTrackRegSwap(newLo, oldLo);
#if TGT_x86
                    inst_RV_RV    (INS_xchg, newLo, oldLo);
#else
                    assert(!"need non-x86 code");
#endif
                }
                else
                {
                    /* New lower == old higher, so move higher half first */

                    assert(newHi != oldLo);
                    genMoveRegPairHalf(tree, newHi, oldHi, sizeof(int));
                    genMoveRegPairHalf(tree, newLo, oldLo, 0);

                }
            }
            else
            {
                /* Move lower half first */
                genMoveRegPairHalf(tree, newLo, oldLo, 0);
                genMoveRegPairHalf(tree, newHi, oldHi, sizeof(int));
            }
        }
    }
    /* Record the fact that we're switching to another pair */

    tree->gtRegPair   = newPair;
#ifdef  SET_USED_REG_SET_DURING_CODEGEN
    tree->gtUsedRegs |= genRegPairMask(newPair);
#endif
}

/*****************************************************************************
 *
 *  Compute the value 'tree' into a register pair that's in 'needReg' (or any
 *  free register pair if 'needReg' is 0). Note that 'needReg' is merely a
 *  recommendation. If 'freeReg' is 0, we mark both registers the value ends
 *  up in as being used.
 */

void                Compiler::genComputeRegPair(GenTreePtr    tree,
                                                unsigned      needReg,
                                                regPairNo     needRegPair,
                                                bool          freeReg,
                                                bool          freeOnly)
{
    unsigned        regMask;
    regPairNo       regPair;
    unsigned        tmpMask;
    regNumber       rLo;
    regNumber       rHi;

#if SPECIAL_DOUBLE_ASG
    assert(genTypeSize(tree->TypeGet()) == genTypeSize(TYP_LONG));
#else
    assert(isRegPairType(tree->gtType));
#endif

    assert(needRegPair == REG_PAIR_NONE ||
           needReg     == genRegPairMask(needRegPair));

    /* Generate the value, hopefully into the right register pair */

    regMask = needReg;
    if  (freeOnly)
        regMask = rsRegMaskFree();

    genCodeForTreeLng(tree, regMask);

    assert(tree->gtFlags & GTF_REG_VAL);

    regPair = tree->gtRegPair;
    tmpMask = genRegPairMask(regPair);

    rLo     = genRegPairLo(regPair);
    rHi     = genRegPairHi(regPair);

    /* At least one half is in a real register */

    assert(rLo != REG_STK || rHi != REG_STK);

    /* Did the value end up in an acceptable register pair? */

    if  (needRegPair != REG_PAIR_NONE)
    {
        if  (needRegPair != regPair)
        {
            // UNDONE: avoid the hack below!!!!
            /* This is a hack. If we specify a regPair for genMoveRegPair */
            /* it expects the source pair being marked as used */
            rsMarkRegPairUsed(tree);
            genMoveRegPair(tree, 0, needRegPair);
        }
    }
    else if  (freeOnly)
    {
        /* Do we have to end up with a free register pair? */

        /* Something might have gotten freed up above */

        regMask = rsRegMaskFree();

        /* Did the value end up in a free register pair? */

        if  ((tmpMask & regMask) != tmpMask || rLo == REG_STK || rHi == REG_STK)
        {
            if (genOneBitOnly(regMask))
                regMask = rsRegMaskCanGrab();

            /* We'll have to move the value to a free (trashable) pair */

            genMoveRegPair(tree, regMask, REG_PAIR_NONE);
        }
    }

    /* Make sure that the value is in "real" registers*/

    else if (rLo == REG_STK)
    {
        /* Get one of the desired registers, but exclude rHi */

        if (regMask == 0)
            regMask = rsRegMaskFree();

        regNumber reg = rsPickReg(regMask & ~tmpMask);

#if TGT_x86
        inst_RV_TT(INS_mov, reg, tree, 0);
#else
        assert(!"need non-x86 code");
#endif

        tree->gtRegPair = gen2regs2pair(reg, rHi);

        rsTrackRegTrash(reg);
        gcMarkRegSetNpt(genRegMask(reg));
    }
    else if (rHi == REG_STK)
    {
        /* Get one of the desired registers, but exclude rHi */
        if (regMask == 0)
            regMask = rsRegMaskFree();

        regNumber reg = rsPickReg(regMask & ~tmpMask);

#if TGT_x86
        inst_RV_TT(INS_mov, reg, tree, EA_4BYTE);
#else
        assert(!"need non-x86 code");
#endif

        tree->gtRegPair = gen2regs2pair(rLo, reg);

        rsTrackRegTrash(reg);
        gcMarkRegSetNpt(genRegMask(reg));
    }

    /* Does the caller want us to mark the register as used? */

    if  (!freeReg)
    {
        /* In case we're computing a value into a register variable */

        genUpdateLife(tree);

        /* Mark the register as 'used' */

        rsMarkRegPairUsed(tree);
    }
}

/*****************************************************************************
 *
 *  Same as genComputeRegPair(), the only difference being that the result
 *  is guaranteed to end up in a trashable register pair.
 */

inline
void                Compiler::genCompIntoFreeRegPair(GenTreePtr   tree,
                                                     unsigned     needReg,
                                                     bool         freeReg)
{
    genComputeRegPair(tree, needReg, REG_PAIR_NONE, freeReg, true);
}

/*****************************************************************************
 *
 *  The value 'tree' was earlier computed into a register pair; free up that
 *  register pair (but also make sure the value is presently in a register
 *  pair).
 */

void                Compiler::genReleaseRegPair(GenTreePtr    tree)
{
    if  (tree->gtFlags & GTF_SPILLED)
    {
        /* The register has been spilled -- reload it */

        rsUnspillRegPair(tree, 0, false);
        return;
    }

    rsMarkRegFree(genRegPairMask(tree->gtRegPair));
}

/*****************************************************************************
 *
 *  The value 'tree' was earlier computed into a register pair. Check whether
 *  either register of that pair has been spilled (and reload it if so), and
 *  if 'keepReg' is 0, free the register pair.
 */

void                Compiler::genRecoverRegPair(GenTreePtr    tree,
                                                regPairNo     regPair,
                                                bool          keepReg)
{
    if  (tree->gtFlags & GTF_SPILLED)
    {
        unsigned        regMask = (regPair == REG_PAIR_NONE) ? 0
                                                             : genRegPairMask(regPair);

        /* The register pair has been spilled -- reload it */

        rsUnspillRegPair(tree, regMask, true);
    }

    /* Does the caller insist on the value being in a specific place? */

    if  (regPair != REG_PAIR_NONE && regPair != tree->gtRegPair)
    {
        /* No good -- we'll have to move the value to a new place */

        genMoveRegPair(tree, 0, regPair);

        /* Mark the pair as used if appropriate */

        if  (keepReg)
            rsMarkRegPairUsed(tree);

        return;
    }

    /* Free the register pair if the caller desired so */

    if  (!keepReg)
        rsMarkRegFree(genRegPairMask(tree->gtRegPair));
}

/*****************************************************************************
 *
 *  Compute the given long value into the specified register pair; don't mark
 *  the register pair as used.
 */

inline
void                Compiler::genEvalIntoFreeRegPair(GenTreePtr tree, regPairNo regPair)
{
    genComputeRegPair(tree, genRegPairMask(regPair), regPair, false);
    genRecoverRegPair(tree,                regPair , false);
}

/*****************************************************************************
 *
 *  Take an address expression and try to find the best set of components to
 *  form an address mode; returns non-zero if this is successful.
 *
 *  'fold' specifies if it is OK to fold the array index which hangs off
 *  a GT_NOP node.
 *
 *  If successful, the parameters will be set to the following values:
 *
 *      *rv1Ptr     ...     register
 *      *rv2Ptr     ...     optional register
 *  #if SCALED_ADDR_MODES
 *      *mulPtr     ...     optional multiplier (2/4/8) for rv2
 *  #endif
 *      *cnsPtr     ...     integer constant [optional]
 *
 *  The 'mode' parameter may have one of the following values:
 *
 *  #if LEA_AVAILABLE
 *         +1       ...     we're trying to compute a value via 'LEA'
 *  #endif
 *
 *          0       ...     we're trying to form an address mode
 *
 *         -1       ...     we're generating code for an address mode,
 *                          and thus the address must already form an
 *                          address mode (without any further work)
 *
 *  IMPORTANT NOTE: This routine doesn't generate any code, it merely
 *                  identifies the components that might be used to
 *                  form an address mode later on.
 */

bool                Compiler::genCreateAddrMode(GenTreePtr    addr,
                                                int           mode,
                                                bool          fold,
                                                unsigned      regMask,
#if!LEA_AVAILABLE
                                                var_types     optp,
#endif
                                                bool        * revPtr,
                                                GenTreePtr  * rv1Ptr,
                                                GenTreePtr  * rv2Ptr,
#if SCALED_ADDR_MODES
                                                unsigned    * mulPtr,
#endif
                                                unsigned    * cnsPtr,
                                                bool          nogen)
{
    bool            rev;

    GenTreePtr      rv1 = 0;
    GenTreePtr      rv2 = 0;

    GenTreePtr      op1;
    GenTreePtr      op2;

    unsigned        cns;
#if SCALED_ADDR_MODES
    unsigned        mul;
#endif

    GenTreePtr      tmp;

#if     TGT_x86

    /*
        The following indirections are address modes on the x86:

            [reg                   ]
            [reg             + icon]

            [reg2 +     reg1       ]
            [reg2 +     reg1 + icon]

            [reg2 + 2 * reg1       ]
            [reg2 + 4 * reg1       ]
            [reg2 + 8 * reg1       ]

            [reg2 + 2 * reg1 + icon]
            [reg2 + 4 * reg1 + icon]
            [reg2 + 8 * reg1 + icon]
     */

#elif   TGT_SH3

    /*
        The following indirections are address modes on the SH-3:

            [reg1       ]
            [reg1 + icon]

            [reg1 + reg2]       for            32-bit operands

            [ R0  + reg2]       for  8-bit and 16-bit operands
     */

#endif

    /* All indirect address modes require the address to be an addition */

    if  (addr->gtOper != GT_ADD)
        return false;

    // Cant use indirect addressing mode as we need to check for overflow
    // Also, cant use 'lea' as it doesnt set the flags

    if (addr->gtOverflow())
        return false;

    /* Need to keep track of which sub-operand is to be evaluated first */

    rev = false;

    op1 = addr->gtOp.gtOp1;
    op2 = addr->gtOp.gtOp2;

    if  (addr->gtFlags & GTF_REVERSE_OPS)
    {
        op1 = addr->gtOp.gtOp2;
        op2 = addr->gtOp.gtOp1;

        rev = !rev;
    }

    /*
        A complex address mode can combine the following operands:

            op1     ...     base address
            op2     ...     optional scaled index
#if SCALED_ADDR_MODES
            mul     ...     optional multiplier (2/4/8) for rv2
#endif
            cns     ...     optional displacement

        Here we try to find such a set of operands and arrange for these
        to sit in registers.
     */

    cns = 0;
#if SCALED_ADDR_MODES
    mul = 0;
#endif

AGAIN:

    /* Check both operands as far as being register variables */

    if  (mode != -1)
    {
        if (op1->gtOper == GT_LCL_VAR) genMarkLclVar(op1);
        if (op2->gtOper == GT_LCL_VAR) genMarkLclVar(op2);
    }

    /* Special case: keep constants as 'op2' */

    if  (op1->gtOper == GT_CNS_INT)
    {
        tmp = op1;
              op1 = op2;
                    op2 = tmp;

        rev = !rev;
    }

    /* Check for an addition of a constant */

    if  (op2->gtOper == GT_CNS_INT)
    {
        /* We're adding a constant */

        cns += op2->gtIntCon.gtIconVal;

        /* Can (and should) we use "add reg, icon" ? */

        if  ((op1->gtFlags & GTF_REG_VAL) && mode == 1 && !nogen)
        {
            regNumber       reg1 = op1->gtRegNum;

            if  (regMask == 0 || (regMask & genRegMask(reg1)) &&
                 genRegTrashable(reg1, addr))
            {
                // In case genMarkLclVar(op1) bashed it above and it is
                // the last use of the variable.

                genUpdateLife(op1);

                /* 'reg1' is trashable, so add "icon" into it */

                genIncRegBy(op1, reg1, cns, addr->TypeGet());

                //UNDONE: too late for IE4
                //addr->gtFlags   |= (GTF_REG_VAL | (op1->gtFlags & (GTF_ZF_SET|GTF_CC_SET)));

                addr->gtFlags   |= GTF_REG_VAL;
                addr->gtRegNum   = reg1;
#ifdef  SET_USED_REG_SET_DURING_CODEGEN
                addr->gtUsedRegs = op1->gtUsedRegs;
#endif

                genUpdateLife(addr);

                gcMarkRegSetNpt(genRegMask(reg1));
                return true;
            }
        }

        /* Inspect the operand the constant is being added to */

        switch (op1->gtOper)
        {
        case GT_ADD:

            if (op1->gtOverflow())
                return false; // Need overflow check

            op2 = op1->gtOp.gtOp2;
            op1 = op1->gtOp.gtOp1;

            goto AGAIN;

#if     SCALED_ADDR_MODES

        case GT_MUL:
            if (op1->gtOverflow())
                return false; // Need overflow check

        case GT_LSH:

            mul = op1->IsScaledIndex();
            if  (mul)
            {
                /* We can use "[mul*rv2 + icon]" */

                rv1 = 0;
                rv2 = op1->gtOp.gtOp1;

                goto FOUND_AM;
            }

#endif

        }

        /* The best we can do is "[rv1 + icon]" */

        rv1 = op1;
        rv2 = 0;

        goto FOUND_AM;
    }

    /* Does op1 or op2 already sit in a register? */

    if      (op2->gtFlags & GTF_REG_VAL)
    {
        /* op2 is sitting in a register, we'll inspect op1 */

        rv1 = op2;
        rv2 = op1;

        rev = !rev;
    }
    else if (op1->gtFlags & GTF_REG_VAL)
    {
        /* op1 is sitting in a register, we'll inspect op2 */

        rv1 = op1;
        rv2 = op2;
    }
    else
    {
        /* Neither op1 nor op2 are sitting in a register right now */

        switch (op1->gtOper)
        {
        case GT_ADD:

            if (op1->gtOverflow())
                return false; // Need overflow check

            if  (op1->gtOp.gtOp2->gtOper == GT_CNS_INT)
            {
                cns += op1->gtOp.gtOp2->gtIntCon.gtIconVal;
                op1  = op1->gtOp.gtOp1;

                goto AGAIN;
            }

            break;

#if     SCALED_ADDR_MODES

        case GT_MUL:

            if (op1->gtOverflow())
                return false; // Need overflow check

        case GT_LSH:

            mul = op1->IsScaledIndex();
            if  (mul)
            {
                /* 'op1' is a scaled value */

                rv1 = op2;
                rv2 = op1->gtOp.gtOp1;

                rev = !rev;

                goto FOUND_AM;
            }

            break;

#endif

        case GT_NOP:

            if  (!nogen)
                break;

            op1 = op1->gtOp.gtOp1;
            goto AGAIN;

        case GT_COMMA:

            if  (!nogen)
                break;

            op1 = op1->gtOp.gtOp2;
            goto AGAIN;
        }

        switch (op2->gtOper)
        {
        case GT_ADD:

            if (op2->gtOverflow())
                return false; // Need overflow check

            if  (op2->gtOp.gtOp2->gtOper == GT_CNS_INT)
            {
                cns += op2->gtOp.gtOp2->gtIntCon.gtIconVal;
                op2  = op2->gtOp.gtOp1;

                goto AGAIN;
            }

            break;

#if     SCALED_ADDR_MODES

        case GT_MUL:

            if (op2->gtOverflow())
                return false; // Need overflow check

        case GT_LSH:

            mul = op2->IsScaledIndex();
            if  (mul)
            {
                /* 'op2' is a scaled value */

                rv1 = op1;
                rv2 = op2->gtOp.gtOp1;

                goto FOUND_AM;
            }

            break;

#endif

        case GT_NOP:

            if  (!nogen)
                break;

            op2 = op2->gtOp.gtOp1;
            goto AGAIN;

        case GT_COMMA:

            if  (!nogen)
                break;

            op2 = op2->gtOp.gtOp2;
            goto AGAIN;
        }

        goto ADD_OP12;
    }

    /* Is 'op1' an addition or a scaled value? */

    switch (op1->gtOper)
    {
    case GT_ADD:

        if (op1->gtOverflow())
            return false; // Need overflow check

        if  (op1->gtOp.gtOp2->gtOper == GT_CNS_INT)
        {
            cns += op1->gtOp.gtOp2->gtIntCon.gtIconVal;
            op1  = op1->gtOp.gtOp1;
            goto AGAIN;
        }

        break;

#if     SCALED_ADDR_MODES

    case GT_MUL:

        if (op1->gtOverflow())
            return false; // Need overflow check

    case GT_LSH:

        mul = op1->IsScaledIndex();
        if  (mul)
        {
            rv1 = op2;
            rv2 = op1->gtOp.gtOp1;

            rev = !rev;

            goto FOUND_AM;
        }

        break;

#endif

    }

    /* Is 'op2' an addition or a scaled value? */

    switch (op2->gtOper)
    {
    case GT_ADD:

        if (op2->gtOverflow()) return false; // Need overflow check

        if  (op2->gtOp.gtOp2->gtOper == GT_CNS_INT)
        {
            cns += op2->gtOp.gtOp2->gtIntCon.gtIconVal;
            op2  = op2->gtOp.gtOp1;
            goto AGAIN;
        }

        break;

#if     SCALED_ADDR_MODES

    case GT_MUL:

        if (op2->gtOverflow()) return false; // Need overflow check

    case GT_LSH:

        mul = op2->IsScaledIndex();
        if  (mul)
        {
            rv1 = op1;
            rv2 = op2->gtOp.gtOp1;

            goto FOUND_AM;
        }

        break;

#endif

    }

ADD_OP12:

    /* The best we can do "[rv1 + rv2]" */

    rv1 = op1;
    rv2 = op2;

FOUND_AM:

    if  (rv2)
    {
        /* Make sure a GC address doesn't end up in 'rv2' */

        if  (varTypeIsGC(rv2->TypeGet()))
        {
            assert(rv1 && !varTypeIsGC(rv1->TypeGet()));

            tmp = rv1;
                  rv1 = rv2;
                        rv2 = tmp;

            rev = !rev;
        }

        /* Special case: constant array index (that is range-checked) */

        if  (fold)
        {
            long        tmpMul;
            GenTreePtr  index;

            if ((rv2->gtOper == GT_MUL || rv2->gtOper == GT_LSH) &&
                (rv2->gtOp.gtOp2->gtOper == GT_CNS_INT))
            {
                /* For valuetype arrays where we cant use the scaled address
                   mode, rv2 will point to the scaled index. So we have to do
                   more work */

                long cnsVal = rv2->gtOp.gtOp2->gtIntCon.gtIconVal;
                if (rv2->gtOper == GT_MUL)
                    tmpMul = cnsVal;
                else
                    tmpMul = 1 << cnsVal;

                index = rv2->gtOp.gtOp1;
            }
            else
            {
                /* May be a simple array. rv2 will points to the actual index */

                index = rv2;
                tmpMul = mul;
            }

            /* Get hold of the array index and see if it's a constant */

            if ((index->gtOper == GT_NOP) && (index->gtFlags & GTF_NOP_RNGCHK) &&
                (index->gtOp.gtOp1->gtOper == GT_CNS_INT))
            {
                /* Get hold of the index value */

                long ixv = index->gtOp.gtOp1->gtIntCon.gtIconVal;

                /* Scale the index if necessary */

#if SCALED_ADDR_MODES
                if  (tmpMul) ixv *= tmpMul;
#endif

                /* Add the scaled index to the offset value */

                cns += ixv;

                /* There is no scaled operand any more */

#if SCALED_ADDR_MODES
                mul = 0;
#endif
                rv2 = 0;
            }
        }
    }

    // We shouldnt have [rv2*1 + cns] - this is equivalent to [rv1 + cns]
    assert(rv1 || mul != 1);

    /* Success - return the various components to the caller */

    *revPtr = rev;
    *rv1Ptr = rv1;
    *rv2Ptr = rv2;
#if SCALED_ADDR_MODES
    *mulPtr = mul;
#endif
    *cnsPtr = cns;

    return  true;
}

/*****************************************************************************/
#if     TGT_x86
/*****************************************************************************
 *
 *  Return non-zero if the given tree can be computed via an addressing mode,
 *  such as "[ebx+esi*4+20]". If the expression isn't an address mode already
 *  try to make it so (but we don't try 'too hard' to accomplish this). If we
 *  end up needing a register (or two registers) to hold some part(s) of the
 *  address, we return the use register mask via '*useMask'.
 */

bool                Compiler::genMakeIndAddrMode(GenTreePtr   addr,
                                                 GenTreePtr   oper,
                                                 bool         compute,
                                                 unsigned     regMask,
                                                 bool         keepReg,
                                                 bool         takeAll,
                                                 unsigned *   useMaskPtr,
                                                 bool         deferOK)
{
    bool            rev;
    GenTreePtr      rv1;
    GenTreePtr      rv2;
    bool            operIsChkdArr;  // is oper an array which needs rng-chk
    GenTreePtr      scaledIndex;    // If scaled addressing mode cant be used

#ifdef  SET_USED_REG_SET_DURING_CODEGEN
    unsigned        regs;
#endif
    unsigned        anyMask = RBM_ALL;

    unsigned        cns;
    unsigned        mul;

    GenTreePtr      tmp;
    long            ixv = LONG_MAX; // unset value

    /* Deferred address mode forming NYI for x86 */

    assert(deferOK == false);

    assert(oper == NULL || oper->gtOper == GT_IND);
    operIsChkdArr =  (oper != NULL) && ((oper->gtFlags & GTF_IND_RNGCHK) != 0);

    /* Is the complete address already sitting in a register? */

    if  (addr->gtFlags & GTF_REG_VAL)
    {
#ifdef  SET_USED_REG_SET_DURING_CODEGEN
        regs = addr->gtUsedRegs;
#endif
        rv1  = addr;
        rv2 = scaledIndex = 0;
        cns  = 0;

        goto YES;
    }

    /* Is it an absolute address */

    if (addr->gtOper == GT_CNS_INT)
    {
        rv1 = rv2 = scaledIndex = 0;
        cns = addr->gtIntCon.gtIconVal;

        goto YES;
    }

    /* Is there a chance of forming an address mode? */

    if  (!genCreateAddrMode(addr, compute, false, regMask, &rev, &rv1, &rv2, &mul, &cns))
    {
        /* This better not be an array index or we're hosed */
        assert(!operIsChkdArr);

        return  false;
    }

   /*  For scaled array access, RV2 may not be pointing to the index of the
       array if the CPU does not support the needed scaling factor.  We will
       make it point to the actual index, and scaledIndex will point to
       the scaled value */

    scaledIndex = NULL;

    if  (operIsChkdArr && rv2->gtOper != GT_NOP)
    {
        assert((rv2->gtOper == GT_MUL || rv2->gtOper == GT_LSH) &&
               !rv2->IsScaledIndex());

        scaledIndex = rv2;
        rv2 = scaledIndex->gtOp.gtOp1;

        assert(scaledIndex->gtOp.gtOp2->gtOper == GT_CNS_INT &&
               rv2->gtOper == GT_NOP);
    }

    /* Has the address already been computed? */

    if  (addr->gtFlags & GTF_REG_VAL)
    {
        if  (compute)
            return  true;

        rv1         = addr;
        rv2         = 0;
        scaledIndex = 0;
        goto YES;
    }

    /*
        Here we have the following operands:

            rv1     .....       base address
            rv2     .....       offset value        (or NULL)
            mul     .....       multiplier for rv2  (or NULL)
            cns     .....       additional constant (or NULL)

        The first operand must be present (and be an address) unless we're
        computing an expression via 'LEA'. The scaled operand is optional,
        but must not be a pointer if present.
     */

    assert(rv2 == 0 || !varTypeIsGC(rv2->TypeGet()));

#if CSELENGTH

    /* Do we have an array length CSE definition? */

    if  (operIsChkdArr && oper->gtInd.gtIndLen)
    {
        GenTreePtr      len = oper->gtInd.gtIndLen;

        assert(len->gtOper == GT_LCL_VAR ||
               len->gtOper == GT_REG_VAR || len->gtOper == GT_ARR_RNGCHK);

        if  (len->gtOper == GT_ARR_RNGCHK)
        {
            anyMask &= ~genCSEevalRegs(len);
            regMask &= anyMask;

            /* Make sure the register mask is actually useful */

            if  (!(regMask & rsRegMaskFree()))
                regMask = anyMask;
        }
    }

#endif

    /*-------------------------------------------------------------------------
     *
     * Make sure both rv1 and rv2 (if present) are in registers
     *
     */

    // Trivial case : Is either rv1 or rv2 a NULL ?

    if  (!rv2)
    {
        /* A single operand, make sure it's in a register */

#ifdef  SET_USED_REG_SET_DURING_CODEGEN
        regs = rv1->gtUsedRegs;
#endif

        genCodeForTree(rv1, regMask);
        goto DONE_REGS;
    }
    else if (!rv1)
    {
        /* A single (scaled) operand, make sure it's in a register */

#ifdef  SET_USED_REG_SET_DURING_CODEGEN
        regs = rv2->gtUsedRegs;
#endif

        genCodeForTree(rv2, 0);
        goto DONE_REGS;
    }

    /* At this point, both rv1 and rv2 are non-NULL and we have to make sure
      they are in registers */

    assert(rv1 && rv2);

#ifdef  SET_USED_REG_SET_DURING_CODEGEN
    regs = rv1->gtUsedRegs | rv2->gtUsedRegs;
#endif

    /*  If we have to check a constant array index, compare it against
        the array dimension (see below) but then fold the index with a
        scaling factor (if any) and additional offset (if any).
     */

    if  (rv2->gtOper == GT_NOP && (rv2->gtFlags & GTF_NOP_RNGCHK))
    {
        /* We must have a range-checked index operation */

        assert(operIsChkdArr);

        /* Get hold of the index value and see if it's a constant */

        if  (rv2->gtOp.gtOp1->gtOper == GT_CNS_INT)
        {
            tmp = rv2->gtOp.gtOp1;
            rv2 = scaledIndex = 0;
            ixv = tmp->gtIntCon.gtIconVal;

            /* Add the scaled index into the added value */

            if  (mul)
                cns += ixv * mul;
            else
                cns += ixv;

            /* Make sure 'rv1' is in a register */

            genCodeForTree(rv1, regMask);

            goto DONE_REGS;
        }
    }

    if      (rv1->gtFlags & GTF_REG_VAL)
    {
        /* op1 already in register - how about op2? */

        if  (rv2->gtFlags & GTF_REG_VAL)
        {
            /* great - both operands are in registers already */

            goto DONE_REGS;
        }

        /* rv1 is in a register, but rv2 isn't */

        goto GEN_RV2;
    }
    else if (rv2->gtFlags & GTF_REG_VAL)
    {
        /* rv2 is in a register, but rv1 isn't */

        assert(rv2->gtOper == GT_REG_VAR);

        /* Generate the for the first operand */

        genCodeForTree(rv1, regMask);

        goto DONE_REGS;
    }
    else
    {
        /* If we are trying to use addr-mode for an arithmetic operation,
           and we dont have atleast 2 registers, just refuse.
           For arrays, we had better have 2 registers or we will
           barf below on genCodeForTree(rv1 or rv2) */

        if (!operIsChkdArr)
        {

            unsigned canGrab = rsRegMaskCanGrab();

            if (canGrab == 0)
            {
                // No registers available. Bail
                return false;
            }
            else if (genOneBitOnly(canGrab))
            {
                // Just one register available. Either rv1 or rv2 should be
                // an enregisterd var

                // @TODO : Check if rv1 or rv2 is an enregisterd variable
                // Dont bash it else, you have to be careful about
                // marking the register as used
                return  false;
            }
        }
    }

    if  (compute && !cns)
        return  false;

    /* Make sure we preserve the correct operand order */

    if  (rev)
    {
        /* Generate the second operand first */

        genCodeForTree(rv2, regMask);
        rsMarkRegUsed(rv2, oper);

        /* Generate the first operand second */

        genCodeForTree(rv1, regMask);
        rsMarkRegUsed(rv1, oper);

        /* Free up both operands in the right order (they might be
           re-marked as used below)
        */
        rsLockUsedReg  (genRegMask(rv1->gtRegNum));
        genReleaseReg(rv2);
        rsUnlockUsedReg(genRegMask(rv1->gtRegNum));
        genReleaseReg(rv1);
    }
    else
    {
        /* Get the first operand into a register */

        genCodeForTree(rv1, anyMask & ~rv2->gtRsvdRegs);

    GEN_RV2:

        /* Here the 'rv1' operand is in a register but 'rv2' isn't */

        assert(rv1->gtFlags & GTF_REG_VAL);

        /* Hang on to the first operand */

        rsMarkRegUsed(rv1, oper);

        /* Generate the second operand as well */

        genCodeForTree(rv2, regMask);
        rsMarkRegUsed(rv2, oper);

        /* Free up both operands in the right order (they might be
           re-marked as used below)
        */
        rsLockUsedReg  (genRegMask(rv2->gtRegNum));
        genReleaseReg(rv1);
        rsUnlockUsedReg(genRegMask(rv2->gtRegNum));
        genReleaseReg(rv2);
    }

    /*-------------------------------------------------------------------------
     *
     * At this piont, both rv1 and rv2 (if present) are in registers
     *
     */

DONE_REGS:

    /* Remember which registers are needed for the address */

#ifdef  SET_USED_REG_SET_DURING_CODEGEN
    addr->gtUsedRegs = regs;
#endif

    /* We must verify that 'rv1' and 'rv2' are both sitting in registers */

    if  (rv1 && !(rv1->gtFlags & GTF_REG_VAL)) return false;
    if  (rv2 && !(rv2->gtFlags & GTF_REG_VAL)) return false;

YES:

    // @HACK - *(intVar1+intVar1) causes problems as we
    // call rsMarkRegUsed(op1) and rsMarkRegUsed(op2). So the calling function
    // needs to know that it has to call rsFreeReg(reg1) twice. We cant do
    // that currently as we return a single mask in useMaskPtr.

    if (keepReg && oper && rv1 && rv2 &&
        (rv1->gtFlags & rv2->gtFlags & GTF_REG_VAL))
    {
        if (rv1->gtRegNum == rv2->gtRegNum)
        {
            assert(!operIsChkdArr);
            return false;
        }
    }

    /* Check either register operand to see if it needs to be saved */

    if  (rv1)
    {
        assert(rv1->gtFlags & GTF_REG_VAL);
//      genUpdateLife(rv1);

        if (keepReg)
        {
            rsMarkRegUsed(rv1, oper);
        }
        else
        {
            /* If the register holds an address, mark it */

            gcMarkRegPtrVal(rv1->gtRegNum, rv1->TypeGet());
        }
    }

    if  (rv2)
    {
        assert(rv2->gtFlags & GTF_REG_VAL);
//      genUpdateLife(rv2);

        if (keepReg)
            rsMarkRegUsed(rv2, oper);
    }

    if  (deferOK)
    {
        assert(!scaledIndex);
        return  true;
    }

    /* Is this an array index that needs to be range-checked? */

    if  (operIsChkdArr)
    {
        genRangeCheck(oper, rv1, rv2, ixv, regMask, keepReg);

        /* For valuetype arrays where we cant use a scaled addressing mode,
           we need to materialize the scaled index so that the element
           can be accessed by a non-scaled addressing mode */

        if (scaledIndex)
        {
            assert(rv2->gtFlags & GTF_REG_VAL);
            if (keepReg)
                genReleaseReg(rv2);

            if (rev)
            {
                /* If rv1 is evaluated after rv2, then evaluating scaledIndex
                   here will reset the liveness to that of rv2. So bash it.
                   It is safe to do this as scaledIndex is simple GT_MUL node
                   and rv2 is guaranteed to be in a register */

                assert((scaledIndex->gtOper == GT_MUL || scaledIndex->gtOper == GT_LSH) &&
                       (scaledIndex->gtOp.gtOp1 == rv2) &&
                       (rv2->gtFlags & GTF_REG_VAL));
                assert(scaledIndex->gtLiveSet == rv2->gtLiveSet);
                scaledIndex->gtLiveSet = rv2->gtLiveSet = genCodeCurLife;
            }

            genCodeForTree(scaledIndex, regMask);
            if (keepReg)
                rsMarkRegUsed(scaledIndex, oper);
        }
    }
    else
    {
        assert(!scaledIndex);

        /*  Special case: a class member might reside at a very large offset,
            and access to such a member via a null pointer may not be trapped
            by the hardware on some architectures/platforms.

            To get around this, if the member offset is larger than some safe
            (but hopefully large) value, we generate "cmp al, [addr]" to make
            sure we try to access the base address of the object and thus trap
            any use of a null pointer.

            For now, we pick an arbitrary offset limit of 32K.
         */

#ifndef NOT_JITC
        // In jitc, eeGetFieldOffset() returns mdMemberRef, which has high byte set
        size_t offset = (cns & 0x80FFFFFFL);
#else
        size_t offset =  cns;
#endif

        if  (compute != 1 && offset > 32*1024)
        {
            // For C indirections, the address can be in any form.
            // rv1 may not be the base, and rv2 the index.
            // Consider (0x400000 + 8*i) --> rv1=NULL, rv2=i, mul=8, and
            // cns=0x400000. So the base is actually in 'cns'
            // So not much we can do.

            if (varTypeIsGC(addr->TypeGet()))
            {
                /* Make sure we have an address */

                assert(varTypeIsGC(rv1->gtType));

                /* Generate "cmp al, [addr]" to trap null pointers */

                inst_RV_AT(INS_cmp, EA_1BYTE, TYP_BYTE, REG_EAX, rv1, 0);
            }
        }
    }

    /* Compute the set of registers the address depends on */

    unsigned        useMask = 0;

    if (rv1)
    {
        assert(rv1->gtFlags & GTF_REG_VAL);
        useMask |= genRegMask(rv1->gtRegNum);
    }

    if (scaledIndex)
    {
        assert(scaledIndex->gtFlags & GTF_REG_VAL);
        useMask |= genRegMask(scaledIndex->gtRegNum);
    }
    else if (rv2)
    {
        assert(rv2->gtFlags & GTF_REG_VAL);
        useMask |= genRegMask(rv2->gtRegNum);
    }

    /* Tell the caller which registers we need to hang on to */

    *useMaskPtr = useMask;

    return true;
}

/*****************************************************************************/
#if CSELENGTH
/*****************************************************************************
 *
 *  Check the passed in GT_IND for an array length operand. If it exists and
 *  it's been converted to a CSE def/use, process it appropriately.
 *
 *  Upon return the array length value will either be NULL (which means the
 *  array length needs to be fetched from the array), or it will be a simple
 *  local/register variable reference (which means it's become a CSE use).
 */

regNumber           Compiler::genEvalCSELength(GenTreePtr   ind,
                                               GenTreePtr   adr,
                                               GenTreePtr   ixv)
{
    GenTreePtr      len;

    assert(ind);

    if  (ind->gtOper == GT_ARR_RNGCHK)
    {
        len = ind;
        ind = 0;
    }
    else
    {
        assert(ind->gtOper == GT_IND);
        assert(ind->gtFlags & GTF_IND_RNGCHK);

        len = ind->gtInd.gtIndLen; assert(len);
    }

    /* We better have an array length node here */

    assert(len->gtOper == GT_ARR_RNGCHK);

    /* Do we have a CSE expression or not? */

    len = len->gtArrLen.gtArrLenCse;
    if  (!len)
    {
        if  (ind)
            ind->gtInd.gtIndLen = NULL;

        return  REG_COUNT;
    }

    /* If we have an address/index, make sure they're marked as "in use" */

    assert(ixv == 0 || ((ixv->gtFlags & GTF_REG_VAL) != 0 &&
                        (ixv->gtFlags & GTF_SPILLED) == 0));
    assert(adr == 0 || ((adr->gtFlags & GTF_REG_VAL) != 0 &&
                        (adr->gtFlags & GTF_SPILLED) == 0));

    switch (len->gtOper)
    {
    case GT_LCL_VAR:

        /* Has this local been enregistered? */

        if (!genMarkLclVar(len))
        {
            /* Not a register variable, do we have any free registers? */

            if  (!riscCode || rsFreeNeededRegCount(rsRegMaskFree()) == 0)
            {
                /* Too bad, just delete the ref as its not worth it */

                if  (ind)
                    ind->gtInd.gtIndLen = NULL;

                genUpdateLife(len);

                return  REG_COUNT;
            }

            /* Loading from a frame var is better than [reg+4] ... */
        }

        /* Otherwise fall through */

    case GT_REG_VAR:

        genCodeForTree(len, 0);

        if  (ind)
            ind->gtInd.gtIndLen = 0;

        genUpdateLife(len);
        break;

    case GT_COMMA:
        {
            GenTreePtr  asg = len->gtOp.gtOp1;
            GenTreePtr  lcl = len->gtOp.gtOp2;

            GenTreePtr  cse = asg->gtOp.gtOp2;
            GenTreePtr  dst = asg->gtOp.gtOp1;

            regNumber   reg;

            /* This must be an array length CSE definition */

            assert(asg->gtOper == GT_ASG);

            assert(cse->gtOper == GT_NOP);
            assert(lcl->gtOper == GT_LCL_VAR);
            assert(dst->gtOper == GT_LCL_VAR);
            assert(dst->gtLclVar.gtLclNum ==
                   lcl->gtLclVar.gtLclNum);

            genUpdateLife(cse);

            /* Has the CSE temp been enregistered? */

            if  (genMarkLclVar(lcl))
            {
                bool        rsp = false;

                reg = lcl->gtRegVar.gtRegNum;

                /* Make sure the variable's register is available */

                if  (rsMaskUsed & genRegMask(reg))
                {
                    if  (reg == adr->gtRegNum)
                    {
                        /* Bad luck: address in same register as target */
#if 1
                        /* BUGBUG: why do we need to spill the address
                         * since this is the only purpose we computed it for? */

                        assert((adr->gtFlags & GTF_SPILLED) == 0);
                        assert((adr->gtFlags & GTF_REG_VAL) != 0);
                        rsSpillReg(reg);
                        assert((adr->gtFlags & GTF_REG_VAL) == 0);
                        assert((adr->gtFlags & GTF_SPILLED) != 0);

                        /* Value copied to spill temp but still in reg */

                        rsp = true;

                        /* Clear flag so that we can indirect through reg */

                        adr->gtFlags &= ~GTF_SPILLED;
                        adr->gtFlags |=  GTF_REG_VAL;
#endif
                    }
                    else
                    {
                        /* Simply spill the target register */

                        rsSpillReg(reg);
                    }
                }

                /* The CSE temp is     enregistered */

                inst_RV_AT(INS_mov, EA_4BYTE, TYP_INT, reg, adr, ARR_ELCNT_OFFS);

                /* If we've spilled the address, restore the flags */

                if  (rsp)
                {
                    adr->gtFlags |=  GTF_SPILLED;
                    adr->gtFlags &= ~GTF_REG_VAL;
                }

                /* Update the contents of the register */

                rsTrackRegTrash(reg);
                gcMarkRegSetNpt(genRegMask(reg));
                genUpdateLife(len);
            }
            else
            {
                /* The CSE temp is not enregistered; move via temp reg */

                regMaskTP adrRegMask = genRegMask(adr->gtRegNum);
                rsLockUsedReg(adrRegMask);

                reg = rsPickReg(RBM_ALL);

                rsUnlockUsedReg(adrRegMask);

                /* Generate "mov tmp, [rv1+ARR_ELCNT_OFFS]" */

                inst_RV_AT(INS_mov, EA_4BYTE, TYP_INT, reg, adr, ARR_ELCNT_OFFS);

                /* The register certainly doesn't contain a pointer */

//              genUpdateLife(cse);
                gcMarkRegSetNpt(genRegMask(reg));
                genUpdateLife(asg);

                /* The register now contains the variable value */

                rsTrackRegLclVar(reg, lcl->gtLclVar.gtLclNum);

                /* Now store the value in the CSE temp */

                inst_TT_RV(INS_mov, dst, reg);

                /* Remember that the value is in a register. However, since
                   the register has not been explicitly marked as used, we
                   need to be careful if reg gets spilled below. */

                lcl->gtFlags |= GTF_REG_VAL;
                lcl->gtRegNum = reg;
            }

            /* We've generated the assignment, now toss the CSE */

            if  (ind)
                ind->gtInd.gtIndLen = NULL;

            /* Is there an index value? */

            if  (ixv)
            {
                /* If the index value has been spilled, recover it */

                if  (ixv->gtFlags & GTF_SPILLED)
                {
                    rsUnspillReg(ixv, 0, true);

                    /* Is the CSE variable is not enregistered, then we used
                       rsTrackRegLclVar(). Check if the reg has been trashed. */

                    if (ixv->gtRegNum == reg)
                    {
                        lcl->gtFlags &= ~GTF_REG_VAL;
                        reg = REG_COUNT;
                    }
                }
            }

            return reg;
        }
        break;

    default:
#ifdef  DEBUG
        gtDispTree(len);
#endif
        assert(!"unexpected length on array range check");
    }

    assert(len->gtFlags & GTF_REG_VAL);

    return  len->gtRegNum;
}

/*****************************************************************************/
#endif//CSELENGTH
/*****************************************************************************
 *
 *  'oper' is an array index that needs to be range-checked.
 *  rv1 is the array.
 *  If rv2, then it is the index tree, else ixv is the constant index.
 */

void                Compiler::genRangeCheck(GenTreePtr  oper,
                                            GenTreePtr  rv1,
                                            GenTreePtr  rv2,
                                            long        ixv,
                                            unsigned    regMask,
                                            bool        keepReg)
{
    assert((oper->gtOper == GT_IND) && (oper->gtFlags & GTF_IND_RNGCHK));

    /* We must have 'rv1' in a register at this point */

    assert(rv1);
    assert(rv1->gtFlags & GTF_REG_VAL);
    assert(!rv2 || ixv == LONG_MAX);

    /* Is the array index a constant value? */

    if  (rv2)
    {
        unsigned    tmpMask;

        /* Make sure we have the values we expect */
        assert(rv2);
        assert(rv2->gtOper == GT_NOP);
        assert(rv2->gtFlags & GTF_REG_VAL);
        assert(rv2->gtFlags & GTF_NOP_RNGCHK);
        assert(oper && oper->gtOper == GT_IND && (oper->gtFlags & GTF_IND_RNGCHK));

#if CSELENGTH

        if  (oper->gtInd.gtIndLen)
        {
            if  (oper->gtInd.gtIndLen->gtArrLen.gtArrLenCse)
            {
                regNumber       lreg;

                /* Make sure we don't lose the address/index values */

                assert(rv1->gtFlags & GTF_REG_VAL);
                assert(rv2->gtFlags & GTF_REG_VAL);

                if  (!keepReg)
                {
                    rsMarkRegUsed(rv1, oper);
                    rsMarkRegUsed(rv2, oper);
                }

                /* Try to get the array length into a register */

                lreg = genEvalCSELength(oper, rv1, rv2);

                /* Has the array length become a CSE? */

                if  (lreg != REG_COUNT)
                {
                    /* Make sure the index is still in a register */

                    assert(rv2->gtFlags & GTF_REG_VAL);

                    if  (rv2->gtFlags & GTF_SPILLED)
                    {
                        /* The register has been spilled -- reload it */

                           rsLockReg(genRegMask(lreg));
                        rsUnspillReg(rv2, 0, false);
                         rsUnlockReg(genRegMask(lreg));
                    }

                    /* Compare the index against the array length */

                    inst_RV_RV(INS_cmp, rv2->gtRegNum, lreg);

                    /* Don't need the index for now */

                    genReleaseReg(rv2);

                    /* Free up the address (unless spilled) as well */

                    if  (rv1->gtFlags & GTF_SPILLED)
                    {
                        regNumber       xreg = rv2->gtRegNum;

                        /* The register has been spilled -- reload it */

                           rsLockReg(genRegMask(xreg));
                        rsUnspillReg(rv1, 0, false);
                         rsUnlockReg(genRegMask(xreg));
                    }
                    else
                    {
                        /* Release the address register */

                        genReleaseReg(rv1);

                        /* Hang on to the value if the caller desires so */

                        if (keepReg)
                        {
                            rsMarkRegUsed(rv1, oper);
                            rsMarkRegUsed(rv2, oper);
                        }

                        /* But note that rv1 is still a pointer */

                        gcMarkRegSetGCref(genRegMask(rv1->gtRegNum));
                    }

                    goto GEN_JAE;
                }

                /* Make sure the index/address are still around */

                if  (rv2->gtFlags & GTF_SPILLED)
                {
                    assert(!"rv2 spilled - can this ever happen?");
                }

                if  (rv1->gtFlags & GTF_SPILLED)
                {
                    /* Lock the index and unspill the address */

                    rsMaskLock |=  genRegMask(rv2->gtRegNum);
                    rsUnspillReg(rv1, 0, false);
                    rsMaskLock &= ~genRegMask(rv2->gtRegNum);
                }

                assert(rv1->gtFlags & GTF_REG_VAL);
                assert(rv1->gtType == TYP_REF);

                /* Release the registers */

                genReleaseReg(rv1);
                genReleaseReg(rv2);

                /* Hang on to the values if the caller desires so */

                if (keepReg)
                {
                    rsMarkRegUsed(rv1, oper);
                    rsMarkRegUsed(rv2, oper);
                }

                /* But note that rv1 is still a pointer */

                gcMarkRegSetGCref(genRegMask(rv1->gtRegNum));
            }
            else
            {
                oper->gtInd.gtIndLen = NULL;
            }
        }

        /*
         *  NOTE:   If length has not been cse'd, or the cse has not
         *          ended up in a register, then we use the array
         *          pointer already loaded at rv1.
         */

#endif

        /* Might it be useful to load the length into a register? */

        tmpMask = rsRegMaskFree() & ~(genRegMask(rv1->gtRegNum)|
                                      genRegMask(rv2->gtRegNum));

        if  (tmpMask &  regMask)
             tmpMask &= regMask;

        if  (riscCode && compCurBB->bbWeight > 1
                      && rsFreeNeededRegCount(tmpMask) != 0)
        {
            regNumber   reg = rsPickReg(tmpMask);

            /* Generate "mov tmp, [rv1+ARR_ELCNT_OFFS]" */

            inst_RV_AT(INS_mov, EA_4BYTE, TYP_INT, reg, rv1, ARR_ELCNT_OFFS);

            /* The register now contains trash */

            rsTrackRegTrash(reg);

            /* Generate "cmp rv2, reg" */

            inst_RV_RV(INS_cmp, rv2->gtRegNum, reg);
        }
        else
        {
            /* Generate "cmp rv2, [rv1+ARR_ELCNT_OFFS]" */

            inst_RV_AT(INS_cmp, EA_4BYTE, TYP_INT, rv2->gtRegNum, rv1, ARR_ELCNT_OFFS);
        }

#if CSELENGTH
    GEN_JAE:
#endif

        /* Generate "jae <fail_label>" */

        assert(oper->gtOper == GT_IND);
        assert(oper->gtInd.gtIndOp2);
        assert(oper->gtInd.gtIndOp2->gtOper == GT_LABEL);

        // UNDONE: The jump should not be "moveable" if within "try" block!!!

        inst_JMP(EJ_jae, oper->gtInd.gtIndOp2->gtLabel.gtLabBB, true, true, true);
    }
    else
    {
        /* Generate "cmp [rv1+ARR_ELCNT_OFFS], cns" */

        assert(oper && oper->gtOper == GT_IND && (oper->gtFlags & GTF_IND_RNGCHK));

#if CSELENGTH

        if  (oper->gtInd.gtIndLen)
        {
            if  (oper->gtInd.gtIndLen->gtArrLen.gtArrLenCse)
            {
                regNumber       lreg;

                /* Make sure we don't lose the index value */

                assert(rv1->gtFlags & GTF_REG_VAL);
                rsMarkRegUsed(rv1); // , oper);

                /* Try to get the array length into a register */

                lreg = genEvalCSELength(oper, rv1, NULL);

                /* Make sure the index is still in a register */

                if  (rv1->gtFlags & GTF_SPILLED)
                {
                    /* The register has been spilled -- reload it */

                    if  (lreg == REG_COUNT)
                    {
                        rsUnspillReg(rv1, 0, false);
                    }
                    else
                    {
                           rsLockReg(genRegMask(lreg));
                        rsUnspillReg(rv1, 0, false);
                         rsUnlockReg(genRegMask(lreg));
                    }
                }
                else
                {
                    /* Release the address register */

                    genReleaseReg(rv1);

                    /* But note that it still contains a pointer */

                    gcMarkRegSetGCref(genRegMask(rv1->gtRegNum));
                }

                assert(rv1->gtFlags & GTF_REG_VAL);

                /* Has the array length become a CSE? */

                if  (lreg != REG_COUNT)
                {
                    /* Compare the index against the array length */

                    inst_RV_IV(INS_cmp, lreg, ixv);

                    goto GEN_JBE;
                }
            }
            else
            {
                oper->gtInd.gtIndLen = NULL;
            }
        }

#endif
        /*
            If length has not been cse'd or genEvalCSELength()
            decided not to use it, we use the array pointer
            already loaded at rv1
         */

        inst_AT_IV(INS_cmp, EA_4BYTE, rv1, ixv, ARR_ELCNT_OFFS);

#if CSELENGTH
    GEN_JBE:
#endif

        /* Generate "jbe <fail_label>" */

        assert(oper->gtOper == GT_IND);
        assert(oper->gtOp.gtOp2);
        assert(oper->gtOp.gtOp2->gtOper == GT_LABEL);

        // UNDONE: The jump should not be "moveable" if within "try" block!!!

        inst_JMP(EJ_jbe, oper->gtOp.gtOp2->gtLabel.gtLabBB, true, true, true);
    }
}

/*****************************************************************************/
#endif//TGT_x86
/*****************************************************************************/
#if     TGT_RISC
/*****************************************************************************
 *
 *  Return non-zero if the given tree can be computed via an addressing mode,
 *  such as "[reg+20]" or "[rg1+rg2]". If the expression isn't an address
 *  mode already try to make it so (but we don't try 'too hard' to accomplish
 *  this). If we end up needing a register (or two registers) to hold some
 *  part(s) of the address, we return the use register mask via '*useMask'.
 */

bool                Compiler::genMakeIndAddrMode(GenTreePtr   addr,
                                                 GenTreePtr   oper,
                                                 bool         compute,
                                                 unsigned     regMask,
                                                 bool         keepReg,
                                                 bool         takeAll,
                                                 unsigned *   useMaskPtr,
                                                 bool         deferOK)
{
    bool            rev;
    GenTreePtr      rv1;
    GenTreePtr      rv2;

    unsigned        regs;
    unsigned        anyMask = RBM_ALL;

    unsigned        cns;
#if SCALED_ADDR_MODES
    unsigned        mul;
#endif

    GenTreePtr      tmp;
    long            ixv;
    bool            operIsChkdArr;  // is oper an array which needs rng-chk

#if!LEA_AVAILABLE
    var_types       optp = oper ? oper->TypeGet() : TYP_UNDEF;
#endif

#if TGT_SH3
    bool            useR0 = false;
#endif

    genAddressMode = AM_NONE;

    assert(oper == NULL || oper->gtOper == GT_IND);
    operIsChkdArr =  (oper != NULL) && ((oper->gtFlags & GTF_IND_RNGCHK) != 0);

    /* Is the complete address already sitting in a register? */

    if  (addr->gtFlags & GTF_REG_VAL)
    {
#ifdef  SET_USED_REG_SET_DURING_CODEGEN
        regs = addr->gtUsedRegs;
#endif
        rv1  = addr;
        rv2  = 0;
        cns  = 0;

        goto YES;
    }

    /* Is there a chance of forming an address mode? */

    if  (!genCreateAddrMode(addr,
                            compute,
                            false,
                            regMask,
#if!LEA_AVAILABLE
                            optp,
#endif
                            &rev,
                            &rv1,
                            &rv2,
#if SCALED_ADDR_MODES
                            &mul,
#endif
                            &cns))
    {
        /* This better not be an array index or we're hosed */
        assert(!operIsChkdArr);

        return  false;
    }

    /* Has the address already been computed? */

    if  (addr->gtFlags & GTF_REG_VAL)
    {
        if  (compute)
            return  true;

        rv1 = addr;
        rv2 = 0;

        goto YES;
    }

    /*
        Here we have the following operands:

            rv1     .....       base address
            rv2     .....       offset value        (or NULL)
#if SCALED_ADDR_MODES
            mul     .....       scaling of rv2      (or 0)
#endif
            cns     .....       additional constant (or 0)

        The first operand must be present (and be an address) unless we're
        computing an expression via 'LEA'. The scaled operand is optional,
        but must not be a pointer if present.
     */

#if CSELENGTH

    /* Do we have an array length CSE definition? */

    if  (operIsChkdArr && oper->gtInd.gtIndLen)
    {
        GenTreePtr      len = oper->gtInd.gtIndLen;

        assert(len->gtOper == GT_LCL_VAR ||
               len->gtOper == GT_REG_VAR || len->gtOper == GT_ARR_RNGCHK);

        if  (len->gtOper == GT_ARR_RNGCHK)
        {
            anyMask &= ~genCSEevalRegs(len);
            regMask &= anyMask;

            /* Make sure the register mask is actually useful */

            if  (!(regMask & rsRegMaskFree()))
                regMask = anyMask;
        }
    }

#endif

    /*-------------------------------------------------------------------------
     *
     * Make sure both rv1 and rv2 (if present) are in registers
     *
     */

    // Trivial case : Is either rv1 or rv2 a NULL ?

    if  (!rv2)
    {
        /* A single operand, make sure it's in a register */

#ifdef  SET_USED_REG_SET_DURING_CODEGEN
        regs = rv1->gtUsedRegs;
#endif

        genCodeForTree(rv1, regMask);
        goto DONE_REGS;
    }
#if SCALED_ADDR_MODES
    else if (!rv1)
    {
#ifdef  SET_USED_REG_SET_DURING_CODEGEN
        regs = rv2->gtUsedRegs;
#endif

        /* A single (scaled) operand, make sure it's in a register */

        genCodeForTree(rv2, 0);
        goto DONE_REGS;
    }

#endif

    /* At this point, both rv1 and rv2 are non-NULL and we have to make sure
       they are in registers */

    assert(rv1 && rv2);

#ifdef  SET_USED_REG_SET_DURING_CODEGEN
    regs = rv1->gtUsedRegs | rv2->gtUsedRegs;
#endif

#if TGT_SH3

    /* It's awfully convenient to use r0 for indexed access */

    useR0 = true;

    /* Are we allowed to use r0 and is it available? */

    if  ((regMask & rsRegMaskFree() & RBM_r00) || !deferOK)
    {
        // ISSUE: When is it good idea (and when not) to use r0 ?
    }
    else
    {
        /*
            We want to use R0 but it's not available and we were told that it was
            OK to defer creating the address mode, so let's give up for now .....
         */

        return  false;
    }

#endif

    /*
        If we have to check a constant array index, compare it against
        the array dimension (see below) but then fold the index with a
        scaling factor (if any) and additional offset (if any).
     */

    if  (rv2->gtOper == GT_NOP && (rv2->gtFlags & GTF_NOP_RNGCHK))
    {
        /* We must have a range-checked index operation */

        assert(operIsChkdArr);

        /* Get hold of the index value and see if it's a constant */

        if  (rv2->gtOp.gtOp1->gtOper == GT_CNS_INT)
        {
            tmp = rv2->gtOp.gtOp1;
            rv2 = 0;
            ixv = tmp->gtIntCon.gtIconVal;

            /* Add the scaled index into the added value */

#if SCALED_ADDR_MODES
            if  (mul) ixv *= mul;
#endif

            cns += ixv;

            /* Make sure 'rv1' is in a register */

            genCodeForTree(rv1, regMask);

            goto DONE_REGS;
        }
    }

    if      (rv1->gtFlags & GTF_REG_VAL)
    {
        /* op1 already in register - how about op2? */

        if  (rv2->gtFlags & GTF_REG_VAL)
        {
            /* great - both operands are in registers already */

            goto DONE_REGS;
        }

        /* rv1 is in a register, but rv2 isn't */

#if TGT_SH3

        /* On the SH-3, small indirection go better via r0 */

        if  (useR0)
            regMask = RBM_r00;

#endif

        goto GEN_RV2;
    }
    else if (rv2->gtFlags & GTF_REG_VAL)
    {
        /* rv2 is in a register, but rv1 isn't */

        assert(rv2->gtOper == GT_REG_VAR);

#if TGT_SH3

        /* On the SH-3, small indirection go better via r0 */

        if  (useR0)
            regMask = RBM_r00;

#endif

        /* Generate the for the first operand */

        genCodeForTree(rv1, regMask);

        goto DONE_REGS;
    }
    else
    {
        /* If we are trying to use addr-mode for an arithmetic operation,
           and we dont have atleast 2 registers, just refuse.
           For arrays, we had better have 2 registers or we will
           barf below on genCodeForTree(rv1 or rv2) */

        if (!operIsChkdArr)
        {

            unsigned canGrab = rsRegMaskCanGrab();

            if (canGrab == 0)
            {
                // No registers available. Bail
                return false;
            }
            else if (genOneBitOnly(canGrab))
            {
                // Just one register available. Either rv1 or rv2 should be
                // an enregisterd var

                // @TODO : Check if rv1 or rv2 is an enregisterd variable
                // Dont bash it else, you have to be careful about
                // marking the register as used
                return  false;
            }
        }
    }

    if  (compute && !cns)
        return  false;

    /* Make sure we preserve the correct operand order */

    if  (rev)
    {

#if TGT_SH3

        if  (useR0)
        {
            // UNDONE: Decide which operand to generate into r0

            anyMask = RBM_r00;
        }

#endif

        /* Generate the second operand first */

        genCodeForTree(rv2, regMask);
        rsMarkRegUsed(rv2, oper);

        /* Generate the first operand second */

        genCodeForTree(rv1, regMask);
        rsMarkRegUsed(rv1, oper);

        /* Free up both operands in the right order (they might be
           re-marked as used below)
        */

        rsLockUsedReg  (genRegMask(rv1->gtRegNum));
        genReleaseReg(rv2);
        rsUnlockUsedReg(genRegMask(rv1->gtRegNum));
        genReleaseReg(rv1);
    }
    else
    {

#if TGT_SH3

        if  (useR0)
        {
            // UNDONE: Decide which operand to generate into r0

            anyMask = RBM_r00;
        }

#endif

        /* Get the first operand into a register */

        genCodeForTree(rv1, anyMask & ~rv2->gtRsvdRegs);

    GEN_RV2:

        /* Here the 'rv1' operand is in a register but 'rv2' isn't */

        assert(rv1->gtFlags & GTF_REG_VAL);

        /* Hang on to the first operand */

        rsMarkRegUsed(rv1, oper);

        /* Generate the second operand as well */

        genCodeForTree(rv2, regMask);
        rsMarkRegUsed(rv2, oper);

        /* Free up both operands in the right order (they might be
           re-marked as used below)
        */
        rsLockUsedReg  (genRegMask(rv2->gtRegNum));
        genReleaseReg(rv1);
        rsUnlockUsedReg(genRegMask(rv2->gtRegNum));
        genReleaseReg(rv2);
    }

    /*-------------------------------------------------------------------------
     *
     * At this piont, both rv1 and rv2 (if present) are in registers
     *
     */

DONE_REGS:

    /* Remember which registers are needed for the address */

#ifdef  SET_USED_REG_SET_DURING_CODEGEN
    addr->gtUsedRegs = regs;
#endif

    /* We must verify that 'rv1' and 'rv2' are both sitting in registers */

    if  (rv1 && !(rv1->gtFlags & GTF_REG_VAL)) return false;
    if  (rv2 && !(rv2->gtFlags & GTF_REG_VAL)) return false;

#if TGT_SH3 && defined(DEBUG)

    /* If we decided we had to use R0, it better really be used */

    if  (useR0 && !deferOK)
    {
        assert(rv1 && rv2);

        assert(rv1->gtRegNum == REG_r00 ||
               rv2->gtRegNum == REG_r00);
    }

#endif

YES:

    // @HACK - *(intVar1+intVar1) causes problems as we
    // call rsMarkRegUsed(op1) and rsMarkRegUsed(op2). So the calling function
    // needs to know that it has to call rsFreeReg(reg1) twice. We cant do
    // that currently as we return a single mask in useMaskPtr.

    if (keepReg && oper && rv1 && rv2 &&
        (rv1->gtFlags & rv2->gtFlags & GTF_REG_VAL))
    {
        if (rv1->gtRegNum == rv2->gtRegNum)
        {
            assert(addr->gtFlags & GTF_NON_GC_ADDR);

            return false;
        }
    }

    /* Do we have a legal address mode combination? */

    if  (oper) oper->gtFlags &= ~GTF_DEF_ADDRMODE;

#if TGT_SH3

    /* Is there a non-zero displacement? */

    if  (cns)
    {
        /* Negative displacement are never allowed */

        if  (cns < 0)
            return  false;

        /* Can't have "dsp" or "rg1+rg2+dsp" as address modes */

        if  (rv1 == NULL)
            return  false;
        if  (rv2 != NULL)
            return  false;

        /* Make sure the displacement is withing range */
        /* [ISSUE: do we need to check alignment here?] */

        if  ((unsigned)cns >= 16U * genTypeSize(optp))
            return  false;

        genAddressMode = AM_IND_REG1_DISP;
        goto DONE_AM;
    }

    /* Do we have to use "R0" ? */

    if  (useR0)
    {
        /* We should have two operands and r0 should be free, right? */

        assert(rv1);
        assert(rv2);

        assert(rsRegMaskFree() & RBM_r00);

        /* Is either operand loaded into R0 ? */

        if  (rv1->gtRegNum != REG_r00 &&
             rv2->gtRegNum != REG_r00)
        {
            /* We'll need to load one operand into R0, should we do it now? */

            if  (deferOK && oper)
            {
                oper->gtFlags |= GTF_DEF_ADDRMODE;
            }
            else
            {
                /* Move one of the operands to R0 */

                // ISSUE: Which operand should be moved to R0????

                genComputeReg(rv1, RBM_r00, true, true, false);

                genAddressMode = AM_IND_REG1_REG0;
            }
        }
    }

DONE_AM:

#endif

    /* Check either register operand to see if it needs to be saved */

    if  (rv1)
    {
        assert(rv1->gtFlags & GTF_REG_VAL);

        if  (keepReg)
        {
            rsMarkRegUsed(rv1, oper);
        }
        else
        {
            /* Mark the register as holding an address */

            switch(rv1->gtType)
            {
            case TYP_REF:   gcMarkRegSetGCref(regMask); break;
            case TYP_BYREF: gcMarkRegSetByref(regMask); break;
            }
        }
    }

    if  (rv2)
    {
        assert(rv2->gtFlags & GTF_REG_VAL);

        if (keepReg)
            rsMarkRegUsed(rv2, oper);
    }

    if  (deferOK)
        return  true;

    /* Is this an array index that needs to be range-checked? */

    if  (operIsChkdArr)
    {
        genRangeCheck(oper, rv1, rv2, ixv, regMask, keepReg);
    }
    else
    {
        /*  Special case: a class member might reside at a very large offset,
            and access to such a member via a null pointer may not be trapped
            by the hardware on some architectures/platforms.

            To get around this, if the member offset is larger than some safe
            (but hopefully large) value, we generate "cmp al, [addr]" to make
            sure we try to access the base address of the object and thus trap
            any use of a null pointer.

            For now, we pick an arbitrary offset limit of 32K.
         */

#if !defined(NOT_JITC)
        // In jitc, eeGetFieldOffset() returns mdMemberRef, which has high byte set
        size_t offset = (cns & 0x80FFFFFFL);
#else
        size_t offset =  cns;
#endif

        if  (compute != 1 && offset > 32*1024)
        {
            if (addr->gtFlags & GTF_NON_GC_ADDR)
            {
                // For C indirections, the address can be in any form.
                // rv1 may not be the base, and rv2 the index.
                // Consider (0x400000 + 8*i) --> rv1=NULL, rv2=i, mul=8, and
                // cns=0x400000. So the base is actually in 'cns'
                // So we cant do anything.
            }
            else
            {
                /* Make sure we have an address */

                assert(rv1->gtType == TYP_REF);

                /* Generate "cmp al, [addr]" to trap null pointers */

//              inst_RV_AT(INS_cmp, 1, TYP_BYTE, REG_EAX, rv1, 0);
                assert(!"need non-x86 code");
            }
        }
    }

    /* Compute the set of registers the address depends on */

    unsigned        useMask = 0;

    if (rv1)
    {
        assert(rv1->gtFlags & GTF_REG_VAL);
        useMask |= genRegMask(rv1->gtRegNum);
    }

    if (rv2)
    {
        assert(rv2->gtFlags & GTF_REG_VAL);
        useMask |= genRegMask(rv2->gtRegNum);
    }

    /* Tell the caller which registers we need to hang on to */

    *useMaskPtr = useMask;

    return true;
}

#if CSELENGTH

regNumber           Compiler::genEvalCSELength(GenTreePtr   ind,
                                               GenTreePtr   adr,
                                               GenTreePtr   ixv,
                                               unsigned *   regMaskPtr)
{
    assert(!"NYI");
    return  REG_NA;
}

#endif

void                Compiler::genRangeCheck(GenTreePtr  oper,
                                            GenTreePtr  rv1,
                                            GenTreePtr  rv2,
                                            long        ixv,
                                            unsigned    regMask,
                                            bool        keepReg)
{
    assert(!"NYI");
}

/*****************************************************************************/
#endif//TGT_RISC
/*****************************************************************************
 *
 *  If an array length CSE is present and has been enregistered, return
 *  the register's mask; otherwise return 0.
 */

#if CSELENGTH

unsigned            Compiler::genCSEevalRegs(GenTreePtr tree)
{
    assert(tree->gtOper == GT_ARR_RNGCHK);

    if  (tree->gtArrLen.gtArrLenCse)
    {
        GenTreePtr      cse = tree->gtArrLen.gtArrLenCse;

        if  (cse->gtOper == GT_COMMA)
        {
            unsigned        varNum;
            LclVarDsc   *   varDsc;

            cse = cse->gtOp.gtOp2; assert(cse->gtOper == GT_LCL_VAR);

            /* Does the variable live in a register? */

            varNum = cse->gtLclVar.gtLclNum;
            assert(varNum < lvaCount);
            varDsc = lvaTable + varNum;

            if  (varDsc->lvRegister)
                return  genRegMask(varDsc->lvRegNum);
        }
    }

    return  0;
}

#endif

/*****************************************************************************
 *
 * If compiling without REDUNDANT_LOAD, same as genMakeAddressable().
 * Otherwise, check if rvalue is in register. If so, mark it. Then
 * call genMakeAddressable(). Needed because genMakeAddressable is used
 * for both lvalue and rvalue, and we only can do this for rvalue.
 */

inline
unsigned            Compiler::genMakeRvalueAddressable(GenTreePtr   tree,
                                                       unsigned     needReg,
                                                       bool         keepReg,
                                                       bool         takeAll,
                                                       bool         smallOK)
{
    regNumber reg;

#if SCHEDULER
    if  (tree->gtOper == GT_IND && tree->gtType == TYP_INT)
    {
        if  (rsRiscify(tree->TypeGet(), needReg))
        {
            genCodeForTree(tree, needReg);
            goto RET;
        }
    }
#endif

#if REDUNDANT_LOAD

    if (tree->gtOper == GT_LCL_VAR)
    {
        reg = rsLclIsInReg(tree->gtLclVar.gtLclNum);

        if (reg != REG_NA && (needReg== 0 || (genRegMask(reg) & needReg) != 0))
        {
            assert(isRegPairType(tree->gtType) == false);

            tree->gtRegNum = reg;
            tree->gtFlags |=  GTF_REG_VAL;
        }
#if SCHEDULER
        else if (!varTypeIsGC(tree->TypeGet()) && rsRiscify(tree->TypeGet(), needReg))
        {
            genCodeForTree(tree, needReg);
        }
#endif
    }

#endif

#if SCHEDULER
RET:
#endif

    return genMakeAddressable(tree, needReg, keepReg, takeAll, smallOK);
}

/*****************************************************************************/
#if TGT_RISC
/*****************************************************************************
 *
 *  The given tree was previously passed to genMakeAddressable() with a
 *  non-zero value for "deferOK"; return non-zero if the address mode has
 *  not yet been fully formed.
 */

inline
bool                Compiler::genDeferAddressable(GenTreePtr tree)
{
    return  (tree->gtFlags & GTF_DEF_ADDRMODE) != 0;
}

inline
unsigned            Compiler::genNeedAddressable(GenTreePtr tree,
                                                 unsigned   addrReg,
                                                 unsigned   needReg)
{
    /* Clear the "deferred" address mode flag */

    assert(tree->gtFlags & GTF_DEF_ADDRMODE); tree->gtFlags &= ~GTF_DEF_ADDRMODE;

    /* Free up the old address register(s) */

    rsMarkRegFree(addrReg);

    /* Now try again, this time disallowing any deferral */

    return  genMakeAddressable(tree, needReg, true, false, true, false);
}

/*****************************************************************************/
#endif//TGT_RISC
/*****************************************************************************
 *
 *  Make sure the given tree is addressable.  'needReg' is a mask that indicates
 *  the set of registers we would prefer the destination tree to be computed
 *  into (0 means no preference).  If 'keepReg' is non-zero, we mark any registers
 *  the addressability depends on as used and return the mask for that register
 *  set (if no registers are marked as used, 0 is returned).
 *  if 'smallOK' is not true and the datatype being address is a byte or short,
 *  then the tree is forced into a register.  This is useful when the machine
 *  instruction being emitted does not have a byte or short version.
 *
 *  The "deferOK" parameter indicates the mode of operation - when it's false,
 *  upon returning an actual address mode must have been formed (i.e. it must
 *  be possible to immediately call one of the inst_TT methods to operate on
 *  the value). When "deferOK" is true, we do whatever it takes to be ready
 *  to form the address mode later - for example, if an index address mode on
 *  a particular CPU requires the use of a specific register, we usually don't
 *  want to immediately grab that register for an address mode that will only
 *  be needed later. The convention is to call genMakeAddressable() is with
 *  "deferOK" equal to true, do whatever work is needed to prepare the other
 *  operand, call genMakeAddressable() with "deferOK" equal to false, and
 *  finally call one of the inst_TT methods right after that.
 *
 *  The 'takeAll' argument does not seem to be used.
 */

unsigned            Compiler::genMakeAddressable(GenTreePtr   tree,
                                                 unsigned     needReg,
                                                 bool         keepReg,
                                                 bool         takeAll,
                                                 bool         smallOK,
                                                 bool         deferOK)
{
    GenTreePtr      addr = NULL;
    unsigned        regMask;

    /* Is the value simply sitting in a register? */

    if  (tree->gtFlags & GTF_REG_VAL)
    {
        genUpdateLife(tree);

#if TGT_RISC
        genAddressMode = AM_REG;
#endif
        goto GOT_VAL;
    }

    // UNDONE: If the value is for example a cast of float -> int, compute
    // UNDONE: the converted value into a stack temp, and leave it there,
    // UNDONE: since stack temps are always addressable. This would require
    // UNDONE: recording the fact that a particular tree is in a stack temp.

    switch (tree->gtOper)
    {
    case GT_LCL_VAR:

#if TGT_x86

        /* byte/char/short operand -- is this acceptable to the caller? */

        if (tree->gtType < TYP_INT && !smallOK)
            break;

#endif
        if (!genMarkLclVar(tree))
        {
#if TGT_RISC
            genAddressMode = AM_LCL;
#endif
            genUpdateLife(tree);
            return 0;
        }

        // Fall through, it turns out the variable lives in a register

    case GT_REG_VAR:

#if TGT_x86

        /* byte/char/short operand -- is this acceptable to the caller? */

        if (tree->gtType < TYP_INT && !smallOK)
            break;

#endif
        genUpdateLife(tree);

#if TGT_RISC
        genAddressMode = AM_REG;
#endif
        goto GOT_VAL;

    case GT_CLS_VAR:

#if TGT_x86

        /* byte/char/short operand -- is this acceptable to the caller? */

        if (tree->gtType < TYP_INT && !smallOK)
            break;

#else

        // ISSUE: Is this acceptable?

        genAddressMode = AM_GLOBAL;

#endif

        return 0;

    case GT_CNS_INT:
    case GT_CNS_LNG:
    case GT_CNS_FLT:
    case GT_CNS_DBL:
#if TGT_RISC
        genAddressMode = AM_CONS;
#endif
        return 0;

#if CSELENGTH

    case GT_ARR_RNGCHK:

        assert(tree->gtFlags & GTF_ALN_CSEVAL);

        tree = tree->gtArrLen.gtArrLenAdr;
        break;

#endif

    case GT_IND:

        /* Is the result of the indirection a byte or short? */

        if  (tree->gtType < TYP_INT)
        {
            /* byte/char/short operand -- is this acceptable to the caller? */

            if  (!smallOK)
                break;
        }

        /* Try to make the address directly addressable */

        if  (genMakeIndAddrMode(tree->gtInd.gtIndOp1,
                                tree,
                                false,
                                needReg,
                                keepReg,
                                takeAll,
                                &regMask,
                                deferOK))
        {
            genUpdateLife(tree);
            return regMask;
        }

        /* No good, we'll have to load the address into a register */

        addr = tree;
        tree = tree->gtInd.gtIndOp1;
        break;
    }

    /* Here we need to compute the value 'tree' into a register */

    genCodeForTree(tree, needReg);

#if TGT_RISC
    genAddressMode = AM_REG;
#endif

GOT_VAL:

    assert(tree->gtFlags & GTF_REG_VAL);

    if  (isRegPairType(tree->gtType))
    {
        /* Are we supposed to hang on to the register? */

        if (keepReg)
            rsMarkRegPairUsed(tree);

        regMask = genRegPairMask(tree->gtRegPair);
    }
    else
    {
        /* Are we supposed to hang on to the register? */

        if (keepReg)
            rsMarkRegUsed(tree, addr);

        regMask = genRegMask(tree->gtRegNum);
    }

    return  regMask;
}

/*****************************************************************************
 *
 *  The given tree was previously passed to genMakeAddressable(); return
 *  non-zero if the operand is still addressable.
 */

inline
int                 Compiler::genStillAddressable(GenTreePtr tree)
{

#if TGT_RISC
    assert((tree->gtFlags & GTF_DEF_ADDRMODE) == 0);
#endif

    /* Has the value (or one or more of its sub-operands) been spilled? */

    if  (tree->gtFlags & (GTF_SPILLED|GTF_SPILLED_OPER))
        return  false;

    return  true;
}

/*****************************************************************************
 *
 *  Recursive helper to restore complex address modes. The 'lockPhase'
 *  argument indicates whether we're in the 'lock' or 'reload' phase.
 */

unsigned            Compiler::genRestoreAddrMode(GenTreePtr   addr,
                                                 GenTreePtr   tree,
                                                 bool         lockPhase)
{
    unsigned        regMask = 0;

    /* Have we found a spilled value? */

    if  (tree->gtFlags & GTF_SPILLED)
    {
        /* Do nothing if we're locking, otherwise reload and lock */

        if  (!lockPhase)
        {
            /* Unspill the register */

            rsUnspillReg(tree, 0, false);

            /* The value should now be sitting in a register */

            assert(tree->gtFlags & GTF_REG_VAL);
            regMask = genRegMask(tree->gtRegNum);

            /* Mark the register as used for the address */

            rsMarkRegUsed(tree, addr);

            /* Lock the register until we're done with the entire address */

            rsMaskLock |= regMask;
        }

        return  regMask;
    }

    /* Is this sub-tree sitting in a register? */

    if  (tree->gtFlags & GTF_REG_VAL)
    {
        regMask = genRegMask(tree->gtRegNum);

        /* Lock the register if we're in the locking phase */

        if  (lockPhase)
            rsMaskLock |= regMask;
    }
    else
    {
        unsigned        kind;

        /* Process any sub-operands of this node */

        kind = tree->OperKind();

        if  (kind & GTK_SMPOP)
        {
            /* Unary/binary operator */

            if  (tree->gtOp.gtOp1)
                regMask |= genRestoreAddrMode(addr, tree->gtOp.gtOp1, lockPhase);
            if  (tree->gtOp.gtOp2)
                regMask |= genRestoreAddrMode(addr, tree->gtOp.gtOp2, lockPhase);
        }
        else
        {
            /* Must be a leaf/constant node */

            assert(kind & (GTK_LEAF|GTK_CONST));
        }
    }

    return  regMask;
}

/*****************************************************************************
 *
 *  The given tree was previously passed to genMakeAddressable, but since then
 *  some of its registers are known to have been spilled; do whatever it takes
 *  to make the operand addressable again (typically by reloading any spilled
 *  registers).
 */

unsigned            Compiler::genRestAddressable(GenTreePtr tree, unsigned addrReg)
{
    unsigned        lockMask;

    /* Is this a 'simple' register spill? */

    if  (tree->gtFlags & GTF_SPILLED)
    {
        /* The mask must match the original register/regpair */

        if  (isRegPairType(tree->gtType))
        {
            assert(addrReg == genRegPairMask(tree->gtRegPair));

            rsUnspillRegPair(tree, 0, true);

            return  genRegPairMask(tree->gtRegPair);
        }
        else
        {
            assert(addrReg == genRegMask(tree->gtRegNum));

            rsUnspillReg(tree, 0, true);

            return  genRegMask(tree->gtRegNum);
        }

        return  addrReg;
    }

    /* We have a complex address mode with some of its sub-operands spilled */

    assert((tree->gtFlags & GTF_REG_VAL     ) == 0);
    assert((tree->gtFlags & GTF_SPILLED_OPER) != 0);

    /*
        We'll proceed in several phases:

         1. Lock any registers that are part of the address mode and
            have not been spilled. This prevents these registers from
            getting spilled in step 2.

         2. Reload any registers that have been spilled; lock each
            one right after it is reloaded.

         3. Unlock all the registers.
     */

    lockMask  = genRestoreAddrMode(tree, tree,  true);
    lockMask |= genRestoreAddrMode(tree, tree, false);

    /* Unlock all registers that the address mode uses */

    assert((rsMaskLock &  lockMask) == lockMask);
            rsMaskLock -= lockMask;

    return  lockMask;
}

/*****************************************************************************
 *
 *  The given tree was previously passed to genMakeAddressable, but since then
 *  some of its registers might have been spilled ('addrReg' is the set of
 *  registers used by the address). This function makes sure the operand is
 *  still addressable (while avoiding any of the registers in 'lockMask'),
 *  and returns the (possibly modified) set of registers that are used by
 *  the address (these will be marked as used on exit).
 */

unsigned            Compiler::genLockAddressable(GenTreePtr   tree,
                                                 unsigned     lockMask,
                                                 unsigned     addrReg)
{
    assert(lockMask);

    /* Make sure the caller has marked the 'lock' registers as used */

    assert((rsMaskUsed & lockMask) == lockMask);

    /* Is the operand still addressable? */

    if  (!genStillAddressable(tree))
    {
        /* Temporarily lock 'lockMask' while we restore addressability */

        assert((rsMaskLock &  lockMask) == 0);
                rsMaskLock |= lockMask;

        addrReg = genRestAddressable(tree, addrReg);

        assert((rsMaskLock &  lockMask) == lockMask);
                rsMaskLock -= lockMask;
    }

    return  addrReg;
}

/*****************************************************************************
 *
 *  The given tree was previously passed to genMakeAddressable, but since then
 *  some of its registers might have been spilled ('addrReg' is the set of
 *  registers used by the address). This function makes sure the operand is
 *  still addressable and returns the (possibly modified) set of registers
 *  that are used by the address (these will be marked as used on exit).
 */

inline
unsigned            Compiler::genKeepAddressable(GenTreePtr   tree,
                                                 unsigned     addrReg)
{
    /* Is the operand still addressable? */

    if  (!genStillAddressable(tree))
        addrReg = genRestAddressable(tree, addrReg);

    return  addrReg;
}

/*****************************************************************************
 *
 *  After we're finished with the given operand (which was previously marked
 *  by calling genMakeAddressable), this function must be called to free any
 *  registers that may have been used by the address.
 */

inline
void                Compiler::genDoneAddressable(GenTreePtr tree, unsigned keptReg)
{
    rsMarkRegFree(keptReg);
}

/*****************************************************************************/
#if     TGT_x86
/*****************************************************************************
 *
 *  Make sure the given floating point value is addressable, and return a tree
 *  that will yield the value as an addressing mode (this tree may differ from
 *  the one passed in, BTW). If the only way to make the value addressable is
 *  to evaluate into the FP stack, we do this and return zero.
 */

GenTreePtr          Compiler::genMakeAddrOrFPstk(GenTreePtr   tree,
                                                 unsigned *   regMaskPtr,
                                                 bool         roundResult)
{
    *regMaskPtr = 0;

    switch (tree->gtOper)
    {
    case GT_LCL_VAR:
    case GT_CLS_VAR:
        return tree;

    case GT_CNS_FLT:
        return  genMakeConst(&tree->gtFltCon.gtFconVal, sizeof(float ), tree->gtType, tree, true);

    case GT_CNS_DBL:
        return  genMakeConst(&tree->gtDblCon.gtDconVal, sizeof(double), tree->gtType, tree, true);

    case GT_IND:

        /* Try to make the address directly addressable */

        if  (genMakeIndAddrMode(tree->gtInd.gtIndOp1,
                                tree,
                                false,
                                0,
                                false,
                                true,
                                regMaskPtr,
                                false))
        {
            genUpdateLife(tree);
            return tree;
        }

        break;
    }

    /* We have no choice but to compute the value 'tree' onto the FP stack */

    genCodeForTreeFlt(tree, roundResult);

    return 0;
}

/*****************************************************************************
 *
 *  Generate the "SUB ESP, <sz>" that makes room on the stack for a float
 *  argument.
 */

void                Compiler::genFltArgPass(size_t *argSzPtr)
{
    assert(argSzPtr);

    size_t          sz = *argSzPtr;

    inst_RV_IV(INS_sub, REG_ESP, sz);

    genSinglePush(false);

    if  (sz == 2*sizeof(unsigned))
        genSinglePush(false);

    *argSzPtr = 0;
}

/*****************************************************************************/
#endif//TGT_x86
/*****************************************************************************
 *
 *  Display a string literal value (debug only).
 */

#ifdef  DEBUG
#ifndef NOT_JITC

static
void                genDispStringLit(const char *str)
{
    bool            hadNum = false;
    bool            inChar = false;
    unsigned        count  = 0;

    int             ch;

    do
    {
        if  (++count > 100)
        {
            printf(" ...etc...");
            break;
        }

        ch = *str++;

        if  (ch < ' ' || ch > 127)
        {
            if  (inChar) printf("', ");
            if  (hadNum) printf(", ");

            printf("%02XH", ch);

            inChar = false;
            hadNum = true;
        }
        else
        {
            if  ( hadNum) printf(",");
            if  (!inChar) printf("'");

            printf("%c", ch);

            inChar = true;
            hadNum = false;
        }
    }
    while (ch);

    if  (inChar) printf("'");
}

#endif
#endif

/*****************************************************************************
 *
 *  The following awful hack used as a last resort in tracking down random
 *  crash bugs.
 */

#if GEN_COUNT_CODE

unsigned            methodCount;

static
void                genMethodCount()
{
    //  FF 05   <ADDR>                  inc dword ptr [classVar]

    genEmitter.emitCodeGenByte(0xFF);
    genEmitter.emitCodeGenByte(0x05);
    genEmitter.emitCodeGenLong((int)&methodCount);

    //  81 3D   <ADDR>    NNNNNNNN      cmp dword ptr [classVar], NNNNNNNN

    genEmitter.emitCodeGenByte(0x81);
    genEmitter.emitCodeGenByte(0x3D);
    genEmitter.emitCodeGenLong((int)&methodCount);
    genEmitter.emitCodeGenLong(0x0000c600);

    //  75 01                           jne short nope

    genEmitter.emitCodeGenByte(0x75);
    genEmitter.emitCodeGenByte(0x01);

    //  CC                              int 3
    instGen(INS_int3);

    //                      nope:

}

#else

inline
void                genMethodCount(){}

#endif

/*****************************************************************************
 *
 *  Generate an exit sequence for a return from a method (note: when compiling
 *  for speed there might be multiple exit points).
 */

void                Compiler::genExitCode(bool endFN)
{
#ifdef DEBUGGING_SUPPORT
    /* Just wrote the first instruction of the epilog - inform debugger
       Note that this may result in a duplicate IPmapping entry, and
       that this is ok  */

    if (opts.compDbgInfo)
    {
        //for nonoptimized debuggable code, there is only one epilog
        genIPmappingAdd(ICorDebugInfo::MappingTypes::EPILOG);
    }
#endif //DEBUGGING_SUPPORT

    genEmitter->emitBegEpilog();

    genMethodCount();

    if  (genFullPtrRegMap)
    {
        if (varTypeIsGC(info.compRetType))
        {
            assert(genTypeStSz(info.compRetType) == genTypeStSz(TYP_INT));

            gcMarkRegPtrVal(REG_INTRET, info.compRetType);

//          genEmitter->emitSetGClife(gcVarPtrSetCur, gcRegGCrefSetCur, gcRegByrefSetCur);
        }
    }

#if     TGT_x86

    /* Check if this a special return block i.e.
     * CEE_JMP instruction */

    if  (compCurBB->bbFlags & BBF_HAS_JMP)
    {
        assert(compCurBB->bbJumpKind == BBJ_RETURN);
        assert(compCurBB->bbTreeList);

        /* figure out what jump we have */

        GenTreePtr jmpNode = compCurBB->bbTreeList->gtPrev;

        assert(jmpNode && (jmpNode->gtNext == 0));
        assert(jmpNode->gtOper == GT_STMT);

        jmpNode = jmpNode->gtStmt.gtStmtExpr;
        assert(jmpNode->gtOper == GT_JMP || jmpNode->gtOper == GT_JMPI);

        if  (jmpNode->gtOper == GT_JMP)
        {
            /* simply emit a jump to the methodHnd
             * This is similar to a call so we can use
             * the same descriptor with some minor adjustments */

            genEmitter->emitIns_Call(emitter::EC_FUNC_TOKEN,
                                     (void *)jmpNode->gtVal.gtVal1,
                                     0,                     /* argSize */
                                     0,                     /* retSize */
                                     gcVarPtrSetCur,
                                     gcRegGCrefSetCur,
                                     gcRegByrefSetCur,
                                     SR_NA, SR_NA, 0, 0,    /* ireg, xreg, xmul, disp */
                                     true);                 /* isJump */
        }
        else
        {
            /* We already have the pointer in EAX - Do a 'jmp EAX' */

            genEmitter->emitIns_R(INS_i_jmp, EA_4BYTE, (emitRegs)REG_EAX);
        }

        /* finish the epilog */

        goto DONE_EMIT;
    }

    /* Return, popping our arguments (if any) */

    assert(compArgSize < 0x10000); // "ret" only has 2 byte operand

        // varargs has caller pop
    if (info.compIsVarArgs)
        instGen(INS_ret);
    else
    {
#if USE_FASTCALL
        // CONSIDER: check if compArgSize is not used anywhere else as the
        // total size of arguments and then update it in lclvars.cpp
        assert(compArgSize >= rsCalleeRegArgNum * sizeof(void *));
        if (compArgSize - (rsCalleeRegArgNum * sizeof(void *)))
            inst_IV(INS_ret, compArgSize - (rsCalleeRegArgNum * sizeof(void *)));
#else
        if  (compArgSize)
            inst_IV(INS_ret, compArgSize);
#endif
        else
            instGen(INS_ret);
    }

#elif   TGT_SH3

    /* Check for CEE_JMP */
    if  (compCurBB->bbFlags & BBF_HAS_JMP)
        assert(!"NYI for SH3!");

    /* Generate "rts", and optionally fill in the branch-delay slot */

    if  (genEmitter->emitIns_BD(INS_rts))
        genEmitter->emitIns(INS_nop);

#else

    assert(!"unexpected target");

#endif

DONE_EMIT:

    genEmitter->emitEndEpilog(endFN);
}

/*****************************************************************************
 *
 *  Generate any side effects within the given expression tree.
 */

void                Compiler::genEvalSideEffects(GenTreePtr tree, unsigned needReg)
{
    genTreeOps      oper;
    unsigned        kind;

AGAIN:

    /* Does this sub-tree contain any side-effects? */

    if  (tree->gtFlags & GTF_SIDE_EFFECT)
    {
        /* Remember the current FP stack level */

        unsigned savFPstkLevel = genFPstkLevel;

        /* Generate the expression and throw it away */

        genCodeForTree(tree, needReg);

        if  (tree->gtFlags & GTF_REG_VAL)
            gcMarkRegPtrVal(tree);

        /* If the tree computed a value on the FP stack, pop the stack */

        if  (genFPstkLevel > savFPstkLevel)
        {
            assert(genFPstkLevel == savFPstkLevel + 1);
            inst_FS(INS_fstp, 0);
            genFPstkLevel--;
        }

        return;
    }

    assert(tree->gtOper != GT_ASG);

    /* Walk the tree, just to mark any dead values appropriately */

    oper = tree->OperGet();
    kind = tree->OperKind();

    /* Is this a constant or leaf node? */

    if  (kind & (GTK_CONST|GTK_LEAF))
    {
        genUpdateLife(tree);
        gcMarkRegPtrVal (tree);
        return;
    }

#if CSELENGTH

    if  (oper == GT_ARR_RNGCHK)
    {
        genCodeForTree(tree, needReg);
        return;
    }

#endif

    /* Must be a 'simple' unary/binary operator */

    assert(kind & GTK_SMPOP );

    if  (tree->gtOp.gtOp2)
    {
        genEvalSideEffects(tree->gtOp.gtOp1, needReg);

        tree = tree->gtOp.gtOp2;
        goto AGAIN;
    }
    else
    {
        tree = tree->gtOp.gtOp1;
        if  (tree)
            goto AGAIN;
    }
}

/*****************************************************************************/
#if     TGT_x86
/*****************************************************************************
 *
 *  Spill the top of the FP stack into a temp, and return that temp.
 */

Compiler::TempDsc *     Compiler::genSpillFPtos(var_types type)
{
    TempDsc  *          temp = tmpGetTemp(type);
    emitAttr            size = EA_ATTR(genTypeSize(type));

    /* Pop the value from the FP stack into the temp */

    genEmitter->emitIns_S(INS_fstp, size, temp->tdTempNum(), 0);

//    assert(genFPstkLevel == 1);
           genFPstkLevel--;

    genTmpAccessCnt++;

    return temp;
}

/*****************************************************************************
 *
 *  Spill the top of the FP stack into a temp, and return that temp.
 */

inline
Compiler::TempDsc * Compiler::genSpillFPtos(GenTreePtr oper)
{
    return  genSpillFPtos(oper->TypeGet());
}

/*****************************************************************************
 *
 *  Reload a previously spilled FP temp via the specified instruction (which
 *  could be something like 'fadd' or 'fcomp', or 'fld' in which case it is
 *  the caller's responsibility to bump the FP stack level).
 */

void                Compiler::genReloadFPtos(TempDsc *temp, instruction ins)
{
    emitAttr      size = EA_ATTR(genTypeSize(temp->tdTempType()));

    genEmitter->emitIns_S(ins, size, temp->tdTempNum(), 0);

    genTmpAccessCnt++;

    /* We no longer need the temp */

    tmpRlsTemp(temp);
}

/*****************************************************************************
 *
 *  A persistent pointer value is being overwritten, record it for the GC.
 */

#if GC_WRITE_BARRIER

unsigned            Compiler::WriteBarrier(GenTreePtr tgt, regNumber reg)
{
    regNumber       rg1;
    regNumber       rg2;
    regNumber       rgTmp;

    unsigned        regUse;

    if (!Compiler::gcIsWriteBarrierCandidate(tgt))
        return 0;

#ifdef  DEBUG
//    static  const   char *  writeBarrier = getenv("WRITEBARRIER");
//    if  (!writeBarrier)
//        return  0;
#endif

    /*
        Generate the following code:

                mov     rg2, 4
                lea     rg1, [address-of-pointer]
                xadd    dword ptr [nextPtr], rg2
                mov     [rg2], rg1

        First, we'll pick registers for the pointer value and table address.
     */

    rg1 = rsGrabReg(RBM_ALL);
    rsMaskUsed |= genRegMask(rg1);
    rsMaskLock |= genRegMask(rg1);


    rg2 = rsGrabReg(RBM_ALL);
    rsMaskUsed |= genRegMask(rg2);
    rsMaskLock |= genRegMask(rg2);

    if  (rg2 == REG_EBP)
    {
        /* Swap rg1 and rg2 because encoding of the last instruction */
        /* would be different for EBP ([EBP+0], different mod field).*/
        /* Avoiding this simplifies en- and decoding.                */

        rgTmp = rg2;
                rg2 = rg1;
                      rg1 = rgTmp;
    }

    /* Initialize scratch register */

    genSetRegToIcon(rg2, 4);

    /* Compute the address of the pointer value */

    assert(tgt->gtOper == GT_IND);
    inst_RV_AT(INS_lea, EA_4BYTE, rg1, tgt->gtOp.gtOp1);

    /* Store the pointer in the table */

#ifdef  DEBUG
    instDisp(INS_xadd, false, "[nextPtr], %s", compRegVarName(rg2, true));
#endif
    genEmitter.emitCodeGenByte(0x0F);
    genEmitter.emitCodeGenByte(0xC1);
    genEmitter.emitCodeGenByte(8*rg2+5);               /* register and mod/r */
    genEmitter.emitCodeGenFixVMData(0);                /* 0 means GC pointer */
    genEmitter.emitCodeGenLong((int)Compiler::s_gcWriteBarrierPtr);

#ifdef  DEBUG
    instDisp(INS_mov, false, "[%s], %s", compRegVarName(rg2, true), compRegVarName(rg1, true));
#endif
    genEmitter.emitCodeGenWord(0x0089 + ((rg2 + 8*rg1) << 8));

    rsTrackRegTrash(rg1);
    rsTrackRegTrash(rg2);

    regUse = genRegMask(rg1) | genRegMask(rg2);

    rsMaskUsed &= ~regUse;
    rsMaskLock &= ~regUse;

    return  regUse;
}

#else

#if GC_WRITE_BARRIER_CALL

unsigned            Compiler::WriteBarrier(GenTreePtr tgt, regNumber reg, unsigned addrReg)
{
    static
    int regToHelper[2][8] =
    {
        // If the target is known to be in managed memory
        {
            CPX_GC_REF_ASGN_EAX,
            CPX_GC_REF_ASGN_ECX,
            -1,
            CPX_GC_REF_ASGN_EBX,
            -1,
            CPX_GC_REF_ASGN_EBP,
            CPX_GC_REF_ASGN_ESI,
            CPX_GC_REF_ASGN_EDI,
        },

        // Dont know if the target is in managed memory
        {
            CPX_GC_REF_CHK_ASGN_EAX,
            CPX_GC_REF_CHK_ASGN_ECX,
            -1,
            CPX_GC_REF_CHK_ASGN_EBX,
            -1,
            CPX_GC_REF_CHK_ASGN_EBP,
            CPX_GC_REF_CHK_ASGN_ESI,
            CPX_GC_REF_CHK_ASGN_EDI,
        },
    };

    regNumber       rg1;
    bool            trashOp1 = true;

    if  (!Compiler::gcIsWriteBarrierCandidate(tgt))
        return  0;

    if (tgt->gtOper == GT_CLS_VAR)
    {
#ifdef DEBUG
        static bool staticsInLargeHeap = getEERegistryDWORD("StaticsInLargeHeap", 0) != 0;
#else
        static bool staticsInLargeHeap = false;
#endif

        if (!staticsInLargeHeap)
            return 0;

        /* System.Array is loaded AFTER __StaticContainer but it has a static.
          So we shouldnt use write-barriers while writing to its statics.
          Remove this after System.Array no longer has any statics */

#ifdef DEBUG
        if (0 == strcmp(info.compFullName, "System.Array..cctor()"))
            return 0;
#endif
    }

    assert(regToHelper[0][REG_EAX] == CPX_GC_REF_ASGN_EAX);
    assert(regToHelper[0][REG_ECX] == CPX_GC_REF_ASGN_ECX);
    assert(regToHelper[0][REG_EBX] == CPX_GC_REF_ASGN_EBX);
    assert(regToHelper[0][REG_ESP] == -1                 );
    assert(regToHelper[0][REG_EBP] == CPX_GC_REF_ASGN_EBP);
    assert(regToHelper[0][REG_ESI] == CPX_GC_REF_ASGN_ESI);
    assert(regToHelper[0][REG_EDI] == CPX_GC_REF_ASGN_EDI);

    assert(regToHelper[1][REG_EAX] == CPX_GC_REF_CHK_ASGN_EAX);
    assert(regToHelper[1][REG_ECX] == CPX_GC_REF_CHK_ASGN_ECX);
    assert(regToHelper[1][REG_EBX] == CPX_GC_REF_CHK_ASGN_EBX);
    assert(regToHelper[1][REG_ESP] == -1                     );
    assert(regToHelper[1][REG_EBP] == CPX_GC_REF_CHK_ASGN_EBP);
    assert(regToHelper[1][REG_ESI] == CPX_GC_REF_CHK_ASGN_ESI);
    assert(regToHelper[1][REG_EDI] == CPX_GC_REF_CHK_ASGN_EDI);

    assert(reg != REG_ESP && reg != REG_EDX);

#ifdef DEBUG
    if  (reg == REG_EDX)
    {
        printf("WriteBarrier: RHS == REG_EDX");
        if (rsMaskVars & RBM_EDX)
            printf(" (EDX is enregistered!)\n");
        else
            printf(" (just happens to be in EDX!)\n");
    }
#endif

    /*
        Generate the following code:

                lea     edx, tgt
                call    write_barrier_helper_reg

        First, we'll pick EDX for the target address.
     */

    if  ((addrReg & RBM_EDX) == 0)
    {
        rg1 = rsGrabReg(RBM_EDX);

        rsMaskUsed |= RBM_EDX;
        rsMaskLock |= RBM_EDX;

        trashOp1 = false;
    }
    else
    {
        rg1 = REG_EDX;
    }
    assert(rg1 == REG_EDX);

    /* Generate "lea EDX, [addr-mode]" */

    assert(tgt->gtType == TYP_REF);
    tgt->gtType = TYP_BYREF;
    inst_RV_TT(INS_lea, rg1, tgt, 0, EA_BYREF);

    rsTrackRegTrash(rg1);
    gcMarkRegSetNpt(genRegMask(rg1));
    gcMarkRegPtrVal(rg1, TYP_BYREF);


    /* Call the proper vm helper */

#if TGT_RISC
    assert(genNonLeaf);
#endif
    assert(tgt->gtOper == GT_IND || tgt->gtOper == GT_CLS_VAR); // enforced by gcIsWriteBarrierCandidate

    unsigned    tgtAnywhere = 0;
    if ((tgt->gtOper == GT_IND) && (tgt->gtFlags & GTF_IND_TGTANYWHERE))
        tgtAnywhere = 1;

    int helper = regToHelper[tgtAnywhere][reg];

    gcMarkRegSetNpt(RBM_EDX);           // byref EDX is killed the call

    genEmitHelperCall(helper,
                      0,             // argSize
                      sizeof(void*));// retSize

    if  (!trashOp1)
    {
        rsMaskUsed &= ~RBM_EDX;
        rsMaskLock &= ~RBM_EDX;
    }

    return RBM_EDX;
}

#else // No GC_WRITE_BARRIER support at all

inline
unsigned            Compiler::WriteBarrier(GenTreePtr tree, regNumber reg){ return 0; }

#endif
#endif

/*****************************************************************************
 *
 *  Generate a conditional jump to the given target.
 */

#if 0

inline
void                Compiler::genJCC(genTreeOps  cmp,
                                     BasicBlock *block,
                                     var_types   type)
{
    BYTE    *       jumps;

    static
    BYTE            genJCCinsSgn[] =
    {
        EJ_je,      // GT_EQ
        EJ_jne,     // GT_NE
        EJ_jl,      // GT_LT
        EJ_jle,     // GT_LE
        EJ_jge,     // GT_GE
        EJ_jg,      // GT_GT
    };

    static
    BYTE            genJCCinsUns[] =       /* unsigned comparison */
    {
        EJ_je,      // GT_EQ
        EJ_jne,     // GT_NE
        EJ_jb,      // GT_LT
        EJ_jbe,     // GT_LE
        EJ_jae,     // GT_GE
        EJ_ja,      // GT_GT
    };

    assert(genJCCinsSgn[GT_EQ - GT_EQ] == EJ_je );
    assert(genJCCinsSgn[GT_NE - GT_EQ] == EJ_jne);
    assert(genJCCinsSgn[GT_LT - GT_EQ] == EJ_jl );
    assert(genJCCinsSgn[GT_LE - GT_EQ] == EJ_jle);
    assert(genJCCinsSgn[GT_GE - GT_EQ] == EJ_jge);
    assert(genJCCinsSgn[GT_GT - GT_EQ] == EJ_jg );

    assert(genJCCinsUns[GT_EQ - GT_EQ] == EJ_je );
    assert(genJCCinsUns[GT_NE - GT_EQ] == EJ_jne);
    assert(genJCCinsUns[GT_LT - GT_EQ] == EJ_jb );
    assert(genJCCinsUns[GT_LE - GT_EQ] == EJ_jbe);
    assert(genJCCinsUns[GT_GE - GT_EQ] == EJ_jae);
    assert(genJCCinsUns[GT_GT - GT_EQ] == EJ_ja );

    assert(GenTree::OperIsCompare(cmp));

    jumps = varTypeIsUnsigned(type) ? genJCCinsUns
                                    : genJCCinsSgn;

    inst_JMP((emitJumpKind)jumps[cmp - GT_EQ], block);
}

#endif

/*****************************************************************************
 *
 *  Generate the appropriate conditional jump(s) right after the low 32 bits
 *  of two long values have been compared.
 */

void                Compiler::genJccLongHi(genTreeOps   cmp,
                                           BasicBlock * jumpTrue,
                                           BasicBlock * jumpFalse,
                                           bool         unsOper )
{
    switch (cmp)
    {
    case GT_EQ:
        inst_JMP(EJ_jne, jumpFalse, false, false, true);
        break;

    case GT_NE:
        inst_JMP(EJ_jne, jumpTrue , false, false, true);
        break;

    case GT_LT:
    case GT_LE:
        if (unsOper)
        {
            inst_JMP(EJ_ja , jumpFalse, false, false, true);
            inst_JMP(EJ_jb , jumpTrue , false, false, true);
        }
        else
        {
            inst_JMP(EJ_jg , jumpFalse, false, false, true);
            inst_JMP(EJ_jl , jumpTrue , false, false, true);
        }
        break;

    case GT_GE:
    case GT_GT:
        if (unsOper)
        {
            inst_JMP(EJ_jb , jumpFalse, false, false, true);
            inst_JMP(EJ_ja , jumpTrue , false, false, true);
        }
        else
        {
            inst_JMP(EJ_jl , jumpFalse, false, false, true);
            inst_JMP(EJ_jg , jumpTrue , false, false, true);
        }
        break;

    default:
        assert(!"expected a comparison operator");
    }
}

/*****************************************************************************
 *
 *  Generate the appropriate conditional jump(s) right after the high 32 bits
 *  of two long values have been compared.
 */

void            Compiler::genJccLongLo(genTreeOps cmp, BasicBlock *jumpTrue,
                                                       BasicBlock *jumpFalse)
{
    switch (cmp)
    {
    case GT_EQ:
        inst_JMP(EJ_je , jumpTrue);
        break;

    case GT_NE:
        inst_JMP(EJ_jne, jumpTrue);
        break;

    case GT_LT:
        inst_JMP(EJ_jb , jumpTrue);
        break;

    case GT_LE:
        inst_JMP(EJ_jbe, jumpTrue);
        break;

    case GT_GE:
        inst_JMP(EJ_jae, jumpTrue);
        break;

    case GT_GT:
        inst_JMP(EJ_ja , jumpTrue);
        break;

    default:
        assert(!"expected comparison");
    }
}

/*****************************************************************************
 *
 *  Called by genCondJump() for TYP_LONG.
 */

void                Compiler::genCondJumpLng(GenTreePtr     cond,
                                             BasicBlock *   jumpTrue,
                                             BasicBlock *   jumpFalse)
{
    assert(jumpTrue && jumpFalse);
    assert((cond->gtFlags & GTF_REVERSE_OPS) == false); // Done in genCondJump()
    assert(cond->gtOp.gtOp1->gtType == TYP_LONG);

    GenTreePtr      op1       = cond->gtOp.gtOp1;
    GenTreePtr      op2       = cond->gtOp.gtOp2;
    genTreeOps      cmp       = cond->OperGet();

    regPairNo       regPair;
    unsigned        addrReg;

    /* Are we comparing against a constant? */

    if  (op2->gtOper == GT_CNS_LNG)
    {
        long            ival;
        __int64         lval = op2->gtLngCon.gtLconVal;
        regNumber       reg;

        /* Make the comparand addressable */

        addrReg = genMakeAddressable(op1, 0, false, false, true);

        /* Compare the high part first */

        ival = (long)(lval >> 32);

        /* Comparing a register against 0 is easier */

        if  (!ival && (op1->gtFlags & GTF_REG_VAL)
             && (reg = genRegPairHi(op1->gtRegPair)) != REG_STK )
        {
            /* Generate 'test reg, reg' */

            inst_RV_RV(INS_test, reg, reg, op1->TypeGet());
        }
        else
        {
            if  (op1->gtOper == GT_CNS_LNG)
            {
                /* Special case: comparison of two constants */
                // Needed as gtFoldExpr() doesnt fold longs

                assert(addrReg == 0);
                int op1_hiword = (long)(op1->gtLngCon.gtLconVal >> 32);

                /* HACK: get the constant operand into a register */
#if REDUNDANT_LOAD
                /* Is the constant already in register? If so, use it */

                reg = rsIconIsInReg(op1_hiword);

                if  (reg == REG_NA)
#endif
                {
                    reg   = rsPickReg();
                    genSetRegToIcon(reg, op1_hiword, TYP_INT);
                    rsTrackRegTrash(reg);
                }

                /* Generate 'cmp reg, ival' */

                inst_RV_IV(INS_cmp, reg, ival);
            }
            else
            {
                assert(op1->gtOper != GT_CNS_LNG);

                /* Generate 'cmp [addr], ival' */

                inst_TT_IV(INS_cmp, op1, ival, 4);
            }
        }

        /* Generate the appropriate jumps */

        if  (cond->gtFlags & GTF_UNSIGNED)
             genJccLongHi(cmp, jumpTrue, jumpFalse, true);
        else
             genJccLongHi(cmp, jumpTrue, jumpFalse);

        /* Compare the low part second */

        ival = (long)lval;

        /* Comparing a register against 0 is easier */

        if  (!ival && (op1->gtFlags & GTF_REG_VAL)
             && (reg = genRegPairLo(op1->gtRegPair)) != REG_STK)
        {
            /* Generate 'test reg, reg' */

            inst_RV_RV(INS_test, reg, reg, op1->TypeGet());
        }
        else
        {
            if  (op1->gtOper == GT_CNS_LNG)
            {
                /* Special case: comparison of two constants */
                // Needed as gtFoldExpr() doesnt fold longs

                assert(addrReg == 0);
                long op1_loword = (long) op1->gtLngCon.gtLconVal;

                /* HACK: get the constant operand into a register */
#if REDUNDANT_LOAD
                /* Is the constant already in register? If so, use it */

                reg = rsIconIsInReg(op1_loword);

                if  (reg == REG_NA)
#endif
                {
                    reg   = rsPickReg();
                    genSetRegToIcon(reg, op1_loword, TYP_INT);
                    rsTrackRegTrash(reg);
                }

                /* Generate 'cmp reg, ival' */

                inst_RV_IV(INS_cmp, reg, ival);
            }
            else
            {
                assert(op1->gtOper != GT_CNS_LNG);

                /* Generate 'cmp [addr], ival' */

                inst_TT_IV(INS_cmp, op1, ival, 0);
            }
        }

        /* Generate the appropriate jumps */

        genJccLongLo(cmp, jumpTrue, jumpFalse);

        gcMarkRegSetNpt(addrReg);
        return;
    }

    /* The operands would be reversed by physically swapping them */

    assert((cond->gtFlags & GTF_REVERSE_OPS) == 0);

    /* Generate the first operand into a register pair */

    genComputeRegPair(op1, RBM_ALL & ~op2->gtRsvdRegs, REG_PAIR_NONE, false, false);
    assert(op1->gtFlags & GTF_REG_VAL);

    /* Make the second operand addressable */

    addrReg = genMakeRvalueAddressable(op2, RBM_ALL & ~genRegPairMask(op1->gtRegPair), true);

    /* Make sure the first operand hasn't been spilled */

    genRecoverRegPair(op1, REG_PAIR_NONE, true);
    assert(op1->gtFlags & GTF_REG_VAL);

    regPair = op1->gtRegPair;

    /* Lock 'op1' and make sure 'op2' is still addressable */

    addrReg = genLockAddressable(op2, genRegPairMask(regPair), addrReg);

    /* Perform the comparison - high parts */

    inst_RV_TT(INS_cmp, genRegPairHi(regPair), op2, 4);

    if  (cond->gtFlags & GTF_UNSIGNED)
        genJccLongHi(cmp, jumpTrue, jumpFalse, true);
    else
        genJccLongHi(cmp, jumpTrue, jumpFalse);

    /* Compare the low parts */

    inst_RV_TT(INS_cmp, genRegPairLo(regPair), op2, 0);
    genJccLongLo(cmp, jumpTrue, jumpFalse);

    /* Free up anything that was tied up by either operand */

    genDoneAddressable(op2, addrReg);
    genReleaseRegPair (op1);

#ifdef  SET_USED_REG_SET_DURING_CODEGEN
    cond->gtUsedRegs = op1->gtUsedRegs | op2->gtUsedRegs;
#endif
    return;
}

/*****************************************************************************
 *
 *  Called by genCondJump() for TYP_FLOAT and TYP_DOUBLE
 */

void                Compiler::genCondJumpFlt(GenTreePtr     cond,
                                             BasicBlock *   jumpTrue,
                                             BasicBlock *   jumpFalse)
{
    assert(jumpTrue && jumpFalse);
    assert(!(cond->gtFlags & GTF_REVERSE_OPS)); // Done in genCondJump()
    assert(cond->gtOp.gtOp1->gtType == TYP_FLOAT ||
           cond->gtOp.gtOp1->gtType == TYP_DOUBLE);

    GenTreePtr      op1 = cond->gtOp.gtOp1;
    GenTreePtr      op2 = cond->gtOp.gtOp2;
    genTreeOps      cmp = cond->OperGet();

    unsigned        addrReg;
    GenTreePtr      addr;
    TempDsc  *      temp;
    BYTE            jmpNaNTrue;
#if ROUND_FLOAT
    bool            roundOp1;
#endif

    if (op1->gtType == TYP_DOUBLE)
        goto DBL;

    /* Are we comparing against floating-point 0 ? */
    /* Because of NaN we can only optimize EQ/NE   */

    if  (op2->gtOper == GT_CNS_FLT    &&
         op2->gtFltCon.gtFconVal == 0 && (cmp == GT_EQ ||
                                          cmp == GT_NE) )
    {

    FLT_CNS:

        /* Is the operand in memory? */

        addr = genMakeAddrOrFPstk(op1, &addrReg, genShouldRoundFP());

        if  (addr)
        {
            /* We have the address of the float operand, compare it */

            switch (cmp)
            {
            case GT_EQ:
                inst_TT_IV(INS_test, addr, 0x7FFFFFFFU);
                inst_JMP  (EJ_je   , jumpTrue);
                break;

            case GT_NE:
                inst_TT_IV(INS_test, addr, 0x7FFFFFFFU);
                inst_JMP  (EJ_jne , jumpTrue);
                break;

#if 0  // cannot be used because of NaN, NaN cannot be ordered
            case GT_LT:
                inst_TT_IV(INS_cmp , addr, 0x80000000U);
                inst_JMP  (EJ_ja , jumpTrue);
                break;

            case GT_LE:
                inst_TT_IV(INS_cmp , addr, 0);
                inst_JMP  (EJ_jle, jumpTrue);
                break;

            case GT_GE:
                inst_TT_IV(INS_cmp , addr, 0x80000000U);
                inst_JMP  (EJ_jbe, jumpTrue);
                break;

            case GT_GT:
                inst_TT_IV(INS_cmp , addr, 0);
                inst_JMP  (EJ_jg , jumpTrue);
                break;
#endif
            }

            gcMarkRegSetNpt(addrReg);
            return;
        }
        else
#if ROUND_FLOAT
        if ((getRoundFloatLevel() > 0))
        {
            TempDsc * temp = NULL;
            /* Allocate a temp for the expression */

            temp = genSpillFPtos(TYP_FLOAT);

            switch (cmp)
            {
            case GT_EQ:
                inst_ST_IV(INS_test, temp, 0, 0x7FFFFFFFU, TYP_FLOAT);
                inst_JMP  (EJ_je   , jumpTrue);
                break;

            case GT_NE:
                inst_ST_IV(INS_test, temp, 0, 0x7FFFFFFFU, TYP_FLOAT);
                inst_JMP  (EJ_jne , jumpTrue);
                break;
#if 0  // cannot be used because of NaN, NaN cannot be ordered
            case GT_LT:
                inst_ST_IV(INS_cmp , temp, 0, 0x80000000U, TYP_FLOAT);
                inst_JMP  (EJ_ja , jumpTrue);
                break;

            case GT_LE:
                inst_ST_IV(INS_cmp , temp, 0, 0, TYP_FLOAT);
                inst_JMP  (EJ_jle, jumpTrue);
                break;

            case GT_GE:
                inst_ST_IV(INS_cmp , temp, 0, 0x80000000U, TYP_FLOAT);
                inst_JMP  (EJ_jbe, jumpTrue);
                break;

            case GT_GT:
                inst_ST_IV(INS_cmp , temp, 0, 0, TYP_FLOAT);
                inst_JMP  (EJ_jg , jumpTrue);
                break;
#endif
            }

            /* We no longer need the temp */

            tmpRlsTemp(temp);
            return;
        }
        else
#endif
        {
            /* The argument is on the FP stack */

            goto FLT_OP2;
        }
    }

    goto FLT_CMP;

DBL:

    /* Are we comparing against floating-point 0 ? */

    if  (op2->gtOper == GT_CNS_DBL && op2->gtDblCon.gtDconVal == 0)
    {
        /* Is the other operand cast from float? */

        if  (op1->gtOper             == GT_CAST &&
             op1->gtOp.gtOp1->gtType == TYP_FLOAT)
        {
            /* We can only optimize EQ/NE because of NaN */

            if (cmp == GT_EQ || cmp == GT_NE)
            {
                /* Simply toss the cast and do a float compare */

                op1 = op1->gtOp.gtOp1;
                goto FLT_CNS;
            }
        }
    }

    /* Compute both of the comparands onto the FP stack */

FLT_CMP:

#if ROUND_FLOAT

    roundOp1 = false;

    switch (getRoundFloatLevel())
    {
    default:

        /* No rounding at all */

        break;

    case 1:

        /* Round values compared against constants only */

        if  (op2->gtOper == GT_CNS_FLT)
            roundOp1 = true;

//      gtFoldExpr() does not fold floats
//      assert(op1->gtOper != GT_CNS_FLT);
        break;

    case 2:

        /* Round all comparands */

        roundOp1 = true;

//      gtFoldExpr() does not fold floats
//      assert(op1->gtOper != GT_CNS_FLT);
        break;

    case 3:

        /*
            If we're going to spill due to call, no need to round
            the result of computation of op1.
         */

        roundOp1 = (op2->gtFlags & GTF_CALL) ? false : true;
        break;
    }

#endif

    /* Is the first comparand a register variable? */

    if  (op1->gtOper == GT_REG_VAR)
    {
        /* Does op1 die here? */

        if  (op1->gtFlags & GTF_REG_DEATH)
        {
            /* Are both comparands register variables? */

            if  (op2->gtOper == GT_REG_VAR && genFPstkLevel == 0)
            {
                /* Mark op1 as dying at the bottom of the stack */

                genFPregVarLoad(op1);

                /* Does 'op2' die here as well? */

                if  (op2->gtFlags & GTF_REG_DEATH)
                {
                    /* We're killing 'op2' here */

                    genFPregVars &= ~raBitOfRegVar(op2);
                    genFPregCnt--;

                    /* Compare the values and pop both */

                    inst_FS(INS_fcompp, 1);
                    genFPstkLevel--;

                    addrReg = 0;
                    goto FLT_REL;
                }
                else
                {
                    /* Compare op1 against op2 and toss op1 */

                    inst_FN(INS_fcomp, op2->gtRegNum + genFPstkLevel);
                    genFPstkLevel--;

                    addrReg = 0;
                    goto FLT_REL;
                }
            }
            else
            {
                /* First comparand dies here and the second one is not a register */

                if  (op1->gtRegNum + genFPstkLevel == 0)
                {
                    genCodeForTreeFlt(op2, roundOp1);
                    inst_FN(INS_fcompp, op1->gtRegNum + genFPstkLevel);

                    /* Record the fact that 'op1' is now dead */

                    genFPregVarDeath(op1);

                    goto DONE_FPREG1;
                }
            }
        }
        else if (op2->gtOper == GT_REG_VAR && op2->gtFlags & GTF_REG_DEATH)
        {
            if (op2->gtRegNum + genFPstkLevel == 0)
            {
                inst_FN(INS_fcomp, op1->gtRegNum);

                /* Record the fact that 'op2' is now dead */

                genFPregVarDeath(op2);

                /* This merely compensates for the decrement below */

                genFPstkLevel++;

                goto DONE_FPREG1;
            }
        }

        /* Load the second operand to TOS and compare */

        genCodeForTreeFlt(op2, roundOp1);
        inst_FN(INS_fcomp, op1->gtRegNum + genFPstkLevel);

    DONE_FPREG1:

        genFPstkLevel--;

        /* Flip the comparison direction */

        cmp            = GenTree::SwapRelop(cmp);
        goto FLT_REL;
    }

    genCodeForTreeFlt(op1, roundOp1);

#if ROUND_FLOAT

    if  (op1->gtType == TYP_DOUBLE && roundOp1)
    {
        if (op1->gtOper             == GT_CAST &&
            op1->gtOp.gtOp1->gtType == TYP_LONG)
        {
            genRoundFpExpression(op1);
        }
    }

#endif

FLT_OP2:

    /* Does the other operand contain a call? */
    /* Or do we compare against infinity ? */

    temp = 0;

    if  (op2->gtFlags & GTF_CALL ||
         (op2->gtOper == GT_CNS_DBL &&
          (*((__int64*)&(op2->gtDblCon.gtDconVal)) & 0x7ff0000000000000) == 0x7ff0000000000000)
         )
    {
        /* We must spill the first operand */

        temp = genSpillFPtos(op1);
    }

    /* Get hold of the second operand and compare against it */

    /* Is the second comparand a dying register variable? */

    if  (op2->gtOper == GT_REG_VAR && (op2->gtFlags & GTF_REG_DEATH) && temp == 0)
    {
        /* The second comparand dies here, how convenient! */

        genFPregVarDeath(op2);

        /* Flip the sense of the comparison */

        cmp = GenTree::SwapRelop(cmp);

        /* The second operand is obviously on the FP stack */

        addr = 0; genFPstkLevel++;
    }
    else
    {
        addr = genMakeAddrOrFPstk(op2, &addrReg, roundOp1);

#if ROUND_FLOAT

        if  (addr == 0 && op2->gtType == TYP_DOUBLE && roundOp1)
        {
            if (op2->gtOper             == GT_CAST &&
                op2->gtOp.gtOp1->gtType == TYP_LONG)
            {
                genRoundFpExpression(op2);
            }
        }

#endif

    }

    /* Did we have to spill the first operand? */

    if  (temp)
    {
        instruction     ins;

        /*
            Either reload the temp back onto the FP stack (if the other
            operand is not itself on the FP stack), or just compare the
            first operand against the temp (if the operand is on the FP
            stack).
         */

        if  (addr)
        {
            ins = INS_fld;
            genFPstkLevel++;
        }
        else
        {
            /* op2 is already on the FP stack. We can immediately
               compare against it, but we have to 'swap' the sense
               of the comparison.
            */

            ins = INS_fcomp;
            cmp = GenTree::SwapRelop(cmp);
        }

        genReloadFPtos(temp, ins);
    }

    if  (addr)
    {
        /* We have the address of the other operand */

        inst_FS_TT(INS_fcomp, addr);
    }
    else
    {
        /* The other operand is on the FP stack */

        if  (!temp)
        {
            inst_FS(INS_fcompp, 1);
            genFPstkLevel--;
            cmp = GenTree::SwapRelop(cmp);
        }
    }

    genFPstkLevel--;

FLT_REL:

    gcMarkRegSetNpt(addrReg);

    /* Grab EAX for the result of the fnstsw */

    rsGrabReg(RBM_EAX);
#ifdef  SET_USED_REG_SET_DURING_CODEGEN
    cond->gtUsedRegs |= RBM_EAX;
#endif

    /* Generate the 'fnstsw' and test its result */

    inst_RV(INS_fnstsw, REG_EAX, TYP_INT);
    rsTrackRegTrash(REG_EAX);
    instGen(INS_sahf);

    /* Start by assuming we wont branch if operands are NaN */

    jmpNaNTrue = false;

    /* reverse the NaN branch for fcompl/dcompl */

    if (cond->gtFlags & GTF_CMP_NAN_UN)
    {
        jmpNaNTrue ^= 1;
    }

    /* Generate the first jump (NaN check) */

    inst_JMP(EJ_jpe, jmpNaNTrue ? jumpTrue
                                : jumpFalse, false, false, true);

    /* Generate the second jump (comparison) */

    static
    BYTE        dblCmpTstJmp2[] =
    {
          EJ_je      , // GT_EQ
          EJ_jne     , // GT_NE
          EJ_jb      , // GT_LT
          EJ_jbe     , // GT_LE
          EJ_jae     , // GT_GE
          EJ_ja      , // GT_GT
    };

    inst_JMP((emitJumpKind)dblCmpTstJmp2[cmp - GT_EQ], jumpTrue);
}

/*****************************************************************************
 *  The condition to use for (the jmp/set for) the given type of operation
 */

static emitJumpKind         genJumpKindForOper(genTreeOps   cmp,
                                               bool         isUnsigned)
{
    static
    BYTE            genJCCinsSgn[] =
    {
        EJ_je,      // GT_EQ
        EJ_jne,     // GT_NE
        EJ_jl,      // GT_LT
        EJ_jle,     // GT_LE
        EJ_jge,     // GT_GE
        EJ_jg,      // GT_GT
    };

    static
    BYTE            genJCCinsUns[] =       /* unsigned comparison */
    {
        EJ_je,      // GT_EQ
        EJ_jne,     // GT_NE
        EJ_jb,      // GT_LT
        EJ_jbe,     // GT_LE
        EJ_jae,     // GT_GE
        EJ_ja,      // GT_GT
    };

    assert(genJCCinsSgn[GT_EQ - GT_EQ] == EJ_je );
    assert(genJCCinsSgn[GT_NE - GT_EQ] == EJ_jne);
    assert(genJCCinsSgn[GT_LT - GT_EQ] == EJ_jl );
    assert(genJCCinsSgn[GT_LE - GT_EQ] == EJ_jle);
    assert(genJCCinsSgn[GT_GE - GT_EQ] == EJ_jge);
    assert(genJCCinsSgn[GT_GT - GT_EQ] == EJ_jg );

    assert(genJCCinsUns[GT_EQ - GT_EQ] == EJ_je );
    assert(genJCCinsUns[GT_NE - GT_EQ] == EJ_jne);
    assert(genJCCinsUns[GT_LT - GT_EQ] == EJ_jb );
    assert(genJCCinsUns[GT_LE - GT_EQ] == EJ_jbe);
    assert(genJCCinsUns[GT_GE - GT_EQ] == EJ_jae);
    assert(genJCCinsUns[GT_GT - GT_EQ] == EJ_ja );

    assert(GenTree::OperIsCompare(cmp));

    if (isUnsigned)
    {
        return (emitJumpKind) genJCCinsUns[cmp - GT_EQ];
    }
    else
    {
        return (emitJumpKind) genJCCinsSgn[cmp - GT_EQ];
    }
}

/*****************************************************************************
 *
 *  Sets the flag for the TYP_INT/TYP_REF comparison.
 *  We try to use the flags if they have already been set by a prior
 *  instruction.
 *  eg. i++; if(i<0) {}  Here, the "i++;" will have set the sign flag. We dont
 *                       need to compare again with zero. Just use a "INS_js"
 *
 *  Returns the flags the following jump/set instruction should use.
 */

emitJumpKind            Compiler::genCondSetFlags(GenTreePtr cond)
{
    assert(varTypeIsI(genActualType(cond->gtOp.gtOp1->gtType)));

    GenTreePtr      op1       = cond->gtOp.gtOp1;
    GenTreePtr      op2       = cond->gtOp.gtOp2;
    genTreeOps      cmp       = cond->OperGet();

    if  (cond->gtFlags & GTF_REVERSE_OPS)
    {
        /* Don't forget to modify the condition as well */

        cond->gtOp.gtOp1 = op2;
        cond->gtOp.gtOp2 = op1;
        cond->gtOper     = GenTree::SwapRelop(cmp);
        cond->gtFlags   &= ~GTF_REVERSE_OPS;

        /* Get hold of the new values */

        cmp  = cond->OperGet();
        op1  = cond->gtOp.gtOp1;
        op2  = cond->gtOp.gtOp2;
    }

    unsigned        regNeed;
    unsigned        addrReg;
    emitJumpKind    jumpKind;
    emitAttr        size = EA_UNKNOWN;

#ifndef NDEBUG
    addrReg = 0xDDDDDDDD;
#endif

    /* Are we comparing against a constant? */

    if  (op2->gtOper == GT_CNS_INT)
    {
        long            ival = op2->gtIntCon.gtIconVal;

        /* Comparisons against 0 can be easier */

        if  (ival == 0)
        {
            /* Is this a simple zero/non-zero test? */

            if  (cmp == GT_EQ || cmp == GT_NE)
            {
                /* Is the operand an "AND" operation? */

                if  (op1->gtOper == GT_AND)
                {
                    GenTreePtr      an1 = op1->gtOp.gtOp1;
                    GenTreePtr      an2 = op1->gtOp.gtOp2;

                    /* Check for the case "expr & icon" */

                    if  (an2->gtOper == GT_CNS_INT)
                    {
                        long iVal = an2->gtIntCon.gtIconVal;

                        /* make sure that constant is not out of an1's range */

                        switch (an1->gtType)
                        {
                        case TYP_BOOL:
                        case TYP_BYTE:
                            if (iVal & 0xffffff00)
                                goto NO_TEST_FOR_AND;
                            break;
                        case TYP_CHAR:
                        case TYP_SHORT:
                            if (iVal & 0xffff0000)
                                goto NO_TEST_FOR_AND;
                            break;
                        }

                        if (an1->gtOper == GT_CNS_INT)
                        {
                            // Special case - Both operands of AND are consts
                            genComputeReg(an1, 0, true, true);
                            addrReg = 0;
                        }
                        else
                        {
                            addrReg = genMakeAddressable(an1, 0,
                                                        false, false, true);
                        }

                        inst_TT_IV(INS_test, an1, iVal);
                        goto DONE;

                    NO_TEST_FOR_AND:
                        ;

                    }

                    // UNDONE: Check for other cases that can generate 'test',
                    // UNDONE: also check for a 64-bit integer zero test which
                    // UNDONE: could generate 'or lo, hi' followed by jz/jnz.
                }
            }

            /* Is the value a simple local variable? */

            if  (op1->gtOper == GT_LCL_VAR)
            {
                /* Is the flags register set to the value? */

                switch (genFlagsAreVar(op1->gtLclVar.gtLclNum))
                {
                case 1:
                    if  (cmp != GT_EQ && cmp != GT_NE)
                        break;
                    else
                        /* fall through */ ;

                case 2:
                    addrReg = 0;
                    goto DONE;
                }
            }

            /* Make the comparand addressable */

            addrReg = genMakeRvalueAddressable(op1, 0, false, false, true);

            /* Are the condition flags set based on the value? */

            if  ((op1->gtFlags & (GTF_ZF_SET|GTF_CC_SET)) ||
                 ((op1->gtFlags & GTF_REG_VAL) && genFlagsAreReg(op1->gtRegNum)))
            {
                /* The zero flag is certainly enough for "==" and "!=" */

                if  (cmp == GT_EQ || cmp == GT_NE)
                    goto DONE;

                /* Without a 'cmp' we can only do "<" and ">="
                 * Also if unsigned comparisson cannot use JS or JNS */

                if  (((cmp == GT_LT) || (cmp == GT_GE)) && !(cond->gtFlags & GTF_UNSIGNED))
                {
                    jumpKind = ((cmp == GT_LT) ? EJ_js : EJ_jns);
                    goto DONE_FLAGS;
                }
            }

            /* Is the value in a register? */

            if  (op1->gtFlags & GTF_REG_VAL)
            {
                regNumber       reg = op1->gtRegNum;

                /* Is it just a test for equality? */

                if (cmp == GT_EQ || cmp == GT_NE)
                {
                    /* Generate 'test reg, reg' */

                    inst_RV_RV(INS_test, reg, reg, op1->TypeGet());
                    goto DONE;
                }

                /* With a 'test' we can only do "<" and ">=" */

                if  (((cmp == GT_LT) || (cmp == GT_GE))
                     && !(cond->gtFlags & GTF_UNSIGNED)  )
                {
                    /* Generate 'test reg, reg' */

                    inst_RV_RV(INS_test, reg, reg, op1->TypeGet());
                    jumpKind = ((cmp == GT_LT) ? EJ_js : EJ_jns);
                    goto DONE_FLAGS;
                }
            }
        }

        else // if (ival != 0)
        {
            bool smallOk = true;

            /* make sure that constant is not out of op1's range */

            /* If op1 is TYP_SHORT, and is followed by an unsigned
             * comparison, we can use smallOk. But we dont know which
             * flags will be needed. This probably doesnt happen often.
             */

            switch (op1->gtType)
            {
            case TYP_BOOL:
            case TYP_BYTE:  if (ival != (signed   char )ival) smallOk = false; break;
            case TYP_UBYTE: if (ival != (unsigned char )ival) smallOk = false; break;

            case TYP_SHORT: if (ival != (signed   short)ival) smallOk = false; break;
            case TYP_CHAR:  if (ival != (unsigned short)ival) smallOk = false; break;

            default:                                                           break;
            }
            /* Make the comparand addressable */

            addrReg = genMakeRvalueAddressable(op1, 0, false, false, smallOk);
        }

        /* Special case: comparison of two constants */

        // Needed if Importer doesnt call gtFoldExpr()

// #if defined(DEBUGGING_SUPPORT) || ALLOW_MIN_OPT

        if  (op1->gtOper == GT_CNS_INT)
        {
            // assert(opts.compMinOptim || opts.compDbgCode);

            /* HACK: get the constant operand into a register */

            genComputeReg(op1, 0, false, true);

            assert(addrReg == 0);
            assert(op1->gtFlags & GTF_REG_VAL);

            addrReg = genRegMask(op1->gtRegNum);
        }

// #endif

        /* Compare the operand against the constant */

        inst_TT_IV(INS_cmp, op1, ival);
        goto DONE;
    }

    //---------------------------------------------------------------------
    //
    // We reach here if op2 was not a GT_CNS_INT
    //

    assert(op1->gtOper != GT_CNS_INT);

    // UNDONE: Record the fact that down below it would be useful if
    // UNDONE: the register that holds 'op2' was a byte-addressable
    // UNDONE: register, so that the register allocator could take it
    // UNDONE: into account.

    if  (op2->gtOper == GT_LCL_VAR)
        genMarkLclVar(op2);

    /* Are we comparing against a register? */

    if  (op2->gtFlags & GTF_REG_VAL)
    {
        /* Make the comparand addressable */

        addrReg = genMakeAddressable(op1, 0, false, false, true);

        /* Is the other value still sitting in a register? */

        if  (op2->gtFlags & GTF_REG_VAL)
        {
            /* Is the size of the comparison byte/char/short ? */

            if  (op1->gtType < TYP_INT)
            {
                /* Is 'op2' sitting in an appropriate register? */

                if  (!isByteReg(op2->gtRegNum))
                {
                    goto NOT_RG2;
                }
            }

            /* Compare against the register */

            inst_TT_RV(INS_cmp, op1, op2->gtRegNum);

            addrReg |= genRegMask(op2->gtRegNum);
            goto DONE;
        }
    }

NOT_RG2:

    /* Compute the first comparand into some register */

    regNeed = 0; // ~op2->gtRsvdRegs

    if  (genTypeSize(op2->gtType) != sizeof(int))
        regNeed = RBM_BYTE_REGS;

    genComputeReg(op1, regNeed, false, false);
    assert(op1->gtFlags & GTF_REG_VAL);

#ifdef  SET_USED_REG_SET_DURING_CODEGEN
    cond->gtUsedRegs = op1->gtUsedRegs;
#endif

    /* Make the second comparand addressable */

    bool        smallOk;

    /* We can do a small type comparisson iff the operands are the same type
     * and op1 ended in a byte addressable register */

    smallOk = (genTypeSize(op2->gtType) == sizeof(int)   ) &&
              (             op1->gtType == op2->gtType   ) &&
              (genRegMask(op1->gtRegNum) & RBM_BYTE_REGS )  ;

    addrReg = genMakeRvalueAddressable(op2, 0, true, false, smallOk);

    /*
        Make sure the first operand is still in a register; if
        it's been spilled, we have to make sure it's reloaded
        into a byte-addressable register.
     */

    /* pass true to keep reg used. otherwise get pointer lifetimes wrong */
    genRecoverReg(op1, regNeed, true);

    assert(op1->gtFlags & GTF_REG_VAL);

    /* Make sure that recover didn't unspill a small int into ESI/EDI/EBP */

    assert(!smallOk || (genRegMask(op1->gtRegNum) & RBM_BYTE_REGS) );

    // UNDONE: lock op1, make sure op2 still addressable, unlock op1

    /* Perform the comparison */

    size = smallOk ?       emitTypeSize(op2->TypeGet())
                   : emitActualTypeSize(op2->TypeGet());

    if  ((op2->gtFlags & GTF_REG_VAL)  &&  (size < EA_4BYTE))
    {
        //
        // The old version of this hack would also convert
        //   EA_GCREF and EA_BYREF into EA_4BYTE,
        // which seems wrong,
        // This version only converts EA_1BYTE and EA2_BYTE into EA_4BYTE
        //
        size = EA_4BYTE; // TEMP HACK
    }

    inst_RV_TT(INS_cmp, op1->gtRegNum, op2, 0, size);

    /* Keep track of what registers we've used */

#ifdef  SET_USED_REG_SET_DURING_CODEGEN
    cond->gtUsedRegs |= op1->gtUsedRegs | op2->gtUsedRegs;
#endif

    /* free reg left used in Recover call */
    rsMarkRegFree(genRegMask(op1->gtRegNum));

    /* Free up anything that was tied up by the LHS */

    genDoneAddressable(op2, addrReg);

DONE:

    if (varTypeIsUnsigned(op1->TypeGet()) || (cond->gtFlags & GTF_UNSIGNED))
    {
        /* comparison between unsigned types */
        jumpKind = genJumpKindForOper(cmp, true);
    }
    else
    {
        /* signed comparisson */
        jumpKind = genJumpKindForOper(cmp, false);
    }

DONE_FLAGS: // We have determined what jumpKind to use

    genUpdateLife(cond);

    /* The condition value is dead at the jump that follows */

   assert(addrReg != 0xDDDDDDDD); gcMarkRegSetNpt(addrReg);

    return jumpKind;
}

/*****************************************************************************/
#endif//TGT_x86
/*****************************************************************************/
#if     TGT_SH3
/*****************************************************************************
 *
 *  Generate a conditional jump with a float/double operand.
 */

void                Compiler::genCondJumpFlt(GenTreePtr     cond,
                                             BasicBlock *   jumpTrue,
                                             BasicBlock *   jumpFalse)
{
    assert(!"RISC flt/dbl compare");
}

/*****************************************************************************
 *
 *  Generate a conditional jump with a long operand.
 */

void                Compiler::genCondJumpLng(GenTreePtr     cond,
                                             BasicBlock *   jumpTrue,
                                             BasicBlock *   jumpFalse)
{
    assert(!"RISC long compare");
}

/*****************************************************************************
 *
 *  Generates code that will set the "true" flag based on the given int/ptr
 *  comparison. When the value trueOnly is false, the "T" flag may be set to
 *  the opposite result of the comparison and 'false' is returned; otherwise
 *  'true' is returned.
 */

bool                    Compiler::genCondSetTflag(GenTreePtr    cond,
                                                  bool          trueOnly)
{
    GenTreePtr      op1 = cond->gtOp.gtOp1;
    GenTreePtr      op2 = cond->gtOp.gtOp2;
    genTreeOps      cmp = cond->OperGet();

    regNumber       rg1;
    regNumber       rg2;

    bool            uns;
    bool            sense;

    struct  cmpDsc
    {
        unsigned short  cmpIns;
        unsigned char   cmpRev;
        unsigned char   cmpYes;
    }
                *   jinfo;

    static
    cmpDsc          genCMPinsSgn[] =
    {
        //   ins    reverse   yes
        { INS_cmpEQ,  true,  true },   // GT_EQ
        { INS_cmpEQ, false, false },   // GT_NE
        { INS_cmpGT,  true,  true },   // GT_LT
        { INS_cmpGE,  true,  true },   // GT_LE
        { INS_cmpGE, false,  true },   // GT_GE
        { INS_cmpGT, false,  true },   // GT_GT
    };

    static
    cmpDsc          genCMPinsUns[] =
    {
        //   ins    reverse   yes
        { INS_cmpEQ,  true,  true },   // GT_EQ
        { INS_cmpEQ, false, false },   // GT_NE
        { INS_cmpHI,  true,  true },   // GT_LT
        { INS_cmpHS,  true,  true },   // GT_LE
        { INS_cmpHS, false,  true },   // GT_GE
        { INS_cmpHI, false,  true },   // GT_GT
    };

    assert(genCMPinsSgn[GT_EQ - GT_EQ].cmpIns == INS_cmpEQ);
    assert(genCMPinsSgn[GT_NE - GT_EQ].cmpIns == INS_cmpEQ);
    assert(genCMPinsSgn[GT_LT - GT_EQ].cmpIns == INS_cmpGT);
    assert(genCMPinsSgn[GT_LE - GT_EQ].cmpIns == INS_cmpGE);
    assert(genCMPinsSgn[GT_GE - GT_EQ].cmpIns == INS_cmpGE);
    assert(genCMPinsSgn[GT_GT - GT_EQ].cmpIns == INS_cmpGT);

    assert(genCMPinsUns[GT_EQ - GT_EQ].cmpIns == INS_cmpEQ);
    assert(genCMPinsUns[GT_NE - GT_EQ].cmpIns == INS_cmpEQ);
    assert(genCMPinsUns[GT_LT - GT_EQ].cmpIns == INS_cmpHI);
    assert(genCMPinsUns[GT_LE - GT_EQ].cmpIns == INS_cmpHS);
    assert(genCMPinsUns[GT_GE - GT_EQ].cmpIns == INS_cmpHS);
    assert(genCMPinsUns[GT_GT - GT_EQ].cmpIns == INS_cmpHI);

    assert(varTypeIsI(genActualType(cond->gtOp.gtOp1->gtType)));

    if  (cond->gtFlags & GTF_REVERSE_OPS)
    {
        /* Don't forget to modify the condition as well */

        cond->gtOp.gtOp1 = op2;
        cond->gtOp.gtOp2 = op1;
        cond->gtOper     = GenTree::SwapRelop(cmp);
        cond->gtFlags   &= ~GTF_REVERSE_OPS;

        /* Get hold of the new values */

        cmp  = cond->OperGet();
        op1  = cond->gtOp.gtOp1;
        op2  = cond->gtOp.gtOp2;
    }

    unsigned        regNeed;
    unsigned        addrReg;

#ifndef NDEBUG
    addrReg = 0xDDDDDDDD;
#endif

    /* Is this an unsigned or signed comparison? */

    if (varTypeIsUnsigned(op1->TypeGet()) || (cond->gtFlags & GTF_UNSIGNED))
    {
        uns   = true;
        jinfo = genCMPinsUns;
    }
    else
    {
        uns   = false;
        jinfo = genCMPinsSgn;
    }

    /* Are we comparing against a constant? */

    if  (op2->gtOper == GT_CNS_INT)
    {
        long            ival = op2->gtIntCon.gtIconVal;

        /* Comparisons against 0 can be easier */

        if  (ival == 0)
        {
            regNumber   reg;
            emitAttr    size = emitActualTypeSize(op1->TypeGet());

            /* Special case: comparison against 0 */

            genCodeForTree(op1, 0, 0);

            /* The comparand should be in a register now */

            assert(op1->gtFlags & GTF_REG_VAL);

            reg     = op1->gtRegNum;
            addrReg = genRegMask(reg);

            /* What kind of a comparison do we have? */

            switch (cmp)
            {
            case GT_EQ:
                genEmitter->emitIns_R_R(INS_tst, size, (emitRegs)reg,
                                                       (emitRegs)reg);
                sense = true;
                break;

            case GT_NE:
                if  (!trueOnly)
                {
                    genEmitter->emitIns_R_R(INS_tst, size, (emitRegs)reg,
                                                           (emitRegs)reg);
                    sense = false;
                    break;
                }
                assert(!"integer != for SH-3 NYI");

            case GT_LT:

                assert(uns == false); // UNDONE: unsigned compare against 0

                if  (!trueOnly)
                {
                    genEmitter->emitIns_R(INS_cmpPZ, size, (emitRegs)reg);

                    sense = false;
                    break;
                }
                assert(!"integer <  for SH-3 NYI");

            case GT_LE:

                assert(uns == false); // UNDONE: unsigned compare against 0

                if  (!trueOnly)
                {
                    genEmitter->emitIns_R(INS_cmpPL, size, (emitRegs)reg);

                    sense = false;
                    break;
                }
                assert(!"integer <= for SH-3 NYI");

            case GT_GE:

                assert(uns == false); // UNDONE: unsigned compare against 0

                genEmitter->emitIns_R(INS_cmpPZ, size, (emitRegs)reg);
                sense = true;
                break;

            case GT_GT:

                assert(uns == false); // UNDONE: unsigned compare against 0

                genEmitter->emitIns_R(INS_cmpPL, size, (emitRegs)reg);
                sense = true;
                break;

            default:
#ifdef DEBUG
                gtDispTree(cond);
#endif
                assert(!"compare operator NYI");
            }

            goto DONE_FLAGS;
        }
    }

    /* Compute the first operand into any register */

    genComputeReg(op1, 0, false, false, false);
    assert(op1->gtFlags & GTF_REG_VAL);

    /* Compute the second operand into any register */

    genComputeReg(op2, 0, false, false, false);
    assert(op2->gtFlags & GTF_REG_VAL);
    rg2 = op2->gtRegNum;

    /* Make sure the first operand is still in a register */

    genRecoverReg(op1, 0, true);
    assert(op1->gtFlags & GTF_REG_VAL);
    rg1 = op1->gtRegNum;

    /* Make sure the second operand is still addressable */

    genLockAddressable(op2, genRegMask(rg1), genRegMask(rg2));

    /* Point at the appropriate comparison entry */

    jinfo = (uns ? genCMPinsUns
                 : genCMPinsSgn) + (cmp - GT_EQ);

    /* Reverse the operands if necessary */

    if  (jinfo->cmpRev)
    {
        rg2 = op1->gtRegNum;
        rg1 = op2->gtRegNum;
    }

    /* Now perform the comparison */

    genEmitter->emitIns_R_R((instruction)jinfo->cmpIns,
                             EA_4BYTE,
                             (emitRegs)rg1,
                             (emitRegs)rg2);

    /* Free up both operands */

    genReleaseReg(op1);
    genReleaseReg(op2);

    genUpdateLife(cond);

    addrReg = genRegMask(rg1) | genRegMask(rg2);

    /* Are we required to produce a "true" result? */

    if  (jinfo->cmpYes)
    {
        sense = true;
    }
    else
    {
        if  (trueOnly)
        {
            assert(!"reverse comparison result");
        }
        else
        {
            sense = false;
        }
    }

DONE_FLAGS:

    /* The condition value is dead at the jump that will follow */

    assert(addrReg != 0xDDDDDDDD); gcMarkRegSetNpt(addrReg);

    return  sense;
}

/*****************************************************************************
 *
 *  Set the "T" flag to the result of comparing the given register value
 *  agains the given integer constant.
 */

void                Compiler::genCompareRegIcon(regNumber   reg,
                                                int         val,
                                                bool        uns,
                                                genTreeOps  rel)
{
    GenTree         op1;
    GenTree         op2;
    GenTree         cmp;

    op1.gtOper             = GT_REG_VAR;
    op1.gtType             = TYP_INT;
    op1.gtFlags            = GTF_REG_VAL;
    op1.gtRegNum           =
    op1.gtRegVar.gtRegNum  = reg;
    op1.gtRegVar.gtRegVar  = -1;

    op2.gtOper             = GT_CNS_INT;
    op2.gtType             = TYP_INT;
    op2.gtFlags            = 0;
    op2.gtIntCon.gtIconVal = val;

    cmp.gtOper             = rel;
    cmp.gtType             = TYP_INT;
    cmp.gtFlags            = uns ? GTF_UNSIGNED : 0;
    cmp.gtOp.gtOp1         = &op1;
    cmp.gtOp.gtOp2         = &op2;

    op1.gtLiveSet          =
    op2.gtLiveSet          =
    cmp.gtLiveSet          = genCodeCurLife;

#ifdef  DEBUG
    op1.gtFlags           |= GTF_NODE_LARGE;
    op2.gtFlags           |= GTF_NODE_LARGE;
    cmp.gtFlags           |= GTF_NODE_LARGE;
#endif

    genCondSetTflag(&cmp, true);
}

/*****************************************************************************/
#endif//TGT_SH3
/*****************************************************************************
 *
 *  Generate code to jump to the jump target of the current basic block if
 *  the given relational operator yields 'true'.
 */

void                Compiler::genCondJump(GenTreePtr cond, BasicBlock *destTrue,
                                                           BasicBlock *destFalse)
{
    BasicBlock  *   jumpTrue;
    BasicBlock  *   jumpFalse;

    GenTreePtr      op1       = cond->gtOp.gtOp1;
    GenTreePtr      op2       = cond->gtOp.gtOp2;
    genTreeOps      cmp       = cond->OperGet();

#if INLINING
    if  (destTrue)
    {
        jumpTrue  = destTrue;
        jumpFalse = destFalse;
    }
    else
#endif
    {
        assert(compCurBB->bbJumpKind == BBJ_COND);

        jumpTrue  = compCurBB->bbJumpDest;
        jumpFalse = compCurBB->bbNext;
    }

    assert(cond->OperIsCompare());

    /* Make sure the more expensive operand is 'op1' */

    if  (cond->gtFlags & GTF_REVERSE_OPS)
    {
        /* Don't forget to modify the condition as well */

        cond->gtOp.gtOp1 = op2;
        cond->gtOp.gtOp2 = op1;
        cond->gtOper     = GenTree::SwapRelop(cmp);
        cond->gtFlags   &= ~GTF_REVERSE_OPS;

        /* Get hold of the new values */

        cmp  = cond->OperGet();
        op1  = cond->gtOp.gtOp1;
        op2  = cond->gtOp.gtOp2;
    }

    /* What is the type of the operand? */

    switch (genActualType(op1->gtType))
    {
    case TYP_INT:
    case TYP_REF:
    case TYP_BYREF:

#if TGT_x86

        emitJumpKind    jumpKind;

        // Check if we can use the currently set flags. Else set them

        jumpKind = genCondSetFlags(cond);

        /* Generate the conditional jump */

        inst_JMP(jumpKind, jumpTrue);

#else

        instruction     ins;

        /* Set the "true" flag and figure what jump to use */

        ins = genCondSetTflag(cond, false) ? INS_bt
                                           : INS_bf;

        /* Issue the conditional jump */

        genEmitter->emitIns_J(ins, false, false, jumpTrue);

#endif

        return;

    case TYP_LONG:

        genCondJumpLng(cond, jumpTrue, jumpFalse);
        return;

    case TYP_FLOAT:
    case TYP_DOUBLE:

        genCondJumpFlt(cond, jumpTrue, jumpFalse);
        return;

#ifdef DEBUG
    default:
        gtDispTree(cond);
        assert(!"unexpected/unsupported 'jtrue' operands type");
#endif
    }
}

/*****************************************************************************
 *
 *  The following can be used to create basic blocks that serve as labels for
 *  the emitter. Use with caution - these are not real basic blocks!
 */

inline
BasicBlock *        Compiler::genCreateTempLabel()
{
    BasicBlock  *   block = bbNewBasicBlock(BBJ_NONE);
    block->bbFlags |= BBF_JMP_TARGET|BBF_HAS_LABEL;
    return  block;
}

inline
void                Compiler::genDefineTempLabel(BasicBlock *label, bool inBlock)
{
#ifdef  DEBUG
    if  (dspCode) printf("\n      L_%02u_%02u:\n", Compiler::s_compMethodsCount, label->bbNum);
#endif

    genEmitter->emitAddLabel(&label->bbEmitCookie,
                             gcVarPtrSetCur,
                             gcRegGCrefSetCur,
                             gcRegByrefSetCur);
}

/*****************************************************************************
 *
 * The last operation done was generating code for "tree" and that would
 * have set the flags. Check if the operation caused an overflow
 * For small types, "reg" is where the result register. We need to sign-extend it
 */

inline
void            Compiler::genCheckOverflow(GenTreePtr tree, regNumber reg)
{
    genTreeOps oper = tree->OperGet();
    var_types  type = tree->TypeGet();

    // Overflow-check should be asked for for this tree
    assert(tree->gtOverflow());

#if TGT_x86

    emitJumpKind jumpKind = (tree->gtFlags & GTF_UNSIGNED) ? EJ_jb : EJ_jo;

    // Get the block to jump to, which will throw the expection

    AddCodeDsc * add = fgFindExcptnTarget(  ACK_OVERFLOW,
                                            compCurBB->bbTryIndex);
    assert(add && add->acdDstBlk);

    // Jump to the excptn-throwing block

    inst_JMP(jumpKind, add->acdDstBlk, true, true, true);

    // No sign extension needed for TYP_INT,TYP_LONG,
    // so 'reg' can be ignored. Else it should be valid

    assert(genIsValidReg(reg) || genTypeSize(type) >= sizeof(int));

    switch(type)
    {
    case TYP_BYTE:

        assert(genRegMask(reg) & RBM_BYTE_REGS);
        // Fall-through

    case TYP_SHORT:

        // ISSUE : Should we select another register to expand the value into

        inst_RV_RV(INS_movsx, reg, reg, type, emitTypeSize(type));
        break;

    case TYP_UBYTE:
    case TYP_CHAR:
        inst_RV_RV(INS_movzx, reg, reg, type, emitTypeSize(type));
        break;

    default:
        break;
    }

#else

    assert(!"need non-x86 overflow checking code");

#endif

}

/*****************************************************************************
 *
 *  Generate code for the given tree (if 'destReg' is non-zero, we'll do our
 *  best to compute the value into a register that is in that register set).
 */

void                Compiler::genCodeForTree(GenTreePtr tree, unsigned destReg,
                                                              unsigned bestReg)
{
    var_types       treeType = tree->TypeGet();
    genTreeOps      oper;
    unsigned        kind;

    regNumber       reg;
#if TGT_RISC
    regNumber       rg2;
#endif

// @TODO:  the 'regs' variable should only represent the register actively held
//         by the tree not all registers touched.  (we are not consistant below)

    unsigned        regs;

    emitAttr        size;
    instruction     ins;

    unsigned        needReg;
    unsigned        prefReg;
    unsigned        goodReg;

#ifdef  DEBUG
//  if  ((int)tree == 0x00360264) debugStop(0);
#endif

    assert(tree);
    assert(tree->gtOper != GT_STMT);

    assert(tree->IsNodeProperlySized());

#ifndef NDEBUG
    reg  =  (regNumber)0xFEEFFAAF;              // to detect uninitialized use
#endif
    regs = rsMaskUsed;

    /* 'destReg' of 0 really means 'any' */

    if  (!destReg) destReg = RBM_ALL;

    /* We'll try to satisfy both 'destReg' and 'bestReg' */

    prefReg = destReg;

#if 1

    needReg = prefReg;

#else

    needReg = prefReg & bestReg;

    if  (needReg)
    {
        /* Yes, we can satisfy both 'destReg' and 'bestReg' */

        prefReg = needReg;
    }
    else
    {
        /* Let's pick at least one of 'destReg' or 'bestReg' */

        needReg = destReg;
        if  (!needReg)
            needReg = bestReg;
    }

#endif

    /* Is this a floating-point or long operation? */

    switch (treeType)
    {
    case TYP_LONG:
#if !   CPU_HAS_FP_SUPPORT
    case TYP_DOUBLE:
#endif
        genCodeForTreeLng(tree, needReg);
        return;

#if     CPU_HAS_FP_SUPPORT
    case TYP_FLOAT:
    case TYP_DOUBLE:
        genCodeForTreeFlt(tree, false);
        return;
#endif

#ifdef DEBUG
    case TYP_UINT:
    case TYP_ULONG:
        assert(!"These types are only used as markers in GT_CAST nodes");
#endif
    }

#if     TGT_x86
#ifdef  GC_WRITE_BARRIER_CALL
    unsigned needReg1 = ((needReg & ~RBM_EDX) ? needReg : RBM_ALL) & ~ RBM_EDX;
#endif
#endif

    /* Is the value already in a register? */

    if  (tree->gtFlags & GTF_REG_VAL)
    {

    REG_VAR1:

        reg   = tree->gtRegNum;
        regs |= genRegMask(reg);

        gcMarkRegPtrVal(reg, tree->TypeGet());

        goto DONE;
    }

    /* We better not have a spilled value here */

    assert((tree->gtFlags & GTF_SPILLED) == 0);

    /* Figure out what kind of a node we have */

    oper = tree->OperGet();
    kind = tree->OperKind();

    /* Is this a constant node? */

    if  (kind & GTK_CONST)
    {
        switch (oper)
        {
            int             ival;

        case GT_CNS_INT:

            ival = tree->gtIntCon.gtIconVal;

#if!CPU_HAS_FP_SUPPORT
        INT_CNS:
#endif

#if REDUNDANT_LOAD

            /* Is the constant already in register? If so, use this register */

            reg = rsIconIsInReg(ival);

            if  (reg != REG_NA)
            {
                regs |= genRegMask(reg);
                break;
            }

#endif

            reg   = rsPickReg(needReg, bestReg);
            regs |= genRegMask(reg);

            /* If the constant is a handle, we need a reloc to be applied to it */

            if (tree->gtFlags & GTF_ICON_HDL_MASK)
                genEmitter->emitIns_R_I(INS_mov, EA_4BYTE_CNS_RELOC, (emitRegs)reg, ival);
            else
                genSetRegToIcon(reg, ival, tree->TypeGet());
            break;

#if!CPU_HAS_FP_SUPPORT
        case GT_CNS_FLT:
            ival = *(int *)&tree->gtFltCon.gtFconVal;
            goto INT_CNS;
#endif

        default:
#ifdef  DEBUG
            gtDispTree(tree);
#endif
            assert(!"unexpected constant node");
        }

#ifdef  DEBUG
        /* Special case: GT_CNS_INT - Restore the current live set if it was changed */

        if  (!genTempLiveChg)
        {
            genCodeCurLife = genTempOldLife;
            genTempLiveChg = true;
        }
#endif

        goto DONE;
    }

    /* Is this a leaf node? */

    if  (kind & GTK_LEAF)
    {
        switch (oper)
        {
        case GT_REG_VAR:
            assert(!"should have been caught above");

        case GT_LCL_VAR:

            /* Does the variable live in a register? */

            if  (genMarkLclVar(tree))
                goto REG_VAR1;

#if REDUNDANT_LOAD

            /* Is the local variable already in register? */

            reg = rsLclIsInReg(tree->gtLclVar.gtLclNum);

            if (reg != REG_NA)
            {
                /* Use the register the variable happens to be in */

                regs |= genRegMask(reg);
                gcMarkRegPtrVal (reg, tree->TypeGet());

                break;
            }

#endif

#if TGT_RISC

            /* Pick a register for the value */

            reg = rsPickReg(needReg, bestReg, tree->TypeGet());

            /* Load the variable into the register */

            inst_RV_TT(INS_mov, reg, tree, 0);

            gcMarkRegPtrVal (reg, tree->TypeGet());
            rsTrackRegLclVar(reg, tree->gtLclVar.gtLclNum);
            break;

        case GT_CLS_VAR:

            /* Pick a register for the address/value */

            reg = rsPickReg(needReg, bestReg, TYP_INT);

            /* Load the variable value into the register */

            inst_RV_TT(INS_mov, reg, tree, 0);

            // UNDONE: Make register load suppression work for addresses!

            rsTrackRegTrash(reg);
            gcMarkRegPtrVal(reg, tree->TypeGet());
            break;

#else

            // Fall through ....

        case GT_CLS_VAR:

            /* Pick a register for the value */

            reg = rsPickReg(needReg, bestReg, tree->TypeGet());

            /* Load the variable into the register */

            size = EA_SIZE(genTypeSize(tree->gtType));

            if  (size < EA_4BYTE)
            {
                bool        uns = varTypeIsUnsigned(tree->TypeGet());

                inst_RV_TT(uns ? INS_movzx : INS_movsx, reg, tree, 0);

                /* We've now "promoted" the tree-node to TYP_INT */

                tree->gtType = TYP_INT;
            }
            else
            {
                inst_RV_TT(INS_mov, reg, tree, 0);
            }

            rsTrackRegTrash(reg);

            gcMarkRegPtrVal (reg, tree->TypeGet());

            if  (oper == GT_CLS_VAR)
            {
                rsTrackRegClsVar(reg, tree->gtClsVar.gtClsVarHnd);
            }
            else
            {
                rsTrackRegLclVar(reg, tree->gtLclVar.gtLclNum);
            }

            break;

        case GT_BREAK:
            // @TODO : Remove GT_BREAK if cee_break will continue to invoke a helper call.
            assert(!"Currently replaced by CPX_USER_BREAKPOINT");
            instGen(INS_int3);
            reg = REG_STK;
            break;

        case GT_NO_OP:
            assert(opts.compDbgCode); // Should normally be optimized away
            instGen(INS_nop);
            reg = REG_STK;
            break;

#endif // TGT_RISC


#if OPTIMIZE_QMARK
#if TGT_x86

        case GT_BB_QMARK:

            /* The "_?" value is always in EAX */
            /* CONSIDER: Don't always load the value into EAX! */

            reg  = REG_EAX;
            break;
#endif
#endif


        case GT_CATCH_ARG:

            /* Catch arguments get passed in the return register */

            reg = REG_INTRET;
            break;

#ifdef  DEBUG
        default:
            gtDispTree(tree);
            assert(!"unexpected leaf");
#endif
        }

        regs |= genRegMask(reg);
        goto DONE;
    }

    /* Is it a 'simple' unary/binary operator? */

    if  (kind & GTK_SMPOP)
    {
        bool            gotOp1;
        bool            isArith;
        bool            op2Released;
        unsigned        addrReg;

        GenTreePtr      op1 = tree->gtOp.gtOp1;
        GenTreePtr      op2 = tree->gtOp.gtOp2;

        GenTreePtr      opsPtr[3];
        unsigned        regsPtr[3];
        bool            ovfl = false;        // Do we need an overflow check
        unsigned        val;

#if GC_WRITE_BARRIER_CALL
        unsigned        regGC;
#endif

#ifndef NDEBUG
        addrReg = 0xDEADCAFE;
#endif

        switch (oper)
        {
            bool            multEAX;
            bool            andv;
            BOOL            unsv;
            unsigned        mask;

        case GT_ASG:

            /* Is the target a register or local variable? */

            switch (op1->gtOper)
            {
                unsigned        varNum;
                LclVarDsc   *   varDsc;
                VARSET_TP       varBit;
                bool            deadStore;

            case GT_CATCH_ARG:
                break;

            case GT_LCL_VAR:

                varNum = op1->gtLclVar.gtLclNum;
                assert(varNum < lvaCount);
                varDsc = lvaTable + varNum;
                varBit = genVarIndexToBit(varDsc->lvVarIndex);

                /* Is this a dead store ? */

                deadStore = varDsc->lvTracked && !(varBit & tree->gtLiveSet);

                /* Don't eliminate assignment of 'return address' (in finally) */
                /* and make sure the variable is not volatile */

                if  ((op2->gtOper == GT_RET_ADDR) || varDsc->lvVolatile)
                    deadStore = false;

#ifdef DEBUGGING_SUPPORT

                /* For non-debuggable code, every definition of a lcl-var has
                 * to be checked to see if we need to open a new scope for it.
                 */
                if (opts.compScopeInfo && !opts.compDbgCode &&
                    info.compLocalVarsCount>0 && !deadStore)
                {
                    siCheckVarScope(varNum, op1->gtLclVar.gtLclOffs);
                }

#endif

                /* Does this variable live in a register? */

                if  (genMarkLclVar(op1))
                    goto REG_VAR2;

                /* Eliminate dead stores */

                if  (deadStore)
                {
#ifdef DEBUG
                    if  (verbose) printf("Eliminating dead store into #%u\n", varNum);
#endif
                    genEvalSideEffects(op2, 0);
                    addrReg = 0;

                    goto DONE_ASSG;
                }

#if OPT_BOOL_OPS
#if TGT_x86

                /* Special case: not'ing of a boolean variable */

                if  (!varDsc->lvNotBoolean && op2->gtOper == GT_LOG0)
                {
                    GenTreePtr      opr = op2->gtOp.gtOp1;

                    if  (opr->gtOper            == GT_LCL_VAR &&
                         opr->gtLclVar.gtLclNum == varNum)
                    {
                        inst_TT_IV(INS_xor, op1, 1);

                        rsTrashLcl(op1->gtLclVar.gtLclNum);

                        addrReg = 0;
                        goto DONE_ASSG;
                    }
                }

#endif
#endif
                break;

            case GT_CLS_VAR:

                /* ISSUE: is it OK to always assign an entire int ? */

                if  (op1->gtType < TYP_INT)
                     op1->gtType = TYP_INT;

                break;

            case GT_REG_VAR:
                assert(!"This was used before. Now it should never be reached directly");

            REG_VAR2:

                /* Is this a dead store? */

                if  (deadStore)
                {
#ifdef DEBUG
                    if  (verbose) printf("Eliminating dead store into '%s'\n",
                                compRegVarName(op1->gtRegVar.gtRegNum));
#endif
                    genEvalSideEffects(op2, 0);
                    addrReg = genRegMask(op1->gtRegVar.gtRegNum);
                    goto DONE_ASSG;
                }

                /* Get hold of the target register */

                reg = op1->gtRegVar.gtRegNum;

                /* Special case: assignment of 'return address' */

                if  (op2->gtOper == GT_RET_ADDR)
                {
                    /* Make sure the target of the store is available */

                    assert((rsMaskUsed & genRegMask(reg)) == 0);

                    goto RET_ADR;
                }

                /* Special case: assignment by popping off the stack */

                if  (op2->gtOper == GT_POP)
                {
                    /* Make sure the target of the store is available */

                    assert((rsMaskUsed & genRegMask(reg)) == 0);
#if TGT_x86
                    /* Generate 'pop reg' and we're done */

                    genStackLevel -= sizeof(void *);
                    inst_RV(INS_pop, reg, op2->TypeGet());
                    genStackLevel += sizeof(void *);

                    genSinglePop();

#else

                    assert(!"need non-x86 code");

#endif

                    /* Make sure we track the values properly */

                    rsTrackRegTrash(reg);
                    gcMarkRegPtrVal(reg, tree->TypeGet());

                    addrReg = 0;
                    goto DONE_ASSG;
                }

#if OPT_BOOL_OPS
#if TGT_x86

                /* Special case: not'ing of a boolean variable */

                if  (!varDsc->lvNotBoolean && op2->gtOper == GT_LOG0)
                {
                    GenTreePtr      opr = op2->gtOp.gtOp1;

                    if  (opr->gtOper            == GT_LCL_VAR &&
                         opr->gtLclVar.gtLclNum == varNum)
                    {
                        inst_RV_IV(INS_xor, reg, 1);

                        rsTrackRegTrash(reg);

                        addrReg = 0;
                        goto DONE_ASSG;
                    }
                }

#endif
#endif

                /* Compute the RHS (hopefully) into the variable's register */

                if  (needReg & genRegMask(reg))
                     needReg = genRegMask(reg);

#ifdef DEBUG

                /* Special cases: op2 is a GT_CNS_INT */

                if  (op2->gtOper == GT_CNS_INT)
                {
                    /* Save the old life status */

                    genTempOldLife = genCodeCurLife;
                    genCodeCurLife = op1->gtLiveSet;

                    /* Set a flag to avoid printing the stupid message
                       and remember that life was changed. */

                    genTempLiveChg = false;
                }
#endif
                // @TODO: For debuggable code, reg will already be part of
                // rsMaskVars as variables are kept alive everywhere. So
                // we should in fact steer away from reg if opts.compDbgCode.
                // Same for float, longs, etc.

                genCodeForTree(op2, needReg, genRegMask(reg));
                assert(op2->gtFlags & GTF_REG_VAL);

                /* Make sure the value ends up in the right place ... */

#if defined(DEBUG) && !defined(NOT_JITC)
                /* hack to make variables printable */
                if (varNames) genUpdateLife(tree);
#endif

                if  (op2->gtRegNum != reg)
                {
                    /* Make sure the target of the store is available */
                    /* CONSIDER: We should be able to avoid this situation somehow */

                    if  (rsMaskUsed & genRegMask(reg))
                        rsSpillReg(reg);
#if TGT_x86
                    inst_RV_RV(INS_mov, reg, op2->gtRegNum, op2->TypeGet());
#else
                    genEmitter->emitIns_R_R(INS_mov,
                                            emitActualTypeSize(op2->TypeGet()),
                                            (emitRegs)reg,
                                            (emitRegs)op2->gtRegNum);

#endif

                    /* The value has been transferred to 'reg' */

                    rsTrackRegCopy (reg, op2->gtRegNum);

                    gcMarkRegSetNpt(genRegMask(op2->gtRegNum));
                    gcMarkRegPtrVal(reg, tree->TypeGet());
                }
#ifdef  DEBUG
                else
                {
                    /* Couldn't print the var name because it wasn't marked live */

                    if  (dspCode  &&
                         varNames && info.compLocalVarsCount>0
                                  && genTempLiveChg && op2->gtOper != GT_CNS_INT)
                    {
                        unsigned        blkBeg = compCurBB->bbCodeOffs;
                        unsigned        blkEnd = compCurBB->bbCodeSize + blkBeg;
                        unsigned        varNum = op1->gtRegVar.gtRegVar;
                        LocalVarDsc *   lvd    = compFindLocalVar(varNum,
                                                                  blkBeg,
                                                                  blkEnd);
                        if (lvd)
                        {
                            printf("            ;       %s now holds '%s'\n",
                                    compRegVarName(op1->gtRegVar.gtRegNum),
                                    lvdNAMEstr(lvd->lvdName));
                        }
                    }
                }
#endif

                addrReg = 0;
                goto DONE_ASSG;
            }

#if GEN_COUNT_PTRASG
#if TGT_x86

            /* Are we assigning a persistent pointer value? */

            if  (op1->gtType == TYP_REF)
            {
                switch (op1->gtOper)
                {
                case GT_IND:
                case GT_CLS_VAR:
                    genEmitter.emitCodeGenByte(0xFF);
                    genEmitter.emitCodeGenByte(0x05);
                    genEmitter.emitCodeGenLong((int)&ptrAsgCount);
#ifndef NOT_JITC
                    ptrAsgCount++;
#endif
                    break;
                }
            }

#endif
#endif

            /* Is the value being assigned a simple one? */

            switch (op2->gtOper)
            {
            case GT_LCL_VAR:

                if  (!genMarkLclVar(op2))
                    goto SMALL_ASG;

                // Fall through ...

            case GT_REG_VAR:

                /* Is the target a byte/short/char value? */

                if  (op1->gtType < TYP_INT)
                    goto SMALL_ASG;

#if CSE

                /* This can happen when the RHS becomes a CSE */

                if  (tree->gtFlags & GTF_REVERSE_OPS)
                    goto SMALL_ASG;

#endif

                /* Make the target addressable */

                addrReg = genMakeAddressable(op1, needReg, true, false, true);

                // UNDONE: Write barrier for non-x86

#if GC_WRITE_BARRIER_CALL && TGT_x86

                /* Write barrier helper does the assignment */

                regGC = WriteBarrier(op1, op2->gtRegVar.gtRegNum, addrReg);

                if  (regGC != 0)
                {
                    regs |= regGC;
                }
                else
                {
                    /* Move the value into the target */

                    inst_TT_RV(INS_mov, op1, op2->gtRegVar.gtRegNum);
                }

#else

                /* Move the value into the target */

                inst_TT_RV(INS_mov, op1, op2->gtRegVar.gtRegNum);

                /* This could be a pointer assignment */

#if TGT_x86
                regs |= WriteBarrier(op1, op2->gtRegVar.gtRegNum);
#endif

#endif

                /* Free up anything that was tied up by the LHS */

                genDoneAddressable(op1, addrReg);

                /* Remember that we've also touched the op2 register */

                addrReg |= genRegMask(op2->gtRegVar.gtRegNum);
                break;

#if TGT_x86

            case GT_CNS_INT:

                /* Make the target addressable */

                addrReg = genMakeAddressable(op1, needReg, true, false, true);

#if REDUNDANT_LOAD
                reg = rsIconIsInReg(op2->gtIntCon.gtIconVal);

                if  (reg != REG_NA && (genTypeSize(tree->TypeGet()) == genTypeSize(TYP_INT) ||
                                       isByteReg(reg)))
                {
                    genCodeForTree(op2, needReg);

                    assert(op2->gtFlags & GTF_REG_VAL);

                    /* Move the value into the target */

                    inst_TT_RV(INS_mov, op1, op2->gtRegNum);
                }
                else
#endif
                /* Move the value into the target */

                inst_TT_IV(INS_mov, op1, op2->gtIntCon.gtIconVal);

                /* Free up anything that was tied up by the LHS */

                genDoneAddressable(op1, addrReg);
                break;

#endif

            case GT_RET_ADDR:

            RET_ADR:

                /* this should only happen at the start of a finally-clause,
                   i.e. we start with the return-value pushed onto the stack.
                   Right now any try-block requires an EBP frame, so we don't
                   have to deal with proper stack-depth tracking for BBs with
                   non-empty stack on entry.
                */

#if TGT_x86

                assert(genFPreqd);

                genEmitter->emitMarkStackLvl(sizeof(void*));

                /* We pop the return address off the stack into the target */

                addrReg = genMakeAddressable(op1, needReg, true, false, true);

                /* Move the value into the target */

                inst_TT(INS_pop, op1);

                /* Free up anything that was tied up by the LHS */

                genDoneAddressable(op1, addrReg);


#else

#ifdef  DEBUG
                gtDispTree(tree);
#endif
                assert(!"need non-x86 code");

#endif

                break;

            case GT_POP:

                assert(op1->gtOper == GT_LCL_VAR);

#if TGT_x86

                /* Generate 'pop [lclVar]' and we're done */

                genStackLevel -= sizeof(void*);
                inst_TT(INS_pop, op1);
                genStackLevel += sizeof(void*);

                genSinglePop();

                addrReg = 0;

#else

#ifdef  DEBUG
                gtDispTree(tree);
#endif
                assert(!"need non-x86 code");

#endif

                break;

            default:

            SMALL_ASG:

#if GC_WRITE_BARRIER_CALL
                bool            isWriteBarrier = false;
#endif

#if TGT_x86

                /*
                    Is the LHS more complex than the RHS? Also, if
                    target (op1) is a local variable, start with op2.
                 */

                if  ((tree->gtFlags & GTF_REVERSE_OPS) || op1->gtOper == GT_LCL_VAR)
                {
                    /* Is the target a byte/short/char value? */

                    if  (op1->gtType < TYP_INT)
                    {
                        if  (op2->gtOper == GT_CAST)
                        {
                            /* Special case: cast to small type */

                            if  (op2->gtOp.gtOp2->gtIntCon.gtIconVal >=
                                 op1->gtType)
                            {
                                /* Make sure the cast operand is not > int */

                                if  (op2->gtOp.gtOp1->gtType <= TYP_INT)
                                {
                                    /* Cast via a non-smaller type */

                                    op2 = op2->gtOp.gtOp1;
                                }
                            }
                        }

                        if (op2->gtOper             == GT_AND &&
                            op2->gtOp.gtOp2->gtOper == GT_CNS_INT)
                        {
                            switch (op1->gtType)
                            {
                            case TYP_BYTE : mask = 0x000000FF; break;
                            case TYP_SHORT: mask = 0x0000FFFF; break;
                            case TYP_CHAR : mask = 0x0000FFFF; break;
                            default: goto SIMPLE_SMALL;
                            }

                            if  ((unsigned)op2->gtOp.gtOp2->gtIntCon.gtIconVal == mask)
                            {
                                /* Redundant AND */

                                op2 = op2->gtOp.gtOp1;
                            }
                        }

                        /* Must get the new value into a byte register */

                    SIMPLE_SMALL:

                        genComputeReg(op2, RBM_BYTE_REGS, true, false);
                    }
                    else
                    {
                        /* Generate the RHS into a register */

#if GC_WRITE_BARRIER_CALL
                        isWriteBarrier = Compiler::gcIsWriteBarrierAsgNode(tree);
                        if  (isWriteBarrier)
                            genComputeReg(op2, needReg1, true, false);
                        else
#endif
                            genComputeReg(op2, needReg, false, false);
                    }

                    assert(op2->gtFlags & GTF_REG_VAL);

                    /* Make the target addressable */

#if GC_WRITE_BARRIER_CALL
                    if  (isWriteBarrier)
                    {
                        addrReg = genMakeAddressable(op1, needReg1, true, false, true);
                    }
                    else
#endif
                        addrReg = genMakeAddressable(op1, needReg, true, false, true);

                    /*
                        Make sure the RHS register hasn't been spilled;
                        keep the register marked as "used", otherwise
                        we might get the pointer lifetimes wrong.
                     */

                    genRecoverReg(op2, RBM_BYTE_REGS, true);
                    assert(op2->gtFlags & GTF_REG_VAL);

                    /* Lock the RHS temporarily (lock only already used) */

                    rsLockUsedReg(genRegMask(op2->gtRegNum));

                    /* Make sure the LHS is still addressable */

                    addrReg = genKeepAddressable(op1, addrReg);

                    /* We can unlock (only already used ) the RHS register */

                    rsUnlockUsedReg(genRegMask(op2->gtRegNum));

#if GC_WRITE_BARRIER_CALL

                    /* Write barrier helper does the assignment */

                    regGC = WriteBarrier(op1, op2->gtRegNum, addrReg);

                    if  (regGC != 0)
                    {
                        assert(isWriteBarrier);
                        regs |= regGC;
                    }
                    else
                    {
                        /* Move the value into the target */

                        inst_TT_RV(INS_mov, op1, op2->gtRegNum);
                    }

#ifdef SSB
                    rsMarkRegFree(genRegMask(op2->gtRegNum));
#endif

#else
                    /* Move the value into the target */

                    inst_TT_RV(INS_mov, op1, op2->gtRegNum);

#ifdef SSB
                    rsMarkRegFree(genRegMask(op2->gtRegNum));
#endif
                    /* This could be a pointer assignment */

                    regs |= WriteBarrier(op1, op2->gtRegNum);
#endif

                    /* Update the current liveness info */

#ifndef NDEBUG
                    if (varNames) genUpdateLife(tree);
#endif

#ifndef SSB
                    /* free reg left used in Recover call */
                    rsMarkRegFree(genRegMask(op2->gtRegNum));
#endif

                    /* Free up anything that was tied up by the LHS */

                    genDoneAddressable(op1, addrReg);
                }
                else
                {
                    prefReg = ~op2->gtRsvdRegs;

#if GC_WRITE_BARRIER_CALL
                    isWriteBarrier = Compiler::gcIsWriteBarrierAsgNode(tree);

                    if  (isWriteBarrier)
                        needReg = needReg1;
#endif

                    if  (needReg &  prefReg)
                         needReg &= prefReg;

                    /* Make the target addressable */

                    addrReg = genMakeAddressable(op1, needReg, true, false, true);

                    /* Is the target a byte/short/char value? */

                    if  (op1->gtType < TYP_INT)
                    {
                        /* Must get the new value into a byte register */

                        if  (op2->gtType >= op1->gtType)
                            op2->gtFlags |= GTF_SMALL_OK;

                        genComputeReg(op2, RBM_BYTE_REGS, true, false);
                    }
                    else
                    {
                        /* Generate the RHS into a register */

#if GC_WRITE_BARRIER_CALL
                        if  (isWriteBarrier)
                            genComputeReg(op2, needReg1, true, false);
                        else
#endif
                            genComputeReg(op2, needReg, false, false);
                    }

                    /* Make sure the target is still addressable */

                    assert(op2->gtFlags & GTF_REG_VAL);
                    addrReg = genLockAddressable(op1, genRegMask(op2->gtRegNum), addrReg);
                    assert(op2->gtFlags & GTF_REG_VAL);

#if GC_WRITE_BARRIER_CALL

                    /* Write barrier helper does the assignment */

                    regGC = WriteBarrier(op1, op2->gtRegNum, addrReg);

                    if  (regGC != 0)
                    {
                        assert(isWriteBarrier);
                        regs |= regGC;
                    }
                    else
                    {
                        /* Move the value into the target */

                        inst_TT_RV(INS_mov, op1, op2->gtRegNum);
                    }

                    /* The new value is no longer needed */

                    genReleaseReg(op2);

#else
                    /* Move the value into the target */

                    inst_TT_RV(INS_mov, op1, op2->gtRegNum);

                    /* The new value is no longer needed */

                    genReleaseReg(op2);

                    /* This could be a pointer assignment */

                    regs |= WriteBarrier(op1, op2->gtRegNum);
#endif

                    /* Update the current liveness info */

#ifndef NDEBUG
                    if (varNames) genUpdateLife(tree);
#endif

                    /* Free up anything that was tied up by the LHS */

                    genDoneAddressable(op1, addrReg);
                }

#else

#if     GC_WRITE_BARRIER_CALL
                // UNDONE: GC write barrier for RISC
#endif

                /*
                    Is the LHS more complex than the RHS? Also, if
                    target (op1) is a local variable, start with op2.
                 */

                if  ((tree->gtFlags & GTF_REVERSE_OPS) || op1->gtOper == GT_LCL_VAR)
                {
                    /* Generate the RHS into a register */

                    genComputeReg(op2, rsRegExclMask(needReg, op1->gtRsvdRegs), false, false);
                    assert(op2->gtFlags & GTF_REG_VAL);

                    /* Make the target addressable */

                    addrReg = genMakeAddressable(op1, needReg, true, false, true, true);

                    /*
                        Make sure the RHS register hasn't been spilled;
                        keep the register marked as "used", otherwise
                        we might get the pointer lifetimes wrong.
                     */

                    genRecoverReg(op2, RBM_ALL, true);
                    assert(op2->gtFlags & GTF_REG_VAL);

                    /* Lock the RHS temporarily (lock only already used) */

                    rsLockUsedReg(genRegMask(op2->gtRegNum));

                    /* Make sure the LHS is still addressable */

                    if  (genDeferAddressable(op1))
                        addrReg = genNeedAddressable(op1, addrReg, needReg);
                    else
                        addrReg = genKeepAddressable(op1, addrReg);

                    /* We can unlock the register holding the RHS */

                    rsUnlockUsedReg(genRegMask(op2->gtRegNum));

                    /* Move the value into the target */

                    inst_TT_RV(INS_mov, op1, op2->gtRegNum);

                    /* Update the current liveness info */

#ifndef NDEBUG
                    if (varNames) genUpdateLife(tree);
#endif

                    /* Free up anything that was tied up by either operand */

                    rsMarkRegFree(genRegMask(op2->gtRegNum));
                    genDoneAddressable(op1, addrReg);
                }
                else
                {
                    prefReg = ~op2->gtRsvdRegs;
                    if  (needReg &  prefReg)
                         needReg &= prefReg;

                    /* Make the target addressable */

                    addrReg = genMakeAddressable(op1, needReg, true, false, true);

                    /* Generate the RHS into a register */

                    genComputeReg(op2, needReg, false, false);

                    /* Make sure the target is still addressable */

                    assert(op2->gtFlags & GTF_REG_VAL);
                    addrReg = genLockAddressable(op1, genRegMask(op2->gtRegNum), addrReg);
                    assert(op2->gtFlags & GTF_REG_VAL);

                    /* Move the value into the target */

                    inst_TT_RV(INS_mov, op1, op2->gtRegNum);

                    /* The new value is no longer needed */

                    genReleaseReg(op2);

                    /* Update the current liveness info */

#ifndef NDEBUG
                    if (varNames) genUpdateLife(tree);
#endif

                    /* Free up anything that was tied up by the LHS */

                    genDoneAddressable(op1, addrReg);
                }

#endif

                addrReg = 0;
                break;
            }

    DONE_ASSG:

#ifdef  SET_USED_REG_SET_DURING_CODEGEN
            tree->gtUsedRegs = regs | op1->gtUsedRegs | op2->gtUsedRegs;
#endif
            genUpdateLife(tree);

#if REDUNDANT_LOAD

            if (op1->gtOper == GT_LCL_VAR)
            {
                /* Clear this local from reg table */

                rsTrashLcl(op1->gtLclVar.gtLclNum);

                /* Have we just assigned a value that is in a register? */

                if ((op2->gtFlags & GTF_REG_VAL) && tree->gtOper == GT_ASG)
                {
                    /* Constant/bitvalue has precedence over local */

                    switch (rsRegValues[op2->gtRegNum].rvdKind)
                    {
                    case RV_INT_CNS:
#if USE_SET_FOR_LOGOPS
                    case RV_BIT:
#endif
                        break;

                    default:

                        /* Mark RHS register as containing the local var */

                        rsTrackRegLclVar(op2->gtRegNum, op1->gtLclVar.gtLclNum);
                        break;
                    }
                }
            }

#endif

            assert(addrReg != 0xDEADCAFE);
            gcMarkRegSetNpt(addrReg);

            if (ovfl)
            {
                assert(oper == GT_ASG_ADD || oper == GT_ASG_SUB);

                /* If GTF_REG_VAL is not set, and it is a small type, then
                   we must have loaded it up from memory, done the increment,
                   checked for overflow, and then stored it back to memory */

                bool ovfCheckDone =  (genTypeSize(treeType) < sizeof(int)) &&
                                    !(op1->gtFlags & GTF_REG_VAL);

                if (!ovfCheckDone)
                {
                    // For small sizes, reg should be set as we sign/zero extend it.

                    assert(genIsValidReg(reg) ||
                           genTypeSize(treeType) == sizeof(int));

                    /* Currently we dont morph x=x+y into x+=y in try blocks
                     * if we need overflow check, as x+y may throw an exception.
                     * We can do it if x is not live on entry to the catch block
                     */
                    assert(!compCurBB->bbTryIndex);

                    genCheckOverflow(tree, reg);
                }
            }

            return;

#if TGT_x86

        case GT_ASG_LSH: ins = INS_shl; goto ASG_SHF;
        case GT_ASG_RSH: ins = INS_sar; goto ASG_SHF;
        case GT_ASG_RSZ: ins = INS_shr; goto ASG_SHF;

        ASG_SHF:

            assert(!varTypeIsGC(tree->TypeGet()));

            /* Shifts by a constant amount are easier */

            if  (op2->gtOper == GT_CNS_INT)
            {
                /* Make the target addressable */

                addrReg = genMakeAddressable(op1, needReg, false, false, true);

                /* Are we shifting a register left by 1 bit? */

                if  (op2->gtIntCon.gtIconVal == 1 &&
                     (op1->gtFlags & GTF_REG_VAL) && oper == GT_ASG_LSH)
                {
                    /* The target lives in a register */

                    reg  = op1->gtRegNum;
#ifdef  SET_USED_REG_SET_DURING_CODEGEN
                    regs = op1->gtUsedRegs;
#endif

                    /* "add reg, reg" is cheaper than "shl reg, 1" */

                    inst_RV_RV(INS_add, reg, reg, tree->TypeGet());
                }
                else
                {
                    /* Shift by the constant value */

                    inst_TT_SH(ins, op1, op2->gtIntCon.gtIconVal);
                }

                /* If the target is a register, it has a new value */

                if  (op1->gtFlags & GTF_REG_VAL)
                    rsTrackRegTrash(op1->gtRegNum);

                gcMarkRegSetNpt(addrReg);
            }
            else
            {
                /* Make the target addressable */

                addrReg = genMakeAddressable(op1, RBM_ALL & ~RBM_ECX, true, false, true);

                /* Load the shift count into ECX */

                genComputeReg(op2, RBM_ECX, true, false);

                /* Make sure the address is still there, and free it */

                genDoneAddressable(op1, genLockAddressable(op1, RBM_ECX, addrReg));

                /* Keep track of reg usage */

#ifdef  SET_USED_REG_SET_DURING_CODEGEN
                regs |= op1->gtUsedRegs | op2->gtUsedRegs;
#endif

                /* Perform the shift */

                inst_TT_CL(ins, op1);

                /* If the value is in a register, it's now trash */

                if  (op1->gtFlags & GTF_REG_VAL)
                    rsTrackRegTrash(op1->gtRegNum);

                /* Release the ECX operand */

                genReleaseReg(op2);
            }

            /* The zero flag is now equal to the target value */

            tree->gtFlags |= GTF_ZF_SET;

            if  (op1->gtOper == GT_LCL_VAR)
                genFlagsEqualToVar(op1->gtLclVar.gtLclNum, false);
            if  (op1->gtOper == GT_REG_VAR)
                genFlagsEqualToReg(op1->         gtRegNum, false);

            goto DONE_ASSG;

#else

        case GT_ASG_LSH:
        case GT_ASG_RSH:
        case GT_ASG_RSZ:

#ifdef  DEBUG
            gtDispTree(tree);
#endif
            assert(!"need non-x86 code");
            break;

#endif

        case GT_POST_INC:
        case GT_POST_DEC:
            {
            long        ival;

            assert(op1->gtOper == GT_LCL_VAR);
            assert(op2->gtOper == GT_CNS_INT);

            //
            // @TODO : OVERFLOW_ISSUE
            //
            // Can overflow arithmetic ever be converted to ++/--
            //

            ovfl = tree->gtOverflow();

            /* Copy the current variable value into some register */

            genCompIntoFreeReg(op1, needReg, true);
            assert(op1->gtFlags & GTF_REG_VAL);

            /* The copied value is the result */

            reg   = op1->gtRegNum;
#ifdef  SET_USED_REG_SET_DURING_CODEGEN
            regs |= op1->gtUsedRegs;
#endif

            /* Is this a register variable that dies here? */

            if  (op1->gtOper == GT_REG_VAR)
            {
                /* Is the value still in the same register? */

                if  (reg == op1->gtRegVar.gtRegNum)
                {
                    /* Variable must be dead now, don't bother updating it */

                    assert((genRegMask(reg) & rsMaskVars) == 0);
                    goto CHK_OVF;
                }
            }

            /* Update the original variable value */

            ival = op2->gtIntCon.gtIconVal;

#if TGT_x86

            if  (op1->gtOper == GT_REG_VAR)
            {
                if  (oper == GT_POST_DEC)
                    ival = -ival;

                genIncRegBy(op1, op1->gtRegVar.gtRegNum, ival);
            }
            else
            {
                /* Operate on the variable, not on its copy */

                op1->gtFlags &= ~GTF_REG_VAL;

                if  (oper == GT_POST_INC)
                {
                    if  (ival == 1)
                        inst_TT   (INS_inc, op1);
                    else
                        inst_TT_IV(INS_add, op1, ival);
                }
                else
                {
                    if  (ival == 1)
                        inst_TT   (INS_dec, op1);
                    else
                        inst_TT_IV(INS_sub, op1, ival);
                }
            }

#else

            if  (op1->gtOper == GT_REG_VAR)
            {
                if  (oper == GT_POST_DEC)
                    ival = -ival;

                genIncRegBy(op1, op1->gtRegVar.gtRegNum, ival);
            }
            else
            {
                assert(!"need non-x86 code");
            }

#endif

            /* The register has no useful value now */

            rsTrackRegTrash(reg);

            goto CHK_OVF;
            }

        case GT_ASG_OR : ins = INS_or ; goto ASG_OPR;
        case GT_ASG_XOR: ins = INS_xor; goto ASG_OPR;
        case GT_ASG_AND: ins = INS_and; goto ASG_OPR;

        case GT_ASG_SUB: ins = INS_sub; goto ASG_ARITH;
        case GT_ASG_ADD: ins = INS_add; goto ASG_ARITH;

        ASG_ARITH:

//            assert(!varTypeIsGC(tree->TypeGet()));

            ovfl = tree->gtOverflow();

            // We cant use += with overflow if the value cannot be changed
            // in case of an overflow-exception which the "+" might cause
            assert(!ovfl || (op1->gtOper == GT_LCL_VAR && !compCurBB->bbTryIndex));

            /* Do not allow overflow instructions with refs/byrefs */

            assert(!ovfl || !varTypeIsGC(tree->TypeGet()));

#if TGT_x86
            // We disallow byte-ops here as it is too much trouble
            assert(!ovfl || genTypeSize(treeType) != sizeof(char));
#endif

            /* Is the second operand a constant? */

            if  (op2->gtOper == GT_CNS_INT)
            {
                long        ival = op2->gtIntCon.gtIconVal;

                /* What is the target of the assignment? */

                switch (op1->gtOper)
                {
                case GT_REG_VAR:

                REG_VAR4:

                    reg = op1->gtRegVar.gtRegNum;

                    /* No registers are needed for addressing */

                    addrReg = 0;

                INCDEC_REG:

                    /* We're adding a constant to a register */

                    if  (oper == GT_ASG_ADD)
                        genIncRegBy(tree, reg,  ival, treeType, ovfl);
                    else
                        genIncRegBy(tree, reg, -ival, treeType, ovfl);

                    break;

                case GT_LCL_VAR:

                    /* Does the variable live in a register? */

                    if  (genMarkLclVar(op1))
                        goto REG_VAR4;

                    // Fall through ....

                default:

#if     TGT_x86

                    /* Make the target addressable */

                    addrReg = genMakeAddressable(op1, needReg, false, false, true);

                    /* For small types with overflow check, we need to
                       sign/zero extend the result, so we need it in a reg */

                    if (ovfl && genTypeSize(treeType) < sizeof(int))
                    {
                        // Load op1 into a reg

                        reg = rsPickReg();

                        inst_RV_TT(INS_mov, reg, op1);

                        // Issue the add/sub and the overflow check

                        inst_RV_IV(ins, reg, ival, treeType);
                        rsTrackRegTrash(reg);

                        genCheckOverflow(tree, reg);

                        /* Store the (sign/zero extended) result back to
                           the stack location of the variable */

                        inst_TT_RV(INS_mov, op1, reg);

                        rsMarkRegFree(genRegMask(reg));

                        break;
                    }

                    /* Add/subtract the new value into/from the target */

                    if  (op1->gtFlags & GTF_REG_VAL)
                    {
                        reg = op1->gtRegNum;
                        goto INCDEC_REG;
                    }

                    /* Special case: inc/dec */

                    switch (ival)
                    {
                    case +1:
                        if  (oper == GT_ASG_ADD)
                            inst_TT(INS_inc, op1);
                        else
                            inst_TT(INS_dec, op1);

                        op1->gtFlags |= GTF_ZF_SET;

                        /* For overflow instrs on small type, we will sign-extend the result */

                        if  (op1->gtOper == GT_LCL_VAR && (!ovfl || treeType == TYP_INT))
                            genFlagsEqualToVar(op1->gtLclVar.gtLclNum, false);

                        break;

                    case -1:
                        if  (oper == GT_ASG_ADD)
                            inst_TT(INS_dec, op1);
                        else
                            inst_TT(INS_inc, op1);

                        op1->gtFlags |= GTF_ZF_SET;

                        /* For overflow instrs on small type, we will sign-extend the result */

                        if  (op1->gtOper == GT_LCL_VAR && (!ovfl || treeType == TYP_INT))
                            genFlagsEqualToVar(op1->gtLclVar.gtLclNum, false);

                        break;

                    default:
                        inst_TT_IV(ins, op1, ival);
                        op1->gtFlags |= GTF_CC_SET;

                        /* For overflow instrs on small type, we will sign-extend the result */

                        if  (op1->gtOper == GT_LCL_VAR && (!ovfl || treeType == TYP_INT))
                            genFlagsEqualToVar(op1->gtLclVar.gtLclNum,  true);

                        break;
                    }

#else

#ifdef  DEBUG
                    gtDispTree(tree);
#endif
                    assert(!"need non-x86 code");
#endif

                    break;
                }

                gcMarkRegSetNpt(addrReg);
                goto DONE_ASSG;
            }

            // Fall through

        ASG_OPR:

            assert(!varTypeIsGC(tree->TypeGet()));

            /* Is the target a register or local variable? */

            switch (op1->gtOper)
            {
            case GT_LCL_VAR:

                /* Does the target variable live in a register? */

                if  (!genMarkLclVar(op1))
                    break;

            case GT_REG_VAR:

                /* Get hold of the target register */

                reg = op1->gtRegVar.gtRegNum;

                /* Make sure the target of the store is available */

                if  (rsMaskUsed & genRegMask(reg))
                {
                    /* CONSIDER: We should be able to avoid this situation somehow */

                    rsSpillReg(reg);
                }

                /* Make the RHS addressable */

#if TGT_x86
                addrReg = genMakeRvalueAddressable(op2, 0, true);
#else
                genComputeReg(op2, 0, false, false);
                assert(op2->gtFlags & GTF_REG_VAL);
                addrReg = genRegMask(op2->gtRegNum);
#endif

                /* Compute the new value into the target register */

                inst_RV_TT(ins, reg, op2, 0, emitTypeSize(treeType));

                /* The zero flag is now equal to the register value */

#if TGT_x86
                tree->gtFlags |= GTF_ZF_SET;
                genFlagsEqualToReg(reg, false);
#endif

                /* Remember that we trashed the target */

                rsTrackRegTrash(reg);

                /* Free up anything that was tied up by the RHS */

                genDoneAddressable(op2, addrReg);
                goto DONE_ASSG;
            }

#if TGT_x86

            /* Special case: "x ^= -1" is actually "not(x)" */

            if  (oper == GT_ASG_XOR)
            {
                if  (op2->gtOper == GT_CNS_INT &&
                     op2->gtIntCon.gtIconVal == -1)
                {
                    addrReg = genMakeAddressable(op1, 0, true, false, true);
                    inst_TT(INS_not, op1);
                    genDoneAddressable(op1, addrReg);
                    goto DONE_ASSG;
                }
            }

            /* Setup target mask for op2 (byte-regs for small operands) */

            mask = (genTypeSize(tree->gtType) < sizeof(int)) ? RBM_BYTE_REGS
                                                             : RBM_ALL;

            /* Is the value or the address to be computed first? */

            if  (tree->gtFlags & GTF_REVERSE_OPS)
            {
                /* Compute the new value into a register */

                genComputeReg(op2, mask, true, false);

                /* For small types with overflow check, we need to
                   sign/zero extend the result, so we need it in a reg */

                if  (ovfl && genTypeSize(treeType) < sizeof(int))
                {
                    reg = rsPickReg();
                    goto ASG_OPR_USING_REG;
                }

                /* Shall we "RISCify" the assignment? */

                if  (op1->gtOper == GT_LCL_VAR && riscCode
                                               && compCurBB->bbWeight > 1)
                {
                    unsigned    regFree;
                    regFree   = rsRegMaskFree();

                    if  (rsFreeNeededRegCount(regFree) != 0)
                    {
                        reg = rsPickReg(regFree);

ASG_OPR_USING_REG:
                        assert(genIsValidReg(reg));

                        /* Generate "mov tmp, [var]" */

                        inst_RV_TT(INS_mov, reg, op1);

                        /* Compute the new value */

                        inst_RV_RV(ins, reg, op2->gtRegNum, treeType, emitTypeSize(treeType));

                        if (ovfl) genCheckOverflow(tree, reg);

                        /* Move the new value back to the variable */

                        inst_TT_RV(INS_mov, op1, reg);

                        rsTrackRegLclVar(reg, op1->gtLclVar.gtLclNum);

                        /* Free up the register */

                        rsMarkRegFree(genRegMask(op2->gtRegNum));

                        addrReg = 0;
                        goto DONE_ASSG;
                    }
                }

                /* Make the target addressable */

                addrReg = genMakeAddressable(op1, 0, true, false, true);

                /* Make sure the new value is in a register */

                genRecoverReg(op2, 0, false);

                /* Add the new value into the target */

                inst_TT_RV(ins, op1, op2->gtRegNum);

                /* Free up anything that is tied up by the address */

                genDoneAddressable(op1, addrReg);
            }
            else
            {
                /* Make the target addressable */

                addrReg = genMakeAddressable(op1, 0, true, false, true);

                /* Compute the new value into a register */

                genComputeReg(op2, mask, true, false);

                /* Make sure the target is still addressable */

                addrReg = genKeepAddressable(op1, addrReg);

                /* For small types with overflow check, we need to
                   sign/zero extend the result, so we need it in a reg */

                if (ovfl && genTypeSize(treeType) < sizeof(int))
                {
                    reg = rsPickReg();

                    inst_RV_TT(INS_mov, reg, op1);

                    inst_RV_RV(ins, reg, op2->gtRegNum, treeType, emitTypeSize(treeType));
                    rsTrackRegTrash(reg);

                    genCheckOverflow(tree, reg);

                    inst_TT_RV(INS_mov, op1, reg);

                    rsMarkRegFree(genRegMask(reg));
                }
                else
                {
                    /* Add the new value into the target */

                    inst_TT_RV(ins, op1, op2->gtRegNum);
                }

                /* Free up anything that was tied up either side */

                genDoneAddressable(op1, addrReg);
                genReleaseReg (op2);
            }

            goto DONE_ASSG;


#else

#ifdef  DEBUG
            gtDispTree(tree);
#endif
            assert(!"need non-x86 code");
            break;

#endif

        case GT_CHS:

#if TGT_x86

            addrReg = genMakeAddressable(op1, 0, true, false, true);
            inst_TT(INS_neg, op1);
            genDoneAddressable(op1, addrReg);
            goto DONE_ASSG;

#else

#ifdef  DEBUG
            gtDispTree(tree);
#endif
            assert(!"need non-x86 code");
            break;

#endif

#if TGT_SH3

        case GT_AND: ins = INS_and;  isArith = false;  goto BIN_OPR;
        case GT_OR : ins = INS_or;   isArith = false;  goto BIN_OPR;
        case GT_XOR: ins = INS_xor;  isArith = false;  goto BIN_OPR;

        case GT_ADD: ins = INS_add;  goto ARITH;
        case GT_SUB: ins = INS_sub;  goto ARITH;
        case GT_MUL: ins = INS_mul;  goto ARITH;

#endif

#if TGT_x86

        case GT_AND: ins = INS_and;  isArith = false;  goto BIN_OPR;
        case GT_OR : ins = INS_or ;  isArith = false;  goto BIN_OPR;
        case GT_XOR: ins = INS_xor;  isArith = false;  goto BIN_OPR;

        case GT_ADD: ins = INS_add;  goto ARITH;
        case GT_SUB: ins = INS_sub;  goto ARITH;

        case GT_MUL: ins = INS_imul;

            /* Special case: try to use "imul r1, r2, icon" */

            if  (op2->gtOper == GT_CNS_INT && op1->gtOper != GT_CNS_INT &&
                (tree->gtFlags & GTF_MUL_64RSLT) == 0 &&
                genTypeSize(treeType) != sizeof(char)) // No encoding for say "imul al,al,imm"
            {
                /* Make the first operand addressable */

                addrReg = genMakeRvalueAddressable(op1,
                                                   prefReg & ~op2->gtRsvdRegs,
                                                   false);

                /* Grab a register for the target */

                reg   = rsPickReg(needReg, bestReg);
#ifdef  SET_USED_REG_SET_DURING_CODEGEN
                regs |= genRegMask(reg) | op1->gtUsedRegs;
#endif

                /* Compute the value into the target */

                inst_RV_TT_IV(INS_imul, reg, op1, op2->gtIntCon.gtIconVal);

                /* The register has been trashed now */

                rsTrackRegTrash(reg);

                /* The address is no longer live */

                gcMarkRegSetNpt(addrReg);

                goto CHK_OVF;
            }

            goto ARITH;

#endif

        ARITH: // We reach here for GT_ADD, GT_SUB and GT_MUL.

            ovfl = tree->gtOverflow();

            /* We record the accurate (small) types in trees only we need to
             * check for overflow. Otherwise we record genActualType()
             */

            assert(ovfl || (treeType == genActualType(treeType)));

#if     LEA_AVAILABLE

            /* Can we use an 'lea' to compute the result? */

            /* Cant use 'lea' for overflow as it doesnt set flags */

            if  (!ovfl && genMakeIndAddrMode(tree, 0, true, needReg, false, true, &regs, false))
            {
                regMaskTP       tempRegs;

                /* Is the value now computed in some register? */

                if  (tree->gtFlags & GTF_REG_VAL)
                    goto REG_VAR1;

                /* Figure out a register for the value */

                if  ((op1->gtFlags & GTF_REG_VAL) &&
                     (op2->gtFlags & GTF_REG_VAL))
                {
                    /*
                        Special case: if we're adding a register variables
                        and another local, we want to avoid the following:

                            mov     r1, [op2]
                            lea     r2, [regvar+r1]

                        It's better to generate the following instead:

                            mov     r1, [op2]
                            add     r1, [regvar]
                     */

                    reg = op1->gtRegNum;
                    if  (genRegMask(reg) & rsRegMaskFree())
                        goto GOT_REG;
                    reg = op2->gtRegNum;
                    if  (genRegMask(reg) & rsRegMaskFree())
                        goto GOT_REG;
                }

                reg   = rsPickReg(needReg, bestReg);

            GOT_REG:

                regs |= genRegMask(reg);

                /* Is the operand still an address mode? */

                if  (genMakeIndAddrMode(tree, 0, true, needReg, false, true, &tempRegs, false))
                {
                    /* Is the value now computed in some register? */

                    if  (tree->gtFlags & GTF_REG_VAL)
                        goto REG_VAR1;

                    /*
                        Avoid generating some foolish variations:

                            lea reg1, [reg1+reg2]

                            lea reg1, [reg1+icon]
                     */

                    if  ((op1->gtFlags & GTF_REG_VAL) && op1->gtRegNum == reg)
                    {
                        if  (op2->gtFlags & GTF_REG_VAL)
                        {
                            /* Simply add op2 to the register */

                            inst_RV_TT(INS_add, reg, op2, 0, emitTypeSize(treeType));

                            /* The register has been trashed */

                            rsTrackRegTrash(reg);
                        }
                        else if (op2->gtOper == GT_CNS_INT)
                        {
                            /* Simply add op2 to the register */

                            genIncRegBy(op1, reg, op2->gtIntCon.gtIconVal, treeType);

                            /* The register has been trashed */

                            rsTrackRegTrash(reg);
                        }
                        else
                            goto NON_MATCHING_REG;
                    }
                    else if  ((op2->gtFlags & GTF_REG_VAL) && op2->gtRegNum == reg)
                    {
                        if  (op1->gtFlags & GTF_REG_VAL)
                        {
                            /* Simply add op1 to the register */

                            inst_RV_TT(INS_add, reg, op1, 0, emitTypeSize(treeType));

                            /* The register has been trashed */

                            rsTrackRegTrash(reg);
                        }
                        else if (op1->gtOper == GT_CNS_INT)
                        {
                            /* Simply add op1 to the register */

                            genIncRegBy(op2, reg, op1->gtIntCon.gtIconVal, treeType);

                            /* The register has been trashed */

                            rsTrackRegTrash(reg);
                        }
                        else
                            goto NON_MATCHING_REG;
                    }
                    else
                    {
                    NON_MATCHING_REG:

                        /* Generate "lea reg, [addr-mode]" */

                        inst_RV_AT(INS_lea, (treeType == TYP_BYREF) ? EA_BYREF : EA_4BYTE, treeType, reg, tree);

                        /* The register has been trashed now */

                        rsTrackRegTrash(reg);
                    }

                    regs |= tempRegs;

                    /* The following could be an 'inner' pointer!!! */

                    if (treeType == TYP_BYREF)
                    {
                        genUpdateLife(tree);
                        gcMarkRegSetNpt(tempRegs);

                        gcMarkRegPtrVal(reg, TYP_BYREF);

                        if (op1->TypeGet() == TYP_REF ||
                            op2->TypeGet() == TYP_REF)
                        {
                            /* Generate "cmp al, [addr]" to trap null pointers. */
#if TGT_x86
                            genEmitter->emitIns_R_AR(INS_cmp, EA_1BYTE, SR_EAX,
                                                     (emitRegs)reg, 0);
#else
                            assert(!"No non-x86 support");
#endif
                        }
                    }
                    goto DONE;
                }
            }

#endif // LEA_AVAILABLE

            assert(!varTypeIsGC(treeType) || (treeType == TYP_BYREF && ins == INS_add));

            isArith = true;

        BIN_OPR:

            /* The following makes an assumption about gtSetEvalOrder(this) */

            assert((tree->gtFlags & GTF_REVERSE_OPS) == 0);

#if TGT_x86

            /* Special case: "small_val & small_mask" */

            if  (op1->gtType <  TYP_INT    &&
                 op2->gtOper == GT_CNS_INT && oper == GT_AND)
            {
                unsigned        and = op2->gtIntCon.gtIconVal;
                var_types       typ = op1->TypeGet();

                switch (typ)
                {
                case TYP_BOOL : mask = 0x000000FF; break;
                case TYP_BYTE : mask = 0x000000FF; break;
                case TYP_UBYTE : mask = 0x000000FF; break;
                case TYP_SHORT: mask = 0x0000FFFF; break;
                case TYP_CHAR : mask = 0x0000FFFF; break;
                default: assert(!"unexpected type");
                }

                if  (!(and & ~mask))
                {
                    /* Make sure the operand is addressable */

                    addrReg = genMakeAddressable(op1, needReg, true, true, true);

                    /* Pick a register for the value */

                    reg   = rsPickReg(needReg, bestReg, tree->TypeGet());
#ifdef  SET_USED_REG_SET_DURING_CODEGEN
                    regs |= genRegMask(reg) | op1->gtUsedRegs;
#endif

                    /* Make sure the operand is still addressable */

                    addrReg = genKeepAddressable(op1, addrReg);

                    /* Does the "and" mask cover some or all the bits? */

                    if  (and != mask)
                    {
                        // CONSIDER: load via byte/short register

//                      if  (genRegMask(reg) & RBM_BYTE_REGS)
//                      {
//                      }
//                      else
//                      {
//                      }

                        /* Load the value and "and" it */

                        inst_RV_ST(INS_movzx, emitTypeSize(typ), reg, op1);
                        inst_RV_IV(INS_and  , reg, and);
                    }
                    else
                    {
                        /* Simply generate "movzx reg, [addr]" */

                        inst_RV_ST(INS_movzx, emitTypeSize(typ), reg, op1);
                    }

                    /* Note the new contents of the register we used */

                    rsTrackRegTrash(reg);

                    /* Free up anything that was tied up by the operand */

                    genDoneAddressable(op1, addrReg);

                    /* Update the live set of register variables */

#ifndef NDEBUG
                    if (varNames) genUpdateLife(tree);
#endif

                    /* Now we can update the register pointer information */

                    gcMarkRegSetNpt(addrReg);
                    gcMarkRegPtrVal(reg, tree->TypeGet());
                    goto DONE_LIFE;
                }
            }

#endif//TGT_x86

            /* Compute a useful register mask */

            prefReg &= rsRegMaskFree();

            if  ((prefReg & ~op2->gtRsvdRegs) == 0)
                prefReg = RBM_ALL;
            prefReg &= ~op2->gtRsvdRegs;

            /* 8-bit operations can only be done in the byte-regs */
            if (ovfl && genTypeSize(treeType) == sizeof(char))
            {
                prefReg &= RBM_BYTE_REGS;

                if (!prefReg)
                    prefReg = RBM_BYTE_REGS;
            }

            /* Do we have to use the special "imul" encoding which has eax
             * as the implicit operand ?
             */

            multEAX = false;

            if (oper == GT_MUL)
            {
                if (tree->gtFlags & GTF_MUL_64RSLT)
                {
                    /* Only multiplying with EAX will leave the 64-bit
                     * result in EDX:EAX */

                    multEAX = true;
                }
                else if (ovfl)
                {
                    if (tree->gtFlags & GTF_UNSIGNED)
                    {
                        /* "mul reg/mem" always has EAX as default operand */

                        multEAX = true;
                    }
                    else if (genTypeSize(tree->TypeGet()) < genTypeSize(TYP_INT))
                    {
                        /* Only the "imul with EAX" encoding has the 'w' bit
                         * to specify the size of the operands */

                        multEAX = true;
                    }
                }
            }

#if     TGT_x86

            /* Generate the first operand into some register */

            if  (multEAX)
            {
                assert(oper == GT_MUL);

                genComputeReg(op1, RBM_EAX, true, false, true);

                assert(op1->gtFlags & GTF_REG_VAL);
                assert(op1->gtRegNum == REG_EAX);
            }
            else
            {
                genCompIntoFreeReg(op1, prefReg);
                assert(op1->gtFlags & GTF_REG_VAL);
            }

#ifdef  SET_USED_REG_SET_DURING_CODEGEN
            regs |= op1->gtUsedRegs;
#endif

            /* Make the second operand addressable */

            addrReg = genMakeRvalueAddressable(op2, prefReg, true);

            /* Is op1 spilled and op2 in a register? */

            if  ((op1->gtFlags & GTF_SPILLED) &&
                 (op2->gtFlags & GTF_REG_VAL) && ins != INS_sub
                                              && !multEAX)
            {
                TempDsc * temp;

                assert(ins == INS_add  ||
                       ins == INS_imul ||
                       ins == INS_and  ||
                       ins == INS_or   ||
                       ins == INS_xor);

                assert(op2->gtOper != GT_LCL_VAR);

                reg = op2->gtRegNum;
                regMaskTP   regMask = genRegMask(reg);

                /* Is the register holding op2 available? */

                if  (regMask & rsMaskVars)
                {
                    // CONSIDER: Grab another register for the operation
                }
                else
                {
                    /* Get the temp we spilled into */

                    temp = rsGetSpillTempWord(op1->gtRegNum);

                    op1->gtFlags &= ~GTF_SPILLED;

                    /* For 8bit operations, we need to make sure that op2 is
                       in a byte-addressable registers */

                    if (ovfl && genTypeSize(treeType) == sizeof(char) &&
                        !(regMask & RBM_BYTE_REGS))
                    {
                        regNumber byteReg = rsGrabReg(RBM_BYTE_REGS);

                        inst_RV_RV(INS_mov, byteReg, reg);
                        rsTrackRegTrash(byteReg);

                        /* op2 couldnt have spilled as it was not sitting in
                           RBM_BYTE_REGS, and rsGrabReg() will only spill its args */
                        assert(op2->gtFlags & GTF_REG_VAL);

                        rsUnlockReg  (regMask);
                        rsMarkRegFree(regMask);

                        reg             = byteReg;
                        regMask         = genRegMask(reg);
                        op2->gtRegNum   = reg;
                        rsMarkRegUsed(op2);
                    }

                    inst_RV_ST(ins, reg, temp, 0, tree->TypeGet());

                    rsTrackRegTrash(reg);

                    genTmpAccessCnt++;

                    /* Free the temp */

                    tmpRlsTemp(temp);

                    /* Keep track of what registers we've used */

#ifdef  SET_USED_REG_SET_DURING_CODEGEN
                    regs |= op1->gtUsedRegs | op2->gtUsedRegs;
#endif

                    /* 'add'/'sub' set all CC flags, others only ZF */

                    /* If we need to check overflow, for small types, the
                     * flags cant be used as we perform the arithmetic
                     * operation (on small registers) and then sign extend it
                     *
                     * NOTE : If we ever dont need to sign-extend the result,
                     * we can use the flags
                     */

                    if  (oper != GT_MUL && (!ovfl || treeType==TYP_INT))
                    {
                        tree->gtFlags |= isArith ? GTF_CC_SET
                                                 : GTF_ZF_SET;
                    }

                    /* The result is where the second operand is sitting */
                    // ISSUE: Why not rsMarkRegFree(genRegMask(op2->gtRegNum)) ?

                    genRecoverReg(op2, 0, false);

                    goto CHK_OVF;
                }
            }

#else//!TGT_x86

            if  (GenTree::OperIsCommutative(oper))
            {
                /* It might be better to start with the second operand */

                if  (op1->gtFlags & GTF_REG_VAL)
                {
                    reg = op1->gtRegNum;

                    if  (!(genRegMask(reg) & rsRegMaskFree()))
                    {
                        /* op1 is in a non-free register */

                        op1 = tree->gtOp.gtOp2;
                        op2 = tree->gtOp.gtOp1;
                    }
                }
            }

            /* Compute the first operand into a free register */

            genCompIntoFreeReg(op1, prefReg);
            assert(op1->gtFlags & GTF_REG_VAL);

#ifdef  SET_USED_REG_SET_DURING_CODEGEN
            regs |= op1->gtUsedRegs;
#endif

            /* Can we use an "add/sub immediate" instruction? */

            if  (op2->gtOper != GT_CNS_INT || (oper != GT_ADD &&
                                               oper != GT_SUB)
                                           || treeType != TYP_INT)
            {
                /* Compute the second operand into any register */

                genComputeReg(op2, prefReg, false, false, false);
                assert(op2->gtFlags & GTF_REG_VAL);
                addrReg = genRegMask(op2->gtRegNum);
            }

#endif//!TGT_x86

            /* Make sure the first operand is still in a register */

            genRecoverReg(op1, multEAX ? RBM_EAX : 0, true);
            assert(op1->gtFlags & GTF_REG_VAL);
            reg = op1->gtRegNum;

#if     TGT_x86
            // For 8 bit operations, we need to pick byte addressable registers

            if (ovfl && genTypeSize(treeType) == sizeof(char) &&
               !(genRegMask(reg) & RBM_BYTE_REGS))
            {
                regNumber   byteReg = rsGrabReg(RBM_BYTE_REGS);

                inst_RV_RV(INS_mov, byteReg, reg);

                rsTrackRegTrash(reg);
                rsMarkRegFree  (genRegMask(reg));

                reg = byteReg;
                op1->gtRegNum = reg;
                rsMarkRegUsed(op1);
            }
#endif

            /* Make sure the operand is still addressable */

            addrReg = genLockAddressable(op2, genRegMask(reg), addrReg);

            /* Free up the operand, if it's a regvar */

            genUpdateLife(op2);

            /* The register is about to be trashed */

            rsTrackRegTrash(reg);

            op2Released = false;

            emitAttr opSize;

            // For overflow instructions, tree->gtType is the accurate type,
            // and gives us the size for the operands.

            opSize = emitTypeSize(treeType);

            /* Compute the new value */

#if CPU_HAS_FP_SUPPORT
            if  (op2->gtOper == GT_CNS_INT && isArith && !multEAX)
#else
            if  (op2->gtOper == GT_CNS_INT && isArith && !multEAX && treeType == TYP_INT)
#endif
            {
                long        ival = op2->gtIntCon.gtIconVal;

                if      (oper == GT_ADD)
                {
                    genIncRegBy(op1, reg,  ival, treeType, ovfl);
                }
                else if (oper == GT_SUB)
                {
                    if (ovfl && (tree->gtFlags & GTF_UNSIGNED))
                    {
                        /* For unsigned overflow, we have to use INS_sub to set
                           the flags correctly */

                        genDecRegBy(tree, reg,  ival);
                    }
                    else
                    {
                        /* Else, we simply add the negative of the value */

                        genIncRegBy(op1, reg, -ival, treeType, ovfl);
                    }
                }
#if     TGT_x86
                else
                {
                    genMulRegBy(op1, reg,  ival, treeType);
                }
#else
                op2Released = true;
#endif
            }
#if     TGT_x86
            else if (multEAX)
            {
                assert(oper == GT_MUL);

                /*HACK: we need op2 in a register, but it is just addressable, */
                /*      but we know that EDX is available (it will be used by  */
                /*      the result anyway). */

                /* Make sure EDX is not used */

                if  ((op2->gtFlags & GTF_REG_VAL) && op2->gtRegNum == REG_EDX)
                {
                    /* Ensure that op2 is already dead */

                    assert((op2->gtOper != GT_REG_VAR) ||
                           (RBM_EDX & op2->gtLiveSet) == 0);
                }
                else
                {
                    if ((op2->gtFlags & GTF_REG_VAL) == 0)
                    {
                        genComputeReg(op2, RBM_EDX, true, true);
                    }
                    else
                    {
                        /* Free up anything that was tied up by the operand */

                        genDoneAddressable(op2, addrReg);
                        op2Released = true;

                        rsGrabReg(RBM_EDX);
                    }
                }

#if 0
                if  ((op2->gtFlags & GTF_REG_VAL) == 0)
                {
                    genComputeReg(op2, RBM_EDX, true, true, true);
                }
                else if (op2->gtRegNum != REG_EDX)
                {
                    /* Make sure EDX is not (yet) used */

                    rsGrabReg(RBM_EDX);
                }
                else
                {
                }
#endif

                assert(op2->gtFlags & GTF_REG_VAL);

                if (tree->gtFlags & GTF_UNSIGNED)
                    ins = INS_mulEAX;
                else
                    ins = INS_imulEAX;

                inst_TT(ins, op2, 0, 0, opSize);

                /* Both EAX and EDX are now trashed */

                rsTrackRegTrash (REG_EAX);
                rsTrackRegTrash (REG_EDX);

            }
            else
            {
                if (ovfl && genTypeSize(treeType) == sizeof(char) &&
                    (op2->gtFlags & GTF_REG_VAL))
                {
                    assert(genRegMask(reg) & RBM_BYTE_REGS);

                    regNumber   op2reg      = op2->gtRegNum;
                    regMaskTP   op2regMask  = genRegMask(op2reg);

                    if (!(op2regMask & RBM_BYTE_REGS))
                    {
                        regNumber   byteReg = rsGrabReg(RBM_BYTE_REGS);

                        inst_RV_RV(INS_mov, byteReg, op2reg);

                        genDoneAddressable(op2, addrReg);
                        op2Released = true;

                        op2->gtRegNum = byteReg;
                    }
                }
                inst_RV_TT(ins, reg, op2, 0, opSize);
            }
#else//!TGT_x86
            else
            {
                /* On RISC the two operands better be in registers now */

                assert(op2->gtFlags & GTF_REG_VAL);
                rg2 = op2->gtRegNum;

#if 0   // UNDONE: The following doesn't completely work; 'rg2' is marked as
        //         used here, plus we end with the result marked wrong, but
        //         this little optimization holds some promise ...

                /* Would it legal and better to compute the result into 'rg2' ? */

                if  (genRegTrashable(rg2, tree) && GenTree::OperIsCommutative(oper))
                {
                    /* Does 'rg2' look better than 'reg' for the result? */

                    if  ((genRegMask(reg) & needReg) == 0 &&
                         (genRegMask(rg2) & needReg) != 0)
                    {
#if     TGT_SH3
                        if  (oper != GT_MUL)
#endif
                        {
                            /* Switch 'reg' and 'rg2' */

                            rg2 = reg;
                            reg = op2->gtRegNum;
                        }
                    }
                }

#endif

                /* Compute the result into "reg" */

                genEmitter->emitIns_R_R(ins, EA_4BYTE, (emitRegs)reg,
                                                          (emitRegs)rg2);

#if     TGT_SH3

                /* On the SH-3 the result of a multiply is in the "MAC.lo" reg */

                if  (oper == GT_MUL)
                {
                    /* Is the target the right register? */

                    if  (prefReg && !(prefReg & genRegMask(reg)))
                    {
                        /* Is a better register available? */

                        if  (prefReg & rsRegMaskFree())
                        {
                            reg = rsGrabReg(prefReg); assert(reg != op1->gtRegNum);

                            /* Free op the old register */

                            rsMarkRegFree(genRegMask(op1->gtRegNum));

                            /* Switch 'op1' over to the new register */

                            op1->gtRegNum = reg; rsMarkRegUsed(op1);
                        }
                    }

                    genEmitter->emitIns_R(INS_stsmacl, EA_4BYTE, (emitRegs)reg);
                }
            }

#endif

#endif//TGT_x86

            /* Free up anything that was tied up by the operand */

            if (!op2Released)
                genDoneAddressable(op2, addrReg);

            /* Keep track of what registers we've used */

#ifdef  SET_USED_REG_SET_DURING_CODEGEN
            regs |= op1->gtUsedRegs | op2->gtUsedRegs;
#endif

#if     TGT_x86

            /* 'add'/'sub' set all CC flags, others only ZF */

            if  (oper != GT_MUL)
            {
                tree->gtFlags |= isArith ? GTF_CC_SET
                                         : GTF_ZF_SET;
            }

#endif

            /* The result will be where the first operand is sitting */

            genRecoverReg(op1, 0, false);

            reg = op1->gtRegNum;

#if     TGT_x86
            assert(multEAX == false || reg == REG_EAX);
#endif

    CHK_OVF:

            /* Do we need an overflow check */

            if (ovfl)
                genCheckOverflow(tree, reg);

            goto DONE;

        case GT_UMOD:

            /* Is this a division by an integer constant? */

            if  (op2->gtOper == GT_CNS_INT)
            {
                unsigned ival = op2->gtIntCon.gtIconVal;

                /* Is the divisor a power of 2 ? */

                if  (ival != 0 && ival == (unsigned)genFindLowestBit(ival))
                {
                    /* Generate the operand into some register */

                    genCompIntoFreeReg(op1, needReg, true);
                    assert(op1->gtFlags & GTF_REG_VAL);

                    reg   = op1->gtRegNum;
#ifdef  SET_USED_REG_SET_DURING_CODEGEN
                    regs |= op1->gtUsedRegs;
#endif

                    /* Generate the appropriate sequence */

#if TGT_x86
                    inst_RV_IV(INS_and, reg, ival - 1);
#else
                    assert(!"need non-x86 code");
#endif

                    /* The register is now trashed */

                    rsTrackRegTrash(reg);

                    goto DONE;
                }
            }

            goto DIVIDE;

        case GT_MOD:

#if TGT_x86

            /* Is this a division by an integer constant? */

            if  (op2->gtOper == GT_CNS_INT)
            {
                long        ival = op2->gtIntCon.gtIconVal;

                /* Is the divisor a power of 2 ? */

                if  (ival > 0 && (unsigned)ival == genFindLowestBit((unsigned)ival))
                {
                    BasicBlock *    skip = genCreateTempLabel();

                    /* Generate the operand into some register */

                    genCompIntoFreeReg(op1, needReg, true);
                    assert(op1->gtFlags & GTF_REG_VAL);

                    reg   = op1->gtRegNum;
#ifdef  SET_USED_REG_SET_DURING_CODEGEN
                    regs |= op1->gtUsedRegs;
#endif

                    /* Generate the appropriate sequence */

                    inst_RV_IV(INS_and, reg, (ival - 1) | 0x80000000);

                    /* The register is now trashed */

                    rsTrackRegTrash(reg);

                    /* Generate "jns skip" */

                    inst_JMP(EJ_jns, skip, false, false, true);

                    /* Generate the rest of the sequence and we're done */

                    inst_RV   (INS_dec, reg, TYP_INT);
                    inst_RV_IV(INS_or , reg, -ival);
                    inst_RV   (INS_inc, reg, TYP_INT);

                    /* Define the 'skip' label and we're done */

                    genDefineTempLabel(skip, true);

                    goto DONE;
                }
            }

#endif

            goto DIVIDE;

        case GT_UDIV:

            /* Is this a division by an integer constant? */

            if  ((op2->gtOper == GT_CNS_INT) && opts.compFastCode)
            {
                unsigned    ival = op2->gtIntCon.gtIconVal;

                /* Division by 1 must be handled elsewhere */

                assert(ival != 1);

                /* Is the divisor a power of 2 ? */

                if  (ival && (long)ival == (long)genFindLowestBit(ival))
                {
                    /* Generate the operand into some register */

                    genCompIntoFreeReg(op1, needReg, true);
                    assert(op1->gtFlags & GTF_REG_VAL);

                    reg   = op1->gtRegNum;
#ifdef  SET_USED_REG_SET_DURING_CODEGEN
                    regs |= op1->gtUsedRegs;
#endif

                    /* Generate "shr reg, log2(value)" */

#if TGT_x86
                    inst_RV_SH(INS_shr, reg, genLog2(ival)-1);
#else
                    assert(!"need non-x86 code");
#endif

                    /* The register is now trashed */

                    rsTrackRegTrash(reg);

                    goto DONE;
                }
            }

            goto DIVIDE;

        case GT_DIV:

#if TGT_x86

            /* Is this a division by an integer constant? */

            if  ((op2->gtOper == GT_CNS_INT) && opts.compFastCode)
            {
                unsigned    ival = op2->gtIntCon.gtIconVal;

                /* Division by 1 must be handled elsewhere */

                assert(ival != 1);

                /* Is the divisor a power of 2 ? */

                if  (ival && (long)ival == (long)genFindLowestBit(ival))
                {
#if 1
                    BasicBlock *    skip = genCreateTempLabel();

                    /* Generate the operand into some register */

                    genCompIntoFreeReg(op1, needReg, true);
                    assert(op1->gtFlags & GTF_REG_VAL);

                    reg   = op1->gtRegNum;
#ifdef  SET_USED_REG_SET_DURING_CODEGEN
                    regs |= op1->gtUsedRegs;
#endif

                    if (ival == 2)
                    {
                        /* Generate "sar reg, log2(value)" */

                        inst_RV_SH(INS_sar, reg, genLog2(ival)-1);

                        /* Generate "jns skip" followed by "adc reg, 0" */

                        inst_JMP  (EJ_jns, skip, false, false, true);
                        inst_RV_IV(INS_adc, reg, 0);

                        /* Define the 'skip' label and we're done */

                        genDefineTempLabel(skip, true);

                        /* The register is now trashed */

                        rsTrackRegTrash(reg);

                        /* The result is the same as the operand */

                        reg  = op1->gtRegNum;
#ifdef  SET_USED_REG_SET_DURING_CODEGEN
                        regs = op1->gtUsedRegs;
#endif
                    }
                    else
                    {
                        /* Generate the following sequence */
                        /*
                            test    reg, reg
                            jns     skip
                            add     reg, ival-1
                            skip:
                            sar     reg, log2(ival)
                         */

                        //
                        // UNSIGNED_ISSUE
                        // Handle divs
                        //

                        assert(op1->TypeGet() == TYP_INT);

                        inst_RV_RV(INS_test, reg, reg, TYP_INT);

                        inst_JMP  (EJ_jns, skip, false, false, true);
                        inst_RV_IV(INS_add, reg, ival-1);

                        /* Define the 'skip' label and we're done */

                        genDefineTempLabel(skip, true);

                        /* Generate "sar reg, log2(value)" */

                        inst_RV_SH(INS_sar, reg, genLog2(ival)-1);

                        /* The register is now trashed */

                        rsTrackRegTrash(reg);

                        /* The result is the same as the operand */

                        reg  = op1->gtRegNum;
#ifdef  SET_USED_REG_SET_DURING_CODEGEN
                        regs = op1->gtUsedRegs;
#endif

                    }

#else

                    /* Make sure EAX is not used */

                    rsGrabReg(RBM_EAX);

                    /* Compute the operand into EAX */

                    genComputeReg(op1, RBM_EAX, true, false);

                    /* Make sure EDX is not used */

                    rsGrabReg(RBM_EDX);

                    /*
                        Generate the following code:

                            cdq
                            and edx, <value-1>
                            add eax, edx
                            sar eax, <log2-1>
                     */

                    instGen(INS_cdq);

                    if  (ival == 2)
                    {
                        inst_RV_RV(INS_sub, REG_EAX, REG_EDX, tree->TypeGet());
                    }
                    else
                    {
                        inst_RV_IV(INS_and, REG_EDX, ival-1);
                        inst_RV_RV(INS_add, REG_EAX, REG_EDX, tree->TypeGet());
                    }
                    inst_RV_SH(INS_sar, REG_EAX, genLog2(ival)-1);

                    /* Free up the operand (i.e. EAX) */

                    genReleaseReg(op1);

                    /* Both EAX and EDX are now trashed */

                    rsTrackRegTrash (REG_EAX);
                    rsTrackRegTrash (REG_EDX);

                    /* The result is in EAX */

                    reg  = REG_EAX;
#ifdef  SET_USED_REG_SET_DURING_CODEGEN
                    regs = op1->gtUsedRegs|RBM_EAX|RBM_EDX;
#endif
#endif

                    goto DONE;
                }
            }

#endif

        DIVIDE: // Jump here if op2 for GT_UMOD, GT_MOD, GT_UDIV, GT_DIV
                // is not a power of 2 constant

#if TGT_x86

            /* We want to avoid using EAX or EDX for the second operand */

            goodReg = (unsigned)(~(RBM_EAX|RBM_EDX));

            /* Which operand are we supposed to evaluate first? */

            if  (tree->gtFlags & GTF_REVERSE_OPS)
            {
                /* We'll evaluate 'op2' first */

                gotOp1   = false;
                goodReg &= ~op1->gtRsvdRegs;
            }
            else
            {
                /* We'll evaluate 'op1' first */

                gotOp1 = true;

                /* Generate the dividend into EAX and hold on to it */

                genComputeReg(op1, RBM_EAX, true, false, true);
            }

            /* Compute the desired register mask for the second operand */

            if  (destReg & goodReg)
                goodReg &= destReg;

            /* Make the second operand addressable */

            /* Special case: if op2 is a local var we are done */

            if  (op2->gtOper != GT_LCL_VAR)
            {
                genComputeReg(op2, RBM_ALL & ~(RBM_EAX|RBM_EDX), false, false);

                assert(op2->gtFlags & GTF_REG_VAL);
                addrReg = genRegMask(op2->gtRegNum);
            }
            else
            {
                if ((op2->gtFlags & GTF_REG_VAL) == 0)
                    addrReg = genMakeRvalueAddressable(op2, goodReg, true);
                else
                    addrReg = 0;

            }

            /* Make sure we have the dividend in EAX */

            if  (gotOp1)
            {
                /* We've previously computed op1 into EAX */

                genRecoverReg(op1, RBM_EAX, true);
            }
            else
            {
                /* Compute op1 into EAX and hold on to it */

                genComputeReg(op1, RBM_EAX, true, false, true);
            }

            assert(op1->gtFlags & GTF_REG_VAL);
            assert(op1->gtRegNum == REG_EAX);

            /* We can now safely (we think) grab EDX */

            rsGrabReg(RBM_EDX);
            rsLockReg(RBM_EDX);

            /* Convert the integer in EAX into a un/signed long in EDX:EAX */

            if (oper == GT_UMOD || oper == GT_UDIV)
                inst_RV_RV(INS_xor, REG_EDX, REG_EDX);
            else
                instGen(INS_cdq);

            /* Make sure the divisor is still addressable */

            addrReg = genLockAddressable(op2, RBM_EAX, addrReg);

            /* Perform the division */

            if (oper == GT_UMOD || oper == GT_UDIV)
                inst_TT(INS_div,  op2);
            else
                inst_TT(INS_idiv, op2);

            /* Free up anything tied up by the divisor's address */

            genDoneAddressable(op2, addrReg);

            /* Unlock and free EDX */

            rsUnlockReg(RBM_EDX);

            /* Free up op1 (which is in EAX) as well */

            genReleaseReg(op1);

            /* Both EAX and EDX are now trashed */

            rsTrackRegTrash (REG_EAX);
            rsTrackRegTrash (REG_EDX);

            /* Figure out which register the result is in */

            reg = (oper == GT_DIV || oper == GT_UDIV)   ? REG_EAX
                                                        : REG_EDX;

            /* Don't forget to mark the first operand as using EAX and EDX */

            op1->gtRegNum    = reg;
#ifdef  SET_USED_REG_SET_DURING_CODEGEN
            op1->gtUsedRegs |= RBM_EAX|RBM_EDX|addrReg;
#endif

#ifdef  SET_USED_REG_SET_DURING_CODEGEN
            regs |= op1->gtUsedRegs | op2->gtUsedRegs;
#endif

            goto DONE;

#elif   TGT_SH3
            assert(!"div/mod should have been morphed into a helper call");
#else
#error  Unexpected target
#endif

#if     TGT_x86

        case GT_LSH: ins = INS_shl; goto SHIFT;
        case GT_RSH: ins = INS_sar; goto SHIFT;
        case GT_RSZ: ins = INS_shr; goto SHIFT;

        SHIFT:

            /* Is the shift count constant? */

            if  (op2->gtOper == GT_CNS_INT)
            {
                // UNDONE: Check to see if we could generate a LEA instead!

                /* Compute the left operand into any free register */

                genCompIntoFreeReg(op1, needReg, false);
                assert(op1->gtFlags & GTF_REG_VAL);

                reg   = op1->gtRegNum;
#ifdef  SET_USED_REG_SET_DURING_CODEGEN
                regs |= op1->gtUsedRegs;
#endif

                /* Are we shifting left by 1 bit? */

                if  (op2->gtIntCon.gtIconVal == 1 && oper == GT_LSH)
                {
                    /* "add reg, reg" is cheaper than "shl reg, 1" */

                    inst_RV_RV(INS_add, reg, reg, tree->TypeGet());
                }
                else
                {
                    /* Generate the appropriate shift instruction */

                    inst_RV_SH(ins, reg, op2->gtIntCon.gtIconVal);
                }

                /* The register is now trashed */

                genReleaseReg(op1);
                rsTrackRegTrash (reg);
            }
            else
            {
                /* Compute the left operand into anything but ECX */

                genComputeReg(op1, RBM_ALL & ~RBM_ECX, true, false, true);
                assert(op1->gtFlags & GTF_REG_VAL);

                /* Discourage 'op1' from being assigned to ECX */

                // ISSUE: The following won't do any good if the variable
                // ISSUE: dies here, since the ECX use won't appear to
                // ISSUE: overlap with its lifetime. Of course, if we
                // ISSUE: do get unlucky, we'll just spill - no biggie.

#ifdef  SET_USED_REG_SET_DURING_CODEGEN
                op1->gtUsedRegs |= RBM_ECX;
#endif

                /* Load the shift count into ECX and lock it */

                genComputeReg(op2, RBM_ECX, true, true);
                rsLockReg(RBM_ECX);

                /* Make sure the other operand wasn't displaced */

                genRecoverReg(op1, 0, false);

                /* Keep track of reg usage */

                reg   = op1->gtRegNum;
#ifdef  SET_USED_REG_SET_DURING_CODEGEN
                regs |= op1->gtUsedRegs;
#endif

                /* Perform the shift */

                inst_RV_CL(ins, reg);

                /* The register is now trashed */

                rsTrackRegTrash(reg);

                /* Unlock and free ECX */

                rsUnlockReg(RBM_ECX);
            }

            assert(op1->gtFlags & GTF_REG_VAL);
            reg = op1->gtRegNum;
            goto DONE;

#elif   TGT_SH3

        case GT_LSH:
        case GT_RSH:
        case GT_RSZ:

            /* Compute the first operand into any free register */

            genCompIntoFreeReg(op1, needReg, false);
            assert(op1->gtFlags & GTF_REG_VAL);

            reg   = op1->gtRegNum;
#ifdef  SET_USED_REG_SET_DURING_CODEGEN
            regs |= op1->gtUsedRegs;
#endif

            /* Is the shift count constant? */

            if  (op2->gtOper == GT_CNS_INT)
            {
                instruction ins01;
                instruction ins02;
                instruction ins08;
                instruction ins16;

                unsigned    scnt = op2->gtIntCon.gtIconVal;

                /* Arithmetic right shifts only work by one bit */

                if  (oper == GT_RSH)
                {
                    if  (scnt > 2)
                        goto SHF_VAR;
                }
                else
                {
                    /* If '4' is present, it must be alone */

                    if  ((scnt & 4) && scnt != 4)
                        goto SHF_VAR;

                    /* Make sure no more than 2 bits are set */

                    if  (scnt)
                    {
                        if  (!genOneBitOnly(scnt - genFindLowestBit(scnt)))
                            goto SHF_VAR;
                    }

                    /* Figure out the instructions we'll need */

                    if  (oper == GT_LSH)
                    {
                        ins01 = INS_shll;
                        ins02 = INS_shll2;
                        ins08 = INS_shll8;
                        ins16 = INS_shll16;
                    }
                    else
                    {
                        ins01 = INS_shlr;
                        ins02 = INS_shlr2;
                        ins08 = INS_shlr8;
                        ins16 = INS_shlr16;
                    }
                }

                /* Is this an arithmetic shift right? */

                if  (oper == GT_RSH)
                {
                    while (scnt)
                    {
                        /* Generate "shar reg" for each shift */

                        genEmitter->emitIns_R(INS_shar,
                                               EA_4BYTE,
                                               (emitRegs)reg);

                        scnt--;
                    }
                }
                else
                {
                    /* Generate the appropriate shift instruction(s) */

                    if  (scnt & 4)
                    {
                        assert(scnt == 4);

                        genEmitter->emitIns_R(ins02,
                                               EA_4BYTE,
                                               (emitRegs)reg);

                        /* Get another shift by 2 below */

                        scnt = 2;
                    }

                    if  (scnt & 16)
                        genEmitter->emitIns_R(ins16,
                                               EA_4BYTE,
                                               (emitRegs)reg);
                    if  (scnt &  8)
                        genEmitter->emitIns_R(ins08,
                                               EA_4BYTE,
                                               (emitRegs)reg);
                    if  (scnt &  2)
                        genEmitter->emitIns_R(ins02,
                                               EA_4BYTE,
                                               (emitRegs)reg);
                    if  (scnt &  1)
                        genEmitter->emitIns_R(ins01,
                                               EA_4BYTE,
                                               (emitRegs)reg);
                }
            }
            else
            {
                /* We don't have a constant and convenient shift count */

            SHF_VAR:

                /* Compute the second operand into any register */

                genComputeReg(op2, prefReg, false, false, false);
                assert(op2->gtFlags & GTF_REG_VAL);
                addrReg = genRegMask(op2->gtRegNum);

                /* Make sure the first operand is still in a register */

                genRecoverReg(op1, 0, true);
                assert(op1->gtFlags & GTF_REG_VAL);
                reg = op1->gtRegNum;

                /* Make sure the second operand is still addressable */

                addrReg = genLockAddressable(op2, genRegMask(reg), addrReg);

                /* Free up the second operand */

                genUpdateLife(op2);
                genReleaseReg(op2);

                /* Now do the shifting */

                switch (oper)
                {
                case GT_LSH: ins = INS_shad; break;
                case GT_RSH: ins = INS_shad; break;
                case GT_RSZ: ins = INS_shld; break;
                }

                genEmitter->emitIns_R_R(ins, EA_4BYTE, (emitRegs)reg,
                                                           (emitRegs)op2->gtRegNum);
            }

            /* The result register is now trashed */

            genReleaseReg(op1);
            rsTrackRegTrash(reg);

            goto DONE;

#else
#error  Unexpected target
#endif

        case GT_NEG:
        case GT_NOT:

#if TGT_x86

            /* Generate the operand into some register */

            genCompIntoFreeReg(op1, needReg, true);
            assert(op1->gtFlags & GTF_REG_VAL);

            reg   = op1->gtRegNum;
#ifdef  SET_USED_REG_SET_DURING_CODEGEN
            regs |= op1->gtUsedRegs;
#endif

            /* Negate/reverse the value in the register */

            inst_RV((oper == GT_NEG) ? INS_neg
                                     : INS_not, reg, tree->TypeGet());

#elif   TGT_SH3

            /* Compute the operand into any register */

            genComputeReg(op1, prefReg, false, true);
            assert(op1->gtFlags & GTF_REG_VAL);
            rg2  = op1->gtRegNum;

            /* Get hold of a free register for the result */

            reg  = rsGrabReg(prefReg);
            regs = genRegMask(reg) | genRegMask(rg2);

            /* Compute the result into the register */

            genEmitter->emitIns_R_R((oper == GT_NEG) ? INS_neg
                                                     : INS_not,
                                      EA_4BYTE,
                                      (emitRegs)reg,
                                      (emitRegs)rg2);

#else
#error  Unexpected target
#endif

            /* The register is now trashed */

            rsTrackRegTrash(reg);

            goto DONE;

        case GT_IND:

//            assert(op1->gtType == TYP_REF   ||
//                   op1->gtType == TYP_BYREF || (op1->gtFlags & GTF_NON_GC_ADDR));

            /* Make sure the operand is addressable */

            addrReg = genMakeAddressable(tree, needReg, false, true, true);

            /* Figure out the size of the value being loaded */

            size = EA_SIZE(genTypeSize(tree->gtType));

            /* Pick a register for the value */

#if     TGT_SH3
            if  (size < EA_4BYTE && genAddressMode == AM_IND_REG1_DISP)
            {
                /* Small loads with a displacement have to go via R0 */

                reg = REG_r00; rsPickReg(reg);
            }
            else
#endif
            {

                if  (needReg == RBM_ALL && bestReg == 0)
                {
                    /* Absent a better suggestion, pick a useless register */

                    bestReg = rsRegMaskFree() & rsUselessRegs();
                }

                reg = rsPickReg(needReg, bestReg, tree->TypeGet());
            }

#ifdef  SET_USED_REG_SET_DURING_CODEGEN
            regs |= genRegMask(reg) | op1->gtUsedRegs;
#endif

#if     TGT_x86

            if ( (op1->gtOper                       == GT_CNS_INT)       &&
                ((op1->gtFlags & GTF_ICON_HDL_MASK) == GTF_ICON_TLS_HDL))
            {
                assert(size == EA_4BYTE);
                genEmitter->emitIns_R_C (INS_mov,
                                         EA_4BYTE,
                                         (emitRegs)reg,
                                         FLD_GLOBAL_FS,
                                         op1->gtIntCon.gtIconVal);
            }
            else
            {
                /* Generate "mov reg, [addr]" or "movsx/movzx reg, [addr]" */

                if  (size < EA_4BYTE)
                {
                    if  ((tree->gtFlags & GTF_SMALL_OK)    &&
                         (genRegMask(reg) & RBM_BYTE_REGS) && size == EA_1BYTE)
                    {
                        /* We only need to load the actual size */

                      inst_RV_TT(INS_mov, reg, tree, 0, EA_1BYTE);
                    }
                    else
                    {
                        bool uns = varTypeIsUnsigned(tree->TypeGet());

                        /* Generate the "movsx/movzx" opcode */

                        inst_RV_ST(uns ? INS_movzx : INS_movsx, size, reg, tree);
                    }
                }
                else
                {
                    inst_RV_AT(INS_mov, size, tree->TypeGet(), reg, op1);
                }
            }

#elif   TGT_SH3

            /* Load the value into the chosen register */

            inst_RV_TT(INS_mov, reg, tree, 0, size);

            /* Do we need to zero-extend the value? */

            if  (size < EA_4BYTE && varTypeIsUnsigned(tree->TypeGet()))
            {
                assert(size == EA_1BYTE || size == EA_2BYTE);

                /* ISSUE: The following isn't the smartest thing */

                genEmitter->emitIns_R_R((size == EA_1BYTE) ? INS_extub : INS_extuw,
                                         EA_4BYTE,
                                         (emitRegs)reg,
                                         (emitRegs)reg);
            }

#else
#error  Unexpected target
#endif

            /* Note the new contents of the register we used */

            rsTrackRegTrash(reg);

            /* Update the live set of register variables */

#ifndef NDEBUG
            if (varNames) genUpdateLife(tree);
#endif

            /* Now we can update the register pointer information */

            gcMarkRegSetNpt(addrReg);
            gcMarkRegPtrVal(reg, tree->TypeGet());
            goto DONE_LIFE;

        case GT_CAST:

            /* Constant casts should have been folded earlier */

            assert(op1->gtOper != GT_CNS_INT &&
                   op1->gtOper != GT_CNS_LNG &&
                   op1->gtOper != GT_CNS_FLT &&
                   op1->gtOper != GT_CNS_DBL || tree->gtOverflow());

            var_types   dstType;
            dstType     = (var_types)op2->gtIntCon.gtIconVal;

            assert(dstType != TYP_VOID);

#if TGT_x86

            /* What type are we casting from? */

            switch (op1->gtType)
            {
            case TYP_LONG:

                /* Make the operand addressable. gtOverflow(), hold on to
                   addrReg as we will need to access the higher dword */

                addrReg = genMakeAddressable(op1, needReg, tree->gtOverflow());

                /* Load the lower half of the value into some register */

                if  (op1->gtFlags & GTF_REG_VAL)
                {
                    /* Can we simply use the low part of the value? */

                    regMaskTP loMask = genRegMask(genRegPairLo(op1->gtRegPair));

                    if  (loMask & rsRegMaskFree())
                        bestReg = loMask;
                }

                reg   = rsPickReg(needReg, bestReg);
#ifdef  SET_USED_REG_SET_DURING_CODEGEN
                regs |= genRegMask(reg) | op1->gtUsedRegs;
#endif

                /* Generate "mov reg, [addr-mode]" */

                if  (!(op1->gtFlags & GTF_REG_VAL) || reg != genRegPairLo(op1->gtRegPair))
                    inst_RV_TT(INS_mov, reg, op1);

                /* conv.ovf.i8i4, or conv.ovf.u8u4 */

                if (tree->gtOverflow())
                {
                    /* Find the block which throws the overflow exception */

                    AddCodeDsc * add = fgFindExcptnTarget(ACK_OVERFLOW, compCurBB->bbTryIndex);
                    assert(add && add->acdDstBlk);
                    BasicBlock * throwBlock = add->acdDstBlk;

                    regNumber hiReg = (op1->gtFlags & GTF_REG_VAL) ? genRegPairHi(op1->gtRegPair)
                                                                   : REG_NA;

                    switch(dstType)
                    {
                    case TYP_INT:   // conv.i8.i4
                        /*  Generate the following sequence

                                test loDWord, loDWord   // set flags
                                jl neg
                           pos: test hiDWord, hiDWord   // set flags
                                jne ovf
                                jmp done
                           neg: cmp hiDWord, 0xFFFFFFFF
                                jne ovf
                          done:

                        */

                        inst_RV_RV(INS_test, reg, reg);
                        if (tree->gtFlags & GTF_UNSIGNED)       // conv.ovf.u8.i4       (i4 > 0 and upper bits 0)
                        {
                            inst_JMP(EJ_jl, throwBlock, true, true, true);
                            goto UPPER_BITS_ZERO;
                        }

                        BasicBlock * neg;
                        BasicBlock * done;

                        neg  = genCreateTempLabel();
                        done = genCreateTempLabel();

                        // Is the loDWord positive or negative

                        inst_JMP(EJ_jl, neg, true, true, true);

                        // If loDWord is positive, hiDWord should be 0 (sign extended loDWord)

                        if (hiReg < REG_STK)
                        {
                            inst_RV_RV(INS_test, hiReg, hiReg);
                        }
                        else
                        {
                            inst_TT_IV(INS_cmp, op1, 0x00000000, EA_4BYTE);
                        }
                        inst_JMP(EJ_jne, throwBlock, true, true, true);
                        inst_JMP(EJ_jmp, done,       true, true, true);

                        // If loDWord is negative, hiDWord should be -1 (sign extended loDWord)

                        genDefineTempLabel(neg, true);

                        if (hiReg < REG_STK)
                        {
                            inst_RV_IV(INS_cmp, hiReg, 0xFFFFFFFFL);
                        }
                        else
                        {
                            inst_TT_IV(INS_cmp, op1, 0xFFFFFFFFL, EA_4BYTE);
                        }
                        inst_JMP(EJ_jne, throwBlock, true, true, true);

                        // Done

                        genDefineTempLabel(done, true);

                        break;

                    case TYP_UINT:  // conv.ovf.u8u4
UPPER_BITS_ZERO:

                        // Just check that the upper DWord is 0

                        if (hiReg < REG_STK)
                        {
                            inst_RV_RV(INS_test, hiReg, hiReg);
                        }
                        else
                        {
                            inst_TT_IV(INS_cmp, op1, 0, EA_4BYTE);
                        }

                        inst_JMP(EJ_jne, throwBlock, true, true, true);
                        break;

                    default:
                        assert(!"Unexpected dstType");
                        break;
                    }

                    genDoneAddressable(op1, addrReg);
                }

                rsTrackRegTrash(reg);
                gcMarkRegSetNpt(addrReg);
                goto DONE;


            case TYP_BOOL:
            case TYP_BYTE:
            case TYP_SHORT:
            case TYP_CHAR:
            case TYP_UBYTE:
                break;

            case TYP_UINT:
            case TYP_INT:
                break;

            case TYP_FLOAT:
            case TYP_DOUBLE:
                assert(!"this cast supposed to be done via a helper call");

            default:
                assert(!"unexpected cast type");
            }

            /* The second sub-operand yields the 'real' type */

            assert(op2);
            assert(op2->gtOper == GT_CNS_INT);

            andv        = false;

            if (tree->gtOverflow())
            {
                /* Compute op1 into a register, and free the register */

                genComputeReg(op1, 0, true, true);
                reg = op1->gtRegNum;

                /* Find the block which throws the overflow exception */

                AddCodeDsc * add = fgFindExcptnTarget(ACK_OVERFLOW, compCurBB->bbTryIndex);
                assert(add && add->acdDstBlk);
                BasicBlock * throwBlock = add->acdDstBlk;

                /* Do we need to compare the value, or just check masks */

                int typeMin, typeMax, mask;

                switch(dstType)
                {
                case TYP_BYTE:
                    mask = 0xFFFFFF80;
                    typeMin = SCHAR_MIN; typeMax = SCHAR_MAX;
                    unsv = (tree->gtFlags & GTF_UNSIGNED);
                    break;
                case TYP_SHORT:
                    mask = 0xFFFF8000;
                    typeMin = SHRT_MIN;  typeMax = SHRT_MAX;
                    unsv = (tree->gtFlags & GTF_UNSIGNED);
                    break;
                case TYP_INT:   unsv = true;    mask = 0x80000000L; assert(tree->gtFlags & GTF_UNSIGNED); break;
                case TYP_UBYTE: unsv = true;    mask = 0xFFFFFF00L; break;
                case TYP_CHAR:  unsv = true;    mask = 0xFFFF0000L; break;
                case TYP_UINT:  unsv = true;    mask = 0x80000000L; assert(!(tree->gtFlags & GTF_UNSIGNED)); break;
                default:        assert(!"Unknown type");
                }

                // If we just have to check a mask.
                // This must be conv.ovf.u4u1, conv.ovf.u4u2, conv.ovf.u4i4,
                // or conv.i4u4

                if (unsv)
                {
                    inst_RV_IV(INS_test, reg, mask);
                    inst_JMP(EJ_jne, throwBlock, true, true, true); // SHRI
                }

                // Check the value is in range.
                // This must be conv.ovf.i4i1, etc.

                else
                {
                    // Compare with the MAX

                    inst_RV_IV(INS_cmp, reg, typeMax);
                    inst_JMP(EJ_jg, throwBlock, true, true, true); // SHRI

                    // Compare with the MIN

                    inst_RV_IV(INS_cmp, reg, typeMin);
                    inst_JMP(EJ_jl, throwBlock, true, true, true); // SHRI
                }

                /* Keep track of what registers we've used */

#ifdef  SET_USED_REG_SET_DURING_CODEGEN
                regs |= op1->gtUsedRegs;
#endif
                goto DONE;
            }

            /* Make the operand addressable */

            addrReg = genMakeAddressable(op1, needReg, false, true, true);

            if  (genTypeSize(op1->gtType) < genTypeSize(dstType))
            {
                // Widening cast

                /* we need the source size */

                size = EA_SIZE(genTypeSize(op1->gtType));

                assert(size == EA_1BYTE || size == EA_2BYTE);

                unsv = true;

                if  (!varTypeIsUnsigned(op1->TypeGet()))
                {
                    /*
                        Special case: for a cast of byte to char we first
                        have to expand the byte (w/ sign extension), then
                        mask off the high bits.
                        Use 'movsx' followed by 'and'
                    */

                    ins  = INS_movsx;
                    andv = true;
                }
                else
                {
                    ins  = INS_movzx;
                }
            }
            else
            {
                // Narrowing cast, or sign-changing cast

                assert(genTypeSize(op1->gtType) >= genTypeSize(dstType));

                size = EA_SIZE(genTypeSize(dstType));

                /* Is the type of the cast unsigned? */

                if  (varTypeIsUnsigned(dstType))
                {
                    unsv = true;
                    ins  = INS_movzx;
                }
                else
                {
                    unsv = false;
                    ins  = INS_movsx;
                }
            }

            /* Keep track of what registers we've used */

#ifdef  SET_USED_REG_SET_DURING_CODEGEN
            regs |= op1->gtUsedRegs;
#endif

            /* Is the value already sitting in a register? */

            if  (op1->gtFlags & GTF_REG_VAL)
            {
                /* Is the value sitting in a byte-addressable register? */

                if  (!isByteReg(op1->gtRegNum))
                {
                    /* Is the cast to a signed value? */

                    if  (unsv)
                    {
                        /* We'll copy and then blow the high bits away */

                        andv = true;
                    }
                    else
                    {
                        /* Move the value into a byte register */

                        reg   = rsGrabReg(RBM_BYTE_REGS);
                        regs |= genRegMask(reg);

                        /* Move the value into that register */

                        rsTrackRegCopy     (reg, op1->gtRegNum);
                        inst_RV_RV(INS_mov, reg, op1->gtRegNum, op1->TypeGet());

                        /* The value has a new home now */

                        op1->gtRegNum = reg;

                        /* Now we can generate the 'movsx erx, rl" */

                        goto GEN_MOVSX;
                    }
                }
            }

            /* Pick a register for the value */

            reg   = rsPickReg(needReg, bestReg);
            regs |= genRegMask(reg);

            /* Are we supposed to be 'anding' a register? */

            if  (andv && (op1->gtFlags & GTF_REG_VAL))
            {
                assert(size == EA_1BYTE || size == EA_2BYTE);

                /* Generate "mov reg1, reg2" followed by "and" */

                inst_RV_RV(INS_mov, reg, op1->gtRegNum, op1->TypeGet());
                inst_RV_IV(INS_and, reg, (size == EA_1BYTE) ? 0xFF : 0xFFFF);
            }
            else
            {
                /* Generate "movsx/movzx reg, [addr]" */

            GEN_MOVSX:

                assert(size == EA_1BYTE || size == EA_2BYTE);

                if  ((op1->gtFlags & GTF_REG_VAL) && op1->gtRegNum == reg && unsv)
                {
                    assert(ins  == INS_movzx);
                    assert(andv == false);

                    /* Generate "and reg, xxxx" instead of "movzx reg, reg" */

                    inst_RV_IV(INS_and, reg, (size == EA_1BYTE) ? 0xFF : 0xFFFF);
                }
                else
                    inst_RV_ST(ins, size, reg, op1);

                /* Mask off high bits for widening cast */

                if  (andv && (genTypeSize(op1->gtType) < genTypeSize(dstType)))
                {
                    if (genTypeSize(dstType) < genTypeSize(TYP_INT))
                    {
                        assert(genTypeSize(dstType) == 2);

                        inst_RV_IV(INS_and, reg, 0xFFFF);
                    }
                }
            }

            rsTrackRegTrash(reg);
            gcMarkRegSetNpt(addrReg);
            goto DONE;

#else

#ifdef  DEBUG
            gtDispTree(tree);
#endif
            assert(!"need non-x86 code");
            break;

#endif

        case GT_JTRUE:

            /* Is this a test of a relational operator? */

            if  (op1->OperIsCompare())
            {
                /* Generate the conditional jump */

                genCondJump(op1);

#ifdef  SET_USED_REG_SET_DURING_CODEGEN
                tree->gtUsedRegs = regs | op1->gtUsedRegs;
#endif
                genUpdateLife(tree);
                return;
            }

#ifdef  DEBUG
            gtDispTree(tree);
#endif
            assert(!"ISSUE: can we ever have a jumpCC without a compare node?");

        case GT_SWITCH:
            genCodeForSwitch(tree);
#ifdef  SET_USED_REG_SET_DURING_CODEGEN
            tree->gtUsedRegs |= regs;
#endif
            return;

        case GT_RETFILT:
            assert(tree->gtType == TYP_VOID || op1 != 0);
            if (op1 == 0)   // endfinally
            {
                reg  = REG_NA;
                regs = 0;
            }
            else            // endfilter
            {
                genComputeReg(op1, RBM_INTRET, true, true);
                assert(op1->gtFlags & GTF_REG_VAL);
                assert(op1->gtRegNum == REG_INTRET);
                    /* The return value has now been computed */
                reg   = op1->gtRegNum;
#ifdef  SET_USED_REG_SET_DURING_CODEGEN
                regs |= op1->gtUsedRegs;
#endif
            }

            /* Return */

            instGen(INS_ret);
            goto DONE;

        case GT_RETURN:

#if INLINE_NDIRECT

            // UNDONE: this should be done AFTER we called exit mon so that
            //         we are sure that we don't have to keep 'this' alive

            if (info.compCallUnmanaged && (compCurBB == genReturnBB))
            {
                unsigned baseOffset = lvaTable[lvaScratchMemVar].lvStkOffs +
                                      info.compNDFrameOffset;

                /* either it's an "empty" statement or the return statement
                   of a synchronized method
                 */

                assert(!op1 || op1->gtType == TYP_VOID);

                LclVarDsc   *   varDsc = &lvaTable[info.compLvFrameListRoot];
                regNumbers  reg;
                regNumbers  reg2 = REG_EDI;

                if (varDsc->lvRegister)
                {
                    reg = (regNumbers)varDsc->lvRegNum;
                    if (reg == reg2)
                        reg2 = REG_ESI;
                }
                else
                {
                    /* mov esi, [tcb address]    */

                    genEmitter->emitIns_R_AR (INS_mov,
                                              EA_4BYTE,
                                              SR_ESI,
                                              SR_EBP,
                                              varDsc->lvStkOffs);
                    reg = REG_ESI;
                }



                /* mov edi, [ebp-frame.next] */

                genEmitter->emitIns_R_AR (INS_mov,
                                          EA_4BYTE,
                                          (emitRegs)reg2,
                                          SR_EBP,
                                          baseOffset + info.compEEInfo.offsetOfFrameLink);

                /* mov [esi+offsetOfThreadFrame], edi */

                genEmitter->emitIns_AR_R (INS_mov,
                                          EA_4BYTE,
                                          (emitRegs)reg2,
                                          (emitRegs)reg,
                                          info.compEEInfo.offsetOfThreadFrame);

            }

#endif

#ifdef PROFILER_SUPPORT
            if (opts.compEnterLeaveEventCB && (compCurBB == genReturnBB))
            {
#if     TGT_x86
                unsigned        saveStackLvl2 = genStackLevel;
                BOOL            bHookFunction;

                PROFILING_HANDLE profHandle, *pProfHandle;
                profHandle = eeGetProfilingHandle(info.compMethodHnd, &bHookFunction, &pProfHandle);
                assert((!profHandle) != (!pProfHandle));

                // Only hook if profiler says it's okay.
                if (bHookFunction)
                {
                    // Can we directly use the profilingHandle?

                    if (profHandle)
                        inst_IV(INS_push, (long)profHandle);
                    else
                        genEmitter->emitIns_AR_R(INS_push, EA_4BYTE_DSP_RELOC,
                                                 SR_NA, SR_NA, (int)pProfHandle);

                    genSinglePush(false);

                    genEmitHelperCall(CPX_PROFILER_LEAVE,
                                      sizeof(int),      // argSize
                                      0);               // retSize

                    /* Restore the stack level */

                    genStackLevel = saveStackLvl2;
                    genOnStackLevelChanged();
                }

#else
                assert(!"profiler support not implemented for non x86");
#endif
            }
#endif
            /* Is there a return value and/or an exit statement? */

            if  (op1)
            {
                /* Is there really a non-void return value? */

#if     TGT_x86
                if  (op1->gtType == TYP_VOID)
                {
                    TempDsc *    temp;

                    /* This must be a synchronized method */

                    assert(info.compFlags & FLG_SYNCH);

                    /* Save the return value of the method, if any */

                    switch (genActualType(info.compRetType))
                    {
                    case TYP_VOID:
                        break;

                    case TYP_REF:
                    case TYP_BYREF:
                        assert(genTypeStSz(TYP_REF)   == genTypeStSz(TYP_INT));
                        assert(genTypeStSz(TYP_BYREF) == genTypeStSz(TYP_INT));
                        inst_RV(INS_push, REG_INTRET, info.compRetType);

                        genSinglePush(true);
                        gcMarkRegSetNpt(RBM_INTRET);
                        break;

                    case TYP_INT:
                    case TYP_LONG:

                        inst_RV(INS_push, REG_INTRET, TYP_INT);
                        genSinglePush(false);

                        if (info.compRetType == TYP_LONG)
                        {
                            inst_RV(INS_push, REG_EDX, TYP_INT);
                            genSinglePush(false);
                        }
                        break;

                    case TYP_FLOAT:
                    case TYP_DOUBLE:
                        assert(genFPstkLevel == 0); genFPstkLevel++;
                        temp = genSpillFPtos(info.compRetType);
                        break;

                    default:
                        assert(!"unexpected return type");
                    }

                    /* Generate the 'monitorExit' call */

                    genCodeForTree(op1, 0);

                    /* Restore the return value of the method, if any */

                    switch (genActualType(info.compRetType))
                    {
                    case TYP_VOID:
                        break;

                    case TYP_REF:
                    case TYP_BYREF:
                        assert(genTypeStSz(TYP_REF)   == genTypeStSz(TYP_INT));
                        assert(genTypeStSz(TYP_BYREF) == genTypeStSz(TYP_INT));
                        inst_RV(INS_pop, REG_INTRET, info.compRetType);

                        genStackLevel -= sizeof(void *);
                        genOnStackLevelChanged();
                        gcMarkRegPtrVal(REG_INTRET, info.compRetType);
                        break;

                    case TYP_LONG:
                        inst_RV(INS_pop, REG_EDX, TYP_INT);
                        genSinglePop();
                        gcMarkRegSetNpt(RBM_EDX);

                        /* fall through */

                    case TYP_INT:
                        inst_RV(INS_pop, REG_INTRET, TYP_INT);
                        genStackLevel -= sizeof(void*);
                        genOnStackLevelChanged();
                        gcMarkRegSetNpt(RBM_INTRET);
                        break;

                    case TYP_FLOAT:
                    case TYP_DOUBLE:
                        genReloadFPtos(temp, INS_fld);
                        assert(genFPstkLevel == 0);
                        break;

                    default:
                        assert(!"unexpected return type");
                    }
                }
                else

#endif // TGT_x86

                {
                    assert(op1->gtType != TYP_VOID);

                    /* Generate the return value into the return register */

                    genComputeReg(op1, RBM_INTRET, true, true);

                    /* The result must now be in the return register */

                    assert(op1->gtFlags & GTF_REG_VAL);
                    assert(op1->gtRegNum == REG_INTRET);
                }

                /* The return value has now been computed */

                reg   = op1->gtRegNum;
#ifdef  SET_USED_REG_SET_DURING_CODEGEN
                regs |= op1->gtUsedRegs;
#endif

                goto DONE;
            }

#ifdef  SET_USED_REG_SET_DURING_CODEGEN
            tree->gtUsedRegs = regs;
#endif
            return;

        case GT_COMMA:

            assert((tree->gtFlags & GTF_REVERSE_OPS) == 0);

            /* Generate side effects of the first operand */

            genEvalSideEffects(op1, 0);
            genUpdateLife (op1);

            /* Is the value of the second operand used? */

            if  (tree->gtType == TYP_VOID)
            {
                /* The right operand produces no result */

                genEvalSideEffects(op2, 0);
                genUpdateLife(tree);
                return;
            }

            /* Generate the second operand, i.e. the 'real' value */

            genCodeForTree(op2, needReg); assert(op2->gtFlags & GTF_REG_VAL);

            /* The result of 'op2' is also the final result */

            reg  = op2->gtRegNum;

            /* Remember which registers we've used */

#ifdef  SET_USED_REG_SET_DURING_CODEGEN
            regs = op1->gtUsedRegs | op2->gtUsedRegs;
#endif

            /* Remember whether we set the flags */

            tree->gtFlags |= (op2->gtFlags & (GTF_CC_SET|GTF_ZF_SET));

            goto DONE;

#if OPTIMIZE_QMARK

        case GT_QMARK:

#if !TGT_x86

#ifdef  DEBUG
            gtDispTree(tree);
#endif
            assert(!"need non-x86 code");
            break;
#else

            BasicBlock *    lab_true;
            BasicBlock *    lab_false;
            BasicBlock *    lab_done;

            GenTreePtr      thenNode;
            GenTreePtr      elseNode;

            genLivenessSet  entryLiveness;
            genLivenessSet  exitLiveness;

            /*
                This is a ?: operator; generate code like this:

                    condition_compare
                    jmp_if_true lab_false

                lab_true:
                    op1 (true = 'then' part)
                    jmp lab_done

                lab_false:
                    op2 (false = 'else' part)

                lab_done:


                NOTE: If no 'else' part we do not generate the 'jmp lab_done'
                      or the 'lab_done' label
            */

            assert(op1->OperIsCompare());
            assert(op2->gtOper == GT_COLON);

            lab_true  = genCreateTempLabel();
            lab_false = genCreateTempLabel();
            lab_done  = genCreateTempLabel();

            /* Get hold of the two branches */

            thenNode = op2->gtOp.gtOp1;
            elseNode = op2->gtOp.gtOp2;

            /* If the 'then' branch is empty swap the two branches and reverse the condition */

            if (thenNode->IsNothingNode())
            {
                assert(!elseNode->IsNothingNode());

                op2->gtOp.gtOp1 = elseNode;
                op2->gtOp.gtOp2 = thenNode;
                op1->gtOper     = GenTree::ReverseRelop(op1->OperGet());
            }

            /* Spill any register that hold partial values */

            if (rsMaskUsed & rsRegMaskCanGrab())
                rsSpillRegs(rsMaskUsed & rsRegMaskCanGrab());

            /* Generate the conditional jump */

            genCondJump(op1, lab_false, lab_true);

            /* Make sure to update the current live variables
             * @MIHAII - After cond_jump is COLON that follows, not tree   */

            /* the "colon or op2" liveSet  has liveness information        */
            /* which is the union of both the then and else parts          */

            genUpdateLife(op2);

            /* Save the current liveness, register status, and GC pointers */
            /* This is the liveness information upon entry                 */
            /* to both the then and else parts of the qmark                */

            saveLiveness(&entryLiveness);

            /* Clear the liveness of any local varbles that are dead upon     */
            /* entry to the then part.                                        */

            /* Subtract the liveSet upon entry of the then part (op1->gtNext) */
            /* from the "colon or op2" liveSet                                */
            genDyingVars(op2->gtLiveSet, op1->gtNext);

            /* genCondJump() closes the current emitter block */

            genDefineTempLabel(lab_true, true);

            /* Does the operator yield a value? */

            if  (tree->gtType == TYP_VOID)
            {
                /* Generate the code for the then part of the qmark */

                genCodeForTree(thenNode, needReg, bestReg);

                /* The type is VOID, so we shouldn't have computed a value */

                assert(!(thenNode->gtFlags & GTF_REG_VAL));

                /* Save the current liveness, register status, and GC pointers               */
                /* This is the liveness information upon exit of the then part of the qmark  */

                saveLiveness(&exitLiveness);

                /* Is there an 'else' part? */

                if  (gtIsaNothingNode(elseNode))
                {
                    /* No 'else' - just generate the 'lab_false' label */

                    genDefineTempLabel(lab_false, true);
                }
                else
                {
                    /* Generate jmp lab_done */

                    inst_JMP  (EJ_jmp, lab_done, false, false, true);

                    /* Restore the liveness that we had upon entry of the then part of the qmark */

                    restoreLiveness(&entryLiveness);

                    /* Clear the liveness of any local varbles that are dead upon      */
                    /* entry to the else part.                                         */

                    /* Subtract the liveSet upon entry of the else part (op2->gtNext)  */
                    /* from the "colon or op2" liveSet                                 */
                    genDyingVars(op2->gtLiveSet, op2->gtNext);

                    /* Generate lab_false: */

                    genDefineTempLabel(lab_false, true);

                    /* Enter the else part - trash all registers */

                    rsTrackRegClr();

                    /* Generate the code for the else part of the qmark */

                    genCodeForTree(elseNode, needReg, bestReg);

                    /* The type is VOID, so we shouldn't have computed a value */

                    assert(!(elseNode->gtFlags & GTF_REG_VAL));

                    /* Verify that the exit liveness information is same for the two parts of the qmark */

                    checkLiveness(&exitLiveness);

                    /* Define the "result" label */

                    genDefineTempLabel(lab_done, true);
                }

                /* Join of the two branches - trash all registers */

                rsTrackRegClr();

                /* We're just about done */

                genUpdateLife(tree);
            }
            else
            {
                /* Generate the code for the then part of the qmark */

                assert(gtIsaNothingNode(thenNode) == false);

                genComputeReg(thenNode, needReg, false, true, true);

                assert(thenNode->gtFlags & GTF_REG_VAL);
                assert(thenNode->gtRegNum != REG_NA);

                /* Record the chosen register */

                reg  = thenNode->gtRegNum;
                regs = genRegMask(reg);

                /* Save the current liveness, register status, and GC pointers               */
                /* This is the liveness information upon exit of the then part of the qmark  */

                saveLiveness(&exitLiveness);

                /* Generate jmp lab_done */

                inst_JMP  (EJ_jmp, lab_done, false, false, true);

                /* Restore the liveness that we had upon entry of the then part of the qmark */

                restoreLiveness(&entryLiveness);

                /* Clear the liveness of any local varbles that are dead upon      */
                /* entry to the then part.                                         */

                /* Subtract the liveSet upon entry of the else part (op2->gtNext)  */
                /* from the "colon or op2" liveSet                                 */
                genDyingVars(op2->gtLiveSet, op2->gtNext);

                /* Generate lab_false: */

                genDefineTempLabel(lab_false, true);

                /* Enter the else part - trash all registers */

                rsTrackRegClr();

                /* Generate the code for the else part of the qmark */

                assert(gtIsaNothingNode(elseNode) == false);

                /* This must place a value into the chosen register */
                genComputeReg(elseNode, regs, true, true, false);

                assert(elseNode->gtFlags & GTF_REG_VAL);
                assert(elseNode->gtRegNum == reg);

                /* Verify that the exit liveness information is same for the two parts of the qmark */

                checkLiveness(&exitLiveness);

                /* Define the "result" label */

                genDefineTempLabel(lab_done, true);

                /* Join of the two branches - trash all registers */

                rsTrackRegClr();

                /* Check whether this subtree has freed up any variables */

                genUpdateLife(tree);

                tree->gtFlags   |= GTF_REG_VAL;
                tree->gtRegNum   = reg;
            }
            return;
#endif // TGT_x86


        case GT_BB_COLON:

#if !TGT_x86

#ifdef  DEBUG
            gtDispTree(tree);
#endif
            assert(!"need non-x86 code");
            break;
#else

            /* CONSIDER: Don't always load the value into EAX! */

            genComputeReg(op1, RBM_EAX, true, true);

            /* The result must now be in EAX */

            assert(op1->gtFlags & GTF_REG_VAL);
            assert(op1->gtRegNum == REG_EAX);

            /* The "_:" value has now been computed */

            reg   = op1->gtRegNum;
#ifdef  SET_USED_REG_SET_DURING_CODEGEN
            regs |= op1->gtUsedRegs;
#endif
            goto DONE;

#endif // TGT_x86
#endif // OPTIMIZE_QMARK

        case GT_LOG0:
        case GT_LOG1:

            assert(varTypeIsFloating(op1->TypeGet()) == false);

            // CONSIDER: allow to materialize comparison result

            // CONSIDER: special-case variables known to be boolean

            assert(op1->OperIsCompare() == false);

#if TGT_x86


#ifdef  DEBUG
            gtDispTree(tree);
#endif
            assert(!"need non-x86 code");
            break;

#else // TGT_x86

#if USE_SET_FOR_LOGOPS

            /*
                Generate the following sequence:

                    xor     reg, reg
                    cmp     op1, 0  (or "test reg, reg")
                    set[n]e reg
             */

            regNumber       bit;

#if !SETEONP5
            /* Sete/Setne are slow on P5. */

            if (genCPU == 5)
                goto NO_SETE1;
#endif

            /* Don't use SETE/SETNE for some kinds of operands */

            if  (op1->gtOper == GT_CALL)
                goto NO_SETE1;

            /* Prepare the operand */

            /*
                The following is rude - the idea is to try to keep
                a bit register for multiple conditionals in a row.
             */

            rsNextPickRegIndex = 0;

            // ISSUE: is the following reasonable?

            switch (op1->gtType)
            {
            default:

                /* Not an integer - only allow simple values */

                if  (op1->gtOper != GT_LCL_VAR)
                    break;

            case TYP_INT:

                /* Load the value to create scheduling opportunities */

                genCodeForTree(op1, needReg);
                break;

            case TYP_REF:
            case TYP_BYREF:

                /* Stay away from pointer values! */

                break;
            }

            addrReg = genMakeRvalueAddressable(op1, needReg, true);

            /* Don't use SETE/SETNE if no registers are free */

            if  (!rsFreeNeededRegCount(RBM_ALL))
                goto NO_SETE2;

            /* Pick a target register */

            assert(needReg);

            /* Can we reuse a register that has all upper bits cleared? */

#if REDUNDANT_LOAD
            /* Request free, byte-addressable register */
            reg = bit = rsFindRegWithBit(true, true);
#else
            reg = bit = REG_NA;
#endif

            if  (reg == REG_NA || !(genRegMask(reg) & RBM_BYTE_REGS))
            {
                /* Didn't find a suitable register with a bit in it */

                needReg &= RBM_BYTE_REGS;
                if  (!(needReg & rsRegMaskFree()))
                    needReg = RBM_BYTE_REGS;

                /* Make sure the desired mask contains a free register */

                if  (!(needReg & rsRegMaskFree()))
                    goto NO_SETE2;

                /*
                    The following is rude - the idea is to try to keep
                    a bit register for multiple conditionals in a row.
                 */

                rsNextPickRegIndex = 1;

                /* Pick the target register */

                bit = REG_NA;
                reg = rsPickReg(needReg);
            }

            assert(genRegMask(reg) & rsRegMaskFree());

            /* Temporarily lock the register */

            rsLockReg(genRegMask(reg));

            /* Remember which registers we've used */

#ifdef  SET_USED_REG_SET_DURING_CODEGEN
            regs |= genRegMask(reg) | op1->gtUsedRegs;
#endif

            /* Clear the target register */

            if  (bit == REG_NA)
                genSetRegToIcon(reg, 0);

            /* Make sure the operand is still addressable */

            addrReg = genKeepAddressable(op1, addrReg);

            /* Test the value against 0 */

            if  (op1->gtFlags & GTF_REG_VAL)
                inst_RV_RV(INS_test, op1->gtRegNum, op1->gtRegNum);
            else
                inst_TT_IV(INS_cmp, op1, 0);

            /* The operand value is no longer needed */

            genDoneAddressable(op1, addrReg);
            genUpdateLife (op1);

            /* Now set the target register based on the comparison result */

            inst_RV((oper == GT_LOG0) ? INS_sete
                                      : INS_setne, reg, TYP_INT);

            rsTrackRegOneBit(reg);

            /* Now unlock the target register */

            rsUnlockReg(genRegMask(reg));

            goto DONE;

        NO_SETE1:

#endif // USE_SET_FOR_LOGOPS

            /* Make the operand addressable */

            addrReg = genMakeRvalueAddressable(op1, needReg, true);

#if USE_SET_FOR_LOGOPS
        NO_SETE2:
#endif

            /*
                Generate the 'magic' sequence:

                    cmp op1, 1
                    sbb reg, reg
                    neg reg

                or

                    cmp op1, 1
                    sbb reg, reg
                    inc reg
             */

            inst_TT_IV(INS_cmp, op1, 1);

            /* The operand value is no longer needed */

            genDoneAddressable(op1, addrReg);
            genUpdateLife (op1);

            /* Pick a register for the value */

            reg   = rsPickReg(needReg, bestReg);
#ifdef  SET_USED_REG_SET_DURING_CODEGEN
            regs |= genRegMask(reg) | op1->gtUsedRegs;
#endif

            inst_RV_RV(INS_sbb, reg, reg, tree->TypeGet());

            inst_RV((oper == GT_LOG0) ? INS_neg
                                      : INS_inc, reg, TYP_INT);

            /* The register is now trashed */

            rsTrackRegTrash(reg);

            goto DONE;

#endif // TGT_x86


        case GT_RET:

#if TGT_x86

            /* Make the operand addressable */

            addrReg = genMakeAddressable(op1, needReg, false, true, true);

            /* Jump indirect to the operand address */

            inst_TT(INS_i_jmp, op1);

            gcMarkRegSetNpt(addrReg);

#ifdef  SET_USED_REG_SET_DURING_CODEGEN
            tree->gtUsedRegs = regs | op1->gtUsedRegs;
#endif
            return;

#else

#ifdef  DEBUG
            gtDispTree(tree);
#endif
            assert(!"need non-x86 code");
            break;

#endif

        case GT_NOP:

#if INLINING || OPT_BOOL_OPS
            if  (op1 == 0)
                return;
#endif

            /* Generate the operand into some register */

            genCodeForTree(op1, needReg);

            /* The result is the same as the operand */

            reg  = op1->gtRegNum;
#ifdef  SET_USED_REG_SET_DURING_CODEGEN
            regs = op1->gtUsedRegs;
#endif

            goto DONE;

#if INLINE_MATH

        case GT_MATH:

#if TGT_x86

            switch (tree->gtMath.gtMathFN)
            {
                BasicBlock *    skip;

            case MATH_FN_ABS:

                skip = genCreateTempLabel();

                /* Generate the operand into some register */

                genCompIntoFreeReg(op1, needReg, true);
                assert(op1->gtFlags & GTF_REG_VAL);

                reg   = op1->gtRegNum;
#ifdef  SET_USED_REG_SET_DURING_CODEGEN
                regs |= op1->gtUsedRegs;
#endif

                /* Generate "test reg, reg" */

                inst_RV_RV(INS_test, reg, reg);

                /* Generate "jns skip" followed by "neg reg" */

                inst_JMP(EJ_jns, skip, false, false, true);
                inst_RV (INS_neg, reg, TYP_INT);

                /* Define the 'skip' label and we're done */

                genDefineTempLabel(skip, true);

                /* The register is now trashed */

                rsTrackRegTrash(reg);

                /* The result is the same as the operand */

                reg  = op1->gtRegNum;
#ifdef  SET_USED_REG_SET_DURING_CODEGEN
                regs = op1->gtUsedRegs;
#endif

                break;

            default:
                assert(!"unexpected math intrinsic");

            }

            goto DONE;

#else

#ifdef  DEBUG
            gtDispTree(tree);
#endif
            assert(!"need non-x86 code");
            break;

#endif

#endif

        case GT_LCLHEAP:

#if TGT_x86

            assert(genFPused);
            assert(genStackLevel == 0); // Cant have anything on the stack

            // Compute the size of the block to (loc)alloc-ate
            reg   = info.compInitMem ? REG_ECX : rsPickReg(needReg);
            regs  = genRegMask(reg);
            genComputeReg(op1, regs, true, true);
#ifdef  SET_USED_REG_SET_DURING_CODEGEN
            regs |= op1->gtUsedRegs;
#endif

            // DWORD-align the size
            inst_RV_IV(INS_add, reg,  (sizeof(int) - 1));
            rsTrackRegTrash(reg);
            inst_RV_IV(INS_and, reg, ~(sizeof(int) - 1));

            // Adjust ESP to make space for the localloc
            if (info.compInitMem)
            {
                assert(reg==REG_ECX);

                    // --- shr ecx, 2 ---
                inst_RV_SH(INS_shr, REG_ECX, 2); // convert to # of DWORDs

                // Loop:
                    // --- push 0
                inst_IV(INS_push_hide, 0);      // _hide means don't track the stack
                    // --- loop Loop:
                inst_IV(INS_loop, -4);   // Branch backwards to Start of Loop

                    // --- move ECX, ESP
                inst_RV_RV(INS_mov, REG_ECX, REG_ESP);
            }
            else
            {
                genAllocStack(reg);
            }

            genEmitter->emitIns_AR_R(INS_mov, EA_4BYTE, SR_ESP,
                                     SR_EBP, -lvaShadowSPfirstOffs);
            goto DONE;

#else

#ifdef  DEBUG
            gtDispTree(tree);
#endif
            assert(!"need non-x86 code");
            break;

#endif // TGT_x86

        case GT_COPYBLK:

            assert(op1->OperGet() == GT_LIST);

            /* if the value class doesn't have any fields that      */
            /* are GC refs, we can merge it with CPBLK              */
            /* GC fields cannot be copied directly, instead we will */
            /* need to use a jit-helper for that                    */

            if ((op2->OperGet() == GT_CNS_INT) &&
                ((op2->gtFlags & GTF_ICON_HDL_MASK) == GTF_ICON_CLASS_HDL))
            {
                int         size;
                regNumber   reg1;
                bool *      gcPtrs;
                CLASS_HANDLE clsHnd = (CLASS_HANDLE) op2->gtIntCon.gtIconVal;

                assert(op1->gtOp.gtOp1->gtType == TYP_BYREF);
                assert(op1->gtOp.gtOp2->gtType == TYP_BYREF);

                size    = eeGetClassSize(clsHnd);
                assert(size % 4 == 0);

                unsigned slots = roundUp(size, sizeof(void*)) / sizeof(void*);
                gcPtrs  = (bool*) compGetMemA(slots * sizeof(bool));

                if (clsHnd == REFANY_CLASS_HANDLE)
                {
                    /* refany's are guaranteed to exist only on the stack. So
                       copying one refany into another doesnt need to be
                       handled specially as the byref in the refany will be
                       reported because of the refany */
                    assert(size == 2*sizeof(void*));
                    gcPtrs[0] = gcPtrs[1] = false;
                }
                else
                    eeGetClassGClayout(clsHnd, gcPtrs);
#if TGT_x86
                GenTreePtr  treeFirst, treeSecond;
                regNumber    regFirst,  regSecond;

                // Check what order the object-ptrs have to be evaluated in ?

                if (op1->gtFlags & GTF_REVERSE_OPS)
                {
                    treeFirst   = op1->gtOp.gtOp2;
                    treeSecond  = op1->gtOp.gtOp1;

                    regFirst    = REG_ESI;
                    regSecond   = REG_EDI;
                }
                else
                {
                    treeFirst   = op1->gtOp.gtOp1;
                    treeSecond  = op1->gtOp.gtOp2;

                    regFirst    = REG_EDI;
                    regSecond   = REG_ESI;
                }

                // Materialize the trees in the order desired

                genComputeReg(treeFirst,  genRegMask(regFirst),  true, false);
                genComputeReg(treeSecond, genRegMask(regSecond), true, false);

                genRecoverReg(treeFirst,  genRegMask(regFirst),  true);

                /* Grab ECX because it will be trashed by the helper        */
                /* It needs a scratch register (actually 2) and we know     */
                /* ECX is available because we expected to use rep movsd    */

                reg1 = rsGrabReg(RBM_ECX);

                assert(reg1 == REG_ECX);

                /* @TODO: use rep instruction after all GC pointers copied.   */

                while (size >= sizeof(void*))
                {
                    if (*gcPtrs++)
                    {
                        genEmitHelperCall(CPX_BYREF_ASGN,
                                         0,             // argSize
                                         sizeof(void*));// retSize
                    }
                    else
                        instGen(INS_movsd);

                    size -= sizeof(void*);
                }

                if (size > 0) {
                        // Presently the EE makes this code path impossible
                    assert(!"TEST ME");
                    inst_RV_IV(INS_mov, REG_ECX, size);
                    instGen(INS_r_movsb);
                }

                genEmitter->emitAddLabel((void**) &clsHnd,     // just a dummy
                                       gcVarPtrSetCur,
                                       gcRegGCrefSetCur & ~(RBM_EDI|RBM_ESI), //??
                                       gcRegByrefSetCur & ~(RBM_ESI|RBM_EDI));

                // "movsd" as well as CPX_BYREF_ASG modify all three registers

                rsTrackRegTrash(REG_EDI);
                rsTrackRegTrash(REG_ESI);
                rsTrackRegTrash(REG_ECX);

                genReleaseReg(treeFirst);
                genReleaseReg(treeSecond);

                reg  = REG_COUNT;
                regs = 0;

                goto DONE;
#endif
            }

            // fall through

        case GT_INITBLK:

            assert(op1->OperGet() == GT_LIST);
#if TGT_x86

            regs = (oper == GT_INITBLK) ? RBM_EAX : RBM_ESI; // reg for Val/Src

            /* Some special code for block moves/inits for constant sizes */

            /* CONSIDER:
               we should avoid using the string instructions altogether,
               there are numbers that indicate that using regular instructions
               (normal mov instructions through a register) is faster than
               even the single string instructions.
            */

            assert(op1 && op1->OperGet() == GT_LIST);
            assert(op1->gtOp.gtOp1 && op1->gtOp.gtOp2);

            if (op2->OperGet() == GT_CNS_INT &&
                ((oper == GT_COPYBLK) ||
                 (op1->gtOp.gtOp2->OperGet() == GT_CNS_INT))
                )
            {
                unsigned length = (unsigned) op2->gtIntCon.gtIconVal;
                instruction ins_D, ins_DR, ins_B;

                if (oper == GT_INITBLK)
                {
                    long val;

                    ins_D  = INS_stosd;
                    ins_DR = INS_r_stosd;
                    ins_B  = INS_stosb;

                    /* If it is a non-zero value we have to replicate     */
                    /* the byte value inside the dword. In that situation */
                    /* we simply bash the value in the tree-node          */

                    if (val = op1->gtOp.gtOp2->gtIntCon.gtIconVal)
                    {
                        op1->gtOp.gtOp2->gtIntCon.gtIconVal =
                            val | (val << 8) | (val << 16) | (val << 24);

                    }

                }
                else
                {
                    ins_D  = INS_movsd;
                    ins_DR = INS_r_movsd;
                    ins_B  = INS_movsb;
                }

                /* Evaluate dest and src/val */

                if (op1->gtFlags & GTF_REVERSE_OPS)
                {
                    genComputeReg(op1->gtOp.gtOp2, regs, true, false);
                    genComputeReg(op1->gtOp.gtOp1, RBM_EDI, true, false);
                    genRecoverReg(op1->gtOp.gtOp2, regs, true);
                }
                else
                {
                    genComputeReg(op1->gtOp.gtOp1, RBM_EDI, true, false);
                    genComputeReg(op1->gtOp.gtOp2, regs, true, false);
                    genRecoverReg(op1->gtOp.gtOp1, RBM_EDI, true);
                }

                if (length <= 16)
                {
                    while (length > 3)
                    {
                        instGen(ins_D);
                        length -= 4;
                    }
                }
                else
                {
                    /* set ECX to length/4 (in dwords) */
                    genSetRegToIcon(REG_ECX, length/4, TYP_INT);

                    length &= 0x3;

                    instGen(ins_DR);

                    rsTrackRegTrash(REG_ECX);

                }

                /* Now take care of the remainder */
                while (length--)
                {
                    instGen(ins_B);
                }

                rsTrackRegTrash(REG_EDI);

                if (oper == GT_COPYBLK)
                    rsTrackRegTrash(REG_ESI);
                // else No need to trash EAX as it wasnt destroyed by the "rep stos"

                genReleaseReg(op1->gtOp.gtOp1);
                genReleaseReg(op1->gtOp.gtOp2);

            }
            else
            {

                // What order should the Dest, Val/Src, and Size be calculated

                fgOrderBlockOps(tree,   RBM_EDI, regs, RBM_ECX,
                                        opsPtr,  regsPtr); // OUT arguments

                genComputeReg(opsPtr[0], regsPtr[0], true, false);
                genComputeReg(opsPtr[1], regsPtr[1], true, false);
                genComputeReg(opsPtr[2], regsPtr[2], true, false);

                genRecoverReg(opsPtr[0], regsPtr[0], true);
                genRecoverReg(opsPtr[1], regsPtr[1], true);

                assert( (op1->gtOp.gtOp1->gtFlags & GTF_REG_VAL) && // Dest
                        (op1->gtOp.gtOp1->gtRegNum == REG_EDI));

                assert( (op1->gtOp.gtOp2->gtFlags & GTF_REG_VAL) && // Val/Src
                        (genRegMask(op1->gtOp.gtOp2->gtRegNum) == regs));

                assert( (            op2->gtFlags & GTF_REG_VAL) && // Size
                        (            op2->gtRegNum == REG_ECX));


                // CONSIDER : Use "rep stosd" for the bulk of the operation, and
                // "rep stosb" for the remaining 3 or less bytes.
                // Will need an extra register.

                if (oper == GT_INITBLK)
                    instGen(INS_r_stosb);
                else
                    instGen(INS_r_movsb);

                rsTrackRegTrash(REG_EDI);
                rsTrackRegTrash(REG_ECX);

                if (oper == GT_COPYBLK)
                    rsTrackRegTrash(REG_ESI);
                // else No need to trash EAX as it wasnt destroyed by the "rep stos"

                genReleaseReg(opsPtr[0]);
                genReleaseReg(opsPtr[1]);
                genReleaseReg(opsPtr[2]);
            }

            reg  = REG_COUNT;
            regs = 0;

            goto DONE;

#