id
            cyNew = Math.Max(DividerLimitHigh(target), cyNew);

            // just return what we got here
            return(cyNew);
        }
       
        private static void DrawXorBar(Control ctlDrawTo, Rectangle rcFrame) {
            Rectangle rc = ctlDrawTo.RectangleToScreen(rcFrame);

            if (rc.Width < rc.Height) {
                for (int i = 0; i < rc.Width; i++) {
                    ControlPaint.DrawReversibleLine(new Point(rc.X+i, rc.Y), new Point(rc.X+i, rc.Y+rc.Height), ctlDrawTo.BackColor);
                }
            }
            else {
                for (int i = 0; i < rc.Height; i++) {
                    ControlPaint.DrawReversibleLine(new Point(rc.X, rc.Y+i), new Point(rc.X+rc.Width, rc.Y+i), ctlDrawTo.BackColor);
                }
            }
        }

        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.IComPropertyBrowser.DropDownDone"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>[To be supplied.]</para>
        /// </devdoc>
        void IComPropertyBrowser.DropDownDone() {
            GetPropertyGridView().DropDownDone();
        }
        
        private bool EnablePropPageButton(Object obj) {
            if (obj == null) {
                btnViewPropertyPages.Enabled = false;
                return false;
            }

            IUIService uiSvc = (IUIService)GetService(typeof(IUIService));
            bool enable = false;

            if (uiSvc != null) {
                enable = uiSvc.CanShowComponentEditor(obj);
            }
            else {
                enable = (TypeDescriptor.GetEditor(obj, typeof(ComponentEditor)) != null);
            }

            btnViewPropertyPages.Enabled = enable;
            return enable;
        }

        // walk through the current tabs to see if they're all valid for this Object
        private void EnableTabs() {
            if (currentObjects != null) {
                // make sure our toolbars is okay
                SetupToolbar();

                Debug.Assert(viewTabs != null, "Invalid tab array");
                Debug.Assert(viewTabs.Length == viewTabScopes.Length && viewTabScopes.Length == viewTabButtons.Length,"Uh oh, tab arrays aren't all the same length! tabs=" + viewTabs.Length.ToString() + ", scopes=" + viewTabScopes.Length.ToString() + ", buttons=" + viewTabButtons.Length.ToString());



                // skip the property tab since it's always valid
                for (int i = 1; i < viewTabs.Length; i++) {
                    Debug.Assert(viewTabs[i] != null, "Invalid tab array entry");

                    bool canExtend = true;
                    // make sure the tab is valid for all objects
                    for (int j = 0; j < currentObjects.Length; j++) {
                        try {
                            if (!viewTabs[i].CanExtend(GetUnwrappedObject(j))) {
                                canExtend = false;
                                break;
                            }
                        }
                        catch (Exception e) {
                            Debug.Fail("Bad Tab.  Disable for now.", e.ToString());
                            canExtend = false;
                            break;
                        }
                    }

                    if (canExtend != viewTabButtons[i].Visible) {
                        viewTabButtons[i].Visible = canExtend;
                        if (!canExtend && i == selectedViewTab) {
                            SelectViewTabButton(viewTabButtons[PROPERTIES], true);
                        }
                    }
                }
            }
        }

        private void EnsureLargeButtons() {
            if (this.imageList[LARGE_BUTTONS] == null) {
                this.imageList[LARGE_BUTTONS] = new ImageList();
                this.imageList[LARGE_BUTTONS].ImageSize = new Size(32,32);
                
                ImageList.ImageCollection images = imageList[NORMAL_BUTTONS].Images;

                for (int i = 0; i < images.Count; i++) {
                    if (images[i] is Bitmap) {
                        this.imageList[LARGE_BUTTONS].Images.Add(new Bitmap((Bitmap)images[i], 32,32));
                    }
                }
            }
        }
        
        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.IComPropertyBrowser.EnsurePendingChangesCommitted"]/*' />
        /// <internalonly/>
        bool IComPropertyBrowser.EnsurePendingChangesCommitted() {

            // The commits sometimes cause transactions to open
            // and close, which will cause refreshes, which we want to ignore.
            // See ASURT 71390.
            //
            try {

                if (this.designerHost != null) {
                    designerHost.TransactionOpened -= new EventHandler(this.OnTransactionOpened);
                    designerHost.TransactionClosed -= new DesignerTransactionCloseEventHandler(this.OnTransactionClosed);
                }
            
                return GetPropertyGridView().EnsurePendingChangesCommitted();
            }
            finally {
                if (this.designerHost != null) {
                    designerHost.TransactionOpened += new EventHandler(this.OnTransactionOpened);
                    designerHost.TransactionClosed += new DesignerTransactionCloseEventHandler(this.OnTransactionClosed);
                }
            }
        }
        
        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.ExpandAllGridItems"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void ExpandAllGridItems() {
            gridView.RecursivelyExpand(peMain, false, true, PropertyGridView.MaxRecurseExpand);
        }

        private static Type[] GetCommonTabs(Object[] objs, PropertyTabScope tabScope) {

            if (objs == null || objs.Length == 0) {
                return new Type[0];
            }

            Type[] tabTypes = new Type[5];
            int    types = 0;
            int    i,j,k;
            PropertyTabAttribute tabAttr = (PropertyTabAttribute) TypeDescriptor.GetAttributes(objs[0])[typeof(PropertyTabAttribute)];

            if (tabAttr == null) {
                return new Type[0];
            }

            // filter out all the types of the current scope
            for (i = 0; i < tabAttr.TabScopes.Length; i++) {
                PropertyTabScope item =  tabAttr.TabScopes[i];

                if (item == tabScope) {
                    if (types == tabTypes.Length) {
                        Type[] newTabs = new Type[types * 2];
                        Array.Copy(tabTypes, 0, newTabs, 0, types);
                        tabTypes = newTabs;
                    }
                    tabTypes[types++] = tabAttr.TabClasses[i];
                }
            }

            if (types == 0) {
                return new Type[0];
            }

            bool found;

            for (i = 1; i < objs.Length && types > 0; i++) {

                // get the tab attribute
                tabAttr = (PropertyTabAttribute) TypeDescriptor.GetAttributes(objs[i])[typeof(PropertyTabAttribute)];

                if (tabAttr == null) {
                    // if this guy has no tabs at all, we can fail right now
                    return new Type[0];
                }

                // make sure this guy has all the items in the array,
                // if not, remove the items he doesn't have
                for (j = 0; j < types; j++) {
                    found = false;
                    for (k = 0; k < tabAttr.TabClasses.Length; k++) {
                        if (tabAttr.TabClasses[k] == tabTypes[j]) {
                            found = true;
                            break;
                        }
                    }

                    // if we didn't find an item, remove it from the list
                    if (!found) {
                        // swap in with the last item and decrement
                        tabTypes[j] = tabTypes[types-1];
                        tabTypes[types-1] = null;
                        types--;

                        // recheck this item since we'll be ending sooner
                        j--;
                    }
                }
            }

            Type[] returnTypes = new Type[types];
            if (types > 0) {
                Array.Copy(tabTypes, 0, returnTypes, 0, types);
            }
            return returnTypes;
        }

        internal GridEntry GetDefaultGridEntry() {
            if (peDefault == null && currentPropEntries != null) {
                peDefault = (GridEntry)currentPropEntries[0];
            }
            return peDefault;
        }

        private object GetUnwrappedObject(int index) {
            if (currentObjects == null || index < 0 || index > currentObjects.Length) {
                return null;
            }

            Object obj = currentObjects[index];
            if (obj is ICustomTypeDescriptor) {
                obj = ((ICustomTypeDescriptor)obj).GetPropertyOwner(null);
            }
            return obj;
        }

        internal GridEntryCollection GetPropEntries() {

            if (currentPropEntries == null) {
                UpdateSelection();
            }
            SetFlag(PropertiesChanged, false);
            return currentPropEntries;
        }


        private PropertyGridView GetPropertyGridView() {
            return gridView;
        }
        
        private int GetSelectState() {
            // views == 2 (Alpha || Categories
            // viewTabs = viewTabs.length

            // state -> tab = state / views
            // state -> view = state % views

            // For each view tab, we have two view types (alpha or category), so the total number
            // of view states is the tabs X the view types.

            // Example:
            // Tab#     View    State
            // ----------------------
            // 0        A (0)   0
            // 0        C (1)   1
            // 1        A       2
            // 1        C       3
            // 2        A       4
            // 3        C       5
            // ...      ...     ...
            // n        view   (2*n)+view

            // current state is as below
            return(selectedViewTab * viewSortButtons.Length) + selectedViewSort;
        }

        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.IComPropertyBrowser.HandleF4"]/*' />
        /// <internalonly/>
        void IComPropertyBrowser.HandleF4() {
            
            if (gridView.ContainsFocus) {
                return;
            }
        
            if (this.ActiveControl != gridView) {
                this.SetActiveControlInternal(gridView);
            }
            gridView.FocusInternal();
        }

        internal bool HavePropEntriesChanged() {
            return GetFlag(PropertiesChanged);
        }


        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.IComPropertyBrowser.LoadState"]/*' />
        /// <internalonly/>
        void IComPropertyBrowser.LoadState(RegistryKey optRoot) {
            if (optRoot != null) {
                Object val = optRoot.GetValue("PbrsAlpha", "0");

                if (val != null && val.ToString().Equals("1")) {
                    this.PropertySort = PropertySort.Alphabetical;
                }
                else {
                    this.PropertySort = PropertySort.Categorized | PropertySort.Alphabetical;
                }

                val = optRoot.GetValue("PbrsShowDesc", "1");
                this.HelpVisible = (val != null && val.ToString().Equals("1"));

                val = optRoot.GetValue("PbrsDescHeightRatio", "-1");

                bool update = false;
                if (val is string) {
                    int ratio = Int32.Parse((string)val);
                    if (ratio > 0) {
                        dcSizeRatio = ratio;
                        update = true;
                    }
                }

                val = optRoot.GetValue("PbrsHotCommandHeightRatio", "-1");
                if (val is string) {
                    int ratio = Int32.Parse((string)val);
                    if (ratio > 0) {
                        dcSizeRatio = ratio;
                        update = true;
                    }
                }

                if (update) {
                    OnLayoutInternal(false);
                }


            }
        }

        // when the active document is changed, check all the components so see if they
        // are offering up any new tabs
        private void OnActiveDesignerChanged(Object sender, ActiveDesignerEventArgs e) {

            if (e.OldDesigner != null && e.OldDesigner == designerHost) {
                this.ActiveDesigner = null;
            }

            if (e.NewDesigner != null && e.NewDesigner != designerHost) {
                this.ActiveDesigner = e.NewDesigner;
            }
        }

        /// <devdoc>
        /// Called when a property on an Ole32 Object changes.
        /// See IPropertyNotifySink::OnChanged
        /// </devdoc>
        void UnsafeNativeMethods.IPropertyNotifySink.OnChanged(int dispID) {
            // we don't want the grid's own property sets doing this, but if we're getting
            // an OnChanged that isn't the DispID of the property we're currently changing,
            // we need to cause a refresh.
            //
            //
            bool fullRefresh = false;
            PropertyDescriptorGridEntry selectedEntry = gridView.SelectedGridEntry as PropertyDescriptorGridEntry;
            if (selectedEntry != null && selectedEntry.PropertyDescriptor != null && selectedEntry.PropertyDescriptor.Attributes != null) {

                // fish out the DispIdAttribute which will tell us the DispId of the
                // property that we're changing.
                //
                DispIdAttribute dispIdAttr = (DispIdAttribute)selectedEntry.PropertyDescriptor.Attributes[(typeof(DispIdAttribute))];
                if (dispIdAttr != null && !dispIdAttr.IsDefaultAttribute()) {
                    fullRefresh = (dispID != dispIdAttr.Value);
                }
            }

            if (!gridView.GetInPropertySet() || fullRefresh) {
                Refresh(fullRefresh);
            }

            // this is so changes to names of native
            // objects will be reflected in the combo box
            Object obj = GetUnwrappedObject(0);
            if (ComNativeDescriptor.Instance.IsNameDispId(obj, dispID) || dispID == NativeMethods.ActiveX.DISPID_Name) {
                OnComComponentNameChanged(new ComponentRenameEventArgs(obj, null, TypeDescriptor.GetClassName(obj)));
            }
        }

        /// <devdoc>
        /// We forward messages from several of our children
        /// to our mouse move so we can put up the spliter over their borders
        /// </devdoc>
        private void OnChildMouseMove(Object sender, MouseEventArgs me) {
            Point newPt = Point.Empty;
            if (ShouldForwardChildMouseMessage((Control)sender, me, ref newPt)) {
                // forward the message
                this.OnMouseMove(new MouseEventArgs(me.Button, me.Clicks, newPt.X, newPt.Y, me.Delta));
                return;
            }
        }

        /// <devdoc>
        /// We forward messages from several of our children
        /// to our mouse move so we can put up the spliter over their borders
        /// </devdoc>
        private void OnChildMouseDown(Object sender, MouseEventArgs me) {
            Point newPt = Point.Empty;

            if (ShouldForwardChildMouseMessage((Control)sender, me, ref newPt)) {
                // forward the message
                this.OnMouseDown(new MouseEventArgs(me.Button, me.Clicks, newPt.X, newPt.Y, me.Delta));
                return;
            }
        }
        
        private void OnComponentAdd(Object sender, ComponentEventArgs e) {

            PropertyTabAttribute attribute = (PropertyTabAttribute) TypeDescriptor.GetAttributes(e.Component.GetType())[typeof(PropertyTabAttribute)];

            if (attribute == null) {
                return;
            }

            // add all the document items
            for (int i=0; i < attribute.TabClasses.Length; i++) {
                if (attribute.TabScopes[i] == PropertyTabScope.Document) {
                    AddRefTab(attribute.TabClasses[i], e.Component, PropertyTabScope.Document, true);
                }
            }
        }

        private void OnComponentChanged(Object sender, ComponentChangedEventArgs e) {
            bool batchMode = GetFlag(BatchMode);
            if (batchMode || GetFlag(InternalChange) || gridView.GetInPropertySet() ||
               (currentObjects == null) || (currentObjects.Length == 0)) {
    
                if (batchMode && !gridView.GetInPropertySet()) {
                    SetFlag(BatchModeChange, true);
                }
                return;
            }

            int objectCount = currentObjects.Length;
            for (int i = 0; i < objectCount; i++) {
                if (currentObjects[i] == e.Component) {
                    Refresh(false);
                    break;
                }
            }
        }

        private void OnComponentRemove(Object sender, ComponentEventArgs e) {

            PropertyTabAttribute attribute = (PropertyTabAttribute) TypeDescriptor.GetAttributes(e.Component.GetType())[typeof(PropertyTabAttribute)];

            if (attribute == null) {
                return;
            }

            // remove all the document items
            for (int i=0; i < attribute.TabClasses.Length; i++) {
                if (attribute.TabScopes[i] == PropertyTabScope.Document) {
                    ReleaseTab(attribute.TabClasses[i], e.Component);
                }
            }
            
            for (int i = 0; i < currentObjects.Length; i++) {
                if (e.Component == currentObjects[i]) {
                    
                        object[] newObjects = new object[currentObjects.Length - 1];
                        Array.Copy(currentObjects, 0, newObjects, 0, i);
                        if (i < newObjects.Length) {
                            Array.Copy(currentObjects, 0, newObjects, i + i, newObjects.Length - i);
                        }

                    if (!GetFlag(BatchMode)) {
                        this.SelectedObjects = newObjects;
                    }
                    else {
                        // otherwise, just dump the selection
                        //
                        gridView.ClearProps();
                        this.currentObjects = newObjects;
                        SetFlag(FullRefreshAfterBatch, true);
                    }
                }
            }

            SetupToolbar();
            
        }

        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.OnFontChanged"]/*' />
        protected override void OnFontChanged(EventArgs e) {
           Refresh();
           base.OnFontChanged(e);
        }

        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.OnHandleCreated"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnHandleCreated(EventArgs e) {
            base.OnHandleCreated(e);
            OnLayoutInternal(false);
            TypeDescriptor.Refreshed += new RefreshEventHandler(this.OnTypeDescriptorRefreshed);
            if (currentObjects != null && currentObjects.Length > 0) {
                Refresh(true);
            }
        }

        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.OnHandleDestroyed"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnHandleDestroyed(EventArgs e) {
            TypeDescriptor.Refreshed -= new RefreshEventHandler(this.OnTypeDescriptorRefreshed);
            base.OnHandleDestroyed(e);
        }

        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.OnGotFocus"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnGotFocus(EventArgs e) {
        
            base.OnGotFocus(e);
            
            if (this.ActiveControl == null) {
                this.SetActiveControlInternal(gridView);
            }
            else {
                // sometimes the edit is still the active control
                // when it's hidden or disabled...
                if (!this.ActiveControl.FocusInternal()) {
                    this.SetActiveControlInternal(gridView);
                }
            }
        }

        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.ScaleCore"]/*' />
        protected override void ScaleCore(float dx, float dy) {
            float xAdjust;
            float yAdjust;
            if (Left < 0) {
                xAdjust = -0.5f;
            }
            else {
                xAdjust = 0.5f;
            }
            if (Top < 0) {
                yAdjust = -0.5f;
            }
            else {
                yAdjust = 0.5f;
            }
            int sx = (int)(Left * dx + xAdjust);
            int sy = (int)(Top * dy + yAdjust);
            int sw = Width;
            sw = (int)((Left + Width) * dx + 0.5f) - sx;
            int sh = Height;
            sh = (int)((Top + Height) * dy + 0.5f) - sy;
            SetBounds(sx, sy, sw, sh, BoundsSpecified.All);
        }



        private void OnLayoutInternal(bool dividerOnly) {
        
            if (!IsHandleCreated || !this.Visible) {
                return;
            }

            try {

                this.FreezePainting = true;

                if (!dividerOnly) {
                    // no toolbar or doc comment or commands, just
                    // fill the whole thing with the grid
                    if (!toolbar.Visible && !doccomment.Visible && !hotcommands.Visible) {
                        gridView.Location = new Point(0,0);
                        gridView.Size = Size;
                        return;
                    }

                    if (toolbar.Visible) {
                        toolbar.Location = new Point(0,1);
                        toolbar.Size = this.Size;
                        int oldY = gridView.Location.Y;
                        gridView.Location = new Point(0, toolbar.Height + toolbar.Top);
                        /*if (oldY < gridView.Location.Y) {
                            // since the toolbar doesn't erase it's
                            // background, we'll have to force it to happen here.
                            Brush b = new SolidBrush(BackColor);
                            Graphics g = toolbar.CreateGraphicsInternal();
                            g.FillRectangle(b, toolbar.ClientRectangle);
                            b.Dispose();
                            g.Dispose();
                            toolbar.Invalidate();
                        }*/
                    }
                    else {
                        gridView.Location = new Point(0, 0);
                    }
                }

                // now work up from the bottom
                int endSize = Size.Height;

                if (endSize < MIN_GRID_HEIGHT) {
                    return;
                }

                int maxSpace = endSize - (gridView.Location.Y + MIN_GRID_HEIGHT);
                int height;

                // if we're just moving the divider, set the requested heights
                int dcRequestedHeight = 0;
                int hcRequestedHeight = 0;
                int dcOptHeight = 0;
                int hcOptHeight = 0;

                if (dividerOnly) {
                    dcRequestedHeight = doccomment.Visible ? doccomment.Size.Height : 0;
                    hcRequestedHeight = hotcommands.Visible ? hotcommands.Size.Height : 0;
                }
                else {
                    if (doccomment.Visible) {
                        dcOptHeight = doccomment.GetOptimalHeight(Size.Width - CYDIVIDER);
                        if (doccomment.userSized) {
                            dcRequestedHeight = doccomment.Size.Height;
                        }
                        else if (dcSizeRatio != -1) {
                            dcRequestedHeight = (this.Height * dcSizeRatio) / 100;
                        }
                        else {
                            dcRequestedHeight = dcOptHeight;
                        }
                    }

                    if (hotcommands.Visible) {
                        hcOptHeight = hotcommands.GetOptimalHeight(Size.Width - CYDIVIDER);
                        if (hotcommands.userSized) {
                            hcRequestedHeight = hotcommands.Size.Height;
                        }
                        else if (hcSizeRatio != -1) {
                            hcRequestedHeight = (this.Height * hcSizeRatio) / 100;
                        }
                        else {
                            hcRequestedHeight = hcOptHeight;
                        }
                    }
                }

                // place the help comment window
                if (dcRequestedHeight > 0) {

                    maxSpace -= CYDIVIDER;

                    if (hcRequestedHeight == 0 || (dcRequestedHeight + hcRequestedHeight) < maxSpace) {
                        // full size
                        height = Math.Min(dcRequestedHeight, maxSpace);
                    }
                    else if (hcRequestedHeight > 0 && hcRequestedHeight < maxSpace) {
                        // give most of the space to the hot commands
                        height = maxSpace - hcRequestedHeight;
                    }
                    else {
                        // split the difference
                        height = Math.Min(dcRequestedHeight, maxSpace / 2 - 1);
                    }

                    height = Math.Max(height, CYDIVIDER * 2);

                    doccomment.SetBounds(0, endSize - height, Size.Width, height);

                    // if we've modified the height to less than the optimal, clear the userSized item
                    if (height <= dcOptHeight && height < dcRequestedHeight) {
                        doccomment.userSized = false;
                    }
                    else if (dcSizeRatio != -1 || doccomment.userSized) {
                        dcSizeRatio = (doccomment.Height * 100) / this.Height;
                    }

                    doccomment.Invalidate();
                    endSize = doccomment.Location.Y - CYDIVIDER;
                    maxSpace -= height;
                }

                // place the hot commands
                if (hcRequestedHeight > 0) {
                    maxSpace -= CYDIVIDER;


                    if (maxSpace > hcRequestedHeight) {
                        // full size
                        height = Math.Min(hcRequestedHeight, maxSpace);
                    }
                    else {
                        // what's left
                        height = maxSpace;
                    }

                    height = Math.Max(height, CYDIVIDER * 2);

                    // if we've modified the height, clear the userSized item
                    if (height <= hcOptHeight && height < hcRequestedHeight) {
                        hotcommands.userSized = false;
                    }
                    else if (hcSizeRatio != -1 || hotcommands.userSized) {
                        hcSizeRatio = (hotcommands.Height * 100) / this.Height;
                    }

                    hotcommands.SetBounds(0, endSize - height, Size.Width, height);
                    hotcommands.Invalidate();
                    endSize = hotcommands.Location.Y - CYDIVIDER;
                }

                gridView.Size = new Size(Size.Width, endSize - gridView.Location.Y);
            }
            finally {
                this.FreezePainting = false;
            }
        }
        
        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.OnMouseDown"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnMouseDown(MouseEventArgs me) {
            SnappableControl target = DividerInside(me.X,me.Y);
            if (target != null && me.Button == MouseButtons.Left) {
                // capture mouse.
                CaptureInternal = true;
                targetMove = target;
                dividerMoveY = me.Y;
                DividerDraw(dividerMoveY);
            }
            base.OnMouseDown(me);
        }
        
        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.OnMouseMove"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnMouseMove(MouseEventArgs me) {

            if (dividerMoveY == -1) {
                if (DividerInside(me.X,me.Y) != null) {
                    Cursor = Cursors.HSplit;
                }
                else {
                    Cursor = null;
                }
                return;
            }

            int yNew = DividerLimitMove(targetMove, me.Y);

            if (yNew != dividerMoveY) {
                DividerDraw(dividerMoveY);
                dividerMoveY = yNew;
                DividerDraw(dividerMoveY);
            }
            base.OnMouseMove(me);
        }

        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.OnMouseUp"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnMouseUp(MouseEventArgs me) {
            if (dividerMoveY == -1)
                return;

            Cursor = null;

            DividerDraw(dividerMoveY);
            dividerMoveY = DividerLimitMove(targetMove, me.Y);
            Rectangle rectDoc = targetMove.Bounds;
            if (dividerMoveY != rectDoc.Y) {
                int yNew = rectDoc.Height + rectDoc.Y - dividerMoveY - (CYDIVIDER / 2); // we subtract two so the mouse is still over the divider
                Size size = targetMove.Size;
                size.Height = Math.Max(0,yNew);
                targetMove.Size = size;
                targetMove.userSized = true;
                OnLayoutInternal(true);
                // invalidate the divider area so we cleanup anything
                // left by the xor
                Invalidate(new Rectangle(0, me.Y - CYDIVIDER, Size.Width, me.Y + CYDIVIDER));

                // in case we're doing the top one, we might have wrecked stuff
                // on the grid
                gridView.Invalidate(new Rectangle(0, gridView.Size.Height - CYDIVIDER, Size.Width, CYDIVIDER));
            }

            // end the move
            CaptureInternal = false;
            dividerMoveY = -1;
            targetMove = null;
            base.OnMouseUp(me);
        }

        /// <devdoc>
        /// Called when a property on an Ole32 Object that is tagged
        /// with "requestedit" is about to be edited.
        /// See IPropertyNotifySink::OnRequestEdit
        /// </devdoc>
        int UnsafeNativeMethods.IPropertyNotifySink.OnRequestEdit(int dispID) {
            // we don't do anything here...
            return NativeMethods.S_OK;
        }

        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.OnResize"]/*' />
        protected override void OnResize(EventArgs e) {
            if (IsHandleCreated && this.Visible) {
                OnLayoutInternal(false);
            }
            base.OnResize(e);
        }



        private void OnButtonClick(Object sender, ToolBarButtonClickEventArgs tbcevent) {
            ((EventHandler)tbcevent.Button.Tag).Invoke(tbcevent.Button, EventArgs.Empty);

            // we don't want to steal focus from the property pages...
            if (tbcevent.Button != btnViewPropertyPages) {
                gridView.FocusInternal();
            }
        }

        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.OnComComponentNameChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected void OnComComponentNameChanged(ComponentRenameEventArgs e) {
            ComponentRenameEventHandler handler = (ComponentRenameEventHandler)Events[EventComComponentNameChanged];
            if (handler != null) handler(this,e);
        }
        
        
        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.OnNotifyPropertyValueUIItemsChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected void OnNotifyPropertyValueUIItemsChanged(object sender, EventArgs e) {
            gridView.LabelPaintMargin = 0;
            gridView.Invalidate(true);
        }
  
        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.OnPaint"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnPaint(PaintEventArgs pevent) {
            
            // just erase the stuff above and below the properties window
            // so we don't flicker.
            Point psheetLoc = gridView.Location;
            int width = Size.Width;
            
            Brush background;
            if (BackColor.IsSystemColor) {
                background = SystemBrushes.FromSystemColor(BackColor);
            }
            else {
                background = new SolidBrush(BackColor);
            }
            pevent.Graphics.FillRectangle(background, new Rectangle(0,0,width, psheetLoc.Y));

            int yLast = psheetLoc.Y + gridView.Size.Height;

            // fill above hotcommands
            if (hotcommands.Visible) {
                pevent.Graphics.FillRectangle(background, new Rectangle(0, yLast, width, hotcommands.Location.Y - yLast));
                yLast += hotcommands.Size.Height;
            }

            // fill above doccomment
            if (doccomment.Visible) {
                pevent.Graphics.FillRectangle(background, new Rectangle(0, yLast, width, doccomment.Location.Y - yLast));
                yLast += doccomment.Size.Height;
            }

            // anything that might be left
            pevent.Graphics.FillRectangle(background, new Rectangle(0, yLast, width, Size.Height - yLast));
            
            if (!BackColor.IsSystemColor) {
                background.Dispose();
            }
            base.OnPaint(pevent);

            if (lineBrush != null) {
                lineBrush.Dispose();
                lineBrush = null;
            }
        }

        private void OnTransactionClosed(object sender, DesignerTransactionCloseEventArgs e) {
            SetFlag(BatchMode, false);
            if (GetFlag(FullRefreshAfterBatch)) {
                this.SelectedObjects = currentObjects;
                SetFlag(FullRefreshAfterBatch, false);
            }
            else if (GetFlag(BatchModeChange)){
                Refresh(false);
            }
            SetFlag(BatchModeChange, false);
        }
        
        private void OnTransactionOpened(object sender, EventArgs e) {
            SetFlag(BatchMode, true);
        }


        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.OnVisibleChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnVisibleChanged(EventArgs e) {
            base.OnVisibleChanged(e);
            if (Visible && IsHandleCreated) {
                OnLayoutInternal(false);
                SetupToolbar();
            }
        }

        internal void OnPropertyValueSet(GridItem changedItem, object oldValue) {
            OnPropertyValueChanged(new PropertyValueChangedEventArgs(changedItem, oldValue));
        }

        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.OnPropertyValueChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OnPropertyValueChanged(PropertyValueChangedEventArgs e) {
            PropertyValueChangedEventHandler handler = (PropertyValueChangedEventHandler)Events[EventPropertyValueChanged];
            if (handler != null) handler(this,e);
        }
        
        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.OnPropertyTabChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OnPropertyTabChanged (PropertyTabChangedEventArgs e) {
            PropertyTabChangedEventHandler handler = (PropertyTabChangedEventHandler)Events[EventPropertyTabChanged];
            if (handler != null) handler(this,e);
        }
        
        internal void OnSelectedGridItemChanged(GridEntry oldEntry, GridEntry newEntry) {
            OnSelectedGridItemChanged(new SelectedGridItemChangedEventArgs(oldEntry, newEntry));
        }
        
        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.OnSelectedGridItemChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OnSelectedGridItemChanged(SelectedGridItemChangedEventArgs e) {
            SelectedGridItemChangedEventHandler handler = (SelectedGridItemChangedEventHandler)Events[EventSelectedGridItemChanged];
            
            if (handler != null) {
                handler(this, e);
            }
        }
        
        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.OnSelectedObjectsChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OnSelectedObjectsChanged(EventArgs e) {
            EventHandler handler = (EventHandler)Events[EventSelectedObjectsChanged];
            if (handler != null) {
                handler(this, e);
            }
        }
        
        private void OnTypeDescriptorRefreshed(RefreshEventArgs e) {
            if (currentObjects != null) {
                for (int i = 0; i < currentObjects.Length; i++) {  
                    Type typeChanged = e.TypeChanged;
                    if (currentObjects[i] == e.ComponentChanged || typeChanged != null && typeChanged.IsAssignableFrom(currentObjects[i].GetType())) {
                        // clear our property hashes
                        ClearCachedProps();
                        Refresh(true);
                        return;
                    }
                }
            }
        }
        
        private void OnViewSortButtonClick(Object sender, EventArgs e) {
            try {
            
               this.FreezePainting = true;
        
               // is this tab selected? If so, do nothing.
               if (sender == viewSortButtons[selectedViewSort]) {
                   viewSortButtons[selectedViewSort].Pushed = true;
                   return;
               }
   
               // check new button and uncheck old button.
               viewSortButtons[selectedViewSort].Pushed = false;
   
               // find the new button in the list
               int index = 0;
               for (index = 0; index < viewSortButtons.Length; index++) {
                   if (viewSortButtons[index] == sender) {
                       break;
                   }
               }
               
               selectedViewSort = index;
               viewSortButtons[selectedViewSort].Pushed = true;
               
               switch (selectedViewSort) {
                  case ALPHA:
                     propertySortValue = PropertySort.Alphabetical;
                     break;
                  case CATEGORIES:
                     propertySortValue = PropertySort.Alphabetical | PropertySort.Categorized;
                     break;
                  case NO_SORT:
                     propertySortValue = PropertySort.NoSort;
                     break;
               }
               
               Refresh(false);
               OnLayoutInternal(false);
            }
            finally {
               this.FreezePainting = false;
            }
        }

        private void OnViewTabButtonClick(Object sender, EventArgs e) {
            try {
            
               this.FreezePainting = true;
               SelectViewTabButton((ToolBarButton)sender, true);
               OnLayoutInternal(false);
               SaveTabSelection();
            }
            finally {
               this.FreezePainting = false;
            }
        }

        private void OnViewButtonClickPP(Object sender, EventArgs e) {

            if (btnViewPropertyPages.Enabled &&
                currentObjects != null &&
                currentObjects.Length > 0) {
                Object baseObject = currentObjects[0];
                Object obj = baseObject;

                bool success = false;

                IUIService uiSvc = (IUIService)GetService(typeof(IUIService));

                try {
                    if (uiSvc != null) {
                        success = uiSvc.ShowComponentEditor(obj, this);
                    }
                    else {
                        try {
                            ComponentEditor editor = (ComponentEditor)TypeDescriptor.GetEditor(obj, typeof(ComponentEditor));
                            if (editor != null) {
                                if (editor is WindowsFormsComponentEditor) {
                                    success = ((WindowsFormsComponentEditor)editor).EditComponent(null, obj, (IWin32Window)this);
                                }
                                else {
                                    success = editor.EditComponent(obj);
                                }
                            }
                        }
                        catch (Exception) {
                        }
                    }

                    if (success) {

                        if (baseObject is IComponent &&
                            connectionPointCookies[0] == null) {

                            ISite site = ((IComponent)baseObject).Site;
                            if (site != null) {
                                IComponentChangeService changeService = (IComponentChangeService)site.GetService(typeof(IComponentChangeService));

                                if (changeService != null) {
                                    try {
                                        changeService.OnComponentChanging(baseObject, null);
                                    }
                                    catch (CheckoutException coEx) {
                                        if (coEx == CheckoutException.Canceled) {
                                            return;
                                        }
                                        throw coEx;
                                    }

                                    try {
                                        // Now notify the change service that the change was successful.
                                        //
                                        SetFlag(InternalChange, true);
                                        changeService.OnComponentChanged(baseObject, null, null, null);
                                    }
                                    finally {
                                        SetFlag(InternalChange, false);
                                    }

                                }
                            }
                        }
                        gridView.Refresh();

                    }
                }
                catch (Exception ex1) {
                    String errString = SR.GetString(SR.ErrorPropertyPageFailed);
                    if (uiSvc != null) {
                        uiSvc.ShowError(ex1, errString);
                    }
                    else {
                        MessageBox.Show(errString, "PropertyGrid");
                    }
                }
            }
        }
        

        /*
            
        /// <summary>
        /// Returns the first child control that can take focus
        /// </summary>
        /// <retval>
        /// Returns null if no control is able to take focus
        /// </retval>
        private Control FirstFocusableChild {
            get {
                if (toolbar.Visible) {
                    return toolbar;
                }
                else if (peMain != null) {
                    return gridView;
                }
                else if (hotcommands.Visible) {
                    return hotcommands;
                }
                else if (doccomment.Visible) {
                    return doccomment;
                }
                return null;
            }
        }

        
        private Control LastFocusableChild {
            get {
                if (doccomment.Visible) {
                    return doccomment;
                }
                else if (hotcommands.Visible) {
                    return hotcommands;
                }
                else if (peMain != null) {
                    return gridView;
                }
                else if (toolbar.Visible) {
                    return toolbar;
                }
                return null;
            }
        }


        protected override bool ProcessDialogKey(Keys keyData) {
            switch (keyData & Keys.KeyCode) {
                case Keys.Tab:
                    // are we going forward?
                    if ((keyData & Keys.Shift) != 0) {
                        // this is backward
                        if (!this.ContainsFocus) {
                            Control lastFocusable = this.LastFocusableChild;
                            
                            if (lastFocusable != null) {
                                lastFocusable.Focus();
                                return true;
                            }
                        }
                    }
                    else {
                    
                        // this is going forward
                        
                        if (!this.ContainsFocus) {
                            Control firstFocusable = this.FirstFocusableChild;
                                
                            if (firstFocusable != null) {
                                firstFocusable.Focus();
                                return true;
                            }
                        }
                     }
                     // properties window is already selected
                     // pass on to parent
                     bool result = base.ProcessDialogKey(keyData);

                     // if we're not hosted in a windows forms thing, just give the parent the focus
                     if (!result && this.Parent == null) {
                         int hWndParent = Windows.GetParent(this.Handle);
                         if (hWndParent != 0) {
                             Windows.SetFocus(hWndParent);
                         }
                     }
                     return result;

         }
        }
        */

        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.ProcessDialogKey"]/*' />
        /// <devdoc>
        /// Returns the last child control that can take focus
        /// </devdoc>
        protected override bool ProcessDialogKey(Keys keyData) {
            switch (keyData & Keys.KeyCode) {
                case Keys.Tab:
                     if (((keyData & Keys.Control) != 0) || 
                         ((keyData & Keys.Alt) != 0)) {
                        break;
                     }
                  
                    // are we going forward?
                    if ((keyData & Keys.Shift) != 0) {
                        // this is backward
                        if (hotcommands.Visible && hotcommands.ContainsFocus) {
                            gridView.ReverseFocus();
                        }
                        else if (gridView.FocusInside) {
                            if (toolbar.Visible) {
                                toolbar.FocusInternal();
                            }
                            else {
                                return base.ProcessDialogKey(keyData);
                            }
                        }
                        else {
                            // if we get here and the toolbar has focus,
                            // it means we're processing normally, so
                            // pass the focus to the parent
                            if (toolbar.Focused || !toolbar.Visible) {
                                return base.ProcessDialogKey(keyData);
                            }
                            else {
                                // otherwise, we're processing a message from elsewhere,
                                // wo we select our bottom guy.
                                if (hotcommands.Visible) {
                                    hotcommands.Select(false);
                                }
                                else if (peMain != null) {
                                    gridView.ReverseFocus();
                                }
                                else if (toolbar.Visible) {
                                    toolbar.FocusInternal();
                                }
                                else {
                                    return base.ProcessDialogKey(keyData);
                                }
                            }
                        }
                        return true;
                    }
                    else {

                        bool passToParent = false;

                        // this is forward
                        if (toolbar.Focused) {
                            // normal stuff, just do the propsheet
                            if (peMain != null) {
                                gridView.FocusInternal();
                            }
                            else {
                                base.ProcessDialogKey(keyData);
                            }
                            return true;
                        }
                        else if (gridView.FocusInside) {
                            if (hotcommands.Visible) {
                                hotcommands.Select(true);
                                return true;
                            }
                            else {
                                passToParent = true;
                            }

                        }
                        else if (hotcommands.ContainsFocus) {
                            passToParent = true;
                        }
                        else {
                            // coming from out side, start with the toolbar
                            if (toolbar.Visible) {
                                toolbar.FocusInternal();
                            }
                            else {
                                gridView.FocusInternal();
                            }
                        }

                        // nobody's claimed the focus, pass it on...
                        if (passToParent) {
                            // properties window is already selected
                            // pass on to parent
                            bool result = base.ProcessDialogKey(keyData);

                            // if we're not hosted in a windows forms thing, just give the parent the focus
                            if (!result && this.Parent == null) {
                                IntPtr hWndParent = UnsafeNativeMethods.GetParent(new HandleRef(this, Handle));
                                if (hWndParent != IntPtr.Zero) {
                                    UnsafeNativeMethods.SetFocus(new HandleRef(null, hWndParent));
                                }
                            }
                            return result;
                        }
                    }
                    return true;
                /* This conflicts with VS tab linking (ASURT # 31433)
                case Keys.Prior: // PAGE_UP
                    if ((keyData & Keys.Control) != 0) {
                        SelectPriorView();
                        return true;
                    }
                    break;
                case Keys.Next: //PAGE_DOWN
                    if ((keyData & Keys.Control) != 0) {
                        SelectNextView();
                        return true;
                    }
                    break;
                */

            }
            return base.ProcessDialogKey(keyData);
        }

        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.Refresh"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void Refresh() {
            Refresh(true);
            base.Refresh();
        }
        
        
        private void Refresh(bool clearCached) {

            if (Disposing) {
                return;
            }
        
            try {
               this.FreezePainting = true;
               
               if (clearCached) {
                  ClearCachedProps();
               }
               RefreshProperties(clearCached);
               gridView.Refresh();
               DisplayHotCommands();
           }
           finally {
               this.FreezePainting = false;
           }
        }

        internal void RefreshProperties(bool clearCached) {
            
            // Clear our current cache so we can do a full refresh.
            if (clearCached && selectedViewTab != -1 && viewTabs != null) {
               PropertyTab tab = viewTabs[selectedViewTab]; 
               if (tab != null && viewTabProps != null) {
                   string tabName = tab.TabName + propertySortValue.ToString();
                   viewTabProps.Remove(tabName);
               }
            }
         
            SetFlag(PropertiesChanged, true);
            UpdateSelection();
        }


        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.RefreshTabs"]/*' />
        /// <devdoc>
        /// Refreshes the tabs of the given scope by deleting them and requerying objects and documents
        /// for them.
        /// </devdoc>
        public void RefreshTabs(PropertyTabScope tabScope) {
            
            if (tabScope < PropertyTabScope.Document) {
                throw new ArgumentException(SR.GetString(SR.PropertyGridTabScope));
            }

            RemoveTabs(tabScope, false);

            // check the component level tabs
            if (tabScope <= PropertyTabScope.Component) {
                if (currentObjects != null && currentObjects.Length > 0) {
                    // get the subset of PropertyTabs that's common to all objects
                    Type[] tabTypes = GetCommonTabs(currentObjects, PropertyTabScope.Component);

                    for (int i = 0; i < tabTypes.Length; i++) {
                        for (int j = 0; j < currentObjects.Length; j++) {
                            AddRefTab(tabTypes[i], currentObjects[j], PropertyTabScope.Component, false);
                        }
                    }
                }
            }

            // check the document level tabs
            if (tabScope <= PropertyTabScope.Document && designerHost != null) {
                IContainer container = designerHost.Container;
                if (container != null) {
                    ComponentCollection components = container.Components;
                    if (components != null) {
                        foreach (IComponent comp in components) {
                            PropertyTabAttribute attribute = (PropertyTabAttribute) TypeDescriptor.GetAttributes(comp.GetType())[typeof(PropertyTabAttribute)];

                            if (attribute != null) {
                                for (int j = 0; j < attribute.TabClasses.Length; j++) {
                                    if (attribute.TabScopes[j] == PropertyTabScope.Document) {
                                        AddRefTab(attribute.TabClasses[j], comp, PropertyTabScope.Document, false);
                                    }
                                }
                            }
                        }
                    }
                }
            }

            SetupToolbar();
        }

        internal void ReleaseTab(Type tabType, Object component) {
            PropertyTab tab = null;
            int tabIndex = -1;
            for (int i = 0; i < viewTabs.Length; i++) {
                if (tabType == viewTabs[i].GetType()) {
                    tab = viewTabs[i];
                    tabIndex = i;
                    break;
                }
            }

            if (tab == null) {
                //Debug.Fail("How can we release a tab when it isn't here.");
                return;
            }

            Object[] components = tab.Components;
            bool killTab = false;

            try {
                int index = -1;
                if (components != null)
                    index = Array.IndexOf(components, component);

                if (index >= 0) {
                    object[] newComponents = new object[components.Length - 1];
                    Array.Copy(components, 0, newComponents, 0, index);
                    Array.Copy(components, index + 1, newComponents, index, components.Length - index - 1);
                    components = newComponents;
                    tab.Components = components;
                }
                killTab = (components.Length == 0);
            }
            catch (Exception e) {
                Debug.Fail("Bad Tab.  It's going away.", e.ToString());
                killTab = true;
            }

            // we don't remove PropertyTabScope.Global tabs here.  Our owner has to do that.
            if (killTab && viewTabScopes[tabIndex] > PropertyTabScope.Global) {
                RemoveTab(tabIndex, false);
            }
        }

        private void RemoveImage(int index) {
            imageList[NORMAL_BUTTONS].Images.RemoveAt(index);
            if (imageList[LARGE_BUTTONS] != null) {
                imageList[LARGE_BUTTONS].Images.RemoveAt(index);
            }
        }

        // removes all the tabs with a classification greater than or equal to the specified classification.
        // for example, removing PropertyTabScope.Document will remove PropertyTabScope.Document and PropertyTabScope.Component tabs
        internal void RemoveTabs(PropertyTabScope classification, bool setupToolbar) {
            if (classification == PropertyTabScope.Static) {
                throw new ArgumentException(SR.GetString(SR.PropertyGridRemoveStaticTabs));
            }
            
            // in case we've been disposed
            if (viewTabButtons == null || viewTabs == null || viewTabScopes == null) {
                return;
            }

            ToolBarButton selectedButton = (selectedViewTab >=0 && selectedViewTab < viewTabButtons.Length ? viewTabButtons[selectedViewTab] : null);

            for (int i = viewTabs.Length-1; i >= 0; i--) {
                if (viewTabScopes[i] >= classification) {

                    // adjust the selected view tab because we're deleting.
                    if (selectedViewTab == i) {
                        selectedViewTab = -1;
                    }
                    else if (selectedViewTab > i) {
                        selectedViewTab--;
                    }
                    
                    PropertyTab[] newTabs = new PropertyTab[viewTabs.Length - 1];
                    Array.Copy(viewTabs, 0, newTabs, 0, i);
                    Array.Copy(viewTabs, i + 1, newTabs, i, viewTabs.Length - i - 1);
                    viewTabs = newTabs;

                    PropertyTabScope[] newTabScopes = new PropertyTabScope[viewTabScopes.Length - 1];
                    Array.Copy(viewTabScopes, 0, newTabScopes, 0, i);
                    Array.Copy(viewTabScopes, i + 1, newTabScopes, i, viewTabScopes.Length - i - 1);
                    viewTabScopes = newTabScopes;

                    viewTabsDirty = true;
                }
            }

            if (setupToolbar && viewTabsDirty) {
                SetupToolbar();

                Debug.Assert(viewTabs != null && viewTabs.Length > 0, "Holy Moly!  We don't have any tabs left!");

                selectedViewTab = -1;
                SelectViewTabButtonDefault(selectedButton);

                // clear the component refs of the tabs
                for (int i = 0; i < viewTabs.Length; i++) {
                    viewTabs[i].Components = new Object[0];
                }
            }
        }

        internal void RemoveTab(int tabIndex, bool setupToolbar) {
            Debug.Assert(viewTabs != null, "Tab array destroyed!");

            if (tabIndex >= viewTabs.Length || tabIndex < 0) {
                throw new ArgumentException(SR.GetString(SR.PropertyGridBadTabIndex));
            }

            if (viewTabScopes[tabIndex] == PropertyTabScope.Static) {
                throw new ArgumentException(SR.GetString(SR.PropertyGridRemoveStaticTabs));
            }


            if (selectedViewTab == tabIndex) {
                selectedViewTab = PROPERTIES;
            }
            
            // Remove this tab from our "last selected" group
            //
            if (!GetFlag(ReInitTab) && ActiveDesigner != null) {
               int hashCode = ActiveDesigner.GetHashCode();
               if (designerSelections != null && designerSelections.ContainsKey(hashCode) && (int)designerSelections[hashCode] == tabIndex) {
                  designerSelections.Remove(hashCode);
               }
            }

            ToolBarButton selectedButton = viewTabButtons[selectedViewTab];

            PropertyTab[] newTabs = new PropertyTab[viewTabs.Length - 1];
            Array.Copy(viewTabs, 0, newTabs, 0, tabIndex);
            Array.Copy(viewTabs, tabIndex + 1, newTabs, tabIndex, viewTabs.Length - tabIndex - 1);
            viewTabs = newTabs;

            PropertyTabScope[] newTabScopes = new PropertyTabScope[viewTabScopes.Length - 1];
            Array.Copy(viewTabScopes, 0, newTabScopes, 0, tabIndex);
            Array.Copy(viewTabScopes, tabIndex + 1, newTabScopes, tabIndex, viewTabScopes.Length - tabIndex - 1);
            viewTabScopes = newTabScopes;

            viewTabsDirty = true;

            if (setupToolbar) {
                SetupToolbar();
                selectedViewTab = -1;
                SelectViewTabButtonDefault(selectedButton);
            }
        }

        internal void RemoveTab(Type tabType) {
            PropertyTab tab = null;
            int tabIndex = -1;
            for (int i = 0; i < viewTabs.Length; i++) {
                if (tabType == viewTabs[i].GetType()) {
                    tab = viewTabs[i];
                    tabIndex = i;
                    break;
                }
            }

            // just quit if the tab isn't present.
            if (tabIndex == -1) {
                return;
            }

            PropertyTab[] newTabs = new PropertyTab[viewTabs.Length - 1];
            Array.Copy(viewTabs, 0, newTabs, 0, tabIndex);
            Array.Copy(viewTabs, tabIndex + 1, newTabs, tabIndex, viewTabs.Length - tabIndex - 1);
            viewTabs = newTabs;

            PropertyTabScope[] newTabScopes = new PropertyTabScope[viewTabScopes.Length - 1];
            Array.Copy(viewTabScopes, 0, newTabScopes, 0, tabIndex);
            Array.Copy(viewTabScopes, tabIndex + 1, newTabScopes, tabIndex, viewTabScopes.Length - tabIndex - 1);
            viewTabScopes = newTabScopes;
            
            viewTabsDirty = true;
            SetupToolbar();
        }

        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.ResetSelectedProperty"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void ResetSelectedProperty() {
            GetPropertyGridView().Reset();
        }

        private void SaveTabSelection() {
            if (designerHost != null) {
               if (designerSelections == null) {
                   designerSelections = new Hashtable();
               }
               designerSelections[designerHost.GetHashCode()] = selectedViewTab;
            }
        }
        
        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.IComPropertyBrowser.SaveState"]/*' />
        /// <internalonly/>
        void IComPropertyBrowser.SaveState(RegistryKey optRoot) {

            if (optRoot == null) {
                return;
            }
            
            optRoot.SetValue("PbrsAlpha", (this.PropertySort == PropertySort.Alphabetical ? "1" : "0"));
            optRoot.SetValue("PbrsShowDesc", (this.HelpVisible ? "1" : "0"));
            optRoot.SetValue("PbrsDescHeightRatio", dcSizeRatio.ToString());
            optRoot.SetValue("PbrsHotCommandHeightRatio", hcSizeRatio.ToString());
       }
       
        void SetHotCommandColors(bool vscompat) {
            if (vscompat) {
                hotcommands.SetColors(SystemColors.Control, SystemColors.ControlText, SystemColors.ActiveCaption, SystemColors.ActiveCaption, SystemColors.ActiveCaption, SystemColors.ControlDark);
            }
            else {
                hotcommands.SetColors(SystemColors.Control, SystemColors.ControlText, Color.Empty, Color.Empty, Color.Empty, Color.Empty);
            }
        }

        internal void SetStatusBox(string title,string desc) {
            doccomment.SetComment(title,desc);
        }

        private void SelectViewTabButton(ToolBarButton button, bool updateSelection) {
            
                Debug.Assert(viewTabButtons != null, "No view tab buttons to select!");
    
                int oldTab = selectedViewTab;
    
                if (!SelectViewTabButtonDefault(button)) {
                    Debug.Fail("Failed to find the tab!");
                }
                
                if (updateSelection) {
                    Refresh(false);
    
                    // Notify the help service that the property tab has changed
                    //
                    IHelpService hs = (IHelpService) GetService(typeof(IHelpService));
                    if (hs != null) {
                        hs.RemoveContextAttribute("PropertyTab", viewTabs[oldTab].HelpKeyword);
                        hs.AddContextAttribute("PropertyTab", viewTabs[selectedViewTab].HelpKeyword, HelpKeywordType.FilterKeyword);
                    }
                }
        }

        private bool SelectViewTabButtonDefault(ToolBarButton button) {
                // make sure our selection number is valid
                if (selectedViewTab >= 0 && selectedViewTab >= viewTabButtons.Length) {
                    selectedViewTab = -1;
                }
    
                // is this tab button checked? If so, do nothing.
                if (selectedViewTab >=0 && selectedViewTab < viewTabButtons.Length &&
                    button == viewTabButtons[selectedViewTab]) {
                    viewTabButtons[selectedViewTab].Pushed = true;
                    return true;
                }
                
                PropertyTab oldTab = null;
    
                // unselect what's selected
                if (selectedViewTab != -1) {
                    viewTabButtons[selectedViewTab].Pushed = false;
                    oldTab = viewTabs[selectedViewTab];
                }
    
                // get the new index of the button
                for (int i = 0; i < viewTabButtons.Length; i++) {
                    if (viewTabButtons[i] == button) {
                        selectedViewTab = i;
                        viewTabButtons[i].Pushed = true;
                        try {
                            SetFlag(TabsChanging, true);
                            OnPropertyTabChanged(new PropertyTabChangedEventArgs(oldTab, viewTabs[i]));
                        }
                        finally {
                            SetFlag(TabsChanging, false);
                        }
                        return true;
                    }
                }
    
                // select the first tab if we didn't find that one.
                selectedViewTab = PROPERTIES;
                Debug.Assert(viewTabs[PROPERTIES].GetType() == DefaultTabType, "First item is not property tab!");
                SelectViewTabButton(viewTabButtons[PROPERTIES], false);
                return false;
        }

        private void SelectNextView() {
            SetSelectState(GetSelectState()+1);
        }

        private void SelectPriorView() {
            SetSelectState(GetSelectState()-1);
        }

        private void SetSelectState(int state) {
            
        
            if (state >= (viewTabs.Length * viewSortButtons.Length)) {
                state = 0;
            }
            else if (state < 0) {
                state = (viewTabs.Length * viewSortButtons.Length) - 1;
            }


            // NOTE: See GetSelectState for the full description
            // of the state transitions

            // views == 2 (Alpha || Categories)
            // viewTabs = viewTabs.length

            // state -> tab = state / views
            // state -> view = state % views

            int viewTypes = viewSortButtons.Length;
            
            if (viewTypes > 0) {
            
                int tab = state / viewTypes;
                int view = state % viewTypes;
    
                Debug.Assert(tab < viewTabs.Length, "Trying to select invalid tab!");
                Debug.Assert(view < viewSortButtons.Length, "Can't select view type > 1");
    
                OnViewTabButtonClick(viewTabButtons[tab], EventArgs.Empty);
                OnViewSortButtonClick(viewSortButtons[view], EventArgs.Empty);
            }
        }

        
        private void SetupToolbar() {
            SetupToolbar(false);
        }
        
        private void SetupToolbar(bool fullRebuild) {

            // if the tab array hasn't changed, don't bother to do all
            // this work.
            //
            if (!viewTabsDirty && !fullRebuild) {
                return;
            }
            
            try {
               this.FreezePainting = true;
   
   
               if (imageList[NORMAL_BUTTONS] == null || fullRebuild) {
                   imageList[NORMAL_BUTTONS] = new ImageList();
               }
               
               // setup our event handlers
               EventHandler ehViewTab = new EventHandler(this.OnViewTabButtonClick);
               EventHandler ehViewType = new EventHandler(this.OnViewSortButtonClick);
               EventHandler ehPP = new EventHandler(this.OnViewButtonClickPP);
   
               Bitmap b;
               int i;
   
   
               // we manange the buttons as a seperate list so the toobar doesn't flash
               ArrayList buttonList; 
               
               if (fullRebuild) {
                  buttonList = new ArrayList();
               }
               else {
                  buttonList = new ArrayList(toolbar.Buttons);
               }
   
               // setup the view type buttons.  We only need to do this once
               if (viewSortButtons == null || fullRebuild) {
                   viewSortButtons = new ToolBarButton[3];
   
                   int alphaIndex = -1;
                   int categoryIndex = -1;
   
                   try {
                       if (bmpAlpha == null) {
                           bmpAlpha = new Bitmap(typeof(PropertyGrid), "PBAlpha.bmp");
                       }
                       alphaIndex = AddImage(bmpAlpha);
                   }
                   catch (Exception e) {
                       Debug.Fail("Failed to load Alpha bitmap", e.ToString());
                   }
   
                   try {
                       if (bmpCategory == null) {
                           bmpCategory = new Bitmap(typeof(PropertyGrid), "PBCatego.bmp");
                       }
                       categoryIndex = AddImage(bmpCategory);
                   }
                   catch (Exception e) {
                       Debug.Fail("Failed to load category bitmap", e.ToString());
                   }
   
                   viewSortButtons[ALPHA] = CreatePushButton(SR.GetString(SR.PBRSToolTipAlphabetic), alphaIndex, ehViewType);
                   viewSortButtons[CATEGORIES] = CreatePushButton(SR.GetString(SR.PBRSToolTipCategorized), categoryIndex, ehViewType);
                   
                   // we create a dummy hidden button for view sort
                   viewSortButtons[NO_SORT] = CreatePushButton("", 0, ehViewType);
                   viewSortButtons[NO_SORT].Visible = false;
   
                   // add the viewType buttons and a separator
                   for (i = 0; i < viewSortButtons.Length; i++) {
                       buttonList.Add(viewSortButtons[i]);
                   }
               }
               else {
                   // clear all the items from the toolbar and image list after the first two
                   int items = buttonList.Count; 
   
                   for (i = items-1; i >= 2; i--) {
                       buttonList.RemoveAt(i);
                   }
   
                   items = imageList[NORMAL_BUTTONS].Images.Count;
   
                   for (i = items-1; i >= 2; i--) {
                       RemoveImage(i);
                   }
               }
   
               buttonList.Add(separator1);
   
               // here's our buttons array
               viewTabButtons = new ToolBarButton[viewTabs.Length];
               bool doAdd = viewTabs.Length > 1;
   
               // if we've only got the properties tab, don't add
               // the button (or we'll just have a properties button that you can't do anything with)
               // setup the view tab buttons
               for (i = 0; i < viewTabs.Length; i++) {
                   try {
                       b = viewTabs[i].Bitmap;
                       viewTabButtons[i] = CreatePushButton(viewTabs[i].TabName, AddImage(b), ehViewTab);
                       if (doAdd) {
                           buttonList.Add(viewTabButtons[i]);
                       }
                   }
                   catch (Exception ex) {
                       Debug.Fail(ex.ToString());
                   }
               }
   
               // if we didn't add anything, we don't need another separator either.
               if (doAdd) {
                   buttonList.Add(separator2);
               }
   
               // add the design page button
               int designpg = 0;
   
               try {
                   if (bmpPropPage == null) {
                       bmpPropPage = new Bitmap(typeof(PropertyGrid), "PBPPage.bmp");
                   }
                   designpg = AddImage(bmpPropPage);
               }
               catch (Exception e) {
                   Debug.Fail(e.ToString());
               }
   
               // we recreate this every time to ensure it's at the end
               //
               btnViewPropertyPages = CreatePushButton(SR.GetString(SR.PBRSToolTipPropertyPages), designpg, ehPP);
               btnViewPropertyPages.Enabled = false;
               buttonList.Add(btnViewPropertyPages);
   
               // Dispose this so it will get recreated for any new buttons.
               if (imageList[LARGE_BUTTONS] != null) {
                   imageList[LARGE_BUTTONS].Dispose();
                   imageList[LARGE_BUTTONS] = null;
               }
   
               if (buttonType != NORMAL_BUTTONS) {
                   EnsureLargeButtons();
               }
   
               toolbar.ImageList = imageList[this.buttonType];
               ToolBarButton[] temp = new ToolBarButton[buttonList.Count];
               buttonList.CopyTo(temp, 0);
               
               toolbar.Buttons.Clear();
               toolbar.Buttons.AddRange(temp);
               
               if (viewTabsDirty) {
                  // if we're redoing our tabs make sure
                  // we setup the toolbar area correctly.
                  //
                  OnLayoutInternal(false);
               }
               
               viewTabsDirty = false;
           }
           finally {
               this.FreezePainting = false;
           }
        }

        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.ShowEventsButton"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected void ShowEventsButton(bool value) {
            if (viewTabs != null && viewTabs.Length > EVENTS && (viewTabs[EVENTS] is EventsTab)) {
               
                Debug.Assert(viewTabButtons != null && viewTabButtons.Length > EVENTS && viewTabButtons[EVENTS] != null, "Events button is not at EVENTS position");
                viewTabButtons[EVENTS].Visible = value;
                if (!value && selectedViewTab == EVENTS) {
                    SelectViewTabButton(viewTabButtons[PROPERTIES], true);
                }
            }
        }

        private bool ShouldSerializeCommandsBackColor() {
            return !CommandsBackColor.Equals(SystemColors.Control);
        }

        private bool ShouldSerializeCommandsForeColor() {
            return !CommandsForeColor.Equals(SystemColors.ControlText);
        }

        private bool ShouldSerializeHelpBackColor() {
            return !HelpBackColor.Equals(SystemColors.Control);
        }

        private bool ShouldSerializeHelpForeColor() {
            return !HelpForeColor.Equals(SystemColors.ControlText);
        }

        /// <devdoc>
        ///  Sinks the property notify events on all the objects we are currently
        ///  browsing.
        ///
        ///  See IPropertyNotifySink
        /// </devdoc>
        private void SinkPropertyNotifyEvents() {
            // first clear any existing sinks.
            for (int i = 0;connectionPointCookies != null && i < connectionPointCookies.Length; i++) {
                if (connectionPointCookies[i] != null) {
                    connectionPointCookies[i].Disconnect();
                    connectionPointCookies[i] = null;
                }
            }

            if (currentObjects == null || currentObjects.Length == 0) {
                connectionPointCookies = null;
                return;
            }

            // it's okay if our array is too big...we'll just reuse it and ignore the empty slots.
            if (connectionPointCookies == null || (currentObjects.Length > connectionPointCookies.Length)) {
                connectionPointCookies = new NativeMethods.ConnectionPointCookie[currentObjects.Length];
            }
            
            for (int i = 0; i < currentObjects.Length; i++) {
                try {
                    Object obj = GetUnwrappedObject(i);

                    if (!Marshal.IsComObject(obj)) {
                        continue;
                    }
                    connectionPointCookies[i] = new NativeMethods.ConnectionPointCookie(obj, this, typeof(UnsafeNativeMethods.IPropertyNotifySink), false);
                }
                catch (Exception) {
                    // guess we failed eh?
                }
            }
        }

        private bool ShouldForwardChildMouseMessage(Control child, MouseEventArgs me, ref Point pt) {

            Size size = child.Size;

            // are we within two pixels of the edge?
            if (me.Y <= 1 || (size.Height - me.Y) <= 1) {
                // convert the coordinates to
                NativeMethods.POINT temp = new NativeMethods.POINT();
                temp.x = me.X;
                temp.y = me.Y;
                UnsafeNativeMethods.MapWindowPoints(new HandleRef(child, child.Handle), new HandleRef(this, Handle), temp, 1);

                // forward the message
                pt.X = temp.x;
                pt.Y = temp.y;
                return true;
            }
            return false;
        }

        internal void UpdateSelection() {

            if (!GetFlag(PropertiesChanged)) {
                return;
            }
            
            if (viewTabs == null) {
                return;
            }
            
            string tabName = viewTabs[selectedViewTab].TabName + propertySortValue.ToString();

            if (viewTabProps != null && viewTabProps.ContainsKey(tabName)) {
               peMain = (GridEntry)viewTabProps[tabName];
               if (peMain != null) {
                   peMain.Refresh();
               }
            }
            else {
               if (currentObjects != null && currentObjects.Length > 0) {
                   peMain = (GridEntry)GridEntry.Create(gridView, currentObjects, new PropertyGridServiceProvider(this), designerHost, this.SelectedTab, propertySortValue);
               }
               else {
                   peMain = null;
               }
   
               if (peMain == null) {
                   currentPropEntries = new GridEntryCollection(null, new GridEntry[0]);
                   gridView.ClearProps();
                   return;
               }
   
               if (BrowsableAttributes != null) {
                   peMain.BrowsableAttributes = BrowsableAttributes;
               }

               if (viewTabProps == null) {
                    viewTabProps = new Hashtable();
               }
               
               viewTabProps[tabName] = peMain;
            }

            // get entries.
            currentPropEntries = peMain.Children;
            peDefault = peMain.DefaultChild;
            gridView.Invalidate();
        }



        // a mini version of process dialog key
        // for responding to WM_GETDLGCODE
        internal bool WantsTab(bool forward) {
            if (forward) {
                return toolbar.Visible && toolbar.Focused;
            }
            else {
                return gridView.ContainsFocus && toolbar.Visible;
            }
        }

        private string propName;
        private int    dwMsg;

        private void GetDataFromCopyData(IntPtr lparam) {
            NativeMethods.COPYDATASTRUCT cds = (NativeMethods.COPYDATASTRUCT)UnsafeNativeMethods.PtrToStructure(lparam, typeof(NativeMethods.COPYDATASTRUCT));

            if (cds != null && cds.lpData != IntPtr.Zero) {
                propName = Marshal.PtrToStringAuto(cds.lpData);
                dwMsg = cds.dwData;
            }
        }
        
        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.OnSystemColorsChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnSystemColorsChanged(EventArgs e) {
            // refresh the toolbar buttons
            SetupToolbar(true);
            
            // this doesn't stick the first time we do it...
            // either probably a toolbar issue, maybe GDI+, so we call it again
            // fortunately this doesn't happen very often.
            //
            if (!GetFlag(SysColorChangeRefresh)) {
               SetupToolbar(true);
               SetFlag(SysColorChangeRefresh, true);
            }
            base.OnSystemColorsChanged(e);
        }

        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.WndProc"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        protected override void WndProc(ref Message m) {

            switch (m.Msg) {
                case NativeMethods.WM_CLEAR:
                    if (m.LParam == this.Handle) {
                        gridView.RefreshHelpAttributes();
                        return;
                    }
                    break;
                case NativeMethods.WM_UNDO:
                    if ((int)m.LParam == 0) {
                        gridView.DoUndoCommand();
                    }
                    else {
                        m.Result = CanUndo ? (IntPtr)1 : (IntPtr)0;
                    }
                    return;
                case NativeMethods.WM_CUT:
                    if ((int)m.LParam == 0) {
                        gridView.DoCutCommand();
                    }
                    else {
                        m.Result = CanCut ? (IntPtr)1 : (IntPtr)0;
                    }
                    return;

                case NativeMethods.WM_COPY:
                    if ((int)m.LParam == 0) {
                        gridView.DoCopyCommand();
                    }
                    else {
                        m.Result = CanCopy ? (IntPtr)1 : (IntPtr)0;
                    }
                    return;

                case NativeMethods.WM_PASTE:
                    if ((int)m.LParam == 0) {
                        gridView.DoPasteCommand();
                    }
                    else {
                        m.Result = CanPaste ? (IntPtr)1 : (IntPtr)0;
                    }
                    return;
                
                case NativeMethods.WM_COPYDATA:
                    GetDataFromCopyData(m.LParam);
                    m.Result = (IntPtr)1;
                    return;
                case AutomationMessages.PGM_GETBUTTONCOUNT:
                    if (toolbar != null) {
                        m.Result = (IntPtr)toolbar.Buttons.Count;
                        return;
                    }
                    break;
                case AutomationMessages.PGM_GETBUTTONSTATE:
                    if (toolbar != null) {
                        m.Result = (IntPtr)(toolbar.Buttons[(int)m.WParam].Pushed ? 1 : 0);
                        return;
                    }
                    break;
                case AutomationMessages.PGM_SETBUTTONSTATE:
                    if (toolbar != null) {
                        ToolBarButton button = toolbar.Buttons[(int)m.WParam];
                        // special treatment for the properies page button
                        if (button == btnViewPropertyPages) {
                            OnViewButtonClickPP(button, EventArgs.Empty);
                        }
                        else {
                            switch ((int)m.WParam) {
                                case ALPHA:
                                case CATEGORIES:
                                    OnViewSortButtonClick(button, EventArgs.Empty);
                                    break;
                                default:
                                    SelectViewTabButton(button, true);
                                    break;
                            }
                        }
                        return;
                    }
                    break;

                case AutomationMessages.PGM_GETBUTTONTEXT:
                case AutomationMessages.PGM_GETBUTTONTOOLTIPTEXT:
                    if (toolbar != null) {
                        string t;
                        if (m.Msg == AutomationMessages.PGM_GETBUTTONTEXT) {
                            t = toolbar.Buttons[(int)m.WParam].Text;
                        }
                        else {
                            t = toolbar.Buttons[(int)m.WParam].ToolTipText;
                        }
                        int len = t == null ? 0 : t.Length ;
                        IntPtr ptr = m.LParam;

                        if (ptr != IntPtr.Zero) {
                            for (int i = 0; i < len; i++) {
                                Marshal.WriteInt16((IntPtr)((long)ptr+(i*2)), t[i]);
                            }
                        }
                        m.Result = (IntPtr)len;
                        return;
                    }
                    break;
                case AutomationMessages.PGM_GETROWCOORDS:
                    if (m.Msg == this.dwMsg) {
                        m.Result = (IntPtr) gridView.GetPropertyLocation(propName, m.LParam == IntPtr.Zero, m.WParam == IntPtr.Zero);
                        return;
                    }
                    break;
                case AutomationMessages.PGM_GETSELECTEDROW:
                case AutomationMessages.PGM_GETVISIBLEROWCOUNT:
                    m.Result = gridView.SendMessage(m.Msg, m.WParam, m.LParam);
                    return;
                case AutomationMessages.PGM_SETSELECTEDTAB:
                    
                    string tabTypeName = Marshal.PtrToStringBSTR(m.LParam);

                    for (int i = 0; i < viewTabs.Length;i++) {
                       if (viewTabs[i].GetType().FullName == tabTypeName && viewTabButtons[i].Visible) {
                           SelectViewTabButtonDefault(viewTabButtons[i]);
                           m.Result = (IntPtr)1;
                           break;
                       }
                    }
                    m.Result = (IntPtr)0;
                    return;
            }

            base.WndProc(ref m);
        }

        internal abstract class SnappableControl : Control {
            internal bool userSized = false;
            public abstract int GetOptimalHeight(int width);
            public abstract int SnapHeightRequest(int request);
            
            public SnappableControl() {
                SetStyle(ControlStyles.DoubleBuffer, true);
            }

            public override Cursor Cursor {
                 get {
                     return Cursors.Default;
                 }
                 set {
                     base.Cursor = value;
                 }
            }


            protected override void OnControlAdded(ControlEventArgs ce) {
                //ce.Control.MouseEnter += new EventHandler(this.OnChildMouseEnter);
            }
            
            private void OnChildMouseEnter(object sender, EventArgs e) {
                if (sender is Control) {
                    ((Control)sender).Cursor = Cursors.Default;
                }
            }
            
            protected override void OnPaint(PaintEventArgs e) {
                base.OnPaint(e);
                Rectangle r = this.ClientRectangle;
                r.Width --;
                r.Height--;
                e.Graphics.DrawRectangle(SystemPens.ControlDark, r);
            }
        }

        internal class GridToolBar : ToolBar {
        
            private int lastMouseMove = -1;
            private bool msoPaint = false;
            private short lowRes = LowResCheck;

            private const short LowResCheck = 0;
            private const short LowResYes   = 1;
            private const short LowResNo    = 2;
         
            public GridToolBar() : base() {
                SetStyle(ControlStyles.Opaque, true);
            }
            
            private bool LowRes {
                get {

                    if (lowRes == LowResCheck) {
                        if (SystemInformation.TerminalServerSession || BitDepth <= 8) {
                            lowRes = LowResYes;
                        }
                        else {
                            lowRes = LowResNo;
                        }
                    }
                    return lowRes == LowResYes;
                }
            }
            
            private int BitDepth {
                get {

                    int minBitDepth = -1;

                    foreach (Screen s in Screen.AllScreens) {
                        if (minBitDepth == -1) {
                            minBitDepth = s.BitDepth;
                        }
                        else {
                            minBitDepth = Math.Min(s.BitDepth, minBitDepth);
                        }
                    }

                    return minBitDepth;
                }
            }
            
            public bool MsoPaint {
                get {
                    return msoPaint;
                }
                set {
                    msoPaint = value;
                    if (value != msoPaint) {
                        if (value) {
                            SystemEvents.UserPreferenceChanged += new UserPreferenceChangedEventHandler(this.OnSysColorChange);
                        }
                        else {
                            SystemEvents.UserPreferenceChanged -= new UserPreferenceChangedEventHandler(this.OnSysColorChange);
                        }
                    }
                }
            }

            protected override void Dispose(bool disposing) {

                if (disposing) {
                    // this wil unhook the system events hadnler..
                    //
                    this.MsoPaint = false;
                }
                base.Dispose(disposing);
            }
            
            private void DrawBackgroundRect(Graphics g, ref NativeMethods.RECT rect, bool hot, bool pushed) {
            
                // draw the hot background
                Rectangle bounds = new Rectangle(rect.left, rect.top, rect.right-rect.left, rect.bottom-rect.top);
                
                Color colorHighlight = SystemColors.Highlight;
                Color colorWhite = SystemColors.Window;
                Color colorBorder = SystemColors.Highlight;
                
                bool lowRes = this.LowRes;
                bool highContrast = SystemInformation.HighContrast;
                
                if (hot && !pushed) {
                    if (highContrast) {
                        colorWhite = Color.Empty;
                        colorBorder = SystemColors.HighlightText;
                    }
                    else if (!lowRes) {
                        colorHighlight = Color.FromArgb(70, colorHighlight);
                        colorWhite = Color.FromArgb(50, colorWhite);
                    }
                    else {
                        colorHighlight = Color.Empty;
                    }
                }
                else if (pushed && !hot) {
                    if (!lowRes) {
                        colorHighlight = Color.FromArgb(50, colorHighlight);
                        colorWhite = Color.FromArgb(70, colorWhite);
                    }
                    else {
                        colorHighlight = Color.Empty;
                    }
                }
                else if(hot && pushed) {
                    if (highContrast) {
                        colorWhite = Color.Empty;
                        colorBorder = SystemColors.HighlightText;
                    }
                    else if (!lowRes) {
                        colorHighlight = Color.FromArgb(90, colorHighlight);
                        colorWhite = Color.FromArgb(15, colorWhite);
                    }
                    else {
                        colorWhite = Color.Empty;
                    }
                }
                else {
                    return;
                }
                
                
                
                Brush backBrush = new SolidBrush(SystemColors.Window);
                Brush highLight = new SolidBrush(colorHighlight);
                Brush whiteWash = new SolidBrush(colorWhite);
                Pen borderPen = new Pen(colorBorder);
                                                
                g.FillRectangle(backBrush, bounds);

                if (colorHighlight != Color.Empty) {
                    g.FillRectangle(highLight, bounds);
                }
                
                if (colorWhite != Color.Empty) {
                    g.FillRectangle(whiteWash, bounds);
                }

                g.DrawRectangle(borderPen, bounds.X, bounds.Y, bounds.Width - 1, bounds.Height - 1);

                borderPen.Dispose();
                highLight.Dispose();
                whiteWash.Dispose();
                backBrush.Dispose();

                
            }
            
            private void DrawDefaultButton(Graphics g, ref NativeMethods.RECT rect, ToolBarButton b, bool wash) {
                // center the image in the rect.
                Image image = b.Parent.ImageList.Images[b.ImageIndex];
                int x = rect.left + (rect.right - rect.left - image.Width) / 2;
                int y = rect.top + (rect.bottom - rect.top - image.Height) / 2;
                g.DrawImage(image, x, y, image.Width, image.Height);
                image.Dispose();

                if (wash && !LowRes) {
                    Brush washBrush = new SolidBrush(Color.FromArgb(30, Color.White));
                    g.FillRectangle(washBrush, rect.left, rect.top, rect.right-rect.left, rect.bottom-rect.top);
                    washBrush.Dispose();
                }
            }
            
            private void DrawDisabledButton(Graphics g, ref NativeMethods.RECT rect, ToolBarButton b) {
                // center the image in the rect.
                Image image = b.Parent.ImageList.Images[b.ImageIndex];
                int x = rect.left + (rect.right - rect.left - image.Width) / 2;
                int y = rect.top + (rect.bottom - rect.top - image.Height) / 2;
                DrawDisabledImage(g, image, x, y);
                image.Dispose();
            }
            
            private unsafe void DrawDisabledImage(Graphics g, Image image, int x, int y) {
                Bitmap b = new Bitmap(image);
                BitmapData bd = b.LockBits(new Rectangle(0, 0, b.Width, b.Height), ImageLockMode.ReadWrite, PixelFormat.Format32bppArgb);
                try {
                    int size = b.Width * b.Height;
                    int darkColor = SystemColors.ControlDark.ToArgb();
                        // make all the white bits transparent, and any non-transparent ones dark gray.
                        //
                        int* pData = (int*)bd.Scan0;
                        int transColor = pData[size-1];
                        for (int i = 0; i < size; i++) {
                            if (pData[i] != transColor) {
                                if ((pData[i] & 0xFFFFFF) == 0xFFFFFF) {
                                    pData[i] = transColor;
                                }
                                else {
                                    pData[i] = darkColor;
                                }
                            }
                        }
                }
                finally {
                    b.UnlockBits(bd);
                }
                g.DrawImage(b, x, y, b.Width, b.Height);
                b.Dispose();
            }
            
            private void DrawHotButton(Graphics g, ref NativeMethods.RECT rect, ToolBarButton b, bool drawSelected) {
                
                drawSelected |= b.Pushed;
                
                // draw the hot background
                DrawBackgroundRect(g, ref rect, true, drawSelected);

                
                // center the image in the rect.
                Image image = b.Parent.ImageList.Images[b.ImageIndex];
                int x = rect.left + (rect.right - rect.left - image.Width) / 2;
                int y = rect.top + (rect.bottom - rect.top - image.Height) / 2;
                if (drawSelected) {
                    g.DrawImage(image, x, y, image.Width, image.Height);
                }
                else {
                    int xdelta = image.Width / 16;
                    int ydelta = image.Height / 16;
                    DrawDisabledImage(g, image, x, y+ydelta);
                    g.DrawImage(image, x - xdelta, y - xdelta, image.Width, image.Height);
                }
                
                image.Dispose();
            }
            
            private void DrawPushedButton(Graphics g, ref NativeMethods.RECT rect, ToolBarButton b) {
                // draw the hot background
                DrawBackgroundRect(g, ref rect, false, true);
                DrawDefaultButton(g, ref rect, b, false);
            }

            private void OnSysColorChange(object sender, UserPreferenceChangedEventArgs e) {
                // reset lowres so we'll re-fetch the value...
                lowRes = LowResCheck;
            }
            
            private void PaintBorder(IntPtr wparam, IntPtr lparam) {
                Graphics g = CreateGraphicsInternal();

                // top left -> top right
                g.DrawLine(SystemPens.ControlLightLight, 0, 0, this.Width - 1, 0);

                // top left -> bottom left
                g.DrawLine(SystemPens.ControlLightLight, 0, 0, 0, this.Height - 1);

                // top right -> bottom right
                g.DrawLine(SystemPens.ControlDark, this.Width-1, 0, this.Width-1, this.Height);

                // bottom left -> bottom right
                g.DrawLine(SystemPens.ControlDark, 0, this.Height-1, this.Width, this.Height-1);

                g.Dispose();
            }
            
            internal IntPtr PaintItem(NativeMethods.NMCUSTOMDRAW nmCustomDraw) {
                Graphics g = Graphics.FromHdc(nmCustomDraw.hdc);
                try {
                    switch (nmCustomDraw.uItemState) {
                        case NativeMethods.CDIS_CHECKED:
                            DrawPushedButton(g, ref nmCustomDraw.rc, Buttons[nmCustomDraw.dwItemSpec]);
                            return (IntPtr)NativeMethods.CDRF_SKIPDEFAULT;
                        case NativeMethods.CDIS_HOT|NativeMethods.CDIS_CHECKED:
                        case NativeMethods.CDIS_HOT|NativeMethods.CDIS_SELECTED:
                        case NativeMethods.CDIS_HOT|NativeMethods.CDIS_SELECTED|NativeMethods.CDIS_CHECKED:
                            DrawHotButton(g, ref nmCustomDraw.rc, Buttons[nmCustomDraw.dwItemSpec], true);
                            return (IntPtr)NativeMethods.CDRF_SKIPDEFAULT;
                        case NativeMethods.CDIS_HOT:
                            DrawHotButton(g, ref nmCustomDraw.rc, Buttons[nmCustomDraw.dwItemSpec], false);
                            return (IntPtr)NativeMethods.CDRF_SKIPDEFAULT;
                        case NativeMethods.CDIS_GRAYED:
                        case NativeMethods.CDIS_DISABLED:
                            DrawDisabledButton(g, ref nmCustomDraw.rc, Buttons[nmCustomDraw.dwItemSpec]);
                            return (IntPtr)NativeMethods.CDRF_SKIPDEFAULT;
                        case NativeMethods.CDIS_DEFAULT:
                        case 0:
                            DrawDefaultButton(g, ref nmCustomDraw.rc, Buttons[nmCustomDraw.dwItemSpec], true);
                            return (IntPtr)NativeMethods.CDRF_SKIPDEFAULT;
                        default:
                        return (IntPtr)NativeMethods.CDRF_DODEFAULT;
                    }
                }
                finally {
                    g.Dispose();
                }
            }

            protected override void OnGotFocus(EventArgs e) {
                base.OnGotFocus(e);
            }

            protected override void OnMouseMove(MouseEventArgs me) {
                Cursor = Cursors.Default;
                base.OnMouseMove(me);
            }
            
            protected override void OnPaint(PaintEventArgs pe) {
                Brush b = new SolidBrush(this.BackColor);
                pe.Graphics.FillRectangle(b, this.ClientRectangle);
                b.Dispose();
                base.OnPaint(pe);
            }
            
            
            protected override void WndProc(ref Message m) {
                switch (m.Msg) {
                    case NativeMethods.WM_REFLECT + NativeMethods.WM_NOTIFY:
                    
                        if (!msoPaint) {
                            break;
                        }
                        
                        NativeMethods.NMHDR nmhdr = (NativeMethods.NMHDR)m.GetLParam(typeof(NativeMethods.NMHDR));
                        switch (nmhdr.code) {
                            case NativeMethods.NM_CUSTOMDRAW:
                                NativeMethods.NMCUSTOMDRAW cd = (NativeMethods.NMCUSTOMDRAW)m.GetLParam(typeof(NativeMethods.NMCUSTOMDRAW));
                                switch (cd.dwDrawStage) {
                                    case NativeMethods.CDDS_PREPAINT:
                                        m.Result = (IntPtr)NativeMethods.CDRF_NOTIFYITEMDRAW;
                                        return;
                                    
                                    case NativeMethods.CDDS_ITEMPREPAINT:
                                        m.Result = PaintItem(cd);
                                        return;
                                }
                                break;
                        }
                        break;

                    case NativeMethods.WM_PAINT:
                        base.WndProc(ref m);
                        if (!msoPaint) {
                            PaintBorder(m.WParam, m.LParam);
                        }
                        return;
                        
                    case NativeMethods.WM_MOUSEMOVE:
                        if (lastMouseMove == (int)m.LParam) {
                           return;   
                        }
                        lastMouseMove = (int)m.LParam;
                        break;
                }
                base.WndProc(ref m);
            }
        }
        
        /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.PropertyTabCollection"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Name="FullTrust")]
        [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
        public class PropertyTabCollection : ICollection {
        
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            internal static PropertyTabCollection Empty = new PropertyTabCollection(null);
            
            private  PropertyGrid   owner;
    
            internal PropertyTabCollection(PropertyGrid owner) {
                this.owner = owner;
            }
            
            /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.PropertyTabCollection.Count"]/*' />
            /// <devdoc>
            ///     Retrieves the number of member attributes.
            /// </devdoc>
            public int Count {
                get {
                    if (owner == null) {
                        return 0;
                    }
                    return owner.viewTabs.Length;
                }
            }
    
            /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyTabCollection.ICollection.SyncRoot"]/*' />
            /// <internalonly/>
            object ICollection.SyncRoot {
                get {
                    return this;
                }
            }
    
            /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyTabCollection.ICollection.IsSynchronized"]/*' />
            /// <internalonly/>
            bool ICollection.IsSynchronized {
                get {
                    return false;
                }
            }
    
            /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.PropertyTabCollection.this"]/*' />
            /// <devdoc>
            ///     Retrieves the member attribute with the specified index.
            /// </devdoc>
            public PropertyTab this[int index] {
                get {
                    if (owner == null) {
                        throw new InvalidOperationException(SR.GetString(SR.PropertyGridPropertyTabCollectionReadOnly));
                    }
                    return owner.viewTabs[index];
                }
            }
            
            /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.PropertyTabCollection.AddTabType"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public void AddTabType(Type propertyTabType) {
                if (owner == null) {
                    throw new InvalidOperationException(SR.GetString(SR.PropertyGridPropertyTabCollectionReadOnly));
                }
                owner.AddTab(propertyTabType, PropertyTabScope.Global);
            }
            
            /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.PropertyTabCollection.AddTabType1"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public void AddTabType(Type propertyTabType, PropertyTabScope tabScope) {
                if (owner == null) {
                    throw new InvalidOperationException(SR.GetString(SR.PropertyGridPropertyTabCollectionReadOnly));
                }
                owner.AddTab(propertyTabType, tabScope);
            }
            
            /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.PropertyTabCollection.Clear"]/*' />
            /// <devdoc>
            /// Clears the tabs of the given scope or smaller.
            /// tabScope must be PropertyTabScope.Component or PropertyTabScope.Document.
            /// </devdoc>
            public void Clear(PropertyTabScope tabScope) {
                if (owner == null) {
                    throw new InvalidOperationException(SR.GetString(SR.PropertyGridPropertyTabCollectionReadOnly));
                }
                owner.ClearTabs(tabScope);
            }
            
            
            /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyTabCollection.ICollection.CopyTo"]/*' />
            /// <internalonly/>
            void ICollection.CopyTo(Array dest, int index) {
                if (owner == null) {
                    return;
                }
                if (owner.viewTabs.Length > 0) {
                    System.Array.Copy(owner.viewTabs, 0, dest, index, owner.viewTabs.Length);
                }
            }
            /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.PropertyTabCollection.GetEnumerator"]/*' />
            /// <devdoc>
            ///      Creates and retrieves a new enumerator for this collection.
            /// </devdoc>
            public IEnumerator GetEnumerator() {
                if (owner == null) {
                    return new PropertyTab[0].GetEnumerator();
                }
                
                return owner.viewTabs.GetEnumerator();
            }
            
            /// <include file='doc\PropertyGrid.uex' path='docs/doc[@for="PropertyGrid.PropertyTabCollection.RemoveTabType"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public void RemoveTabType(Type propertyTabType) {
                if (owner == null) {
                    throw new InvalidOperationException(SR.GetString(SR.PropertyGridPropertyTabCollectionReadOnly));
                }
                owner.RemoveTab(propertyTabType);
            }
    
        }

        internal class SelectedObjectConverter : ReferenceConverter {
            public SelectedObjectConverter() : base(typeof(IComponent)) {
            }
        }

        private class PropertyGridServiceProvider : IServiceProvider {
            PropertyGrid owner;
            
            public PropertyGridServiceProvider(PropertyGrid owner) {
                this.owner = owner;
            }

            public object GetService(Type serviceType) {
               object s = null;
               
               if (owner.ActiveDesigner != null) {
                   s = owner.ActiveDesigner.GetService(serviceType);
               }

               if (s == null) {
                   s = owner.gridView.GetService(serviceType);
               }

               if (s == null && owner.Site != null) {
                   s = owner.Site.GetService(serviceType);
               }
               return s;
            }
            
        }
    }

    internal class AutomationMessages {
        private const int WM_USER = NativeMethods.WM_USER;
        internal const int PGM_GETBUTTONCOUNT = WM_USER + 0x50;
        internal const int PGM_GETBUTTONSTATE = WM_USER + 0x52;
        internal const int PGM_SETBUTTONSTATE = WM_USER + 0x51;
        internal const int PGM_GETBUTTONTEXT = WM_USER + 0x53;
        internal const int PGM_GETBUTTONTOOLTIPTEXT = WM_USER + 0x54;
        internal const int PGM_GETROWCOORDS = WM_USER + 0x55;
        internal const int PGM_GETVISIBLEROWCOUNT = WM_USER + 0x56;
        internal const int PGM_GETSELECTEDROW = WM_USER + 0x57;
        internal const int PGM_SETSELECTEDTAB = WM_USER + 0x58; // DO NOT CHANGE THIS : VC uses it!
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\richtextboxscrollbars.cs ===
//------------------------------------------------------------------------------
// <copyright file="RichTextBoxScrollBars.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    using Microsoft.Win32;


    /// <include file='doc\RichTextBoxScrollBars.uex' path='docs/doc[@for="RichTextBoxScrollBars"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies how a <see cref='System.Windows.Forms.RichTextBox'/> control displays scroll bars.
    ///
    ///    </para>
    /// </devdoc>
    public enum RichTextBoxScrollBars {

        /// <include file='doc\RichTextBoxScrollBars.uex' path='docs/doc[@for="RichTextBoxScrollBars.None"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Never display scroll bars.
        ///    </para>
        /// </devdoc>
        None       = 0,

        /// <include file='doc\RichTextBoxScrollBars.uex' path='docs/doc[@for="RichTextBoxScrollBars.Horizontal"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Display only a
        ///       horizontal scroll bar when needed.
        ///
        ///    </para>
        /// </devdoc>
        Horizontal = RichTextBoxConstants.RTB_HORIZ,

        /// <include file='doc\RichTextBoxScrollBars.uex' path='docs/doc[@for="RichTextBoxScrollBars.Vertical"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Display only a
        ///       vertical scroll bar when needed.
        ///
        ///    </para>
        /// </devdoc>
        Vertical   = RichTextBoxConstants.RTB_VERT,

        /// <include file='doc\RichTextBoxScrollBars.uex' path='docs/doc[@for="RichTextBoxScrollBars.Both"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Display both a horizontal and a vertical scroll bar when needed.
        ///    </para>
        /// </devdoc>
        Both       = Horizontal | Vertical,

        /// <include file='doc\RichTextBoxScrollBars.uex' path='docs/doc[@for="RichTextBoxScrollBars.ForcedHorizontal"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Always
        ///       display only a horizontal scroll bar.
        ///
        ///    </para>
        /// </devdoc>
        ForcedHorizontal = RichTextBoxConstants.RTB_FORCE | Horizontal,

        /// <include file='doc\RichTextBoxScrollBars.uex' path='docs/doc[@for="RichTextBoxScrollBars.ForcedVertical"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Always display only a vertical scroll bar.
        ///    </para>
        /// </devdoc>
        ForcedVertical = RichTextBoxConstants.RTB_FORCE | Vertical,

        /// <include file='doc\RichTextBoxScrollBars.uex' path='docs/doc[@for="RichTextBoxScrollBars.ForcedBoth"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Always display both a horizontal and a vertical scroll bar.
        ///    </para>
        /// </devdoc>
        ForcedBoth = ForcedHorizontal | ForcedVertical,

        // Be careful when adding new members -- this enum is part normal, part flags
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\richtextbox.cs ===
//------------------------------------------------------------------------------
// <copyright file="RichTextBox.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

//=--------------------------------------------------------------------------=
// RichText Box.cs
//=--------------------------------------------------------------------------=
// Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

namespace System.Windows.Forms {
    using System.Runtime.Serialization.Formatters;
    using System.Text;
    using System.Security;
    using System.Runtime.InteropServices;
    using System.Runtime.Remoting;
    using System.ComponentModel;
    using System.Windows.Forms.ComponentModel;
    using Util = NativeMethods.Util;
    using System.Diagnostics;
    using System;
    using System.Security.Permissions;
    using System.Drawing;
    using System.Windows.Forms;
    using System.IO;
    using Microsoft.Win32;
    using System.Globalization;

    //     CONSIDER: Future improvements:
    //     :
    //     : selectionCharOffset doesn't throw exception for mixed styles, see EM_SETCHARFORMAT
    //     : selectionColor doesn't return a null when there is a mixture of colors
    //     : selectionIsCharOffset not implemented
    //     : selectionPrint not implemented (need a printer class)

    /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox"]/*' />
    /// <devdoc>
    ///     Rich Text control. The RichTextBox is a control that contains formatted text.
    ///     It supports font selection, boldface, and other type attributes.
    /// </devdoc>
    public class RichTextBox : TextBoxBase {
        static TraceSwitch richTextDbg;
        static TraceSwitch RichTextDbg {
            get {
                if (richTextDbg == null) {
                    richTextDbg = new TraceSwitch("RichTextDbg", "Debug info about RichTextBox");
                }
                return richTextDbg;
            }
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.DV_E_DVASPECT"]/*' />
        /// <devdoc>
        ///     Paste special flags.
        /// </devdoc>
        private const int DV_E_DVASPECT      = unchecked((int)0x8004006B);
        private const int DVASPECT_CONTENT   = 1;
        private const int DVASPECT_THUMBNAIL = 2;
        private const int DVASPECT_ICON      = 4;
        private const int DVASPECT_DOCPRINT  = 8;

        internal const int INPUT             = 0x0001;
        internal const int OUTPUT            = 0x0002;
        internal const int DIRECTIONMASK     = INPUT | OUTPUT;
        internal const int ANSI              = 0x0004;
        internal const int UNICODE           = 0x0008;
        internal const int FORMATMASK        = ANSI | UNICODE;
        internal const int TEXTLF            = 0x0010;
        internal const int TEXTCRLF          = 0x0020;
        internal const int RTF               = 0x0040;
        internal const int KINDMASK          = TEXTLF | TEXTCRLF | RTF;

        // This is where we store the reched library.
        private static IntPtr moduleHandle;

        private static readonly string SZ_RTF_TAG      = "{\\rtf";
        private const int CHAR_BUFFER_LEN    = 512;

        // Event objects
        //
        private static readonly object EVENT_HSCROLL          = new object();
        private static readonly object EVENT_LINKACTIVATE     = new object();
        private static readonly object EVENT_IMECHANGE        = new object();
        private static readonly object EVENT_PROTECTED        = new object();
        private static readonly object EVENT_REQUESTRESIZE    = new object();
        private static readonly object EVENT_SELCHANGE        = new object();
        private static readonly object EVENT_VSCROLL          = new object();


        // Persistent state
        //
        private int         bulletIndent;
        private int         rightMargin;
        private bool        autoWordSelection;
        private bool        showSelBar; // show selection margin on left?
        private bool        autoUrlDetect = true;
        private string      textRtf; // If not null, takes precedence over cached Text value
        private string      textPlain;
        private bool     fInCtor = true;
        private RichTextBoxScrollBars scrollBars = RichTextBoxScrollBars.Both;

        // Non-persistent state
        //
        static int logPixelsX;
        static int logPixelsY;
        Stream editStream = null;
        bool       protectedError;
        bool        linkcursor;
        float zoomMultiplier = 1.0f;

        // used to decide when to fire the selectionChange event.
        private int curSelStart;
        private int curSelEnd;
        private short curSelType;
        bool allowOleDrop = false;
        object oleCallback;
        private bool suppressTextChangedEvent = false;

        // Prevent unnecessary firing of contentresize:
        //
        bool callOnContentsResized = false;

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.RichTextBox"]/*' />
        /// <devdoc>
        ///     Constructs a new RichTextBox.
        /// </devdoc>
        public RichTextBox() : base() {
            MaxLength = int.MaxValue;
            Multiline = true;
            AutoSize = false;
            SetStyle(ControlStyles.StandardClick, false);
            curSelStart = curSelEnd = curSelType = -1;
            fInCtor = false;
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.AllowDrop"]/*' />
        /// <devdoc>
        ///     RichTextBox controls have built-in drag and drop support which can't be changed.
        /// </devdoc>
        public override bool AllowDrop {
            get {
                return allowOleDrop;
            }
            set {
                if (value) {
                    IntSecurity.ClipboardRead.Demand();
                }
                allowOleDrop = value;
                UpdateOleCallback();
            }
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.AutoWordSelection"]/*' />
        /// <devdoc>
        ///     Controls whether whether mouse selection snaps to whole words.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(false),
        SRDescription(SR.RichTextBoxAutoWordSelection)
        ]
        public bool AutoWordSelection {
            get {
                return autoWordSelection;
            }

            set {
                this.autoWordSelection = value;
                if (IsHandleCreated) {
                    SendMessage(RichTextBoxConstants.EM_SETOPTIONS,
                                autoWordSelection ? RichTextBoxConstants.ECOOP_OR : RichTextBoxConstants.ECOOP_XOR,
                                RichTextBoxConstants.ECO_AUTOWORDSELECTION);
                }
            }
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.AutoSize"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        Localizable(true),
        DefaultValue(false)
        ]
        public override bool AutoSize {
            get {
                return base.AutoSize;
            }
            set {
                base.AutoSize = value;
            }
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.BackgroundImage"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override Image BackgroundImage {
            get {
                return base.BackgroundImage;
            }
            set {
                base.BackgroundImage = value;
            }
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.BackgroundImageChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler BackgroundImageChanged {
            add {
                base.BackgroundImageChanged += value;
            }
            remove {
                base.BackgroundImageChanged -= value;
            }
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.BulletIndent"]/*' />
        /// <devdoc>
        ///     Returns the amount of indent used in a RichTextBox control when
        ///     SelectionBullet is set to true.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(0),
        Localizable(true),
        SRDescription(SR.RichTextBoxBulletIndent)
        ]
        public int BulletIndent {
            get {
                return bulletIndent;
            }

            set {

                if (value < 0) {
                    throw new ArgumentException(SR.GetString(SR.InvalidArgument, "BulletIndent", (value).ToString()));
                }

                this.bulletIndent = value;

                // Call to update the control only if the bullet is set.
                if (IsHandleCreated && SelectionBullet)
                    SelectionBullet = true;
            }
        }

        internal override bool CanRaiseTextChangedEvent {
            get {
                return !suppressTextChangedEvent;
            }
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.CanRedo"]/*' />
        /// <devdoc>
        ///      Whether or not there are actions that can be Redone on the RichTextBox control.
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.RichTextBoxCanRedoDescr)
        ]
        public bool CanRedo {
            get {
                if (IsHandleCreated) {
                    bool b;
                    b = (int)SendMessage(RichTextBoxConstants.EM_CANREDO, 0, 0) != 0;

                    return b;
                }
                return false;
            }
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.CreateParams"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override CreateParams CreateParams {
            [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
            get {

                // Check for library
                if (moduleHandle == IntPtr.Zero) {
                    moduleHandle = UnsafeNativeMethods.LoadLibrary(RichTextBoxConstants.DLL_RICHEDIT);
                    if ((int)moduleHandle < 32) {
                        throw new Win32Exception(Marshal.GetLastWin32Error(), SR.GetString(SR.LoadDLLError,RichTextBoxConstants.DLL_RICHEDIT));
                    }
                }

                CreateParams cp = base.CreateParams;
                if (Marshal.SystemDefaultCharSize == 1)
                    cp.ClassName = RichTextBoxConstants.WC_RICHEDITA;
                else
                    cp.ClassName = RichTextBoxConstants.WC_RICHEDITW;

                if (Multiline) {
                    if (((int)scrollBars & RichTextBoxConstants.RTB_HORIZ) != 0 && !WordWrap) {
                        // RichEd infers word wrap from the absence of horizontal scroll bars
                        cp.Style |= NativeMethods.WS_HSCROLL;
                        if (((int)scrollBars & RichTextBoxConstants.RTB_FORCE) != 0)
                            cp.Style |= RichTextBoxConstants.ES_DISABLENOSCROLL;
                    }

                    if (((int)scrollBars & RichTextBoxConstants.RTB_VERT) != 0) {
                        cp.Style |= NativeMethods.WS_VSCROLL;
                        if (((int)scrollBars & RichTextBoxConstants.RTB_FORCE) != 0)
                            cp.Style |= RichTextBoxConstants.ES_DISABLENOSCROLL;
                    }
                }

                return cp;
            }
        }

        // public bool CanUndo {}; <-- inherited from TextBoxBase

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.DetectUrls"]/*' />
        /// <devdoc>
        ///     Controls whether or not the rich edit control will automatically highlight URLs.
        ///     By default, this is true. Note that changing this property will not update text that is
        ///     already present in the RichTextBox control; it only affects text which is entered after the
        ///     property is changed.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(true),
        SRDescription(SR.RichTextBoxDetectURLs)
        ]
        public bool DetectUrls {
            get {
                return autoUrlDetect;
            }
            set {
                if (autoUrlDetect != value) {
                    autoUrlDetect = value;
                    if (IsHandleCreated) {
                        this.SendMessage(RichTextBoxConstants.EM_AUTOURLDETECT, value ? 1 : 0, 0);

                        // We need to re-enter the text to make rich edit apply autodetect to existing text
                        if (IsHandleCreated) {
                            RepokeText();
                        }
                    }
                }
            }
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.DefaultSize"]/*' />
        protected override Size DefaultSize {
            get {
                return new Size(100, 96);
            }
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.ForeColor"]/*' />
        public override Color ForeColor {
            get {
                return base.ForeColor;
            }
            set {
                if (IsHandleCreated) {
                    if (InternalSetForeColor(value)) {
                        base.ForeColor = value;
                    }
                }
                else {
                    base.ForeColor = value;
                }
            }
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.Font"]/*' />
        public override Font Font {
            get {
                return base.Font;
            }
            set {
                if (IsHandleCreated) {
                    if (SafeNativeMethods.GetWindowTextLength(new HandleRef(window, window.Handle)) > 0) {
                        if (value == null) {
                            base.Font = null;
                            SetCharFormatFont(false, Font);
                        }
                        else {
                            try{
                                Font f = GetCharFormatFont(false);
                                if (f == null || !f.Equals (value)) {
                                    SetCharFormatFont(false, value);
                                    // update controlfont from "resolved" font from the attempt
                                    // to set the document font...
                                    //
                                    callOnContentsResized = true;
                                    base.Font = GetCharFormatFont(false);
                                }
                            }
                            finally{
                                callOnContentsResized = false;
                            }
                        }
                    }
                    else {
                        base.Font = value;
                    }
                }
                else {
                    base.Font = value;
                }
            }
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.MaxLength"]/*' />
        [
        DefaultValue(int.MaxValue),
        ]
        public override int MaxLength {
            get {
                return base.MaxLength;
            }
            set {
                base.MaxLength = value;
            }
        }
        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.Multiline"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [DefaultValue(true)]
        public override bool Multiline {
            get {
                return base.Multiline;
            }
            set {
                base.Multiline = value;
            }
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.RedoActionName"]/*' />
        /// <devdoc>
        ///     Returns the name of the action that will be performed if the user
        ///     Redo's their last Undone operation. If no operation can be redone,
        ///     an empty string ("") is returned.
        /// </devdoc>
        //NOTE: This is overridable, because we want people to be able to
        //      mess with the names if necessary...?
        [
        SRCategory(SR.CatBehavior),
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.RichTextBoxRedoActionNameDescr)
        ]
        public string RedoActionName {
            get {
                if (!CanRedo) return "";
                int n;
                n = (int)SendMessage(RichTextBoxConstants.EM_GETREDONAME, 0, 0);
                return GetEditorActionName(n);
            }
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.RightMargin"]/*' />
        /// <devdoc>
        ///     The right margin of a RichTextBox control.  A nonzero margin implies WordWrap.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(0),
        Localizable(true),
        SRDescription(SR.RichTextBoxRightMargin)
        ]
        public int RightMargin {
            get {
                return rightMargin;
            }
            set {
                if (this.rightMargin != value) {
                    if (value < 0)
                        throw new ArgumentException(SR.GetString(SR.InvalidLowBoundArgumentEx,
                                                                 "RightMargin", value.ToString(), "0"));
                    this.rightMargin = value;

                    if (value == 0) {
                        // Once you set EM_SETTARGETDEVICE to something nonzero, RichEd will assume
                        // word wrap forever and ever.
                        RecreateHandle();
                    }
                    else if (IsHandleCreated) {
                        IntPtr hDC = UnsafeNativeMethods.CreateIC("DISPLAY", null, null, 0);
                        try {
                            SendMessage(RichTextBoxConstants.EM_SETTARGETDEVICE, hDC, (IntPtr)Pixel2Twip(hDC, value, true));
                        }
                        finally {
                            if (hDC != IntPtr.Zero) {
                                UnsafeNativeMethods.DeleteDC(new HandleRef(null, hDC));
                            }
                        }
                    }
                }
            }
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.Rtf"]/*' />
        /// <devdoc>
        ///     The text of a RichTextBox control, including all Rtf codes.
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        DefaultValue(""),
        SRDescription(SR.RichTextBoxRTF)
        ]
        public string Rtf {
            get {
                if (IsHandleCreated)
                    return StreamOut(RichTextBoxConstants.SF_RTF);
                else
                    return textRtf;
            }
            set {
                if (value == null) value = "";

                if (value.Equals(Rtf))
                    return;

                ForceHandleCreate();
                textRtf = value;
                StreamIn(value, RichTextBoxConstants.SF_RTF);
                if (CanRaiseTextChangedEvent) {
                    OnTextChanged(EventArgs.Empty);
                }
            }
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.ScrollBars"]/*' />
        /// <devdoc>
        ///     The current scrollbar settings for a multi-line rich edit control.
        ///     Possible return values are given by the RichTextBoxScrollBars enumeration.
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        DefaultValue(RichTextBoxScrollBars.Both),
        Localizable(true),
        SRDescription(SR.RichTextBoxScrollBars)
        ]
        public RichTextBoxScrollBars ScrollBars {
            get {
                return scrollBars;
            }
            set {
                if (!Enum.IsDefined(typeof(RichTextBoxScrollBars), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(RichTextBoxScrollBars));
                }


                if (scrollBars != value) {
                    scrollBars = value;
                    if (IsHandleCreated) RecreateHandle();
                }
            }
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.SelectionAlignment"]/*' />
        /// <devdoc>
        ///     The alignment of the paragraphs in a RichTextBox control.
        /// </devdoc>
        [
        DefaultValue(HorizontalAlignment.Left),
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.RichTextBoxSelAlignment)
        ]
        public HorizontalAlignment SelectionAlignment {
            get {
                HorizontalAlignment selectionAlignment = HorizontalAlignment.Left;

                ForceHandleCreate();
                NativeMethods.PARAFORMAT pf = new NativeMethods.PARAFORMAT();
                pf.rgxTabs = new int[RichTextBoxConstants.MAX_TAB_STOPS];

                // get the format for our currently selected paragraph
                UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), RichTextBoxConstants.EM_GETPARAFORMAT, 0, pf);

                // check if alignment has been set yet
                if ((RichTextBoxConstants.PFM_ALIGNMENT & pf.dwMask) != 0) {
                    switch (pf.wAlignment) {
                        case RichTextBoxConstants.PFA_LEFT:
                            selectionAlignment = HorizontalAlignment.Left;
                            break;

                        case RichTextBoxConstants.PFA_RIGHT:
                            selectionAlignment = HorizontalAlignment.Right;
                            break;

                        case RichTextBoxConstants.PFA_CENTER:
                            selectionAlignment = HorizontalAlignment.Center;
                            break;
                    }
                }

                return selectionAlignment;
            }
            set {
                if (!Enum.IsDefined(typeof(HorizontalAlignment), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(HorizontalAlignment));
                }

                ForceHandleCreate();
                NativeMethods.PARAFORMAT pf = new NativeMethods.PARAFORMAT();
                pf.dwMask = RichTextBoxConstants.PFM_ALIGNMENT;
                switch (value) {
                    
                    case HorizontalAlignment.Left:
                        pf.wAlignment = RichTextBoxConstants.PFA_LEFT;
                        break;

                    case HorizontalAlignment.Right:
                        pf.wAlignment = RichTextBoxConstants.PFA_RIGHT;
                        break;

                    case HorizontalAlignment.Center:
                        pf.wAlignment = RichTextBoxConstants.PFA_CENTER;
                        break;
                }

                // set the format for our current paragraph or selection
                UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), RichTextBoxConstants.EM_SETPARAFORMAT, 0, pf);
            }
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.SelectionBullet"]/*' />
        /// <devdoc>
        ///     Determines if a paragraph in the RichTextBox control
        ///     contains the current selection or insertion point has the bullet style.
        /// </devdoc>
        [
        DefaultValue(false),
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.RichTextBoxSelBullet)
        ]
        public bool SelectionBullet {
            get {
                RichTextBoxSelectionAttribute selectionBullet = RichTextBoxSelectionAttribute.None;

                ForceHandleCreate();
                NativeMethods.PARAFORMAT pf = new NativeMethods.PARAFORMAT();
                pf.rgxTabs = new int[RichTextBoxConstants.MAX_TAB_STOPS];

                // get the format for our currently selected paragraph
                UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), RichTextBoxConstants.EM_GETPARAFORMAT, 0, pf);

                // check if alignment has been set yet
                if ((RichTextBoxConstants.PFM_NUMBERING & pf.dwMask) != 0) {
                    if (RichTextBoxConstants.PFN_BULLET == pf.wNumbering) {
                        selectionBullet = RichTextBoxSelectionAttribute.All;
                    }
                }
                else {
                    // For paragraphs with mixed SelectionBullets, we just return false
                    return false;
                }                  

                return selectionBullet == RichTextBoxSelectionAttribute.All;
            }
            set {
                ForceHandleCreate();

                NativeMethods.PARAFORMAT pf = new NativeMethods.PARAFORMAT();
                pf.dwMask = RichTextBoxConstants.PFM_NUMBERING | RichTextBoxConstants.PFM_OFFSET;

                if (!value) {
                    pf.wNumbering = 0;
                    pf.dxOffset = 0;
                }
                else {
                    pf.wNumbering = RichTextBoxConstants.PFN_BULLET;
                    pf.dxOffset = Pixel2Twip(IntPtr.Zero, bulletIndent, true);
                }
                // set the format for our current paragraph or selection
                UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), RichTextBoxConstants.EM_SETPARAFORMAT, 0, pf);
            }
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.SelectionCharOffset"]/*' />
        /// <devdoc>
        ///     Determines whether text in the RichTextBox control
        ///     appears on the baseline (normal), as a superscript above the baseline,
        ///     or as a subscript below the baseline.
        /// </devdoc>
        [
        DefaultValue(0),
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.RichTextBoxSelCharOffset)
        ]
        public int SelectionCharOffset {
            get {
                int selCharOffset = 0;

                ForceHandleCreate();
                NativeMethods.CHARFORMATA cf = GetCharFormat(true);
                // if the effects member contains valid info
                if ((cf.dwMask & RichTextBoxConstants.CFM_OFFSET) != 0) {
                    selCharOffset = cf.yOffset;
                }
                else {
                    // The selection contains characters of different offsets,
                    // so we just return the offset of the first character.
                    selCharOffset = cf.yOffset;
                }

                return Twip2Pixel(IntPtr.Zero,selCharOffset,false);
            }
            set {
                if (value > 2000 || value < -2000)
                    throw new ArgumentException(SR.GetString(SR.InvalidBoundArgument, "SelectionCharOffset", value, -2000, 2000));

                ForceHandleCreate();
                NativeMethods.CHARFORMATA cf = new NativeMethods.CHARFORMATA();
                cf.dwMask = RichTextBoxConstants.CFM_OFFSET;
                cf.yOffset = Pixel2Twip(IntPtr.Zero, value, false);

                // Set the format information
                // SendMessage will force the handle to be created if it hasn't already. Normally,
                // we would cache property values until the handle is created - but for this property,
                // it's far more simple to just create the handle.
                //
                UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), RichTextBoxConstants.EM_SETCHARFORMAT, RichTextBoxConstants.SCF_SELECTION, cf);
            }
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.SelectionColor"]/*' />
        /// <devdoc>
        ///     The color of the currently selected text in the
        ///     RichTextBox control.
        ///     Returns Color.Empty if the selection has more than one color.
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.RichTextBoxSelColor)
        ]
        public Color SelectionColor {
            get {
                Color selColor = Color.Empty;

                ForceHandleCreate();
                NativeMethods.CHARFORMATA cf = GetCharFormat(true);
                // if the effects member contains valid info
                if ((cf.dwMask & RichTextBoxConstants.CFM_COLOR) != 0)
                    selColor = ColorTranslator.FromOle(cf.crTextColor);

                return selColor;
            }
            set {
                ForceHandleCreate();
                NativeMethods.CHARFORMATA cf = GetCharFormat(true);
                cf.dwMask = RichTextBoxConstants.CFM_COLOR;
                cf.dwEffects = 0;
                cf.crTextColor = ColorTranslator.ToWin32(value);

                // set the format information
                UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), RichTextBoxConstants.EM_SETCHARFORMAT, RichTextBoxConstants.SCF_SELECTION, cf);
            }
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.SelectionFont"]/*' />
        /// <devdoc>
        ///     The font used to display the currently selected text
        ///     or the characters(s) immediately following the insertion point in the
        ///     RichTextBox control.  Null if the selection has more than one font.
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.RichTextBoxSelFont)
        ]
        public Font SelectionFont {
            get {
                return GetCharFormatFont(true);
            }
            set {
                SetCharFormatFont(true, value);
            }
        }


        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.SelectionHangingIndent"]/*' />
        /// <devdoc>
        ///     The distance (in pixels) between the left edge of the first line of text
        ///     in the selected paragraph(s) (as specified by the SelectionIndent property)
        ///     and the left edge of subsequent lines of text in the same paragraph(s).
        /// </devdoc>
        [
        DefaultValue(0),
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.RichTextBoxSelHangingIndent)
        ]
        public int SelectionHangingIndent {
            get {
                int selHangingIndent = 0;

                ForceHandleCreate();
                NativeMethods.PARAFORMAT pf = new NativeMethods.PARAFORMAT();
                pf.rgxTabs = new int[RichTextBoxConstants.MAX_TAB_STOPS];

                // get the format for our currently selected paragraph
                UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), RichTextBoxConstants.EM_GETPARAFORMAT, 0, pf);

                // check if alignment has been set yet
                if ((RichTextBoxConstants.PFM_OFFSET & pf.dwMask) != 0)
                    selHangingIndent = pf.dxOffset;

                return Twip2Pixel(IntPtr.Zero, selHangingIndent, true);
            }
            set {
                ForceHandleCreate();

                NativeMethods.PARAFORMAT pf = new NativeMethods.PARAFORMAT();
                pf.dwMask = RichTextBoxConstants.PFM_OFFSET;
                pf.dxOffset = Pixel2Twip(IntPtr.Zero, value, true);

                // set the format for our current paragraph or selection
                UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), RichTextBoxConstants.EM_SETPARAFORMAT, 0, pf);
            }
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.SelectionIndent"]/*' />
        /// <devdoc>
        ///     The distance (in pixels) between the left edge of the RichTextBox control and
        ///     the left edge of the text that is selected or added at the current
        ///     insertion point.
        /// </devdoc>
        [
        DefaultValue(0),
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.RichTextBoxSelIndent)
        ]
        public int SelectionIndent {
            get {
                int selIndent = 0;

                ForceHandleCreate();
                NativeMethods.PARAFORMAT pf = new NativeMethods.PARAFORMAT();
                pf.rgxTabs = new int[RichTextBoxConstants.MAX_TAB_STOPS];

                // get the format for our currently selected paragraph
                UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), RichTextBoxConstants.EM_GETPARAFORMAT, 0, pf);

                // check if alignment has been set yet
                if ((RichTextBoxConstants.PFM_STARTINDENT & pf.dwMask) != 0)
                    selIndent = pf.dxStartIndent;

                return Twip2Pixel(IntPtr.Zero, selIndent, true);
            }
            set {
                ForceHandleCreate();

                NativeMethods.PARAFORMAT pf = new NativeMethods.PARAFORMAT();
                pf.dwMask = RichTextBoxConstants.PFM_STARTINDENT;
                pf.dxStartIndent = Pixel2Twip(IntPtr.Zero, value, true);

                // set the format for our current paragraph or selection
                UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), RichTextBoxConstants.EM_SETPARAFORMAT, 0, pf);
            }
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.SelectionLength"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the number of characters selected in the text
        ///       box.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.TextBoxSelectionLengthDescr)
        ]
        public override int SelectionLength {
            get {

                if (!IsHandleCreated) {
                    return base.SelectionLength;
                }

                // RichTextBox allows the user to select the EOF character,
                // but we don't want to include this in the SelectionLength.
                // So instead of sending EM_GETSEL, we just obtain the SelectedText and return
                // the length of it.
                //
                return SelectedText.Length;
            }

            set {
                base.SelectionLength = value;
            }
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.SelectionProtected"]/*' />
        /// <devdoc>
        ///     true if the current selection prevents any changes to its contents.
        /// </devdoc>
        [
        DefaultValue(false),
        SRDescription(SR.RichTextBoxSelProtected),
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public bool SelectionProtected {
            get {
                ForceHandleCreate();
                return GetCharFormat(RichTextBoxConstants.CFM_PROTECTED, RichTextBoxConstants.CFM_PROTECTED) == RichTextBoxSelectionAttribute.All;
            }
            set {
                ForceHandleCreate();
                SetCharFormat(RichTextBoxConstants.CFM_PROTECTED, value ? RichTextBoxConstants.CFE_PROTECTED : 0, RichTextBoxSelectionAttribute.All);
            }
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.SelectedRtf"]/*' />
        /// <devdoc>
        ///     The currently selected text of a RichTextBox control, including
        ///     all Rtf codes.
        /// </devdoc>
        [
        DefaultValue(""),
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.RichTextBoxSelRTF)
        ]
        public string SelectedRtf {
            get {
                ForceHandleCreate();
                return StreamOut(RichTextBoxConstants.SFF_SELECTION | RichTextBoxConstants.SF_RTF);
            }
            set {
                ForceHandleCreate();
                if (value == null) value = "";
                StreamIn(value, RichTextBoxConstants.SFF_SELECTION | RichTextBoxConstants.SF_RTF);
            }
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.SelectionRightIndent"]/*' />
        /// <devdoc>
        ///     The distance (in pixels) between the right edge of the RichTextBox control and
        ///     the right edge of the text that is selected or added at the current
        ///     insertion point.
        /// </devdoc>
        [
        DefaultValue(0),
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.RichTextBoxSelRightIndent)
        ]
        public int SelectionRightIndent {
            get {
                int selRightIndent = 0;

                ForceHandleCreate();

                NativeMethods.PARAFORMAT pf = new NativeMethods.PARAFORMAT();
                pf.rgxTabs = new int[RichTextBoxConstants.MAX_TAB_STOPS];

                // get the format for our currently selected paragraph
                UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), RichTextBoxConstants.EM_GETPARAFORMAT, 0, pf);

                // check if alignment has been set yet
                if ((RichTextBoxConstants.PFM_RIGHTINDENT & pf.dwMask) != 0)
                    selRightIndent = pf.dxRightIndent;

                return Twip2Pixel(IntPtr.Zero, selRightIndent, true);
            }
            set {
                if (value < 0)
                    throw new ArgumentException(SR.GetString(SR.InvalidLowBoundArgumentEx, "SelectionRightIndent", value, 0));

                ForceHandleCreate();
                NativeMethods.PARAFORMAT pf = new NativeMethods.PARAFORMAT();
                pf.dwMask = RichTextBoxConstants.PFM_RIGHTINDENT;
                pf.dxRightIndent = Pixel2Twip(IntPtr.Zero, value, true);

                // set the format for our current paragraph or selection
                UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), RichTextBoxConstants.EM_SETPARAFORMAT, 0, pf);
            }
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.SelectionTabs"]/*' />
        /// <devdoc>
        ///     The absolute tab positions (in pixels) of text in a RichTextBox control.
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.RichTextBoxSelTabs)
        ]
        public int[] SelectionTabs {
            get {
                int[] selTabs = new int[0];

                ForceHandleCreate();
                NativeMethods.PARAFORMAT pf = new NativeMethods.PARAFORMAT();
                pf.rgxTabs = new int[RichTextBoxConstants.MAX_TAB_STOPS];

                // get the format for our currently selected paragraph
                UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), RichTextBoxConstants.EM_GETPARAFORMAT, 0, pf);

                // check if alignment has been set yet
                if ((RichTextBoxConstants.PFM_TABSTOPS & pf.dwMask) != 0) {
                    selTabs = new int[pf.cTabCount];
                    for (int x = 0; x < pf.cTabCount; x++)
                        selTabs[x] = Twip2Pixel(IntPtr.Zero, pf.rgxTabs[x], true);
                }

                return selTabs;
            }
            set {
                // Verify the argument, and throw an error if is bad
                if (value != null && (value.Length < 0 || value.Length > RichTextBoxConstants.MAX_TAB_STOPS))
                    throw new ArgumentException(SR.GetString(SR.SelTabCountRange));

                ForceHandleCreate();
                NativeMethods.PARAFORMAT pf = new NativeMethods.PARAFORMAT();
                pf.rgxTabs = new int[RichTextBoxConstants.MAX_TAB_STOPS];

                // get the format for our currently selected paragraph because
                // we need to get the number of tabstops to copy
                UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), RichTextBoxConstants.EM_GETPARAFORMAT, 0, pf);

                pf.cTabCount = (short)((value == null) ? 0 : value.Length);
                pf.dwMask = RichTextBoxConstants.PFM_TABSTOPS;
                for (int x = 0; x < pf.cTabCount; x++)
                    pf.rgxTabs[x] = Pixel2Twip(IntPtr.Zero, value[x], true);

                // set the format for our current paragraph or selection
                UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), RichTextBoxConstants.EM_SETPARAFORMAT, 0, pf);
            }
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.SelectedText"]/*' />
        /// <devdoc>
        ///     The currently selected text of a RichTextBox control; consists of a
        ///     zero length string if no characters are selected.
        /// </devdoc>
        [
        DefaultValue(""),
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.RichTextBoxSelText)
        ]
        public override string SelectedText {
            get {
                ForceHandleCreate();

                String text = StreamOut(RichTextBoxConstants.SFF_SELECTION | RichTextBoxConstants.SF_TEXT | RichTextBoxConstants.SF_UNICODE);
                return text;
            }
            set {
                ForceHandleCreate();
                StreamIn(value, RichTextBoxConstants.SFF_SELECTION | RichTextBoxConstants.SF_TEXT | RichTextBoxConstants.SF_UNICODE);
            }
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.SelectionType"]/*' />
        /// <devdoc>
        ///     The type of the current selection. The returned value is one
        ///     of the values enumerated in RichTextBoxSelectionType.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.RichTextBoxSelTypeDescr)
        ]
        public RichTextBoxSelectionTypes SelectionType {
            get {
                ForceHandleCreate();
                if (SelectionLength > 0) {
                    int n;
                    n =  (int)SendMessage(RichTextBoxConstants.EM_SELECTIONTYPE, 0, 0);
                    return (RichTextBoxSelectionTypes)n;
                }
                else {
                    return RichTextBoxSelectionTypes.Empty;
                }
            }
        }

        // Don't SetSelectionOnHandle inside CreateHandle() -- do that in OnHandleCreated
        internal override bool SetSelectionInCreateHandle {
            get {
                return false;
            }
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.ShowSelectionMargin"]/*' />
        /// <devdoc>
        ///     Whether or not the left edge of the control will have a "selection margin" which
        ///     can be used to select entire lines
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(false),
        SRDescription(SR.RichTextBoxSelMargin)
        ]
        public bool ShowSelectionMargin {
            get {
                return showSelBar;
            }
            set {
                if (showSelBar != value) {
                    showSelBar = value;
                    if (IsHandleCreated) {
                        SendMessage(RichTextBoxConstants.EM_SETOPTIONS,
                            showSelBar ? RichTextBoxConstants.ECOOP_OR :
                            RichTextBoxConstants.ECOOP_XOR,
                            RichTextBoxConstants.ECO_SELECTIONBAR);
                    }
                }
            }
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.Text"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        Localizable(true)
        ]
        public override string Text {
            get {
                if (IsDisposed) {
                    return base.Text;
                }

                if (RecreatingHandle || GetAnyDisposingInHierarchy()) {
                    // We can return any old garbage if we're in the process of recreating the handle
                    return "";
                }

                if (!IsHandleCreated && textRtf == null) {
                    if (textPlain != null) {
                        return textPlain;
                    }
                    else {
                        return "";
                    }
                }
                else {
                    // if the handle is created, we are golden, however
                    // if the handle isn't created, but textRtf was 
                    // specified, we need the RichEdit to translate
                    // for us, so we must create the handle;
                    //
                    ForceHandleCreate();

                    return StreamOut(RichTextBoxConstants.SF_TEXT | RichTextBoxConstants.SF_UNICODE);
                }
            }
            set {
                textRtf = null;
                if (!IsHandleCreated) {
                    textPlain = value;
                }
                else {
                    textPlain = null;
                    if (value == null) {
                        value = "";
                    }
                    StreamIn(value, RichTextBoxConstants.SF_TEXT | RichTextBoxConstants.SF_UNICODE);
                    // reset Modified
                    SendMessage(NativeMethods.EM_SETMODIFY, 0, 0);
                }
            }
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.TextLength"]/*' />
        [Browsable(false)]
        public override int TextLength {
            get {
                return Text.Length;
            }
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.UndoActionName"]/*' />
        /// <devdoc>
        ///     Returns the name of the action that will be undone if the user
        ///     Undo's their last operation. If no operation can be undone, it will
        ///     return an empty string ("").
        /// </devdoc>
        //NOTE: This is overridable, because we want people to be able to
        //      mess with the names if necessary...?
        [
        SRCategory(SR.CatBehavior),
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.RichTextBoxUndoActionNameDescr)
        ]
        public string UndoActionName {
            get {
                if (!CanUndo) return "";
                int n;
                n = (int) SendMessage(RichTextBoxConstants.EM_GETUNDONAME, 0, 0);
                return GetEditorActionName(n);
            }
        }

        private string GetEditorActionName(int actionID) {
            switch (actionID) {
                case 0:
                    return SR.GetString(SR.RichTextBox_IDUnknown);
                case 1:
                    return SR.GetString(SR.RichTextBox_IDTyping);
                case 2:
                    return SR.GetString(SR.RichTextBox_IDDelete);
                case 3:
                    return SR.GetString(SR.RichTextBox_IDDragDrop);
                case 4:
                    return SR.GetString(SR.RichTextBox_IDCut);
                case 5:
                    return SR.GetString(SR.RichTextBox_IDPaste);
                default:
                    goto
                case 0;
            }
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.ZoomFactor"]/*' />
        /// <devdoc>
        ///     The current zoom level for the RichTextBox control. This may be between 1/64 and 64. 1.0 indicates
        ///     no zoom (i.e. normal viewing).  Zoom works best with TrueType fonts;
        ///     for non-TrueType fonts, ZoomFactor will be treated as the nearest whole number.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(1.0f),
        Localizable(true),
        SRDescription(SR.RichTextBoxZoomFactor)
        ]
        public float ZoomFactor {
            get {
                if (IsHandleCreated) {
                    short numerator = 0;
                    short denominator = 0;
                    SendMessage(RichTextBoxConstants.EM_GETZOOM, ref numerator, ref denominator);
                    if ( (numerator != 0) && (denominator != 0) ) {
                        zoomMultiplier = ((float)numerator)/((float)denominator);                        
                    }
                    else {
                        zoomMultiplier = 1.0f;
                    }
                    return zoomMultiplier;
                }
                else return zoomMultiplier;
            }

            set {
                if (zoomMultiplier == value) return;

                if (value <= 0.015625f || value >= 64.0f)
                    throw new ArgumentException(SR.GetString(SR.InvalidExBoundArgument,
                                                             "ZoomFactor", (value).ToString(),
                                                             (0.015625f).ToString(), (64.0f).ToString()));
                SendZoomFactor(value);
            }
        }


        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.ContentsResized"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatBehavior), SRDescription(SR.RichTextBoxContentsResized)]
        public event ContentsResizedEventHandler ContentsResized {
            add {
                Events.AddHandler(EVENT_REQUESTRESIZE, value);
            }
            remove {
                Events.RemoveHandler(EVENT_REQUESTRESIZE, value);
            }
        }        


        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.DoubleClick"]/*' />
        /// <internalonly/><hideinheritance/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event EventHandler DoubleClick {
            add {
                base.DoubleClick += value;
            }
            remove {
                base.DoubleClick -= value;
            }
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.DragDrop"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event DragEventHandler DragDrop {
            add {
                base.DragDrop += value;
            }
            remove {
                base.DragDrop -= value;
            }
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.DragEnter"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event DragEventHandler DragEnter {
            add {
                base.DragEnter += value;
            }
            remove {
                base.DragEnter -= value;
            }
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.DragLeave"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event EventHandler DragLeave {
            add {
                base.DragLeave += value;
            }
            remove {
                base.DragLeave -= value;
            }
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.DragOver"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event DragEventHandler DragOver {
            add {
                base.DragOver += value;
            }
            remove {
                base.DragOver -= value;
            }
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.GiveFeedback"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event GiveFeedbackEventHandler GiveFeedback {
            add {
                base.GiveFeedback += value;
            }
            remove {
                base.GiveFeedback -= value;
            }
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.QueryContinueDrag"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event QueryContinueDragEventHandler QueryContinueDrag {
            add {
                base.QueryContinueDrag += value;
            }
            remove {
                base.QueryContinueDrag -= value;
            }
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.HScroll"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatBehavior), SRDescription(SR.RichTextBoxHScroll)]
        public event EventHandler HScroll {
            add {
                Events.AddHandler(EVENT_HSCROLL, value);
            }
            remove {
                Events.RemoveHandler(EVENT_HSCROLL, value);
            }
        }        


        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.LinkClicked"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatBehavior), SRDescription(SR.RichTextBoxLinkClick)]
        public event LinkClickedEventHandler LinkClicked {
            add {
                Events.AddHandler(EVENT_LINKACTIVATE, value);
            }
            remove {
                Events.RemoveHandler(EVENT_LINKACTIVATE, value);
            }
        }        


        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.ImeChange"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatBehavior), SRDescription(SR.RichTextBoxIMEChange)]
        public event EventHandler ImeChange {
            add {
                Events.AddHandler(EVENT_IMECHANGE, value);
            }
            remove {
                Events.RemoveHandler(EVENT_IMECHANGE, value);
            }
        }        


        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.Protected"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatBehavior), SRDescription(SR.RichTextBoxProtected)]
        public event EventHandler Protected {
            add {
                Events.AddHandler(EVENT_PROTECTED, value);
            }
            remove {
                Events.RemoveHandler(EVENT_PROTECTED, value);
            }
        }        


        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.SelectionChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatBehavior), SRDescription(SR.RichTextBoxSelChange)]
        public event EventHandler SelectionChanged {
            add {
                Events.AddHandler(EVENT_SELCHANGE, value);
            }
            remove {
                Events.RemoveHandler(EVENT_SELCHANGE, value);
            }
        }        


        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.VScroll"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatBehavior), SRDescription(SR.RichTextBoxVScroll)]
        public event EventHandler VScroll {
            add {
                Events.AddHandler(EVENT_VSCROLL, value);
            }
            remove {
                Events.RemoveHandler(EVENT_VSCROLL, value);
            }
        }        

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.CanPaste"]/*' />
        /// <devdoc>
        ///     Returns a boolean indicating whether the RichTextBoxConstants control can paste the
        ///     given clipboard format.
        /// </devdoc>
        public bool CanPaste(DataFormats.Format clipFormat) {
            bool b = false;
            b = (int)SendMessage(RichTextBoxConstants.EM_CANPASTE, clipFormat.Id, 0) != 0;

            return b;
        }
        
        private unsafe int EditStreamProc(IntPtr dwCookie, IntPtr buf, int cb, out int transferred) {
            int ret = 0;    // assume that everything is Okay

            byte[] bytes = new byte[cb];

            transferred = 0;
            try {
                switch ((int)dwCookie & DIRECTIONMASK) {
                    case RichTextBox.OUTPUT: {
                        Debug.Assert(editStream != null, "output stream null in callback");
                        switch ((int)dwCookie & KINDMASK) {
                            case RichTextBox.RTF:
                            case RichTextBox.TEXTCRLF:
                                Marshal.Copy(buf, bytes, 0, cb);
                                editStream.Write(bytes, 0, cb);
                                break;
                            case RichTextBox.TEXTLF:
                                // Strip out \r characters so that we consistently return
                                // \n for linefeeds. In a future version the RichEdit control
                                // may support a SF_NOXLATCRLF flag which would do this for
                                // us. Internally the RichEdit stores the text with only
                                // a \n, so we want to keep that the same here.
                                //
                                if (((int)dwCookie & UNICODE) != 0) {
                                    Debug.Assert(cb % 2 == 0, "EditStreamProc call out of cycle. Expected to always get character boundary calls");
                                    int requestedCharCount = cb/2;
                                    int consumedCharCount = 0;
    
                                    fixed (byte* pb = bytes) {
                                        char* pChars = (char*)pb;
                                        char* pBuffer = (char*)(long)buf;
    
                                        for (int i=0; i<requestedCharCount; i++) {
                                            if (*pBuffer == '\r') {
                                                pBuffer++;
                                                continue;
                                            }
                                            *pChars = *pBuffer;
                                            pChars++;
                                            pBuffer++;
                                            consumedCharCount++;
                                        }
                                    }
                                    editStream.Write(bytes, 0, consumedCharCount * 2);
                                }
                                else {
                                    int requestedCharCount = cb;
                                    int consumedCharCount = 0;
    
                                    fixed (byte* pb = bytes) {
                                        byte* pChars = (byte*)pb;
                                        byte* pBuffer = (byte*)(long)buf;
    
                                        for (int i=0; i<requestedCharCount; i++) {
                                            if (*pBuffer == (byte)'\r') {
                                                pBuffer++;
                                                continue;
                                            }
                                            *pChars = *pBuffer;
                                            pChars++;
                                            pBuffer++;
                                            consumedCharCount++;
                                        }
                                    }
                                    editStream.Write(bytes, 0, consumedCharCount);
                                }
                                break;
                        }

                        // set up number of bytes transferred
                        transferred = cb;
                        break;
                    }

                    case RichTextBox.INPUT: {
                        Debug.Assert(editStream != null, "input stream null in callback");
                        transferred = editStream.Read(bytes, 0, cb);
                        Marshal.Copy(bytes, 0, buf, transferred);

                        // set up number of bytes transferred
                        if (transferred < 0) transferred = 0;

                        break;
                    }
                }
            }
#if DEBUG
            catch (IOException e) {
                Debug.Fail("Failed to edit proc operation.", e.ToString());
                transferred = 0;
                ret = 1;
            }
#else
            catch (IOException) {
                transferred = 0;
                ret = 1;
            }
#endif

            return ret;       // tell the RichTextBoxConstants how we are doing 0 - Okay, 1 - quit
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.Find"]/*' />
        /// <devdoc>
        ///     Searches the text in a RichTextBox control for a given string.
        /// </devdoc>
        public int Find(string str) {
            return Find(str, 0, 0, RichTextBoxFinds.None);
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.Find1"]/*' />
        /// <devdoc>
        ///     Searches the text in a RichTextBox control for a given string.
        /// </devdoc>
        public int Find(string str, RichTextBoxFinds options) {
            return Find(str, 0, 0, options);
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.Find2"]/*' />
        /// <devdoc>
        ///     Searches the text in a RichTextBox control for a given string.
        /// </devdoc>
        public int Find(string str, int start, RichTextBoxFinds options) {
            return Find(str, start, -1, options);
        }                                   

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.Find3"]/*' />
        /// <devdoc>
        ///     Searches the text in a RichTextBox control for a given string.
        /// </devdoc>
        public int Find(string str, int start, int end, RichTextBoxFinds options) {

            int textLen = TextLength;

            if (str == null)
                throw new ArgumentNullException("str");
            if (start < 0 || start > textLen)
                throw new ArgumentException(SR.GetString(SR.InvalidBoundArgument, "start", start, 0, textLen));
            if (end < -1)
                throw new ArgumentException(SR.GetString(SR.RichTextFindEndInvalid, end));

            bool selectWord = true;
            NativeMethods.FINDTEXT ft = new NativeMethods.FINDTEXT();
            ft.chrg = new NativeMethods.CHARRANGE();

            // set up the default values for the FINDTEXT structure, that is
            // the given string and the whole range of the text stream
            ft.lpstrText = str;
            if (end == -1) {
                end = textLen;
            }

            if (start > end) {
                throw new ArgumentException(SR.GetString(SR.RichTextFindEndInvalid, end));
            }

            if ((options & RichTextBoxFinds.Reverse) != RichTextBoxFinds.Reverse) {
                // normal
                //
                ft.chrg.cpMin = start;
                ft.chrg.cpMax = end;
            }
            else {
                // reverse
                //
                ft.chrg.cpMin = end;
                ft.chrg.cpMax = start;
            }

            // force complete search if we ended up with a zero length search
            if (ft.chrg.cpMin == ft.chrg.cpMax) {
                if ((options & RichTextBoxFinds.Reverse) != RichTextBoxFinds.Reverse) {
                    ft.chrg.cpMin = 0;
                    ft.chrg.cpMax = -1;
                }
                else {
                    ft.chrg.cpMin = textLen;
                    ft.chrg.cpMax = 0;
                }
            }

            // set up the options for the search
            int findOptions = 0;
            if ((options & RichTextBoxFinds.WholeWord) == RichTextBoxFinds.WholeWord)
                findOptions |= RichTextBoxConstants.FR_WHOLEWORD;
            if ((options & RichTextBoxFinds.MatchCase) == RichTextBoxFinds.MatchCase)
                findOptions |= RichTextBoxConstants.FR_MATCHCASE;
            if ((options & RichTextBoxFinds.NoHighlight) == RichTextBoxFinds.NoHighlight)
                selectWord = false;
            if ((options & RichTextBoxFinds.Reverse) != RichTextBoxFinds.Reverse) {
                // The default for RichEdit 2.0 is to search in reverse
                findOptions |= RichTextBoxConstants.FR_DOWN;
            }

            // Perform the find, will return ubyte position
            int position;

            position = (int)UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), RichTextBoxConstants.EM_FINDTEXT, findOptions, ft);

            // if we didn't find anything, or we don't have to select what was found,
            // we're done
            if (position != -1 && selectWord) {
                // Select the string found, this is done in ubyte units
                NativeMethods.CHARRANGE chrg = new NativeMethods.CHARRANGE();
                chrg.cpMin = position;
                chrg.cpMax = position + str.Length;
                UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), RichTextBoxConstants.EM_EXSETSEL, 0, chrg);
                SendMessage(NativeMethods.EM_SCROLLCARET, 0, 0);

            }

            return position;
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.Find4"]/*' />
        /// <devdoc>
        ///     Searches the text in a RichTextBox control for the giving characters.
        /// </devdoc>
        public int Find(char[] characterSet) {
            return Find(characterSet, 0, -1);
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.Find5"]/*' />
        /// <devdoc>
        ///     Searches the text in a RichTextBox control for the giving characters.
        /// </devdoc>
        public int Find(char[] characterSet, int start) {
            return Find(characterSet, start, -1);
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.Find6"]/*' />
        /// <devdoc>
        ///     Searches the text in a RichTextBox control for the giving characters.
        /// </devdoc>
        public int Find(char[] characterSet, int start, int end) {
            // Code used to support ability to search backwards and negate character sets.
            // The API no longer supports this, but in case we change our mind, I'm leaving
            // the ability in here.
            bool forward = true;
            bool negate = false;

            int textLength = TextLength;

            if (characterSet == null)
                throw new ArgumentNullException("characterSet");
            if (start < 0 || start > textLength)
                throw new ArgumentException(SR.GetString(SR.InvalidBoundArgument, "start", start, 0, textLength));
            if (end < start && end != -1)
                throw new ArgumentException(SR.GetString(SR.InvalidLowBoundArgumentEx, "end", end, "start"));

            // Don't do anything if we get nothing to look for
            if (characterSet.Length == 0)
                return -1;

            int textLen = SafeNativeMethods.GetWindowTextLength(new HandleRef(this, Handle));
            if (start == end) {
                start = 0;
                end = textLen;
            }
            if (end == -1) {
                end = textLen;
            }

            NativeMethods.CHARRANGE chrg = new NativeMethods.CHARRANGE(); // The range of characters we have searched
            chrg.cpMax = chrg.cpMin = start;

            // Use the TEXTRANGE to move our text buffer forward
            // or backwards within the main text
            NativeMethods.TEXTRANGE txrg = new NativeMethods.TEXTRANGE(); // Characters we have slurped into memory in order to search
            txrg.chrg = new NativeMethods.CHARRANGE();

            txrg.chrg.cpMin = chrg.cpMin;
            txrg.chrg.cpMax = chrg.cpMax;
            NativeMethods.CharBuffer charBuffer;
            charBuffer = NativeMethods.CharBuffer.CreateBuffer(CHAR_BUFFER_LEN+1);
            
            txrg.lpstrText = charBuffer.AllocCoTaskMem();
            if (txrg.lpstrText == IntPtr.Zero)
                throw new OutOfMemoryException();

            try {
                bool done = false;

                // We want to loop as long as it takes.  This loop will grab a
                // chunk of text out from the control as directed by txrg.chrg;
                while (!done) {
                    if (forward) {
                        // Move forward by starting at the end of the
                        // previous text window and extending by the
                        // size of our buffer
                        txrg.chrg.cpMin = chrg.cpMax;
                        txrg.chrg.cpMax += CHAR_BUFFER_LEN;
                    }
                    else {
                        // Move backwards by anchoring at the start
                        // of the previous buffer window, and backing
                        // up by the desired size of our buffer
                        txrg.chrg.cpMax = chrg.cpMin;
                        txrg.chrg.cpMin -= CHAR_BUFFER_LEN;

                        // We need to keep our request within the
                        // lower bound of zero
                        if (txrg.chrg.cpMin < 0)
                            txrg.chrg.cpMin = 0;
                    }

                    if (end != -1)
                        txrg.chrg.cpMax = Math.Min(txrg.chrg.cpMax, end);

                    // go get the text in this range, if we didn't get any text then punt
                    int len;
                    len = (int)UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), RichTextBoxConstants.EM_GETTEXTRANGE, 0, txrg);
                    if (len == 0) {
                        chrg.cpMax = chrg.cpMin = -1; // Hit end of control without finding what we wanted
                        break;
                    }

                    // get the data from RichTextBoxConstants into a string for us to use.
                    charBuffer.PutCoTaskMem(txrg.lpstrText);
                    string str = charBuffer.GetString();
                    
                    // Loop through our text
                    if (forward) {
                        // Start at the begining of the buffer
                        for (int x = 0; x < len; x++) {
                            // Is it in char set?
                            bool found = GetCharInCharSet(str[x], characterSet, negate);

                            if (found) {
                                done = true;
                                break;
                            }

                            // Advance the buffer
                            chrg.cpMax++;
                        }
                    }
                    else { // Span reverse.
                        int x = len;
                        while (x-- != 0) {
                            // Is it in char set?
                            bool found = GetCharInCharSet(str[x], characterSet, negate);

                            if (found) {
                                done = true;
                                break;
                            }

                            // Bring the selection back while keeping it anchored
                            chrg.cpMin--;
                        }
                    }
                }
            }
            finally {
                // release the resources we got for our GETTEXTRANGE operation.
                if (txrg.lpstrText != IntPtr.Zero) Marshal.FreeCoTaskMem(txrg.lpstrText);
            }

            int index = (forward) ? chrg.cpMax : chrg.cpMin;
            return index;
        }

        void ForceHandleCreate() {
            IntPtr ignored = Handle;
        }

        // Sends set color message to HWND; doesn't call Control.SetForeColor
        private bool InternalSetForeColor(Color value) {
            NativeMethods.CHARFORMATA cf = GetCharFormat(false);
            if ((cf.dwMask & RichTextBoxConstants.CFM_COLOR) != 0 
                && ColorTranslator.ToWin32(value) == cf.crTextColor) {

                return true;
            }

            cf.dwMask = RichTextBoxConstants.CFM_COLOR;
            cf.dwEffects = 0;
            cf.crTextColor = ColorTranslator.ToWin32(value);
            return SetCharFormat(RichTextBoxConstants.SCF_ALL, cf);
        }

        private void RaiseEvent(object key, ContentsResizedEventArgs e) {
            ContentsResizedEventHandler handler = (ContentsResizedEventHandler)Events[key];
            if (handler != null) handler(this, e);
        }

        private void RaiseEvent(object key, LinkClickedEventArgs e) {
            LinkClickedEventHandler handler = (LinkClickedEventHandler)Events[key];
            if (handler != null) handler(this, e);
        }


        private NativeMethods.CHARFORMATA GetCharFormat(bool fSelection) {
            NativeMethods.CHARFORMATA cf = new NativeMethods.CHARFORMATA();
            UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), RichTextBoxConstants.EM_GETCHARFORMAT, fSelection ? -1 : 0, cf);
            return cf;
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.GetCharFormat"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        private RichTextBoxSelectionAttribute GetCharFormat(int mask, int effect) {
            RichTextBoxSelectionAttribute charFormat = RichTextBoxSelectionAttribute.None;

            // check to see if the control has been created
            if (IsHandleCreated) {
                NativeMethods.CHARFORMATA cf = GetCharFormat(true);
                // if the effects member contains valid info
                if ((cf.dwMask & mask) != 0)
                    // if the text has the desired effect
                    if ((cf.dwEffects & effect) != 0)
                        charFormat = RichTextBoxSelectionAttribute.All;
            }

            return charFormat;
        }

        Font GetCharFormatFont(bool selectionOnly) {
            ForceHandleCreate();

            NativeMethods.CHARFORMATA cf = GetCharFormat(selectionOnly);
            if ((cf.dwMask & RichTextBoxConstants.CFM_FACE) == 0) {
                return null;
            }

            string fontName = Encoding.Default.GetString(cf.szFaceName);
            int index = fontName.IndexOf('\0');
            if (index != -1) {
                fontName = fontName.Substring(0, index);
            }

            float fontSize = 13;
            if ((cf.dwMask & RichTextBoxConstants.CFM_SIZE) != 0) {
                fontSize = (float)cf.yHeight/(float)20.0;
                if (fontSize == 0 && cf.yHeight > 0) {
                    fontSize = 1;
                }
            }

            FontStyle style = FontStyle.Regular;
            if ((cf.dwMask & RichTextBoxConstants.CFM_BOLD) != 0 && (cf.dwEffects & RichTextBoxConstants.CFE_BOLD) != 0)
                style |= FontStyle.Bold;
            if ((cf.dwMask & RichTextBoxConstants.CFM_ITALIC) != 0 && (cf.dwEffects & RichTextBoxConstants.CFE_ITALIC) != 0)
                style |= FontStyle.Italic;
            if ((cf.dwMask & RichTextBoxConstants.CFM_STRIKEOUT) != 0 && (cf.dwEffects & RichTextBoxConstants.CFE_STRIKEOUT) != 0)
                style |= FontStyle.Strikeout;
            if ((cf.dwMask & RichTextBoxConstants.CFM_UNDERLINE) != 0 && (cf.dwEffects & RichTextBoxConstants.CFE_UNDERLINE) != 0)
                style |= FontStyle.Underline;

            try {
                return new Font(fontName, fontSize, style, GraphicsUnit.Point, cf.bCharSet);
            }
            catch {
            }

            return null;
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.GetCharFromPosition"]/*' />
        /// <devdoc>
        ///     Returns the character nearest to the given point.
        /// </devdoc>
        public char GetCharFromPosition(Point pt) {
            return Text[GetCharIndexFromPosition(pt)];
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.GetCharIndexFromPosition"]/*' />
        /// <devdoc>
        ///     Returns the index of the character nearest to the given point.
        /// </devdoc>
        public int GetCharIndexFromPosition(Point pt) {
            NativeMethods.POINT wpt = new NativeMethods.POINT(pt.X, pt.Y);
            int n;
            n = (int)UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.EM_CHARFROMPOS, 0, wpt);

            // EM_CHARFROMPOS will return an invalid number if the last character in the RichEdit
            // is a newline.
            //
            if (n >= Text.Length) {
                n = Math.Max(Text.Length - 1, 0);
            }

            return n;
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.GetCharInCharSet"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        private bool GetCharInCharSet(char c, char[] charSet, bool negate) {
            bool match = false;
            int charSetLen = charSet.Length;

            // Loop through the given character set and compare for a match
            for (int i = 0; !match && i < charSetLen; i++)
                match = c == charSet[i];

            return negate ? !match : match;
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.GetLineFromCharIndex"]/*' />
        /// <devdoc>
        ///     Returns the number of the line containing a specified character position
        ///     in a RichTextBox control. Note that this returns the physical line number
        ///     and not the conceptual line number. For example, if the first conceptual
        ///     line (line number 0) word-wraps and extends to the second line, and if
        ///     you pass the index of a overflowed character, GetLineFromCharIndex would
        ///     return 1 and not 0.
        /// </devdoc>
        public int GetLineFromCharIndex(int index) {
            int n = (int)SendMessage(RichTextBoxConstants.EM_EXLINEFROMCHAR, 0, index);
            return n;
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.GetPositionFromCharIndex"]/*' />
        /// <devdoc>
        ///     Returns the location of the character at the given index.
        /// </devdoc>
        public Point GetPositionFromCharIndex(int index) {

            if (index < 0 || index > Text.Length)
                return Point.Empty;

            NativeMethods.POINT wpt = new NativeMethods.POINT();
            UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.EM_POSFROMCHAR, wpt, index);
            return new Point(wpt.x, wpt.y);
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.GetProtectedError"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        private bool GetProtectedError() {
            if (protectedError) {
                protectedError = false;
                return true;
            }

            return false;
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.LoadFile"]/*' />
        /// <devdoc>
        ///     Loads the contents of the given RTF or text file into a RichTextBox control.
        /// </devdoc>
        public void LoadFile(string path) {
            LoadFile(path, RichTextBoxStreamType.RichText);
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.LoadFile1"]/*' />
        /// <devdoc>
        ///     Loads the contents of a RTF or text into a RichTextBox control.
        /// </devdoc>
        public void LoadFile(string path, RichTextBoxStreamType fileType) {
            if (!Enum.IsDefined(typeof(RichTextBoxStreamType), fileType)) {
                throw new InvalidEnumArgumentException("fileType", (int)fileType, typeof(RichTextBoxStreamType));
            }
        
            Stream file = new FileStream(path, FileMode.Open, FileAccess.Read, FileShare.Read);
            try {
                LoadFile(file, fileType);
            }
            finally {
                file.Close();
            }
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.LoadFile2"]/*' />
        /// <devdoc>
        ///     Loads the contents of a RTF or text into a RichTextBox control.
        /// </devdoc>
        public void LoadFile(Stream data, RichTextBoxStreamType fileType) {
            if (!Enum.IsDefined(typeof(RichTextBoxStreamType), fileType)) {
                throw new InvalidEnumArgumentException("fileType", (int)fileType, typeof(RichTextBoxStreamType));
            }
        
            int flags;
            switch (fileType) {
                case RichTextBoxStreamType.RichText:
                    flags = RichTextBoxConstants.SF_RTF;
                    break;
                case RichTextBoxStreamType.PlainText:
                    flags = RichTextBoxConstants.SF_TEXT;
                    break;
                case RichTextBoxStreamType.UnicodePlainText:
                    flags = RichTextBoxConstants.SF_UNICODE | RichTextBoxConstants.SF_TEXT;
                    break;
                default:
                    throw new ArgumentException(SR.GetString(SR.InvalidFileType));
            }
            StreamIn(data, flags);
        }


        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.OnBackColorChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnBackColorChanged(EventArgs e) {
            if (IsHandleCreated)
                SendMessage(RichTextBoxConstants.EM_SETBKGNDCOLOR, 0, ColorTranslator.ToWin32(BackColor));
            
            base.OnBackColorChanged(e);
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.OnContextMenuChanged"]/*' />
        protected override void OnContextMenuChanged(EventArgs e) {
            base.OnContextMenuChanged(e);
            UpdateOleCallback();
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.OnRightToLeftChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnRightToLeftChanged(EventArgs e) {
            base.OnRightToLeftChanged(e);
            if (IsHandleCreated) {
                // It seems we need to re-poke the text to get it to align properly. See ASURT 47219.
                //
                RepokeText();
            }
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.OnContentsResized"]/*' />
        /// <devdoc>
        ///     Fires an event when the user changes the control's contents
        ///     are either smaller or larger than the control's window size.
        /// </devdoc>
        protected virtual void OnContentsResized(ContentsResizedEventArgs e) {
            ContentsResizedEventHandler handler = (ContentsResizedEventHandler)Events[EVENT_REQUESTRESIZE];
            if (handler != null) handler(this,e);
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.OnHandleCreated"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnHandleCreated(EventArgs e) {
            // base.OnHandleCreated is called somewhere in the middle of this

            curSelStart = curSelEnd = curSelType = -1;

            // We will always set the control to use the maximum text, it defaults to 32k..
            // This must be done before we start loading files, because some files may
            // be larger than 32k.
            //
            UpdateMaxLength();

            // This is needed so that the control will fire change and update events
            // even if it is hidden
            //
            SendMessage(RichTextBoxConstants.EM_SETEVENTMASK,
                        0,
                        RichTextBoxConstants.ENM_PROTECTED | RichTextBoxConstants.ENM_SELCHANGE |
                        RichTextBoxConstants.ENM_DROPFILES | RichTextBoxConstants.ENM_REQUESTRESIZE |
                        RichTextBoxConstants.ENM_IMECHANGE | RichTextBoxConstants.ENM_CHANGE |
                        RichTextBoxConstants.ENM_UPDATE    | RichTextBoxConstants.ENM_SCROLL |
                        RichTextBoxConstants.ENM_KEYEVENTS | RichTextBoxConstants.ENM_MOUSEEVENTS |
                        RichTextBoxConstants.ENM_SCROLLEVENTS | RichTextBoxConstants.ENM_LINK);

            int rm = rightMargin;
            rightMargin = 0;
            RightMargin = rm;

            //CONSIDER: simcooke: Note: RichTextBox is created with autoUrlDetect set to false. We can
            //assume this to always be true or play it safe and send the message regardless of the value
            // ... in this case, we'll play it safe.
            this.SendMessage(RichTextBoxConstants.EM_AUTOURLDETECT, autoUrlDetect ? 1 : 0, 0);

            // Initialize colors before initializing RTF, otherwise CFE_AUTOCOLOR will be in effect
            // and our text will all be Color.WindowText.
            AutoWordSelection = AutoWordSelection;
            SendMessage(RichTextBoxConstants.EM_SETBKGNDCOLOR, 0, ColorTranslator.ToWin32(BackColor));
            InternalSetForeColor(ForeColor);
            
            // base sets the Text property.  It's important to do this *after* setting EM_AUTOUrlDETECT.
            base.OnHandleCreated(e);
            
            // RTF property takes precedence over Text property
            //
            try {
                suppressTextChangedEvent = true;
                if (textRtf != null) {
                    // setting RTF calls back on Text, which relies on textRTF being null
                    string text = textRtf;
                    textRtf = null;
                    Rtf = text;
                }
                else if (textPlain != null) {
                    string text = textPlain;
                    textPlain = null;
                    Text = text;
                }
            }
            finally {
                suppressTextChangedEvent = false;
            }
            
            // Since we can't send EM_SETSEL until RTF has been set,
            // we can't rely on base to do it for us.
            SetSelectionOnHandle();
            
            if (showSelBar) {
                // If you call SendMessage instead of PostMessage, the control
                // will resize itself to the size of the parent's client area.  Don't know why...
                UnsafeNativeMethods.PostMessage(new HandleRef(this, Handle), RichTextBoxConstants.EM_SETOPTIONS, (IntPtr)RichTextBoxConstants.ECOOP_OR,
                                                (IntPtr)RichTextBoxConstants.ECO_SELECTIONBAR);
            }

            ClearUndo();                                  

            SendZoomFactor(zoomMultiplier);            

            UpdateOleCallback();
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.OnHandleDestroyed"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnHandleDestroyed(EventArgs e) {
            base.OnHandleDestroyed(e);
            
            if (!fInCtor) {
                textRtf = Rtf;
                if (textRtf.Length == 0)
                    textRtf = null;
            }

            oleCallback = null;
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.OnHScroll"]/*' />
        /// <devdoc>
        ///     Fires an event when the user clicks a RichTextBox control's horizontal
        ///     scroll bar.
        /// </devdoc>
        protected virtual void OnHScroll(EventArgs e) {
            EventHandler handler = (EventHandler)Events[EVENT_HSCROLL];
            if (handler != null) handler(this,e);
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.OnLinkClicked"]/*' />
        /// <devdoc>
        ///     Fires an event when the user clicks on a link
        ///     in a rich-edit control.
        /// </devdoc>
        protected virtual void OnLinkClicked(LinkClickedEventArgs e) {
            LinkClickedEventHandler handler = (LinkClickedEventHandler)Events[EVENT_LINKACTIVATE];
            if (handler != null) handler(this,e);
        }


        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.OnImeChange"]/*' />
        /// <devdoc>
        ///     Fires an event when the user changes the control's IME conversion status.
        /// </devdoc>
        protected virtual void OnImeChange(EventArgs e) {
            EventHandler handler = (EventHandler)Events[EVENT_IMECHANGE];
            if (handler != null) handler(this,e);
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.OnProtected"]/*' />
        /// <devdoc>
        ///     Fires an event when the user is taking an action that would change
        ///     a protected range of text in the RichTextBox control.
        /// </devdoc>
        protected virtual void OnProtected(EventArgs e) {
            protectedError = true;
            EventHandler handler = (EventHandler)Events[EVENT_PROTECTED];
            if (handler != null) handler(this,e);
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.OnSelectionChanged"]/*' />
        /// <devdoc>
        ///     Fires an event when the current selection of text in the RichTextBox
        ///     control has changed or the insertion point has moved.
        /// </devdoc>
        protected virtual void OnSelectionChanged(EventArgs e) {
            EventHandler handler = (EventHandler)Events[EVENT_SELCHANGE];
            if (handler != null) handler(this,e);
        }
        
        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.OnSystemColorsChanged"]/*' />
        protected override void OnSystemColorsChanged(EventArgs e) {
            base.OnSystemColorsChanged(e);
        
            if (IsHandleCreated) {
                SendMessage(RichTextBoxConstants.EM_SETBKGNDCOLOR, 0, ColorTranslator.ToWin32(BackColor));
            }
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.OnTextChanged"]/*' />
        /// <devdoc>
        ///     Fires the event indicating that the text property has been changed.
        ///     Inheriting controls should use this in favour of actually listening to
        ///     the event, but should not forget to call base.onTextChanged() to
        ///     ensure that the event is still fired for external listeners.
        /// </devdoc>
        protected override void OnTextChanged(EventArgs e) {
            this.Invalidate();
            base.OnTextChanged(e);
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.OnVScroll"]/*' />
        /// <devdoc>
        ///     Fires an event when the user clicks a RichTextBox control's vertical
        ///     scroll bar.
        /// </devdoc>
        protected virtual void OnVScroll(EventArgs e) {
            EventHandler handler = (EventHandler)Events[EVENT_VSCROLL];
            if (handler != null) handler(this,e);
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.Paste"]/*' />
        /// <devdoc>
        ///     Pastes the contents of the clipboard in the given clipboard format.
        /// </devdoc>
        public void Paste(DataFormats.Format clipFormat) {
            Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "ClipboardRead Demanded");
            IntSecurity.ClipboardRead.Demand();

            Paste(clipFormat, 0);
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.Paste1"]/*' />
        /// <devdoc>
        /// </devdoc>
        private void Paste(DataFormats.Format clipFormat, int hIcon) {
            NativeMethods.REPASTESPECIAL rps = null;

            if (hIcon != 0) {
                rps = new NativeMethods.REPASTESPECIAL();
                rps.dwAspect = DVASPECT_ICON;
                rps.dwParam = hIcon;
            }
            UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), RichTextBoxConstants.EM_PASTESPECIAL, clipFormat.Id, rps);
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.Redo"]/*' />
        /// <devdoc>
        ///     Redoes the last undone editing operation.
        /// </devdoc>
        public void Redo() {
            SendMessage(RichTextBoxConstants.EM_REDO, 0, 0);
        }

        // In some circumstances, we need to re-poke the text into the RichTextBox to get
        // it to display the text properly e.g. changing the DetectUrls property, or
        // RightToLeft.
        private void RepokeText() {
            if (IsHandleCreated) {
                // We use WindowText rather than Text because this way we can avoid
                // spurious TextChanged events.
                //
                string oldText = WindowText;
                WindowText = null;
                WindowText = oldText;
            }
        }

        //NOTE: Undo is implemented on TextBox

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.ResetZoom"]/*' />
        /// <devdoc>
        ///     Clears the Zoom level for the RichTextBox control back to normal (1.0)
        /// </devdoc>
        private void ResetZoom() {
            //CONSIDER: Should we force this anyway, due to floating point errors?
            if (ZoomFactor != 1.0f) {
                SendMessage(RichTextBoxConstants.EM_SETZOOM, 0, 0);
                zoomMultiplier = 1.0f;
            }
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.SaveFile"]/*' />
        /// <devdoc>
        ///     Saves the contents of a RichTextBox control to a file.
        /// </devdoc>
        public void SaveFile(string path) {
            SaveFile(path, RichTextBoxStreamType.RichText);
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.SaveFile1"]/*' />
        /// <devdoc>
        ///     Saves the contents of a RichTextBox control to a file.
        /// </devdoc>
        public void SaveFile(string path, RichTextBoxStreamType fileType) {
            if (!Enum.IsDefined(typeof(RichTextBoxStreamType), fileType)) {
                throw new InvalidEnumArgumentException("fileType", (int)fileType, typeof(RichTextBoxStreamType));
            }
            
            Stream file = File.Create(path);
            try {
                SaveFile(file, fileType);
            }
            finally {
                file.Close();
            }
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.SaveFile2"]/*' />
        /// <devdoc>
        ///     Saves the contents of a RichTextBox control to a file.
        /// </devdoc>
        public void SaveFile(Stream data, RichTextBoxStreamType fileType) {
            if (!Enum.IsDefined(typeof(RichTextBoxStreamType), fileType)) {
                throw new InvalidEnumArgumentException("fileType", (int)fileType, typeof(RichTextBoxStreamType));
            }
        
            int flags;
            switch (fileType) {
                case RichTextBoxStreamType.RichText:
                    flags = RichTextBoxConstants.SF_RTF;
                    break;
                case RichTextBoxStreamType.PlainText:
                    flags = RichTextBoxConstants.SF_TEXT;
                    break;
                case RichTextBoxStreamType.UnicodePlainText:
                    flags = RichTextBoxConstants.SF_UNICODE | RichTextBoxConstants.SF_TEXT;
                    break;
                case RichTextBoxStreamType.RichNoOleObjs:
                    flags = RichTextBoxConstants.SF_RTFNOOBJS;
                    break;
                case RichTextBoxStreamType.TextTextOleObjs:
                    flags = RichTextBoxConstants.SF_TEXTIZED;
                    break;
                default:
                    throw new ArgumentException(SR.GetString(SR.InvalidFileType));
            }

            StreamOut(data, flags, true);
        }
        
        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.SendZoomFactor"]/*' />
        /// <devdoc>
        ///     Core Zoom calculation and message passing (used by ZoomFactor property and CreateHandle()
        /// </devdoc>
        /// <internalonly/>
        private void SendZoomFactor(float zoom) {
            short numerator;
            short denominator;

            if (zoom < 1.0f) {
                denominator = (short)16384;
                numerator = (short)Math.Ceiling(16384.0f * zoom);
            }
            else if (zoom > 1.0f) {
                numerator = (short)16384;
                denominator = (short)Math.Ceiling(16384.0f / zoom);
            }
            else {
                denominator = (short)0;
                numerator = (short)0;
            }

            if (IsHandleCreated) {
                SendMessage(RichTextBoxConstants.EM_SETZOOM, numerator, denominator);
#if DEBUG

                // DEBUG CODE: Verify that EM_SETZOOM actually set the zoom
                short n = 0, d = 0;
                SendMessage(RichTextBoxConstants.EM_GETZOOM, ref n, ref d);
                Debug.Assert(n == numerator && d == denominator, "EM_SETZOOM failed");
                // END DEBUG CODE
#endif                
            }

            if (numerator != 0) {
                zoomMultiplier = ((float)numerator)/((float)denominator);                
            }
            else {
                zoomMultiplier = 1.0f;
            }
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.SetCharFormat"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        private bool SetCharFormat(int mask, int effect, RichTextBoxSelectionAttribute charFormat) {
            // check to see if the control has been created
            if (IsHandleCreated) {
                NativeMethods.CHARFORMATA cf = new NativeMethods.CHARFORMATA();

                cf.dwMask = mask;

                switch (charFormat) {
                    case RichTextBoxSelectionAttribute.All:
                        cf.dwEffects = effect;
                        break;
                    case RichTextBoxSelectionAttribute.None:
                        cf.dwEffects = 0;
                        break;
                    default:
                        throw new ArgumentException(SR.GetString(SR.UnknownAttr));
                }

                // set the format information
                return IntPtr.Zero != UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), RichTextBoxConstants.EM_SETCHARFORMAT, RichTextBoxConstants.SCF_SELECTION, cf);
            }
            return false;
        }

        private bool SetCharFormat(int charRange, NativeMethods.CHARFORMATA cf) {
            return IntPtr.Zero != UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), RichTextBoxConstants.EM_SETCHARFORMAT, charRange, cf);
        }

        void SetCharFormatFont(bool selectionOnly, Font value) {
            ForceHandleCreate();
            NativeMethods.LOGFONT logfont = new NativeMethods.LOGFONT();

            IntSecurity.ObjectFromWin32Handle.Assert();
            try {
                value.ToLogFont(logfont);
            }
            finally {
                CodeAccessPermission.RevertAssert();
            }

            byte[] bytesFaceName;

            int dwMask = RichTextBoxConstants.CFM_FACE | RichTextBoxConstants.CFM_SIZE | RichTextBoxConstants.CFM_BOLD |
                RichTextBoxConstants.CFM_ITALIC | RichTextBoxConstants.CFM_STRIKEOUT | RichTextBoxConstants.CFM_UNDERLINE |
                RichTextBoxConstants.CFM_CHARSET;

            int dwEffects = 0;
            if (value.Bold) dwEffects |= RichTextBoxConstants.CFE_BOLD;
            if (value.Italic) dwEffects |= RichTextBoxConstants.CFE_ITALIC;
            if (value.Strikeout) dwEffects |= RichTextBoxConstants.CFE_STRIKEOUT;
            if (value.Underline) dwEffects |= RichTextBoxConstants.CFE_UNDERLINE;

            if (Marshal.SystemDefaultCharSize == 1)            
            {
                bytesFaceName = Encoding.Default.GetBytes(logfont.lfFaceName);

                NativeMethods.CHARFORMATA cfA = new NativeMethods.CHARFORMATA();
                for (int i=0; i<bytesFaceName.Length; i++) cfA.szFaceName[i] = bytesFaceName[i];
                cfA.dwMask = dwMask;
                cfA.dwEffects = dwEffects;
                cfA.yHeight = (int) (value.SizeInPoints * 20);
                cfA.bCharSet = logfont.lfCharSet;
                cfA.bPitchAndFamily = logfont.lfPitchAndFamily;

                UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), RichTextBoxConstants.EM_SETCHARFORMAT, selectionOnly ? RichTextBoxConstants.SCF_SELECTION : RichTextBoxConstants.SCF_ALL, cfA);
            }
            else
            {
                bytesFaceName = Encoding.Unicode.GetBytes(logfont.lfFaceName);

                NativeMethods.CHARFORMATW cfW = new NativeMethods.CHARFORMATW();
                for (int i=0; i<bytesFaceName.Length; i++) cfW.szFaceName[i] = bytesFaceName[i];
                cfW.dwMask = dwMask;
                cfW.dwEffects = dwEffects;
                cfW.yHeight = (int) (value.SizeInPoints * 20);
                cfW.bCharSet = logfont.lfCharSet;
                cfW.bPitchAndFamily = logfont.lfPitchAndFamily;

                UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), RichTextBoxConstants.EM_SETCHARFORMAT, selectionOnly ? RichTextBoxConstants.SCF_SELECTION : RichTextBoxConstants.SCF_ALL, cfW);
            }
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.SetupLogPixels"]/*' />
        /// <devdoc>
        /// </devdoc>
        private static void SetupLogPixels(IntPtr hDC) {
            bool release = false;
            if (hDC == IntPtr.Zero) {
                hDC = UnsafeNativeMethods.GetDC(NativeMethods.NullHandleRef);
                release = true;
            }
            if (hDC == IntPtr.Zero) return;
            logPixelsX = UnsafeNativeMethods.GetDeviceCaps(new HandleRef(null, hDC), NativeMethods.LOGPIXELSX);
            logPixelsY = UnsafeNativeMethods.GetDeviceCaps(new HandleRef(null, hDC), NativeMethods.LOGPIXELSY);
            if (release)
                UnsafeNativeMethods.ReleaseDC(NativeMethods.NullHandleRef, new HandleRef(null, hDC));
        }

        private static int Pixel2Twip(IntPtr hDC, int v, bool xDirection) {
            SetupLogPixels(hDC);
            int logP = xDirection ? logPixelsX : logPixelsY;
            return(int) ((((double)v) / logP) * 72.0 * 20.0);
        }

        private static int Twip2Pixel(IntPtr hDC, int v, bool xDirection) {
            SetupLogPixels(hDC);
            int logP = xDirection ? logPixelsX : logPixelsY;
            return(int) (((((double) v) / 20.0) / 72.0) * logP);
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.StreamIn"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        private void StreamIn(string str, int flags) {
            if (str.Length == 0 ) {
                // Destroy the selection if callers was setting
                // selection text
                //
                if ((RichTextBoxConstants.SFF_SELECTION & flags) != 0) {
                    SendMessage(NativeMethods.WM_CLEAR, 0, 0);
                    protectedError = false;
                    return;
                }
                // WM_SETTEXT is allowed even if we have protected text
                //
                SendMessage(NativeMethods.WM_SETTEXT, 0, "");
                return;
            }

            // Rather than work only some of the time with null characters,
            // we're going to be consistent and never work with them.
            int nullTerminatedLength = str.IndexOf((char) 0);
            if (nullTerminatedLength != -1)
                str = str.Substring(0, nullTerminatedLength);

            // get the string into a byte array
            editStream = new MemoryStream();
            byte[] encodedBytes;
            if ((flags & RichTextBoxConstants.SF_UNICODE) != 0) {
                encodedBytes = Encoding.Unicode.GetBytes(str);
            }
            else {
                encodedBytes = Encoding.Default.GetBytes(str);
            }
            editStream.Write(encodedBytes, 0, encodedBytes.Length);
            editStream.Position = 0;
            StreamIn(editStream, flags);
        }

        private void StreamIn(Stream data, int flags) {
            // clear out the selection only if we are replacing all the text
            //
            if ((flags & RichTextBoxConstants.SFF_SELECTION) == 0) {
                NativeMethods.CHARRANGE cr = new NativeMethods.CHARRANGE();
                UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), RichTextBoxConstants.EM_EXSETSEL, 0, cr);
            }

            try {
                editStream = data;
                Debug.Assert(data != null, "StreamIn passed a null stream");

                // If SF_RTF is requested then check for the RTF tag at the start
                // of the file.  We don't load if the tag is not there
                // CONSIDER: what happens if the stream doesn't support seeking?
                if ((flags & RichTextBoxConstants.SF_RTF) != 0) {
                    long streamStart = editStream.Position;
                    byte[] bytes = new byte[SZ_RTF_TAG.Length];
                    editStream.Read(bytes, (int)streamStart, SZ_RTF_TAG.Length);
                    string str = Encoding.Default.GetString(bytes);
                    if (!SZ_RTF_TAG.Equals(str))
                        throw new ArgumentException(SR.GetString(SR.InvalidFileFormat));

                    // put us back at the start of the file
                    editStream.Position = streamStart;
                }

                // set up structure to do stream operation
                NativeMethods.EDITSTREAM es = new NativeMethods.EDITSTREAM();
                if ((flags & RichTextBoxConstants.SF_UNICODE) != 0) {
                    es.dwCookie = INPUT | UNICODE;
                }
                else {
                    es.dwCookie = INPUT | ANSI;
                }
                if ((flags & RichTextBoxConstants.SF_RTF) != 0) {
                    es.dwCookie |= RTF;
                }
                else {
                    es.dwCookie |= TEXTLF;
                }
                es.pfnCallback = new NativeMethods.EditStreamCallback(this.EditStreamProc);


                // gives us TextBox compatible behavior, programatic text change shouldn't
                // be limited...
                //
                SendMessage(RichTextBoxConstants.EM_EXLIMITTEXT, 0, Int32.MaxValue);

                // go get the text for the control
                UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), RichTextBoxConstants.EM_STREAMIN, flags, es);

                UpdateMaxLength();

                // If we failed to load because of protected
                // text then return protect event was fired so no
                // exception is required for the the error
                if (GetProtectedError())
                    return;

                if (es.dwError != 0)
                    throw new InvalidOperationException(SR.GetString(SR.LoadTextError));

                // set the modify tag on the control
                SendMessage(NativeMethods.EM_SETMODIFY, -1, 0);

                // EM_GETLINECOUNT will cause the RichTextBoxConstants to recalculate its line indexes
                SendMessage(NativeMethods.EM_GETLINECOUNT, 0, 0);
            }
            finally {
                // release any storage space held.
                editStream = null;
            }
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.StreamOut"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        private string StreamOut(int flags) {
            Stream stream = new MemoryStream();
            StreamOut(stream, flags, false);
            stream.Position = 0;
            int streamLength = (int)stream.Length;
            
            if (streamLength > 0) {
                byte[] bytes = new byte[streamLength];
                stream.Read(bytes, 0, streamLength);
                if ((flags & RichTextBoxConstants.SF_UNICODE) != 0) {
                    return Encoding.Unicode.GetString(bytes);
                }
                else {
                    return Encoding.Default.GetString(bytes);
                }
            }
            else {
                return string.Empty;
            }
        }

        private void StreamOut(Stream data, int flags, bool includeCrLfs) {
            // set up the EDITSTREAM structure for the callback.
            Debug.Assert(data != null, "StreamOut passed a null stream");
            editStream = data;

            try {
                NativeMethods.EDITSTREAM es = new NativeMethods.EDITSTREAM();
                if ((flags & RichTextBoxConstants.SF_UNICODE) != 0) {
                    es.dwCookie = OUTPUT | UNICODE;
                }
                else {
                    es.dwCookie = OUTPUT | ANSI;
                }
                if ((flags & RichTextBoxConstants.SF_RTF) != 0) {
                    es.dwCookie |= RTF;
                }
                else {
                    if (includeCrLfs) {
                        es.dwCookie |= TEXTCRLF;
                    }
                    else {
                        es.dwCookie |= TEXTLF;
                    }
                }
                es.pfnCallback = new NativeMethods.EditStreamCallback(this.EditStreamProc);

                // Get Text
                UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), RichTextBoxConstants.EM_STREAMOUT, flags, es);
                
                // check to make sure things went well
                if (es.dwError != 0)
                    throw new InvalidOperationException(SR.GetString(SR.SaveTextError));

            }
            finally {
                // release any storage space held.
                editStream = null;
            }
        }

        void UpdateOleCallback() {
            Debug.WriteLineIf(RichTextDbg.TraceVerbose, "update ole callback (" + AllowDrop + ")");
            if (IsHandleCreated) {
                if (oleCallback == null) {
                    Debug.WriteLineIf(RichTextDbg.TraceVerbose, "binding ole callback");
                    oleCallback = CreateRichEditOleCallback();
                    
                    // Forcibly QI (through IUnknown::QueryInterface) to handle multiple
                    // definitions of the interface.
                    //
                    IntPtr punk = Marshal.GetIUnknownForObject(oleCallback);
                    try {
                        IntPtr pRichEditOleCallback;
                        Guid iidRichEditOleCallback = typeof(UnsafeNativeMethods.IRichEditOleCallback).GUID;
                        Marshal.QueryInterface(punk, ref iidRichEditOleCallback, out pRichEditOleCallback);
                        try {
                            UnsafeNativeMethods.SendCallbackMessage(new HandleRef(this, Handle), RichTextBoxConstants.EM_SETOLECALLBACK, IntPtr.Zero, pRichEditOleCallback);
                        }
                        finally {
                            Marshal.Release(pRichEditOleCallback);
                        }
                    } finally {
                        Marshal.Release(punk);
                    }
                }
                UnsafeNativeMethods.DragAcceptFiles(new HandleRef(this, Handle), false);
            }
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.CreateRichEditOleCallback"]/*' />
        /// <devdoc>
        ///   Creates the IRichEditOleCallback compatible object for handling RichEdit callbacks. For more
        ///   information look up the MSDN info on this interface. This is designed to be a back door of 
        ///   sorts, which is why it is fairly obscure, and uses the RichEdit name instead of RichTextBox.
        /// </devdoc>
        [SecurityPermission(SecurityAction.InheritanceDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        protected virtual object CreateRichEditOleCallback() {
            return new OleCallback(this);
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.EnLinkMsgHandler"]/*' />
        /// <devdoc>
        ///      Handles link messages (mouse move, down, up, dblclk, etc)
        /// </devdoc>
        /// <internalonly/>
        private void EnLinkMsgHandler(ref Message m) {
            NativeMethods.ENLINK enlink = (NativeMethods.ENLINK)m.GetLParam(typeof(NativeMethods.ENLINK));
            switch (enlink.msg) {
                case NativeMethods.WM_SETCURSOR:
                    linkcursor = true;
                    m.Result = (IntPtr)1;
                    return;
                    // Mouse-down triggers Url; this matches Outlook 2000's behavior.
                case NativeMethods.WM_LBUTTONDOWN:
                    string linktext = CharRangeToString(enlink.charrange);
                    OnLinkClicked(new LinkClickedEventArgs(linktext));
                    m.Result = (IntPtr)1;
                    return;
            }
            m.Result = IntPtr.Zero;
            return;
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.CharRangeToString"]/*' />
        /// <devdoc>
        ///     Converts a CHARRANGE to a string. Note: The behavior of this is dependent on the current window
        ///     class name being used. We have to create a CharBuffer of the type of RichTextBox DLL we're using,
        ///     not based on the SystemCharWidth.
        /// </devdoc>
        /// <internalonly/>
        private string CharRangeToString(NativeMethods.CHARRANGE c) {
            NativeMethods.TEXTRANGE txrg = new NativeMethods.TEXTRANGE();
            txrg.chrg = c;
            Debug.Assert((c.cpMax-c.cpMin)>0, "CHARRANGE was null or negative - can't do it!");
            int characters = (c.cpMax-c.cpMin) + 1; // +1 for null termination
            NativeMethods.CharBuffer charBuffer = NativeMethods.CharBuffer.CreateBuffer(characters);
            IntPtr unmanagedBuffer = charBuffer.AllocCoTaskMem();
            if (unmanagedBuffer == IntPtr.Zero)
                throw new OutOfMemoryException(SR.GetString(SR.OutOfMemory));

            txrg.lpstrText = unmanagedBuffer;
            int len = (int)UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), RichTextBoxConstants.EM_GETTEXTRANGE, 0, txrg);
            Debug.Assert(len != 0, "CHARRANGE from RichTextBox was bad! - impossible?");

            charBuffer.PutCoTaskMem(unmanagedBuffer);
            if (txrg.lpstrText != IntPtr.Zero)
                Marshal.FreeCoTaskMem(unmanagedBuffer);

            string result = charBuffer.GetString();
            return result;
        }
        
        internal override void UpdateMaxLength() {
            if (IsHandleCreated) {
                SendMessage(RichTextBoxConstants.EM_EXLIMITTEXT, 0, MaxLength);
            }
        }
        
        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.WmReflectCommand"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        private void WmReflectCommand(ref Message m) {

            // We check if we're in the middle of handle creation because
            // the rich edit control fires spurious events during this time.
            //
            if (m.LParam == Handle && !GetState(STATE_CREATINGHANDLE)) {
                switch (Util.HIWORD(m.WParam)) {
                    
                    case NativeMethods.EN_HSCROLL:
                        OnHScroll(EventArgs.Empty);
                        break;

                    case NativeMethods.EN_VSCROLL:
                        OnVScroll(EventArgs.Empty);
                        break;

                    default:
                        base.WndProc(ref m);
                        break;
                }
            }
            else {
                base.WndProc(ref m);
            }
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.WmReflectNotify"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        internal void WmReflectNotify(ref Message m) {
            if (m.HWnd == Handle) {
                NativeMethods.NMHDR nmhdr = (NativeMethods.NMHDR)m.GetLParam(typeof(NativeMethods.NMHDR));
                switch (nmhdr.code) {
                    case RichTextBoxConstants.EN_LINK:
                        EnLinkMsgHandler(ref m);
                        break;
                    case RichTextBoxConstants.EN_DROPFILES:
                        NativeMethods.ENDROPFILES endropfiles = (NativeMethods.ENDROPFILES)m.GetLParam(typeof(NativeMethods.ENDROPFILES));

                        // Only look at the first file.
                        StringBuilder path = new StringBuilder(NativeMethods.MAX_PATH);
                        UnsafeNativeMethods.DragQueryFile(new HandleRef(endropfiles, endropfiles.hDrop), 0, path, NativeMethods.MAX_PATH);

                        // Try to load the file as an RTF
                        try {
                            LoadFile(path.ToString(), RichTextBoxStreamType.RichText);
                        }
                        catch (Exception) {
                            // we failed to load as rich text so try it as plain text
                            try {
                                LoadFile(path.ToString(), RichTextBoxStreamType.PlainText);
                            }
                            catch (Exception) {
                                // ignore any problems we have
                            }
                        }
                        m.Result = (IntPtr)1;   // tell them we did the drop
                        break;

                    case RichTextBoxConstants.EN_REQUESTRESIZE:
                        if (!callOnContentsResized) {
                            NativeMethods.REQRESIZE reqResize = (NativeMethods.REQRESIZE)m.GetLParam(typeof(NativeMethods.REQRESIZE));
                            if (BorderStyle == System.Windows.Forms.BorderStyle.Fixed3D) {
                                reqResize.rc.bottom++;
                            }
                            OnContentsResized(new ContentsResizedEventArgs(Rectangle.FromLTRB(reqResize.rc.left, reqResize.rc.top, reqResize.rc.right, reqResize.rc.bottom)));
                            }
                            break;

                    case RichTextBoxConstants.EN_SELCHANGE:
                        NativeMethods.SELCHANGE selChange = (NativeMethods.SELCHANGE)m.GetLParam(typeof(NativeMethods.SELCHANGE));
                        WmSelectionChange(selChange);
                        break;

                    case RichTextBoxConstants.EN_PROTECTED: {
                            NativeMethods.ENPROTECTED enprotected = (NativeMethods.ENPROTECTED)m.GetLParam(typeof(NativeMethods.ENPROTECTED));

                            switch (enprotected.msg) {
                                case RichTextBoxConstants.EM_SETCHARFORMAT:
                                    // Allow change of protected style
                                    //
                                    NativeMethods.CHARFORMATA charFormat = (NativeMethods.CHARFORMATA)UnsafeNativeMethods.PtrToStructure(enprotected.lParam, typeof(NativeMethods.CHARFORMATA));
                                    if ((charFormat.dwMask & RichTextBoxConstants.CFM_PROTECTED) != 0) {
                                        m.Result = IntPtr.Zero;
                                        return;
                                    }
                                    break;

                                    // Throw an exception for the following
                                    //
                                case RichTextBoxConstants.EM_SETPARAFORMAT:
                                case NativeMethods.EM_REPLACESEL:
                                    break;

                                case RichTextBoxConstants.EM_STREAMIN:
                                    // Don't allow STREAMIN to replace protected selection
                                    //
                                    if (((int)enprotected.wParam & RichTextBoxConstants.SFF_SELECTION) != 0)
                                        break;
                                    m.Result = IntPtr.Zero;
                                    return;

                                    // Allow the following
                                    //
                                case NativeMethods.WM_COPY:
                                case NativeMethods.WM_SETTEXT:
                                case RichTextBoxConstants.EM_EXLIMITTEXT:
                                    m.Result = IntPtr.Zero;
                                    return;

                                    // Beep and disallow change for all other messages
                                    //
                                default:
                                    SafeNativeMethods.MessageBeep(0);
                                    break;
                            }

                            OnProtected(EventArgs.Empty);
                            m.Result = (IntPtr)1;
                            break;
                        }

                    default:
                        base.WndProc(ref m);
                        break;
                }
            }
            else {
                base.WndProc(ref m);
            }
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.WmSelectionChange"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        private void WmSelectionChange(NativeMethods.SELCHANGE selChange) {
            int selStart = selChange.chrg.cpMin;
            int selEnd = selChange.chrg.cpMax;
            short selType = (short)selChange.seltyp;

            if (selStart != curSelStart || selEnd != curSelEnd || selType != curSelType) {
                curSelStart = selStart;
                curSelEnd   = selEnd;
                curSelType  = selType;
                OnSelectionChanged(EventArgs.Empty);
            }
        }

        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.WmSetFont"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        private void WmSetFont(ref Message m) {

            // This function would normally cause two TextChanged events to be fired, one
            // from the base.WndProc, and another from InternalSetForeColor.
            // To prevent this, we suppress the first event fire.
            //
            try {
                suppressTextChangedEvent = true;
                base.WndProc(ref m);
            }
            finally {
                suppressTextChangedEvent = false;
            }

            InternalSetForeColor(ForeColor);
        }

        // <internalonly/>
        // </doc>
        //
        /// <include file='doc\RichTextBox.uex' path='docs/doc[@for="RichTextBox.WndProc"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        protected override void WndProc(ref Message m) {
            switch (m.Msg) {
                case NativeMethods.WM_REFLECT + NativeMethods.WM_NOTIFY:
                    WmReflectNotify(ref m);
                    break;

                case NativeMethods.WM_REFLECT + NativeMethods.WM_COMMAND:
                    WmReflectCommand(ref m);
                    break;

                case NativeMethods.WM_SETCURSOR:
                    //NOTE: RichTextBox uses the WM_SETCURSOR message over links to allow us to
                    //      change the cursor to a hand. It does this through a synchronous notification
                    //      message. So we have to pass the message to the DefWndProc first, and
                    //      then, if we receive a notification message in the mean time (indicated by
                    //      changing "linkcursor", we set it to a hand. Otherwise, we call the
                    //      WM_SETCURSOR implementation on Control to set it to the user's selection for
                    //      the RichTextBox's cursor.
                    //
                    //      Similarly,
                    linkcursor = false;
                    DefWndProc(ref m);
                    if (linkcursor && !Cursor.Equals(Cursors.WaitCursor)) {
                        UnsafeNativeMethods.SetCursor(new HandleRef(Cursors.Hand, Cursors.Hand.Handle));
                        m.Result = (IntPtr)1;
                    }
                    else {
                        base.WndProc(ref m);
                    }
                    break;

                case NativeMethods.WM_SETFONT:
                    WmSetFont(ref m);
                    break;
                    
                case NativeMethods.WM_IME_NOTIFY:
                    OnImeChange(EventArgs.Empty);
                    base.WndProc(ref m);
                    break;

                case NativeMethods.WM_GETDLGCODE:
                    base.WndProc(ref m);
                    m.Result = (IntPtr)((AcceptsTab) ? (int)m.Result | NativeMethods.DLGC_WANTTAB : (int)m.Result & ~NativeMethods.DLGC_WANTTAB);
                    break;

                default:
                    base.WndProc(ref m);
                    break;
            }
        }

        // I used the visual basic 6 RichText (REOleCB.CPP) as a guide for this
        private class OleCallback : UnsafeNativeMethods.IRichTextBoxOleCallback {

            private RichTextBox owner;
            IDataObject lastDataObject;
            DragDropEffects lastEffect;
            bool unrestricted = false;

            internal OleCallback(RichTextBox owner) {
                try {
                    IntSecurity.UnmanagedCode.Demand();
                    unrestricted = true;
                }
                catch (SecurityException) {
                    unrestricted = false;
                }
                this.owner = owner;
            }


            public int GetNewStorage(out UnsafeNativeMethods.IStorage storage) {
                Debug.WriteLineIf(RichTextDbg.TraceVerbose, "IRichTextBoxOleCallback::GetNewStorage");
                // Debug.WriteLine("get new storage");
                UnsafeNativeMethods.ILockBytes pLockBytes = UnsafeNativeMethods.CreateILockBytesOnHGlobal(NativeMethods.NullHandleRef, true);

                Debug.Assert(pLockBytes != null, "pLockBytes is NULL!");

                storage = UnsafeNativeMethods.StgCreateDocfileOnILockBytes(pLockBytes,
                                                                           NativeMethods.STGM_SHARE_EXCLUSIVE | NativeMethods.STGM_CREATE | NativeMethods.STGM_READWRITE,
                                                                           0);
                Debug.Assert(storage != null, "storage is NULL!");

                return NativeMethods.S_OK;
            }

            public int GetInPlaceContext(IntPtr lplpFrame,
                                         IntPtr lplpDoc,
                                         IntPtr lpFrameInfo) {
                Debug.WriteLineIf(RichTextDbg.TraceVerbose, "IRichTextBoxOleCallback::GetInPlaceContext");
                return NativeMethods.E_NOTIMPL;
            }

            public int ShowContainerUI(int fShow) {
                Debug.WriteLineIf(RichTextDbg.TraceVerbose, "IRichTextBoxOleCallback::ShowContainerUI");
                // Do nothing
                return NativeMethods.S_OK;
            }

            public int QueryInsertObject(ref Guid lpclsid, IntPtr lpstg,
                                         int cp) {
                Debug.WriteLineIf(RichTextDbg.TraceVerbose, "IRichTextBoxOleCallback::QueryInsertObject(" + lpclsid.ToString() + ")");
                if (unrestricted) {
                    return NativeMethods.S_OK;
                }
                else {
                    Guid realClsid = new Guid();
                    
                    
                    int hr = UnsafeNativeMethods.ReadClassStg(new HandleRef(null, lpstg), ref realClsid);
                    Debug.WriteLineIf(RichTextDbg.TraceVerbose, "real clsid:" + realClsid.ToString() + " (hr=" + hr.ToString("X") + ")");
                    
                    if (!NativeMethods.Succeeded(hr)) {
                        return NativeMethods.S_FALSE;
                    }

                    if (realClsid == Guid.Empty) {
                        realClsid = lpclsid;
                    }

                    switch (realClsid.ToString().ToUpper(CultureInfo.InvariantCulture)) {
                        case "00000315-0000-0000-C000-000000000046": // Metafile
                        case "00000316-0000-0000-C000-000000000046": // DIB
                        case "00000319-0000-0000-C000-000000000046": // EMF
                        case "0003000A-0000-0000-C000-000000000046": //BMP
                            return NativeMethods.S_OK;
                        default:
                            Debug.WriteLineIf(RichTextDbg.TraceVerbose, "   denying '" + lpclsid.ToString() + "' from being inserted due to security restrictions");
                            return NativeMethods.S_FALSE;
                    }
                }
            }

            public int DeleteObject(IntPtr lpoleobj) {
                Debug.WriteLineIf(RichTextDbg.TraceVerbose, "IRichTextBoxOleCallback::DeleteObject");
                // Do nothing
                return NativeMethods.S_OK;
            }

            public int QueryAcceptData(UnsafeNativeMethods.IOleDataObject lpdataobj,
                                       /* CLIPFORMAT* */ IntPtr lpcfFormat, int reco,
                                       int fReally, IntPtr hMetaPict) {
                Debug.WriteLineIf(RichTextDbg.TraceVerbose, "IRichTextBoxOleCallback::QueryAcceptData(reco=" + reco + ")");

                if (reco == NativeMethods.RECO_DROP) {
                    if (owner.AllowDrop) {
                        MouseButtons b = Control.MouseButtons;
                        int keyState = 0;
                        if ((b & MouseButtons.Left) == MouseButtons.Left) {
                            keyState |= NativeMethods.MK_LBUTTON;
                        }
                        if ((b & MouseButtons.Right) == MouseButtons.Right) {
                            keyState |= NativeMethods.MK_RBUTTON;
                        }
                        if ((b & MouseButtons.Middle) == MouseButtons.Middle) {
                            keyState |= NativeMethods.MK_MBUTTON;
                        }
                        lastDataObject = new DataObject(lpdataobj);
                        lastEffect = DragDropEffects.None;
                        DragEventArgs e = new DragEventArgs(lastDataObject, 
                                                            keyState, 
                                                            Control.MousePosition.X, 
                                                            Control.MousePosition.Y, 
                                                            DragDropEffects.All, 
                                                            lastEffect);
                        if (fReally == 0) {
                            owner.OnDragEnter(e);
                        }
                        else {
                            owner.OnDragDrop(e);
                        }
                        lastEffect = e.Effect;
                        if (e.Effect == DragDropEffects.None) {
                            Debug.WriteLineIf(RichTextDbg.TraceVerbose, "\tCancel data");
                            return NativeMethods.E_FAIL;
                        }
                        else {
                            Debug.WriteLineIf(RichTextDbg.TraceVerbose, "\tAccept data");
                            return NativeMethods.S_OK;
                        }
                    }
                    else {
                        Debug.WriteLineIf(RichTextDbg.TraceVerbose, "\tCancel data, allowdrop == false");
                        lastDataObject = null;
                        return NativeMethods.E_FAIL;
                    }
                }
                else {
                    return NativeMethods.E_NOTIMPL;
                }
            }

            public int ContextSensitiveHelp(int fEnterMode) {
                Debug.WriteLineIf(RichTextDbg.TraceVerbose, "IRichTextBoxOleCallback::ContextSensitiveHelp");
                return NativeMethods.E_NOTIMPL;
            }

            public int GetClipboardData(NativeMethods.CHARRANGE lpchrg, int reco,
                                        IntPtr lplpdataobj) {
                Debug.WriteLineIf(RichTextDbg.TraceVerbose, "IRichTextBoxOleCallback::GetClipboardData");
                return NativeMethods.E_NOTIMPL;
            }

            public int GetDragDropEffect(bool fDrag, int grfKeyState, ref int pdwEffect) {
                Debug.WriteLineIf(RichTextDbg.TraceVerbose, "IRichTextBoxOleCallback::GetDragDropEffect");
                if (owner.AllowDrop && lastDataObject != null) {
                    DragEventArgs e = new DragEventArgs(lastDataObject, 
                                                        grfKeyState, 
                                                        Control.MousePosition.X, 
                                                        Control.MousePosition.Y, 
                                                        DragDropEffects.All, 
                                                        lastEffect);
                    // The below is the complete reverse of what the docs on MSDN suggest,
                    // but if we follow the docs, we would be firing OnDragDrop all the
                    // time instead of OnDragOver (see bug 99294). MSDN seems to be wrong here.
                    if (fDrag) {
                        owner.OnDragDrop(e);
                    }
                    else {
                        owner.OnDragOver(e);
                    }
                    lastEffect = e.Effect;
                    pdwEffect = (int)e.Effect;
                }
                else {
                    pdwEffect = (int)DragDropEffects.None;
                }
                return NativeMethods.S_OK;
            }

            public int GetContextMenu(short seltype, IntPtr lpoleobj, NativeMethods.CHARRANGE lpchrg, out IntPtr hmenu) {
                Debug.WriteLineIf(RichTextDbg.TraceVerbose, "IRichTextBoxOleCallback::GetContextMenu");
                if (owner.ContextMenu == null)
                    hmenu = IntPtr.Zero;
                else {
                    owner.ContextMenu.OnPopup(EventArgs.Empty);
                    // RichEd calls DestroyMenu after displaying the context menu
                    IntPtr handle = owner.ContextMenu.Handle;
                    // if another control shares the same context menu
                    // then we have to mark the context menu's handles empty because
                    // RichTextBox will delete the menu handles once the popup menu is dismissed.
                    Menu menu = owner.ContextMenu;
                    while (true) {
                        int i = 0;
                        int count = menu.itemCount;
                        for (; i< count; i++) {
                            if (menu.items[i].handle != IntPtr.Zero) {
                                menu = menu.items[i];
                                break;
                            }
                        }
                        if (i == count) {
                            menu.handle = IntPtr.Zero;
                            menu.created = false;
                            if (menu == owner.ContextMenu)
                                break;
                            else
                                menu = ((MenuItem) menu).menu;
                        }
                    }

                    hmenu = handle;
                }

                return NativeMethods.S_OK;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\richtextboxselectiontypes.cs ===
//------------------------------------------------------------------------------
// <copyright file="RichTextBoxSelectionTypes.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    using Microsoft.Win32;



    /// <include file='doc\RichTextBoxSelectionTypes.uex' path='docs/doc[@for="RichTextBoxSelectionTypes"]/*' />
    /// <devdoc>
    ///     Defines the possible kinds selection types in a RichTextBox control.
    ///     The actual vale returned by RichTextBox.getSelType() is a combination
    ///     of any of the below options.
    ///
    /// </devdoc>
    [Flags]
    public enum RichTextBoxSelectionTypes {
        /// <include file='doc\RichTextBoxSelectionTypes.uex' path='docs/doc[@for="RichTextBoxSelectionTypes.Empty"]/*' />
        /// <devdoc>
        ///     The current selection is empty.
        /// </devdoc>
        Empty            = 0,

        /// <include file='doc\RichTextBoxSelectionTypes.uex' path='docs/doc[@for="RichTextBoxSelectionTypes.Text"]/*' />
        /// <devdoc>
        ///     The current selection is text only.
        /// </devdoc>
        Text             = 1,

        /// <include file='doc\RichTextBoxSelectionTypes.uex' path='docs/doc[@for="RichTextBoxSelectionTypes.Object"]/*' />
        /// <devdoc>
        ///     The current selection contains atleast one OLE object.
        /// </devdoc>
        Object           = 2,

        /// <include file='doc\RichTextBoxSelectionTypes.uex' path='docs/doc[@for="RichTextBoxSelectionTypes.MultiChar"]/*' />
        /// <devdoc>
        ///     The current selection contains more than one character.
        /// </devdoc>
        MultiChar        = 4,

        /// <include file='doc\RichTextBoxSelectionTypes.uex' path='docs/doc[@for="RichTextBoxSelectionTypes.MultiObject"]/*' />
        /// <devdoc>
        ///     The current selection contains more than one OLE object.
        /// </devdoc>
        MultiObject      = 8,

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\richtextboxselectionattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="RichTextBoxSelectionAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    using Microsoft.Win32;


    /// <include file='doc\RichTextBoxSelectionAttribute.uex' path='docs/doc[@for="RichTextBoxSelectionAttribute"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies whether any characters in the
    ///       current selection have the style or attribute.
    ///
    ///    </para>
    /// </devdoc>
    public enum RichTextBoxSelectionAttribute {
        /// <include file='doc\RichTextBoxSelectionAttribute.uex' path='docs/doc[@for="RichTextBoxSelectionAttribute.Mixed"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Some but not all characters.
        ///    </para>
        /// </devdoc>
        Mixed     = -1,

        /// <include file='doc\RichTextBoxSelectionAttribute.uex' path='docs/doc[@for="RichTextBoxSelectionAttribute.None"]/*' />
        /// <devdoc>
        ///    <para>
        ///       No characters.
        ///    </para>
        /// </devdoc>
        None      = 0,

        /// <include file='doc\RichTextBoxSelectionAttribute.uex' path='docs/doc[@for="RichTextBoxSelectionAttribute.All"]/*' />
        /// <devdoc>
        ///    <para>
        ///       All characters.
        ///    </para>
        /// </devdoc>
        All       = 1,

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\richtextboxwordpunctuations.cs ===
//------------------------------------------------------------------------------
// <copyright file="RichTextBoxWordPunctuations.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    using Microsoft.Win32;


    /// <include file='doc\RichTextBoxWordPunctuations.uex' path='docs/doc[@for="RichTextBoxWordPunctuations"]/*' />
    /// <devdoc>
    ///     This class defines the possible kinds of punctuation tables that
    ///     can be used with the RichTextBox word wrapping and word breaking features.
    /// </devdoc>
    /* 
      CONSIDER: This should be marked with the Flags attribute, but we can't because our
              code generator cannot emit code for OR'd combinations of flags.
              
              Flags */
    public enum RichTextBoxWordPunctuations {
        /// <include file='doc\RichTextBoxWordPunctuations.uex' path='docs/doc[@for="RichTextBoxWordPunctuations.Level1"]/*' />
        /// <devdoc>
        ///     Use pre-defined Level 1 punctuation table as default.
        /// </devdoc>
        Level1     = 0x080,

        /// <include file='doc\RichTextBoxWordPunctuations.uex' path='docs/doc[@for="RichTextBoxWordPunctuations.Level2"]/*' />
        /// <devdoc>
        ///     Use pre-defined Level 2 punctuation table as default.
        /// </devdoc>
        Level2     = 0x100,

        /// <include file='doc\RichTextBoxWordPunctuations.uex' path='docs/doc[@for="RichTextBoxWordPunctuations.Custom"]/*' />
        /// <devdoc>
        ///     Use a custom defined punctuation table.
        /// </devdoc>
        Custom     = 0x200,

        /// <include file='doc\RichTextBoxWordPunctuations.uex' path='docs/doc[@for="RichTextBoxWordPunctuations.All"]/*' />
        /// <devdoc>
        ///     Used as a mask.
        /// </devdoc>
        All = Level1 | Level2 | Custom,

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\richtextboxstreamtype.cs ===
//------------------------------------------------------------------------------
// <copyright file="RichTextBoxStreamType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    using Microsoft.Win32;


    /// <include file='doc\RichTextBoxStreamType.uex' path='docs/doc[@for="RichTextBoxStreamType"]/*' />
    /// <devdoc>
    ///     Defines the possible kinds of input/output streams used by RichTextBox
    ///     control's load/save mechansim. These stream options are also used the
    ///     control's text modification methods.
    ///
    /// </devdoc>
    public enum RichTextBoxStreamType {
        /// <include file='doc\RichTextBoxStreamType.uex' path='docs/doc[@for="RichTextBoxStreamType.RichText"]/*' />
        /// <devdoc>
        ///     Rich Text Format (RTF).
        /// </devdoc>
        RichText       = 0,

        /// <include file='doc\RichTextBoxStreamType.uex' path='docs/doc[@for="RichTextBoxStreamType.PlainText"]/*' />
        /// <devdoc>
        ///     Text with spaces in place of OLE objects.
        /// </devdoc>
        PlainText      = 1,

        /// <include file='doc\RichTextBoxStreamType.uex' path='docs/doc[@for="RichTextBoxStreamType.RichNoOleObjs"]/*' />
        /// <devdoc>
        ///     RTF with spaces in place of OLE object (valid only for saveFile).
        /// </devdoc>
        RichNoOleObjs = 2,

        /// <include file='doc\RichTextBoxStreamType.uex' path='docs/doc[@for="RichTextBoxStreamType.TextTextOleObjs"]/*' />
        /// <devdoc>
        ///     Text with a text representation of OLE objects (valid only for saveFile).
        /// </devdoc>
        TextTextOleObjs = 3,

        /// <include file='doc\RichTextBoxStreamType.uex' path='docs/doc[@for="RichTextBoxStreamType.UnicodePlainText"]/*' />
        /// <devdoc>
        ///     Text with spaces in place of OLE objects, encoded in Unicode.
        /// </devdoc>
        UnicodePlainText      = 4,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\richtextboxconstants.cs ===
//------------------------------------------------------------------------------
// <copyright file="RichTextBoxConstants.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

//=--------------------------------------------------------------------------=
// RichTextBoxConstants.cs
//=--------------------------------------------------------------------------=
// Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.Drawing;
    using Microsoft.Win32;

    /// <include file='doc\RichTextBoxConstants.uex' path='docs/doc[@for="RichTextBoxConstants"]/*' />
    /// <devdoc>
    /// </devdoc>
    internal class RichTextBoxConstants {

        // flags for enum that we don't want public
        //
        internal const int RTB_HORIZ = 0x0001;
        internal const int RTB_VERT = 0x0002;
        internal const int RTB_FORCE = 0x0010;

        /* Richedit dll name */
        internal const string RICHEDIT_DLL10       = "RichEd32.DLL";
        internal const string RICHEDIT_DLL20       = "RichEd20.DLL";
        internal const string RICHEDIT_DLL30       = RICHEDIT_DLL20;

        /* Richedit1.0 Window Class */
        internal const string RICHEDIT_CLASS10A    = "RICHEDIT";

        /* Richedit2.0 Window Class. */
        internal const string RICHEDIT_CLASS20A    = "RichEdit20A";
        internal const string RICHEDIT_CLASS20W    = "RichEdit20W";

        /* Richedit3.0 Window Class */
        internal const string RICHEDIT_CLASS30A    = RICHEDIT_CLASS20A;
        internal const string RICHEDIT_CLASS30W    = RICHEDIT_CLASS20W;

        internal const string DLL_RICHEDIT         = RICHEDIT_DLL30;
        internal const string WC_RICHEDITA          = RICHEDIT_CLASS30A;
        internal const string WC_RICHEDITW          = RICHEDIT_CLASS30W;

        /* RichTextBox messages */
        internal const int WM_CONTEXTMENU          = 0x007B;

        internal const int WM_PRINTCLIENT          = 0x0318;

        internal const int EM_GETLIMITTEXT         = (NativeMethods.WM_USER + 37);

        internal const int EM_POSFROMCHAR          = (NativeMethods.WM_USER + 38);
        internal const int EM_CHARFROMPOS          = (NativeMethods.WM_USER + 39);

        internal const int EM_SCROLLCARET          = (NativeMethods.WM_USER + 49);
        internal const int EM_CANPASTE             = (NativeMethods.WM_USER + 50);
        internal const int EM_DISPLAYBAND          = (NativeMethods.WM_USER + 51);
        internal const int EM_EXGETSEL             = (NativeMethods.WM_USER + 52);
        internal const int EM_EXLIMITTEXT          = (NativeMethods.WM_USER + 53);
        internal const int EM_EXLINEFROMCHAR       = (NativeMethods.WM_USER + 54);
        internal const int EM_EXSETSEL             = (NativeMethods.WM_USER + 55);
        internal const int EM_FINDTEXT             = (NativeMethods.WM_USER + 56);
        internal const int EM_FORMATRANGE          = (NativeMethods.WM_USER + 57);
        internal const int EM_GETCHARFORMAT        = (NativeMethods.WM_USER + 58);
        internal const int EM_GETEVENTMASK         = (NativeMethods.WM_USER + 59);
        internal const int EM_GETOLEINTERFACE      = (NativeMethods.WM_USER + 60);
        internal const int EM_GETPARAFORMAT        = (NativeMethods.WM_USER + 61);
        internal const int EM_GETSELTEXT           = (NativeMethods.WM_USER + 62);
        internal const int EM_HIDESELECTION        = (NativeMethods.WM_USER + 63);
        internal const int EM_PASTESPECIAL         = (NativeMethods.WM_USER + 64);
        internal const int EM_REQUESTRESIZE        = (NativeMethods.WM_USER + 65);
        internal const int EM_SELECTIONTYPE        = (NativeMethods.WM_USER + 66);
        internal const int EM_SETBKGNDCOLOR        = (NativeMethods.WM_USER + 67);
        internal const int EM_SETCHARFORMAT        = (NativeMethods.WM_USER + 68);
        internal const int EM_SETEVENTMASK         = (NativeMethods.WM_USER + 69);
        internal const int EM_SETOLECALLBACK       = (NativeMethods.WM_USER + 70);
        internal const int EM_SETPARAFORMAT        = (NativeMethods.WM_USER + 71);
        internal const int EM_SETTARGETDEVICE      = (NativeMethods.WM_USER + 72);
        internal const int EM_STREAMIN             = (NativeMethods.WM_USER + 73);
        internal const int EM_STREAMOUT            = (NativeMethods.WM_USER + 74);
        internal const int EM_GETTEXTRANGE         = (NativeMethods.WM_USER + 75);
        internal const int EM_FINDWORDBREAK        = (NativeMethods.WM_USER + 76);
        internal const int EM_SETOPTIONS           = (NativeMethods.WM_USER + 77);
        internal const int EM_GETOPTIONS           = (NativeMethods.WM_USER + 78);
        internal const int EM_FINDTEXTEX           = (NativeMethods.WM_USER + 79);
        internal const int EM_GETWORDBREAKPROCEX   = (NativeMethods.WM_USER + 80);
        internal const int EM_SETWORDBREAKPROCEX   = (NativeMethods.WM_USER + 81);

        // Richedit v2.0 messages
        internal const int EM_SETUNDOLIMIT         = (NativeMethods.WM_USER + 82);
        internal const int EM_REDO                 = (NativeMethods.WM_USER + 84);
        internal const int EM_CANREDO              = (NativeMethods.WM_USER + 85);
        internal const int EM_GETUNDONAME          = (NativeMethods.WM_USER + 86);
        internal const int EM_GETREDONAME          = (NativeMethods.WM_USER + 87);
        internal const int EM_STOPGROUPTYPING      = (NativeMethods.WM_USER + 88);

        internal const int EM_SETTEXTMODE          = (NativeMethods.WM_USER + 89);
        internal const int EM_GETTEXTMODE          = (NativeMethods.WM_USER + 90);

        internal const int EM_AUTOURLDETECT        = (NativeMethods.WM_USER + 91);
        internal const int EM_GETAUTOURLDETECT     = (NativeMethods.WM_USER + 92);
        internal const int EM_SETPALETTE           = (NativeMethods.WM_USER + 93);
        internal const int EM_GETTEXTEX            = (NativeMethods.WM_USER + 94);
        internal const int EM_GETTEXTLENGTHEX      = (NativeMethods.WM_USER + 95);

        // Asia specific messages
        internal const int EM_SETPUNCTUATION       = (NativeMethods.WM_USER + 100);
        internal const int EM_GETPUNCTUATION       = (NativeMethods.WM_USER + 101);
        internal const int EM_SETWORDWRAPMODE      = (NativeMethods.WM_USER + 102);
        internal const int EM_GETWORDWRAPMODE      = (NativeMethods.WM_USER + 103);
        internal const int EM_SETIMECOLOR          = (NativeMethods.WM_USER + 104);
        internal const int EM_GETIMECOLOR          = (NativeMethods.WM_USER + 105);
        internal const int EM_SETIMEOPTIONS        = (NativeMethods.WM_USER + 106);
        internal const int EM_GETIMEOPTIONS        = (NativeMethods.WM_USER + 107);
        internal const int EM_CONVPOSITION         = (NativeMethods.WM_USER + 108);

        internal const int EM_SETLANGOPTIONS       = (NativeMethods.WM_USER + 120);
        internal const int EM_GETLANGOPTIONS       = (NativeMethods.WM_USER + 121);
        internal const int EM_GETIMECOMPMODE       = (NativeMethods.WM_USER + 122);

        internal const int EM_FINDTEXTW            = (NativeMethods.WM_USER + 123);
        internal const int EM_FINDTEXTEXW          = (NativeMethods.WM_USER + 124);

        //Rich TextBox 3.0 Asia msgs
        internal const int EM_RECONVERSION         = (NativeMethods.WM_USER + 125);
        internal const int EM_SETIMEMODEBIAS       = (NativeMethods.WM_USER + 126);
        internal const int EM_GETIMEMODEBIAS       = (NativeMethods.WM_USER + 127);

        // BiDi Specific messages
        internal const int EM_SETBIDIOPTIONS       = (NativeMethods.WM_USER + 200);
        internal const int EM_GETBIDIOPTIONS       = (NativeMethods.WM_USER + 201);

        internal const int EM_SETTYPOGRAPHYOPTIONS = (NativeMethods.WM_USER + 202);
        internal const int EM_GETTYPOGRAPHYOPTIONS = (NativeMethods.WM_USER + 203);

        // Extended TextBox style specific messages
        internal const int EM_SETEDITSTYLE         = (NativeMethods.WM_USER + 204);
        internal const int EM_GETEDITSTYLE         = (NativeMethods.WM_USER + 205);

        // Extended edit style masks
        internal const int SES_EMULATESYSEDIT      = 1;
        internal const int SES_BEEPONMAXTEXT       = 2;
        internal const int SES_EXTENDBACKCOLOR     = 4;
        internal const int SES_MAPCPS              = 8;
        internal const int SES_EMULATE10           = 16;
        internal const int SES_USECRLF             = 32;
        internal const int SES_USEAIMM             = 64;
        internal const int SES_NOIME               = 128;
        internal const int SES_ALLOWBEEPS          = 256;
        internal const int SES_UPPERCASE           = 512;
        internal const int SES_LOWERCASE           = 1024;
        internal const int SES_NOINPUTSEQUENCECHK  = 2048;
        internal const int SES_BIDI                = 4096;
        internal const int SES_SCROLLONKILLFOCUS   = 8192;
        internal const int SES_XLTCRCRLFTOCR       = 16384;

        // Options for EM_SETLANGOPTIONS and EM_GETLANGOPTIONS
        internal const int IMF_AUTOKEYBOARD        = 0x0001;
        internal const int IMF_AUTOFONT            = 0x0002;
        internal const int IMF_IMECANCELCOMPLETE   = 0x0004;   // high completes the comp string when aborting, low cancels.
        internal const int IMF_IMEALWAYSSENDNOTIFY = 0x0008;
        internal const int IMF_AUTOFONTSIZEADJUST  = 0x0010;
        internal const int IMF_UIFONTS             = 0x0020;
        internal const int IMF_DUALFONT            = 0x0080;

        // Values for EM_GETIMECOMPMODE
        internal const int ICM_NOTOPEN             = 0x0000;
        internal const int ICM_LEVEL3              = 0x0001;
        internal const int ICM_LEVEL2              = 0x0002;
        internal const int ICM_LEVEL2_5            = 0x0003;
        internal const int ICM_LEVEL2_SUI          = 0x0004;

        // Pegasus outline mode messages (RE 3.0)

        // Outline mode message
        internal const int EM_OUTLINE              = NativeMethods.WM_USER + 220;

        // Message for getting and restoring scroll pos
        internal const int EM_GETSCROLLPOS         = NativeMethods.WM_USER + 221;
        internal const int EM_SETSCROLLPOS         = NativeMethods.WM_USER + 222;

        // Change fontsize in current selection by wparam
        internal const int EM_SETFONTSIZE          = NativeMethods.WM_USER + 223;
        internal const int EM_GETZOOM              = NativeMethods.WM_USER + 224;
        internal const int EM_SETZOOM              = NativeMethods.WM_USER + 225;

        // Outline mode wparam values
        internal const int EMO_EXIT    = 0; // enter normal mode,  lparam ignored
        internal const int EMO_ENTER   = 1; // enter outline mode, lparam ignored
        internal const int EMO_PROMOTE = 2; // LOWORD(lparam) == 0 ==>
                                            // promote  to body-text
                                            // LOWORD(lparam) != 0 ==>
                                            // promote/demote current selection
                                            // by indicated number of levels
        internal const int EMO_EXPAND  = 3; // HIWORD(lparam) = EMO_EXPANDSELECTION
                                            // -> expands selection to level
                                            // indicated in LOWORD(lparam)
                                            // LOWORD(lparam) = -1/+1 corresponds
                                            // to collapse/expand button presses
                                            // in winword (other values are
                                            // equivalent to having pressed these
                                            // buttons more than once)
                                            // HIWORD(lparam) = EMO_EXPANDDOCUMENT
                                            // -> expands whole document to
                                            // indicated level
        internal const int EMO_MOVESELECTION = 4; // LOWORD(lparam) != 0 -> move current
                                                  // selection up/down by indicated
                                                  // amount
        internal const int EMO_GETVIEWMODE   = 5; // Returns VM_NORMAL or VM_OUTLINE

        // EMO_EXPAND options

        internal const int EMO_EXPANDSELECTION    = 0;
        internal const int EMO_EXPANDDOCUMENT     = 1;
        internal const int VM_NORMAL              = 4; // Agrees with RTF \viewkindN
        internal const int VM_OUTLINE             = 2;

        // New notifications
        internal const int EN_MSGFILTER            = 0x0700;
        internal const int EN_REQUESTRESIZE        = 0x0701;
        internal const int EN_SELCHANGE            = 0x0702;
        internal const int EN_DROPFILES            = 0x0703;
        internal const int EN_PROTECTED            = 0x0704;
        internal const int EN_CORRECTTEXT          = 0x0705;       /* PenWin specific */
        internal const int EN_STOPNOUNDO           = 0x0706;
        internal const int EN_IMECHANGE            = 0x0707;       /* Asia specific */
        internal const int EN_SAVECLIPBOARD        = 0x0708;
        internal const int EN_OLEOPFAILED          = 0x0709;
        internal const int EN_OBJECTPOSITIONS      = 0x070a;
        internal const int EN_LINK                 = 0x070b;
        internal const int EN_DRAGDROPDONE         = 0x070c;
        internal const int EN_PARAGRAPHEXPANDED    = 0x070d;

        // BiDi specific notifications
        internal const int EN_ALIGNLTR             = 0x0710;
        internal const int EN_ALIGNRTL             = 0x0711;

        // Event notification masks */
        internal const int ENM_NONE                = 0x00000000;
        internal const int ENM_CHANGE              = 0x00000001;
        internal const int ENM_UPDATE              = 0x00000002;
        internal const int ENM_SCROLL              = 0x00000004;
        internal const int ENM_KEYEVENTS           = 0x00010000;
        internal const int ENM_MOUSEEVENTS         = 0x00020000;
        internal const int ENM_REQUESTRESIZE       = 0x00040000;
        internal const int ENM_SELCHANGE           = 0x00080000;
        internal const int ENM_DROPFILES           = 0x00100000;
        internal const int ENM_PROTECTED           = 0x00200000;
        internal const int ENM_CORRECTTEXT         = 0x00400000;   /* PenWin specific */
        internal const int ENM_SCROLLEVENTS        = 0x00000008;
        internal const int ENM_DRAGDROPDONE        = 0x00000010;
        internal const int ENM_PARAGRAPHEXPANDED   = 0x00000020;

        /* Asia specific notification mask */
        internal const int ENM_IMECHANGE           = 0x00800000;   /* unused by RE2.0 */
        internal const int ENM_LANGCHANGE          = 0x01000000;
        internal const int ENM_OBJECTPOSITIONS     = 0x02000000;
        internal const int ENM_LINK                = 0x04000000;

        /* New edit control styles */
        internal const int ES_SAVESEL              = 0x00008000;
        internal const int ES_SUNKEN               = 0x00004000;
        internal const int ES_DISABLENOSCROLL      = 0x00002000;
        /* same as WS_MAXIMIZE, but that doesn't make sense so we re-use the value */
        internal const int ES_SELECTIONBAR         = 0x01000000;
        /* same as ES_UPPERCASE, but re-used to completely disable OLE drag'n'drop */
        internal const int ES_NOOLEDRAGDROP        = 0x00000008;

        /* New edit control extended style */
        internal const int ES_EX_NOCALLOLEINIT     = 0x01000000;

        /* These flags are used in FE Windows */
        internal const int ES_VERTICAL             = 0x00400000; // NOT IN RE3.0/2.0
        internal const int ES_NOIME                = 0x00080000;
        internal const int ES_SELFIME              = 0x00040000;

        /* TextBox control options */
        internal const int ECO_AUTOWORDSELECTION   = 0x00000001;
        internal const int ECO_AUTOVSCROLL         = 0x00000040;
        internal const int ECO_AUTOHSCROLL         = 0x00000080;
        internal const int ECO_NOHIDESEL           = 0x00000100;
        internal const int ECO_READONLY            = 0x00000800;
        internal const int ECO_WANTRETURN          = 0x00001000;
        internal const int ECO_SAVESEL             = 0x00008000;
        internal const int ECO_SELECTIONBAR        = 0x01000000; // guessing this is selection margin
        internal const int ECO_VERTICAL            = 0x00400000;   /* FE specific */


        /* ECO operations */
        internal const int ECOOP_SET               = 0x0001;
        internal const int ECOOP_OR                = 0x0002;
        internal const int ECOOP_AND               = 0x0003;
        internal const int ECOOP_XOR               = 0x0004;

        /* new word break function actions */
        internal const int WB_CLASSIFY             = 3;
        internal const int WB_MOVEWORDLEFT         = 4;
        internal const int WB_MOVEWORDRIGHT        = 5;
        internal const int WB_LEFTBREAK            = 6;
        internal const int WB_RIGHTBREAK           = 7;

        /* Asia specific flags */
        internal const int WB_MOVEWORDPREV         = 4;
        internal const int WB_MOVEWORDNEXT         = 5;
        internal const int WB_PREVBREAK            = 6;
        internal const int WB_NEXTBREAK            = 7;

        internal const int PC_FOLLOWING            = 1;
        internal const int PC_LEADING              = 2;
        internal const int PC_OVERFLOW             = 3;
        internal const int PC_DELIMITER            = 4;

        internal const int WBF_WORDWRAP            = 0x010;
        internal const int WBF_WORDBREAK           = 0x020;
        internal const int WBF_OVERFLOW            = 0x040;
        internal const int WBF_LEVEL1              = 0x080;
        internal const int WBF_LEVEL2              = 0x100;
        internal const int WBF_CUSTOM              = 0x200;

        /* for use with EM_GET/SETTEXTMODE */
        internal const int TM_PLAINTEXT                        = 1;
        internal const int TM_RICHTEXT                         = 2;    /* default behavior */
        internal const int TM_SINGLELEVELUNDO          = 4;
        internal const int TM_MULTILEVELUNDO           = 8;    /* default behavior */
        internal const int TM_SINGLECODEPAGE           = 16;
        internal const int TM_MULTICODEPAGE            = 32;   /* default behavior */

        /* Asia specific flags */
        internal const int IMF_FORCENONE           = 0x0001;
        internal const int IMF_FORCEENABLE         = 0x0002;
        internal const int IMF_FORCEDISABLE        = 0x0004;
        internal const int IMF_CLOSESTATUSWINDOW   = 0x0008;
        internal const int IMF_VERTICAL            = 0x0020;
        internal const int IMF_FORCEACTIVE         = 0x0040;
        internal const int IMF_FORCEINACTIVE       = 0x0080;
        internal const int IMF_FORCEREMEMBER       = 0x0100;
        internal const int IMF_MULTIPLEEDIT        = 0x0400;

        /* Word break flags (used with WB_CLASSIFY) */
        internal const int WBF_CLASS               = 0x0F;
        internal const int WBF_ISWHITE             = 0x10;
        internal const int WBF_BREAKLINE           = 0x20;
        internal const int WBF_BREAKAFTER          = 0x40;

        internal const int cchTextLimitDefault     = 32767;

        /* CHARFORMAT masks */
        internal const int CFM_BOLD                = 0x00000001;
        internal const int CFM_ITALIC              = 0x00000002;
        internal const int CFM_UNDERLINE           = 0x00000004;
        internal const int CFM_STRIKEOUT           = 0x00000008;
        internal const int CFM_PROTECTED           = 0x00000010;
        internal const int CFM_LINK                = 0x00000020;   /* Exchange hyperlink extension */
        internal const int CFM_SIZE                = unchecked((int)0x80000000);
        internal const int CFM_COLOR               = 0x40000000;
        internal const int CFM_FACE                = 0x20000000;
        internal const int CFM_OFFSET              = 0x10000000;
        internal const int CFM_CHARSET             = 0x08000000;

        /* CHARFORMAT effects */
        internal const int CFE_BOLD                = 0x0001;
        internal const int CFE_ITALIC              = 0x0002;
        internal const int CFE_UNDERLINE           = 0x0004;
        internal const int CFE_STRIKEOUT           = 0x0008;
        internal const int CFE_PROTECTED           = 0x0010;
        internal const int CFE_LINK                = 0x0020;
        internal const int CFE_AUTOCOLOR           = 0x40000000;   /* NOTE: this corresponds to */
                                                                 /* CFM_COLOR, which controls it */
        internal const int yHeightCharPtsMost      = 1638;

        /* EM_SETCHARFORMAT wparam masks */
        internal const int SCF_SELECTION           = 0x0001;
        internal const int SCF_WORD                = 0x0002;
        internal const int SCF_DEFAULT             = 0x0000;   // set the default charformat or paraformat
        internal const int SCF_ALL                 = 0x0004;   // not valid with SCF_SELECTION or SCF_WORD
        internal const int SCF_USEUIRULES          = 0x0008;   // modifier for SCF_SELECTION; says that
                                                                    // the format came from a toolbar, etc. and
                                                                    // therefore UI formatting rules should be
                                                                    // used instead of strictly formatting the
                                                                    // selection.

        /* stream formats */
        internal const int SF_TEXT = 0x0001;
        internal const int SF_RTF = 0x0002;
        internal const int SF_RTFNOOBJS = 0x0003; /* outbound only */
        internal const int SF_TEXTIZED = 0x0004;  /* outbound only */
        internal const int SF_UNICODE = 0x0010;   /* Unicode file of some kind */

        /* Flag telling stream operations to operate on the selection only */
        /* EM_STREAMIN will replace the current selection */
        /* EM_STREAMOUT will stream out the current selection */
        internal const int SFF_SELECTION           = 0x8000;

        /* Flag telling stream operations to operate on the common RTF keyword only */
        /* EM_STREAMIN will accept the only common RTF keyword */
        /* EM_STREAMOUT will stream out the only common RTF keyword */
        internal const int SFF_PLAINRTF            = 0x4000;

        /* all paragraph measurements are in twips */

        internal const int MAX_TAB_STOPS           = 32;
        internal const int lDefaultTab             = 720;

        /* PARAFORMAT mask values */
        internal const int PFM_STARTINDENT         = 0x00000001;
        internal const int PFM_RIGHTINDENT         = 0x00000002;
        internal const int PFM_OFFSET              = 0x00000004;
        internal const int PFM_ALIGNMENT           = 0x00000008;
        internal const int PFM_TABSTOPS            = 0x00000010;
        internal const int PFM_NUMBERING           = 0x00000020;
        internal const int PFM_OFFSETINDENT        = unchecked((int)0x80000000);

        /* PARAFORMAT numbering options */
        internal const int PFN_BULLET              = 0x0001;

        /* PARAFORMAT alignment options */
        internal const int PFA_LEFT                = 0x0001;
        internal const int PFA_RIGHT               = 0x0002;
        internal const int PFA_CENTER              = 0x0003;

        /* CHARFORMAT and PARAFORMAT "ALL" masks
           CFM_COLOR mirrors CFE_AUTOCOLOR, a little
           code to easily deal with autocolor */
        internal const int CFM_EFFECTS             = (CFM_BOLD | CFM_ITALIC |
                                                           CFM_UNDERLINE | CFM_COLOR |
                                                           CFM_STRIKEOUT | CFE_PROTECTED |
                                                           CFM_LINK);
        internal const int CFM_ALL                 = (CFM_EFFECTS | CFM_SIZE |
                                                           CFM_FACE | CFM_OFFSET | CFM_CHARSET);
        internal const int PFM_ALL                 = (PFM_STARTINDENT | PFM_RIGHTINDENT |
                                                           PFM_OFFSET | PFM_ALIGNMENT |
                                                           PFM_TABSTOPS | PFM_NUMBERING |
                                                           PFM_OFFSETINDENT);

        /* New masks and effects -- a parenthesized asterisk indicates that
           the data is stored by RichEdit2.0, but not displayed */

        internal const int CFM_SMALLCAPS           = 0x0040;                   /* (*)  */
        internal const int CFM_ALLCAPS             = 0x0080;                   /* (*)  */
        internal const int CFM_HIDDEN              = 0x0100;                   /* (*)  */
        internal const int CFM_OUTLINE             = 0x0200;                   /* (*)  */
        internal const int CFM_SHADOW              = 0x0400;                   /* (*)  */
        internal const int CFM_EMBOSS              = 0x0800;                   /* (*)  */
        internal const int CFM_IMPRINT             = 0x1000;                   /* (*)  */
        internal const int CFM_DISABLED            = 0x2000;
        internal const int CFM_REVISED             = 0x4000;

        internal const int CFM_BACKCOLOR           = 0x04000000;
        internal const int CFM_LCID                = 0x02000000;
        internal const int CFM_UNDERLINETYPE       = 0x00800000;               /* (*)  */
        internal const int CFM_WEIGHT              = 0x00400000;
        internal const int CFM_SPACING             = 0x00200000;               /* (*)  */
        internal const int CFM_KERNING             = 0x00100000;               /* (*)  */
        internal const int CFM_STYLE               = 0x00080000;               /* (*)  */
        internal const int CFM_ANIMATION           = 0x00040000;               /* (*)  */
        internal const int CFM_REVAUTHOR           = 0x00008000;

        internal const int CFE_SUBSCRIPT           = 0x00010000;               /* Superscript and subscript are */
        internal const int CFE_SUPERSCRIPT         = 0x00020000;               /*  mutually exclusive                   */

        internal const int CFM_SUBSCRIPT           = (CFE_SUBSCRIPT | CFE_SUPERSCRIPT);
        internal const int CFM_SUPERSCRIPT         = CFM_SUBSCRIPT;

        internal const int CFM_EFFECTS2            = (CFM_EFFECTS | CFM_DISABLED |
                                                           CFM_SMALLCAPS | CFM_ALLCAPS |
                                                           CFM_HIDDEN | CFM_OUTLINE |
                                                           CFM_SHADOW | CFM_EMBOSS |
                                                           CFM_IMPRINT | CFM_DISABLED |
                                                           CFM_REVISED | CFM_SUBSCRIPT |
                                                           CFM_SUPERSCRIPT | CFM_BACKCOLOR);

        internal const int CFM_ALL2                = (CFM_ALL | CFM_EFFECTS2 |
                                                           CFM_BACKCOLOR | CFM_LCID |
                                                           CFM_UNDERLINETYPE | CFM_WEIGHT |
                                                           CFM_REVAUTHOR | CFM_SPACING |
                                                           CFM_KERNING | CFM_STYLE |
                                                           CFM_ANIMATION);

        internal const int CFE_SMALLCAPS           = CFM_SMALLCAPS;
        internal const int CFE_ALLCAPS             = CFM_ALLCAPS;
        internal const int CFE_HIDDEN              = CFM_HIDDEN;
        internal const int CFE_OUTLINE             = CFM_OUTLINE;
        internal const int CFE_SHADOW              = CFM_SHADOW;
        internal const int CFE_EMBOSS              = CFM_EMBOSS;
        internal const int CFE_IMPRINT             = CFM_IMPRINT;
        internal const int CFE_DISABLED            = CFM_DISABLED;
        internal const int CFE_REVISED             = CFM_REVISED;

        /* NOTE: CFE_AUTOCOLOR and CFE_AUTOBACKCOLOR correspond to CFM_COLOR and
           CFM_BACKCOLOR, respectively, which control them */
        internal const int CFE_AUTOBACKCOLOR       = CFM_BACKCOLOR;

        /* Underline types */
        internal const int CFU_CF1UNDERLINE        = 0xFF; /* map charformat's bit underline to CF2.*/
        internal const int CFU_INVERT              = 0xFE; /* For IME composition fake a selection.*/
        internal const int CFU_UNDERLINEDOTTED     = 0x4;  /* (*) displayed as ordinary underline      */
        internal const int CFU_UNDERLINEDOUBLE     = 0x3;  /* (*) displayed as ordinary underline      */
        internal const int CFU_UNDERLINEWORD       = 0x2;  /* (*) displayed as ordinary underline      */
        internal const int CFU_UNDERLINE           = 0x1;
        internal const int CFU_UNDERLINENONE       = 0;

        /* PARAFORMAT 2.0 masks and effects */

        internal const int PFM_SPACEBEFORE         = 0x00000040;
        internal const int PFM_SPACEAFTER          = 0x00000080;
        internal const int PFM_LINESPACING         = 0x00000100;
        internal const int PFM_STYLE               = 0x00000400;
        internal const int PFM_BORDER              = 0x00000800;       /* (*)  */
        internal const int PFM_SHADING             = 0x00001000;       /* (*)  */
        internal const int PFM_NUMBERINGSTYLE      = 0x00002000;       /* (*)  */
        internal const int PFM_NUMBERINGTAB        = 0x00004000;       /* (*)  */
        internal const int PFM_NUMBERINGSTART      = 0x00008000;       /* (*)  */

        internal const int PFM_RTLPARA             = 0x00010000;
        internal const int PFM_KEEP                = 0x00020000;       /* (*)  */
        internal const int PFM_KEEPNEXT            = 0x00040000;       /* (*)  */
        internal const int PFM_PAGEBREAKBEFORE     = 0x00080000;       /* (*)  */
        internal const int PFM_NOLINENUMBER        = 0x00100000;       /* (*)  */
        internal const int PFM_NOWIDOWCONTROL      = 0x00200000;       /* (*)  */
        internal const int PFM_DONOTHYPHEN         = 0x00400000;       /* (*)  */
        internal const int PFM_SIDEBYSIDE          = 0x00800000;       /* (*)  */

        internal const int PFM_TABLE               = unchecked((int)0xc0000000);       /* (*)  */

        /* Note: PARAFORMAT has no effects */
        internal const int PFM_EFFECTS             = (PFM_RTLPARA | PFM_KEEP |
                                                           PFM_KEEPNEXT | PFM_TABLE |
                                                           PFM_PAGEBREAKBEFORE | PFM_NOLINENUMBER |
                                                           PFM_NOWIDOWCONTROL | PFM_DONOTHYPHEN |
                                                           PFM_SIDEBYSIDE | PFM_TABLE);

        internal const int PFM_ALL2                = (PFM_ALL | PFM_EFFECTS |
                                                           PFM_SPACEBEFORE | PFM_SPACEAFTER |
                                                           PFM_LINESPACING | PFM_STYLE |
                                                           PFM_SHADING | PFM_BORDER |
                                                           PFM_NUMBERINGTAB | PFM_NUMBERINGSTART |
                                                           PFM_NUMBERINGSTYLE);

        internal const int PFE_RTLPARA             = (PFM_RTLPARA               >> 16);
        internal const int PFE_KEEP                = (PFM_KEEP                  >> 16);        /* (*)  */
        internal const int PFE_KEEPNEXT            = (PFM_KEEPNEXT              >> 16);        /* (*)  */
        internal const int PFE_PAGEBREAKBEFORE     = (PFM_PAGEBREAKBEFORE >> 16);      /* (*)  */
        internal const int PFE_NOLINENUMBER        = (PFM_NOLINENUMBER  >> 16);        /* (*)  */
        internal const int PFE_NOWIDOWCONTROL      = (PFM_NOWIDOWCONTROL >> 16);       /* (*)  */
        internal const int PFE_DONOTHYPHEN         = (PFM_DONOTHYPHEN   >> 16);        /* (*)  */
        internal const int PFE_SIDEBYSIDE          = (PFM_SIDEBYSIDE    >> 16);        /* (*)  */

        internal const int PFE_TABLEROW            = 0xc000;           /* These 3 options are mutually */
        internal const int PFE_TABLECELLEND        = 0x8000;           /*  exclusive and each imply    */
        internal const int PFE_TABLECELL           = 0x4000;           /*  that para is part of a table*/

        /*
         *  PARAFORMAT numbering options (values for wNumbering):
         *
         *          Numbering Type          Value   Meaning
         *          tomNoNumbering            0             Turn off paragraph numbering
         *          tomNumberAsLCLetter       1             a, b, c, ...
         *          tomNumberAsUCLetter       2             A, B, C, ...
         *          tomNumberAsLCRoman        3             i, ii, iii, ...
         *          tomNumberAsUCRoman        4             I, II, III, ...
         *          tomNumberAsSymbols        5             default is bullet
         *          tomNumberAsNumber         6             0, 1, 2, ...
         *          tomNumberAsSequence       7             tomNumberingStart is first Unicode to use
         *
         *  Other valid Unicode chars are Unicodes for bullets.
         */
        internal const int PFA_JUSTIFY             = 4;        /* New paragraph-alignment option 2.0 (*) */

        internal const int SEL_EMPTY               = 0x0000;
        internal const int SEL_TEXT                = 0x0001;
        internal const int SEL_OBJECT              = 0x0002;
        internal const int SEL_MULTICHAR           = 0x0004;
        internal const int SEL_MULTIOBJECT         = 0x0008;

        /* used with IRichEditOleCallback::GetContextMenu, this flag will be
           passed as a "selection type".  It indicates that a context menu for
           a right-mouse drag drop should be generated.  The IOleObject parameter
           will really be the IDataObject for the drop
         */
        internal const int GCM_RIGHTMOUSEDROP      = 0x8000;

        internal const int OLEOP_DOVERB            = 1;

        /* clipboard formats - use as parameter to RegisterClipboardFormat() */
        internal const string CF_RTF               = "Rich Text Format";
        internal const string CF_RTFNOOBJS         = "Rich Text Format Without Objects";
        internal const string CF_RETEXTOBJ         = "RichEdit Text and Objects";

        /*  UndoName info */
        internal const int UID_UNKNOWN             = 0;
        internal const int UID_TYPING                  = 1;
        internal const int UID_DELETE                  = 2;
        internal const int UID_DRAGDROP                = 3;
        internal const int UID_CUT                             = 4;
        internal const int UID_PASTE                   = 5;

        /* flags for the GETEXTEX data structure */
        internal const int GT_DEFAULT              = 0;
        internal const int GT_USECRLF              = 1;

        /* flags for the GETTEXTLENGTHEX data structure */
        internal const int GTL_DEFAULT             = 0;        /* do the default (return # of chars)           */
        internal const int GTL_USECRLF             = 1;        /* compute answer using CRLFs for paragraphs*/
        internal const int GTL_PRECISE             = 2;        /* compute a precise answer                                     */
        internal const int GTL_CLOSE               = 4;        /* fast computation of a "close" answer         */
        internal const int GTL_NUMCHARS            = 8;        /* return the number of characters                      */
        internal const int GTL_NUMBYTES            = 16;       /* return the number of _bytes_                         */

        /* UNICODE embedding character */
        internal static readonly char WCH_EMBEDDING          = (char)0xFFFC;

        /* flags for the find text options */
        internal const int FR_DOWN                 = 0x00000001;
        internal const int FR_WHOLEWORD            = 0x00000002;
        internal const int FR_MATCHCASE            = 0x00000004;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\righttoleft.cs ===
//------------------------------------------------------------------------------
// <copyright file="RightToLeft.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {

    using System.Diagnostics;

    using System.Drawing;

    /// <include file='doc\RightToLeft.uex' path='docs/doc[@for="RightToLeft"]/*' />
    /// <devdoc>
    ///    <para>Specifies a value indicating whether the text appears
    ///       from right to
    ///       left, as when using Hebrew or Arabic fonts.</para>
    /// </devdoc>
    public enum RightToLeft {

        /// <include file='doc\RightToLeft.uex' path='docs/doc[@for="RightToLeft.No"]/*' />
        /// <devdoc>
        ///    <para>
        ///       
        ///       The
        ///       
        ///       text reads
        ///       
        ///       from left to right. This is the default.
        ///       
        ///    </para>
        /// </devdoc>
        No = 0,

        /// <include file='doc\RightToLeft.uex' path='docs/doc[@for="RightToLeft.Yes"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The text reads from
        ///       right to left.
        ///       
        ///    </para>
        /// </devdoc>
        Yes = 1,

        /// <include file='doc\RightToLeft.uex' path='docs/doc[@for="RightToLeft.Inherit"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The direction the
        ///       text appears in is inherited from the parent control.
        ///       
        ///    </para>
        /// </devdoc>
        Inherit = 2
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\scrollbar.cs ===
//------------------------------------------------------------------------------
// <copyright file="ScrollBar.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.InteropServices;
    using System.Runtime.Remoting;
    using System.Diagnostics;

    using System;
    using System.Security.Permissions;
    
    using System.Windows.Forms;
    using System.ComponentModel;
    using System.Drawing;
    using Microsoft.Win32;


    /// <include file='doc\ScrollBar.uex' path='docs/doc[@for="ScrollBar"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Implements the basic functionality of a scroll bar control.
    ///    </para>
    /// </devdoc>
    [
    DefaultProperty("Value"),
    DefaultEvent("Scroll"),
    ]
    public abstract class ScrollBar : Control {

        private static readonly object EVENT_SCROLL = new object();
        private static readonly object EVENT_VALUECHANGED = new object();

        private int minimum = 0;
        private int maximum = 100;
        private int smallChange = 1;
        private int largeChange = 10;
        private int value = 0;

        /// <include file='doc\ScrollBar.uex' path='docs/doc[@for="ScrollBar.ScrollBar"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Windows.Forms.ScrollBar'/>
        ///       class.
        ///       
        ///    </para>
        /// </devdoc>
        public ScrollBar()
        : base() {
            SetStyle(ControlStyles.UserPaint, false);
            SetStyle(ControlStyles.StandardClick, false);
            TabStop = false;
        }



        /// <include file='doc\ScrollBar.uex' path='docs/doc[@for="ScrollBar.BackColor"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override Color BackColor {
            get {
                return base.BackColor;
            }
            set {
                base.BackColor = value;
            }
        }

        /// <include file='doc\ScrollBar.uex' path='docs/doc[@for="ScrollBar.BackColorChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler BackColorChanged {
            add {
                base.BackColorChanged += value;
            }
            remove {
                base.BackColorChanged -= value;
            }
        }

        /// <include file='doc\ScrollBar.uex' path='docs/doc[@for="ScrollBar.BackgroundImage"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override Image BackgroundImage {
            get {
                return base.BackgroundImage;
            }
            set {
                base.BackgroundImage = value;
            }
        }
        
        /// <include file='doc\ScrollBar.uex' path='docs/doc[@for="ScrollBar.BackgroundImageChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler BackgroundImageChanged {
            add {
                base.BackgroundImageChanged += value;
            }
            remove {
                base.BackgroundImageChanged -= value;
            }
        }

        /// <include file='doc\ScrollBar.uex' path='docs/doc[@for="ScrollBar.CreateParams"]/*' />
        /// <devdoc>
        ///     Retrieves the parameters needed to create the handle.  Inheriting classes
        ///     can override this to provide extra functionality.  They should not,
        ///     however, forget to call base.getCreateParams() first to get the struct
        ///     filled up with the basic info.
        /// </devdoc>
        /// <internalonly/>
        protected override CreateParams CreateParams {
            [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
            get {
                CreateParams cp = base.CreateParams;
                cp.ClassName = "SCROLLBAR";
                cp.Style &= (~NativeMethods.WS_BORDER);
                return cp;
            }
        }
        
        /// <include file='doc\ScrollBar.uex' path='docs/doc[@for="ScrollBar.DefaultImeMode"]/*' />
        protected override ImeMode DefaultImeMode {
            get {
                return ImeMode.Disable;
            }
        }

        /// <include file='doc\ScrollBar.uex' path='docs/doc[@for="ScrollBar.ForeColor"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the foreground color of the scroll bar control.
        ///    </para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override Color ForeColor {
            get {
                return base.ForeColor;
            }
            set {
                base.ForeColor = value;
            }
        }

        /// <include file='doc\ScrollBar.uex' path='docs/doc[@for="ScrollBar.ForeColorChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler ForeColorChanged {
            add {
                base.ForeColorChanged += value;
            }
            remove {
                base.ForeColorChanged -= value;
            }
        }

        /// <include file='doc\ScrollBar.uex' path='docs/doc[@for="ScrollBar.Font"]/*' />
        /// <internalonly/><hideinheritance/>
        /// <devdoc>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override Font Font {
            get {
                return base.Font;
            }
            set {
                base.Font = value;
            }
        }
        
        /// <include file='doc\ScrollBar.uex' path='docs/doc[@for="ScrollBar.FontChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler FontChanged {
            add {
                base.FontChanged += value;
            }
            remove {
                base.FontChanged -= value;
            }
        }

        /// <include file='doc\ScrollBar.uex' path='docs/doc[@for="ScrollBar.ImeMode"]/*' />
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public ImeMode ImeMode {
            get {
                return base.ImeMode;
            }
            set {
                base.ImeMode = value;
            }
        }

        /// <include file='doc\ScrollBar.uex' path='docs/doc[@for="ScrollBar.ImeModeChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event EventHandler ImeModeChanged {
            add {
                base.ImeModeChanged += value;
            }
            remove {
                base.ImeModeChanged -= value;
            }
        }

        /// <include file='doc\ScrollBar.uex' path='docs/doc[@for="ScrollBar.LargeChange"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value to be added or subtracted to the <see cref='System.Windows.Forms.ScrollBar.Value'/>
        ///       property when the scroll box is moved a large distance.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(10),
        SRDescription(SR.ScrollBarLargeChangeDescr),
        RefreshProperties(RefreshProperties.Repaint)
        ]
        public int LargeChange {
            get {
                // We preserve the actual large change value that has been set, but when we come to
                // get the value of this property, make sure it's within the maximum allowable value.
                // This way we ensure that we don't depend on the order of property sets when
                // code is generated at design-time.
                //
                return Math.Min(largeChange, maximum - minimum + 1);                
            }
            set {
                if (largeChange != value) {
                
                    if (value < 0) {                
                        throw new ArgumentException(SR.GetString(SR.InvalidLowBoundArgumentEx,
                                                                  "LargeChange", (value).ToString(),
                                                                  "0"));
                    }
                
                    largeChange = value;
                    UpdateScrollInfo();
                }
            }
        }

        /// <include file='doc\ScrollBar.uex' path='docs/doc[@for="ScrollBar.Maximum"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the upper limit of values of the scrollable range.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(100),
        SRDescription(SR.ScrollBarMaximumDescr),
        RefreshProperties(RefreshProperties.Repaint)
        ]
        public int Maximum {
            get {
                return maximum;
            }
            set {
                if (maximum != value) {
                    if (minimum > value)
                        minimum = value;
                    // bring this.value in line.
                    if (value < this.value)
                        Value = value;
                    maximum = value;
                    UpdateScrollInfo();
                }
            }
        }

        /// <include file='doc\ScrollBar.uex' path='docs/doc[@for="ScrollBar.Minimum"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the lower limit of values of the scrollable range.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(0),
        SRDescription(SR.ScrollBarMinimumDescr),
        RefreshProperties(RefreshProperties.Repaint)
        ]
        public int Minimum {
            get {
                return minimum;
            }
            set {
                if (minimum != value) {
                    if (maximum < value)
                        maximum = value;
                    // bring this.value in line.
                    if (value > this.value)
                        this.value = value;
                    minimum = value;
                    UpdateScrollInfo();
                }
            }
        }

        /// <include file='doc\ScrollBar.uex' path='docs/doc[@for="ScrollBar.SmallChange"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the value to be added or subtracted to the
        ///    <see cref='System.Windows.Forms.ScrollBar.Value'/> 
        ///    property when the scroll box is
        ///    moved a small distance.
        /// </para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(1),
        SRDescription(SR.ScrollBarSmallChangeDescr)
        ]
        public int SmallChange {
            get {
                // We can't have SmallChange > LargeChange, but we shouldn't manipulate
                // the set values for these properties, so we just return the smaller 
                // value here. 
                //
                return Math.Min(smallChange, LargeChange);
            }
            set {
                if (smallChange != value) {
                
                    if (value < 0) {                
                        throw new ArgumentException(SR.GetString(SR.InvalidLowBoundArgumentEx,
                                                                  "SmallChange", (value).ToString(),
                                                                  "0"));
                    }
                
                    smallChange = value;
                    UpdateScrollInfo();
                }
            }
        }

        /// <include file='doc\ScrollBar.uex' path='docs/doc[@for="ScrollBar.TabStop"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        [DefaultValue(false)]
        new public bool TabStop {
            get {
                return base.TabStop;
            }
            set {
                base.TabStop = value;
            }
        }

        /// <include file='doc\ScrollBar.uex' path='docs/doc[@for="ScrollBar.Text"]/*' />
        /// <internalonly/>        
        /// <devdoc>
        /// </devdoc>
        [
        Browsable(false), EditorBrowsable(EditorBrowsableState.Never), 
        Bindable(false), 
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]                
        public override string Text {
            get {
                return base.Text;
            }
            set {
                base.Text = value;
            }
        }

        /// <include file='doc\ScrollBar.uex' path='docs/doc[@for="ScrollBar.TextChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler TextChanged {
            add {
                base.TextChanged += value;
            }
            remove {
                base.TextChanged -= value;
            }
        }
        
        /// <include file='doc\ScrollBar.uex' path='docs/doc[@for="ScrollBar.Value"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a numeric value that represents the current
        ///       position of the scroll box
        ///       on
        ///       the scroll bar control.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(0),
        Bindable(true),
        SRDescription(SR.ScrollBarValueDescr)
        ]
        public int Value {
            get {
                return value;
            }
            set {
                if (this.value != value) {
                    if (value < minimum || value > maximum) {
                        throw new ArgumentException(SR.GetString(SR.InvalidBoundArgument,
                                                                  "value", (value).ToString(),
                                                                  "'minimum'", "'maximum'"));
                    }
                    this.value = value;
                    UpdateScrollInfo();
                    OnValueChanged(EventArgs.Empty);
                }
            }
        }
         
        /// <include file='doc\ScrollBar.uex' path='docs/doc[@for="ScrollBar.Click"]/*' />
        /// <internalonly/><hideinheritance/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event EventHandler Click {
            add {
                base.Click += value;
            }
            remove {
                base.Click -= value;
            }
        }
        
        /// <include file='doc\ScrollBar.uex' path='docs/doc[@for="ScrollBar.OnPaint"]/*' />
        /// <devdoc>
        ///     ScrollBar Onpaint.
        /// </devdoc>
        /// <internalonly/><hideinheritance/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event PaintEventHandler Paint {
            add {
                base.Paint += value;
            }
            remove {
                base.Paint -= value;
            }
        }

        /// <include file='doc\ScrollBar.uex' path='docs/doc[@for="ScrollBar.DoubleClick"]/*' />
        /// <internalonly/><hideinheritance/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event EventHandler DoubleClick {
            add {
                base.DoubleClick += value;
            }
            remove {
                base.DoubleClick -= value;
            }
        }

        /// <include file='doc\ScrollBar.uex' path='docs/doc[@for="ScrollBar.MouseDown"]/*' />
        /// <internalonly/><hideinheritance/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event MouseEventHandler MouseDown {
            add {
                base.MouseDown += value;
            }
            remove {
                base.MouseDown -= value;
            }
        }

        /// <include file='doc\ScrollBar.uex' path='docs/doc[@for="ScrollBar.MouseUp"]/*' />
        /// <internalonly/><hideinheritance/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event MouseEventHandler MouseUp {
            add {
                base.MouseUp += value;
            }
            remove {
                base.MouseUp -= value;
            }
        }

        /// <include file='doc\ScrollBar.uex' path='docs/doc[@for="ScrollBar.MouseMove"]/*' />
        /// <internalonly/><hideinheritance/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event MouseEventHandler MouseMove {
            add {
                base.MouseMove += value;
            }
            remove {
                base.MouseMove -= value;
            }
        }

        /// <include file='doc\ScrollBar.uex' path='docs/doc[@for="ScrollBar.Scroll"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Occurs when the scroll box has
        ///       been
        ///       moved by either a mouse or keyboard action.
        ///    </para>
        /// </devdoc>
        [SRCategory(SR.CatAction), SRDescription(SR.ScrollBarOnScrollDescr)]
        public event ScrollEventHandler Scroll {
            add {
                Events.AddHandler(EVENT_SCROLL, value);
            }
            remove {
                Events.RemoveHandler(EVENT_SCROLL, value);
            }
        }

        /// <include file='doc\ScrollBar.uex' path='docs/doc[@for="ScrollBar.ValueChanged"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Occurs when the <see cref='System.Windows.Forms.ScrollBar.Value'/> property has changed, either by a
        ///    <see cref='System.Windows.Forms.ScrollBar.OnScroll'/> event or programatically.
        ///    </para>
        /// </devdoc>
        [SRCategory(SR.CatAction), SRDescription(SR.valueChangedEventDescr)]
        public event EventHandler ValueChanged {
            add {
                Events.AddHandler(EVENT_VALUECHANGED, value);
            }
            remove {
                Events.RemoveHandler(EVENT_VALUECHANGED, value);
            }
        }

        internal override IntPtr InitializeDCForWmCtlColor(IntPtr dc, int msg) {
            return IntPtr.Zero;
        }

        /// <include file='doc\ScrollBar.uex' path='docs/doc[@for="ScrollBar.OnEnabledChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnEnabledChanged(EventArgs e) {
            if (Enabled) {
                UpdateScrollInfo();
            }
            base.OnEnabledChanged(e);
        }

        /// <include file='doc\ScrollBar.uex' path='docs/doc[@for="ScrollBar.OnHandleCreated"]/*' />
        /// <devdoc>
        ///     Creates the handle.  overridden to help set up scrollbar information.
        /// </devdoc>
        /// <internalonly/>
        protected override void OnHandleCreated(EventArgs e) {
            base.OnHandleCreated(e);
            UpdateScrollInfo();
        }

        /// <include file='doc\ScrollBar.uex' path='docs/doc[@for="ScrollBar.OnScroll"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Windows.Forms.ScrollBar.ValueChanged'/> event.
        ///    </para>
        /// </devdoc>
        protected virtual void OnScroll(ScrollEventArgs se) {
            ScrollEventHandler handler = (ScrollEventHandler)Events[EVENT_SCROLL];
            if (handler != null) handler(this,se);
        }

        /// <include file='doc\ScrollBar.uex' path='docs/doc[@for="ScrollBar.OnValueChanged"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Windows.Forms.ScrollBar.ValueChanged'/> event.
        ///    </para>
        /// </devdoc>
        protected virtual void OnValueChanged(EventArgs e) {
            EventHandler handler = (EventHandler)Events[EVENT_VALUECHANGED];
            if (handler != null) handler(this,e);
        }

        // Reflects the position of the scrollbar
        private int ReflectPosition(int position) {
            if (this is HScrollBar) {
                return minimum + (maximum - LargeChange + 1) - position;
            }
            return position;
        }
        
        /// <include file='doc\ScrollBar.uex' path='docs/doc[@for="ScrollBar.ToString"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        public override string ToString() {
            string s = base.ToString();
            return s + ", Minimum: " + Minimum.ToString() + ", Maximum: " + Maximum.ToString() + ", Value: " + Value.ToString();
        }

        /// <include file='doc\ScrollBar.uex' path='docs/doc[@for="ScrollBar.UpdateScrollInfo"]/*' />
        /// <devdoc>
        ///     Internal helper method
        /// </devdoc>
        /// <internalonly/>
        protected void UpdateScrollInfo() {
            if (IsHandleCreated && Enabled) {
            
                NativeMethods.SCROLLINFO si = new NativeMethods.SCROLLINFO();
                si.cbSize = Marshal.SizeOf(typeof(NativeMethods.SCROLLINFO));
                si.fMask = NativeMethods.SIF_ALL;
                si.nMin = minimum;
                si.nMax = maximum;
                si.nPage = LargeChange;
                
                if (RightToLeft == RightToLeft.Yes) {
                    // Reflect the scrollbar position horizontally on an Rtl system
                    si.nPos = ReflectPosition(value);
                }
                else {
                    si.nPos = value;
                }
                
                si.nTrackPos = 0;

                UnsafeNativeMethods.SetScrollInfo(new HandleRef(this, Handle), NativeMethods.SB_CTL, si, true);
            }
        }


        /// <include file='doc\ScrollBar.uex' path='docs/doc[@for="ScrollBar.WmReflectScroll"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        private void WmReflectScroll(ref Message m) {

            ScrollEventType id = (ScrollEventType)NativeMethods.Util.LOWORD(m.WParam);
            
            // For Rtl systems we need to swap increment and decrement
            //
            if (RightToLeft == RightToLeft.Yes) {
                switch (id) {
                    case ScrollEventType.First:
                        id = ScrollEventType.Last;
                        break;

                    case ScrollEventType.Last:
                        id = ScrollEventType.First;
                        break;

                    case ScrollEventType.SmallDecrement:
                        id = ScrollEventType.SmallIncrement;
                        break;

                    case ScrollEventType.SmallIncrement:
                        id = ScrollEventType.SmallDecrement;
                        break;

                    case ScrollEventType.LargeDecrement:
                        id = ScrollEventType.LargeIncrement;
                        break;

                    case ScrollEventType.LargeIncrement:
                        id = ScrollEventType.LargeDecrement;
                        break;
                }
            }
            
            int newValue = value;

            // The ScrollEventArgs constants are defined in terms of the windows
            // messages..  this eliminates confusion between the VSCROLL and
            // HSCROLL constants, which are identical.
            //
            switch (id) {
                case ScrollEventType.First:
                    newValue = minimum;
                    break;

                case ScrollEventType.Last:
                    newValue = maximum - LargeChange + 1; // si.nMax - si.nPage + 1;
                    break;

                case ScrollEventType.SmallDecrement:
                    newValue = Math.Max(value - SmallChange, minimum);
                    break;

                case ScrollEventType.SmallIncrement:
                    newValue = Math.Min(value + SmallChange, maximum - LargeChange + 1); // max - lChange + 1);
                    break;

                case ScrollEventType.LargeDecrement:
                    newValue = Math.Max(value - LargeChange, minimum);
                    break;

                case ScrollEventType.LargeIncrement:
                    newValue = Math.Min(value + LargeChange, maximum - LargeChange + 1); // si.nPos + si.nPage,si.nMax - si.nPage + 1);
                    break;

                case ScrollEventType.ThumbPosition:
                case ScrollEventType.ThumbTrack:
                    NativeMethods.SCROLLINFO si = new NativeMethods.SCROLLINFO();
                    si.fMask = NativeMethods.SIF_TRACKPOS;
                    SafeNativeMethods.GetScrollInfo(new HandleRef(this, Handle), NativeMethods.SB_CTL, si);
                    
                    if (RightToLeft == RightToLeft.Yes) {
                        newValue = ReflectPosition(si.nTrackPos);
                    }
                    else {
                        newValue = si.nTrackPos;
                    }
                    
                    break;
            }

            ScrollEventArgs se = new ScrollEventArgs(id, newValue);
            OnScroll(se);
            Value = se.NewValue;
        }

        /// <include file='doc\ScrollBar.uex' path='docs/doc[@for="ScrollBar.WndProc"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        protected override void WndProc(ref Message m) {
            switch (m.Msg) {
                case NativeMethods.WM_REFLECT + NativeMethods.WM_HSCROLL:
                case NativeMethods.WM_REFLECT + NativeMethods.WM_VSCROLL:
                    WmReflectScroll(ref m);
                    break;
                case NativeMethods.WM_ERASEBKGND:
                    break;

                case NativeMethods.WM_SIZE:
                    //VS7#13707 : FredB, 4/26/1999 - Fixes the scrollbar focus rect
                    if (UnsafeNativeMethods.GetFocus() == this.Handle) {
                        DefWndProc(ref m);
                        SendMessage(NativeMethods.WM_KILLFOCUS, 0, 0);
                        SendMessage(NativeMethods.WM_SETFOCUS, 0, 0);
                    }
                    break;

                default:
                    base.WndProc(ref m);
                    break;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\screen.cs ===
//------------------------------------------------------------------------------
// <copyright file="Screen.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

namespace System.Windows.Forms {
    using System.Threading;
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;
    using System.Drawing;
    using System.Windows.Forms;
    using System.Collections;
    using Microsoft.Win32;

    /// <include file='doc\Screen.uex' path='docs/doc[@for="Screen"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a display device or
    ///       multiple display devices on a single system.
    ///    </para>
    /// </devdoc>
    public class Screen {

        readonly IntPtr hmonitor;
        /// <devdoc>         
        ///     Bounds of the screen         
        /// </devdoc>         
        readonly Rectangle    bounds;
        /// <devdoc>         
        ///     Available working area on the screen. This excludes taskbars and other         
        ///     docked windows.         
        /// </devdoc>         
        readonly Rectangle    workingArea;
        /// <devdoc>         
        ///     Set to true if this screen is the primary monitor         
        /// </devdoc>         
        readonly bool         primary;
        /// <devdoc>         
        ///     Device name associated with this monitor         
        /// </devdoc>         
        readonly string       deviceName;

        readonly int          bitDepth;

        // This identifier is just for us, so that we don't try to call the multimon
        // functions if we just need the primary monitor... this is safer for
        // non-multimon OSes.
        //
        private const int PRIMARY_MONITOR = unchecked((int)0xBAADF00D);

        private const int MONITOR_DEFAULTTONULL       = 0x00000000;
        private const int MONITOR_DEFAULTTOPRIMARY    = 0x00000001;
        private const int MONITOR_DEFAULTTONEAREST    = 0x00000002;
        private const int MONITORINFOF_PRIMARY        = 0x00000001;

        private static bool multiMonitorSupport = (UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_CMONITORS) != 0);
        private static Screen[] screens;

        internal Screen(IntPtr monitor) : this(monitor, IntPtr.Zero) {
        }

        internal Screen(IntPtr monitor, IntPtr hdc) {

            IntPtr screenDC = hdc;

            if (!multiMonitorSupport || monitor == (IntPtr)PRIMARY_MONITOR) {
                // Single monitor system
                //
                bounds = SystemInformation.VirtualScreen;
                workingArea = SystemInformation.WorkingArea;
                primary = true;
                deviceName = "DISPLAY";
            }
            else {
                // MultiMonitor System
                // We call the 'A' version of GetMonitorInfoA() because
                // the 'W' version just never fills out the struct properly on Win2K.
                //
                NativeMethods.MONITORINFOEX info = new NativeMethods.MONITORINFOEX();
                SafeNativeMethods.GetMonitorInfo(new HandleRef(null, monitor), info);
                bounds = Rectangle.FromLTRB(info.rcMonitor.left, info.rcMonitor.top, info.rcMonitor.right, info.rcMonitor.bottom);
                workingArea = Rectangle.FromLTRB(info.rcWork.left, info.rcWork.top, info.rcWork.right, info.rcWork.bottom);
                primary = ((info.dwFlags & MONITORINFOF_PRIMARY) != 0);
                int count = info.szDevice.Length;
                while (count > 0 && info.szDevice[count - 1] == (char)0) {
                    count--;
                }

                deviceName = new string(info.szDevice);
                deviceName = deviceName.TrimEnd((char)0);

                if (hdc == IntPtr.Zero) {
                    screenDC = UnsafeNativeMethods.CreateDC(deviceName);
                }

            }
            hmonitor = monitor;

            this.bitDepth = UnsafeNativeMethods.GetDeviceCaps(new HandleRef(null, screenDC), NativeMethods.BITSPIXEL);
            this.bitDepth *= UnsafeNativeMethods.GetDeviceCaps(new HandleRef(null, screenDC), NativeMethods.PLANES);

            if (hdc != screenDC) {
                UnsafeNativeMethods.DeleteDC(new HandleRef(null, screenDC));
            }
        }

        /// <include file='doc\Screen.uex' path='docs/doc[@for="Screen.AllScreens"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets an array of all of the displays on the system.
        ///    </para>
        /// </devdoc>
        public static Screen[] AllScreens {
            get {
                if (screens == null) {
                    if (multiMonitorSupport) {
                        MonitorEnumCallback closure = new MonitorEnumCallback();
                        NativeMethods.MonitorEnumProc proc = new NativeMethods.MonitorEnumProc(closure.Callback);
                        IntPtr hdc = UnsafeNativeMethods.GetDC(NativeMethods.NullHandleRef);
                        try {
                            SafeNativeMethods.EnumDisplayMonitors(new HandleRef(null, hdc), null, proc, IntPtr.Zero);
                        }
                        finally {
                            UnsafeNativeMethods.ReleaseDC(NativeMethods.NullHandleRef, new HandleRef(null, hdc));
                        }

                        if (closure.screens.Count > 0) {
                            Screen[] temp = new Screen[closure.screens.Count];
                            closure.screens.CopyTo(temp, 0);
                            screens = temp;
                        }
                        else {
                            screens = new Screen[] {new Screen((IntPtr)PRIMARY_MONITOR)};
                        }
                    }
                    else {
                        screens = new Screen[] {PrimaryScreen};
                    }

                    // Now that we have our screens, attach a display setting changed
                    // event so that we know when to invalidate them.
                    //
                    SystemEvents.DisplaySettingsChanged += new EventHandler(OnDisplaySettingsChanged);
                }

                return screens;
            }
        }

        internal int BitDepth {
            get {
                return bitDepth;
            }
        }

        /// <include file='doc\Screen.uex' path='docs/doc[@for="Screen.Bounds"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the bounds of the display.
        ///    </para>
        /// </devdoc>
        public Rectangle Bounds {
            get {
                return bounds;
            }
        }

        /// <include file='doc\Screen.uex' path='docs/doc[@for="Screen.DeviceName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the device name associated with a display.
        ///    </para>
        /// </devdoc>
        public string DeviceName {
            get {
                return deviceName;
            }
        }

        /// <include file='doc\Screen.uex' path='docs/doc[@for="Screen.Primary"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether a particular display is
        ///       the primary device.
        ///    </para>
        /// </devdoc>
        public bool Primary {
            get {
                return primary;
            }
        }

        /// <include file='doc\Screen.uex' path='docs/doc[@for="Screen.PrimaryScreen"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the
        ///       primary display.
        ///    </para>
        /// </devdoc>
        public static Screen PrimaryScreen {
            get {
                if (multiMonitorSupport) {
                    Screen[] screens = AllScreens;
                    for (int i=0; i<screens.Length; i++) {
                        if (screens[i].primary) {
                            return screens[i];
                        }
                    }
                    return null;
                }
                else {
                    return new Screen((IntPtr)PRIMARY_MONITOR, IntPtr.Zero);
                }
            }
        }

        /// <include file='doc\Screen.uex' path='docs/doc[@for="Screen.WorkingArea"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the working area of the screen.
        ///    </para>
        /// </devdoc>
        public Rectangle WorkingArea {
            get {
                return workingArea;
            }
        }

        /// <include file='doc\Screen.uex' path='docs/doc[@for="Screen.Equals"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies a value that indicates whether the specified object is equal to
        ///       this one.
        ///    </para>
        /// </devdoc>
        public override bool Equals(object obj) {
            if (obj is Screen) {
                Screen comp = (Screen)obj;
                if (hmonitor == comp.hmonitor) {
                    return true;
                }
            }
            return false;
        }

        /// <include file='doc\Screen.uex' path='docs/doc[@for="Screen.FromPoint"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Retrieves a <see cref='System.Windows.Forms.Screen'/>
        ///       for the monitor that contains the specified point.
        ///       
        ///    </para>
        /// </devdoc>
        public static Screen FromPoint(Point point) {
            if (multiMonitorSupport) {
                return new Screen(SafeNativeMethods.MonitorFromPoint(point.X, point.Y, MONITOR_DEFAULTTONEAREST));
            }
            else {
                return new Screen((IntPtr)PRIMARY_MONITOR);
            }
        }

        /// <include file='doc\Screen.uex' path='docs/doc[@for="Screen.FromRectangle"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Retrieves a <see cref='System.Windows.Forms.Screen'/>
        ///       for the monitor that contains the
        ///       largest region of the rectangle.
        ///       
        ///    </para>
        /// </devdoc>
        public static Screen FromRectangle(Rectangle rect) {
            if (multiMonitorSupport) {
                NativeMethods.RECT rc = NativeMethods.RECT.FromXYWH(rect.X, rect.Y, rect.Width, rect.Height);
                return new Screen(SafeNativeMethods.MonitorFromRect(ref rc, MONITOR_DEFAULTTONEAREST));
            }
            else {
                return new Screen((IntPtr)PRIMARY_MONITOR, IntPtr.Zero);
            }
        }

        /// <include file='doc\Screen.uex' path='docs/doc[@for="Screen.FromControl"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Retrieves a <see cref='System.Windows.Forms.Screen'/>
        ///       for the monitor that contains the largest
        ///       region of the window of the control.
        ///    </para>
        /// </devdoc>
        public static Screen FromControl(Control control) {
            return FromHandleInternal(control.Handle);
        }

        /// <include file='doc\Screen.uex' path='docs/doc[@for="Screen.FromHandle"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Retrieves a <see cref='System.Windows.Forms.Screen'/>
        ///       for the monitor that
        ///       contains the largest region of the window.
        ///    </para>
        /// </devdoc>
        public static Screen FromHandle(IntPtr hwnd) {
            Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "ObjectFromWin32Handle Demanded");
            IntSecurity.ObjectFromWin32Handle.Demand();
            return FromHandleInternal(hwnd);
        }

        internal static Screen FromHandleInternal(IntPtr hwnd) {
            if (multiMonitorSupport) {
                return new Screen(SafeNativeMethods.MonitorFromWindow(new HandleRef(null, hwnd), MONITOR_DEFAULTTONEAREST));
            }
            else {
                return new Screen((IntPtr)PRIMARY_MONITOR, IntPtr.Zero);
            }
        }

        /// <include file='doc\Screen.uex' path='docs/doc[@for="Screen.GetWorkingArea"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Retrieves the working area for the monitor that is closest to the
        ///       specified point.
        ///       
        ///    </para>
        /// </devdoc>
        public static Rectangle GetWorkingArea(Point pt) {
            return Screen.FromPoint(pt).WorkingArea;
        }
        /// <include file='doc\Screen.uex' path='docs/doc[@for="Screen.GetWorkingArea1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Retrieves the working area for the monitor that contains the largest region
        ///       of the specified rectangle.
        ///       
        ///    </para>
        /// </devdoc>
        public static Rectangle GetWorkingArea(Rectangle rect) {
            return Screen.FromRectangle(rect).WorkingArea;
        }
        /// <include file='doc\Screen.uex' path='docs/doc[@for="Screen.GetWorkingArea2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Retrieves the working area for the monitor that contains the largest
        ///       region of the specified control.
        ///       
        ///    </para>
        /// </devdoc>
        public static Rectangle GetWorkingArea(Control ctl) {
            return Screen.FromControl(ctl).WorkingArea;
        }

        /// <include file='doc\Screen.uex' path='docs/doc[@for="Screen.GetBounds"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Retrieves the bounds of the monitor that is closest to the specified
        ///       point.
        ///    </para>
        /// </devdoc>
        public static Rectangle GetBounds(Point pt) {
            return Screen.FromPoint(pt).Bounds;
        }
        /// <include file='doc\Screen.uex' path='docs/doc[@for="Screen.GetBounds1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Retrieves the bounds of the monitor that contains the largest region of the
        ///       specified rectangle.
        ///    </para>
        /// </devdoc>
        public static Rectangle GetBounds(Rectangle rect) {
            return Screen.FromRectangle(rect).Bounds;
        }
        /// <include file='doc\Screen.uex' path='docs/doc[@for="Screen.GetBounds2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Retrieves the bounds of the monitor
        ///       that contains the largest region of the specified control.
        ///    </para>
        /// </devdoc>
        public static Rectangle GetBounds(Control ctl) {
            return Screen.FromControl(ctl).Bounds;
        }

        /// <include file='doc\Screen.uex' path='docs/doc[@for="Screen.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Computes and retrieves a hash code for an object.
        ///    </para>
        /// </devdoc>
        public override int GetHashCode() {
            return(int)hmonitor;
        }

        /// <devdoc>
        ///     Called by the SystemEvents class when our display settings have
        ///     changed.  We cache screen information and at this point we must
        ///     invalidate our cache.
        /// </devdoc>
        private static void OnDisplaySettingsChanged(object sender, EventArgs e) {

            // Now that we've responded to this event, we don't need it again until
            // someone re-queries. We will re-add the event at that time.
            //
            SystemEvents.DisplaySettingsChanged -= new EventHandler(OnDisplaySettingsChanged);

            // Display settings changed, so the set of screens we have is invalid.
            //
            screens = null;
        }

        /// <include file='doc\Screen.uex' path='docs/doc[@for="Screen.ToString"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Retrieves a string representing this object.
        ///    </para>
        /// </devdoc>
        public override string ToString() {
            return GetType().Name + "[Bounds=" + bounds.ToString() + " WorkingArea=" + workingArea.ToString() + " Primary=" + primary.ToString() + " DeviceName=" + deviceName;
        }


        /// <include file='doc\Screen.uex' path='docs/doc[@for="Screen.MonitorEnumCallback"]/*' />
        /// <devdoc>         
        /// </devdoc>         
        private class MonitorEnumCallback {
            public ArrayList screens = new ArrayList();

            public virtual bool Callback(IntPtr monitor, IntPtr hdc, IntPtr lprcMonitor, IntPtr lparam) {
                screens.Add(new Screen(monitor, hdc));
                return true;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\savefiledialog.cs ===
//------------------------------------------------------------------------------
// <copyright file="SaveFileDialog.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using CodeAccessPermission = System.Security.CodeAccessPermission;
    using System.IO;
    using System.Drawing;
    using System.Security.Permissions;
    using System.ComponentModel;
    using System.Windows.Forms;
    using Microsoft.Win32;


    /// <include file='doc\SaveFileDialog.uex' path='docs/doc[@for="SaveFileDialog"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents
    ///       a common dialog box that allows the user to specify options for saving a
    ///       file. This class cannot be inherited.
    ///    </para>
    /// </devdoc>
    [
    Designer("System.Windows.Forms.Design.SaveFileDialogDesigner, " + AssemblyRef.SystemDesign)
    ]
    public sealed class SaveFileDialog : FileDialog {

        /// <include file='doc\SaveFileDialog.uex' path='docs/doc[@for="SaveFileDialog.CreatePrompt"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the dialog box prompts the user for
        ///       permission to create a file if the user specifies a file that does not exist.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(false),
        SRDescription(SR.SaveFileDialogCreatePrompt)
        ]
        public bool CreatePrompt {
            get {
                return GetOption(NativeMethods.OFN_CREATEPROMPT);
            }
            set {
                Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "FileDialogCustomization Demanded");
                IntSecurity.FileDialogCustomization.Demand();
                SetOption(NativeMethods.OFN_CREATEPROMPT, value);
            }
        }

        /// <include file='doc\SaveFileDialog.uex' path='docs/doc[@for="SaveFileDialog.OverwritePrompt"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the Save As dialog box displays a warning if the user specifies
        ///       a file name that already exists.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(true),
        SRDescription(SR.SaveFileDialogOverWritePrompt)
        ]
        public bool OverwritePrompt {
            get {
                return GetOption(NativeMethods.OFN_OVERWRITEPROMPT);
            }
            set {
                Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "FileDialogCustomization Demanded");
                IntSecurity.FileDialogCustomization.Demand();
                SetOption(NativeMethods.OFN_OVERWRITEPROMPT, value);
            }
        }

        /// <include file='doc\SaveFileDialog.uex' path='docs/doc[@for="SaveFileDialog.OpenFile"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Opens the file with read/write permission selected by the user.
        ///    </para>
        /// </devdoc>
        public Stream OpenFile() {
            Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "FileDialogSaveFile Demanded");
            IntSecurity.FileDialogSaveFile.Demand();

            string filename = FileNamesInternal[0];

            if (filename == null || filename == "")
                throw new ArgumentNullException( "FileName" );
                
            Stream s = null;
            
            // SECREVIEW : We demanded the FileDialog permission above, so it is safe
            //           : to assert this here. Since the user picked the file, it
            //           : is OK to give them read/write access to the stream.
            //
            new FileIOPermission(FileIOPermissionAccess.AllAccess, IntSecurity.UnsafeGetFullPath(filename)).Assert();
            try {
                s = new FileStream(filename, FileMode.Create, FileAccess.ReadWrite);
            }
            finally {
                CodeAccessPermission.RevertAssert();
            }
            return s;
        }

        /// <include file='doc\SaveFileDialog.uex' path='docs/doc[@for="SaveFileDialog.PromptFileCreate"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Prompts the user with a <see cref='System.Windows.Forms.MessageBox'/>
        ///       when a file is about to be created. This method is
        ///       invoked when the CreatePrompt property is true and the specified file
        ///       does not exist. A return value of false prevents the dialog from
        ///       closing.
        ///    </para>
        /// </devdoc>
        private bool PromptFileCreate(string fileName) 
        {
            return MessageBoxWithFocusRestore(SR.GetString(SR.FileDialogCreatePrompt, fileName),
                    DialogCaption, MessageBoxButtons.YesNo, MessageBoxIcon.Warning);
        }

        /// <include file='doc\SaveFileDialog.uex' path='docs/doc[@for="SaveFileDialog.PromptFileOverwrite"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Prompts the user when a file is about to be overwritten. This method is
        ///       invoked when the "overwritePrompt" property is true and the specified
        ///       file already exists. A return value of false prevents the dialog from
        ///       closing.
        ///       
        ///    </para>
        /// </devdoc>
        private bool PromptFileOverwrite(string fileName) {
            return MessageBoxWithFocusRestore(SR.GetString(SR.FileDialogOverwritePrompt, fileName),
                    DialogCaption, MessageBoxButtons.YesNo, MessageBoxIcon.Warning);
        }

        // If it's necessary to throw up a "This file exists, are you sure?" kind of
        // MessageBox, here's where we do it.
        // Return value is whether or not the user hit "okay".
        internal override bool PromptUserIfAppropriate(string fileName) {
            bool ok = base.PromptUserIfAppropriate(fileName);
            if (!ok)
                return false;

            if ((options & NativeMethods.OFN_OVERWRITEPROMPT) != 0 && File.Exists(fileName)) {
                if (!PromptFileOverwrite(fileName)) return false;
            }
            if ((options & NativeMethods.OFN_CREATEPROMPT) != 0 && !File.Exists(fileName)) {
                if (!PromptFileCreate(fileName)) return false;
            }
            
            return true;
        }

        /// <include file='doc\SaveFileDialog.uex' path='docs/doc[@for="SaveFileDialog.Reset"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Resets all dialog box options to their default
        ///       values.
        ///    </para>
        /// </devdoc>
        public override void Reset() {
            base.Reset();
            SetOption(NativeMethods.OFN_OVERWRITEPROMPT, true);
        }

        /// <include file='doc\SaveFileDialog.uex' path='docs/doc[@for="SaveFileDialog.RunFileDialog"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        internal override bool RunFileDialog(NativeMethods.OPENFILENAME_I ofn) {
            bool result = UnsafeNativeMethods.GetSaveFileName(ofn);
            
            if (!result) {
                // Something may have gone wrong - check for error condition
                //
                int errorCode = SafeNativeMethods.CommDlgExtendedError();
                switch(errorCode) {
                    case NativeMethods.FNERR_INVALIDFILENAME:
                        throw new InvalidOperationException(SR.GetString(SR.FileDialogInvalidFileName, FileName));
                }
            }
            
            return result;
         }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\safenativemethods.cs ===
//------------------------------------------------------------------------------
// <copyright file="SafeNativeMethods.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {
    using System.Runtime.InteropServices;
    using System;
    using System.Security;
    using System.Security.Permissions;
    using System.Collections;
    using System.IO;
    using System.Text;

    [SuppressUnmanagedCodeSecurity]
    internal class SafeNativeMethods {
        [DllImport(ExternDll.Gdi32)]
        public static extern IntPtr GetPaletteEntries(HandleRef hpal, int iStartIndex, int nEntries, byte[] lppe);
        [DllImport(ExternDll.Gdi32)]
        public static extern IntPtr GetSystemPaletteEntries(HandleRef hdc, int iStartIndex, int nEntries, byte[] lppe);
        [DllImport(ExternDll.Gdi32)]
        public static extern IntPtr GetDIBits(HandleRef hdc, HandleRef hbm, int arg1, int arg2, IntPtr arg3, NativeMethods.BITMAPINFOHEADER bmi, int arg5);
        [DllImport(ExternDll.Gdi32)]
        public static extern IntPtr GetDIBits(HandleRef hdc, HandleRef hbm, int arg1, int arg2, IntPtr arg3, ref NativeMethods.BITMAPINFO_FLAT bmi, int arg5);

        [DllImport(ExternDll.Gdi32, ExactSpelling=true, EntryPoint="CreateCompatibleBitmap", CharSet=CharSet.Auto)]
        public static extern IntPtr IntCreateCompatibleBitmap(HandleRef hDC, int width, int height);
        public static IntPtr CreateCompatibleBitmap(HandleRef hDC, int width, int height) {
            return HandleCollector.Add(IntCreateCompatibleBitmap(hDC, width, height), NativeMethods.CommonHandles.GDI);
        }

        [DllImport(ExternDll.Gdi32, ExactSpelling=true, EntryPoint="CreateDIBSection", CharSet=CharSet.Auto)]
        public static extern IntPtr IntCreateDIBSection(HandleRef hdc, ref NativeMethods.BITMAPINFO_FLAT bmi, int iUsage, ref IntPtr ppvBits, IntPtr hSection, int dwOffset);
        public static IntPtr CreateDIBSection(HandleRef hdc, ref NativeMethods.BITMAPINFO_FLAT bmi, int iUsage, ref IntPtr ppvBits, IntPtr hSection, int dwOffset) {
            return HandleCollector.Add(IntCreateDIBSection(hdc, ref bmi, iUsage, ref ppvBits, hSection, dwOffset), NativeMethods.CommonHandles.GDI);
        }

        [DllImport(ExternDll.Uxtheme, CharSet=CharSet.Unicode)]
        public static extern int IsAppThemed();
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool GetScrollInfo(HandleRef hWnd, int fnBar, [In, Out] NativeMethods.SCROLLINFO si);
        [DllImport(ExternDll.Ole32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool IsAccelerator(HandleRef hAccel, int cAccelEntries, [In] ref NativeMethods.MSG lpMsg, short[] lpwCmd);
        [DllImport(ExternDll.Comdlg32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool ChooseFont([In, Out] NativeMethods.CHOOSEFONT cf);
        [DllImport(ExternDll.Gdi32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int GetBitmapBits(HandleRef hbmp, int cbBuffer, byte[] lpvBits);
        [DllImport(ExternDll.Comdlg32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern int CommDlgExtendedError();
        [DllImport(ExternDll.Oleaut32, ExactSpelling=true, CharSet=CharSet.Unicode)]
        public static extern void SysFreeString(HandleRef bstr);
        [DllImport(ExternDll.Oleaut32, CharSet = CharSet.Unicode)]
        public static extern int RegisterTypeLib(UCOMITypeLib typelib, string path, string helpPath);

        [DllImport(ExternDll.Olepro32, PreserveSig=false)]
        public static extern void OleCreatePropertyFrame(HandleRef hwndOwner, int x, int y, [MarshalAs(UnmanagedType.LPWStr)]string caption, int objects, [MarshalAs(UnmanagedType.Interface)] ref object pobjs, int pages, HandleRef pClsid, int locale, int reserved1, IntPtr reserved2);
        [DllImport(ExternDll.Olepro32, PreserveSig=false)]
        public static extern void OleCreatePropertyFrame(HandleRef hwndOwner, int x, int y, [MarshalAs(UnmanagedType.LPWStr)]string caption, int objects, [MarshalAs(UnmanagedType.Interface)] ref object pobjs, int pages, Guid[] pClsid, int locale, int reserved1, IntPtr reserved2);
        [DllImport(ExternDll.Olepro32, PreserveSig=false)]
        public static extern void OleCreatePropertyFrame(HandleRef hwndOwner, int x, int y, [MarshalAs(UnmanagedType.LPWStr)]string caption, int objects, HandleRef lplpobjs, int pages, HandleRef pClsid, int locale, int reserved1, IntPtr reserved2);
        [DllImport(ExternDll.Hhctrl, CharSet=CharSet.Auto)]
        public static extern int HtmlHelp(HandleRef hwndCaller, [MarshalAs(UnmanagedType.LPTStr)]string pszFile, int uCommand, int dwData);
        [DllImport(ExternDll.Hhctrl, CharSet=CharSet.Auto)]
        public static extern int HtmlHelp(HandleRef hwndCaller, [MarshalAs(UnmanagedType.LPTStr)]string pszFile, int uCommand, string dwData);
        [DllImport(ExternDll.Hhctrl, CharSet=CharSet.Auto)]
        public static extern int HtmlHelp(HandleRef hwndCaller, [MarshalAs(UnmanagedType.LPTStr)]string pszFile, int uCommand, NativeMethods.HH_POPUP dwData);
        [DllImport(ExternDll.Hhctrl, CharSet=CharSet.Auto)]
        public static extern int HtmlHelp(HandleRef hwndCaller, [MarshalAs(UnmanagedType.LPTStr)]string pszFile, int uCommand, NativeMethods.HH_FTS_QUERY dwData);
        [DllImport(ExternDll.Hhctrl, CharSet=CharSet.Auto)]
        public static extern int HtmlHelp(HandleRef hwndCaller, [MarshalAs(UnmanagedType.LPTStr)]string pszFile, int uCommand, NativeMethods.HH_AKLINK dwData);
        [DllImport(ExternDll.Oleaut32, PreserveSig=false)]
        public static extern void VariantInit(HandleRef pObject);
        [ DllImport(ExternDll.Oleaut32, PreserveSig=false)]
        public static extern void VariantClear(HandleRef pObject);
        [DllImport(ExternDll.Gdi32, CharSet=CharSet.Auto)]
        internal static extern bool ExtTextOut(
                                              HandleRef hdc, int x, int y, int options, ref NativeMethods.RECT rect,string str, int length, int[] spacing);

        [DllImport(ExternDll.Gdi32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern bool LineTo(HandleRef hdc, int x, int y);

        [DllImport(ExternDll.Gdi32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern bool MoveToEx(HandleRef hdc, int x, int y, NativeMethods.POINT pt);

        [DllImport(ExternDll.Gdi32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern bool Rectangle(
                                           HandleRef hdc, int left, int top, int right, int bottom);

        [DllImport(ExternDll.Gdi32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern IntPtr SelectObject(HandleRef hdc, int obj);
        [DllImport(ExternDll.Gdi32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern bool PatBlt(HandleRef hdc, int left, int top, int width, int height, int rop);
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int GetUserDefaultLCID();
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int GetSystemDefaultLCID();
        [DllImport(ExternDll.Kernel32, EntryPoint="GetThreadLocale", CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int GetThreadLCID();
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int GetMessagePos();

        [DllImport(ExternDll.Gdi32, ExactSpelling=true, EntryPoint="CreatePalette", CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        private static extern IntPtr /*HPALETTE*/ IntCreatePalette(NativeMethods.LOGPALETTE lplgpl);
        public static IntPtr /*HPALETTE*/ CreatePalette(NativeMethods.LOGPALETTE lplgpl) {
            return HandleCollector.Add(IntCreatePalette(lplgpl), NativeMethods.CommonHandles.GDI);
        }


        [DllImport(ExternDll.Gdi32, ExactSpelling=true, EntryPoint="CreatePalette", CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        private static extern IntPtr /*HPALETTE*/ IntCreatePalette(HandleRef ptrlgpl);
        public static IntPtr /*HPALETTE*/ CreatePalette(HandleRef ptrlgpl) {
            return HandleCollector.Add(IntCreatePalette(ptrlgpl), NativeMethods.CommonHandles.GDI);
        }
        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern int RegisterClipboardFormat(string format);
        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int GetClipboardFormatName(int format, StringBuilder lpString, int cchMax);
        
        [DllImport(ExternDll.Comdlg32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool ChooseColor([In, Out] NativeMethods.CHOOSECOLOR cc);
        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int RegisterWindowMessage(string msg);
        [DllImport(ExternDll.Gdi32, ExactSpelling=true, EntryPoint="DeleteObject", CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool ExternalDeleteObject(HandleRef hObject);
        [DllImport(ExternDll.Gdi32, ExactSpelling=true, EntryPoint="DeleteObject", CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        private static extern bool IntDeleteObject(HandleRef hObject);
        public static bool DeleteObject(HandleRef hObject) {
            HandleCollector.Remove((IntPtr)hObject, NativeMethods.CommonHandles.GDI);
            return IntDeleteObject(hObject);
        }

        [DllImport(ExternDll.Olepro32, EntryPoint="OleCreateFontIndirect", ExactSpelling=true, PreserveSig=false)]
        public static extern SafeNativeMethods.IFont OleCreateIFontIndirect(NativeMethods.FONTDESC fd, ref Guid iid);
        [DllImport(ExternDll.Olepro32, EntryPoint="OleCreateFontIndirect", ExactSpelling=true, PreserveSig=false)]
        public static extern SafeNativeMethods.IFontDisp OleCreateIFontDispIndirect(NativeMethods.FONTDESC fd, ref Guid iid);

        [DllImport(ExternDll.Olepro32, EntryPoint="OleCreatePictureIndirect", ExactSpelling=true, PreserveSig=false)]
        public static extern SafeNativeMethods.IPicture OleCreateIPictureIndirect([MarshalAs(UnmanagedType.AsAny)]object pictdesc, ref Guid iid, bool fOwn);
        [DllImport(ExternDll.Olepro32, EntryPoint="OleCreatePictureIndirect", ExactSpelling=true, PreserveSig=false)]
        public static extern SafeNativeMethods.IPictureDisp OleCreateIPictureDispIndirect([MarshalAs(UnmanagedType.AsAny)] object pictdesc, ref Guid iid, bool fOwn);
        
        [DllImport(ExternDll.Gdi32, ExactSpelling=true, EntryPoint="CreateSolidBrush", CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        private static extern IntPtr IntCreateSolidBrush(int crColor);
        public static IntPtr CreateSolidBrush(int crColor) {
            return HandleCollector.Add(IntCreateSolidBrush(crColor), NativeMethods.CommonHandles.GDI);
        }
        [DllImport(ExternDll.Gdi32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool SetWindowExtEx(HandleRef hDC, int x, int y, [In, Out] NativeMethods.SIZE size);

        [DllImport(ExternDll.Oleaut32, CharSet = CharSet.Unicode)]
        public static extern int LoadTypeLib(string file, out UCOMITypeLib typelib);
        
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int FormatMessage(int dwFlags, HandleRef lpSource, int dwMessageId,
                                               int dwLanguageId, StringBuilder lpBuffer, int nSize, HandleRef arguments);
        
        
        // cpb: #8309 -- next three methods, refiid arg must be IPicture.iid
        [DllImport(ExternDll.Oleaut32, PreserveSig=false)]
        public static extern SafeNativeMethods.IPicture OleLoadPicture(UnsafeNativeMethods.IStream pStream, int lSize, bool fRunmode, ref Guid refiid);
        
        [DllImport(ExternDll.Oleaut32, PreserveSig=false)]
        public static extern SafeNativeMethods.IPicture OleCreatePictureIndirect(NativeMethods.PICTDESC pictdesc, [In]ref Guid refiid, bool fOwn);

        [DllImport(ExternDll.Oleaut32, PreserveSig=false)]
        public static extern SafeNativeMethods.IFont OleCreateFontIndirect(NativeMethods.tagFONTDESC fontdesc, [In]ref Guid refiid);
        
        [DllImport(ExternDll.Oleacc, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int CreateStdAccessibleObject(HandleRef hWnd, int objID, ref Guid refiid, [In, Out, MarshalAs(UnmanagedType.Interface)] ref object pAcc);
        [DllImport(ExternDll.Comctl32)]
        public static extern void InitCommonControls();

        [DllImport(ExternDll.Comctl32)]
        public static extern bool InitCommonControlsEx(NativeMethods.INITCOMMONCONTROLSEX icc);

#if DEBUG
        private static System.Collections.ArrayList validImageListHandles = new System.Collections.ArrayList();
#endif

        // UNDONE: Whidbey, use HandleCollector across the board for native handles in Windows Forms
        //
#if DEBUG
        [DllImport(ExternDll.Comctl32, EntryPoint="ImageList_Create")]
        private static extern IntPtr IntImageList_Create(int cx, int cy, int flags, int cInitial, int cGrow);
        public static IntPtr ImageList_Create(int cx, int cy, int flags, int cInitial, int cGrow) {
            IntPtr newHandle = IntImageList_Create(cx, cy, flags, cInitial, cGrow);
            validImageListHandles.Add(newHandle);
            return newHandle;
        }
#else
        [DllImport(ExternDll.Comctl32)]
        public static extern IntPtr ImageList_Create(int cx, int cy, int flags, int cInitial, int cGrow);
#endif

#if DEBUG
        [DllImport(ExternDll.Comctl32, EntryPoint="ImageList_Destroy")]
        private static extern bool IntImageList_Destroy(HandleRef himl);
        public static bool ImageList_Destroy(HandleRef himl) {
            System.Diagnostics.Debug.Assert(validImageListHandles.Contains(himl.Handle), "Invalid ImageList handle");
            validImageListHandles.Remove(himl.Handle);
            return IntImageList_Destroy(himl);
        }
#else
        [DllImport(ExternDll.Comctl32)]
        public static extern bool ImageList_Destroy(HandleRef himl);
#endif

        [DllImport(ExternDll.Comctl32)]
        public static extern int ImageList_GetImageCount(HandleRef himl);
        [DllImport(ExternDll.Comctl32)]
        public static extern int ImageList_Add(HandleRef himl, HandleRef hbmImage, HandleRef hbmMask);
        [DllImport(ExternDll.Comctl32)]
        public static extern int ImageList_ReplaceIcon(HandleRef himl, int index, HandleRef hicon);
        [DllImport(ExternDll.Comctl32)]
        public static extern int ImageList_SetBkColor(HandleRef himl, int clrBk);
        [DllImport(ExternDll.Comctl32)]
        public static extern bool ImageList_Draw(HandleRef himl, int i, HandleRef hdcDst, int x, int y, int fStyle);
        [DllImport(ExternDll.Comctl32)]
        public static extern bool ImageList_Replace(HandleRef himl, int i, HandleRef hbmImage, HandleRef hbmMask);
        [DllImport(ExternDll.Comctl32)]
        public static extern bool ImageList_DrawEx(HandleRef himl, int i, HandleRef hdcDst, int x, int y, int dx, int dy, int rgbBk, int rgbFg, int fStyle);
        [DllImport(ExternDll.Comctl32)]
        public static extern bool ImageList_DrawIndirect(NativeMethods.IMAGELISTDRAWPARAMS pimldp);
        [DllImport(ExternDll.Comctl32)]
        public static extern bool ImageList_Remove(HandleRef himl, int i);
        [DllImport(ExternDll.Comctl32)]
        public static extern bool ImageList_GetImageInfo(HandleRef himl, int i, NativeMethods.IMAGEINFO pImageInfo);

#if DEBUG
        [DllImport(ExternDll.Comctl32, EntryPoint="ImageList_Read")]
        private static extern IntPtr IntImageList_Read(UnsafeNativeMethods.IStream pstm);
        public static IntPtr ImageList_Read(UnsafeNativeMethods.IStream pstm) {
            IntPtr newHandle = IntImageList_Read(pstm);
            validImageListHandles.Add(newHandle);
            return newHandle;
        }
#else
        [DllImport(ExternDll.Comctl32)]
        public static extern IntPtr ImageList_Read(UnsafeNativeMethods.IStream pstm);
#endif

        [DllImport(ExternDll.Comctl32)]
        public static extern bool ImageList_Write(HandleRef himl, UnsafeNativeMethods.IStream pstm);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool TrackPopupMenuEx(HandleRef hmenu, int fuFlags, int x, int y, HandleRef hwnd, NativeMethods.TPMPARAMS tpm);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern IntPtr GetKeyboardLayout(int dwLayout);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto, SetLastError=true)]
        public static extern IntPtr ActivateKeyboardLayout(HandleRef hkl, int uFlags);
        
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern int GetKeyboardLayoutList(int size, [Out, MarshalAs(UnmanagedType.LPArray)] int [] hkls);
        
        
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern bool GetMonitorInfo(HandleRef hmonitor, [In, Out]NativeMethods.MONITORINFOEX info);
        [DllImport(ExternDll.User32, ExactSpelling=true)]
        public static extern IntPtr MonitorFromPoint(int x, int y, int flags);
        [DllImport(ExternDll.User32, ExactSpelling=true)]
        public static extern IntPtr MonitorFromRect(ref NativeMethods.RECT rect, int flags);
        [DllImport(ExternDll.User32, ExactSpelling=true)]
        public static extern IntPtr MonitorFromWindow(HandleRef handle, int flags);
        [DllImport(ExternDll.User32, ExactSpelling=true)]
        public static extern bool EnumDisplayMonitors(HandleRef hdc, ref NativeMethods.RECT rcClip, NativeMethods.MonitorEnumProc lpfnEnum, IntPtr dwData);
        [DllImport(ExternDll.User32, ExactSpelling=true)]
        public static extern bool EnumDisplayMonitors(HandleRef hdc, NativeMethods.COMRECT rcClip, NativeMethods.MonitorEnumProc lpfnEnum, IntPtr dwData);
        [DllImport(ExternDll.Gdi32, ExactSpelling=true, EntryPoint="CreateHalftonePalette", CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        private static extern IntPtr /*HPALETTE*/ IntCreateHalftonePalette(HandleRef hdc);
        public static IntPtr /*HPALETTE*/ CreateHalftonePalette(HandleRef hdc) {
            return HandleCollector.Add(IntCreateHalftonePalette(hdc), NativeMethods.CommonHandles.GDI);
        }
        [DllImport(ExternDll.Gdi32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int GetPaletteEntries(HandleRef hpal, int iStartIndex, int nEntries, int[] lppe);
        [DllImport(ExternDll.Gdi32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int GetPaletteEntries(HandleRef hpal, int iStartIndex, int nEntries, IntPtr lppe);
        [DllImport(ExternDll.Gdi32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool GetTextMetrics(HandleRef hdc, NativeMethods.TEXTMETRIC tm);
        [DllImport(ExternDll.Gdi32, ExactSpelling=true, EntryPoint="CreateDIBSection", CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        private static extern IntPtr IntCreateDIBSection(HandleRef hdc, NativeMethods.BITMAPINFO bmi, int iUsage, ref IntPtr ppvBits, IntPtr hSection, int dwOffset);
        public static IntPtr CreateDIBSection(HandleRef hdc, NativeMethods.BITMAPINFO bmi, int iUsage, ref IntPtr ppvBits, IntPtr hSection, int dwOffset) {
            return HandleCollector.Add(IntCreateDIBSection(hdc, bmi, iUsage, ref ppvBits, hSection, dwOffset), NativeMethods.CommonHandles.GDI);
        }
        [DllImport(ExternDll.Gdi32, ExactSpelling=true, EntryPoint="CreateBitmap", CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        private static extern IntPtr /*HBITMAP*/ IntCreateBitmap(int nWidth, int nHeight, int nPlanes, int nBitsPerPixel, int [] lpvBits);
        public static IntPtr /*HBITMAP*/ CreateBitmap(int nWidth, int nHeight, int nPlanes, int nBitsPerPixel, int [] lpvBits) {
            return HandleCollector.Add(IntCreateBitmap(nWidth, nHeight, nPlanes, nBitsPerPixel, lpvBits), NativeMethods.CommonHandles.GDI);
        }
        [DllImport(ExternDll.Gdi32, ExactSpelling=true, EntryPoint="CreateDIBSection", CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        private static extern IntPtr IntCreateDIBSection(HandleRef hdc, HandleRef pbmi, int iUsage, byte[] ppvBits, IntPtr hSection, int dwOffset);
        public static IntPtr CreateDIBSection(HandleRef hdc, HandleRef pbmi, int iUsage, byte[] ppvBits, IntPtr hSection, int dwOffset) {
            return HandleCollector.Add(IntCreateDIBSection(hdc, pbmi, iUsage, ppvBits, hSection, dwOffset), NativeMethods.CommonHandles.GDI);
        }

        [DllImport(ExternDll.Gdi32, ExactSpelling=true, EntryPoint="CreateDIBSection", CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        private static extern IntPtr IntCreateDIBSection(HandleRef hdc, HandleRef pbmi, int iUsage, int [] ppvBits, IntPtr hSection, int dwOffset);
        public static IntPtr CreateDIBSection(HandleRef hdc, HandleRef pbmi, int iUsage, int [] ppvBits, IntPtr hSection, int dwOffset) {
            return HandleCollector.Add(IntCreateDIBSection(hdc, pbmi, iUsage, ppvBits, hSection, dwOffset), NativeMethods.CommonHandles.GDI);
        }

        [DllImport(ExternDll.Gdi32, ExactSpelling=true, EntryPoint="CreateBitmap", CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        private static extern IntPtr /*HBITMAP*/ IntCreateBitmap(int nWidth, int nHeight, int nPlanes, int nBitsPerPixel, short[] lpvBits);
        public static IntPtr /*HBITMAP*/ CreateBitmap(int nWidth, int nHeight, int nPlanes, int nBitsPerPixel, short[] lpvBits) {
            return HandleCollector.Add(IntCreateBitmap(nWidth, nHeight, nPlanes, nBitsPerPixel, lpvBits), NativeMethods.CommonHandles.GDI);
        }

        [DllImport(ExternDll.Gdi32, ExactSpelling=true, EntryPoint="CreateBitmap", CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        private static extern IntPtr /*HBITMAP*/ IntCreateBitmap(int nWidth, int nHeight, int nPlanes, int nBitsPerPixel, byte[] lpvBits);
        public static IntPtr /*HBITMAP*/ CreateBitmap(int nWidth, int nHeight, int nPlanes, int nBitsPerPixel, byte[] lpvBits) {
            return HandleCollector.Add(IntCreateBitmap(nWidth, nHeight, nPlanes, nBitsPerPixel, lpvBits), NativeMethods.CommonHandles.GDI);
        }
        [DllImport(ExternDll.Gdi32, ExactSpelling=true, EntryPoint="CreatePatternBrush", CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        private static extern IntPtr /*HBRUSH*/ IntCreatePatternBrush(HandleRef hbmp);
        public static IntPtr /*HBRUSH*/ CreatePatternBrush(HandleRef hbmp) {
            return HandleCollector.Add(IntCreatePatternBrush(hbmp), NativeMethods.CommonHandles.GDI);
        }
        [DllImport(ExternDll.Gdi32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int GetTextExtentPoint32(HandleRef hDC, string str, int len, [In, Out] NativeMethods.SIZE size);
        [DllImport(ExternDll.Gdi32, ExactSpelling=true, EntryPoint="CreateBrushIndirect", CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        private static extern IntPtr IntCreateBrushIndirect(NativeMethods.LOGBRUSH lb);
        public static IntPtr CreateBrushIndirect(NativeMethods.LOGBRUSH lb) {
            return HandleCollector.Add(IntCreateBrushIndirect(lb), NativeMethods.CommonHandles.GDI);
        }
        [DllImport(ExternDll.Gdi32, ExactSpelling=true, EntryPoint="CreatePen", CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        private static extern IntPtr IntCreatePen(int nStyle, int nWidth, int crColor);
        public static IntPtr CreatePen(int nStyle, int nWidth, int crColor) {
            return HandleCollector.Add(IntCreatePen(nStyle, nWidth, crColor), NativeMethods.CommonHandles.GDI);
        }


        [DllImport(ExternDll.Gdi32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool SetViewportExtEx(HandleRef hDC, int x, int y, NativeMethods.SIZE size);
        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern IntPtr LoadCursor(HandleRef hInst, int iconId);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public extern static bool GetClipCursor([In, Out] ref NativeMethods.RECT lpRect);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern IntPtr GetCursor();
        [DllImport(ExternDll.Gdi32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int IntersectClipRect(HandleRef hDC, int x1, int y1, int x2, int y2);
        [DllImport(ExternDll.User32, ExactSpelling=true, EntryPoint="CopyImage", CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        private static extern IntPtr IntCopyImage(HandleRef hImage, int uType, int cxDesired, int cyDesired, int fuFlags);
        public static IntPtr CopyImage(HandleRef hImage, int uType, int cxDesired, int cyDesired, int fuFlags) {
            return HandleCollector.Add(IntCopyImage(hImage, uType, cxDesired, cyDesired, fuFlags), NativeMethods.CommonHandles.GDI);
        }
        

        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool AdjustWindowRectEx(ref NativeMethods.RECT lpRect, int dwStyle, bool bMenu, int dwExStyle);
        [DllImport(ExternDll.Kernel32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int GetACP();
        [DllImport(ExternDll.Ole32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int DoDragDrop(UnsafeNativeMethods.IOleDataObject dataObject, UnsafeNativeMethods.IOleDropSource dropSource, int allowedEffects, int[] finalEffect);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern IntPtr GetSysColorBrush(int nIndex);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool EnableWindow(HandleRef hWnd, bool enable);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool GetClientRect(HandleRef hWnd, [In, Out] ref NativeMethods.RECT rect);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern int GetDoubleClickTime();
        [DllImport(ExternDll.Kernel32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public extern static int GetLastError();
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int FillRect(HandleRef hdc, [In] ref NativeMethods.RECT rect, HandleRef hbrush);
        [DllImport(ExternDll.Gdi32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int /*COLORREF*/ SetTextColor(HandleRef hDC, int crColor);
        [DllImport(ExternDll.Gdi32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int SetBkColor(HandleRef hDC, int clr);
        [DllImport(ExternDll.Gdi32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern IntPtr /* HPALETTE */SelectPalette(HandleRef hdc, HandleRef hpal, int bForceBackground);
        [DllImport(ExternDll.Gdi32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool SetViewportOrgEx(HandleRef hDC, int x, int y, [In, Out] NativeMethods.POINT point);

        [DllImport(ExternDll.Gdi32, ExactSpelling=true, EntryPoint="CreateRectRgn", CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        private static extern IntPtr IntCreateRectRgn(int x1, int y1, int x2, int y2);
        public static IntPtr CreateRectRgn(int x1, int y1, int x2, int y2) {
            return HandleCollector.Add(IntCreateRectRgn(x1, y1, x2, y2), NativeMethods.CommonHandles.GDI);
        }
        [DllImport(ExternDll.Gdi32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int CombineRgn(HandleRef hRgn, HandleRef hRgn1, HandleRef hRgn2, int nCombineMode);
        [DllImport(ExternDll.Gdi32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern int RealizePalette(HandleRef hDC);
        [DllImport(ExternDll.Gdi32)]
        public static extern bool LPtoDP(HandleRef hDC, [In, Out] NativeMethods.POINT lpPoint, int nCount);
        [DllImport(ExternDll.Gdi32)]
        public static extern bool LPtoDP(HandleRef hDC, int lpPoints, int nCount);
        [DllImport(ExternDll.Gdi32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool LPtoDP(HandleRef hDC, [In, Out] NativeMethods.SIZE lpSize, int nCount);
        [DllImport(ExternDll.Gdi32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool LPtoDP(HandleRef hDC, [In, Out] ref NativeMethods.RECT lpRect, int nCount);
        [DllImport(ExternDll.Gdi32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool DPtoLP(HandleRef hDC, [In, Out] ref NativeMethods.RECT lpRect, int nCount);
        [DllImport(ExternDll.Gdi32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool SetWindowOrgEx(HandleRef hDC, int x, int y, [In, Out] NativeMethods.POINT point);
        [DllImport(ExternDll.Gdi32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool GetWindowExtEx(HandleRef hDC, [In, Out] NativeMethods.SIZE s);
        [DllImport(ExternDll.Gdi32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool GetViewportExtEx(HandleRef hDC, [In, Out] NativeMethods.SIZE s);
        [DllImport(ExternDll.Gdi32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int SetMapMode(HandleRef hDC, int nMapMode);

        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool IsWindowEnabled(HandleRef hWnd);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool IsWindowVisible(HandleRef hWnd);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool ReleaseCapture();
        [DllImport(ExternDll.Kernel32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int GetCurrentThreadId();
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int GetWindowThreadProcessId(HandleRef hWnd, out int lpdwProcessId);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool ShowWindow(HandleRef hWnd, int nCmdShow);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool SetWindowPos(HandleRef hWnd, HandleRef hWndInsertAfter,
                                               int x, int y, int cx, int cy, int flags);

        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int GetWindowTextLength(HandleRef hWnd);
        // this is a wrapper that comctl exposes for the NT function since it doesn't exist natively on 95.
        [DllImport(ExternDll.Comctl32, ExactSpelling=true), CLSCompliantAttribute(false)]
        private static extern bool _TrackMouseEvent(NativeMethods.TRACKMOUSEEVENT tme);
        public static bool TrackMouseEvent(NativeMethods.TRACKMOUSEEVENT tme) {
            // only on NT - not on 95 - comctl32 has a wrapper for 95 and NT.
            return _TrackMouseEvent(tme);
        }
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool RedrawWindow(HandleRef hwnd, ref NativeMethods.RECT rcUpdate, HandleRef hrgnUpdate, int flags);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool RedrawWindow(HandleRef hwnd, NativeMethods.COMRECT rcUpdate, HandleRef hrgnUpdate, int flags);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool InvalidateRect(HandleRef hWnd, ref NativeMethods.RECT rect, bool erase);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool InvalidateRect(HandleRef hWnd, NativeMethods.COMRECT rect, bool erase);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool InvalidateRgn(HandleRef hWnd, HandleRef hrgn, bool erase);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool UpdateWindow(HandleRef hWnd);
        [DllImport(ExternDll.Kernel32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int GetCurrentProcessId();
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool ScrollWindowEx(HandleRef hWnd, int nXAmount, int nYAmount, ref NativeMethods.RECT rectScrollRegion, ref NativeMethods.RECT rectClip, HandleRef hrgnUpdate, ref NativeMethods.RECT prcUpdate, int flags);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool ScrollWindowEx(HandleRef hWnd, int nXAmount, int nYAmount, NativeMethods.COMRECT rectScrollRegion, ref NativeMethods.RECT rectClip, HandleRef hrgnUpdate, ref NativeMethods.RECT prcUpdate, int flags);
        [DllImport(ExternDll.Kernel32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int GetThreadLocale();
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool MessageBeep(int type);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool DrawMenuBar(HandleRef hWnd);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public extern static bool IsChild(HandleRef parent, HandleRef child);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern IntPtr SetTimer(HandleRef hWnd, int nIDEvent, int uElapse, NativeMethods.TimerProc lpTimerFunc);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool KillTimer(HandleRef hwnd, int idEvent);
        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int MessageBox(HandleRef hWnd, string text, string caption, int type);
        [DllImport(ExternDll.Gdi32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern IntPtr SelectObject(HandleRef hDC, HandleRef hObject);
        [DllImport(ExternDll.Gdi32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int GetRegionData(HandleRef hRgn, int size, byte[] data);
        [DllImport(ExternDll.Kernel32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int GetTickCount();
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool ScrollWindow(HandleRef hWnd, int nXAmount, int nYAmount, ref NativeMethods.RECT rectScrollRegion, ref NativeMethods.RECT rectClip);
        [DllImport(ExternDll.Kernel32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern IntPtr GetCurrentProcess();
        [DllImport(ExternDll.Kernel32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern IntPtr GetCurrentThread();
        [DllImport(ExternDll.Kernel32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public extern static bool SetThreadLocale(int Locale);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool IsWindowUnicode(HandleRef hWnd);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool DrawEdge(HandleRef hDC, ref NativeMethods.RECT rect, int edge, int flags);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool DrawFrameControl(HandleRef hDC, ref NativeMethods.RECT rect, int type, int state);
        [DllImport(ExternDll.Gdi32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int SelectClipRgn(HandleRef hDC, HandleRef hRgn);
        [DllImport(ExternDll.Gdi32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int SetROP2(HandleRef hDC, int nDrawMode);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool DrawIcon(HandleRef hDC, int x, int y, HandleRef hIcon);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool DrawIconEx(HandleRef hDC, int x, int y, HandleRef hIcon, int width, int height, int iStepIfAniCursor, HandleRef hBrushFlickerFree, int diFlags);
        [DllImport(ExternDll.Gdi32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int SetBkMode(HandleRef hDC, int nBkMode);
        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int DrawText(HandleRef hDC, string lpszString, int nCount, ref NativeMethods.RECT lpRect, int nFormat);

        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
        public static extern int DrawText(HandleRef hDC, byte[] lpszString, int byteCount, ref NativeMethods.RECT lpRect, int nFormat);

        [DllImport(ExternDll.Gdi32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool BitBlt(HandleRef hDC, int x, int y, int nWidth, int nHeight,
                                         HandleRef hSrcDC, int xSrc, int ySrc, int dwRop);
                                         
                                         
        public static int RGBToCOLORREF(int rgbValue) {
        
            // clear the A value, swap R & B values 
            int bValue = (rgbValue & 0xFF) << 16;
            
            rgbValue &= 0xFFFF00;
            rgbValue |= ((rgbValue >> 16) & 0xFF);
            rgbValue &= 0x00FFFF;
            rgbValue |= bValue;
            return rgbValue;
        }                                         
    
        [ComImport(), Guid("7BF80980-BF32-101A-8BBB-00AA00300CAB"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
        public interface IPicture {
            
             IntPtr GetHandle();

            
             IntPtr GetHPal();

            [return: MarshalAs(UnmanagedType.I2)]
             short GetPictureType();

            
             int GetWidth();

            
             int GetHeight();

            
             void Render(
                IntPtr hDC,
                int x,
                int y,
                int cx,
                int cy,
                int xSrc,
                int ySrc,
                int cxSrc,
                int cySrc,
                IntPtr rcBounds
                );

            
             void SetHPal(
                    
                     IntPtr phpal);

            
             IntPtr GetCurDC();

            
             void SelectPicture(
                    
                     IntPtr hdcIn,
                    [Out, MarshalAs(UnmanagedType.LPArray)] 
                     IntPtr [] phdcOut,
                    [Out, MarshalAs(UnmanagedType.LPArray)] 
                     IntPtr [] phbmpOut);

            [return: MarshalAs(UnmanagedType.Bool)]
             bool GetKeepOriginalFormat();

            
             void SetKeepOriginalFormat(
                    [In, MarshalAs(UnmanagedType.Bool)] 
                     bool pfkeep);

            
             void PictureChanged();

            
             [PreserveSig]
             int SaveAsFile(
                    [In, MarshalAs(UnmanagedType.Interface)] 
                     UnsafeNativeMethods.IStream pstm,
                     
                     int fSaveMemCopy,
                    [Out]
                     out int pcbSize);

            
             int GetAttributes();

        }
        [
        ComImport(), 
        Guid("BEF6E002-A874-101A-8BBA-00AA00300CAB"), 
        System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
        public interface IFont {

            [return: MarshalAs(UnmanagedType.BStr)]
             string GetName();

            
             void SetName(
                    [In, MarshalAs(UnmanagedType.BStr)] 
                      string pname);

            [return: MarshalAs(UnmanagedType.U8)]
             long GetSize();

            
             void SetSize(
                    [In, MarshalAs(UnmanagedType.U8)] 
                     long psize);

            [return: MarshalAs(UnmanagedType.Bool)]
             bool GetBold();

            
             void SetBold(
                    [In, MarshalAs(UnmanagedType.Bool)] 
                     bool pbold);

            [return: MarshalAs(UnmanagedType.Bool)]
             bool GetItalic();

            
             void SetItalic(
                    [In, MarshalAs(UnmanagedType.Bool)] 
                     bool pitalic);

            [return: MarshalAs(UnmanagedType.Bool)]
             bool GetUnderline();

            
             void SetUnderline(
                    [In, MarshalAs(UnmanagedType.Bool)] 
                     bool punderline);

            [return: MarshalAs(UnmanagedType.Bool)]
             bool GetStrikethrough();

            
             void SetStrikethrough(
                    [In, MarshalAs(UnmanagedType.Bool)] 
                     bool pstrikethrough);

            [return: MarshalAs(UnmanagedType.I2)]
             short GetWeight();

            
             void SetWeight(
                    [In, MarshalAs(UnmanagedType.I2)] 
                     short pweight);

            [return: MarshalAs(UnmanagedType.I2)]
             short GetCharset();

            
             void SetCharset(
                    [In, MarshalAs(UnmanagedType.I2)] 
                     short pcharset);

             IntPtr GetHFont();

             void Clone(
                       out SafeNativeMethods.IFont ppfont);

             [System.Runtime.InteropServices.PreserveSig]
             int IsEqual(
                    [In, MarshalAs(UnmanagedType.Interface)] 
                      SafeNativeMethods.IFont pfontOther);

            
             void SetRatio(
                     int cyLogical,
                     int cyHimetric);

            
             void QueryTextMetrics(out IntPtr ptm);

             void AddRefHfont(
                     IntPtr hFont);

            
             void ReleaseHfont(
                     IntPtr hFont);


             void SetHdc(
                     IntPtr hdc);

        }
        [ComImport(), Guid("BEF6E003-A874-101A-8BBA-00AA00300CAB"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIDispatch)]
        public interface IFontDisp {

             string Name {get; set;}
            
             long Size {get;set;}
             
             bool Bold {get;set;}

             bool Italic {get;set;}

             bool Underline {get;set;}

             bool Strikethrough {get;set;}

             short Weight {get;set;}

             short Charset {get;set;}
        }
        [ComImport(), Guid("7BF80981-BF32-101A-8BBB-00AA00300CAB"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIDispatch)]
        public interface IPictureDisp {
             IntPtr Handle {get;}
             
             IntPtr HPal {get;}

             short PictureType {get;}
             
            int Width {get;}
            
             int Height{get;}
            
             void Render(
                     IntPtr hdc,
                     int x,
                     int y,
                     int cx,
                     int cy,
                     int xSrc,
                     int ySrc,
                     int cxSrc,
                     int cySrc);
        }

        /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods"]/*' />
        /// <devdoc>
        ///     This class is intended to use with the C# 'using' statement in
        ///     to activate an activation context for turning on visual theming at
        ///     the beginning of a scope, and have it automatically deactivated
        ///     when the scope is exited.
        /// </devdoc>
        [ SuppressUnmanagedCodeSecurity ]
        internal class EnableThemingInScope : IDisposable
        {
            // Private data
            private ulong  cookie;
            private static ACTCTX enableThemingActivationContext;
            private static IntPtr hActCtx;
            private static bool contextCreationSucceeded = false;

            public EnableThemingInScope(bool enable)
            {
                cookie = 0;
                if (enable && OSFeature.Feature.IsPresent(OSFeature.Themes))
                {
                    if (EnsureActivateContextCreated())
                    {
                        if (!ActivateActCtx(hActCtx, out cookie))
                        {
                            // Be sure cookie always zero if activation failed
                            cookie = 0;
                        }
                    }
                }
            }

            ~EnableThemingInScope()
            {
                Dispose(false);
            }

            void IDisposable.Dispose()
            {
                Dispose(true);
            }

            private void Dispose(bool disposing)
            {
                if (cookie != 0)
                {
                    if (DeactivateActCtx(0, cookie))
                    {
                        // deactivation succeeded...
                        cookie = 0;
                    }
                }
            }

            private bool EnsureActivateContextCreated()
            {
                lock (typeof(EnableThemingInScope))
                {
                    if (!contextCreationSucceeded)
                    {
                        // Pull manifest from the .NET Framework install
                        // directory

                        string assemblyLoc = null;
                        
                        FileIOPermission fiop = new FileIOPermission(PermissionState.None);
                        fiop.AllFiles = FileIOPermissionAccess.PathDiscovery;
                        fiop.Assert();
                        try
                        {
                            assemblyLoc = typeof(Object).Assembly.Location;
                        }
                        finally
                        {
                            CodeAccessPermission.RevertAssert();
                        }

                        string manifestLoc = null;
                        string installDir = null;
                        if (assemblyLoc != null)
                        {
                            installDir = Path.GetDirectoryName(assemblyLoc);
                            const string manifestName = "XPThemes.manifest";
                            manifestLoc = Path.Combine(installDir, manifestName);
                        }

                        if (manifestLoc != null && installDir != null)
                        {
                            enableThemingActivationContext = new ACTCTX();
                            enableThemingActivationContext.cbSize = Marshal.SizeOf(typeof(ACTCTX));
                            enableThemingActivationContext.lpSource = manifestLoc;

                            // Set the lpAssemblyDirectory to the install
                            // directory to prevent Win32 Side by Side from
                            // looking for comctl32 in the application
                            // directory, which could cause a bogus dll to be
                            // placed there and open a security hole.
                            enableThemingActivationContext.lpAssemblyDirectory = installDir;
                            enableThemingActivationContext.dwFlags = ACTCTX_FLAG_ASSEMBLY_DIRECTORY_VALID; 

                            // Note this will fail gracefully if file specified
                            // by manifestLoc doesn't exist.
                            hActCtx = CreateActCtx(ref enableThemingActivationContext);
                            contextCreationSucceeded = (hActCtx != new IntPtr(-1));
                        }
                    }

                    // If we return false, we'll try again on the next call into
                    // EnsureActivateContextCreated(), which is fine.
                    return contextCreationSucceeded;
                }
            }

            // All the pinvoke goo...
            [DllImport(ExternDll.Kernel32)]
            private extern static IntPtr CreateActCtx(ref ACTCTX actctx);
            [DllImport(ExternDll.Kernel32)]
            private extern static bool ActivateActCtx(IntPtr hActCtx, out ulong lpCookie);
            [DllImport(ExternDll.Kernel32)]
            private extern static bool DeactivateActCtx(ulong dwFlags, ulong lpCookie);

            private const int ACTCTX_FLAG_ASSEMBLY_DIRECTORY_VALID = 0x004;
            
            private struct ACTCTX 
            {
                public int       cbSize;
                public uint      dwFlags;
                public string    lpSource;
                public ushort    wProcessorArchitecture;
                public ushort    wLangId;
                public string    lpAssemblyDirectory;
                public string    lpResourceName;
                public string    lpApplicationName;
            }
        }


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\scrollbars.cs ===
//------------------------------------------------------------------------------
// <copyright file="ScrollBars.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    using System.Drawing;
    using Microsoft.Win32;


    /// <include file='doc\ScrollBars.uex' path='docs/doc[@for="ScrollBars"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies
    ///       which scroll bars will be visible on a control.
    ///       
    ///    </para>
    /// </devdoc>
    public enum ScrollBars {

        /// <include file='doc\ScrollBars.uex' path='docs/doc[@for="ScrollBars.None"]/*' />
        /// <devdoc>
        ///    <para>
        ///       No scroll bars are shown.
        ///       
        ///    </para>
        /// </devdoc>
        None       = 0,

        /// <include file='doc\ScrollBars.uex' path='docs/doc[@for="ScrollBars.Horizontal"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Only horizontal scroll bars are shown.
        ///       
        ///    </para>
        /// </devdoc>
        Horizontal = 1,

        /// <include file='doc\ScrollBars.uex' path='docs/doc[@for="ScrollBars.Vertical"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Only vertical scroll bars are shown.
        ///       
        ///    </para>
        /// </devdoc>
        Vertical   = 2,

        /// <include file='doc\ScrollBars.uex' path='docs/doc[@for="ScrollBars.Both"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Both horizontal and vertical scroll bars are shown.
        ///       
        ///    </para>
        /// </devdoc>
        Both       = 3,

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\scrollbutton.cs ===
//------------------------------------------------------------------------------
// <copyright file="ScrollButton.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;
    using System;
    using System.ComponentModel;
    using System.Drawing;
    using Microsoft.Win32;



    /// <include file='doc\ScrollButton.uex' path='docs/doc[@for="ScrollButton"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the type of
    ///       scroll arrow to create on a scroll bar.
    ///       
    ///    </para>
    /// </devdoc>
    public enum ScrollButton {

        /// <include file='doc\ScrollButton.uex' path='docs/doc[@for="ScrollButton.Down"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A down-scroll arrow.
        ///       
        ///    </para>
        /// </devdoc>
        Down = NativeMethods.DFCS_SCROLLDOWN,

        /// <include file='doc\ScrollButton.uex' path='docs/doc[@for="ScrollButton.Left"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A left-scroll arrow.
        ///       
        ///    </para>
        /// </devdoc>
        Left = NativeMethods.DFCS_SCROLLLEFT,

        /// <include file='doc\ScrollButton.uex' path='docs/doc[@for="ScrollButton.Right"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A right-scroll arrow.
        ///       
        ///    </para>
        /// </devdoc>
        Right = NativeMethods.DFCS_SCROLLRIGHT,

        /// <include file='doc\ScrollButton.uex' path='docs/doc[@for="ScrollButton.Up"]/*' />
        /// <devdoc>
        ///    <para>
        ///       An up-scroll arrow.
        ///       
        ///    </para>
        /// </devdoc>
        Up = NativeMethods.DFCS_SCROLLUP,

        /// <include file='doc\ScrollButton.uex' path='docs/doc[@for="ScrollButton.Min"]/*' />
        /// <devdoc>
        /// </devdoc>
        Min = NativeMethods.DFCS_SCROLLUP,
        
        /// <include file='doc\ScrollButton.uex' path='docs/doc[@for="ScrollButton.Max"]/*' />
        Max = NativeMethods.DFCS_SCROLLRIGHT,

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\scrollevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="ScrollEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    using System.Drawing;
    using Microsoft.Win32;


    /// <include file='doc\ScrollEvent.uex' path='docs/doc[@for="ScrollEventArgs"]/*' />
    /// <devdoc>
    /// <para>Provides data for the <see cref='System.Windows.Forms.ScrollBar.Scroll'/>
    /// event.</para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    public class ScrollEventArgs : EventArgs {

        readonly ScrollEventType type;
        int newValue;

        /// <include file='doc\ScrollEvent.uex' path='docs/doc[@for="ScrollEventArgs.ScrollEventArgs"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Windows.Forms.ScrollEventArgs'/>class.
        ///       
        ///    </para>
        /// </devdoc>
        public ScrollEventArgs(ScrollEventType type, int newValue) {
            this.type = type;
            this.newValue = newValue;
        }

        /// <include file='doc\ScrollEvent.uex' path='docs/doc[@for="ScrollEventArgs.Type"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies the type of scroll event that occurred.
        ///       
        ///    </para>
        /// </devdoc>
        public ScrollEventType Type {
            get {
                return type;
            }
        }

        /// <include file='doc\ScrollEvent.uex' path='docs/doc[@for="ScrollEventArgs.NewValue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies the new location of the scroll box
        ///       within the
        ///       scroll bar.
        ///       
        ///    </para>
        /// </devdoc>
        public int NewValue {
            get {
                return newValue;
            }
            set {
                newValue = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\scrolleventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="ScrollEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;


    /// <include file='doc\ScrollEventHandler.uex' path='docs/doc[@for="ScrollEventHandler"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents the method that handles the
    ///    <see langword='Scroll'/> event of a <see cref='System.Windows.Forms.ScrollBar'/>, <see cref='System.Windows.Forms.TrackBar'/>, or 
    ///    <see cref='System.Windows.Forms.DataGrid'/>.
    ///       
    ///    </para>
    /// </devdoc>
    public delegate void ScrollEventHandler(object sender, ScrollEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\scrolleventtype.cs ===
//------------------------------------------------------------------------------
// <copyright file="ScrollEventType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {

    using System.Diagnostics;
    using System;
    using System.ComponentModel;
    using System.Drawing;
    using Microsoft.Win32;


    /// <include file='doc\ScrollEventType.uex' path='docs/doc[@for="ScrollEventType"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the type of action used to raise the <see cref='System.Windows.Forms.ScrollBar.Scroll'/> event.
    ///       
    ///    </para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    public enum ScrollEventType {

        /// <include file='doc\ScrollEventType.uex' path='docs/doc[@for="ScrollEventType.SmallDecrement"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The
        ///       scroll box was
        ///       moved a small
        ///       distance. The user clicked the left(horizontal) or top(vertical) scroll arrow or pressed the UP ARROW
        ///       key.
        ///       
        ///    </para>
        /// </devdoc>
        SmallDecrement = NativeMethods.SB_LINELEFT,

        /// <include file='doc\ScrollEventType.uex' path='docs/doc[@for="ScrollEventType.SmallIncrement"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The
        ///       scroll box was
        ///       moved a small distance. The user clicked the right(horizontal) or bottom(vertical) scroll arrow or
        ///       pressed the DOWN ARROW key.
        ///       
        ///    </para>
        /// </devdoc>
        SmallIncrement = NativeMethods.SB_LINERIGHT,

        /// <include file='doc\ScrollEventType.uex' path='docs/doc[@for="ScrollEventType.LargeDecrement"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The scroll box
        ///       moved a large distance. The user clicked the scroll bar to the left(horizontal) or above(vertical)
        ///       the scroll box, or pressed the PAGE UP key.
        ///       
        ///    </para>
        /// </devdoc>
        LargeDecrement = NativeMethods.SB_PAGELEFT,

        /// <include file='doc\ScrollEventType.uex' path='docs/doc[@for="ScrollEventType.LargeIncrement"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The scroll box moved a large distance. The user clicked the scroll bar to
        ///       the right(horizontal) or below(vertical) the scroll box, or pressed the PAGE DOWN key.
        ///       
        ///    </para>
        /// </devdoc>
        LargeIncrement = NativeMethods.SB_PAGERIGHT,

        /// <include file='doc\ScrollEventType.uex' path='docs/doc[@for="ScrollEventType.ThumbPosition"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The scroll box was moved.
        ///       
        ///    </para>
        /// </devdoc>
        ThumbPosition = NativeMethods.SB_THUMBPOSITION,

        /// <include file='doc\ScrollEventType.uex' path='docs/doc[@for="ScrollEventType.ThumbTrack"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The scroll box
        ///       is currently being moved.
        ///       
        ///    </para>
        /// </devdoc>
        ThumbTrack = NativeMethods.SB_THUMBTRACK,

        /// <include file='doc\ScrollEventType.uex' path='docs/doc[@for="ScrollEventType.First"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The
        ///       scroll box was moved to the <see cref='System.Windows.Forms.ScrollBar.Minimum'/>
        ///       position.
        ///       
        ///    </para>
        /// </devdoc>
        First = NativeMethods.SB_LEFT,

        /// <include file='doc\ScrollEventType.uex' path='docs/doc[@for="ScrollEventType.Last"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The
        ///       scroll box was moved to the <see cref='System.Windows.Forms.ScrollBar.Maximum'/>
        ///       position.
        ///       
        ///    </para>
        /// </devdoc>
        Last = NativeMethods.SB_RIGHT,

        /// <include file='doc\ScrollEventType.uex' path='docs/doc[@for="ScrollEventType.EndScroll"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The scroll box has stopped moving.
        ///       
        ///    </para>
        /// </devdoc>
        EndScroll = NativeMethods.SB_ENDSCROLL,

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\securityidtype.cs ===
//------------------------------------------------------------------------------
// <copyright file="SecurityIDType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;
    
    using System;

    /// <include file='doc\SecurityIDType.uex' path='docs/doc[@for="SecurityIDType"]/*' />
    /// <internalonly/>
    /// <devdoc>
    /// </devdoc>
    public enum SecurityIDType {
        /// <include file='doc\SecurityIDType.uex' path='docs/doc[@for="SecurityIDType.User"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        User           = 1,
        /// <include file='doc\SecurityIDType.uex' path='docs/doc[@for="SecurityIDType.Group"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Group          = 2,
        /// <include file='doc\SecurityIDType.uex' path='docs/doc[@for="SecurityIDType.Domain"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Domain         = 3,
        /// <include file='doc\SecurityIDType.uex' path='docs/doc[@for="SecurityIDType.Alias"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Alias          = 4,
        /// <include file='doc\SecurityIDType.uex' path='docs/doc[@for="SecurityIDType.WellKnownGroup"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        WellKnownGroup = 5,
        /// <include file='doc\SecurityIDType.uex' path='docs/doc[@for="SecurityIDType.DeletedAccount"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        DeletedAccount = 6,
        /// <include file='doc\SecurityIDType.uex' path='docs/doc[@for="SecurityIDType.Invalid"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Invalid        = 7,
        /// <include file='doc\SecurityIDType.uex' path='docs/doc[@for="SecurityIDType.Unknown"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Unknown        = 8,
        /// <include file='doc\SecurityIDType.uex' path='docs/doc[@for="SecurityIDType.Computer"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Computer       = 9,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\scrollablecontrol.cs ===
//------------------------------------------------------------------------------
// <copyright file="ScrollableControl.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;

    using System.Diagnostics;

    using System;
    using System.Security.Permissions;
    using System.Reflection;
    using System.Windows.Forms;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Drawing;
    using Microsoft.Win32;
    
    /// <include file='doc\ScrollableControl.uex' path='docs/doc[@for="ScrollableControl"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Defines a base class for controls that support auto-scrolling behavior.
    ///    </para>
    /// </devdoc>
    [
    Designer("System.Windows.Forms.Design.ScrollableControlDesigner, " + AssemblyRef.SystemDesign)
    ]
    public class ScrollableControl : Control {
#if DEBUG        
        internal static readonly TraceSwitch AutoScrolling = new TraceSwitch("AutoScrolling", "Debug autoscrolling logic");
#else
        internal static readonly TraceSwitch AutoScrolling;
#endif

        /// <include file='doc\ScrollableControl.uex' path='docs/doc[@for="ScrollableControl.ScrollStateAutoScrolling"]/*' />
        /// <internalonly/>
        protected const int ScrollStateAutoScrolling     =  0x0001;
        /// <include file='doc\ScrollableControl.uex' path='docs/doc[@for="ScrollableControl.ScrollStateHScrollVisible"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected const int ScrollStateHScrollVisible    =  0x0002;
        /// <include file='doc\ScrollableControl.uex' path='docs/doc[@for="ScrollableControl.ScrollStateVScrollVisible"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected const int ScrollStateVScrollVisible    =  0x0004;
        /// <include file='doc\ScrollableControl.uex' path='docs/doc[@for="ScrollableControl.ScrollStateUserHasScrolled"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected const int ScrollStateUserHasScrolled   =  0x0008;
        /// <include file='doc\ScrollableControl.uex' path='docs/doc[@for="ScrollableControl.ScrollStateFullDrag"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected const int ScrollStateFullDrag          =  0x0010;

        /// <devdoc>
        ///     Number of pixels to scroll the client region as a "line" for autoscroll.
        /// </devdoc>
        /// <internalonly/>
        private const int SCROLL_LINE = 5;


        private Size       userAutoScrollMinSize = System.Drawing.Size.Empty;
        /// <devdoc>
        ///     Current size of the displayRect.
        /// </devdoc>
        /// <internalonly/>
        private Rectangle   displayRect = Rectangle.Empty;
        /// <devdoc>
        ///     Current margins for autoscrolling.
        /// </devdoc>
        /// <internalonly/>
        private Size       scrollMargin = System.Drawing.Size.Empty;
        /// <devdoc>
        ///     User requested margins for autoscrolling.
        /// </devdoc>
        /// <internalonly/>
        private Size       requestedScrollMargin = System.Drawing.Size.Empty;
        /// <devdoc>
        ///     User requested autoscroll position - used for form creation only.
        /// </devdoc>
        /// <internalonly/>
        internal Point       scrollPosition = Point.Empty;

        private DockPaddingEdges dockPadding = null;

        private int         scrollState;

        /// <include file='doc\ScrollableControl.uex' path='docs/doc[@for="ScrollableControl.ScrollableControl"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Windows.Forms.ScrollableControl'/> class.
        ///    </para>
        /// </devdoc>
        public ScrollableControl()
        : base() {
            SetStyle(ControlStyles.ContainerControl, true);
            SetStyle(ControlStyles.AllPaintingInWmPaint, false);
            SetScrollState(ScrollStateAutoScrolling, false);
        }

        /// <include file='doc\ScrollableControl.uex' path='docs/doc[@for="ScrollableControl.AutoScroll"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       or sets a value
        ///       indicating whether the container will allow the user to scroll to any
        ///       controls placed outside of its visible boundaries.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatLayout),
        Localizable(true),
        DefaultValue(false),
        SRDescription(SR.FormAutoScrollDescr)
        ]
        public virtual bool AutoScroll {
            get {
                return GetScrollState(ScrollStateAutoScrolling);
            }

            set {
                if (value) {
                    UpdateFullDrag();
                }

                SetScrollState(ScrollStateAutoScrolling, value);
                PerformLayout();
            }
        }

        /// <include file='doc\ScrollableControl.uex' path='docs/doc[@for="ScrollableControl.AutoScrollMargin"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or
        ///       sets the size of the auto-scroll
        ///       margin.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatLayout),
        Localizable(true),
        SRDescription(SR.FormAutoScrollMarginDescr)
        ]
        public Size AutoScrollMargin {
            get {
                return requestedScrollMargin;
            }

            set {
                if (value.Width < 0 || value.Height < 0) {
                    throw new ArgumentException(SR.GetString(SR.InvalidArgument, "AutoScrollMargin", value.ToString()));
                }
                SetAutoScrollMargin(value.Width, value.Height);
            }
        }

        /// <include file='doc\ScrollableControl.uex' path='docs/doc[@for="ScrollableControl.AutoScrollPosition"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the location of the auto-scroll position.</para>
        /// </devdoc>
        [
        SRCategory(SR.CatLayout),
        Browsable(false), 
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.FormAutoScrollPositionDescr)        
        ]
        public Point AutoScrollPosition {
            get {
                Rectangle rect = GetDisplayRectInternal();
                return new Point(rect.X, rect.Y);
            }

            set {
                if (Created) {
                    SetDisplayRectLocation(-value.X, -value.Y);
                    SyncScrollbars();
                }

                scrollPosition = value;
            }
        }

        /// <include file='doc\ScrollableControl.uex' path='docs/doc[@for="ScrollableControl.AutoScrollMinSize"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the mimimum size of the auto-scroll.</para>
        /// </devdoc>
        [
        SRCategory(SR.CatLayout),
        Localizable(true),
        SRDescription(SR.FormAutoScrollMinSizeDescr)
        ]
        public Size AutoScrollMinSize {
            get {
                return userAutoScrollMinSize;
            }

            set {
                if (value != userAutoScrollMinSize) {
                    userAutoScrollMinSize = value;
                    AutoScroll = true;
                    PerformLayout();
                }
            }
        }

        /// <include file='doc\ScrollableControl.uex' path='docs/doc[@for="ScrollableControl.CreateParams"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Retrieves the CreateParams used to create the window.
        ///       If a subclass overrides this function, it must call the base implementation.
        ///    </para>
        /// </devdoc>
        protected override CreateParams CreateParams {
            [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
            get {
                CreateParams cp = base.CreateParams;

                if (HScroll) {
                    cp.Style |= NativeMethods.WS_HSCROLL;
                }
                else {
                    cp.Style &= (~NativeMethods.WS_HSCROLL);
                }
                if (VScroll) {
                    cp.Style |= NativeMethods.WS_VSCROLL;
                }
                else {
                    cp.Style &= (~NativeMethods.WS_VSCROLL);
                }

                return cp;
            }
        }

        /// <include file='doc\ScrollableControl.uex' path='docs/doc[@for="ScrollableControl.DisplayRectangle"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Retreives the current display rectangle. The display rectangle
        ///       is the virtual display area that is used to layout components.
        ///       The position and dimensions of the Form's display rectangle
        ///       change during autoScroll.
        ///    </para>
        /// </devdoc>
        public override Rectangle DisplayRectangle {
            get {
                Rectangle rect = base.ClientRectangle;
                if (!displayRect.IsEmpty) {
                    rect.X = displayRect.X;
                    rect.Y = displayRect.Y;
                    if (HScroll) {
                        rect.Width = displayRect.Width;
                    }
                    if (VScroll) {
                        rect.Height = displayRect.Height;
                    }
                }

                if (dockPadding != null) {
                    rect.X += dockPadding.left;
                    rect.Y += dockPadding.top;
                    rect.Width -= dockPadding.left + dockPadding.right;
                    rect.Height -= dockPadding.top + dockPadding.bottom;
                }

                return rect;
            }
        }

        /// <include file='doc\ScrollableControl.uex' path='docs/doc[@for="ScrollableControl.HScroll"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or
        ///       sets a value indicating whether the horizontal scroll bar is visible.
        ///    </para>
        /// </devdoc>
        protected bool HScroll {
            get {
                return GetScrollState(ScrollStateHScrollVisible);
            }
            set { 
                SetScrollState(ScrollStateHScrollVisible, value);
            }
        }


        /// <include file='doc\ScrollableControl.uex' path='docs/doc[@for="ScrollableControl.VScroll"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or
        ///       sets a value indicating whether the vertical scroll bar is visible.
        ///    </para>
        /// </devdoc>
        protected bool VScroll {
            get { 
                return GetScrollState(ScrollStateVScrollVisible);
            }
            set {
                SetScrollState(ScrollStateVScrollVisible, value);
            }
        }

        /// <include file='doc\ScrollableControl.uex' path='docs/doc[@for="ScrollableControl.DockPadding"]/*' />
        /// <devdoc>
        ///    <para>Gets the dock padding settings for all
        ///       edges of the control.</para>
        /// </devdoc>
        [
        SRCategory(SR.CatLayout),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Content),
        SRDescription(SR.FormPaddingDescr),
        Localizable(true)
        ]
        public DockPaddingEdges DockPadding {
            get {
                if (dockPadding == null) {
                    dockPadding = new DockPaddingEdges(this);
                }
                return dockPadding;
            }
        }

        /// <include file='doc\ScrollableControl.uex' path='docs/doc[@for="ScrollableControl.AdjustFormScrollbars"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adjusts
        ///       the auto-scroll bars on the container based on the current control
        ///       positions and the control currently selected.
        ///    </para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void AdjustFormScrollbars(bool displayScrollbars) {
            bool needLayout = false;

            Rectangle display = GetDisplayRectInternal();

            if (!displayScrollbars && (HScroll || VScroll)) {
                needLayout = SetVisibleScrollbars(false, false);
            }

            if (!displayScrollbars) {
                Rectangle client = ClientRectangle;
                display.Width = client.Width;
                display.Height = client.Height;
            }
            else {
                needLayout |= ApplyScrollbarChanges(display);
            }

            if (needLayout) {
                PerformLayout();
            }
        }
        
        private bool ApplyScrollbarChanges(Rectangle display) {
            Debug.WriteLineIf(CompModSwitches.RichLayout.TraceInfo, GetType().Name + "::ApplyScrollbarChanges(" + display + ") {");
            Debug.Indent();

            bool needLayout = false;
            bool needHscroll = false;
            bool needVscroll = false;
            Rectangle currentClient = ClientRectangle;
            Rectangle fullClient = currentClient;
            Rectangle minClient = fullClient;
            if (HScroll) {
                fullClient.Height += SystemInformation.HorizontalScrollBarHeight;
            }
            else {
                minClient.Height -= SystemInformation.HorizontalScrollBarHeight;
            }
            if (VScroll) {
                fullClient.Width += SystemInformation.VerticalScrollBarWidth;
            }
            else {
                minClient.Width -= SystemInformation.VerticalScrollBarWidth;
            }
            
            
            int maxX = minClient.Width;
            int maxY = minClient.Height;

            if (Controls.Count != 0) {

                // Compute the actual scroll margins (take into account docked
                // things.)
                //
                scrollMargin = requestedScrollMargin;
                
                if (dockPadding != null) {
                    scrollMargin.Height += dockPadding.bottom;
                    scrollMargin.Width += dockPadding.right;
                }
                
                for (int i=0; i<Controls.Count; i++) {
                    Control current = Controls[i];

                    // Since Control.Visible checks the parent visibility, we
                    // want to see if this control will be visible if we
                    // become visible. This prevents a nasty painting issue
                    // if we suddenly update windows styles in response
                    // to a WM_SHOWWINDOW.
                    //
                    // In addition, this is the more correct thing, because
                    // we want to layout the children with respect to their
                    // "local" visibility, not the hierarchy.
                    //
                    if (current != null && current.GetState(STATE_VISIBLE)) {
                        switch (((Control)current).Dock) {
                            case DockStyle.Bottom:
                                scrollMargin.Height += current.Size.Height;
                                break;
                            case DockStyle.Right:
                                scrollMargin.Width += current.Size.Width;
                                break;
                        }
                    }
                }
            }

            if (!userAutoScrollMinSize.IsEmpty) {
                maxX = userAutoScrollMinSize.Width + scrollMargin.Width;
                maxY = userAutoScrollMinSize.Height + scrollMargin.Height;
                needHscroll = true;
                needVscroll = true;
            }

            if (Controls.Count != 0) {

                // Compute the dimensions of the display rect
                //
                for (int i=0; i<Controls.Count; i++) {
                    bool watchHoriz = true;
                    bool watchVert = true;

                    Control current = Controls[i];

                    // Same logic as the margin calc - you need to see if the
                    // control *will* be visible... 
                    //
                    if (current != null && current.GetState(STATE_VISIBLE)) {

                        Control richCurrent = (Control)current;

                        switch (richCurrent.Dock) {
                            case DockStyle.Top:
                                watchHoriz = false;
                                break;
                            case DockStyle.Left:
                                watchVert = false;
                                break;
                            case DockStyle.Bottom:
                            case DockStyle.Fill:
                            case DockStyle.Right:
                                watchHoriz = false;
                                watchVert = false;
                                break;
                            default:
                                AnchorStyles anchor = richCurrent.Anchor;
                                if ((anchor & AnchorStyles.Right) == AnchorStyles.Right) {
                                    watchHoriz = false;
                                }
                                if ((anchor & AnchorStyles.Left) != AnchorStyles.Left) {
                                    watchHoriz = false;
                                }
                                if ((anchor & AnchorStyles.Bottom) == AnchorStyles.Bottom) {
                                    watchVert = false;
                                }
                                if ((anchor & AnchorStyles.Top) != AnchorStyles.Top) {
                                    watchVert = false;
                                }
                                break;
                        }

                        if (watchHoriz || watchVert) {
                            Rectangle bounds = current.Bounds;
                            int ctlRight = -display.X + bounds.X + bounds.Width + scrollMargin.Width;
                            int ctlBottom = -display.Y + bounds.Y + bounds.Height + scrollMargin.Height;

                            if (ctlRight > maxX && watchHoriz) {
                                needHscroll = true;
                                maxX = ctlRight;
                            }
                            if (ctlBottom > maxY && watchVert) {
                                needVscroll = true;
                                maxY = ctlBottom;
                            }
                        }
                    }
                }
            }

            // Check maxX/maxY against the clientRect, we must compare it to the
            // clientRect without any scrollbars, and then we can check it against
            // the clientRect with the "new" scrollbars. This will make the
            // scrollbars show and hide themselves correctly at the boundaries.
            //
            if (maxX <= fullClient.Width) {
                needHscroll = false;
            }
            if (maxY <= fullClient.Height) {
                needVscroll = false;
            }
            Rectangle clientToBe = fullClient;
            if (needHscroll) {
                clientToBe.Height -= SystemInformation.HorizontalScrollBarHeight;
            }
            if (needVscroll) {
                clientToBe.Width -= SystemInformation.VerticalScrollBarWidth;
            }
            if (needHscroll && maxY > clientToBe.Height) {
                needVscroll = true;
            }
            if (needVscroll && maxX > clientToBe.Width) {
                needHscroll = true;
            }
            if (!needHscroll) {
                maxX = clientToBe.Width;
            }
            if (!needVscroll) {
                maxY = clientToBe.Height;
            }

            Debug.WriteLineIf(CompModSwitches.RichLayout.TraceInfo, "Current scrollbars(" + HScroll + ", " + VScroll + ")");
            Debug.WriteLineIf(CompModSwitches.RichLayout.TraceInfo, "Needed  scrollbars(" + needHscroll + ", " + needVscroll + ")");

            // Show the needed scrollbars
            //
            needLayout = (SetVisibleScrollbars(needHscroll, needVscroll) || needLayout);

            // If needed, adjust the size...
            //
            if (HScroll || VScroll) {
                needLayout = (SetDisplayRectangleSize(maxX, maxY) || needLayout);
            }
            // Else just update the display rect size... this keeps it as big as the client
            // area in a resize scenario
            //
            else {
                SetDisplayRectangleSize(maxX, maxY);
            }

            // Sync up the scrollbars
            //
            SyncScrollbars();

            Debug.WriteLineIf(CompModSwitches.RichLayout.TraceInfo, needLayout ? "Need layout" : "No layout changes");
            Debug.Unindent();
            Debug.WriteLineIf(CompModSwitches.RichLayout.TraceInfo, "}");
            return needLayout;
        }

        private Rectangle GetDisplayRectInternal() {
            if (displayRect.IsEmpty) {
                displayRect = ClientRectangle;
            }

            return displayRect;
        }


        /// <include file='doc\ScrollableControl.uex' path='docs/doc[@for="ScrollableControl.GetScrollState"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Tests a given scroll state bit to determine if it is set.
        ///    </para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected bool GetScrollState(int bit) {
            return(bit & scrollState) == bit;
        }

        /// <include file='doc\ScrollableControl.uex' path='docs/doc[@for="ScrollableControl.OnLayout"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    Forces the layout of any docked or anchored child controls.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected override void OnLayout(LayoutEventArgs levent) {

            // V#33515 - ChrisAn, 3/18/1998
            // We get into a problem when you change the docking of a control
            // with autosizing on. Since the control (affectedControl) has
            // already had the dock property changed, adjustFormScrollbars
            // treats it as a docked control. However, since base.onLayout
            // hasn't been called yet, the bounds of the control haven't been
            // changed.
            //
            // We can't just call base.onLayout() once in this case, since
            // adjusting the scrollbars COULD adjust the display area, and
            // thus require a new layout. The result is that when you
            // affect a control's layout, we are forced to layout twice. There
            // isn't any noticible flicker, but this could be a perf problem...
            //
            if (levent.AffectedControl != null && AutoScroll) {
                base.OnLayout(levent);
            }
            AdjustFormScrollbars(AutoScroll);
            base.OnLayout(levent);
        }

        /// <include file='doc\ScrollableControl.uex' path='docs/doc[@for="ScrollableControl.OnMouseWheel"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///     Handles mouse wheel processing for our scrollbars.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected override void OnMouseWheel(MouseEventArgs e) {

            // Favor the vertical scroll bar, since it's the most
            // common use.  However, if there isn't a vertical 
            // scroll and the horizontal is on, then wheel it around.
            //
            if (VScroll) {
                Rectangle client = ClientRectangle;
                int pos = -displayRect.Y;
                int maxPos = -(client.Height - displayRect.Height);

                pos = Math.Max(pos - e.Delta, 0);
                pos = Math.Min(pos, maxPos);

                SetDisplayRectLocation(displayRect.X, -pos);
                SyncScrollbars();
            }
            else if (HScroll) {
                Rectangle client = ClientRectangle;
                int pos = -displayRect.X;
                int maxPos = -(client.Width - displayRect.Width);

                pos = Math.Max(pos - e.Delta, 0);
                pos = Math.Min(pos, maxPos);

                SetDisplayRectLocation(-pos, displayRect.Y);
                SyncScrollbars();
            }

            base.OnMouseWheel(e);
        }

        /// <include file='doc\ScrollableControl.uex' path='docs/doc[@for="ScrollableControl.OnVisibleChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected override void OnVisibleChanged(EventArgs e) {
            if (Visible) {
                // When the page becomes visible, we need to call OnLayout to adjust the scrollbars.
                PerformLayout();
            }

            base.OnVisibleChanged(e);
        }

        // internal for Form to call
        //
        internal void ScaleDockPadding(float dx, float dy) {
            if (dockPadding != null) {
                dockPadding.Scale(dx, dy);
            }
        }

        /// <include file='doc\ScrollableControl.uex' path='docs/doc[@for="ScrollableControl.ScaleCore"]/*' />
        protected override void ScaleCore(float dx, float dy) {
            ScaleDockPadding(dx, dy);
            base.ScaleCore(dx, dy);
        }

        /// <include file='doc\ScrollableControl.uex' path='docs/doc[@for="ScrollableControl.SetDisplayRectLocation"]/*' />
        /// <devdoc>
        ///    Adjusts the displayRect to be at the offset x, y. The contents of the
        ///    Form is scrolled using Windows.ScrollWindowEx.
        /// </devdoc>
        //
        // CONSIDER: make this private -- no one calls outside this class, and since it 
        // doesn't update the scrollbars, wouldn't be useful to them anyway.
        protected void SetDisplayRectLocation(int x, int y) {
            int xDelta = 0;
            int yDelta = 0;


            Rectangle client = ClientRectangle;
            int minX = Math.Min(client.Width - displayRect.Width, 0);
            int minY = Math.Min(client.Height - displayRect.Height, 0);

            if (x > 0) {
                x = 0;
            }
            if (y > 0) {
                y = 0;
            }
            if (x < minX) {
                x = minX;
            }
            if (y < minY) {
                y = minY;
            }

            if (displayRect.X != x) {
                xDelta = x - displayRect.X;
            }
            if (displayRect.Y != y) {
                yDelta = y - displayRect.Y;
            }
            displayRect.X = x;
            displayRect.Y = y;

            if (xDelta != 0 || yDelta != 0 && IsHandleCreated) {
                Rectangle cr = ClientRectangle;
                NativeMethods.RECT rcClip = NativeMethods.RECT.FromXYWH(cr.X, cr.Y, cr.Width, cr.Height);
                NativeMethods.RECT rcUpdate = NativeMethods.RECT.FromXYWH(cr.X, cr.Y, cr.Width, cr.Height);
                SafeNativeMethods.ScrollWindowEx(new HandleRef(this, Handle), xDelta, yDelta, 
                                                 null,
                                                 ref rcClip, 
                                                 NativeMethods.NullHandleRef, 
                                                 ref rcUpdate,
                                                 NativeMethods.SW_INVALIDATE
                                                 | NativeMethods.SW_ERASE
                                                 | NativeMethods.SW_SCROLLCHILDREN);
            }

            // Force child controls to update bounds.
            //
            for (int i=0; i<Controls.Count; i++) {
                Control ctl = Controls[i];
                if (ctl != null && ctl.IsHandleCreated) {
                    ctl._UpdateBounds();
                }
            }
        }

        /// <include file='doc\ScrollableControl.uex' path='docs/doc[@for="ScrollableControl.ScrollControlIntoView"]/*' />
        /// <devdoc>
        ///    Scrolls the currently active control into view if we are an AutoScroll
        ///    Form that has the Horiz or Vert scrollbar displayed...
        /// </devdoc>
        public void ScrollControlIntoView(Control activeControl) {
            Debug.WriteLineIf(ScrollableControl.AutoScrolling.TraceVerbose, "ScrollControlIntoView(" + activeControl.GetType().FullName + ")");
            Debug.Indent();
            Rectangle client = ClientRectangle;

            if (IsDescendant(activeControl)
                && AutoScroll
                && (HScroll || VScroll)
                && activeControl != null
                && (client.Width > 0 && client.Height > 0)) {

                Debug.WriteLineIf(ScrollableControl.AutoScrolling.TraceVerbose, "Calculating...");

                int xCalc = displayRect.X;
                int yCalc = displayRect.Y;
                int xMargin = scrollMargin.Width;
                int yMargin = scrollMargin.Height;

                Rectangle bounds = activeControl.Bounds;
                if (activeControl.ParentInternal != this) {
                    Debug.WriteLineIf(ScrollableControl.AutoScrolling.TraceVerbose, "not direct child, original bounds: " + bounds);
                    bounds = this.RectangleToClient(activeControl.ParentInternal.RectangleToScreen(bounds));
                }
                Debug.WriteLineIf(ScrollableControl.AutoScrolling.TraceVerbose, "adjusted bounds: " + bounds);

                if (bounds.X < xMargin) {
                    xCalc = displayRect.X + xMargin - bounds.X;
                }
                else if (bounds.X + bounds.Width + xMargin > client.Width) {

                    xCalc = client.Width - (bounds.X + bounds.Width + xMargin - displayRect.X);

                    if (bounds.X + xCalc - displayRect.X < xMargin) {
                        xCalc = displayRect.X + xMargin - bounds.X;
                    }
                }

                if (bounds.Y < yMargin) {
                    yCalc = displayRect.Y + yMargin - bounds.Y;
                }
                else if (bounds.Y + bounds.Height + yMargin > client.Height) {

                    yCalc = client.Height - (bounds.Y + bounds.Height + yMargin - displayRect.Y);

                    if (bounds.Y + yCalc - displayRect.Y < yMargin) {
                        yCalc = displayRect.Y + yMargin - bounds.Y;
                    }
                }

                SetScrollState(ScrollStateUserHasScrolled, false);
                SetDisplayRectLocation(xCalc, yCalc);
                SyncScrollbars();
            }

            Debug.Unindent();
        }

        private int ScrollThumbPosition(int fnBar) {
            NativeMethods.SCROLLINFO si = new NativeMethods.SCROLLINFO();
            si.fMask = NativeMethods.SIF_TRACKPOS;
            SafeNativeMethods.GetScrollInfo(new HandleRef(this, Handle), fnBar, si);
            return si.nTrackPos;
        }

        /// <include file='doc\ScrollableControl.uex' path='docs/doc[@for="ScrollableControl.SetAutoScrollMargin"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Sets the size
        ///       of the auto-scroll margins.
        ///    </para>
        /// </devdoc>
        public void SetAutoScrollMargin(int x, int y) {
            // Make sure we're not setting the margins to negative numbers
            if (x < 0) {
                x = 0;
            }
            if (y < 0) {
                y = 0;
            }

            if (x != requestedScrollMargin.Width
                || y != requestedScrollMargin.Height) {

                requestedScrollMargin = new Size(x, y);
                if (AutoScroll) {
                    PerformLayout();
                }
            }
        }


        /// <devdoc>
        ///     Actually displays or hides the horiz and vert autoscrollbars. This will
        ///     also adjust the values of formState to reflect the new state
        /// </devdoc>
        private bool SetVisibleScrollbars(bool horiz, bool vert) {
            bool needLayout = false;

            if (!horiz && HScroll
                || horiz && !HScroll
                || !vert && VScroll
                || vert && !VScroll) {

                needLayout = true;
            }

            if (needLayout) {
                int x = displayRect.X;
                int y = displayRect.Y;
                if (!horiz) {
                    x = 0;
                }
                if (!vert) {
                    y = 0;
                }
                SetDisplayRectLocation(x, y);
                SetScrollState(ScrollStateUserHasScrolled, false);
                HScroll = horiz;
                VScroll = vert;
                UpdateStyles();
            }
            return needLayout;
        }

        /// <devdoc>
        ///     Sets the width and height of the virtual client area used in
        ///     autoscrolling. This will also adjust the x and y location of the
        ///     virtual client area if the new size forces it.
        /// </devdoc>
        /// <internalonly/>
        private bool SetDisplayRectangleSize(int width, int height) {
            bool needLayout = false;

            if (displayRect.Width != width
                || displayRect.Height != height) {

                displayRect.Width = width;
                displayRect.Height = height;
                needLayout = true;
            }

            int minX = ClientRectangle.Width - width;
            int minY = ClientRectangle.Height - height;

            if (minX > 0) minX = 0;
            if (minY > 0) minY = 0;

            int x = displayRect.X;
            int y = displayRect.Y;

            if (!HScroll) {
                x = 0;
            }
            if (!VScroll) {
                y = 0;
            }

            if (x < minX) {
                x = minX;
            }
            if (y < minY) {
                y = minY;
            }
            SetDisplayRectLocation(x, y);

            return needLayout;
        }

        /// <include file='doc\ScrollableControl.uex' path='docs/doc[@for="ScrollableControl.SetScrollState"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Sets a given scroll state bit.
        ///    </para>
        /// </devdoc>
        protected void SetScrollState(int bit, bool value) {
            if (value) {
                scrollState |= bit;
            }
            else {
                scrollState &= (~bit);
            }
        }

        /// <devdoc>
        ///    <para>
        ///       Indicates whether the <see cref='System.Windows.Forms.ScrollableControl.AutoScrollPosition'/>
        ///       property should be persisted.
        ///    </para>
        /// </devdoc>
        private bool ShouldSerializeAutoScrollPosition() {
            if (AutoScroll) {
                Point pt = AutoScrollPosition;
                if (pt.X != 0 || pt.Y != 0) {
                    return true;
                }
            }
            return false;
        }

        /// <devdoc>
        ///    <para>
        ///       Indicates whether the <see cref='System.Windows.Forms.ScrollableControl.AutoScrollMargin'/> property should be persisted.
        ///    </para>
        /// </devdoc>
        private bool ShouldSerializeAutoScrollMargin() {
            return !AutoScrollMargin.Equals(new Size(0,0));
        }

        /// <devdoc>
        ///    <para>
        ///       Indicates whether the <see cref='System.Windows.Forms.ScrollableControl.AutoScrollMinSize'/>
        ///       property should be persisted.
        ///    </para>
        /// </devdoc>
        private bool ShouldSerializeAutoScrollMinSize() {
            return !AutoScrollMinSize.Equals(new Size(0,0));
        }



        /// <devdoc>
        ///     Updates the value of the autoscroll scrollbars based on the current form
        ///     state. This is a one-way sync, updating the scrollbars only.
        /// </devdoc>
        /// <internalonly/>
        private void SyncScrollbars() {

            if (!IsHandleCreated) {
                return;
            }

            if (HScroll) {
                NativeMethods.SCROLLINFO horiz = new NativeMethods.SCROLLINFO();
                Rectangle client = ClientRectangle;

                horiz.cbSize = Marshal.SizeOf(typeof(NativeMethods.SCROLLINFO));
                horiz.fMask = NativeMethods.SIF_RANGE | NativeMethods.SIF_PAGE | NativeMethods.SIF_POS;
                horiz.nMin = 0;
                horiz.nMax = displayRect.Width - 1;
                horiz.nPos = -displayRect.X;
                horiz.nPage = client.Width;

                UnsafeNativeMethods.SetScrollInfo(new HandleRef(this, Handle), NativeMethods.SB_HORZ, horiz, true);
            }

            if (VScroll) {
                NativeMethods.SCROLLINFO vert = new NativeMethods.SCROLLINFO();
                Rectangle client = ClientRectangle;

                vert.cbSize = Marshal.SizeOf(typeof(NativeMethods.SCROLLINFO));
                vert.fMask = NativeMethods.SIF_RANGE | NativeMethods.SIF_PAGE | NativeMethods.SIF_POS;
                vert.nMin = 0;
                vert.nMax = displayRect.Height - 1;
                vert.nPos = -displayRect.Y;
                vert.nPage = client.Height;

                UnsafeNativeMethods.SetScrollInfo(new HandleRef(this, Handle), NativeMethods.SB_VERT, vert, true);
            }
        }

        /// <devdoc>
        ///     Queries the system to determine the users preference for full drag
        ///     of windows.
        /// </devdoc>
        private void UpdateFullDrag() {
            SetScrollState(ScrollStateFullDrag, SystemInformation.DragFullWindows);
        }


        /// <devdoc>
        ///     WM_VSCROLL handler
        /// </devdoc>
        /// <internalonly/>
        private void WmVScroll(ref Message m) {

            // The lparam is handle of the sending scrollbar, or NULL when
            // the scrollbar sending the message is the "form" scrollbar...
            //
            if (m.LParam != IntPtr.Zero) {
                base.WndProc(ref m);
                return;
            }

            Rectangle client = ClientRectangle;
            int pos = -displayRect.Y;
            int maxPos = -(client.Height - displayRect.Height);

            switch (NativeMethods.Util.LOWORD((int)m.WParam)) {
                case NativeMethods.SB_THUMBPOSITION:
                case NativeMethods.SB_THUMBTRACK:
                    pos = ScrollThumbPosition(NativeMethods.SB_VERT);                    
                    break;
                case NativeMethods.SB_LINEUP:
                    if (pos > 0) {
                        pos-=SCROLL_LINE;
                    }
                    else {
                        pos = 0;
                    }
                    break;
                case NativeMethods.SB_LINEDOWN:
                    if (pos < maxPos-SCROLL_LINE) {
                        pos+=SCROLL_LINE;
                    }
                    else {
                        pos = maxPos;
                    }
                    break;
                case NativeMethods.SB_PAGEUP:
                    if (pos > client.Height) {
                        pos-=client.Height;
                    }
                    else {
                        pos = 0;
                    }
                    break;
                case NativeMethods.SB_PAGEDOWN:
                    if (pos < maxPos-client.Height) {
                        pos+=client.Height;
                    }
                    else {
                        pos = maxPos;
                    }
                    break;
                case NativeMethods.SB_TOP:
                    pos = 0;
                    break;
                case NativeMethods.SB_BOTTOM:
                    pos = maxPos;
                    break;
            }

            if (GetScrollState(ScrollStateFullDrag) || NativeMethods.Util.LOWORD(m.WParam) != NativeMethods.SB_THUMBTRACK) {
                SetScrollState(ScrollStateUserHasScrolled, true);
                SetDisplayRectLocation(displayRect.X, -pos);
                SyncScrollbars();
            }
        }

        /// <devdoc>
        ///     WM_HSCROLL handler
        /// </devdoc>
        /// <internalonly/>
        private void WmHScroll(ref Message m) {

            // The lparam is handle of the sending scrollbar, or NULL when
            // the scrollbar sending the message is the "form" scrollbar...
            //
            if (m.LParam != IntPtr.Zero) {
                base.WndProc(ref m);
                return;
            }


            Rectangle client = ClientRectangle;
            int pos = -displayRect.X;
            int maxPos = -(client.Width - displayRect.Width);

            switch (NativeMethods.Util.LOWORD(m.WParam)) {
                case NativeMethods.SB_THUMBPOSITION:
                case NativeMethods.SB_THUMBTRACK:
                    pos = ScrollThumbPosition(NativeMethods.SB_HORZ);
                    break;
                case NativeMethods.SB_LINEUP:
                    if (pos > SCROLL_LINE) {
                        pos-=SCROLL_LINE;
                    }
                    else {
                        pos = 0;
                    }
                    break;
                case NativeMethods.SB_LINEDOWN:
                    if (pos < maxPos-SCROLL_LINE) {
                        pos+=SCROLL_LINE;
                    }
                    else {
                        pos = maxPos;
                    }
                    break;
                case NativeMethods.SB_PAGEUP:
                    if (pos > client.Width) {
                        pos-=client.Width;
                    }
                    else {
                        pos = 0;
                    }
                    break;
                case NativeMethods.SB_PAGEDOWN:
                    if (pos < maxPos-client.Width) {
                        pos+=client.Width;
                    }
                    else {
                        pos = maxPos;
                    }
                    break;
                case NativeMethods.SB_LEFT:
                    pos = 0;
                    break;
                case NativeMethods.SB_RIGHT:
                    pos = maxPos;
                    break;
            }
            if (GetScrollState(ScrollStateFullDrag) || NativeMethods.Util.LOWORD(m.WParam) != NativeMethods.SB_THUMBTRACK) {
                SetScrollState(ScrollStateUserHasScrolled, true);
                SetDisplayRectLocation(-pos, displayRect.Y);
                SyncScrollbars();
            }
        }

        private void WmSettingChange(ref Message m) {
            base.WndProc(ref m);
            UpdateFullDrag();
        }

        /// <include file='doc\ScrollableControl.uex' path='docs/doc[@for="ScrollableControl.WndProc"]/*' />
        /// <devdoc>
        ///    The button's window procedure.  Inheriting classes can override this
        ///    to add extra functionality, but should not forget to call
        ///    base.wndProc(m); to ensure the button continues to function properly.
        /// </devdoc>
        /// <internalonly/>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        protected override void WndProc(ref Message m) {
            switch (m.Msg) {
                case NativeMethods.WM_VSCROLL:
                    WmVScroll(ref m);
                    break;
                case NativeMethods.WM_HSCROLL:
                    WmHScroll(ref m);
                    break;
                case NativeMethods.WM_SETTINGCHANGE:
                    WmSettingChange(ref m);
                    break;
                default:
                    base.WndProc(ref m);
            break;
            }
        }

        /// <include file='doc\ScrollableControl.uex' path='docs/doc[@for="ScrollableControl.DockPaddingEdges"]/*' />
        /// <devdoc>
        ///    <para>Determines the border padding for
        ///       docked controls.</para>
        /// </devdoc>
        [
        TypeConverterAttribute(typeof(DockPaddingEdgesConverter))
        ]
        public class DockPaddingEdges : ICloneable {
            private ScrollableControl owner;
            internal bool all = true;
            internal int top = 0;
            internal int left = 0;
            internal int right = 0;
            internal int bottom = 0;

            /// <devdoc>
            ///     Creates a new DockPaddingEdges. The specified owner will
            ///     be notified when the values are changed.
            /// </devdoc>
            internal DockPaddingEdges(ScrollableControl owner) {
                this.owner = owner;
            }

            /// <include file='doc\ScrollableControl.uex' path='docs/doc[@for="ScrollableControl.DockPaddingEdges.All"]/*' />
            /// <devdoc>
            ///    <para>Gets
            ///       or
            ///       sets the padding width for all edges of a docked control.</para>
            /// </devdoc>
            [
            RefreshProperties(RefreshProperties.All),
            SRDescription(SR.PaddingAllDescr)
            ]
            public int All {
                get {
                    return all ? top : 0;
                }
                set {
                    if (all != true || top != value) {
                        all = true;
                        top = left = right = bottom = value;

                        owner.PerformLayout();
                    }
                }
            }

            /// <include file='doc\ScrollableControl.uex' path='docs/doc[@for="ScrollableControl.DockPaddingEdges.Bottom"]/*' />
            /// <devdoc>
            ///    <para>Gets
            ///       or
            ///       sets the padding width for the bottom edge of a docked control.</para>
            /// </devdoc>
            [
            RefreshProperties(RefreshProperties.All),
            SRDescription(SR.PaddingBottomDescr)
            ]
            public int Bottom {
                get {
                    if (all) {
                        return top;
                    }
                    return bottom;
                }
                set {
                    if (all || bottom != value) {
                        all = false;
                        bottom = value;
                        owner.PerformLayout();
                    }
                }
            }

            /// <include file='doc\ScrollableControl.uex' path='docs/doc[@for="ScrollableControl.DockPaddingEdges.Left"]/*' />
            /// <devdoc>
            ///    <para>Gets
            ///       or sets the padding width for the left edge of a docked control.</para>
            /// </devdoc>
            [
            RefreshProperties(RefreshProperties.All),
            SRDescription(SR.PaddingLeftDescr)
            ]
            public int Left {
                get {
                    if (all) {
                        return top;
                    }
                    return left;
                }
                set {
                    if (all || left != value) {
                        all = false;
                        left = value;
                        owner.PerformLayout();
                    }
                }
            }

            /// <include file='doc\ScrollableControl.uex' path='docs/doc[@for="ScrollableControl.DockPaddingEdges.Right"]/*' />
            /// <devdoc>
            ///    <para>Gets
            ///       or sets the padding width for the right edge of a docked control.</para>
            /// </devdoc>
            [
            RefreshProperties(RefreshProperties.All),
            SRDescription(SR.PaddingRightDescr)
            ]
            public int Right {
                get {
                    if (all) {
                        return top;
                    }
                    return right;
                }
                set {
                    if (all || right != value) {
                        all = false;
                        right = value;
                        owner.PerformLayout();
                    }
                }
            }

            /// <include file='doc\ScrollableControl.uex' path='docs/doc[@for="ScrollableControl.DockPaddingEdges.Top"]/*' />
            /// <devdoc>
            ///    <para>Gets
            ///       or sets the padding width for the top edge of a docked control.</para>
            /// </devdoc>
            [
            RefreshProperties(RefreshProperties.All),
            SRDescription(SR.PaddingTopDescr)
            ]
            public int Top {
                get {
                    return top;
                }
                set {
                    if (all || top != value) {
                        all = false;
                        top = value;
                        owner.PerformLayout();
                    }
                }
            }

            /// <include file='doc\ScrollableControl.uex' path='docs/doc[@for="ScrollableControl.DockPaddingEdges.Equals"]/*' />
            /// <internalonly/>
            public override bool Equals(object other) {
                DockPaddingEdges dpeOther = other as DockPaddingEdges;

                if (dpeOther == null) {
                    return false;
                }

                return dpeOther.all == all && 
                       dpeOther.top == top && 
                       dpeOther.left == left && 
                       dpeOther.bottom == bottom && 
                       dpeOther.right == right;
            }

            /// <include file='doc\ScrollableControl.uex' path='docs/doc[@for="ScrollableControl.DockPaddingEdges.GetHashCode"]/*' />
            /// <internalonly/>
            public override int GetHashCode() {
                return base.GetHashCode();
            }


            /// <internalonly/>
            private void ResetAll() {
                All = 0;
            }

            /// <internalonly/>
            private void ResetBottom() {
                Bottom = 0;
            }

            /// <internalonly/>
            private void ResetLeft() {
                Left = 0;
            }

            /// <internalonly/>
            private void ResetRight() {
                Right = 0;
            }

            /// <internalonly/>
            private void ResetTop() {
                Top = 0;
            }

            internal void Scale(float dx, float dy) {
                top = (int)((float)top * dy);
                left = (int)((float)left * dx);
                right = (int)((float)right * dx);
                bottom = (int)((float)bottom * dy);
            }

            /// <internalonly/>
            private bool ShouldSerializeAll() {
                return all && top != 0;
            }

            /// <internalonly/>
            private bool ShouldSerializeBottom() {
                return !all && bottom != 0;
            }

            /// <internalonly/>
            private bool ShouldSerializeLeft() {
                return !all && left != 0;
            }

            /// <internalonly/>
            private bool ShouldSerializeRight() {
                return !all && right != 0;
            }

            /// <internalonly/>
            private bool ShouldSerializeTop() {
                return !all && top != 0;
            }

            /// <include file='doc\ScrollableControl.uex' path='docs/doc[@for="ScrollableControl.DockPaddingEdges.ToString"]/*' />
            /// <internalonly/>
            public override string ToString() {
                return "";      // used to say "(DockPadding)" but that's useless
            }

            /// <include file='doc\ScrollableControl.uex' path='docs/doc[@for="DockPaddingEdges.ICloneable.Clone"]/*' />
            /// <internalonly/>
            object ICloneable.Clone() {
                DockPaddingEdges dpe = new DockPaddingEdges(owner);
                dpe.all = all;
                dpe.top = top;
                dpe.right = right;
                dpe.bottom = bottom;
                dpe.left = left;
                return dpe;
            }
        }


        /// <include file='doc\ScrollableControl.uex' path='docs/doc[@for="ScrollableControl.DockPaddingEdgesConverter"]/*' />
        public class DockPaddingEdgesConverter : TypeConverter {
            /// <include file='doc\ScrollableControl.uex' path='docs/doc[@for="ScrollableControl.DockPaddingEdgesConverter.GetProperties"]/*' />
            /// <devdoc>
            ///    Retrieves the set of properties for this type.  By default, a type has
            ///    does not return any properties.  An easy implementation of this method
            ///    can just call TypeDescriptor.GetProperties for the correct data type.
            /// </devdoc>
            public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes) {
                PropertyDescriptorCollection props = TypeDescriptor.GetProperties(typeof(DockPaddingEdges), attributes);
                return props.Sort(new string[] {"All", "Left", "Top", "Right", "Bottom"});
            }

            /// <include file='doc\ScrollableControl.uex' path='docs/doc[@for="ScrollableControl.DockPaddingEdgesConverter.GetPropertiesSupported"]/*' />
            /// <devdoc>
            ///    Determines if this object supports properties.  By default, this
            ///    is false.
            /// </devdoc>
            public override bool GetPropertiesSupported(ITypeDescriptorContext context) {
                return true;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\selectedgriditemchangedeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="SelectedGridItemChangedEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {

    using System.Diagnostics;
    using System;
    using System.ComponentModel;

    /// <include file='doc\SelectedGridItemChangedEventHandler.uex' path='docs/doc[@for="SelectedGridItemChangedEventHandler"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public delegate void SelectedGridItemChangedEventHandler(object sender, SelectedGridItemChangedEventArgs e);
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\selectionmode.cs ===
//------------------------------------------------------------------------------
// <copyright file="SelectionMode.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    /// <include file='doc\SelectionMode.uex' path='docs/doc[@for="SelectionMode"]/*' />
    /// <devdoc>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    public enum SelectionMode {

        /// <include file='doc\SelectionMode.uex' path='docs/doc[@for="SelectionMode.None"]/*' />
        /// <devdoc>
        ///     indicates that no items can be selected.
        /// </devdoc>
        None             = 0,

        /// <include file='doc\SelectionMode.uex' path='docs/doc[@for="SelectionMode.One"]/*' />
        /// <devdoc>
        ///     indicates that only one item at a time can be selected.
        /// </devdoc>
        One              = 1,

        /// <include file='doc\SelectionMode.uex' path='docs/doc[@for="SelectionMode.MultiSimple"]/*' />
        /// <devdoc>
        ///     indicates that more than one item at a time can be selected.
        /// </devdoc>
        MultiSimple     = 2,

        /// <include file='doc\SelectionMode.uex' path='docs/doc[@for="SelectionMode.MultiExtended"]/*' />
        /// <devdoc>
        ///     Indicates that more than one item at a time can be selected, and
        ///     keyboard combinations, such as SHIFT and CTRL can be used to help
        ///     in selection.
        /// </devdoc>
        MultiExtended   = 3,

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\selectedgriditemchangedevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="SelectedGridItemChangedEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {

    using System.Diagnostics;
    using System;
    using System.ComponentModel;

    /// <include file='doc\SelectedGridItemChangedEvent.uex' path='docs/doc[@for="SelectedGridItemChangedEventArgs"]/*' />
    /// <devdoc>
    /// The event class that is created when the selected GridItem in the PropertyGrid is changed by the user.
    /// </devdoc>
    public class SelectedGridItemChangedEventArgs : EventArgs {
        private GridItem oldSelection;
        private GridItem newSelection;
        
        /// <include file='doc\SelectedGridItemChangedEvent.uex' path='docs/doc[@for="SelectedGridItemChangedEventArgs.SelectedGridItemChangedEventArgs"]/*' />
        /// <devdoc>
        /// Constructs a SelectedGridItemChangedEventArgs object.
        /// </devdoc>
        public SelectedGridItemChangedEventArgs(GridItem oldSel, GridItem newSel) {
            this.oldSelection = oldSel;
            this.newSelection = newSel;
        }
        
        
        
        /// <include file='doc\SelectedGridItemChangedEvent.uex' path='docs/doc[@for="SelectedGridItemChangedEventArgs.NewSelection"]/*' />
        /// <devdoc>
        /// The newly selected GridItem object
        /// </devdoc>
        public GridItem NewSelection {
            get {
                return this.newSelection;
            }
        }
        
        /// <include file='doc\SelectedGridItemChangedEvent.uex' path='docs/doc[@for="SelectedGridItemChangedEventArgs.OldSelection"]/*' />
        /// <devdoc>
        /// The previously selected GridItem object.  This can be null.
        /// </devdoc>
        public GridItem OldSelection {
            get {
                return this.oldSelection;
            }
        }    
        
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\selectionrangeconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="SelectionRangeConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;

    using Microsoft.Win32;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design.Serialization;
    using System.Drawing;
    using System.Diagnostics;
    using System.Globalization;
    using System.Reflection;

    /// <include file='doc\SelectionRangeConverter.uex' path='docs/doc[@for="SelectionRangeConverter"]/*' />
    /// <devdoc>
    ///      SelectionRangeConverter is a class that can be used to convert
    ///      SelectionRange objects from one data type to another.  Access this
    ///      class through the TypeDescriptor.
    /// </devdoc>
    public class SelectionRangeConverter : TypeConverter {
    
        /// <include file='doc\SelectionRangeConverter.uex' path='docs/doc[@for="SelectionRangeConverter.CanConvertFrom"]/*' />
        /// <devdoc>
        ///      Determines if this converter can convert an object in the given source
        ///      type to the native type of the converter.
        /// </devdoc>
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
            if (sourceType == typeof(string)) {
                return true;
            }
            return base.CanConvertFrom(context, sourceType);
        }

        /// <include file='doc\SelectionRangeConverter.uex' path='docs/doc[@for="SelectionRangeConverter.CanConvertTo"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether this converter can
        ///       convert an object to the given destination type using the context.</para>
        /// </devdoc>
        public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType) {
            if (destinationType == typeof(InstanceDescriptor)) {
                return true;
            }
            return base.CanConvertTo(context, destinationType);
        }
        
        /// <include file='doc\SelectionRangeConverter.uex' path='docs/doc[@for="SelectionRangeConverter.ConvertFrom"]/*' />
        /// <devdoc>
        ///      Converts the given object to the converter's native type.
        /// </devdoc>
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {
            if (value is string) {
                string text = ((string)value).Trim();
                if (text.Length == 0) {
                    return new SelectionRange(DateTime.Now.Date, DateTime.Now.Date);
                }
                
                // Separate the string into the two dates, and parse each one
                //
                if (culture == null) {
                    culture = CultureInfo.CurrentCulture;
                }                    
                char separator = culture.TextInfo.ListSeparator[0];
                string[] tokens = text.Split(new char[] {separator});
                
                if (tokens.Length == 2) {
                    TypeConverter dateTimeConverter = TypeDescriptor.GetConverter(typeof(DateTime));
                    DateTime start = (DateTime)dateTimeConverter.ConvertFromString(context, culture, tokens[0]);
                    DateTime end   = (DateTime)dateTimeConverter.ConvertFromString(context, culture, tokens[1]);
                    return new SelectionRange(start, end);
                }
                else {
                    throw new ArgumentException(SR.GetString(SR.TextParseFailedFormat,
                                                              text,
                                                              "Start" + separator + " End"));
                }
            }
            
            return base.ConvertFrom(context, culture, value);
        }

        
        /// <include file='doc\SelectionRangeConverter.uex' path='docs/doc[@for="SelectionRangeConverter.ConvertTo"]/*' />
        /// <devdoc>
        ///      Converts the given object to another type.  The most common types to convert
        ///      are to and from a string object.  The default implementation will make a call
        ///      to ToString on the object if the object is valid and if the destination
        ///      type is string.  If this cannot convert to the desitnation type, this will
        ///      throw a NotSupportedException.
        /// </devdoc>
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == null) {
                throw new ArgumentNullException("destinationType");
            }

            if (destinationType == typeof(string) && value is SelectionRange) {
                if (culture == null) {
                    culture = CultureInfo.CurrentCulture; 
                }
                string sep = culture.TextInfo.ListSeparator + " ";
                PropertyDescriptorCollection props = GetProperties(value);
                string[] args = new string[props.Count];
                
                for (int i = 0; i < props.Count; i++) {
                    object propValue = props[i].GetValue(value);
                    args[i] = TypeDescriptor.GetConverter(propValue).ConvertToString(context, culture, propValue);
                }
                
                return string.Join(sep, args);
            }
            if (destinationType == typeof(InstanceDescriptor) && value is SelectionRange) {
                SelectionRange r = (SelectionRange)value;
                ConstructorInfo ctor = typeof(SelectionRange).GetConstructor(new Type[] {
                    typeof(DateTime), typeof(DateTime)});
                if (ctor != null) {
                    return new InstanceDescriptor(ctor, new object[] {r.Start, r.End});
                }
            }
            
            return base.ConvertTo(context, culture, value, destinationType);
        }
        
        /// <include file='doc\SelectionRangeConverter.uex' path='docs/doc[@for="SelectionRangeConverter.CreateInstance"]/*' />
        /// <devdoc>
        ///      Creates an instance of this type given a set of property values
        ///      for the object.  This is useful for objects that are immutable, but still
        ///      want to provide changable properties.
        /// </devdoc>
        public override object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues) {
            return new SelectionRange((DateTime)propertyValues["Start"],
                                      (DateTime)propertyValues["End"]);
        }

        /// <include file='doc\SelectionRangeConverter.uex' path='docs/doc[@for="SelectionRangeConverter.GetCreateInstanceSupported"]/*' />
        /// <devdoc>
        ///      Determines if changing a value on this object should require a call to
        ///      CreateInstance to create a new value.
        /// </devdoc>
        public override bool GetCreateInstanceSupported(ITypeDescriptorContext context) {
            return true;
        }

        /// <include file='doc\SelectionRangeConverter.uex' path='docs/doc[@for="SelectionRangeConverter.GetProperties"]/*' />
        /// <devdoc>
        ///      Retrieves the set of properties for this type.  By default, a type has
        ///      does not return any properties.  An easy implementation of this method
        ///      can just call TypeDescriptor.GetProperties for the correct data type.
        /// </devdoc>
        public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes) {
            PropertyDescriptorCollection props = TypeDescriptor.GetProperties(typeof(SelectionRange), attributes);
            return props.Sort(new string[] {"Start", "End"});
        }
       
        /// <include file='doc\SelectionRangeConverter.uex' path='docs/doc[@for="SelectionRangeConverter.GetPropertiesSupported"]/*' />
        /// <devdoc>
        ///      Determines if this object supports properties.  By default, this
        ///      is false.
        /// </devdoc>
        public override bool GetPropertiesSupported(ITypeDescriptorContext context) {
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\selectionrange.cs ===
//------------------------------------------------------------------------------
// <copyright file="SelectionRange.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {
    using System.Runtime.Serialization.Formatters;

    using System.Diagnostics;

    using System;
    using System.Globalization;
    using System.Drawing;
    using System.Windows.Forms;
    using System.ComponentModel;
    using System.IO;
    using Microsoft.Win32;

    /// <include file='doc\SelectionRange.uex' path='docs/doc[@for="SelectionRange"]/*' />
    /// <devdoc>
    ///     This is a class that represents the date selection range of a MonthCalendar control.
    /// </devdoc>
    [
    TypeConverterAttribute(typeof(SelectionRangeConverter))
    ]
    public sealed class SelectionRange {
        /// <include file='doc\SelectionRange.uex' path='docs/doc[@for="SelectionRange.start"]/*' />
        /// <devdoc>
        ///     The lower limit of the selection range.
        /// </devdoc>
        private DateTime start = DateTime.MinValue.Date;

        /// <include file='doc\SelectionRange.uex' path='docs/doc[@for="SelectionRange.end"]/*' />
        /// <devdoc>
        ///     The upper limit of the selection range.
        /// </devdoc>
        private DateTime end = DateTime.MaxValue.Date;

        /// <include file='doc\SelectionRange.uex' path='docs/doc[@for="SelectionRange.SelectionRange"]/*' />
        /// <devdoc>
        ///     Create a new SelectionRange object with the range [null, null].
        /// </devdoc>
        public SelectionRange() {
        }

        /// <include file='doc\SelectionRange.uex' path='docs/doc[@for="SelectionRange.SelectionRange1"]/*' />
        /// <devdoc>
        ///     Create a new SelectionRange object with the given range.
        /// </devdoc>
        public SelectionRange(DateTime lower, DateTime upper) {
            //NOTE: simcooke: we explicitly DO NOT want to throw an exception here - just silently
            //                swap them around. This is because the win32 control can return non-
            //                normalized ranges.
            
            // We use lower.Date and upper.Date to remove any time component
            //
            if (lower < upper) {
                start = lower.Date;
                end = upper.Date;
            }
            else {
                start = upper.Date;
                end = lower.Date;
            }                        
        }

        /// <include file='doc\SelectionRange.uex' path='docs/doc[@for="SelectionRange.SelectionRange2"]/*' />
        /// <devdoc>
        ///     Create a new SelectionRange object given an existing SelectionRange object.
        /// </devdoc>
        public SelectionRange(SelectionRange range) {
            this.start = range.start;
            this.end = range.end;
        }

        /// <include file='doc\SelectionRange.uex' path='docs/doc[@for="SelectionRange.End"]/*' />
        /// <devdoc>
        ///     Returns the ending time of this range.
        /// </devdoc>
        public DateTime End {
            get { 
                return end;
            }
            set { 
                end = value.Date;
            }
        }

        /// <include file='doc\SelectionRange.uex' path='docs/doc[@for="SelectionRange.Start"]/*' />
        /// <devdoc>
        ///     Starting time of this range
        /// </devdoc>
        public DateTime Start {
            get {
                return start;
            }
            set { 
                start = value.Date;
            }
        }

        /// <include file='doc\SelectionRange.uex' path='docs/doc[@for="SelectionRange.ToString"]/*' />
        /// <devdoc>
        ///     Returns a string representation for this control.
        /// </devdoc>
        /// <internalonly/>
        public override string ToString() {
            return "SelectionRange: Start: " + start.ToString() + ", End: " + end.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\sortorder.cs ===
//------------------------------------------------------------------------------
// <copyright file="SortOrder.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {

    using System.Diagnostics;
    using System;
    using System.ComponentModel;
    using System.Drawing;
    using Microsoft.Win32;



    /// <include file='doc\SortOrder.uex' path='docs/doc[@for="SortOrder"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies how items in
    ///       a list are sorted.
    ///    </para>
    /// </devdoc>
    public enum SortOrder {

        /// <include file='doc\SortOrder.uex' path='docs/doc[@for="SortOrder.None"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The items are
        ///       not sorted.
        ///    </para>
        /// </devdoc>
        None = 0,

        /// <include file='doc\SortOrder.uex' path='docs/doc[@for="SortOrder.Ascending"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The items
        ///       are sorted in ascending order.
        ///    </para>
        /// </devdoc>
        Ascending = 1,

        /// <include file='doc\SortOrder.uex' path='docs/doc[@for="SortOrder.Descending"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The items are
        ///       sorted in descending order.
        ///    </para>
        /// </devdoc>
        Descending = 2,

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\sizegripstyle.cs ===
//------------------------------------------------------------------------------
// <copyright file="SizeGripStyle.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;
    using System;

    /// <include file='doc\SizeGripStyle.uex' path='docs/doc[@for="SizeGripStyle"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the style of the sizing grip on a <see cref='System.Windows.Forms.Form'/>.
    ///    </para>
    /// </devdoc>
    public enum SizeGripStyle {
        /// <include file='doc\SizeGripStyle.uex' path='docs/doc[@for="SizeGripStyle.Auto"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The size grip is automatically display when needed.
        ///    </para>
        /// </devdoc>
        Auto = 0,
        /// <include file='doc\SizeGripStyle.uex' path='docs/doc[@for="SizeGripStyle.Show"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The sizing grip is always shown on the form.
        ///    </para>
        /// </devdoc>
        Show = 1,
        /// <include file='doc\SizeGripStyle.uex' path='docs/doc[@for="SizeGripStyle.Hide"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The sizing grip is hidden.
        ///    </para>
        /// </devdoc>
        Hide = 2,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\shortcut.cs ===
//------------------------------------------------------------------------------
// <copyright file="Shortcut.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {
    using System.ComponentModel;
    using System.Diagnostics;
    using System;    
    using System.Drawing;
    using Microsoft.Win32;

    /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies shortcut keys that can be used by menu items.
    ///    </para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    public enum Shortcut {

        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.None"]/*' />
        /// <devdoc>
        ///    <para>
        ///       No shortcut key is associated with the menu item.
        ///    </para>
        /// </devdoc>
        None = 0,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlA"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shorcut keys CTRL+A.
        ///    </para>
        /// </devdoc>
        CtrlA = Keys.Control + Keys.A,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlB"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shorcut keys CTRL+B.
        ///    </para>
        /// </devdoc>
        CtrlB = Keys.Control + Keys.B,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlC"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shorcut keys CTRL+C.
        ///    </para>
        /// </devdoc>
        CtrlC = Keys.Control + Keys.C,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlD"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shorcut keys CTRL+D.
        ///    </para>
        /// </devdoc>
        CtrlD = Keys.Control + Keys.D,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlE"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shorcut keys CTRL+E.
        ///    </para>
        /// </devdoc>
        CtrlE = Keys.Control + Keys.E,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlF"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shorcut keys CTRL+F.
        ///    </para>
        /// </devdoc>
        CtrlF = Keys.Control + Keys.F,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlG"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shorcut keys CTRL+G.
        ///    </para>
        /// </devdoc>
        CtrlG = Keys.Control + Keys.G,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlH"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shorcut keys CTRL+H.
        ///    </para>
        /// </devdoc>
        CtrlH = Keys.Control + Keys.H,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlI"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shorcut keys CTRL+I.
        ///    </para>
        /// </devdoc>
        CtrlI = Keys.Control + Keys.I,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlJ"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shorcut keys CTRL+J.
        ///    </para>
        /// </devdoc>
        CtrlJ = Keys.Control + Keys.J,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlK"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shorcut keys CTRL+K.
        ///    </para>
        /// </devdoc>
        CtrlK = Keys.Control + Keys.K,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlL"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shorcut keys CTRL+L.
        ///    </para>
        /// </devdoc>
        CtrlL = Keys.Control + Keys.L,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlM"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shorcut keys CTRL+M.
        ///    </para>
        /// </devdoc>
        CtrlM = Keys.Control + Keys.M,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlN"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shorcut keys CTRL+N.
        ///    </para>
        /// </devdoc>
        CtrlN = Keys.Control + Keys.N,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlO"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shorcut keys CTRL+O.
        ///    </para>
        /// </devdoc>
        CtrlO = Keys.Control + Keys.O,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlP"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shorcut keys CTRL+P.
        ///    </para>
        /// </devdoc>
        CtrlP = Keys.Control + Keys.P,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlQ"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shorcut keys CTRL+Q.
        ///    </para>
        /// </devdoc>
        CtrlQ = Keys.Control + Keys.Q,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlR"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shorcut keys CTRL+R.
        ///    </para>
        /// </devdoc>
        CtrlR = Keys.Control + Keys.R,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlS"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shorcut keys CTRL+S.
        ///    </para>
        /// </devdoc>
        CtrlS = Keys.Control + Keys.S,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlT"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shorcut keys CTRL+T.
        ///    </para>
        /// </devdoc>
        CtrlT = Keys.Control + Keys.T,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlU"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shorcut keys CTRL+U
        ///    </para>
        /// </devdoc>
        CtrlU = Keys.Control + Keys.U,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlV"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shorcut keys CTRL+V.
        ///    </para>
        /// </devdoc>
        CtrlV = Keys.Control + Keys.V,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlW"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shorcut keys CTRL+W.
        ///    </para>
        /// </devdoc>
        CtrlW = Keys.Control + Keys.W,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlX"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shorcut keys CTRL+X.                
        ///    </para>
        /// </devdoc>
        CtrlX = Keys.Control + Keys.X,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlY"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shorcut keys CTRL+Y.
        ///    </para>
        /// </devdoc>
        CtrlY = Keys.Control + Keys.Y,                     
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlZ"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shorcut keys CTRL+Z.
        ///    </para>
        /// </devdoc>
        CtrlZ = Keys.Control + Keys.Z,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlShiftA"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+SHIFT+A.
        ///    </para>
        /// </devdoc>
        CtrlShiftA = Keys.Control + Keys.Shift + Keys.A,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlShiftB"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+SHIFT+B.
        ///    </para>
        /// </devdoc>
        CtrlShiftB = Keys.Control + Keys.Shift + Keys.B,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlShiftC"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+SHIFT+C.
        ///    </para>
        /// </devdoc>
        CtrlShiftC = Keys.Control + Keys.Shift + Keys.C,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlShiftD"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+SHIFT+D.
        ///    </para>
        /// </devdoc>
        CtrlShiftD = Keys.Control + Keys.Shift + Keys.D,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlShiftE"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+SHIFT+E.
        ///    </para>
        /// </devdoc>
        CtrlShiftE = Keys.Control + Keys.Shift + Keys.E,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlShiftF"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+SHIFT+F.
        ///    </para>
        /// </devdoc>
        CtrlShiftF = Keys.Control + Keys.Shift + Keys.F,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlShiftG"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+SHIFT+G.
        ///    </para>
        /// </devdoc>
        CtrlShiftG = Keys.Control + Keys.Shift + Keys.G,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlShiftH"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+SHIFT+H.
        ///    </para>
        /// </devdoc>
        CtrlShiftH = Keys.Control + Keys.Shift + Keys.H,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlShiftI"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+SHIFT+I.
        ///    </para>
        /// </devdoc>
        CtrlShiftI = Keys.Control + Keys.Shift + Keys.I,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlShiftJ"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+SHIFT+J.
        ///    </para>
        /// </devdoc>
        CtrlShiftJ = Keys.Control + Keys.Shift + Keys.J,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlShiftK"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+SHIFT+K.
        ///    </para>
        /// </devdoc>
        CtrlShiftK = Keys.Control + Keys.Shift + Keys.K,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlShiftL"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+SHIFT+L.
        ///    </para>
        /// </devdoc>
        CtrlShiftL = Keys.Control + Keys.Shift + Keys.L,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlShiftM"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+SHIFT+M.
        ///    </para>
        /// </devdoc>
        CtrlShiftM = Keys.Control + Keys.Shift + Keys.M,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlShiftN"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+SHIFT+N.
        ///    </para>
        /// </devdoc>
        CtrlShiftN = Keys.Control + Keys.Shift + Keys.N,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlShiftO"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+SHIFT+O.
        ///    </para>
        /// </devdoc>
        CtrlShiftO = Keys.Control + Keys.Shift + Keys.O,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlShiftP"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+SHIFT+P.
        ///    </para>
        /// </devdoc>
        CtrlShiftP = Keys.Control + Keys.Shift + Keys.P,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlShiftQ"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+SHIFT+Q.
        ///    </para>
        /// </devdoc>
        CtrlShiftQ = Keys.Control + Keys.Shift + Keys.Q,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlShiftR"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+SHIFT+R.
        ///    </para>
        /// </devdoc>
        CtrlShiftR = Keys.Control + Keys.Shift + Keys.R,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlShiftS"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+SHIFT+S.
        ///    </para>
        /// </devdoc>
        CtrlShiftS = Keys.Control + Keys.Shift + Keys.S,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlShiftT"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+SHIFT+T.
        ///    </para>
        /// </devdoc>
        CtrlShiftT = Keys.Control + Keys.Shift + Keys.T,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlShiftU"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+SHIFT+U.
        ///    </para>
        /// </devdoc>
        CtrlShiftU = Keys.Control + Keys.Shift + Keys.U,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlShiftV"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+SHIFT+V.
        ///    </para>
        /// </devdoc>
        CtrlShiftV = Keys.Control + Keys.Shift + Keys.V,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlShiftW"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+SHIFT+W.
        ///    </para>
        /// </devdoc>
        CtrlShiftW = Keys.Control + Keys.Shift + Keys.W,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlShiftX"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+SHIFT+X.
        ///    </para>
        /// </devdoc>
        CtrlShiftX = Keys.Control + Keys.Shift + Keys.X,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlShiftY"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+SHIFT+Y.
        ///    </para>
        /// </devdoc>
        CtrlShiftY = Keys.Control + Keys.Shift + Keys.Y,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlShiftZ"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+SHIFT+Z.
        ///    </para>
        /// </devdoc>
        CtrlShiftZ = Keys.Control + Keys.Shift + Keys.Z,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.F1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut key F1.
        ///    </para>
        /// </devdoc>
        F1 = Keys.F1,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.F2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut key F2.
        ///    </para>
        /// </devdoc>
        F2 = Keys.F2,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.F3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut key F3.
        ///    </para>
        /// </devdoc>
        F3 = Keys.F3,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.F4"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut key F4.
        ///    </para>
        /// </devdoc>
        F4 = Keys.F4,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.F5"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut key F5.
        ///    </para>
        /// </devdoc>
        F5 = Keys.F5,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.F6"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut key F6.
        ///    </para>
        /// </devdoc>
        F6 = Keys.F6,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.F7"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut key F7.
        ///    </para>
        /// </devdoc>
        F7 = Keys.F7,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.F8"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        F8 = Keys.F8,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.F9"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut key F9.
        ///    </para>
        /// </devdoc>
        F9 = Keys.F9,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.F10"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut key F10.
        ///    </para>
        /// </devdoc>
        F10 = Keys.F10,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.F11"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut key F11.
        ///    </para>
        /// </devdoc>
        F11 = Keys.F11,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.F12"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut key F12.
        ///    </para>
        /// </devdoc>
        F12 = Keys.F12,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.ShiftF1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys SHIFT+F1.
        ///    </para>
        /// </devdoc>
        ShiftF1 = Keys.Shift + Keys.F1,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.ShiftF2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys SHIFT+F2.
        ///    </para>
        /// </devdoc>
        ShiftF2 = Keys.Shift + Keys.F2,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.ShiftF3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys SHIFT+F3.
        ///    </para>
        /// </devdoc>
        ShiftF3 = Keys.Shift + Keys.F3,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.ShiftF4"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys SHIFT+F4.
        ///    </para>
        /// </devdoc>
        ShiftF4 = Keys.Shift + Keys.F4,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.ShiftF5"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys SHIFT+F5.
        ///    </para>
        /// </devdoc>
        ShiftF5 = Keys.Shift + Keys.F5,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.ShiftF6"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys SHIFT+F6.
        ///    </para>
        /// </devdoc>
        ShiftF6 = Keys.Shift + Keys.F6,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.ShiftF7"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys SHIFT+F7.
        ///    </para>
        /// </devdoc>
        ShiftF7 = Keys.Shift + Keys.F7,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.ShiftF8"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys SHIFT+F8.
        ///    </para>
        /// </devdoc>
        ShiftF8 = Keys.Shift + Keys.F8,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.ShiftF9"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys SHIFT+F9.
        ///    </para>
        /// </devdoc>
        ShiftF9 = Keys.Shift + Keys.F9,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.ShiftF10"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys SHIFT+F10.
        ///    </para>
        /// </devdoc>
        ShiftF10 = Keys.Shift + Keys.F10,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.ShiftF11"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys SHIFT+F11.
        ///    </para>
        /// </devdoc>
        ShiftF11 = Keys.Shift + Keys.F11,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.ShiftF12"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys SHIFT+F12.
        ///    </para>
        /// </devdoc>
        ShiftF12 = Keys.Shift + Keys.F12,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlF1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+F1.
        ///    </para>
        /// </devdoc>
        CtrlF1 = Keys.Control + Keys.F1,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlF2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+F2.
        ///    </para>
        /// </devdoc>
        CtrlF2 = Keys.Control + Keys.F2,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlF3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+F3.
        ///    </para>
        /// </devdoc>
        CtrlF3 = Keys.Control + Keys.F3,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlF4"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+F4.
        ///    </para>
        /// </devdoc>
        CtrlF4 = Keys.Control + Keys.F4,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlF5"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+F5.
        ///    </para>
        /// </devdoc>
        CtrlF5 = Keys.Control + Keys.F5,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlF6"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+F6.
        ///    </para>
        /// </devdoc>
        CtrlF6 = Keys.Control + Keys.F6,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlF7"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+F7.
        ///    </para>
        /// </devdoc>
        CtrlF7 = Keys.Control + Keys.F7,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlF8"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+F8.
        ///    </para>
        /// </devdoc>
        CtrlF8 = Keys.Control + Keys.F8,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlF9"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+F9.
        ///    </para>
        /// </devdoc>
        CtrlF9 = Keys.Control + Keys.F9,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlF10"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+F10.
        ///    </para>
        /// </devdoc>
        CtrlF10 = Keys.Control + Keys.F10,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlF11"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+F11.
        ///    </para>
        /// </devdoc>
        CtrlF11 = Keys.Control + Keys.F11,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlF12"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+F12.
        ///    </para>
        /// </devdoc>
        CtrlF12 = Keys.Control + Keys.F12,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlShiftF1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+SHIFT+F1.
        ///    </para>
        /// </devdoc>
        CtrlShiftF1 = Keys.Control + Keys.Shift + Keys.F1,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlShiftF2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+SHIFT+F2.
        ///    </para>
        /// </devdoc>
        CtrlShiftF2 = Keys.Control + Keys.Shift + Keys.F2,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlShiftF3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+SHIFT+F3.
        ///    </para>
        /// </devdoc>
        CtrlShiftF3 = Keys.Control + Keys.Shift + Keys.F3,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlShiftF4"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+SHIFT+F4.
        ///    </para>
        /// </devdoc>
        CtrlShiftF4 = Keys.Control + Keys.Shift + Keys.F4,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlShiftF5"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+SHIFT+F5.
        ///    </para>
        /// </devdoc>
        CtrlShiftF5 = Keys.Control + Keys.Shift + Keys.F5,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlShiftF6"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+SHIFT+F6.
        ///    </para>
        /// </devdoc>
        CtrlShiftF6 = Keys.Control + Keys.Shift + Keys.F6,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlShiftF7"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+SHIFT+F7.
        ///    </para>
        /// </devdoc>
        CtrlShiftF7 = Keys.Control + Keys.Shift + Keys.F7,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlShiftF8"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+SHIFT+F8.
        ///    </para>
        /// </devdoc>
        CtrlShiftF8 = Keys.Control + Keys.Shift + Keys.F8,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlShiftF9"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+SHIFT+F9.
        ///    </para>
        /// </devdoc>
        CtrlShiftF9 = Keys.Control + Keys.Shift + Keys.F9,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlShiftF10"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+SHIFT+F10.
        ///    </para>
        /// </devdoc>
        CtrlShiftF10 = Keys.Control + Keys.Shift + Keys.F10,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlShiftF11"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+SHIFT+F11.
        ///    </para>
        /// </devdoc>
        CtrlShiftF11 = Keys.Control + Keys.Shift + Keys.F11,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlShiftF12"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+SHIFT+F12.
        ///    </para>
        /// </devdoc>
        CtrlShiftF12 = Keys.Control + Keys.Shift + Keys.F12,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.Ins"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut key INSERT.
        ///    </para>
        /// </devdoc>
        Ins = Keys.Insert,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlIns"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+INSERT.
        ///    </para>
        /// </devdoc>
        CtrlIns = Keys.Control + Keys.Insert,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.ShiftIns"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys SHIFT+INSERT.
        ///    </para>
        /// </devdoc>
        ShiftIns = Keys.Shift + Keys.Insert,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.Del"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut key DELETE.
        ///    </para>
        /// </devdoc>
        Del = Keys.Delete,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlDel"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+DELETE.
        ///    </para>
        /// </devdoc>
        CtrlDel = Keys.Control + Keys.Delete,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.ShiftDel"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys SHIFT+DELETE.
        ///    </para>
        /// </devdoc>
        ShiftDel = Keys.Shift + Keys.Delete,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.AltBksp"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys ALT+BACKSPACE.
        ///    </para>
        /// </devdoc>
        AltBksp = Keys.Alt + Keys.Back,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.AltF1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys ALT+F1.
        ///    </para>
        /// </devdoc>
        AltF1 = Keys.Alt + Keys.F1,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.AltF2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys ALT+F2.
        ///    </para>
        /// </devdoc>
        AltF2 = Keys.Alt + Keys.F2,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.AltF3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys ALT+F3.
        ///    </para>
        /// </devdoc>
        AltF3 = Keys.Alt + Keys.F3,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.AltF4"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys ALT+F4.
        ///    </para>
        /// </devdoc>
        AltF4 = Keys.Alt + Keys.F4,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.AltF5"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys ALT+F5.
        ///    </para>
        /// </devdoc>
        AltF5 = Keys.Alt + Keys.F5,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.AltF6"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys ALT+F6.
        ///    </para>
        /// </devdoc>
        AltF6 = Keys.Alt + Keys.F6,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.AltF7"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys ALT+F7.
        ///    </para>
        /// </devdoc>
        AltF7 = Keys.Alt + Keys.F7,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.AltF8"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys ALT+F8.
        ///    </para>
        /// </devdoc>
        AltF8 = Keys.Alt + Keys.F8,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.AltF9"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys ALT+F9.
        ///    </para>
        /// </devdoc>
        AltF9 = Keys.Alt + Keys.F9,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.AltF10"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys ALT+F10.
        ///    </para>
        /// </devdoc>
        AltF10 = Keys.Alt + Keys.F10,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.AltF11"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys ALT+F11.
        ///    </para>
        /// </devdoc>
        AltF11 = Keys.Alt + Keys.F11,
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.AltF12"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys ALT+F12.
        ///    </para>
        /// </devdoc>
        AltF12 = Keys.Alt + Keys.F12,
        
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.Alt0"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys ALT+0.
        ///    </para>
        /// </devdoc>
        Alt0 = Keys.Alt + Keys.D0,
        
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.Alt1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys ALT+1.
        ///    </para>
        /// </devdoc>
        Alt1 = Keys.Alt + Keys.D1,
        
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.Alt2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys ALT+2.
        ///    </para>
        /// </devdoc>
        Alt2 = Keys.Alt + Keys.D2,
        
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.Alt3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys ALT+3.
        ///    </para>
        /// </devdoc>
        Alt3 = Keys.Alt + Keys.D3,
        
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.Alt4"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys ALT+4.
        ///    </para>
        /// </devdoc>
        Alt4 = Keys.Alt + Keys.D4,
        
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.Alt5"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys ALT+5.
        ///    </para>
        /// </devdoc>
        Alt5 = Keys.Alt + Keys.D5,
        
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.Alt6"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys ALT+6.
        ///    </para>
        /// </devdoc>
        Alt6 = Keys.Alt + Keys.D6,
        
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.Alt7"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys ALT+7.
        ///    </para>
        /// </devdoc>
        Alt7 = Keys.Alt + Keys.D7,
        
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.Alt8"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys ALT+8.
        ///    </para>
        /// </devdoc>
        Alt8 = Keys.Alt + Keys.D8,
        
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.Alt9"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys ALT+9.
        ///    </para>
        /// </devdoc>
        Alt9 = Keys.Alt + Keys.D9,
        
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.Ctrl0"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+0.
        ///    </para>
        /// </devdoc>
        Ctrl0 = Keys.Control + Keys.D0,
        
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.Ctrl1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+1.
        ///    </para>
        /// </devdoc>
        Ctrl1 = Keys.Control + Keys.D1,
        
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.Ctrl2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+2.
        ///    </para>
        /// </devdoc>
        Ctrl2 = Keys.Control + Keys.D2,
        
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.Ctrl3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+3.
        ///    </para>
        /// </devdoc>
        Ctrl3 = Keys.Control + Keys.D3,
        
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.Ctrl4"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+4.
        ///    </para>
        /// </devdoc>
        Ctrl4 = Keys.Control + Keys.D4,
        
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.Ctrl5"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+5.
        ///    </para>
        /// </devdoc>
        Ctrl5 = Keys.Control + Keys.D5,
        
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.Ctrl6"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+6.
        ///    </para>
        /// </devdoc>
        Ctrl6 = Keys.Control + Keys.D6,
        
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.Ctrl7"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+7.
        ///    </para>
        /// </devdoc>
        Ctrl7 = Keys.Control + Keys.D7,
        
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.Ctrl8"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+8.
        ///    </para>
        /// </devdoc>
        Ctrl8 = Keys.Control + Keys.D8,
        
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.Ctrl9"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+9.
        ///    </para>
        /// </devdoc>
        Ctrl9 = Keys.Control + Keys.D9,
        
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlShift0"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+SHIFT+0.
        ///    </para>
        /// </devdoc>
        CtrlShift0 = Keys.Control + Keys.Shift + Keys.D0,
        
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlShift1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+SHIFT+1.
        ///    </para>
        /// </devdoc>
        CtrlShift1 = Keys.Control + Keys.Shift + Keys.D1,
        
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlShift2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+SHIFT+2.
        ///    </para>
        /// </devdoc>
        CtrlShift2 = Keys.Control + Keys.Shift + Keys.D2,
        
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlShift3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+SHIFT+3.
        ///    </para>
        /// </devdoc>
        CtrlShift3 = Keys.Control + Keys.Shift + Keys.D3,
        
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlShift4"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+SHIFT+4.
        ///    </para>
        /// </devdoc>
        CtrlShift4 = Keys.Control + Keys.Shift + Keys.D4,
        
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlShift5"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+SHIFT+5.
        ///    </para>
        /// </devdoc>
        CtrlShift5 = Keys.Control + Keys.Shift + Keys.D5,
        
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlShift6"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+SHIFT+6.
        ///    </para>
        /// </devdoc>
        CtrlShift6 = Keys.Control + Keys.Shift + Keys.D6,
        
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlShift7"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+SHIFT+7.
        ///    </para>
        /// </devdoc>
        CtrlShift7 = Keys.Control + Keys.Shift + Keys.D7,
        
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlShift8"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+SHIFT+8.
        ///    </para>
        /// </devdoc>
        CtrlShift8 = Keys.Control + Keys.Shift + Keys.D8,
        
        /// <include file='doc\Shortcut.uex' path='docs/doc[@for="Shortcut.CtrlShift9"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The shortcut keys CTRL+SHIFT+9.
        ///    </para>
        /// </devdoc>
        CtrlShift9 = Keys.Control + Keys.Shift + Keys.D9,
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\splittereventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="SplitterEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;


    /// <include file='doc\SplitterEventHandler.uex' path='docs/doc[@for="SplitterEventHandler"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a method that will handle splitter events.
    ///    </para>
    /// </devdoc>
    public delegate void SplitterEventHandler(object sender, SplitterEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\sendkeys.cs ===
//------------------------------------------------------------------------------
// <copyright file="SendKeys.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {
    using System.Runtime.InteropServices;
    using System.Security;

    using System.Diagnostics;

    using System;
    
    using System.Drawing;
    using System.Collections;
    using System.ComponentModel;
    using System.Globalization;
    
    /// <include file='doc\SendKeys.uex' path='docs/doc[@for="SendKeys"]/*' />
    /// <devdoc>
    ///    <para>Provides methods for sending keystrokes to an application.</para>
    /// </devdoc>
    public class SendKeys {
        private const int  HAVESHIFT = 0;
        private const int  HAVECTRL  = 1;
        private const int  HAVEALT   = 2;
        
        // I'm unsure what significance the value 10 has, but it seems to make sense
        // to make this a constant rather than have 10 sprinkled throughout the code.
        // It appears to be a sentinel value of some sort - indicating an unknown
        // grouping level.
        //                                                 
        private const int  UNKNOWN_GROUPING = 10;

        private static KeywordVk [] keywords = new KeywordVk[] {
            new KeywordVk("ENTER",      (int)Keys.Return),
            new KeywordVk("TAB",        (int)Keys.Tab),
            new KeywordVk("ESC",        (int)Keys.Escape),
            new KeywordVk("ESCAPE",     (int)Keys.Escape),
            new KeywordVk("HOME",       (int)Keys.Home),
            new KeywordVk("END",        (int)Keys.End),
            new KeywordVk("LEFT",       (int)Keys.Left),
            new KeywordVk("RIGHT",      (int)Keys.Right),
            new KeywordVk("UP",         (int)Keys.Up),
            new KeywordVk("DOWN",       (int)Keys.Down),
            new KeywordVk("PGUP",       (int)Keys.Prior),
            new KeywordVk("PGDN",       (int)Keys.Next),
            new KeywordVk("NUMLOCK",    (int)Keys.NumLock),
            new KeywordVk("SCROLLLOCK", (int)Keys.Scroll),
            new KeywordVk("PRTSC",      (int)Keys.PrintScreen),
            new KeywordVk("BREAK",      (int)Keys.Cancel),
            new KeywordVk("BACKSPACE",  (int)Keys.Back),
            new KeywordVk("BKSP",       (int)Keys.Back),
            new KeywordVk("BS",         (int)Keys.Back),
            new KeywordVk("CLEAR",      (int)Keys.Clear),
            new KeywordVk("CAPSLOCK",   (int)Keys.Capital),
            new KeywordVk("INS",        (int)Keys.Insert),
            new KeywordVk("INSERT",     (int)Keys.Insert),
            new KeywordVk("DEL",        (int)Keys.Delete),
            new KeywordVk("DELETE",     (int)Keys.Delete),
            new KeywordVk("HELP",       (int)Keys.Help),
            new KeywordVk("F1",         (int)Keys.F1),
            new KeywordVk("F2",         (int)Keys.F2),
            new KeywordVk("F3",         (int)Keys.F3),
            new KeywordVk("F4",         (int)Keys.F4),
            new KeywordVk("F5",         (int)Keys.F5),
            new KeywordVk("F6",         (int)Keys.F6),
            new KeywordVk("F7",         (int)Keys.F7),
            new KeywordVk("F8",         (int)Keys.F8),
            new KeywordVk("F9",         (int)Keys.F9),
            new KeywordVk("F10",        (int)Keys.F10),
            new KeywordVk("F11",        (int)Keys.F11),
            new KeywordVk("F12",        (int)Keys.F12),
            new KeywordVk("F13",        (int)Keys.F13),
            new KeywordVk("F14",        (int)Keys.F14),
            new KeywordVk("F15",        (int)Keys.F15),
            new KeywordVk("F16",        (int)Keys.F16),
            new KeywordVk("MULTIPLY",   (int)Keys.Multiply),
            new KeywordVk("ADD",        (int)Keys.Add),
            new KeywordVk("SUBTRACT",   (int)Keys.Subtract),
            new KeywordVk("DIVIDE",     (int)Keys.Divide),
            new KeywordVk("+",          (int)Keys.Add),
            new KeywordVk("%",          (int)(Keys.D5 | Keys.Shift)),
            new KeywordVk("^",          (int)(Keys.D6 | Keys.Shift)),
        };

        private const int  SHIFTKEYSCAN  = 0x0100;
        private const int  CTRLKEYSCAN   = 0x0200;
        private const int  ALTKEYSCAN    = 0x0400;

        /// <include file='doc\SendKeys.uex' path='docs/doc[@for="SendKeys.stopHook"]/*' />
        /// <devdoc>
        ///     should we stop using the hook?
        /// </devdoc>
        private static bool stopHook;

        /// <include file='doc\SendKeys.uex' path='docs/doc[@for="SendKeys.hhook"]/*' />
        /// <devdoc>
        ///     HHOOK
        /// </devdoc>
        private static IntPtr hhook;

        private static NativeMethods.HookProc hook;

        /// <include file='doc\SendKeys.uex' path='docs/doc[@for="SendKeys.events"]/*' />
        /// <devdoc>
        ///     vector of events that we have yet to post to the journaling hook.
        /// </devdoc>
        private static Queue events;

        private static bool fStartNewChar;
        
        private static SKWindow messageWindow;

        static SendKeys() {
            Application.ThreadExit += new EventHandler(OnThreadExit);
            messageWindow = new SKWindow();
            messageWindow.CreateControl();
        }
        
        /// <include file='doc\SendKeys.uex' path='docs/doc[@for="SendKeys.SendKeys"]/*' />
        /// <devdoc>
        ///     private constructor to prevent people from creating one of these.  they
        ///     should use public static methods
        /// </devdoc>
        private SendKeys() {
        }

        /// <include file='doc\SendKeys.uex' path='docs/doc[@for="SendKeys.AddEvent"]/*' />
        /// <devdoc>
        ///     adds an event to our list of events for the hook
        /// </devdoc>
        private static void AddEvent(SKEvent skevent) {

            if (events == null) {
                events = new Queue();
            }
            events.Enqueue(skevent);
        }

        // Helper function for ParseKeys for doing simple, self-describing characters.
        private static bool AddSimpleKey(char character, int repeat, IntPtr hwnd, int[] haveKeys, bool fStartNewChar, int cGrp) {
            int vk = UnsafeNativeMethods.VkKeyScan(character);

            if (vk != -1) {
                if (haveKeys[HAVESHIFT] == 0 && (vk & SHIFTKEYSCAN) != 0) {
                    AddEvent(new SKEvent(NativeMethods.WM_KEYDOWN, (int)Keys.ShiftKey, fStartNewChar, hwnd));
                    fStartNewChar = false;
                    haveKeys[HAVESHIFT] = UNKNOWN_GROUPING;
                }

                if (haveKeys[HAVECTRL] == 0 && (vk & CTRLKEYSCAN) != 0) {
                    AddEvent(new SKEvent(NativeMethods.WM_KEYDOWN, (int)Keys.ControlKey, fStartNewChar, hwnd));
                    fStartNewChar = false;
                    haveKeys[HAVECTRL] = UNKNOWN_GROUPING;
                }

                if (haveKeys[HAVEALT] == 0 && (vk & ALTKEYSCAN) != 0) {
                    AddEvent(new SKEvent(NativeMethods.WM_KEYDOWN, (int)Keys.Menu, fStartNewChar, hwnd));
                    fStartNewChar = false;
                    haveKeys[HAVEALT] = UNKNOWN_GROUPING;
                }
            
                AddMsgsForVK(vk & 0xff, repeat, haveKeys[HAVEALT] > 0 && haveKeys[HAVECTRL] == 0, hwnd);
                CancelMods(haveKeys, UNKNOWN_GROUPING, hwnd);
            }
            else {
                AddEvent(new SKEvent(NativeMethods.WM_CHAR, character, 0, hwnd));
            }

            if (cGrp != 0) fStartNewChar = true;
            return fStartNewChar;
        }

        /// <include file='doc\SendKeys.uex' path='docs/doc[@for="SendKeys.AddMsgsForVK"]/*' />
        /// <devdoc>
        ///     given the vk, add the appropriate messages for it
        /// </devdoc>
        private static void AddMsgsForVK(int vk, int repeat, bool altnoctrldown, IntPtr hwnd) {
            for (int i = 0; i < repeat; i++) {
                AddEvent(new SKEvent(altnoctrldown ? NativeMethods.WM_SYSKEYDOWN : NativeMethods.WM_KEYDOWN, vk, fStartNewChar, hwnd));
                fStartNewChar = false;
                AddEvent(new SKEvent(altnoctrldown ? NativeMethods.WM_SYSKEYUP : NativeMethods.WM_KEYUP, vk, fStartNewChar, hwnd));
            }
        }

        /// <include file='doc\SendKeys.uex' path='docs/doc[@for="SendKeys.CancelMods"]/*' />
        /// <devdoc>
        ///     called whenever there is a closing parenthesis, or the end of a
        ///     character.  This generates events for the end of a modifier.
        /// </devdoc>
        private static void CancelMods(int [] haveKeys, int level, IntPtr hwnd) {
            if (haveKeys[HAVESHIFT] == level) {
                AddEvent(new SKEvent(NativeMethods.WM_KEYUP, (int)Keys.ShiftKey, false, hwnd));
                haveKeys[HAVESHIFT] = 0;
            }
            if (haveKeys[HAVECTRL] == level) {
                AddEvent(new SKEvent(NativeMethods.WM_KEYUP, (int)Keys.ControlKey, false, hwnd));
                haveKeys[HAVECTRL] = 0;
            }
            if (haveKeys[HAVEALT] == level) {
                AddEvent(new SKEvent(NativeMethods.WM_SYSKEYUP, (int)Keys.Menu, false, hwnd));
                haveKeys[HAVEALT] = 0;
            }
        }

        /// <include file='doc\SendKeys.uex' path='docs/doc[@for="SendKeys.InstallHook"]/*' />
        /// <devdoc>
        ///     install the hook.  quite easy
        /// </devdoc>
        private static void InstallHook() {
            if (hhook == IntPtr.Zero) {
                hook = new NativeMethods.HookProc(new SendKeysHookProc().Callback);
                stopHook = false;
                hhook = UnsafeNativeMethods.SetWindowsHookEx(NativeMethods.WH_JOURNALPLAYBACK,
                                                 hook,
                                                 new HandleRef(null, UnsafeNativeMethods.GetModuleHandle(null)),
                                                 0);
                if (hhook == IntPtr.Zero)
                    throw new SecurityException(SR.GetString(SR.SendKeysHookFailed));
            }
        }

        /// <include file='doc\SendKeys.uex' path='docs/doc[@for="SendKeys.JournalCancel"]/*' />
        /// <devdoc>
        ///     tells us to shut down the server, perhaps if we're shutting down and the
        ///     hook is still running
        /// </devdoc>
        private static void JournalCancel() {
            if (hhook != IntPtr.Zero) {
                stopHook = false;
                if (events != null) {
                  events.Clear();
                }
                hhook = IntPtr.Zero;
            }
        }

        private static byte[] GetKeyboardState() {
            byte [] keystate = new byte[256];
            UnsafeNativeMethods.GetKeyboardState(keystate);
            return keystate;
        }

        private static void SetKeyboardState(byte[] keystate) {
            UnsafeNativeMethods.SetKeyboardState(keystate);
        }

        /// <include file='doc\SendKeys.uex' path='docs/doc[@for="SendKeys.ClearKeyboardState"]/*' />
        /// <devdoc>
        ///     before we do a sendkeys, we want to  clear the state
        ///     of a couple of keys [capslock, numlock, scrolllock] so they don't
        ///     interfere.
        /// </devdoc>
        private static void ClearKeyboardState() {

            byte [] keystate = GetKeyboardState();

            keystate[(int)Keys.Capital] = 0;
            keystate[(int)Keys.NumLock] = 0;
            keystate[(int)Keys.Scroll] = 0;

            SetKeyboardState(keystate);
        }

        /// <include file='doc\SendKeys.uex' path='docs/doc[@for="SendKeys.MatchKeyword"]/*' />
        /// <devdoc>
        ///     given the string, match the keyword to a VK.  return -1 if it don't match
        ///     nuthin'
        /// </devdoc>
        private static int MatchKeyword(string keyword) {
            for (int i = 0; i < keywords.Length; i++)
                if (String.Compare(keywords[i].keyword, keyword, true, CultureInfo.InvariantCulture) == 0)
                    return keywords[i].vk;

            return -1;
        }

        /// <include file='doc\SendKeys.uex' path='docs/doc[@for="SendKeys.OnThreadExit"]/*' />
        /// <devdoc>
        ///     This event is raised from Application when each window thread
        ///     termiantes.  It gives us a chance to uninstall our journal
        ///     hook if we had one installed.
        /// </devdoc>
        private static void OnThreadExit(object sender, EventArgs e) {
            try {
                UninstallJournalingHook();
            }
            catch (Exception) {
            }
        }
        
        /// <include file='doc\SendKeys.uex' path='docs/doc[@for="SendKeys.ParseKeys"]/*' />
        /// <devdoc>
        ///     parse the string the user has given us, and generate the appropriate
        ///     events for the journaling hook
        /// </devdoc>
        private static void ParseKeys(string keys, IntPtr hwnd) {

            int i = 0;

            // these four variables are used for grouping
            int [] haveKeys = new int[] { 0, 0, 0}; // shift, ctrl, alt
            int cGrp = 0;

            // fStartNewChar indicates that the next msg will be the first
            // of a char or char group.  This is needed for IntraApp Nesting
            // of SendKeys.
            //
            fStartNewChar = true;

            // okay, start whipping through the characters one at a time.
            //
            int keysLen = keys.Length;
            while (i < keysLen) {
                int repeat = 1;
                char ch = keys[i];
                int vk = 0;

                switch (ch) {
                    case '}':
                        // if these appear at this point they are out of
                        // context, so return an error.  KeyStart processes
                        // ochKeys up to the appropriate KeyEnd.
                        //
                        throw new ArgumentException(SR.GetString(SR.InvalidSendKeysString, keys));

                    case '{':
                        int j = i + 1;
                        
                        // There's a unique class of strings of the form "{} n}" where
                        // n is an integer - in this case we want to send n copies of the '}' character.
                        // Here we test for the possibility of this class of problems, and skip the
                        // first '}' in the string if necessary.
                        //
                        if (j + 1 < keysLen && keys[j] == '}') {
                            // Scan for the final '}' character
                            int final = j + 1;
                            while (final < keysLen && keys[final] != '}') {
                                final++;
                            }
                            if (final < keysLen) {
                                // Found the special case, so skip the first '}' in the string.
                                // The remainder of the code will attempt to find the repeat count.
                                j++;
                            }
                        }
                        
                        // okay, we're in a {<KEYWORD>...} situation.  look for the keyword
                        //
                        while (j < keysLen && keys[j] != '}'
                               && !Char.IsWhiteSpace(keys[j])) {
                            j++;
                        }
                        
                        if (j >= keysLen) {
                            throw new ArgumentException(SR.GetString(SR.SendKeysKeywordDelimError));
                        }
                        
                        // okay, have our KEYWORD.  verify it's one we know about
                        //
                        string keyName = keys.Substring(i + 1, j - (i + 1));

                        // see if we have a space, which would mean a repeat count.
                        //
                        if (Char.IsWhiteSpace(keys[j])) {
                            int digit;
                            while (j < keysLen && Char.IsWhiteSpace(keys[j])) {
                                j++;
                            }
                            
                            if (j >= keysLen) {
                                throw new ArgumentException(SR.GetString(SR.SendKeysKeywordDelimError));                            
                            }
                            
                            if (Char.IsDigit(keys[j])) {
                                digit = j;
                                while (j < keysLen && Char.IsDigit(keys[j])) {
                                    j++;
                                }
                                repeat = Int32.Parse(keys.Substring(digit, j - digit));
                            }
                        }
                        
                        if (j >= keysLen) {
                            throw new ArgumentException(SR.GetString(SR.SendKeysKeywordDelimError));                            
                        }
                        if (keys[j] != '}') {
                            throw new ArgumentException(SR.GetString(SR.InvalidSendKeysRepeat));
                        }

                        vk = MatchKeyword(keyName);
                        if (vk != -1) {
                            // Unlike AddSimpleKey, the bit mask uses Keys, rather than scan keys
                            if (haveKeys[HAVESHIFT] == 0 && (vk & (int)Keys.Shift) != 0) {
                                AddEvent(new SKEvent(NativeMethods.WM_KEYDOWN, (int)Keys.ShiftKey, fStartNewChar, hwnd));
                                fStartNewChar = false;
                                haveKeys[HAVESHIFT] = UNKNOWN_GROUPING;
                            }
                
                            if (haveKeys[HAVECTRL] == 0 && (vk & (int)Keys.Control) != 0) {
                                AddEvent(new SKEvent(NativeMethods.WM_KEYDOWN, (int)Keys.ControlKey, fStartNewChar, hwnd));
                                fStartNewChar = false;
                                haveKeys[HAVECTRL] = UNKNOWN_GROUPING;
                            }
                
                            if (haveKeys[HAVEALT] == 0 && (vk & (int)Keys.Alt) != 0) {
                                AddEvent(new SKEvent(NativeMethods.WM_KEYDOWN, (int)Keys.Menu, fStartNewChar, hwnd));
                                fStartNewChar = false;
                                haveKeys[HAVEALT] = UNKNOWN_GROUPING;
                            }
                            AddMsgsForVK(vk, repeat, haveKeys[HAVEALT] > 0 && haveKeys[HAVECTRL] == 0, hwnd);
                            CancelMods(haveKeys, UNKNOWN_GROUPING, hwnd);
                        }
                        else if (keyName.Length == 1) {
                            fStartNewChar = AddSimpleKey(keyName[0], repeat, hwnd, haveKeys, fStartNewChar, cGrp);
                        }
                        else {
                            throw new ArgumentException(SR.GetString(SR.InvalidSendKeysKeyword, keys.Substring(i + 1, j - (i + 1))));
                        }

                        // don't forget to position ourselves at the end of the {...} group
                        i = j;
                        break;

                    case '+':
                        if (haveKeys[HAVESHIFT] != 0) throw new ArgumentException(SR.GetString(SR.InvalidSendKeysString, keys));

                        AddEvent(new SKEvent(NativeMethods.WM_KEYDOWN, (int)Keys.ShiftKey, fStartNewChar, hwnd));
                        fStartNewChar = false;
                        haveKeys[HAVESHIFT] = UNKNOWN_GROUPING;
                        break;

                    case '^':
                        if (haveKeys[HAVECTRL]!= 0) throw new ArgumentException(SR.GetString(SR.InvalidSendKeysString, keys));

                        AddEvent(new SKEvent(NativeMethods.WM_KEYDOWN, (int)Keys.ControlKey, fStartNewChar, hwnd));
                        fStartNewChar = false;
                        haveKeys[HAVECTRL] = UNKNOWN_GROUPING;
                        break;

                    case '%':
                        if (haveKeys[HAVEALT] != 0) throw new ArgumentException(SR.GetString(SR.InvalidSendKeysString, keys));

                        AddEvent(new SKEvent((haveKeys[HAVECTRL] != 0) ? NativeMethods.WM_KEYDOWN : NativeMethods.WM_SYSKEYDOWN,
                                             (int)Keys.Menu, fStartNewChar, hwnd));
                        fStartNewChar = false;
                        haveKeys[HAVEALT] = UNKNOWN_GROUPING;
                        break;

                    case '(':
                        // convert all immediate mode states to group mode
                        // Allows multiple keys with the same shift, etc. state.
                        // Nests three deep.
                        //
                        cGrp++;
                        if (cGrp > 3) throw new ArgumentException(SR.GetString(SR.SendKeysNestingError));

                        if (haveKeys[HAVESHIFT] == UNKNOWN_GROUPING) haveKeys[HAVESHIFT] = cGrp;
                        if (haveKeys[HAVECTRL] == UNKNOWN_GROUPING) haveKeys[HAVECTRL] = cGrp;
                        if (haveKeys[HAVEALT] == UNKNOWN_GROUPING) haveKeys[HAVEALT] = cGrp;
                        break;

                    case ')':
                        if (cGrp < 1) throw new ArgumentException(SR.GetString(SR.InvalidSendKeysString, keys));
                        CancelMods(haveKeys, cGrp, hwnd);
                        cGrp--;
                        if (cGrp == 0) fStartNewChar = true;
                        break;

                    case '~':
                        vk = (int)Keys.Return;
                        AddMsgsForVK(vk, repeat, haveKeys[HAVEALT] > 0 && haveKeys[HAVECTRL] == 0, hwnd);
                        break;

                    default:
                        fStartNewChar = AddSimpleKey(keys[i], repeat, hwnd, haveKeys, fStartNewChar, cGrp);
                        break;
                }


                // next element in the string
                //
                i++;
            }

            if (cGrp != 0)
                throw new ArgumentException(SR.GetString(SR.SendKeysGroupDelimError));

            CancelMods(haveKeys, UNKNOWN_GROUPING, hwnd);
        }

        /// <include file='doc\SendKeys.uex' path='docs/doc[@for="SendKeys.Send"]/*' />
        /// <devdoc>
        ///    <para>Sends keystrokes to the active application.</para>
        /// </devdoc>
        public static void Send(string keys) {
            Send(keys, null, false);
        }

        /// <include file='doc\SendKeys.uex' path='docs/doc[@for="SendKeys.Send1"]/*' />
        /// <devdoc>
        ///     Sends keystrokes to the active application.
        /// </devdoc>


        // WARNING: this method will never work if control != null, because while
        // Windows journaling *looks* like it can be directed to a specific HWND,
        // it can't.
        //
        private static void Send(string keys, /*bogus*/ Control control) {
            Send(keys, control, false);
        }

        private static void Send(string keys, Control control, bool wait) {
            Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "UnmanagedCode Demanded");
            IntSecurity.UnmanagedCode.Demand();

            if (keys == null || keys.Length == 0) return;

            // If we're not going to wait, make sure there is a pump.
            //
            if (!wait && !Application.MessageLoop) {
                throw new InvalidOperationException(SR.GetString(SR.SendKeysNoMessageLoop));
            }

            // generate the list of events that we're going to fire off with the hook
            //
            ParseKeys(keys, (control != null) ? control.Handle : IntPtr.Zero);

            // if there weren't any events posted as a result, we're done!
            //
            if (events == null) return;

            byte[] oldstate = GetKeyboardState();
            ClearKeyboardState();

            // finally, install the hook to do the work
            //
            InstallHook();

            SetKeyboardState(oldstate);

            if (wait) {
                Flush();
            }
        }

        /// <include file='doc\SendKeys.uex' path='docs/doc[@for="SendKeys.SendWait"]/*' />
        /// <devdoc>
        ///    <para>Sends the given keys to the active application, and then waits for
        ///       the messages to be processed.</para>
        /// </devdoc>
        public static void SendWait(string keys) {
            SendWait(keys, null);
        }

        /// <include file='doc\SendKeys.uex' path='docs/doc[@for="SendKeys.SendWait1"]/*' />
        /// <devdoc>
        ///     Sends the given keys to the active application, and then waits for
        ///     the messages to be processed.
        /// </devdoc>


        // WARNING: this method will never work if control != null, because while
        // Windows journaling *looks* like it can be directed to a specific HWND,
        // it can't.
        //
        private static void SendWait(string keys, Control control) {
            Send(keys, control, true);
        }

        /// <include file='doc\SendKeys.uex' path='docs/doc[@for="SendKeys.Flush"]/*' />
        /// <devdoc>
        ///    <para>Processes all the Windows messages currently in the message queue.</para>
        /// </devdoc>
        public static void Flush() {
            Application.DoEvents();
            while (events != null && events.Count > 0) {
                Application.DoEvents();
            }
        }
    
        /// <include file='doc\SendKeys.uex' path='docs/doc[@for="SendKeys.UninstallJournalingHook"]/*' />
        /// <devdoc>
        ///     cleans up and uninstalls the hook
        /// </devdoc>
        private static void UninstallJournalingHook() {
            if (hhook != IntPtr.Zero) {
                stopHook = false;
                
                if (events != null) {
                  events.Clear();
                }
                UnsafeNativeMethods.UnhookWindowsHookEx(new HandleRef(null, hhook));
                hhook = IntPtr.Zero;
            }
        }
        
        /// <devdoc>
        ///     SendKeys creates a window to monitor WM_CANCELJOURNAL messages.
        /// </devdoc>
        private class SKWindow : Control {
        
            public SKWindow() {
                SetState(STATE_TOPLEVEL, true);
                SetBounds(-1, -1, 0, 0);
                Visible = false;
            }
            
            protected override void WndProc(ref Message m) {
                if (m.Msg == NativeMethods.WM_CANCELJOURNAL) {
                    try {
                        SendKeys.JournalCancel();
                    }
                    catch (Exception) {
                    }
                }
            }
        }
        
        /// <include file='doc\SendKeys.uex' path='docs/doc[@for="SendKeys.SKEvent"]/*' />
        /// <devdoc>
        ///     helps us hold information about the various events we're going to journal
        /// </devdoc>
        private class SKEvent {
            internal int wm;
            internal IntPtr paramL;
            internal IntPtr paramH;
            internal IntPtr hwnd;
    
            public SKEvent(int a, int b, bool c, IntPtr hwnd) {
                wm = a;
                paramL = (IntPtr)b;
                paramH = (IntPtr)((c) ? 1 : 0);
                this.hwnd = hwnd;
            }

            public SKEvent(int a, int b, int c, IntPtr hwnd) {
                wm = a;
                paramL = (IntPtr)b;
                paramH = (IntPtr)c;
                this.hwnd = hwnd;
            }
        }
    
        /// <include file='doc\SendKeys.uex' path='docs/doc[@for="SendKeys.KeywordVk"]/*' />
        /// <devdoc>
        ///     holds a keyword and the associated VK_ for it
        /// </devdoc>
        private class KeywordVk {
            internal string keyword;
            internal int    vk;
    
            public KeywordVk(string key, int v) {
                keyword = key;
                vk = v;
            }
        }
    
        /// <include file='doc\SendKeys.uex' path='docs/doc[@for="SendKeys.SendKeysHookProc"]/*' />
        /// <devdoc>
        ///     this class is our callback for the journaling hook we install
        /// </devdoc>
        private class SendKeysHookProc {
    
            public virtual IntPtr Callback(int code, IntPtr wparam, IntPtr lparam) {
                NativeMethods.EVENTMSG eventmsg = (NativeMethods.EVENTMSG)UnsafeNativeMethods.PtrToStructure(lparam, typeof(NativeMethods.EVENTMSG));
                
    
                if (UnsafeNativeMethods.GetAsyncKeyState((int)Keys.Pause) != 0) {
                    SendKeys.stopHook = true;
                }
                
                //CONSIDER: Change Flush so that it checks for stopHook being true instead of events being empty?
                switch (code) {
                    case NativeMethods.HC_SKIP:
                        if (SendKeys.events != null && SendKeys.events.Count > 0) {
                                SendKeys.events.Dequeue();
                        }
                        SendKeys.stopHook = SendKeys.events == null || SendKeys.events.Count == 0;
                        break;
    
                    case NativeMethods.HC_GETNEXT:
                        
                        #if DEBUG
                        Debug.Assert(SendKeys.events != null && SendKeys.events.Count > 0 && !SendKeys.stopHook, "HC_GETNEXT when queue is empty!");
                        #endif
                        
                        SKEvent evt = (SKEvent)SendKeys.events.Peek();
                        eventmsg.message = evt.wm;
                        eventmsg.paramL = evt.paramL;
                        eventmsg.paramH = evt.paramH;
                        eventmsg.hwnd = evt.hwnd;
                        eventmsg.time = SafeNativeMethods.GetTickCount();
                        Marshal.StructureToPtr(eventmsg, lparam, true);
                        break;
    
                    default:
                        if (code < 0)
                            UnsafeNativeMethods.CallNextHookEx(new HandleRef(null, SendKeys.hhook), code, wparam, lparam);
                        break;
                }
                
                if (SendKeys.stopHook) {
                    SendKeys.UninstallJournalingHook();
                }
                return IntPtr.Zero;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\splitter.cs ===
//------------------------------------------------------------------------------
// <copyright file="Splitter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {
    
    using Microsoft.Win32;
    using System;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Drawing;
    using System.Runtime.InteropServices;
    using System.Runtime.Remoting;
    using System.Security;
    using System.Security.Permissions;
    using System.Windows.Forms;

    /// <include file='doc\Splitter.uex' path='docs/doc[@for="Splitter"]/*' />
    /// <devdoc>
    ///     Provides user resizing of docked elements at run time. To use a Splitter you can
    ///     dock any control to an edge of a container, and then dock the splitter to the same
    ///     edge. The splitter will then resize the control that is previous in the docking
    ///     order.
    /// </devdoc>
    [
    DefaultEvent("SplitterMoved"),
    DefaultProperty("Dock"),
    Designer("System.Windows.Forms.Design.SplitterDesigner, " + AssemblyRef.SystemDesign)
    ]
    public class Splitter : Control, IMessageFilter {
        private const int DRAW_START = 1;
        private const int DRAW_MOVE = 2;
        private const int DRAW_END = 3;

        private const int defaultWidth = 3;

        private BorderStyle borderStyle = System.Windows.Forms.BorderStyle.None;
        private int minSize = 25;
        private int minExtra = 25;
        private Point anchor = Point.Empty;
        private Control splitTarget;
        private int splitSize = -1;
        private int splitterThickness = 3;
        private int initTargetSize;
        private int lastDrawSplit = -1;       
        private int maxSize;
        private static readonly object EVENT_MOVING = new object();
        private static readonly object EVENT_MOVED = new object();

        /// <include file='doc\Splitter.uex' path='docs/doc[@for="Splitter.Splitter"]/*' />
        /// <devdoc>
        ///     Creates a new Splitter.
        /// </devdoc>
        public Splitter()
        : base() {
            SetStyle(ControlStyles.Selectable, false);
            TabStop = false;
            minSize = 25;
            minExtra = 25;
            
            Dock = DockStyle.Left;
        }

        /// <include file='doc\Splitter.uex' path='docs/doc[@for="Splitter.Anchor"]/*' />
        /// <devdoc>
        ///     The current value of the anchor property. The anchor property
        ///     determines which edges of the control are anchored to the container's
        ///     edges.
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never),
        DefaultValue(AnchorStyles.None)]
        public override AnchorStyles Anchor {
            get {
                return AnchorStyles.None;
            }
            set {
                // do nothing!
            }
        }

        /// <include file='doc\Splitter.uex' path='docs/doc[@for="Splitter.AllowDrop"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override bool AllowDrop {
            get {
                return base.AllowDrop;
            }
            set {
                base.AllowDrop = value;
            }
        }

        /// <include file='doc\Splitter.uex' path='docs/doc[@for="Splitter.DefaultSize"]/*' />
        /// <devdoc>
        ///     Deriving classes can override this to configure a default size for their control.
        ///     This is more efficient than setting the size in the control's constructor.
        /// </devdoc>
        protected override Size DefaultSize {
            get {
                return new Size(defaultWidth, defaultWidth);
            }
        }

        internal override Cursor DefaultCursor {
            get {
                switch (Dock) {
                    case DockStyle.Top:
                    case DockStyle.Bottom:
                        return Cursors.HSplit;
                    case DockStyle.Left:
                    case DockStyle.Right:
                        return Cursors.VSplit;
                }
                return base.DefaultCursor;
            }
        }

        /// <include file='doc\Splitter.uex' path='docs/doc[@for="Splitter.ForeColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override Color ForeColor {
            get {
                return base.ForeColor;
            }
            set {
                base.ForeColor = value;
            }
        }

        /// <include file='doc\Splitter.uex' path='docs/doc[@for="Splitter.ForeColorChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler ForeColorChanged {
            add {
                base.ForeColorChanged += value;
            }
            remove {
                base.ForeColorChanged -= value;
            }
        }

        /// <include file='doc\Splitter.uex' path='docs/doc[@for="Splitter.BackgroundImage"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override Image BackgroundImage {
            get {
                return base.BackgroundImage;
            }
            set {
                base.BackgroundImage = value;
            }
        }

        /// <include file='doc\Splitter.uex' path='docs/doc[@for="Splitter.BackgroundImageChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler BackgroundImageChanged {
            add {
                base.BackgroundImageChanged += value;
            }
            remove {
                base.BackgroundImageChanged -= value;
            }
        }

        /// <include file='doc\Splitter.uex' path='docs/doc[@for="Splitter.Font"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>        
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override Font Font {
            get {
                return base.Font;
            }
            set {
                base.Font = value;
            }
        }

        /// <include file='doc\Splitter.uex' path='docs/doc[@for="Splitter.FontChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler FontChanged {
            add {
                base.FontChanged += value;
            }
            remove {
                base.FontChanged -= value;
            }
        }

        /// <include file='doc\Splitter.uex' path='docs/doc[@for="Splitter.BorderStyle"]/*' />
        /// <devdoc>
        ///     Indicates what type of border the Splitter control has.  This value
        ///     comes from the System.Windows.Forms.BorderStyle enumeration.
        /// </devdoc>
        [
        DefaultValue(BorderStyle.None),
        SRCategory(SR.CatAppearance),
        System.Runtime.InteropServices.DispId(NativeMethods.ActiveX.DISPID_BORDERSTYLE),
        SRDescription(SR.SplitterBorderStyleDescr)
        ]
        public BorderStyle BorderStyle {
            get {
                return borderStyle;
            }

            set {
                if (!Enum.IsDefined(typeof(BorderStyle), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(BorderStyle));
                }
            
                if (borderStyle != value) {
                    borderStyle = value;
                    UpdateStyles();
                }
            }
        }

        /// <include file='doc\Splitter.uex' path='docs/doc[@for="Splitter.CreateParams"]/*' />
        /// <devdoc>
        ///     Returns the parameters needed to create the handle.  Inheriting classes
        ///     can override this to provide extra functionality.  They should not,
        ///     however, forget to call base.getCreateParams() first to get the struct
        ///     filled up with the basic info.
        /// </devdoc>
        protected override CreateParams CreateParams {
            [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
            get {
                CreateParams cp = base.CreateParams;
                cp.ExStyle &= (~NativeMethods.WS_EX_CLIENTEDGE);
                cp.Style &= (~NativeMethods.WS_BORDER);

                switch (borderStyle) {
                    case BorderStyle.Fixed3D:
                        cp.ExStyle |= NativeMethods.WS_EX_CLIENTEDGE;
                        break;
                    case BorderStyle.FixedSingle:
                        cp.Style |= NativeMethods.WS_BORDER;
                        break;
                }
                return cp;
            }
        }
        
        /// <include file='doc\Splitter.uex' path='docs/doc[@for="Splitter.DefaultImeMode"]/*' />
        protected override ImeMode DefaultImeMode {
            get {
                return ImeMode.Disable;
            }
        }

        /// <include file='doc\Splitter.uex' path='docs/doc[@for="Splitter.Dock"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        [
        Localizable(true),
        DefaultValue(DockStyle.Left)
        ]
        public override DockStyle Dock {
            get { return base.Dock;}

            set {
            
                if (!(value == DockStyle.Top || value == DockStyle.Bottom || value == DockStyle.Left || value == DockStyle.Right)) {
                    throw new ArgumentException(SR.GetString(SR.SplitterInvalidDockEnum));
                }
                
                int requestedSize = splitterThickness;
                
                base.Dock = value;
                switch (Dock) {
                    case DockStyle.Top:
                    case DockStyle.Bottom:
                        if (splitterThickness != -1) {
                            Height = requestedSize;
                        }
                        break;
                    case DockStyle.Left:
                    case DockStyle.Right:
                        if (splitterThickness != -1) {
                            Width = requestedSize;
                        }
                        break;
                }
            }
        }

        /// <include file='doc\Splitter.uex' path='docs/doc[@for="Splitter.Horizontal"]/*' />
        /// <devdoc>
        ///     Determines if the splitter is horizontal.
        /// </devdoc>
        /// <internalonly/>
        private bool Horizontal {
            get {
                DockStyle dock = Dock;
                return dock == DockStyle.Left || dock == DockStyle.Right;
            }
        }
        
        /// <include file='doc\Splitter.uex' path='docs/doc[@for="Splitter.ImeMode"]/*' />
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public ImeMode ImeMode {
            get {
                return base.ImeMode;
            }
            set {
                base.ImeMode = value;
            }
        }

        /// <include file='doc\Splitter.uex' path='docs/doc[@for="Splitter.ImeModeChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event EventHandler ImeModeChanged {
            add {
                base.ImeModeChanged += value;
            }
            remove {
                base.ImeModeChanged -= value;
            }
        }

        /// <include file='doc\Splitter.uex' path='docs/doc[@for="Splitter.MinExtra"]/*' />
        /// <devdoc>
        ///     The minExtra is this minimum size (in pixels) of the remaining
        ///     area of the container. This area is center of the container that
        ///     is not occupied by edge docked controls, this is the are that
        ///     would be used for any fill docked control.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        Localizable(true),
        DefaultValue(25),
        SRDescription(SR.SplitterMinExtraDescr)
        ]
        public int MinExtra {
            get {
                return minExtra;
            }
            set {
                if (value < 0) value = 0;
                minExtra = value;
            }
        }

        /// <include file='doc\Splitter.uex' path='docs/doc[@for="Splitter.MinSize"]/*' />
        /// <devdoc>
        ///     The minSize is the minimum size (in pixels) of the target of the
        ///     splitter. The target of a splitter is always the control adjacent
        ///     to the splitter, just prior in the dock order.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        Localizable(true),
        DefaultValue(25),
        SRDescription(SR.SplitterMinSizeDescr)
        ]
        public int MinSize {
            get {
                return minSize;
            }
            set {
                if (value < 0) value = 0;
                minSize = value;
            }
        }

        /// <include file='doc\Splitter.uex' path='docs/doc[@for="Splitter.SplitPosition"]/*' />
        /// <devdoc>
        ///     The position of the splitter. If the splitter is not bound
        ///     to a control, SplitPosition will be -1.
        /// </devdoc>
        [
        SRCategory(SR.CatLayout),
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.SplitterSplitPositionDescr)
        ]
        public int SplitPosition {
            get {
                if (splitSize == -1) splitSize = CalcSplitSize();
                return splitSize;
            }
            set {
                // calculate maxSize and other bounding conditions
                SplitData spd = CalcSplitBounds();

                // this is not an else-if to handle the maxSize < minSize case...
                // ie. we give minSize priority over maxSize...
                if (value > maxSize) value = maxSize;
                if (value < minSize) value = minSize;

                // if (value == splitSize) return;  -- do we need this check?

                splitSize = value;
                DrawSplitBar(DRAW_END);

                if (spd.target == null) {
                    splitSize = -1;
                    return;
                }

                Rectangle bounds = spd.target.Bounds;
                switch (Dock) {
                    case DockStyle.Top:
                        bounds.Height = value;
                        break;
                    case DockStyle.Bottom:
                        bounds.Y += bounds.Height - splitSize;
                        bounds.Height = value;
                        break;
                    case DockStyle.Left:
                        bounds.Width = value;
                        break;
                    case DockStyle.Right:
                        bounds.X += bounds.Width - splitSize;
                        bounds.Width = value;
                        break;
                }
                spd.target.Bounds = bounds;
                Application.DoEvents();
                OnSplitterMoved(new SplitterEventArgs(Left, Top, (Left + bounds.Width / 2), (Top + bounds.Height / 2)));
                
            }
        }

        /// <include file='doc\Splitter.uex' path='docs/doc[@for="Splitter.TabStop"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public bool TabStop {
            get {
                return base.TabStop;
            }
            set {
                base.TabStop = value;
            }
        }

        /// <include file='doc\Splitter.uex' path='docs/doc[@for="Splitter.TabStopChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler TabStopChanged {
            add {
                base.TabStopChanged += value;
            }
            remove {
                base.TabStopChanged -= value;
            }
        }

        /// <include file='doc\Splitter.uex' path='docs/doc[@for="Splitter.Text"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>        
        [
        Browsable(false), EditorBrowsable(EditorBrowsableState.Never), 
        Bindable(false), 
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]                
        public override string Text {
            get {
                return base.Text;
            }
            set {
                base.Text = value;
            }
        }
        
        /// <include file='doc\Splitter.uex' path='docs/doc[@for="Splitter.TextChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler TextChanged {
            add {
                base.TextChanged += value;
            }
            remove {
                base.TextChanged -= value;
            }
        }
        
        /// <include file='doc\Splitter.uex' path='docs/doc[@for="Splitter.Enter"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event EventHandler Enter {
            add {
                base.Enter += value;
            }
            remove {
                base.Enter -= value;
            }
        }

        /// <include file='doc\Splitter.uex' path='docs/doc[@for="Splitter.KeyUp"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event KeyEventHandler KeyUp {
            add {
                base.KeyUp += value;
            }
            remove {
                base.KeyUp -= value;
            }
        }

        /// <include file='doc\Splitter.uex' path='docs/doc[@for="Splitter.KeyDown"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event KeyEventHandler KeyDown {
            add {
                base.KeyDown += value;
            }
            remove {
                base.KeyDown -= value;
            }
        }

        /// <include file='doc\Splitter.uex' path='docs/doc[@for="Splitter.KeyPress"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event KeyPressEventHandler KeyPress {
            add {
                base.KeyPress += value;
            }
            remove {
                base.KeyPress -= value;
            }
        }

        /// <include file='doc\Splitter.uex' path='docs/doc[@for="Splitter.Leave"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event EventHandler Leave {
            add {
                base.Leave += value;
            }
            remove {
                base.Leave -= value;
            }
        }

        /// <include file='doc\Splitter.uex' path='docs/doc[@for="Splitter.SplitterMoving"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatBehavior), SRDescription(SR.SplitterSplitterMovingDescr)]
        public event SplitterEventHandler SplitterMoving {
            add {
                Events.AddHandler(EVENT_MOVING, value);
            }
            remove {
                Events.RemoveHandler(EVENT_MOVING, value);
            }
        }


        /// <include file='doc\Splitter.uex' path='docs/doc[@for="Splitter.SplitterMoved"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatBehavior), SRDescription(SR.SplitterSplitterMovedDescr)]
        public event SplitterEventHandler SplitterMoved {
            add {
                Events.AddHandler(EVENT_MOVED, value);
            }
            remove {
                Events.RemoveHandler(EVENT_MOVED, value);
            }
        }

        /// <include file='doc\Splitter.uex' path='docs/doc[@for="Splitter.DrawSplitBar"]/*' />
        /// <devdoc>
        ///     Draws the splitter bar at the current location. Will automatically
        ///     cleanup anyplace the splitter was drawn previously.
        /// </devdoc>
        /// <internalonly/>
        private void DrawSplitBar(int mode) {
            if (mode != DRAW_START && lastDrawSplit != -1) {
                DrawSplitHelper(lastDrawSplit);
                lastDrawSplit = -1;
            }
            // Bail if drawing with no old point...
            //
            else if (mode != DRAW_START && lastDrawSplit == -1) {
                return;
            }

            if (mode != DRAW_END) {
                DrawSplitHelper(splitSize);
                lastDrawSplit = splitSize;
            }
            else {
                if (lastDrawSplit != -1) {
                    DrawSplitHelper(lastDrawSplit);
                }
                lastDrawSplit = -1;
            }
        }

        /// <include file='doc\Splitter.uex' path='docs/doc[@for="Splitter.CalcSplitLine"]/*' />
        /// <devdoc>
        ///     Calculates the bounding rect of the split line. minWeight refers
        ///     to the minimum height or width of the splitline.
        /// </devdoc>
        private Rectangle CalcSplitLine(int splitSize, int minWeight) {
            Rectangle r = Bounds;
            Rectangle bounds = splitTarget.Bounds;
            switch (Dock) {
                case DockStyle.Top:
                    if (r.Height < minWeight) r.Height = minWeight;
                    r.Y = bounds.Y + splitSize;
                    break;
                case DockStyle.Bottom:
                    if (r.Height < minWeight) r.Height = minWeight;
                    r.Y = bounds.Y + bounds.Height - splitSize - r.Height;
                    break;
                case DockStyle.Left:
                    if (r.Width < minWeight) r.Width = minWeight;
                    r.X = bounds.X + splitSize;
                    break;
                case DockStyle.Right:
                    if (r.Width < minWeight) r.Width = minWeight;
                    r.X = bounds.X + bounds.Width - splitSize - r.Width;
                    break;
            }
            return r;
        }

        /// <include file='doc\Splitter.uex' path='docs/doc[@for="Splitter.CalcSplitSize"]/*' />
        /// <devdoc>
        ///     Calculates the current size of the splitter-target.
        /// </devdoc>
        /// <internalonly/>
        private int CalcSplitSize() {
            Control target = FindTarget();
            if (target == null) return -1;
            Rectangle r = target.Bounds;
            switch (Dock) {
                case DockStyle.Top:
                case DockStyle.Bottom:
                    return r.Height;
                case DockStyle.Left:
                case DockStyle.Right:
                    return r.Width;
                default:
                    return -1; // belts & braces
            }
        }

        /// <include file='doc\Splitter.uex' path='docs/doc[@for="Splitter.CalcSplitBounds"]/*' />
        /// <devdoc>
        ///     Calculates the bounding criteria for the splitter.
        /// </devdoc>
        /// <internalonly/>
        private SplitData CalcSplitBounds() {
            SplitData spd = new SplitData();
            Control target = FindTarget();
            spd.target = target;
            if (target != null) {
                switch (target.Dock) {
                    case DockStyle.Left:
                    case DockStyle.Right:
                        initTargetSize = target.Bounds.Width;
                        break;
                    case DockStyle.Top:
                    case DockStyle.Bottom:
                        initTargetSize = target.Bounds.Height;
                        break;
                }
                Control parent = ParentInternal;
                int count = parent.Controls.Count;
                int dockWidth = 0, dockHeight = 0;
                for (int i = 0; i < count; i++) {
                    Control ctl = parent.Controls[i];
                    if (ctl != target) {
                        switch (((Control)ctl).Dock) {
                            case DockStyle.Left:
                            case DockStyle.Right:
                                dockWidth += ctl.Width;
                                break;
                            case DockStyle.Top:
                            case DockStyle.Bottom:
                                dockHeight += ctl.Height;
                                break;
                        }
                    }
                }
                Size clientSize = parent.ClientSize;
                if (Horizontal) {
                    maxSize = clientSize.Width - dockWidth - minExtra;
                }
                else {
                    maxSize = clientSize.Height - dockHeight - minExtra;
                }
                spd.dockWidth = dockWidth;
                spd.dockHeight = dockHeight;
            }
            return spd;
        }

        /// <include file='doc\Splitter.uex' path='docs/doc[@for="Splitter.DrawSplitHelper"]/*' />
        /// <devdoc>
        ///     Draws the splitter line at the requested location. Should only be called
        ///     by drawSpltBar.
        /// </devdoc>
        /// <internalonly/>
        private void DrawSplitHelper(int splitSize) {
            if (splitTarget == null) {
                return;
            }

            Rectangle r = CalcSplitLine(splitSize, 3);
            IntPtr parentHandle = ParentInternal.Handle;
            IntPtr dc = UnsafeNativeMethods.GetDCEx(new HandleRef(ParentInternal, parentHandle), NativeMethods.NullHandleRef, NativeMethods.DCX_CACHE | NativeMethods.DCX_LOCKWINDOWUPDATE);
            IntPtr halftone = ControlPaint.CreateHalftoneHBRUSH();
            IntPtr saveBrush = SafeNativeMethods.SelectObject(new HandleRef(ParentInternal, dc), new HandleRef(null, halftone));
            SafeNativeMethods.PatBlt(new HandleRef(ParentInternal, dc), r.X, r.Y, r.Width, r.Height, NativeMethods.PATINVERT);
            SafeNativeMethods.SelectObject(new HandleRef(ParentInternal, dc), new HandleRef(null, saveBrush));
            SafeNativeMethods.DeleteObject(new HandleRef(null, halftone));
            UnsafeNativeMethods.ReleaseDC(new HandleRef(ParentInternal, parentHandle), new HandleRef(null, dc));
        }

        /// <include file='doc\Splitter.uex' path='docs/doc[@for="Splitter.RaiseSplitterEvent"]/*' />
        /// <devdoc>
        ///     Raises a splitter event
        /// </devdoc>
        /// <internalonly/>
        private void RaiseSplitterEvent(object key, SplitterEventArgs spevent) {
            SplitterEventHandler handler = (SplitterEventHandler)Events[key];
            if (handler != null) handler(this, spevent);
        }

        /// <include file='doc\Splitter.uex' path='docs/doc[@for="Splitter.FindTarget"]/*' />
        /// <devdoc>
        ///     Finds the target of the splitter. The target of the splitter is the
        ///     control that is "outside" or the splitter. For example, if the splitter
        ///     is docked left, the target is the control that is just to the left
        ///     of the splitter.
        /// </devdoc>
        /// <internalonly/>
        private Control FindTarget() {
            Control parent = ParentInternal;
            if (parent == null) return null;
            int count = parent.Controls.Count;
            DockStyle dock = Dock;
            for (int i = 0; i < count; i++) {
                Control target = parent.Controls[i];
                if (target != this) {
                    switch (dock) {
                        case DockStyle.Top:
                            if (target.Bottom == Top) return(Control)target;
                            break;
                        case DockStyle.Bottom:
                            if (target.Top == Bottom) return(Control)target;
                            break;
                        case DockStyle.Left:
                            if (target.Right == Left) return(Control)target;
                            break;
                        case DockStyle.Right:
                            if (target.Left == Right) return(Control)target;
                            break;
                    }
                }
            }
            return null;
        }

        /// <include file='doc\Splitter.uex' path='docs/doc[@for="Splitter.GetSplitSize"]/*' />
        /// <devdoc>
        ///     Calculates the split size based on the mouse position (x, y).
        /// </devdoc>
        /// <internalonly/>
        private int GetSplitSize(int x, int y) {
            int delta;
            if (Horizontal) {
                delta = x - anchor.X;
            }
            else {
                delta = y - anchor.Y;
            }
            int size = 0;
            switch (Dock) {
                case DockStyle.Top:
                    size = splitTarget.Height + delta;
                    break;
                case DockStyle.Bottom:
                    size = splitTarget.Height - delta;
                    break;
                case DockStyle.Left:
                    size = splitTarget.Width + delta;
                    break;
                case DockStyle.Right:
                    size = splitTarget.Width - delta;
                    break;
            }
            return Math.Max(Math.Min(size, maxSize), minSize);
        }
        
        /// <include file='doc\Splitter.uex' path='docs/doc[@for="Splitter.OnKeyDown"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        protected override void OnKeyDown(KeyEventArgs e) {
            base.OnKeyDown(e);
            if (splitTarget != null && e.KeyCode == Keys.Escape) {
                SplitEnd(false);
            }
        }

        /// <include file='doc\Splitter.uex' path='docs/doc[@for="Splitter.OnMouseDown"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        protected override void OnMouseDown(MouseEventArgs e) {
            base.OnMouseDown(e);
            if (e.Button == MouseButtons.Left && e.Clicks == 1) {
                SplitBegin(e.X, e.Y);
            }
        }

        /// <include file='doc\Splitter.uex' path='docs/doc[@for="Splitter.OnMouseMove"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        protected override void OnMouseMove(MouseEventArgs e) {
            base.OnMouseMove(e);
            if (splitTarget != null) {
                int x = e.X + Left;
                int y = e.Y + Top;
                Rectangle r = CalcSplitLine(GetSplitSize(e.X, e.Y), 0);
                int xSplit = r.X;
                int ySplit = r.Y;
                OnSplitterMoving(new SplitterEventArgs(x, y, xSplit, ySplit));
            }
        }

        /// <include file='doc\Splitter.uex' path='docs/doc[@for="Splitter.OnMouseUp"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        protected override void OnMouseUp(MouseEventArgs e) {
            base.OnMouseUp(e);
            if (splitTarget != null) {
                int x = e.X + Left;
                int y = e.Y + Top;
                Rectangle r = CalcSplitLine(GetSplitSize(e.X, e.Y), 0);
                int xSplit = r.X;
                int ySplit = r.Y;
                SplitEnd(true);
            }
        }

        /// <include file='doc\Splitter.uex' path='docs/doc[@for="Splitter.OnSplitterMoving"]/*' />
        /// <devdoc>
        ///     Inherriting classes should override this method to respond to the
        ///     splitterMoving event. This event occurs while the splitter is
        ///     being moved by the user.
        /// </devdoc>
        protected virtual void OnSplitterMoving(SplitterEventArgs sevent) {
            SplitterEventHandler handler = (SplitterEventHandler)Events[EVENT_MOVING];
            if (handler != null) handler(this,sevent);
            if (splitTarget != null) {
                SplitMove(sevent.SplitX, sevent.SplitY);
            }
        }

        /// <include file='doc\Splitter.uex' path='docs/doc[@for="Splitter.OnSplitterMoved"]/*' />
        /// <devdoc>
        ///     Inherriting classes should override this method to respond to the
        ///     splitterMoved event. This event occurs when the user finishes
        ///     moving the splitter.
        /// </devdoc>
        protected virtual void OnSplitterMoved(SplitterEventArgs sevent) {
            SplitterEventHandler handler = (SplitterEventHandler)Events[EVENT_MOVED];
            if (handler != null) handler(this,sevent);
            if (splitTarget != null) {
                SplitMove(sevent.SplitX, sevent.SplitY);
            }
        }

        /// <include file='doc\Splitter.uex' path='docs/doc[@for="Splitter.PreFilterMessage"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        [
            System.Security.Permissions.SecurityPermissionAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode),
        ]
        public bool PreFilterMessage(ref Message m) {
            if (m.Msg >= NativeMethods.WM_KEYFIRST && m.Msg <= NativeMethods.WM_KEYLAST) {
                if (m.Msg == NativeMethods.WM_KEYDOWN && (int)m.WParam == (int)Keys.Escape) {
                    SplitEnd(false);
                }
                return true;
            }
            return false;
        }

        /// <include file='doc\Splitter.uex' path='docs/doc[@for="Splitter.SetBoundsCore"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void SetBoundsCore(int x, int y, int width, int height, BoundsSpecified specified) {
            if (Horizontal) {
                if (width < 1) {
                    width = 3;
                }
                splitterThickness = width;
            }
            else {
                if (height < 1) {
                    height = 3;
                }
                splitterThickness = height;
            }
            base.SetBoundsCore(x, y, width, height, specified);
        }

        /// <include file='doc\Splitter.uex' path='docs/doc[@for="Splitter.SplitBegin"]/*' />
        /// <devdoc>
        ///     Begins the splitter moving.
        /// </devdoc>
        /// <internalonly/>
        private void SplitBegin(int x, int y) {
            SplitData spd = CalcSplitBounds();
            if (spd.target != null && (minSize < maxSize)) {
                anchor = new Point(x, y);
                splitTarget = spd.target;
                splitSize = GetSplitSize(x, y);

                // SECREVIEW : We need a message filter to capture the ESC key
                //           : to cancel the split action.
                //
                IntSecurity.UnmanagedCode.Assert();
                try {
                    Application.AddMessageFilter(this);
                }
                finally {
                    CodeAccessPermission.RevertAssert();
                }
                CaptureInternal = true;
                DrawSplitBar(DRAW_START);
            }
        }

        /// <include file='doc\Splitter.uex' path='docs/doc[@for="Splitter.SplitEnd"]/*' />
        /// <devdoc>
        ///     Finishes the split movement.
        /// </devdoc>
        /// <internalonly/>
        private void SplitEnd(bool accept) {
            DrawSplitBar(DRAW_END);
            splitTarget = null;
            CaptureInternal = false;
            Application.RemoveMessageFilter(this);

            if (accept) {
                ApplySplitPosition();
            }
            else if (splitSize != initTargetSize) {
                SplitPosition = initTargetSize;
            }
            anchor = Point.Empty;
        }

        /// <include file='doc\Splitter.uex' path='docs/doc[@for="Splitter.ApplySplitPosition"]/*' />
        /// <devdoc>
        ///     Sets the split position to be the current split size. This is called
        ///     by splitEdit
        /// </devdoc>
        /// <internalonly/>
        private void ApplySplitPosition() {
            SplitPosition = splitSize;
        }
        
        /// <include file='doc\Splitter.uex' path='docs/doc[@for="Splitter.SplitMove"]/*' />
        /// <devdoc>
        ///     Moves the splitter line to the splitSize for the mouse position
        ///     (x, y).
        /// </devdoc>
        /// <internalonly/>
        private void SplitMove(int x, int y) {
            int size = GetSplitSize(x-Left+anchor.X, y-Top+anchor.Y);
            if (splitSize != size) {
                splitSize = size;
                DrawSplitBar(DRAW_MOVE);
            }
        }

        /// <include file='doc\Splitter.uex' path='docs/doc[@for="Splitter.ToString"]/*' />
        /// <devdoc>
        ///     Returns a string representation for this control.
        /// </devdoc>
        /// <internalonly/>
        public override string ToString() {

            string s = base.ToString();
            return s + ", MinExtra: " + MinExtra.ToString() + ", MinSize: " + MinSize.ToString();
        }

        /// <include file='doc\Splitter.uex' path='docs/doc[@for="Splitter.SplitData"]/*' />
        /// <devdoc>
        ///     Return value holder...
        /// </devdoc>
        private class SplitData {
            public int dockWidth = -1;
            public int dockHeight = -1;
            internal Control target;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\splitterevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="SplitterEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    using System.Drawing;
    using Microsoft.Win32;

    /// <include file='doc\SplitterEvent.uex' path='docs/doc[@for="SplitterEventArgs"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides data for splitter events.
    ///    </para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    public class SplitterEventArgs : EventArgs {

        private readonly int x;
        private readonly int y;
        private int splitX;
        private int splitY;

        /// <include file='doc\SplitterEvent.uex' path='docs/doc[@for="SplitterEventArgs.SplitterEventArgs"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes an instance of the <see cref='System.Windows.Forms.SplitterEventArgs'/> class with the specified coordinates
        ///       of the mouse pointer and the upper-left corner of the <see cref='System.Windows.Forms.Splitter'/>.
        ///    </para>
        /// </devdoc>
        public SplitterEventArgs(int x, int y, int splitX, int splitY) {
            this.x = x;
            this.y = y;
            this.splitX = splitX;
            this.splitY = splitY;
        }

        /// <include file='doc\SplitterEvent.uex' path='docs/doc[@for="SplitterEventArgs.X"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the x-coordinate of the
        ///       mouse pointer (in client coordinates).
        ///    </para>
        /// </devdoc>
        public int X {
            get {
                return x;
            }
        }

        /// <include file='doc\SplitterEvent.uex' path='docs/doc[@for="SplitterEventArgs.Y"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the y-coordinate of the mouse pointer (in
        ///       client coordinates).
        ///    </para>
        /// </devdoc>
        public int Y {
            get {
                return y;
            }
        }

        /// <include file='doc\SplitterEvent.uex' path='docs/doc[@for="SplitterEventArgs.SplitX"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the x-coordinate of the
        ///       upper-left corner of the <see cref='System.Windows.Forms.Splitter'/> (in client coordinates).
        ///    </para>
        /// </devdoc>
        public int SplitX {
            get {
                return splitX;
            }
            set {
                splitX = value;
            }
        }

        /// <include file='doc\SplitterEvent.uex' path='docs/doc[@for="SplitterEventArgs.SplitY"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the y-coordinate of the upper-left corner of the <see cref='System.Windows.Forms.Splitter'/> (in client coordinates).
        ///    </para>
        /// </devdoc>
        public int SplitY {
            get {
                return splitY;
            }
            set {
                splitY = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\statusbar.cs ===
//------------------------------------------------------------------------------
// <copyright file="StatusBar.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.InteropServices;
    using System.Runtime.Remoting;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Security.Permissions;
    using System.Drawing;
    using System.Windows.Forms;    
    using System.Collections;
    using Microsoft.Win32;

    /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a Windows status bar control.
    ///    </para>
    /// </devdoc>
    [
    DefaultEvent("PanelClick"),
    DefaultProperty("Text"),
    Designer("System.Windows.Forms.Design.StatusBarDesigner, " + AssemblyRef.SystemDesign),
    ]
    public class StatusBar : Control {

        private const int SIZEGRIP_WIDTH = 16;
        private const int SIMPLE_INDEX = 0xFF;

        private static readonly object EVENT_PANELCLICK = new object();
        private static readonly object EVENT_SBDRAWITEM = new object();

        private bool                         showPanels;
        private bool                         layoutDirty;
        private int                          panelsRealized;
        private bool                         sizeGrip = true;
        private string                       simpleText;
        private Point                        lastClick = new Point(0, 0);
        private IList                        panels = new ArrayList();
        private StatusBarPanelCollection     panelsCollection;
        private ControlToolTip               tooltips;

        /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.StatusBar"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new default instance of the <see cref='System.Windows.Forms.StatusBar'/> class.
        ///    </para>
        /// </devdoc>
        public StatusBar()
        : base() {
            base.SetStyle(ControlStyles.UserPaint | ControlStyles.Selectable, false);

            Dock = DockStyle.Bottom;
            TabStop = false;
        }

        /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.BackColor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The background color of this control. This is an ambient property and will
        ///       always return a non-null value.
        ///    </para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override Color BackColor {
            get {
                // not supported, always return CONTROL
                return SystemColors.Control;
            }

            set {
                // no op, not supported.
            }
        }

        /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.BackColorChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler BackColorChanged {
            add {
                base.BackColorChanged += value;
            }
            remove {
                base.BackColorChanged -= value;
            }
        }

        /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.BackgroundImage"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the image rendered on the background of the
        ///    <see cref='System.Windows.Forms.StatusBar'/>
        ///    control.
        /// </para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override Image BackgroundImage {
            get {
                return base.BackgroundImage;
            }
            set {
                base.BackgroundImage = value;
            }
        }

        /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.BackgroundImageChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler BackgroundImageChanged {
            add {
                base.BackgroundImageChanged += value;
            }
            remove {
                base.BackgroundImageChanged -= value;
            }
        }

        /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.CreateParams"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the CreateParams used to create the handle for this control.
        ///       Inheriting classes should call base.getCreateParams in the manor below:
        ///    </para>
        /// </devdoc>
        protected override CreateParams CreateParams {
            [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
            get {
                CreateParams cp = base.CreateParams;
                cp.ClassName = NativeMethods.WC_STATUSBAR;

                if (this.sizeGrip) {
                    cp.Style |= NativeMethods.SBARS_SIZEGRIP;
                }
                else {
                    cp.Style &= (~NativeMethods.SBARS_SIZEGRIP);
                }
                cp.Style |= NativeMethods.CCS_NOPARENTALIGN | NativeMethods.CCS_NORESIZE;

                return cp;
            }
        }
        
        /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.DefaultImeMode"]/*' />
        protected override ImeMode DefaultImeMode {
            get {
                return ImeMode.Disable;
            }
        }

        /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.DefaultSize"]/*' />
        /// <devdoc>
        ///     Deriving classes can override this to configure a default size for their control.
        ///     This is more efficient than setting the size in the control's constructor.
        /// </devdoc>
        protected override Size DefaultSize {
            get {
                return new Size(100, 22);
            }
        }

        /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.Dock"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the docking behavior of the <see cref='System.Windows.Forms.StatusBar'/> control.
        ///    </para>
        /// </devdoc>
        [
        Localizable(true),
        DefaultValue(DockStyle.Bottom)
        ]
        public override DockStyle Dock {
            get {
                return base.Dock;
            }
            set {
                base.Dock = value;
            }
        }

        /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.Font"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the font the <see cref='System.Windows.Forms.StatusBar'/>
        ///       control will use to display
        ///       information.
        ///    </para>
        /// </devdoc>
        [
        Localizable(true)
        ]
        public override Font Font {
            get { return base.Font;}
            set {
                base.Font = value;
                SetPanelContentsWidths(false);
            }
        }

        /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.ForeColor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets
        ///       the forecolor for the control.
        ///    </para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override Color ForeColor {
            get {
                return base.ForeColor;
            }
            set {
                base.ForeColor = value;
            }
        }
        
        /// <include file='doc\StatusBar.uex' path='docs/doc[@for="DateTimePicker.StatusBar"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler ForeColorChanged {
            add {
                base.ForeColorChanged += value;
            }
            remove {
                base.ForeColorChanged -= value;
            }
        }

        /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.ImeMode"]/*' />
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public ImeMode ImeMode {
            get {
                return base.ImeMode;
            }
            set {
                base.ImeMode = value;
            }
        }

        /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.ImeModeChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event EventHandler ImeModeChanged {
            add {
                base.ImeModeChanged += value;
            }
            remove {
                base.ImeModeChanged -= value;
            }
        }

        /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.Panels"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the collection of <see cref='System.Windows.Forms.StatusBar'/>
        ///       panels contained within the
        ///       control.
        ///    </para>
        /// </devdoc>
        [
        DesignerSerializationVisibility(DesignerSerializationVisibility.Content),
        SRDescription(SR.StatusBarPanelsDescr),
        Localizable(true),
        SRCategory(SR.CatAppearance),        
        MergableProperty(false)
        ]
        public StatusBarPanelCollection Panels {
            get {
                if (panelsCollection == null) {
                    panelsCollection = new StatusBarPanelCollection(this);
                }

                return panelsCollection;
            }
        }

        /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.Text"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The status bar text.
        ///    </para>
        /// </devdoc>
        [
        Localizable(true)
        ]
        public override string Text {
            get {
                if (simpleText == null) {
                    return "";
                }
                else {
                    return simpleText;
                }
            }
            set {
                SetSimpleText(value);
                if (simpleText != value) {
                    simpleText = value;
                    OnTextChanged(EventArgs.Empty);
                }
            }
        }

        private IntPtr ToolTipHandle {
            get {
                EnumChildren c = new EnumChildren( this );
                UnsafeNativeMethods.EnumChildWindows(new HandleRef(null, UnsafeNativeMethods.GetDesktopWindow()), new NativeMethods.EnumChildrenProc(c.Callback), NativeMethods.NullHandleRef);
                return c.hWndFound;
            }
        }

        /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.ShowPanels"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether panels should be shown.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),        
        DefaultValue(false),
        SRDescription(SR.StatusBarShowPanelsDescr)        
        ]
        public bool ShowPanels {
            get {
                return showPanels;
            }
            set {
                if (showPanels != value) {
                    showPanels = value;

                    layoutDirty = true;
                    if (IsHandleCreated) {
                        int bShowPanels = (!showPanels) ? 1 : 0;

                        SendMessage(NativeMethods.SB_SIMPLE, bShowPanels, 0);

                        if (showPanels) {
                            PerformLayout();
                            RealizePanels();
                        }
                        else if (tooltips != null) {
                            for (int i=0; i<panels.Count; i++) {
                                tooltips.SetTool(panels[i], null);
                            }
                        }

                        SetSimpleText(simpleText);
                    }
                }
            }
        }

        /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.SizingGrip"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether a sizing grip
        ///       will be rendered on the corner of the <see cref='System.Windows.Forms.StatusBar'/>
        ///       control.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        DefaultValue(true),
        SRDescription(SR.StatusBarSizingGripDescr)
        ]
        public bool SizingGrip {
            get {
                return sizeGrip;
            }
            set {
                if (value != sizeGrip) {
                    sizeGrip = value;
                    RecreateHandle();
                }
            }
        }

        /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.TabStop"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the user will be able to tab to the
        ///    <see cref='System.Windows.Forms.StatusBar'/> .
        ///    </para>
        /// </devdoc>
        [DefaultValue(false)]
        new public bool TabStop {
            get {
                return base.TabStop;
            }
            set {
                base.TabStop = value;
            }
        }

        /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.DrawItem"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Occurs when a visual aspect of an owner-drawn status bar changes.
        ///    </para>
        /// </devdoc>
        [SRCategory(SR.CatBehavior), SRDescription(SR.StatusBarDrawItem)]
        public event StatusBarDrawItemEventHandler DrawItem {
            add {
                Events.AddHandler(EVENT_SBDRAWITEM, value);
            }
            remove {
                Events.RemoveHandler(EVENT_SBDRAWITEM, value);
            }
        }        
        
        /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.PanelClick"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Occurs when a panel on the status bar is clicked.
        ///    </para>
        /// </devdoc>
        [SRCategory(SR.CatMouse), SRDescription(SR.StatusBarOnPanelClickDescr)]
        public event StatusBarPanelClickEventHandler PanelClick {
            add {
                Events.AddHandler(EVENT_PANELCLICK, value);
            }
            remove {
                Events.RemoveHandler(EVENT_PANELCLICK, value);
            }
        } 

        /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.OnPaint"]/*' />
        /// <devdoc>
        ///     StatusBar Onpaint.
        /// </devdoc>
        /// <internalonly/><hideinheritance/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event PaintEventHandler Paint {
            add {
                base.Paint += value;
            }
            remove {
                base.Paint -= value;
            }
        }

        /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.ArePanelsRealized"]/*' />
        /// <devdoc>
        ///     Tells whether the panels have been realized.
        /// </devdoc>
        /// <internalonly/>
        internal bool ArePanelsRealized() {
            return this.showPanels && IsHandleCreated;
        }

        /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.DirtyLayout"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        internal void DirtyLayout() {
            layoutDirty = true;
        }

        /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.ApplyPanelWidths"]/*' />
        /// <devdoc>
        ///     Makes the panel according to the sizes in the panel list.
        /// </devdoc>
        /// <internalonly/>
        private void ApplyPanelWidths() {
            // This forces handle creation every time any time the StatusBar
            // has to be re-laidout.
            //
            if (!IsHandleCreated)
                return;

            StatusBarPanel  panel = null;
            int length = this.panels.Count;

            if (length == 0) {
                Size sz = Size;
                int[] offsets = new int[1];
                offsets[0] = sz.Width;
                if (sizeGrip) {
                    offsets[0] -= SIZEGRIP_WIDTH;
                }
                UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.SB_SETPARTS, 1, offsets);
                SendMessage(NativeMethods.SB_SETICON, 0, IntPtr.Zero);

                return;
            }

            int[] offsets2 = new int[length];
            int currentOffset = 0;
            for (int i = 0; i < length; i++) {
                panel = (StatusBarPanel) this.panels[i];
                currentOffset += panel.Width;
                offsets2[i] = currentOffset;
                panel.right = offsets2[i];
            }
            UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.SB_SETPARTS, length, offsets2);

            // Tooltip setup...
            //
            for (int i=0; i<length; i++) {
                panel = (StatusBarPanel) this.panels[i];
                UpdateTooltip(panel);
            }

            layoutDirty = false;
        }

        /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.CreateHandle"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        protected override void CreateHandle() {
            if (!RecreatingHandle) {
                NativeMethods.INITCOMMONCONTROLSEX icc = new NativeMethods.INITCOMMONCONTROLSEX();
                icc.dwICC = NativeMethods.ICC_BAR_CLASSES;
                SafeNativeMethods.InitCommonControlsEx(icc);
            }
            base.CreateHandle();
        }
        
        /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.Dispose"]/*' />
        /// <devdoc>
        ///     Disposes this control
        /// </devdoc>
        protected override void Dispose(bool disposing) {
            if (disposing) {
                if (panelsCollection != null) {
                    StatusBarPanel[] panelCopy = new StatusBarPanel[panelsCollection.Count];
                    ((ICollection)panelsCollection).CopyTo(panelCopy, 0);
                    panelsCollection.Clear();

                    foreach(StatusBarPanel p in panelCopy) {
                        p.Dispose();
                    }
                }
            }
            base.Dispose(disposing);
        }
        
        /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.ForcePanelUpdate"]/*' />
        /// <devdoc>
        ///     Forces the panels to be updated, location, repainting, etc.
        /// </devdoc>
        /// <internalonly/>
        private void ForcePanelUpdate() {
            if (ArePanelsRealized()) {
                layoutDirty = true;
                SetPanelContentsWidths(true);
                PerformLayout();
                RealizePanels();
            }
        }

        /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.OnHandleCreated"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Windows.Forms.Control.CreateHandle'/>
        ///       event.
        ///    </para>
        /// </devdoc>
        protected override void OnHandleCreated(EventArgs e) {
            base.OnHandleCreated(e);
            tooltips = new ControlToolTip(this);
            if (!this.showPanels) {
                SendMessage(NativeMethods.SB_SIMPLE, 1, 0);
                SetSimpleText(simpleText);
            }
            else {
                ForcePanelUpdate();
            }
        }

        /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.OnHandleDestroyed"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Windows.Forms.StatusBar.OnHandleDestroyed'/> event.
        ///    </para>
        /// </devdoc>
        protected override void OnHandleDestroyed(EventArgs e) {
            base.OnHandleDestroyed(e);
            if (tooltips != null) {
                tooltips.Dispose();
                tooltips = null;
            }
        }


        /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.EnumChildren"]/*' />
        /// <devdoc>
        /// </devdoc>
        private sealed class EnumChildren {

            public IntPtr hWndFound = IntPtr.Zero;

            private StatusBar peer;

            public EnumChildren( StatusBar peer ) {
                if (peer == null)
                    throw new ArgumentException("peer");
                this.peer = peer;
            }

            public bool Callback(IntPtr hWnd, IntPtr lparam) {
                if (UnsafeNativeMethods.GetParent(new HandleRef(null, hWnd)) == peer.Handle) {
                    hWndFound = hWnd;
                    return false;
                }

                return true;
            }
        }


        /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.OnMouseDown"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Windows.Forms.StatusBar.OnMouseDown'/> event.
        ///    </para>
        /// </devdoc>
        protected override void OnMouseDown(MouseEventArgs e) {
            lastClick.X = e.X;
            lastClick.Y = e.Y;
            base.OnMouseDown(e);
        }

        /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.OnPanelClick"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Windows.Forms.StatusBar.OnPanelClick'/> event.
        ///    </para>
        /// </devdoc>
        protected virtual void OnPanelClick(StatusBarPanelClickEventArgs e) {
            StatusBarPanelClickEventHandler handler = (StatusBarPanelClickEventHandler)Events[EVENT_PANELCLICK];
            if (handler != null) handler(this,e);
        }

        /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.OnLayout"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raises the Layout event.
        ///    </para>
        /// </devdoc>
        protected override void OnLayout(LayoutEventArgs levent) {
            if (this.showPanels) {
                LayoutPanels();
                if (IsHandleCreated && panelsRealized != panels.Count) {
                    RealizePanels();
                }
            }
            base.OnLayout(levent);
        }

        /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.RealizePanels"]/*' />
        /// <devdoc>
        ///     This function sets up all the panel on the status bar according to
        ///     the internal this.panels List.
        /// </devdoc>
        /// <internalonly/>
        internal void RealizePanels() {
            StatusBarPanel  panel = null;
            int             length = this.panels.Count;
            int             old = panelsRealized;

            panelsRealized = 0;

            if (length == 0) {
                SendMessage(NativeMethods.SB_SETTEXT, 0, "");
            }

            int i;
            for (i = 0; i < length; i++) {
                panel = (StatusBarPanel) this.panels[i];
                try {
                    panel.Realize();
                    panelsRealized++;
                }
                catch (Exception) {
                }
            }
            for (; i<old; i++) {
                SendMessage(NativeMethods.SB_SETTEXT, 0, null);
            }
        }

        /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.RemoveAllPanelsWithoutUpdate"]/*' />
        /// <devdoc>
        ///     Remove the internal list of panels without updating the control.
        /// </devdoc>
        /// <internalonly/>
        internal void RemoveAllPanelsWithoutUpdate() {
            int size = this.panels.Count;
            // remove the parent reference
            for (int i = 0; i < size; i++) {
                StatusBarPanel sbp = (StatusBarPanel) this.panels[i];
                sbp.parent = null;
            }
            
            this.panels.Clear();
            if (this.showPanels == true) {
                ApplyPanelWidths();
                ForcePanelUpdate();
            }
            
        }

        /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.SetPanelContentsWidths"]/*' />
        /// <devdoc>
        ///     Sets the widths of any panels that have the
        ///     StatusBarPanelAutoSize.CONTENTS property set.
        /// </devdoc>
        /// <internalonly/>
        internal void SetPanelContentsWidths(bool newPanels) {
            int size = panels.Count;
            bool changed = false;
            for (int i = 0; i < size; i++) {
                StatusBarPanel sbp = (StatusBarPanel) panels[i];
                if (sbp.autoSize == StatusBarPanelAutoSize.Contents) {
                    int newWidth = sbp.GetContentsWidth(newPanels);
                    if (sbp.width != newWidth) {
                        sbp.width = newWidth;
                        changed = true;
                    }
                }
            }
            if (changed) {
                DirtyLayout();
                PerformLayout();
            }
        }

        private void SetSimpleText(string simpleText) {
            if (!showPanels && IsHandleCreated) {
            
                int wparam = SIMPLE_INDEX + NativeMethods.SBT_NOBORDERS;
                if (RightToLeft == RightToLeft.Yes) {
                    wparam |= NativeMethods.SBT_RTLREADING;
                }
            
                SendMessage(NativeMethods.SB_SETTEXT, wparam, simpleText);
            }
        }

        /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.LayoutPanels"]/*' />
        /// <devdoc>
        ///     Sizes the the panels appropriately.  It looks at the SPRING AutoSize
        ///     property.
        /// </devdoc>
        /// <internalonly/>
        private void LayoutPanels() {
            StatusBarPanel      panel = null;
            int                 barPanelWidth = 0;
            int                 springNum = 0;
            StatusBarPanel[]    pArray = new StatusBarPanel[this.panels.Count];
            bool             changed = false;

            for (int i = 0; i < pArray.Length; i++) {
                panel = (StatusBarPanel) this.panels[i];
                if (panel.autoSize == StatusBarPanelAutoSize.Spring) {
                    pArray[springNum] = panel;
                    springNum++;
                }
                else
                    barPanelWidth += panel.Width;
            }


            if (springNum > 0) {
                Rectangle rect = Bounds;
                int springPanelsLeft = springNum;
                int leftoverWidth = rect.Width - barPanelWidth;
                if (sizeGrip) {
                    leftoverWidth -= SIZEGRIP_WIDTH;
                }
                int copyOfLeftoverWidth = unchecked((int)0x80000000);
                while (springPanelsLeft > 0) {

                    int widthOfSpringPanel = (leftoverWidth) / springPanelsLeft;
                    if (leftoverWidth == copyOfLeftoverWidth)
                        break;
                    copyOfLeftoverWidth = leftoverWidth;

                    for (int i = 0; i < springNum; i++) {
                        panel = pArray[i];
                        if (panel == null)
                            continue;

                        if (widthOfSpringPanel < panel.minWidth) {
                            if (panel.Width != panel.minWidth) {
                                changed = true;
                            }
                            panel.Width = panel.minWidth;
                            pArray[i] = null;
                            springPanelsLeft --;
                            leftoverWidth -= panel.minWidth;
                        }
                        else {
                            if (panel.Width != widthOfSpringPanel) {
                                changed = true;
                            }
                            panel.Width = widthOfSpringPanel;
                        }
                    }
                }
            }

            if (changed || layoutDirty) {
                ApplyPanelWidths();
            }
        }

        /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.OnDrawItem"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Windows.Forms.StatusBar.OnDrawItem'/>
        ///       event.
        ///    </para>
        /// </devdoc>
        protected virtual void OnDrawItem(StatusBarDrawItemEventArgs sbdievent) {
            StatusBarDrawItemEventHandler handler = (StatusBarDrawItemEventHandler)Events[EVENT_SBDRAWITEM];
            if (handler != null) handler(this,sbdievent);
        }

        /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.OnResize"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Windows.Forms.StatusBar.OnResize'/>
        ///       event.
        ///    </para>
        /// </devdoc>
        protected override void OnResize(EventArgs e) {
            Invalidate();
            base.OnResize(e);
        }

        /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.ToString"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns a string representation for this control.
        ///    </para>
        /// </devdoc>
        public override string ToString() {

            string s = base.ToString();
            if (Panels != null) {
                s += ", Panels.Count: " + Panels.Count.ToString();
                if (Panels.Count > 0)
                    s += ", Panels[0]: " + Panels[0].ToString();
            }
            return s;
        }

        internal void UpdateTooltip(StatusBarPanel panel) {
            if (tooltips == null && IsHandleCreated) {
                return;
            }

            if (panel.ToolTipText.Length > 0) {
                int border = SystemInformation.Border3DSize.Width;
                ControlToolTip.Tool t = tooltips.GetTool(panel);
                if (t == null) {
                    t = new ControlToolTip.Tool();
                }
                t.text = panel.ToolTipText;
                t.rect = new Rectangle(panel.right-panel.Width + border, 0, panel.Width - border, Height);
                tooltips.SetTool(panel, t);
            }
            else {
                tooltips.SetTool(panel, null);
            }
        }

        private void UpdatePanelIndex() {
            int length = panels.Count;
            for (int i=0; i<length; i++) {
                ((StatusBarPanel)panels[i]).index = i;
            }
        }

        /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.WmDrawItem"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///     Processes messages for ownerdraw panels.
        /// </devdoc>
        private void WmDrawItem(ref Message m) {
            NativeMethods.DRAWITEMSTRUCT dis = (NativeMethods.DRAWITEMSTRUCT)m.GetLParam(typeof(NativeMethods.DRAWITEMSTRUCT));

            int length = this.panels.Count;
            if (dis.itemID < 0 || dis.itemID >= length)
                Debug.Fail("OwnerDraw item out of range");

            StatusBarPanel panel = (StatusBarPanel)
                                   this.panels[dis.itemID];

            Graphics g = Graphics.FromHdcInternal(dis.hDC);
            Rectangle r = Rectangle.FromLTRB(dis.rcItem.left, dis.rcItem.top, dis.rcItem.right, dis.rcItem.bottom);

            //The itemstate is not defined for a statusbar control
            OnDrawItem(new StatusBarDrawItemEventArgs(g, Font, r, dis.itemID, DrawItemState.None, panel, this.ForeColor, this.BackColor));
            g.Dispose();
        }

        /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.WmNotifyNMClick"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        private void WmNotifyNMClick(NativeMethods.NMHDR note) {
        
            if (!showPanels) {
                return;
            }
        
            int size = panels.Count;
            int currentOffset = 0;
            int index = -1;
            for (int i = 0; i < size; i++) {
                StatusBarPanel panel = (StatusBarPanel) panels[i];
                currentOffset += panel.Width;
                if (lastClick.X < currentOffset) {
                    // this is where the mouse was clicked.
                    index = i;
                    break;
                }
            }
            if (index != -1) {
                MouseButtons button = MouseButtons.Left;
                int clicks = 0;
                switch (note.code) {
                    case NativeMethods.NM_CLICK:
                        button = MouseButtons.Left;
                        clicks = 1;
                        break;
                    case NativeMethods.NM_RCLICK:
                        button = MouseButtons.Right;
                        clicks = 1;
                        break;
                    case NativeMethods.NM_DBLCLK:
                        button = MouseButtons.Left;
                        clicks = 2;
                        break;
                    case NativeMethods.NM_RDBLCLK:
                        button = MouseButtons.Right;
                        clicks = 2;
                        break;
                }

                Point pt = lastClick;
                StatusBarPanel panel = (StatusBarPanel) panels[index];
                
                StatusBarPanelClickEventArgs sbpce = new StatusBarPanelClickEventArgs(panel,
                                                                                      button, clicks, pt.X, pt.Y);
                OnPanelClick(sbpce);
            }
        }

        private void WmNCHitTest(ref Message m) {
            int x = NativeMethods.Util.LOWORD(m.LParam);
            Rectangle bounds = Bounds;
            bool callSuper = true;

            // The default implementation of the statusbar
            //       : will let you size the form when it is docked on the bottom,
            //       : but when it is anywhere else, the statusbar will be resized.
            //       : to prevent that we provide a little bit a sanity to only
            //       : allow resizing, when it would resize the form.
            //
            if (x > bounds.X + bounds.Width - SIZEGRIP_WIDTH) {
                Control parent = ParentInternal;
                if (parent != null && parent is Form) {
                    FormBorderStyle bs = ((Form)parent).FormBorderStyle;

                    if (bs != FormBorderStyle.Sizable
                        && bs != FormBorderStyle.SizableToolWindow) {
                        callSuper = false;
                    }

                    if (!((Form)parent).TopLevel
                        || Dock != DockStyle.Bottom) {

                        callSuper = false;
                    }

                    if (callSuper) {
                        int c = parent.Controls.Count;
                        for (int i=0; i<c; i++) {
                            Control ctl = parent.Controls[i];
                            if (ctl != this && ctl.Dock == DockStyle.Bottom) {
                                if (ctl.Top > Top) {
                                    callSuper = false;
                                    break;
                                }
                            }
                        }
                    }
                }
                else {
                    callSuper = false;
                }
            }

            if (callSuper) {
                base.WndProc(ref m);
            }
            else {
                m.Result = (IntPtr)NativeMethods.HTCLIENT;
            }
        }

        /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.WndProc"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Base wndProc. All messages are sent to wndProc after getting filtered through
        ///       the preProcessMessage function. Inheriting controls should call base.wndProc
        ///       for any messages that they don't handle.
        ///    </para>
        /// </devdoc>
        [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        protected override void WndProc(ref Message m) {
            switch (m.Msg) {
                case NativeMethods.WM_NCHITTEST:
                    WmNCHitTest(ref m);
                    break;
                case NativeMethods.WM_REFLECT + NativeMethods.WM_DRAWITEM:
                    WmDrawItem(ref m);
                    break;
                case NativeMethods.WM_NOTIFY:
                case NativeMethods.WM_NOTIFY + NativeMethods.WM_REFLECT:
                    NativeMethods.NMHDR note = (NativeMethods.NMHDR)m.GetLParam(typeof(NativeMethods.NMHDR));
                    switch (note.code) {
                        case NativeMethods.NM_CLICK:
                        case NativeMethods.NM_RCLICK:
                        case NativeMethods.NM_DBLCLK:
                        case NativeMethods.NM_RDBLCLK:
                            WmNotifyNMClick(note);
                            break;
                    }
                    break;

                default:
                    base.WndProc(ref m);
                    break;
            }
        }

        /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.StatusBarPanelCollection"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The collection of StatusBarPanels that the StatusBar manages.
        ///       event.
        ///    </para>
        /// </devdoc>
        public class StatusBarPanelCollection : IList {
            private StatusBar owner;

            /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.StatusBarPanelCollection.StatusBarPanelCollection"]/*' />
            /// <devdoc>
            ///    <para>
            ///       Constructor for the StatusBarPanelCollection class
            ///    </para>
            /// </devdoc>
            public StatusBarPanelCollection(StatusBar owner) {
                this.owner = owner;
            }
            
            /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.StatusBarPanelCollection.this"]/*' />
            /// <devdoc>
            ///       This method will return an individual StatusBarPanel with the appropriate index.
            /// </devdoc>
            public virtual StatusBarPanel this[int index] {
                get {
                    return(StatusBarPanel)owner.panels[index];
                }
                set {
                    
                    if (value == null)
                        throw new ArgumentNullException("StatusBarPanel");

                    owner.layoutDirty = true;
                    
                    if (value.parent != null) {
                        throw new ArgumentException(SR.GetString(SR.ObjectHasParent), "value");
                    }

                    int length = owner.panels.Count;

                    if (index < 0|| index >= length)
                        throw new ArgumentOutOfRangeException(SR.GetString(SR.InvalidArgument,
                                                                  "index",
                                                                  index.ToString()));

                    StatusBarPanel oldPanel = (StatusBarPanel) owner.panels[index];
                    oldPanel.parent = null;
                    value.parent = owner;
                    if (value.autoSize == StatusBarPanelAutoSize.Contents) {
                        value.Width = value.GetContentsWidth(true);
                    }
                    owner.panels[index] = value;
                    value.index = index;

                    if (owner.ArePanelsRealized()) {
                        owner.PerformLayout();
                        value.Realize();
                    }
                }
            }
            
            /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBarPanelCollection.IList.this"]/*' />
            /// <internalonly/>
            object IList.this[int index] {  
                get {
                    return this[index];
                }
                set {
                    if (value is StatusBarPanel) {
                        this[index] = (StatusBarPanel)value;
                    }
                    else {
                        throw new ArgumentException("value");
                    }
                }
            }

            /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.StatusBarPanelCollection.Count"]/*' />
            /// <devdoc>
            ///    <para>
            ///       Returns an integer representing the number of StatusBarPanels
            ///       in this collection.
            ///    </para>
            /// </devdoc>
            [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
            public int Count {
                get {
                    return owner.panels.Count;
                }
            }

            /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBarPanelCollection.ICollection.SyncRoot"]/*' />
            /// <internalonly/>
            object ICollection.SyncRoot {
                get {
                    return this;
                }
            }

            /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBarPanelCollection.ICollection.IsSynchronized"]/*' />
            /// <internalonly/>
            bool ICollection.IsSynchronized {
                get {
                    return false;
                }
            }
            
            /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBarPanelCollection.IList.IsFixedSize"]/*' />
            /// <internalonly/>
            bool IList.IsFixedSize {
                get {
                    return false;
                }
            }
           
            /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.StatusBarPanelCollection.IsReadOnly"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public bool IsReadOnly {
                get {
                    return false;
                }
            }

            /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.StatusBarPanelCollection.Add"]/*' />
            /// <devdoc>
            ///    <para>
            ///       Adds a StatusBarPanel to the collection.
            ///    </para>
            /// </devdoc>
            public virtual StatusBarPanel Add(string text) {
                StatusBarPanel panel = new StatusBarPanel();
                panel.Text = text;
                Add(panel);
                return panel;
            }

            /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.StatusBarPanelCollection.Add1"]/*' />
            /// <devdoc>
            ///    <para>
            ///       Adds a StatusBarPanel to the collection.
            ///    </para>
            /// </devdoc>
            public virtual int Add(StatusBarPanel value) {
                int index = owner.panels.Count;
                Insert(index, value);
                return index;
            }
            
            /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBarPanelCollection.IList.Add"]/*' />
            /// <internalonly/>
            int IList.Add(object value) {
                if (value is StatusBarPanel) {
                    return Add((StatusBarPanel)value);
                }
                else {
                    throw new ArgumentException("value");
                }
            }
            
            /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.StatusBarPanelCollection.AddRange"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public virtual void AddRange(StatusBarPanel[] panels) {
                if (panels == null) {
                    throw new ArgumentNullException("panels");
                }
                foreach(StatusBarPanel panel in panels) {
                    Add(panel);
                }
            }
            
            /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.StatusBarPanelCollection.Contains"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public bool Contains(StatusBarPanel panel) {
                return IndexOf(panel) != -1;
            }
        
            /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBarPanelCollection.IList.Contains"]/*' />
            /// <internalonly/>
            bool IList.Contains(object panel) {
                if (panel is StatusBarPanel) {
                    return Contains((StatusBarPanel)panel);
                }
                else {  
                    return false;
                }
            }
            
            /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.StatusBarPanelCollection.IndexOf"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public int IndexOf(StatusBarPanel panel) {
                for(int index=0; index < Count; ++index) {
                    if (this[index] == panel) {
                        return index;
                    } 
                }
                return -1;
            }
            
            /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBarPanelCollection.IList.IndexOf"]/*' />
            /// <internalonly/>
            int IList.IndexOf(object panel) {
                if (panel is StatusBarPanel) {
                    return IndexOf((StatusBarPanel)panel);
                }
                else {  
                    return -1;
                }
            }

            /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.StatusBarPanelCollection.Insert"]/*' />
            /// <devdoc>
            ///    <para>
            ///       Inserts a StatusBarPanel in the collection.
            ///    </para>
            /// </devdoc>
            public virtual void Insert(int index, StatusBarPanel value) {

                //check for the value not to be null
                if (value == null) 
                    throw new ArgumentNullException("value");
                //end check


                owner.layoutDirty = true;
                if (value.parent != null)
                    throw new ArgumentException(SR.GetString(SR.ObjectHasParent), "value");

                int length = owner.panels.Count;

                if (index < 0 || index > length)
                    throw new ArgumentOutOfRangeException(SR.GetString(SR.InvalidArgument,
                                                              "index",
                                                              index.ToString()));
                value.parent = owner;

                switch (value.autoSize) {
                    case StatusBarPanelAutoSize.None:
                    case StatusBarPanelAutoSize.Spring:
                        break;
                    case StatusBarPanelAutoSize.Contents:
                        value.Width = value.GetContentsWidth(true);
                        break;
                }

                owner.panels.Insert(index, value);
                owner.UpdatePanelIndex();

                owner.ForcePanelUpdate();
            }
            
            /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBarPanelCollection.IList.Insert"]/*' />
            /// <internalonly/>
            void IList.Insert(int index, object value) {
                if (value is StatusBarPanel) {
                    Insert(index, (StatusBarPanel)value);
                }
                else {
                    throw new ArgumentException("value");
                }
            }

            /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.StatusBarPanelCollection.Clear"]/*' />
            /// <devdoc>
            ///    <para>
            ///       Removes all the StatusBarPanels in the collection.
            ///    </para>
            /// </devdoc>
            public virtual void Clear() {
                owner.RemoveAllPanelsWithoutUpdate();
                owner.PerformLayout();

            }

            /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.StatusBarPanelCollection.Remove"]/*' />
            /// <devdoc>
            ///    <para>
            ///       Removes an individual StatusBarPanel in the collection.
            ///    </para>
            /// </devdoc>
            public virtual void Remove(StatusBarPanel value) {
                
                //check for the value not to be null
                if (value == null) 
                    throw new ArgumentNullException("StatusBarPanel");
                //end check

                if (value.parent != owner) {
                    return;
                }
                RemoveAt(value.index);
            }
            
            /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBarPanelCollection.IList.Remove"]/*' />
            /// <internalonly/>
            void IList.Remove(object value) {
                if (value is StatusBarPanel) {
                    Remove((StatusBarPanel)value);
                }                
            }


            /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.StatusBarPanelCollection.RemoveAt"]/*' />
            /// <devdoc>
            ///    <para>
            ///       Removes an individual StatusBarPanel in the collection at the given index.
            ///    </para>
            /// </devdoc>
            public virtual void RemoveAt(int index) {
                int length = Count;
                if (index < 0 || index >= length)
                    throw new ArgumentOutOfRangeException(SR.GetString(SR.InvalidArgument,
                                                              "index",
                                                              index.ToString()));

                owner.panels.RemoveAt(index);

                // V#41207 - ChrisAn, 4/1/1998 - We must reindex the panels after a removal...
                owner.UpdatePanelIndex();
                owner.ForcePanelUpdate();
            }

            /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBarPanelCollection.ICollection.CopyTo"]/*' />
            /// <internalonly/>
            void ICollection.CopyTo(Array dest, int index) {
                owner.panels.CopyTo(dest, index);
            }
            
            /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.StatusBarPanelCollection.GetEnumerator"]/*' />
            /// <devdoc>
            ///    <para>
            ///       Returns the Enumerator for this collection.
            ///    </para>
            /// </devdoc>
            public IEnumerator GetEnumerator() {
                if (owner.panels != null) {
                    return owner.panels.GetEnumerator();
                }
                else {
                    return new StatusBarPanel[0].GetEnumerator();
                }
            }
        }
        /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.ControlToolTip"]/*' />
        /// <devdoc>
        ///     This is a tooltip control that provides tips for a single
        ///     control. Each "tool" region is defined by a rectangle and
        ///     the string that should be displayed. This implementation
        ///     is based on System.Windows.Forms.ToolTip, but this control
        ///     is lighter weight and provides less functionality... however
        ///     this control binds to rectangular regions, instead of
        ///     full controls.
        /// </devdoc>
        [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        private class ControlToolTip {

            /// <include file='doc\StatusBar.uex' path='docs/doc[@for="Tool"]/*' />
            public class Tool {
                /// <include file='doc\StatusBar.uex' path='docs/doc[@for="Tool.rect"]/*' />
                public Rectangle rect = Rectangle.Empty;
                /// <include file='doc\StatusBar.uex' path='docs/doc[@for="Tool.text;"]/*' />
                public string text;
                internal IntPtr id = new IntPtr(-1);
            }

            private Hashtable           tools = new Hashtable();
            private ToolTipNativeWindow window = null;
            private Control             parent = null;
            private int                 nextId = 0;

            /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.ControlToolTip.ControlToolTip"]/*' />
            /// <devdoc>
            ///    Creates a new ControlToolTip.
            /// </devdoc>
            public ControlToolTip(Control parent) {
                window = new ToolTipNativeWindow(this);
                this.parent = parent;
            }

            /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.ControlToolTip.CreateParams"]/*' />
            /// <devdoc>
            ///    Returns the createParams to create the window.
            /// </devdoc>
            protected CreateParams CreateParams {
                get {
                    NativeMethods.INITCOMMONCONTROLSEX icc = new NativeMethods.INITCOMMONCONTROLSEX();
                    icc.dwICC = NativeMethods.ICC_TAB_CLASSES;
                    SafeNativeMethods.InitCommonControlsEx(icc);
                    CreateParams cp = new CreateParams();
                    cp.Parent = IntPtr.Zero;
                    cp.ClassName = NativeMethods.TOOLTIPS_CLASS;
                    cp.Style |= NativeMethods.TTS_ALWAYSTIP;
                    cp.ExStyle = 0;
                    cp.Caption = null;
                    return cp;
                }
            }

            /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.ControlToolTip.Handle"]/*' />
            /// <devdoc>
            /// </devdoc>
            public IntPtr Handle {
                get {
                    if (window.Handle == IntPtr.Zero) {
                        CreateHandle();
                    }
                    return window.Handle;
                }
            }

            private bool IsHandleCreated {
                get { return window.Handle != IntPtr.Zero;}
            }

            private void AssignId(Tool tool) {
                tool.id = (IntPtr)nextId;
                nextId++;
            }

            /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.ControlToolTip.SetTool"]/*' />
            /// <devdoc>
            ///    Sets the tool for the specified key. Keep in mind
            ///    that as soon as setTool is called, the handle for
            ///    the ControlToolTip is created, and the handle for
            ///    the parent control is also created. If the parent
            ///    handle is recreated in the future, all tools must
            ///    be re-added. The old tool for the specified key
            ///    will be removed. Passing null in for the
            ///    tool parameter will result in the tool
            ///    region being removed.
            /// </devdoc>
            public void SetTool(object key, Tool tool) {
                bool remove = false;
                bool add = false;
                bool update = false;

                Tool toRemove = null;
                if (tools.ContainsKey(key)) {
                    toRemove = (Tool)tools[key];
                }

                if (toRemove != null) {
                    remove = true;
                }
                if (tool != null) {
                    add = true;
                }
                if (tool != null && toRemove != null
                    && tool.id == toRemove.id) {
                    update = true;
                }

                if (update) {
                    UpdateTool(tool);
                }
                else {
                    if (remove) {
                        RemoveTool(toRemove);
                    }
                    if (add) {
                        AddTool(tool);
                    }
                }
                tools[key] = tool;
            }

            /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.ControlToolTip.GetTool"]/*' />
            /// <devdoc>
            ///    Returns the tool associated with the specified key,
            ///    or null if there is no area.
            /// </devdoc>
            public Tool GetTool(object key) {
                return(Tool)tools[key];
            }


            private void AddTool(Tool tool) {
                if (tool != null && tool.text != null && tool.text.Length > 0) {
                    int ret = (int)UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.TTM_ADDTOOL, 0, GetTOOLINFO(tool));
                    if (ret == 0) {
                        throw new InvalidOperationException(SR.GetString(SR.StatusBarAddFailed));
                    }
                }
            }
            private void RemoveTool(Tool tool) {
                if (tool != null && tool.text != null && tool.text.Length > 0 && (int)tool.id >= 0) {
                    UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.TTM_DELTOOL, 0, GetMinTOOLINFO(tool));
                }
            }
            private void UpdateTool(Tool tool) {
                if (tool != null && tool.text != null && tool.text.Length > 0 && (int)tool.id >= 0) {
                    UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.TTM_SETTOOLINFO, 0, GetTOOLINFO(tool));
                }
            }


            /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.ControlToolTip.CreateHandle"]/*' />
            /// <devdoc>
            ///    Creates the handle for the control.
            /// </devdoc>
            protected void CreateHandle() {
                if (IsHandleCreated) {
                    return;
                }

                window.CreateHandle(CreateParams);
                SafeNativeMethods.SetWindowPos(new HandleRef(this, Handle), NativeMethods.HWND_TOPMOST,
                                     0, 0, 0, 0,
                                     NativeMethods.SWP_NOMOVE | NativeMethods.SWP_NOSIZE |
                                     NativeMethods.SWP_NOACTIVATE);

                // Setting the max width has the added benefit of enabling multiline
                // tool tips!
                //
                UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.TTM_SETMAXTIPWIDTH, 0, SystemInformation.MaxWindowTrackSize.Width);
            }

            /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.ControlToolTip.DestroyHandle"]/*' />
            /// <devdoc>
            ///    Destroys the handle for this control.
            /// </devdoc>
            protected void DestroyHandle() {
                if (IsHandleCreated) {
                    window.DestroyHandle();
                    tools.Clear();
                }
            }

            /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.ControlToolTip.Dispose"]/*' />
            /// <devdoc>
            ///    Disposes of the component.  Call dispose when the component is no longer needed.
            ///    This method removes the component from its container (if the component has a site)
            ///    and triggers the dispose event.
            /// </devdoc>
            public void Dispose() {
                DestroyHandle();
            }

            /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.ControlToolTip.GetMinTOOLINFO"]/*' />
            /// <devdoc>
            ///     Returns a new instance of the TOOLINFO_T structure with the minimum
            ///     required data to uniquely identify a region. This is used primarily
            ///     for delete operations. NOTE: This cannot force the creation of a handle.
            /// </devdoc>
            private NativeMethods.TOOLINFO_T GetMinTOOLINFO(Tool tool) {
                NativeMethods.TOOLINFO_T ti = new NativeMethods.TOOLINFO_T();
                ti.cbSize = Marshal.SizeOf(typeof(NativeMethods.TOOLINFO_T));
                ti.hwnd = parent.Handle;
                if ((int)tool.id < 0) {
                    AssignId(tool);
                }
                ti.uId = tool.id;
                return ti;
            }

            /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.ControlToolTip.GetTOOLINFO"]/*' />
            /// <devdoc>
            ///     Returns a detailed TOOLINFO_T structure that represents the specified
            ///     region. NOTE: This may force the creation of a handle.
            /// </devdoc>
            private NativeMethods.TOOLINFO_T GetTOOLINFO(Tool tool) {
                NativeMethods.TOOLINFO_T ti = GetMinTOOLINFO(tool);
                ti.cbSize = Marshal.SizeOf(typeof(NativeMethods.TOOLINFO_T));
                ti.uFlags |= NativeMethods.TTF_TRANSPARENT | NativeMethods.TTF_SUBCLASS;
                
                // RightToLeft reading order
                //
                Control richParent = parent;
                if (richParent != null && richParent.RightToLeft == RightToLeft.Yes) {
                    ti.uFlags |= NativeMethods.TTF_RTLREADING;
                }
                
                ti.lpszText = tool.text;
                ti.rect = NativeMethods.RECT.FromXYWH(tool.rect.X, tool.rect.Y, tool.rect.Width, tool.rect.Height);
                return ti;
            }


            /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.ControlToolTip.Finalize"]/*' />
            /// <devdoc>
            /// </devdoc>
            ~ControlToolTip() {
                DestroyHandle();
            }

            /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.ControlToolTip.WndProc"]/*' />
            /// <devdoc>
            ///    WNDPROC
            /// </devdoc>
            protected void WndProc(ref Message msg) {
                switch (msg.Msg) {
                    case NativeMethods.WM_SETFOCUS:
                        // bug 120872, the COMCTL StatusBar passes WM_SETFOCUS on to the DefWndProc, so
                        // it will take keyboard focus.  We don't want it doing this, so we eat
                        // the message.
                        //
                        return;
                    default:
                        window.DefWndProc(ref msg);
                        break;
                }
            }

            /// <include file='doc\StatusBar.uex' path='docs/doc[@for="StatusBar.ControlToolTip.ToolTipNativeWindow"]/*' />
            /// <devdoc>
            /// </devdoc>
            private class ToolTipNativeWindow : NativeWindow {
                ControlToolTip control;

                internal ToolTipNativeWindow(ControlToolTip control) {
                    this.control = control;
                }

               
                protected override void WndProc(ref Message m) {
                    if (control != null) {
                        control.WndProc(ref m);
                    }
                }
            }
        }


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\statusbarpanel.cs ===
//------------------------------------------------------------------------------
// <copyright file="StatusBarPanel.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System;
    using System.Drawing;
    using System.Windows.Forms;
    using Microsoft.Win32;

    /// <include file='doc\StatusBarPanel.uex' path='docs/doc[@for="StatusBarPanel"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Stores the <see cref='System.Windows.Forms.StatusBar'/>
    ///       control panel's information.
    ///    </para>
    /// </devdoc>
    [
    DesignTimeVisible(false),
    DefaultProperty("Text")
    ]
    public class StatusBarPanel : Component, ISupportInitialize {

        private const int DEFAULTWIDTH = 100;
        private const int DEFAULTMINWIDTH = 10;
        private const int PANELTEXTINSET = 3;
        private const int PANELGAP = 2;

        private string          text          = "";
        private string          toolTipText   = "";
        private Icon            icon          = null;
        
        private HorizontalAlignment        alignment     = HorizontalAlignment.Left;
        private System.Windows.Forms.StatusBarPanelBorderStyle  borderStyle   = System.Windows.Forms.StatusBarPanelBorderStyle.Sunken;
        private StatusBarPanelStyle        style         = StatusBarPanelStyle.Text;

        // these are package scope so the parent can get at them.
        //
        internal StatusBar       parent        = null;
        internal int             width         = DEFAULTWIDTH;
        internal int             right         = 0;
        internal int             minWidth      = DEFAULTMINWIDTH;
        internal int             index         = 0;
        internal StatusBarPanelAutoSize autoSize = StatusBarPanelAutoSize.None;

        private bool initializing = false;                                      
                                      
        /// <include file='doc\StatusBarPanel.uex' path='docs/doc[@for="StatusBarPanel.StatusBarPanel"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new default instance of the <see cref='System.Windows.Forms.StatusBarPanel'/> class.
        ///    </para>
        /// </devdoc>
        public StatusBarPanel() {
        }

        /// <include file='doc\StatusBarPanel.uex' path='docs/doc[@for="StatusBarPanel.Alignment"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the <see cref='System.Windows.Forms.StatusBarPanel.Alignment'/>
        ///       property.
        ///       
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        DefaultValue(HorizontalAlignment.Left),
        Localizable(true),
        SRDescription(SR.StatusBarPanelAlignmentDescr)
        ]
        public HorizontalAlignment Alignment {
            get {
                return alignment;
            }

            set {
                if (!Enum.IsDefined(typeof(HorizontalAlignment), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(HorizontalAlignment));
                }
                if (alignment != value) {
                    alignment = value;
                    Realize();
                }
            }
        }

        /// <include file='doc\StatusBarPanel.uex' path='docs/doc[@for="StatusBarPanel.AutoSize"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the <see cref='System.Windows.Forms.StatusBarPanel.AutoSize'/>
        ///       property.
        ///       
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        DefaultValue(StatusBarPanelAutoSize.None),
        SRDescription(SR.StatusBarPanelAutoSizeDescr)
        ]
        public StatusBarPanelAutoSize AutoSize {
            get {
                return this.autoSize;
            }

            set {
                if (!Enum.IsDefined(typeof(StatusBarPanelAutoSize), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(StatusBarPanelAutoSize));
                }
                if (this.autoSize != value) {
                    this.autoSize = value;
                    UpdateSize();
                }
            }
        }

        /// <include file='doc\StatusBarPanel.uex' path='docs/doc[@for="StatusBarPanel.BorderStyle"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the <see cref='System.Windows.Forms.StatusBarPanel.BorderStyle'/>
        ///       
        ///       property.
        ///       
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        DefaultValue(System.Windows.Forms.StatusBarPanelBorderStyle.Sunken),
        DispId(NativeMethods.ActiveX.DISPID_BORDERSTYLE),
        SRDescription(SR.StatusBarPanelBorderStyleDescr)
        ]
        public StatusBarPanelBorderStyle BorderStyle {
            get {
                return borderStyle;
            }

            set {
                if (!Enum.IsDefined(typeof(StatusBarPanelBorderStyle), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(StatusBarPanelBorderStyle));
                }
                if (this.borderStyle != value) {
                    this.borderStyle = value;
                    Realize();
                    if (Created)
                        this.parent.Invalidate();
                }
            }
        }

        /// <include file='doc\StatusBarPanel.uex' path='docs/doc[@for="StatusBarPanel.Created"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        internal bool Created {
            get {
                return this.parent != null && this.parent.ArePanelsRealized();
            }
        }

        /// <include file='doc\StatusBarPanel.uex' path='docs/doc[@for="StatusBarPanel.Icon"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the <see cref='System.Windows.Forms.StatusBarPanel.Icon'/>
        ///       property.
        ///       
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        DefaultValue(null),
        Localizable(true),
        SRDescription(SR.StatusBarPanelIconDescr)
        ]
        public Icon Icon {
            get {
                // unfortunately we have no way of getting the icon from the control.
                return this.icon;
            }
            set {
                
                if (value != null && (((Icon)value).Height > SystemInformation.SmallIconSize.Height || ((Icon)value).Width > SystemInformation.SmallIconSize.Width)) {
                    this.icon  = new Icon(value, SystemInformation.SmallIconSize);
                }
                else {
                    this.icon = value;
                }
                
                if (Created) {
                    IntPtr handle = (this.icon == null) ? IntPtr.Zero : this.icon.Handle;
                    this.parent.SendMessage(NativeMethods.SB_SETICON, (IntPtr)GetIndex(), handle);
                    
                }
                UpdateSize();
                if (Created) {
                    this.parent.Invalidate();
                }
            }
        }

        /// <include file='doc\StatusBarPanel.uex' path='docs/doc[@for="StatusBarPanel.MinWidth"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the minimum width the <see cref='System.Windows.Forms.StatusBarPanel'/> can be within the <see cref='System.Windows.Forms.StatusBar'/>
        ///       control.
        ///       
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(DEFAULTMINWIDTH),
        Localizable(true),
        RefreshProperties(RefreshProperties.All),
        SRDescription(SR.StatusBarPanelMinWidthDescr)
        ]
        public int MinWidth {
            get {
                return this.minWidth;
            }
            set {
                if (value < 0) {
                    throw new ArgumentException(SR.GetString(SR.InvalidLowBoundArgumentEx,
                                                              "value", value.ToString(), "0"));
                }
                
                if (value != this.minWidth) {
                    this.minWidth = value;

                    UpdateSize();
                    if (this.minWidth > this.Width) {
                        Width = value;
                    }
                }
            }
        }
        
        /// <include file='doc\StatusBarPanel.uex' path='docs/doc[@for="StatusBarPanel.Parent"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Represents the <see cref='System.Windows.Forms.StatusBar'/>
        ///       control which hosts the
        ///       panel.
        ///       
        ///    </para>
        /// </devdoc>
        [Browsable(false)]
        public StatusBar Parent {
            get {
                return parent;
            }
        }

        /// <include file='doc\StatusBarPanel.uex' path='docs/doc[@for="StatusBarPanel.Style"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the style of the panel.
        ///       
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        DefaultValue(StatusBarPanelStyle.Text),
        SRDescription(SR.StatusBarPanelStyleDescr)
        ]
        public StatusBarPanelStyle Style {
            get { return style;}
            set {
                if (!Enum.IsDefined(typeof(StatusBarPanelStyle), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(StatusBarPanelStyle));
                }
                if (this.style != value) {
                    this.style = value;
                    Realize();
                    if (Created) {
                        this.parent.Invalidate();
                    }
                }
            }
        }

        /// <include file='doc\StatusBarPanel.uex' path='docs/doc[@for="StatusBarPanel.Text"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the text of the panel.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        Localizable(true),
        DefaultValue(""),
        SRDescription(SR.StatusBarPanelTextDescr)
        ]
        public string Text {
            get {
                if (text == null) {
                    return "";
                }
                else {
                    return text;
                }
            }
            set {
                if (value == null) {
                    value = "";
                }
                
                if (!Text.Equals(value)) {
                
                    if (value.Length == 0) {
                        this.text = null;
                    }
                    else {
                        this.text = value;
                    }
                    Realize();
                    UpdateSize();
                }
            }
        }


        /// <include file='doc\StatusBarPanel.uex' path='docs/doc[@for="StatusBarPanel.ToolTipText"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       or sets the panel's tool tip text.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        Localizable(true),
        DefaultValue(""),
        SRDescription(SR.StatusBarPanelToolTipTextDescr)
        ]
        public string ToolTipText {
            get {
                if (this.toolTipText == null) {
                    return "";
                }
                else {
                    return this.toolTipText;
                }
            }
            set {
                if (value == null) {
                    value = "";
                }
                
                if (!ToolTipText.Equals(value)) {
                
                    if (value.Length == 0) {
                        this.toolTipText = null;
                    }
                    else {
                        this.toolTipText = value;
                    }

                    if (Created) {
                        parent.UpdateTooltip(this);
                    }
                }
            }
        }

        /// <include file='doc\StatusBarPanel.uex' path='docs/doc[@for="StatusBarPanel.Width"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the width of the <see cref='System.Windows.Forms.StatusBarPanel'/> within the <see cref='System.Windows.Forms.StatusBar'/>
        ///       control.
        ///       
        ///    </para>
        /// </devdoc>
        [
        Localizable(true),
        SRCategory(SR.CatAppearance),
        DefaultValue(DEFAULTWIDTH),
        SRDescription(SR.StatusBarPanelWidthDescr)
        ]
        public int Width {
            get {
                return this.width;
            }
            set {
                if (!initializing && value < this.minWidth)
                    throw new ArgumentException(SR.GetString(SR.WidthGreaterThanMinWidth));

                this.width = value;
                UpdateSize();
            }
        }

        /// <include file='doc\StatusBarPanel.uex' path='docs/doc[@for="StatusBarPanel.BeginInit"]/*' />
        /// <devdoc>
        ///      Handles tasks required when the control is being initialized.
        /// </devdoc>
        public void BeginInit() {
            initializing = true;
        }

        /// <include file='doc\StatusBarPanel.uex' path='docs/doc[@for="StatusBarPanel.Dispose"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override void Dispose(bool disposing) {
            if (disposing) {
                if (parent != null) {
                    int index = GetIndex();
                    if (index != -1) {
                        parent.Panels.RemoveAt(index);
                    }
                }
            }
            base.Dispose(disposing);
        }

        /// <include file='doc\StatusBarPanel.uex' path='docs/doc[@for="StatusBarPanel.EndInit"]/*' />
        /// <devdoc>
        ///      Called when initialization of the control is complete.
        /// </devdoc>
        public void EndInit() {
            initializing = false;

            if (Width < MinWidth) {
                Width = MinWidth;
            }
        }
        
        /// <include file='doc\StatusBarPanel.uex' path='docs/doc[@for="StatusBarPanel.GetContentsWidth"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///     Gets the width of the contents of the panel
        /// </devdoc>
        internal int GetContentsWidth(bool newPanel) {
            string text;
            if (newPanel) {
                if (this.text == null)
                    text = "";
                else
                    text = this.text;
            }
            else
                text = Text;

            Graphics g = this.parent.CreateGraphicsInternal();
            Size sz = Size.Ceiling(g.MeasureString(text, parent.Font));
            if (this.icon != null) {
                sz.Width += this.icon.Size.Width + 5;
            }
            g.Dispose();
            
            int width = sz.Width + SystemInformation.BorderSize.Width*2 + PANELTEXTINSET*2 + PANELGAP;
            return Math.Max(width, minWidth);
        }

        /// <include file='doc\StatusBarPanel.uex' path='docs/doc[@for="StatusBarPanel.GetIndex"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///     Returns the index of the panel by making the parent control search
        ///     for it within its list.
        /// </devdoc>
        private int GetIndex() {
            return index;
        }

        /// <include file='doc\StatusBarPanel.uex' path='docs/doc[@for="StatusBarPanel.Realize"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///     Sets all the properties for this panel.
        /// </devdoc>
        internal void Realize() {
            if (Created) {
                string text;
                string  sendText;
                int     border = 0;

                if (this.text == null) {
                    text = "";
                }
                else {
                    text = this.text;
                }

                // Translate the alignment for Rtl apps
                //
                HorizontalAlignment align = alignment;
                if (parent.RightToLeft == RightToLeft.Yes) {
                    switch (align) {
                        case HorizontalAlignment.Left:
                            align = HorizontalAlignment.Right;
                            break;
                        case HorizontalAlignment.Right:
                            align = HorizontalAlignment.Left;
                            break;
                    }
                }
                
                switch (align) {
                    case HorizontalAlignment.Center:
                        sendText = "\t" + text;
                        break;
                    case HorizontalAlignment.Right:
                        sendText = "\t\t" + text;
                        break;
                    default:
                        sendText = text;
                        break;
                }
                switch (borderStyle) {
                    case StatusBarPanelBorderStyle.None:
                        border |= NativeMethods.SBT_NOBORDERS;
                        break;
                    case StatusBarPanelBorderStyle.Sunken:
                        break;
                    case StatusBarPanelBorderStyle.Raised:
                        border |= NativeMethods.SBT_POPOUT;
                        break;
                }
                switch (style) {
                    case StatusBarPanelStyle.Text:
                        break;
                    case StatusBarPanelStyle.OwnerDraw:
                        border |= NativeMethods.SBT_OWNERDRAW;
                        break;
                }

                
                int wparam = GetIndex() | border;
                if (parent.RightToLeft == RightToLeft.Yes) {
                    wparam |= NativeMethods.SBT_RTLREADING;
                }
                
                int result = (int) UnsafeNativeMethods.SendMessage(new HandleRef(parent, parent.Handle), NativeMethods.SB_SETTEXT, (IntPtr)wparam, sendText);

                if (result == 0)
                    throw new InvalidOperationException(SR.GetString(SR.UnableToSetPanelText));

                if (this.icon != null && style != StatusBarPanelStyle.OwnerDraw) {
                    this.parent.SendMessage(NativeMethods.SB_SETICON, (IntPtr)GetIndex(), this.icon.Handle);
                }
                else {
                    this.parent.SendMessage(NativeMethods.SB_SETICON, (IntPtr)GetIndex(), IntPtr.Zero);
                }

                if (style == StatusBarPanelStyle.OwnerDraw) {
                    NativeMethods.RECT rect = new NativeMethods.RECT();
                    result = (int) UnsafeNativeMethods.SendMessage(new HandleRef(parent, parent.Handle), NativeMethods.SB_GETRECT, (IntPtr)GetIndex(), ref rect);

                    if (result != 0) {
                        this.parent.Invalidate(Rectangle.FromLTRB(rect.left, rect.top, rect.right, rect.bottom));
                    }
                }
            }
        }

        private void UpdateSize() {
            if (this.autoSize == StatusBarPanelAutoSize.Contents) {
                ApplyContentSizing();
            }
            else {
                if (Created) {
                    parent.DirtyLayout();
                    parent.PerformLayout();
                }
            }
        }

        private void ApplyContentSizing() {
            if (this.autoSize == StatusBarPanelAutoSize.Contents &&
                parent != null) {
                int newWidth = GetContentsWidth(false);
                if (newWidth != this.Width) {
                    this.Width = newWidth;
                    if (Created) {
                        parent.DirtyLayout();
                        parent.PerformLayout();
                    }
                }
            }
        }

        /// <include file='doc\StatusBarPanel.uex' path='docs/doc[@for="StatusBarPanel.ToString"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Retrieves a string that contains information about the
        ///       panel.
        ///    </para>
        /// </devdoc>
        public override string ToString() {
            return "StatusBarPanel: {" + Text + "}";
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\statusbardrawitemevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="StatusBarDrawItemEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.Drawing;
    using Microsoft.Win32;

    /// <include file='doc\StatusBarDrawItemEvent.uex' path='docs/doc[@for="StatusBarDrawItemEventArgs"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides data for the <see cref='System.Windows.Forms.StatusBar.OnDrawItem'/>
    ///       event.
    ///    </para>
    /// </devdoc>
    public class StatusBarDrawItemEventArgs : DrawItemEventArgs {
        readonly StatusBarPanel panel;

        /// <include file='doc\StatusBarDrawItemEvent.uex' path='docs/doc[@for="StatusBarDrawItemEventArgs.StatusBarDrawItemEventArgs"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Windows.Forms.StatusBarDrawItemEventArgs'/>
        ///       class.
        ///    </para>
        /// </devdoc>
        public StatusBarDrawItemEventArgs(System.Drawing.Graphics g, Font font, Rectangle r, int itemId,
            DrawItemState itemState, StatusBarPanel panel) : base(g, font, r, itemId, itemState) {
            this.panel = panel;
        }

        /// <include file='doc\StatusBarDrawItemEvent.uex' path='docs/doc[@for="StatusBarDrawItemEventArgs.StatusBarDrawItemEventArgs1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Windows.Forms.StatusBarDrawItemEventArgs'/>
        ///       class using the Forecolor and Backcolor.
        ///    </para>
        /// </devdoc>
        public StatusBarDrawItemEventArgs(System.Drawing.Graphics g, Font font, Rectangle r, int itemId,
            DrawItemState itemState, StatusBarPanel panel, Color foreColor, Color backColor) : base(g, font, r, itemId, itemState, foreColor, backColor) {
            this.panel = panel;
        }

        /// <include file='doc\StatusBarDrawItemEvent.uex' path='docs/doc[@for="StatusBarDrawItemEventArgs.Panel"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies the <see cref='System.Windows.Forms.StatusBarPanel'/>
        ///       to
        ///       draw.
        ///    </para>
        /// </devdoc>
        public StatusBarPanel Panel {
            get {
                return panel;
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\statusbardrawitemeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="StatusBarDrawItemEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;


    /// <include file='doc\StatusBarDrawItemEventHandler.uex' path='docs/doc[@for="StatusBarDrawItemEventHandler"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents the method that will handle the <see cref='System.Windows.Forms.StatusBar.OnDrawItem'/>
    ///       event of a <see cref='System.Windows.Forms.StatusBar'/>.
    ///    </para>
    /// </devdoc>
    public delegate void StatusBarDrawItemEventHandler(object sender, StatusBarDrawItemEventArgs sbdevent);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\statusbarpanelautosize.cs ===
//------------------------------------------------------------------------------
// <copyright file="StatusBarPanelAutoSize.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    using System.Drawing;
    using Microsoft.Win32;


    /// <include file='doc\StatusBarPanelAutoSize.uex' path='docs/doc[@for="StatusBarPanelAutoSize"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies how a panel on a status bar changes when the
    ///       status bar resizes.
    ///    </para>
    /// </devdoc>
    public enum StatusBarPanelAutoSize {

        /// <include file='doc\StatusBarPanelAutoSize.uex' path='docs/doc[@for="StatusBarPanelAutoSize.None"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The panel does not change
        ///       its size when the status bar resizes.
        ///    </para>
        /// </devdoc>
        None        = 1,

        /// <include file='doc\StatusBarPanelAutoSize.uex' path='docs/doc[@for="StatusBarPanelAutoSize.Spring"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The panel shares the available status bar space (the
        ///       space not taken up by panels with the <see langword='None'/> and
        ///    <see langword='Contents'/> settings) with other panels that have the 
        ///    <see langword='Spring'/>
        ///    setting.
        /// </para>
        /// </devdoc>
        Spring      = 2,

        /// <include file='doc\StatusBarPanelAutoSize.uex' path='docs/doc[@for="StatusBarPanelAutoSize.Contents"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The width of the panel is determined by its contents.
        ///    </para>
        /// </devdoc>
        Contents    = 3,

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\statusbarpanelclickevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="StatusBarPanelClickEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.Drawing;
    using System.ComponentModel;
    using Microsoft.Win32;

    /// <include file='doc\StatusBarPanelClickEvent.uex' path='docs/doc[@for="StatusBarPanelClickEventArgs"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides data for the <see cref='System.Windows.Forms.StatusBar.OnPanelClick'/>
    ///       event.
    ///    </para>
    /// </devdoc>
    public class StatusBarPanelClickEventArgs : MouseEventArgs {

        readonly StatusBarPanel statusBarPanel;


        /// <include file='doc\StatusBarPanelClickEvent.uex' path='docs/doc[@for="StatusBarPanelClickEventArgs.StatusBarPanelClickEventArgs"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Windows.Forms.StatusBarPanelClickEventArgs'/>
        ///       class.
        ///    </para>
        /// </devdoc>
        public StatusBarPanelClickEventArgs(StatusBarPanel statusBarPanel, MouseButtons button, int clicks, int x, int y)
            : base(button, clicks, x, y, 0) {
            this.statusBarPanel = statusBarPanel;
        }

        /// <include file='doc\StatusBarPanelClickEvent.uex' path='docs/doc[@for="StatusBarPanelClickEventArgs.StatusBarPanel"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies the <see cref='System.Windows.Forms.StatusBarPanel'/> that represents the clicked panel.
        ///    </para>
        /// </devdoc>
        public StatusBarPanel StatusBarPanel {
            get {
                return statusBarPanel;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\statusbarpanelborderstyle.cs ===
//------------------------------------------------------------------------------
// <copyright file="StatusBarPanelBorderStyle.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    using System.Drawing;
    using Microsoft.Win32;


    /// <include file='doc\StatusBarPanelBorderStyle.uex' path='docs/doc[@for="StatusBarPanelBorderStyle"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the border style of a panel on the <see cref='System.Windows.Forms.StatusBar'/>.
    ///    </para>
    /// </devdoc>
    public enum StatusBarPanelBorderStyle {
        /// <include file='doc\StatusBarPanelBorderStyle.uex' path='docs/doc[@for="StatusBarPanelBorderStyle.None"]/*' />
        /// <devdoc>
        ///     No border.
        /// </devdoc>
        None        = 1,

        /// <include file='doc\StatusBarPanelBorderStyle.uex' path='docs/doc[@for="StatusBarPanelBorderStyle.Raised"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A raised border.
        ///    </para>
        /// </devdoc>
        Raised      = 2,

        /// <include file='doc\StatusBarPanelBorderStyle.uex' path='docs/doc[@for="StatusBarPanelBorderStyle.Sunken"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A sunken border.
        ///    </para>
        /// </devdoc>
        Sunken      = 3,

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\statusbarpanelclickeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="StatusBarPanelClickEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;


    /// <include file='doc\StatusBarPanelClickEventHandler.uex' path='docs/doc[@for="StatusBarPanelClickEventHandler"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents the method that will handle the <see cref='System.Windows.Forms.StatusBar.OnPanelClick'/>
    ///       event of a <see cref='System.Windows.Forms.StatusBar'/>.
    ///    </para>
    /// </devdoc>
    public delegate void StatusBarPanelClickEventHandler(object sender, StatusBarPanelClickEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\structformat.cs ===
//------------------------------------------------------------------------------
// <copyright file="StructFormat.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;
    
    using System;

    /// <include file='doc\StructFormat.uex' path='docs/doc[@for="StructFormat"]/*' />
    /// <internalonly/>
    /// <devdoc>
    /// </devdoc>
    public enum StructFormat {
        /// <include file='doc\StructFormat.uex' path='docs/doc[@for="StructFormat.Ansi"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Ansi = 1,
        /// <include file='doc\StructFormat.uex' path='docs/doc[@for="StructFormat.Unicode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Unicode = 2,
        /// <include file='doc\StructFormat.uex' path='docs/doc[@for="StructFormat.Auto"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Auto = 3,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\stringsorter.cs ===
//------------------------------------------------------------------------------
// <copyright file="StringSorter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {
    
    using System.Threading;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Globalization;

    /// <include file='doc\StringSorter.uex' path='docs/doc[@for="StringSorter"]/*' />
    /// <internalonly/>
    /// <devdoc>
    ///    <para>
    ///       This class provides methods to perform locale based comparison of strings
    ///       and sorting of arrays.
    ///    </para>
    /// </devdoc>
    internal sealed class StringSorter
    {
        /// <include file='doc\StringSorter.uex' path='docs/doc[@for="StringSorter.IgnoreCase"]/*' />
        /// <devdoc>
        ///     Ignore case when comparing two strings. When this flag is specified in
        ///     calls to compare() and sort(), two strings are considered equal if they
        ///     differ only in casing.
        /// </devdoc>
        public const int IgnoreCase = 0x00000001;

        /// <include file='doc\StringSorter.uex' path='docs/doc[@for="StringSorter.IgnoreKanaType"]/*' />
        /// <devdoc>
        ///     Do not differentiate between Hiragana and Katakana characters. When this
        ///     flag is specified in calls to compare() and sort(), corresponding
        ///     Hiragana and Katakana characters compare as equal.
        /// </devdoc>
        public const int IgnoreKanaType = 0x00010000;

        /// <include file='doc\StringSorter.uex' path='docs/doc[@for="StringSorter.IgnoreNonSpace"]/*' />
        /// <devdoc>
        ///     Ignore nonspacing marks (accents, diacritics, and vowel marks). When
        ///     this flag is specified in calls to compare() and sort(), strings compare
        ///     as equal if they differ only in how characters are accented.
        /// </devdoc>
        public const int IgnoreNonSpace = 0x00000002;

        /// <include file='doc\StringSorter.uex' path='docs/doc[@for="StringSorter.IgnoreSymbols"]/*' />
        /// <devdoc>
        ///     Ignore symbols. When this flag is specified in calls to compare() and
        ///     sort(), strings compare as equal if they differ only in what symbol
        ///     characters they contain.
        /// </devdoc>
        public const int IgnoreSymbols = 0x00000004;

        /// <include file='doc\StringSorter.uex' path='docs/doc[@for="StringSorter.IgnoreWidth"]/*' />
        /// <devdoc>
        ///     Ignore character widths. When this flag is specified in calls to
        ///     compare() and sort(), string comparisons do not differentiate between a
        ///     single-ubyte character and the same character as a double-ubyte character.
        /// </devdoc>
        public const int IgnoreWidth = 0x00020000;

        /// <include file='doc\StringSorter.uex' path='docs/doc[@for="StringSorter.StringSort"]/*' />
        /// <devdoc>
        ///     Treat punctuation the same as symbols. Typically, strings are compared
        ///     using what is called a "word sort" technique. In a word sort, all
        ///     punctuation marks and other nonalphanumeric characters, except for the
        ///     hyphen and the apostrophe, come before any alphanumeric character. The
        ///     hyphen and the apostrophe are treated differently than the other
        ///     nonalphanumeric symbols, in order to ensure that words such as "coop"
        ///     and "co-op" stay together within a sorted list. If the STRINGSORT flag
        ///     is specified, strings are compared using what is called a "string sort"
        ///     technique. In a string sort, the hyphen and apostrophe are treated just
        ///     like any other nonalphanumeric symbols: they come before the
        ///     alphanumeric symbols.
        /// </devdoc>
        public const int StringSort = 0x00001000;

        /// <include file='doc\StringSorter.uex' path='docs/doc[@for="StringSorter.Descending"]/*' />
        /// <devdoc>
        ///     Descending sort. When this flag is specified in a call to sort(), the
        ///     strings are sorted in descending order. This flag should not be used in
        ///     calls to compare().
        /// </devdoc>
        public const int Descending = unchecked((int)0x80000000);

        private const int CompareOptions = IgnoreCase | IgnoreKanaType |
            IgnoreNonSpace | IgnoreSymbols | IgnoreWidth | StringSort;

        private string[] keys;
        private object[] items;
        private int lcid;
        private int options;
        private bool descending;

        /// <include file='doc\StringSorter.uex' path='docs/doc[@for="StringSorter.StringSorter"]/*' />
        /// <devdoc>
        ///     Constructs a StringSorter. Instances are created by the sort() routines,
        ///     but never by the user.
        /// </devdoc>
        private StringSorter(CultureInfo culture, string[] keys, object[] items, int options) {
            if (keys == null) {
                if (items is string[]) {
                    keys = (string[])items;
                    items = null;
                }
                else {
                    keys = new string[items.Length];
                    for (int i = 0; i < items.Length; i++) {
                        object item = items[i];
                        if (item != null) keys[i] = item.ToString();
                    }
                }
            }
            this.keys = keys;
            this.items = items;
            this.lcid = culture == null? SafeNativeMethods.GetThreadLocale(): culture.LCID;
            this.options = options & CompareOptions;
            this.descending = (options & Descending) != 0;
        }

        /// <include file='doc\StringSorter.uex' path='docs/doc[@for="StringSorter.ArrayLength"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        internal static int ArrayLength(object[] array) {
            if (array == null)
                return 0;
            else
                return array.Length;
        }
        
        /// <include file='doc\StringSorter.uex' path='docs/doc[@for="StringSorter.Compare"]/*' />
        /// <devdoc>
        ///     Compares two strings using the default locale and no additional string
        ///     comparison flags.
        /// </devdoc>
        public static int Compare(string s1, string s2) {
            return Compare(SafeNativeMethods.GetThreadLocale(), s1, s2, 0);
        }

        /// <include file='doc\StringSorter.uex' path='docs/doc[@for="StringSorter.Compare1"]/*' />
        /// <devdoc>
        ///     Compares two strings using the default locale with the given set of
        ///     string comparison flags.
        /// </devdoc>
        public static int Compare(string s1, string s2, int options) {
            return Compare(SafeNativeMethods.GetThreadLocale(), s1, s2, options);
        }

        /// <include file='doc\StringSorter.uex' path='docs/doc[@for="StringSorter.Compare2"]/*' />
        /// <devdoc>
        ///     Compares two strings using a given locale and a given set of comparison
        ///     flags. If the two strings are of different lengths, they are compared up
        ///     to the length of the shortest one. If they are equal to that point, then
        ///     the return value will indicate that the longer string is greater. Notice
        ///     that if the return value is 0, the two strings are "equal" in the
        ///     collation sense, though not necessarily identical.
        ///     A <embedcode term='null'/> string always sorts before a non-null string. Two
        /// <embedcode term='null'/> strings are considered equal.
        ///     The <paramref name='options'/> parameter is a combination of zero or more of
        ///     the following flags: <code>IGNORECASE</code>, <code>IGNOREKANATYPE</code>,
        /// <code>IGNORENONSPACE</code>, <code>IGNORESYMBOLS</code>,
        /// <code>IGNOREWIDTH</code>, and <code>STRINGSORT</code>.
        /// </devdoc>
        public static int Compare(CultureInfo culture, string s1, string s2, int options) {
            return Compare(culture.LCID, s1, s2, options);
        }

        /// <include file='doc\StringSorter.uex' path='docs/doc[@for="StringSorter.Compare3"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        private static int Compare(int lcid, string s1, string s2, int options) {
            if (s1 == null) return s2 == null? 0: -1;
            if (s2 == null) return 1;
            return String.Compare(s1, s2, false, CultureInfo.CurrentCulture);
        }

        /// <include file='doc\StringSorter.uex' path='docs/doc[@for="StringSorter.CompareKeys"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        private int CompareKeys(string s1, string s2) {
            int result = Compare(lcid, s1, s2, options);
            return descending? -result: result;
        }

        /// <include file='doc\StringSorter.uex' path='docs/doc[@for="StringSorter.QuickSort"]/*' />
        /// <devdoc>
        ///     Implementation of Quicksort algorithm. Within the outer <code>do</code>
        ///     loop, the method recurses on the shorter side and loops on the longer
        ///     side. This bounds the recursive depth by log2(n) in the worst case.
        ///     Otherwise, worst case recursive depth would be n.
        /// </devdoc>
        /// <internalonly/>
        private void QuickSort(int left, int right) {
            do {
                int i = left;
                int j = right;
                string s = keys[(i + j) >> 1];
                do {
                    while (CompareKeys(keys[i], s) < 0) i++;
                    while (CompareKeys(s, keys[j]) < 0) j--;
                    if (i > j) break;
                    if (i < j) {
                        string key = keys[i];
                        keys[i] = keys[j];
                        keys[j] = key;
                        if (items != null) {
                            object item = items[i];
                            items[i] = items[j];
                            items[j] = item;
                        }
                    }
                    i++;
                    j--;
                } while (i <= j);
                if (j - left <= right - i) {
                    if (left < j) QuickSort(left, j);
                    left = i;
                }
                else {
                    if (i < right) QuickSort(i, right);
                    right = j;
                }
            } while (left < right);
        }

        /// <include file='doc\StringSorter.uex' path='docs/doc[@for="StringSorter.Sort"]/*' />
        /// <devdoc>
        ///     Sorts an object array based on the string representation of the
        ///     elements. If the <code>items</code> parameter is not a string array, the
        /// <code>toString</code> method of each of the elements is called to
        ///     produce the string representation. The objects are then sorted by their
        ///     string representations using the default locale.
        /// </devdoc>
        public static void Sort(object[] items) {
            Sort(null, null, items, 0, ArrayLength(items), 0);
        }

        /// <include file='doc\StringSorter.uex' path='docs/doc[@for="StringSorter.Sort1"]/*' />
        /// <devdoc>
        ///     Sorts a range in an object array based on the string representation of
        ///     the elements. If the <code>items</code> parameter is not a string array,
        ///     the <code>toString</code> method of each of the elements is called to
        ///     produce the string representation. The objects are then sorted by their
        ///     string representations using the default locale.
        /// </devdoc>
        public static void Sort(object[] items, int index, int count) {
            Sort(null, null, items, index, count, 0);
        }

        /// <include file='doc\StringSorter.uex' path='docs/doc[@for="StringSorter.Sort2"]/*' />
        /// <devdoc>
        ///     Sorts a string array and an object array based on the elements of the
        ///     string array. The arrays are sorted using the default locale.
        /// </devdoc>
        public static void Sort(string[] keys, object[] items) {
            Sort(null, keys, items, 0, ArrayLength(items), 0);
        }

        /// <include file='doc\StringSorter.uex' path='docs/doc[@for="StringSorter.Sort3"]/*' />
        /// <devdoc>
        ///     Sorts a range in a string array and a range in an object array based on
        ///     the elements of the string array. The arrays are sorted using the
        ///     default locale.
        /// </devdoc>
        public static void Sort(string[] keys, object[] items, int index, int count) {
            Sort(null, keys, items, index, count, 0);
        }

        /// <include file='doc\StringSorter.uex' path='docs/doc[@for="StringSorter.Sort4"]/*' />
        /// <devdoc>
        ///     Sorts an object array based on the string representation of the
        ///     elements. If the <code>items</code> parameter is not a string array, the
        /// <code>toString</code> method of each of the elements is called to
        ///     produce the string representation. The objects are then sorted by their
        ///     string representations using the default locale and the given sorting
        ///     options.
        /// </devdoc>
        public static void Sort(object[] items, int options) {
            Sort(null, null, items, 0, ArrayLength(items), options);
        }

        /// <include file='doc\StringSorter.uex' path='docs/doc[@for="StringSorter.Sort5"]/*' />
        /// <devdoc>
        ///     Sorts a range in an object array based on the string representation of
        ///     the elements. If the <code>items</code> parameter is not a string array,
        ///     the <code>toString</code> method of each of the elements is called to
        ///     produce the string representation. The objects are then sorted by their
        ///     string representations using the default locale and the given sorting
        ///     options.
        /// </devdoc>
        public static void Sort(object[] items, int index, int count, int options) {
            Sort(null, null, items, index, count, options);
        }

        /// <include file='doc\StringSorter.uex' path='docs/doc[@for="StringSorter.Sort6"]/*' />
        /// <devdoc>
        ///     Sorts a string array and an object array based on the elements of the
        ///     string array. The arrays are sorted using the default locale and the
        ///     given sorting options.
        /// </devdoc>
        public static void Sort(string[] keys, object[] items, int options) {
            Sort(null, keys, items, 0, ArrayLength(items), options);
        }

        /// <include file='doc\StringSorter.uex' path='docs/doc[@for="StringSorter.Sort7"]/*' />
        /// <devdoc>
        ///     Sorts a range in a string array and a range in an object array based on
        ///     the elements of the string array. The arrays are sorted using the
        ///     default locale and the given sorting options.
        /// </devdoc>
        public static void Sort(string[] keys, object[] items, int index, int count, int options) {
            Sort(null, keys, items, index, count, options);
        }

        /// <include file='doc\StringSorter.uex' path='docs/doc[@for="StringSorter.Sort8"]/*' />
        /// <devdoc>
        ///     Sorts an object array based on the string representation of the
        ///     elements. If the <code>items</code> parameter is not a string array, the
        /// <code>toString</code> method of each of the elements is called to
        ///     produce the string representation. The objects are then sorted by their
        ///     string representations using the given locale and the given sorting
        ///     options.
        /// </devdoc>
        public static void Sort(CultureInfo culture, object[] items, int options) {
            Sort(culture, null, items, 0, ArrayLength(items), options);
        }

        /// <include file='doc\StringSorter.uex' path='docs/doc[@for="StringSorter.Sort9"]/*' />
        /// <devdoc>
        ///     Sorts a range in an object array based on the string representation of
        ///     the elements. If the <code>items</code> parameter is not a string array,
        ///     the <code>toString</code> method of each of the elements is called to
        ///     produce the string representation. The objects are then sorted by their
        ///     string representations using the given locale and the given sorting
        ///     options.
        /// </devdoc>
        public static void Sort(CultureInfo culture, object[] items, int index, int count, int options) {
            Sort(culture, null, items, index, count, options);
        }

        /// <include file='doc\StringSorter.uex' path='docs/doc[@for="StringSorter.Sort10"]/*' />
        /// <devdoc>
        ///     Sorts a string array and an object array based on the elements of the
        ///     string array. The arrays are sorted using the given locale and the
        ///     given sorting options.
        /// </devdoc>
        public static void Sort(CultureInfo culture, string[] keys, object[] items, int options) {
            Sort(culture, keys, items, 0, ArrayLength(items), options);
        }

        /// <include file='doc\StringSorter.uex' path='docs/doc[@for="StringSorter.Sort11"]/*' />
        /// <devdoc>
        ///     Sorts a range in a string array and a range in an object array based on
        ///     the elements of the string array. Elements in the <code>keys</code>
        ///     array specify the sort keys for corresponding elements in the
        /// <code>items</code> array. The range of elements given by the
        /// <code>index</code> and <code>count</code> parameters is sorted in both
        ///     arrays according to the given locale and sorting options.
        ///     If the <code>keys</code> parameter is <code>null</code>, the sort keys
        ///     are instead computed by calling the <code>toString</code> method of each
        ///     element in the <code>items</code> array.
        /// <code>null</code> keys always sort before a non-null keys.
        ///     The <code>options</code> parameter is a combination of zero or more of
        ///     the following flags: <code>IGNORECASE</code>, <code>IGNOREKANATYPE</code>,
        /// <code>IGNORENONSPACE</code>, <code>IGNORESYMBOLS</code>,
        /// <code>IGNOREWIDTH</code>, <code>STRINGSORT</code>, and
        /// <code>DESCENDING</code>.
        /// </devdoc>
        public static void Sort(CultureInfo culture, string[] keys, object[] items, int index, int count, int options) {
            // keys and items have to be the same length
            //
            if ((items == null)
                || ((keys != null) && (keys.Length != items.Length)))
                throw new ArgumentException(SR.GetString(SR.ArraysNotSameSize,
                                                                   "keys",
                                                                   "items"));
            if (count > 1) {
                StringSorter sorter = new StringSorter(culture, keys, items, options);
                sorter.QuickSort(index, index + count - 1);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\statusbarpanelstyle.cs ===
//------------------------------------------------------------------------------
// <copyright file="StatusBarPanelStyle.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    using System.Drawing;
    using Microsoft.Win32;


    /// <include file='doc\StatusBarPanelStyle.uex' path='docs/doc[@for="StatusBarPanelStyle"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies whether a panel on
    ///       a status bar is owner drawn or system drawn.
    ///    </para>
    /// </devdoc>
    public enum StatusBarPanelStyle {

        /// <include file='doc\StatusBarPanelStyle.uex' path='docs/doc[@for="StatusBarPanelStyle.Text"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The panel is
        ///       drawn by the system.
        ///    </para>
        /// </devdoc>
        Text        = 1,

        /// <include file='doc\StatusBarPanelStyle.uex' path='docs/doc[@for="StatusBarPanelStyle.OwnerDraw"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The panel is
        ///       drawn by the owner.
        ///    </para>
        /// </devdoc>
        OwnerDraw   = 2,

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\systeminformation.cs ===
//------------------------------------------------------------------------------
// <copyright file="SystemInformation.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {
    using System.Text;
    using System.Configuration.Assemblies;
    using System.Threading;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;

    using System.Diagnostics;

    using System;
    using Microsoft.Win32;
    using System.IO;
    using System.Security;
    using System.Security.Permissions;
    using System.Drawing;
    using System.ComponentModel;

    /// <include file='doc\SystemInformation.uex' path='docs/doc[@for="SystemInformation"]/*' />
    /// <devdoc>
    ///    <para>Provides information about the operating system.</para>
    /// </devdoc>
    public class SystemInformation {

        // private constructor to prevent creation
        //
        private SystemInformation() {
        }

        // Figure out if all the multimon stuff is supported on the OS
        //
        private static bool checkMultiMonitorSupport = false;
        private static bool multiMonitorSupport = false;
        private static bool checkNativeMouseWheelSupport = false;
        private static bool nativeMouseWheelSupport = true;
        private static bool highContrast = false;
        private static bool systemEventsAttached = false;
        private static bool systemEventsDirty = true;

        private static IntPtr processWinStation = IntPtr.Zero;
        private static bool isUserInteractive = false;

        private const int  DefaultMouseWheelScrollLines = 3;
        
        ////////////////////////////////////////////////////////////////////////////
        // SystemParametersInfo
        //

        /// <include file='doc\SystemInformation.uex' path='docs/doc[@for="SystemInformation.DragFullWindows"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the user has enabled full window drag.
        ///    </para>
        /// </devdoc>
        public static bool DragFullWindows {
            get {
                int data = 0;
                UnsafeNativeMethods.SystemParametersInfo(NativeMethods.SPI_GETDRAGFULLWINDOWS, 0, ref data, 0);
                return data != 0;
            }
        }
        
        /// <include file='doc\SystemInformation.uex' path='docs/doc[@for="SystemInformation.HighContrast"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the user has selected to run in high contrast
        ///       mode.
        ///    </para>
        /// </devdoc>
        public static bool HighContrast {
            get {
                EnsureSystemEvents();
                if (systemEventsDirty) {
                    systemEventsDirty = false;
                    
                    NativeMethods.HIGHCONTRAST_I data = new NativeMethods.HIGHCONTRAST_I();
                    data.cbSize = Marshal.SizeOf(data);
                    data.dwFlags = 0;
                    data.lpszDefaultScheme = IntPtr.Zero;
                    
                    bool b = UnsafeNativeMethods.SystemParametersInfo(NativeMethods.SPI_GETHIGHCONTRAST, data.cbSize, ref data, 0);
    
                    // NT4 does not support this parameter, so we always force
                    // it to false if we fail to get the parameter.
                    //
                    if (b) {
                        highContrast = (data.dwFlags & NativeMethods.HCF_HIGHCONTRASTON) != 0;
                    }
                    else {
                        highContrast = false;
                    }
                }
                
                return highContrast;
            }
        }
        
        /// <include file='doc\SystemInformation.uex' path='docs/doc[@for="SystemInformation.MouseWheelScrollLines"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the number of lines to scroll when the mouse wheel is rotated.
        ///    </para>
        /// </devdoc>
        public static int MouseWheelScrollLines {
            get {
                if (NativeMouseWheelSupport) {
                    int data = 0;
                    UnsafeNativeMethods.SystemParametersInfo(NativeMethods.SPI_GETWHEELSCROLLLINES, 0, ref data, 0);
                    return data;
                }
                else {
                    IntPtr hWndMouseWheel = IntPtr.Zero;

                    // Check for the MouseZ "service". This is a little app that generated the
                    // MSH_MOUSEWHEEL messages by monitoring the hardware. If this app isn't
                    // found, then there is no support for MouseWheels on the system.
                    //
                    hWndMouseWheel = UnsafeNativeMethods.FindWindow(NativeMethods.MOUSEZ_CLASSNAME, NativeMethods.MOUSEZ_TITLE);

                    if (hWndMouseWheel != IntPtr.Zero) {

                        // Register the MSH_SCROLL_LINES message...
                        //
                        int message = SafeNativeMethods.RegisterWindowMessage(NativeMethods.MSH_SCROLL_LINES);

                        
                        int lines = (int)UnsafeNativeMethods.SendMessage(new HandleRef(null, hWndMouseWheel), message, 0, 0);
                        
                        // this fails under terminal server, so we default to 3, which is the windows
                        // default.  Nobody seems to pay attention to this value anyways...
                        if (lines != 0) {
                            return lines;
                        }
                    }
                }

                return DefaultMouseWheelScrollLines;
            }
        }
        
        ////////////////////////////////////////////////////////////////////////////
        // SystemMetrics
        //

        /// <include file='doc\SystemInformation.uex' path='docs/doc[@for="SystemInformation.PrimaryMonitorSize"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the dimensions of the primary display monitor in pixels.
        ///    </para>
        /// </devdoc>
        public static Size PrimaryMonitorSize {
            get {
                return new Size(UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_CXSCREEN),
                                UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_CYSCREEN));
            }
        }

        /// <include file='doc\SystemInformation.uex' path='docs/doc[@for="SystemInformation.VerticalScrollBarWidth"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the width of the vertical scroll bar in pixels.
        ///    </para>
        /// </devdoc>
        public static int VerticalScrollBarWidth {
            get {
                return UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_CXVSCROLL);
            }
        }

        /// <include file='doc\SystemInformation.uex' path='docs/doc[@for="SystemInformation.HorizontalScrollBarHeight"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the height of the horizontal scroll bar in pixels.
        ///    </para>
        /// </devdoc>
        public static int HorizontalScrollBarHeight {
            get {
                return UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_CYHSCROLL);
            }
        }

        /// <include file='doc\SystemInformation.uex' path='docs/doc[@for="SystemInformation.CaptionHeight"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the height of the normal caption area of a window in pixels.
        ///    </para>
        /// </devdoc>
        public static int CaptionHeight {
            get {
                return UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_CYCAPTION);
            }
        }

        /// <include file='doc\SystemInformation.uex' path='docs/doc[@for="SystemInformation.BorderSize"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the width and
        ///       height of a window border in pixels.
        ///    </para>
        /// </devdoc>
        public static Size BorderSize {
            get {
                return new Size(UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_CXBORDER),
                                UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_CYBORDER));
            }
        }

        /// <include file='doc\SystemInformation.uex' path='docs/doc[@for="SystemInformation.FixedFrameBorderSize"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the thickness in pixels, of the border for a window that has a caption
        ///       and is not resizable.
        ///    </para>
        /// </devdoc>
        public static Size FixedFrameBorderSize {
            get {
                return new Size(UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_CXFIXEDFRAME),
                                UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_CYFIXEDFRAME));
            }
        }

        /// <include file='doc\SystemInformation.uex' path='docs/doc[@for="SystemInformation.VerticalScrollBarThumbHeight"]/*' />
        /// <devdoc>
        ///    <para>Gets the height of the scroll box in a vertical scroll bar in pixels.</para>
        /// </devdoc>
        public static int VerticalScrollBarThumbHeight {
            get {
                return UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_CYVTHUMB);
            }
        }

        /// <include file='doc\SystemInformation.uex' path='docs/doc[@for="SystemInformation.HorizontalScrollBarThumbWidth"]/*' />
        /// <devdoc>
        ///    <para>Gets the width of the scroll box in a horizontal scroll bar in pixels.</para>
        /// </devdoc>
        public static int HorizontalScrollBarThumbWidth {
            get {
                return UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_CXHTHUMB);
            }
        }

        /// <include file='doc\SystemInformation.uex' path='docs/doc[@for="SystemInformation.IconSize"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the default dimensions of an icon in pixels.
        ///    </para>
        /// </devdoc>
        public static Size IconSize {
            get {
                return new Size(UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_CXICON),
                                UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_CYICON));
            }
        }

        /// <include file='doc\SystemInformation.uex' path='docs/doc[@for="SystemInformation.CursorSize"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the dimensions of a cursor in pixels.
        ///    </para>
        /// </devdoc>
        public static Size CursorSize {
            get {
                return new Size(UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_CXCURSOR),
                                UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_CYCURSOR));
            }
        }

        /// <include file='doc\SystemInformation.uex' path='docs/doc[@for="SystemInformation.MenuFont"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the system's font for menus.
        ///    </para>
        /// </devdoc>
        public static Font MenuFont {
            get {
                Font menuFont = null;

                //we can get the system's menu font through the NONCLIENTMETRICS structure via SystemParametersInfo
                //
                NativeMethods.NONCLIENTMETRICS data = new NativeMethods.NONCLIENTMETRICS();
                bool result = UnsafeNativeMethods.SystemParametersInfo(NativeMethods.SPI_GETNONCLIENTMETRICS, data.cbSize, data, 0);

                if (result && data.lfMenuFont != null) {
                    IntSecurity.ObjectFromWin32Handle.Assert();
                    try {
                        menuFont = Font.FromLogFont(data.lfMenuFont);
                    }
                    catch {
                        // menu font is not true type.  Default to standard control font.
                        //
                        menuFont = Control.DefaultFont;
                    }
                    finally {
                        CodeAccessPermission.RevertAssert();
                    }
                }
                return menuFont;
            }
        }

        /// <include file='doc\SystemInformation.uex' path='docs/doc[@for="SystemInformation.MenuHeight"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the height of a one line of a menu in pixels.
        ///    </para>
        /// </devdoc>
        public static int MenuHeight {
            get {
                return UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_CYMENU);
            }
        }

        /// <include file='doc\SystemInformation.uex' path='docs/doc[@for="SystemInformation.WorkingArea"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the size of the working area in pixels.
        ///    </para>
        /// </devdoc>
        public static Rectangle WorkingArea {
            get {
                NativeMethods.RECT rc = new NativeMethods.RECT();
                UnsafeNativeMethods.SystemParametersInfo(NativeMethods.SPI_GETWORKAREA, 0, ref rc, 0);
                return Rectangle.FromLTRB(rc.left, rc.top, rc.right, rc.bottom);
            }
        }

        /// <include file='doc\SystemInformation.uex' path='docs/doc[@for="SystemInformation.KanjiWindowHeight"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       the height, in pixels, of the Kanji window at the bottom
        ///       of the screen for double-byte (DBCS) character set versions of Windows.
        ///    </para>
        /// </devdoc>
        public static int KanjiWindowHeight {
            get {
                return UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_CYKANJIWINDOW);
            }
        }

        /// <include file='doc\SystemInformation.uex' path='docs/doc[@for="SystemInformation.MousePresent"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the system has a mouse installed.
        ///    </para>
        /// </devdoc>
        public static bool MousePresent {
            get {
                return UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_MOUSEPRESENT) != 0;
            }
        }

        /// <include file='doc\SystemInformation.uex' path='docs/doc[@for="SystemInformation.VerticalScrollBarArrowHeight"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the height in pixels, of the arrow bitmap on the vertical scroll bar.
        ///    </para>
        /// </devdoc>
        public static int VerticalScrollBarArrowHeight {
            get {
                return UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_CYVSCROLL);
            }
        }

        /// <include file='doc\SystemInformation.uex' path='docs/doc[@for="SystemInformation.HorizontalScrollBarArrowWidth"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the width, in pixels, of the arrow bitmap on the horizontal scrollbar.
        ///    </para>
        /// </devdoc>
        public static int HorizontalScrollBarArrowWidth {
            get {
                return UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_CXHSCROLL);
            }
        }

        /// <include file='doc\SystemInformation.uex' path='docs/doc[@for="SystemInformation.DebugOS"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether this is a debug version of the operating
        ///       system.
        ///    </para>
        /// </devdoc>
        public static bool DebugOS {
            get {
                Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "SensitiveSystemInformation Demanded");
                IntSecurity.SensitiveSystemInformation.Demand();
                return UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_DEBUG) != 0;
            }
        }

        /// <include file='doc\SystemInformation.uex' path='docs/doc[@for="SystemInformation.MouseButtonsSwapped"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the functions of the left and right mouse
        ///       buttons have been swapped.
        ///    </para>
        /// </devdoc>
        public static bool MouseButtonsSwapped {
            get {
                return(UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_SWAPBUTTON) != 0);
            }
        }

        /// <include file='doc\SystemInformation.uex' path='docs/doc[@for="SystemInformation.MinimumWindowSize"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the minimum allowable dimensions of a window in pixels.
        ///    </para>
        /// </devdoc>
        public static Size MinimumWindowSize {
            get {
                return new Size(UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_CXMIN),
                                UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_CYMIN));
            }
        }

        /// <include file='doc\SystemInformation.uex' path='docs/doc[@for="SystemInformation.CaptionButtonSize"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the dimensions in pixels, of a caption bar or title bar
        ///       button.
        ///    </para>
        /// </devdoc>
        public static Size CaptionButtonSize {
            get {
                return new Size(UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_CXSIZE),
                                UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_CYSIZE));
            }
        }

        /// <include file='doc\SystemInformation.uex' path='docs/doc[@for="SystemInformation.FrameBorderSize"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the thickness in pixels, of the border for a window that can be resized.
        ///    </para>
        /// </devdoc>
        public static Size FrameBorderSize {
            get {
                return new Size(UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_CXFRAME),
                                UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_CYFRAME));
            }
        }

        /// <include file='doc\SystemInformation.uex' path='docs/doc[@for="SystemInformation.MinWindowTrackSize"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the system's default
        ///       minimum tracking dimensions of a window in pixels.
        ///    </para>
        /// </devdoc>
        public static Size MinWindowTrackSize {
            get {
                return new Size(UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_CXMINTRACK),
                                UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_CYMINTRACK));
            }
        }

        /// <include file='doc\SystemInformation.uex' path='docs/doc[@for="SystemInformation.DoubleClickSize"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the dimensions in pixels, of the area that the user must click within
        ///       for the system to consider the two clicks a double-click. The rectangle is
        ///       centered around the first click.
        ///    </para>
        /// </devdoc>
        public static Size DoubleClickSize {
            get {
                return new Size(UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_CXDOUBLECLK),
                                UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_CYDOUBLECLK));
            }
        }

        /// <include file='doc\SystemInformation.uex' path='docs/doc[@for="SystemInformation.DoubleClickTime"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the maximum number of milliseconds allowed between mouse clicks for a
        ///       double-click.
        ///    </para>
        /// </devdoc>
        public static int DoubleClickTime {
            get {
                return SafeNativeMethods.GetDoubleClickTime();
            }
        }

        /// <include file='doc\SystemInformation.uex' path='docs/doc[@for="SystemInformation.IconSpacingSize"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       the dimensions in pixels, of the grid used
        ///       to arrange icons in a large icon view.
        ///    </para>
        /// </devdoc>
        public static Size IconSpacingSize {
            get {
                return new Size(UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_CXICONSPACING),
                                UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_CYICONSPACING));
            }
        }

        /// <include file='doc\SystemInformation.uex' path='docs/doc[@for="SystemInformation.RightAlignedMenus"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether drop down menus should be right-aligned with
        ///       the corresponding menu bar item.
        ///    </para>
        /// </devdoc>
        public static bool RightAlignedMenus {
            get {
                return UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_MENUDROPALIGNMENT) != 0;
            }
        }

        /// <include file='doc\SystemInformation.uex' path='docs/doc[@for="SystemInformation.PenWindows"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the Microsoft Windows for Pen computing
        ///       extensions are installed.
        ///    </para>
        /// </devdoc>
        public static bool PenWindows {
            get {
                return UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_PENWINDOWS) != 0;
            }
        }

        /// <include file='doc\SystemInformation.uex' path='docs/doc[@for="SystemInformation.DbcsEnabled"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the operating system is capable of handling
        ///       double-byte (DBCS) characters.
        ///    </para>
        /// </devdoc>
        public static bool DbcsEnabled {
            get {
                return UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_DBCSENABLED) != 0;
            }
        }

        /// <include file='doc\SystemInformation.uex' path='docs/doc[@for="SystemInformation.MouseButtons"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the number of buttons on mouse.
        ///    </para>
        /// </devdoc>
        public static int MouseButtons {
            get {
                return UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_CMOUSEBUTTONS);
            }
        }

        /// <include file='doc\SystemInformation.uex' path='docs/doc[@for="SystemInformation.Secure"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether security is present on this operating system.
        ///    </para>
        /// </devdoc>
        public static bool Secure {
            get {
                Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "SensitiveSystemInformation Demanded");
                IntSecurity.SensitiveSystemInformation.Demand();
                return UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_SECURE) != 0;
            }
        }

        /// <include file='doc\SystemInformation.uex' path='docs/doc[@for="SystemInformation.Border3DSize"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the dimensions in pixels, of a 3-D
        ///       border.
        ///    </para>
        /// </devdoc>
        public static Size Border3DSize {
            get {
                return new Size(UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_CXEDGE),
                                UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_CYEDGE));
            }
        }

        /// <include file='doc\SystemInformation.uex' path='docs/doc[@for="SystemInformation.MinimizedWindowSpacingSize"]/*' />
        /// <devdoc>
        ///    <para>Gets the dimensions
        ///       in pixels, of
        ///       the grid into which minimized windows will be placed.</para>
        /// </devdoc>
        public static Size MinimizedWindowSpacingSize {
            get {
                return new Size(UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_CXMINSPACING),
                                UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_CYMINSPACING));
            }
        }

        /// <include file='doc\SystemInformation.uex' path='docs/doc[@for="SystemInformation.SmallIconSize"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       the recommended dimensions of a small icon in pixels.
        ///    </para>
        /// </devdoc>
        public static Size SmallIconSize {
            get {
                return new Size(UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_CXSMICON),
                                UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_CYSMICON));
            }
        }

        /// <include file='doc\SystemInformation.uex' path='docs/doc[@for="SystemInformation.ToolWindowCaptionHeight"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the height of
        ///       a small caption in pixels.
        ///    </para>
        /// </devdoc>
        public static int ToolWindowCaptionHeight {
            get {
                return UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_CYSMCAPTION);
            }
        }

        /// <include file='doc\SystemInformation.uex' path='docs/doc[@for="SystemInformation.ToolWindowCaptionButtonSize"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the
        ///       dimensions of small caption buttons in pixels.
        ///    </para>
        /// </devdoc>
        public static Size ToolWindowCaptionButtonSize {
            get {
                return new Size(UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_CXSMSIZE),
                                UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_CYSMSIZE));
            }
        }

        /// <include file='doc\SystemInformation.uex' path='docs/doc[@for="SystemInformation.MenuButtonSize"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       the dimensions in pixels, of menu bar buttons.
        ///    </para>
        /// </devdoc>
        public static Size MenuButtonSize {
            get {
                return new Size(UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_CXMENUSIZE),
                                UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_CYMENUSIZE));
            }
        }

        /// <include file='doc\SystemInformation.uex' path='docs/doc[@for="SystemInformation.ArrangeStartingPosition"]/*' />
        /// <devdoc>
        ///    <para>Gets flags specifying how the system arranges minimized windows.</para>
        /// </devdoc>
        public static ArrangeStartingPosition ArrangeStartingPosition {
            get {
                ArrangeStartingPosition mask = ArrangeStartingPosition.BottomLeft | ArrangeStartingPosition.BottomRight | ArrangeStartingPosition.Hide | ArrangeStartingPosition.TopLeft | ArrangeStartingPosition.TopRight;
                int compoundValue = UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_ARRANGE);
                return mask & (ArrangeStartingPosition) compoundValue;
            }
        }

        /// <include file='doc\SystemInformation.uex' path='docs/doc[@for="SystemInformation.ArrangeDirection"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets flags specifying how the system arranges minimized windows.
        ///    </para>
        /// </devdoc>
        public static ArrangeDirection ArrangeDirection {
            get {
                ArrangeDirection mask = ArrangeDirection.Down | ArrangeDirection.Left | ArrangeDirection.Right | ArrangeDirection.Up;
                int compoundValue = UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_ARRANGE);
                return mask & (ArrangeDirection) compoundValue;
            }
        }

        /// <include file='doc\SystemInformation.uex' path='docs/doc[@for="SystemInformation.MinimizedWindowSize"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the dimensions in pixels, of a normal minimized window.
        ///    </para>
        /// </devdoc>
        public static Size MinimizedWindowSize {
            get {
                return new Size(UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_CXMINIMIZED),
                                UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_CYMINIMIZED));
            }
        }

        /// <include file='doc\SystemInformation.uex' path='docs/doc[@for="SystemInformation.MaxWindowTrackSize"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the default maximum dimensions in pixels, of a
        ///       window that has a caption and sizing borders.
        ///    </para>
        /// </devdoc>
        public static Size MaxWindowTrackSize {
            get {
                return new Size(UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_CXMAXTRACK),
                                UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_CYMAXTRACK));
            }
        }

        /// <include file='doc\SystemInformation.uex' path='docs/doc[@for="SystemInformation.PrimaryMonitorMaximizedWindowSize"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the default dimensions, in pixels, of a maximized top-left window on the
        ///       primary monitor.
        ///    </para>
        /// </devdoc>
        public static Size PrimaryMonitorMaximizedWindowSize {
            get {
                return new Size(UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_CXMAXIMIZED),
                                UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_CYMAXIMIZED));
            }
        }

        /// <include file='doc\SystemInformation.uex' path='docs/doc[@for="SystemInformation.Network"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether this computer is connected to a network.
        ///    </para>
        /// </devdoc>
        public static bool Network {
            get {
                return(UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_NETWORK) & 0x00000001) != 0;
            }
        }

        internal static bool TerminalServerSession {
            get {
                return(UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_REMOTESESSION) & 0x00000001) != 0;
            }
        }



        /// <include file='doc\SystemInformation.uex' path='docs/doc[@for="SystemInformation.BootMode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value that specifies how the system was started.
        ///    </para>
        /// </devdoc>
        public static BootMode BootMode {
            get {
                Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "SensitiveSystemInformation Demanded");
                IntSecurity.SensitiveSystemInformation.Demand();
                return(BootMode) UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_CLEANBOOT);
            }
        }

        /// <include file='doc\SystemInformation.uex' path='docs/doc[@for="SystemInformation.DragSize"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the dimensions in pixels, of the rectangle that a drag operation
        ///       must extend to be considered a drag. The rectangle is centered on a drag
        ///       point.
        ///    </para>
        /// </devdoc>
        public static Size DragSize {
            get {
                return new Size(UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_CXDRAG),
                                UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_CYDRAG));
            }
        }

        /// <include file='doc\SystemInformation.uex' path='docs/doc[@for="SystemInformation.ShowSounds"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the user requires an application to present
        ///       information visually in situations where it would otherwise present the
        ///       information in audible form.
        ///    </para>
        /// </devdoc>
        public static bool ShowSounds {
            get {
                return UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_SHOWSOUNDS) != 0;
            }
        }

        /// <include file='doc\SystemInformation.uex' path='docs/doc[@for="SystemInformation.MenuCheckSize"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the
        ///       dimensions of the default size of a menu checkmark in pixels.
        ///    </para>
        /// </devdoc>
        public static Size MenuCheckSize {
            get {
                return new Size(UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_CXMENUCHECK),
                                UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_CYMENUCHECK));
            }
        }

        /// <include file='doc\SystemInformation.uex' path='docs/doc[@for="SystemInformation.MidEastEnabled"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value
        ///       indicating whether the system is enabled for Hebrew and Arabic languages.
        ///    </para>
        /// </devdoc>
        public static bool MidEastEnabled {
            get {
                return UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_MIDEASTENABLED) != 0;
            }
        }

        private static bool MultiMonitorSupport {
            get {
                if (!checkMultiMonitorSupport) {
                    checkMultiMonitorSupport = true;
                    multiMonitorSupport = (UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_CMONITORS) != 0);
                }
                return multiMonitorSupport;
            }
        }
        
        /// <include file='doc\SystemInformation.uex' path='docs/doc[@for="SystemInformation.NativeMouseWheelSupport"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the system natively supports the mouse wheel
        ///       in newer mice.
        ///    </para>
        /// </devdoc>
        public static bool NativeMouseWheelSupport {
            get {
                if (!checkNativeMouseWheelSupport) {
                    checkNativeMouseWheelSupport = true;
                    nativeMouseWheelSupport = (UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_MOUSEWHEELPRESENT) != 0);
                }
                return nativeMouseWheelSupport;
            }
        }


        /// <include file='doc\SystemInformation.uex' path='docs/doc[@for="SystemInformation.MouseWheelPresent"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether there is a mouse with a mouse wheel
        ///       installed on this machine.
        ///    </para>
        /// </devdoc>
        public static bool MouseWheelPresent {
            get {

                bool mouseWheelPresent = false;

                if (!NativeMouseWheelSupport) {
                    IntPtr hWndMouseWheel = IntPtr.Zero;

                    // Check for the MouseZ "service". This is a little app that generated the
                    // MSH_MOUSEWHEEL messages by monitoring the hardware. If this app isn't
                    // found, then there is no support for MouseWheels on the system.
                    //
                    hWndMouseWheel = UnsafeNativeMethods.FindWindow(NativeMethods.MOUSEZ_CLASSNAME, NativeMethods.MOUSEZ_TITLE);

                    if (hWndMouseWheel != IntPtr.Zero) {
                        mouseWheelPresent = true;
                    }
                }
                else {
                    mouseWheelPresent = (UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_MOUSEWHEELPRESENT) != 0);
                }
                return mouseWheelPresent;
            }
        }


        /// <include file='doc\SystemInformation.uex' path='docs/doc[@for="SystemInformation.VirtualScreen"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the
        ///       bounds of the virtual screen.
        ///    </para>
        /// </devdoc>
        public static Rectangle VirtualScreen {
            get {
                if (MultiMonitorSupport) {
                    return new Rectangle(UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_XVIRTUALSCREEN),
                                         UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_YVIRTUALSCREEN),
                                         UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_CXVIRTUALSCREEN),
                                         UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_CYVIRTUALSCREEN));
                }
                else {
                    Size size = PrimaryMonitorSize;
                    return new Rectangle(0, 0, size.Width, size.Height);
                }
            }
        }


        /// <include file='doc\SystemInformation.uex' path='docs/doc[@for="SystemInformation.MonitorCount"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the number of display monitors on the desktop.
        ///    </para>
        /// </devdoc>
        public static int MonitorCount {
            get {
                if (MultiMonitorSupport) {
                    return UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_CMONITORS);
                }
                else {
                    return 1;
                }
            }
        }


        /// <include file='doc\SystemInformation.uex' path='docs/doc[@for="SystemInformation.MonitorsSameDisplayFormat"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether all the display monitors have the
        ///       same color format.
        ///    </para>
        /// </devdoc>
        public static bool MonitorsSameDisplayFormat {
            get {
                if (MultiMonitorSupport) {
                    return UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_SAMEDISPLAYFORMAT) != 0;
                }
                else {
                    return true;
                }
            }
        }

        ////////////////////////////////////////////////////////////////////////////
        // Misc
        //


        /// <include file='doc\SystemInformation.uex' path='docs/doc[@for="SystemInformation.ComputerName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the computer name of the current system.
        ///    </para>
        /// </devdoc>
        public static string ComputerName {
            get {
                Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "SensitiveSystemInformation Demanded");
                IntSecurity.SensitiveSystemInformation.Demand();

                StringBuilder sb = new StringBuilder(256);
                UnsafeNativeMethods.GetComputerName(sb, new int[] {sb.Capacity});
                return sb.ToString();
            }
        }


        /// <include file='doc\SystemInformation.uex' path='docs/doc[@for="SystemInformation.UserDomainName"]/*' />
        /// <devdoc>
        ///    Gets the user's domain name.
        /// </devdoc>
        public static string UserDomainName {
            get {
                Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "SensitiveSystemInformation Demanded");
                IntSecurity.SensitiveSystemInformation.Demand();

                byte[] sid = new byte[1024];
                int sidLen = sid.Length;
                StringBuilder domainName = new StringBuilder(1024);
                int domainNameLen = domainName.Capacity;
                int peUse;

                bool success = UnsafeNativeMethods.LookupAccountName(null, UserName, sid, ref sidLen, domainName, ref domainNameLen, out peUse);
                if (!success)
                    throw new Win32Exception();

                return domainName.ToString();
            }
        }

        /// <include file='doc\SystemInformation.uex' path='docs/doc[@for="SystemInformation.UserInteractive"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the current process is running in user
        ///       interactive mode.
        ///    </para>
        /// </devdoc>
        public static bool UserInteractive {
            get {

                // SECREVIEW : The Environment.OSVersion property getter Demands the 
                //           : EnvironmentPermission(PermissionState.Unrestricted) however,
                //           : we aren't exposing any of the OSVersion information to the 
                //           : user, so we can safely Assert the permission.
                //           :
                //           : Be careful not to expose any information from this property
                //           : to the user.
                //
                IntSecurity.UnrestrictedEnvironment.Assert();

                try {
                    if (Environment.OSVersion.Platform == System.PlatformID.Win32NT) {
                        IntPtr hwinsta = IntPtr.Zero;

                        hwinsta = UnsafeNativeMethods.GetProcessWindowStation();
                        if (hwinsta != IntPtr.Zero && processWinStation != hwinsta) {
                            isUserInteractive = true;

                            int lengthNeeded = 0;
                            NativeMethods.USEROBJECTFLAGS flags = new NativeMethods.USEROBJECTFLAGS();

                            if (UnsafeNativeMethods.GetUserObjectInformation(new HandleRef(null, hwinsta), NativeMethods.UOI_FLAGS, flags, Marshal.SizeOf(flags), ref lengthNeeded)) {
                                if ((flags.dwFlags & NativeMethods.WSF_VISIBLE) == 0) {
                                    isUserInteractive = false;
                                }
                            }
                            processWinStation = hwinsta;
                        }
                    }
                    else {
                        isUserInteractive = true;
                    }
                }
                finally {
                    System.Security.CodeAccessPermission.RevertAssert();
                }

                return isUserInteractive;
            }
        }

        /// <include file='doc\SystemInformation.uex' path='docs/doc[@for="SystemInformation.UserName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the user name for the current thread, that is, the name of the
        ///       user currently logged onto the system.
        ///    </para>
        /// </devdoc>
        public static string UserName {
            get {
                Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "SensitiveSystemInformation Demanded");
                IntSecurity.SensitiveSystemInformation.Demand();

                StringBuilder sb = new StringBuilder(256);
                UnsafeNativeMethods.GetUserName(sb, new int[] {sb.Capacity});
                return sb.ToString();
            }
        }
        
        private static void EnsureSystemEvents() {
            if (!systemEventsAttached) {
                SystemEvents.UserPreferenceChanged += new UserPreferenceChangedEventHandler(SystemInformation.OnUserPreferenceChanged);
                systemEventsAttached = true;
            }
        }
        
        private static void OnUserPreferenceChanged(object sender, UserPreferenceChangedEventArgs pref) {
            systemEventsDirty = true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\tabalignment.cs ===
//------------------------------------------------------------------------------
// <copyright file="TabAlignment.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    using System.Drawing;
    using Microsoft.Win32;


    /// <include file='doc\TabAlignment.uex' path='docs/doc[@for="TabAlignment"]/*' />
    /// <devdoc>
    ///     Controls where the tabs will be located in a Tab Control.
    /// </devdoc>
    public enum TabAlignment {

        /// <include file='doc\TabAlignment.uex' path='docs/doc[@for="TabAlignment.Top"]/*' />
        /// <devdoc>
        ///     Tabs will be located across the top of the control.
        /// </devdoc>
        Top = 0,

        /// <include file='doc\TabAlignment.uex' path='docs/doc[@for="TabAlignment.Bottom"]/*' />
        /// <devdoc>
        ///     Tabs will be located across the bottom of the control.
        /// </devdoc>
        Bottom = 1,

        /// <include file='doc\TabAlignment.uex' path='docs/doc[@for="TabAlignment.Left"]/*' />
        /// <devdoc>
        ///     Tabs will be located along the left edge of the control.
        /// </devdoc>
        Left = 2,

        /// <include file='doc\TabAlignment.uex' path='docs/doc[@for="TabAlignment.Right"]/*' />
        /// <devdoc>
        ///     Tabs will be located along the right edge of the control.
        /// </devdoc>
        Right = 3,

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\tabappearance.cs ===
//------------------------------------------------------------------------------
// <copyright file="TabAppearance.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    using System.Drawing;
    using Microsoft.Win32;


    /// <include file='doc\TabAppearance.uex' path='docs/doc[@for="TabAppearance"]/*' />
    /// <devdoc>
    ///     The various tab controls will let you configure their appearance.  This
    ///     enumeration contains the possible values.
    /// </devdoc>
    public enum TabAppearance {

        /// <include file='doc\TabAppearance.uex' path='docs/doc[@for="TabAppearance.Normal"]/*' />
        /// <devdoc>
        ///     Indicates that the tabs look like normal tabs typically seen in Property
        ///     page type situations.
        /// </devdoc>
        Normal = 0,

        /// <include file='doc\TabAppearance.uex' path='docs/doc[@for="TabAppearance.Buttons"]/*' />
        /// <devdoc>
        ///     Indicates that the tabs look like buttons as seen on the taskbar found
        ///     in Windows 95 or Windows NT.
        /// </devdoc>
        Buttons = 1,

        /// <include file='doc\TabAppearance.uex' path='docs/doc[@for="TabAppearance.FlatButtons"]/*' />
        /// <devdoc>
        ///     Indicates that buttons should be draw flat instead of like regular
        ///     windows pushbuttons.
        /// </devdoc>
        FlatButtons = 2,

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\sysinfoform.cs ===
//------------------------------------------------------------------------------
// <copyright file="SysInfoForm.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   SysInfoForm.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
#if SECURITY_DIALOG
namespace System.Windows.Forms {

    using System;
    using System.Diagnostics;
    using System.Drawing;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.IO;
    using System.Xml;
    using System.Windows.Forms;
    using System.Reflection;
    using System.Security;
    using System.Security.Permissions;
    using System.Globalization;
    
    /// <include file='doc\SysInfoForm.uex' path='docs/doc[@for="SysInfoForm"]/*' />
    /// <devdoc>
    ///    Summary description for SysInfoForm.
    /// </devdoc>
    internal class SysInfoForm : Form {
        static Switch[] switches;

        /// <include file='doc\SysInfoForm.uex' path='docs/doc[@for="SysInfoForm.components"]/*' />
        /// <devdoc> 
        ///    Required by the Win Forms designer 
        /// </devdoc>
        Container components;
        ColumnHeader codeBaseColumn;
        ColumnHeader versionColumn;
        ColumnHeader fileVersionColumn;
        ColumnHeader asmNameColumn;
        ColumnHeader switchNameColumn;
        ColumnHeader displayNameColumn;
        ListView loadedAssemblyList;
        ListView switchesList;
        Button closeButton;
        TabPage appInfo;
        TabPage sysInfo;
        TabPage secInfo;
        TabPage switchInfo;
        TabPage bugReportInfo;
        TabControl tabControl1;
        PropertyGrid appProps;
        Label bugReportLabel;
        Label securityLabel;
        Label switchLabel;
        TextBox bugReportDescription;
        CheckBox includeSystemInformation;
        CheckBox includeApplicationInformation;
        Panel bugReportPanel;
        Button saveBugReport;
        Button submitBugReport;
        bool windowIsRestricted = false;

        private static Switch[] GetSwitchesFromLoadedAssemblies() {
            ArrayList list = new ArrayList();
            Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();

            new ReflectionPermission(PermissionState.Unrestricted).Assert();
            try {
                foreach (Assembly assembly in assemblies) {
                    Module[] modules = assembly.GetLoadedModules();

                    foreach (Module module in modules) {

                        if (module != null) {
                            foreach (Type type in module.GetTypes()) {

                                if (type != null) {
                                    MemberInfo[] members = type.FindMembers(MemberTypes.Field, 
                                                                            BindingFlags.Static 
                                                                            | BindingFlags.Public 
                                                                            | BindingFlags.NonPublic, 
                                                                            new MemberFilter(Filter), 
                                                                            null);

                                    foreach (MemberInfo member in members) {
                                        if (member != null && member is FieldInfo) {
                                            FieldInfo field = (FieldInfo) member;
                                            object value = field.GetValue(null);
                                            if (value != null)
                                                list.Add(value);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            finally {
                CodeAccessPermission.RevertAssert();
            }
            return(Switch[]) list.ToArray(typeof(Switch));
        }

        private static bool Filter(MemberInfo member, object criteria) {
            if (member == null) {
                return false;
            }
            FieldInfo field = (FieldInfo)member;            
            if (field.FieldType == null) {
                return false;
            }
            return(field.FieldType.IsSubclassOf(typeof(Switch)));
        }

        public SysInfoForm(bool windowIsRestricted) {
            this.windowIsRestricted = windowIsRestricted;

            // Required for Win Form Designer support
            InitializeComponent();

            MinimumSize = Size;
            if (windowIsRestricted) {
                securityLabel.Text = SR.GetString(SR.SecurityRestrictedText);
            }
            else {
                securityLabel.Text = SR.GetString(SR.SecurityUnrestrictedText);
            }
        }

        /// <include file='doc\SysInfoForm.uex' path='docs/doc[@for="SysInfoForm.Dispose"]/*' />
        /// <devdoc>
        ///    Clean up any resources being used
        /// </devdoc>
        protected override void Dispose(bool disposing) {
            if (disposing) {
                components.Dispose();
            }
            base.Dispose(disposing);
        }


        private void PopulateAssemblyInfo() {
            foreach (Assembly asm in AppDomain.CurrentDomain.GetAssemblies()) {
                try {
                    AssemblyName name = asm.GetName();
                    string fileVer = "n/a";
                    if (name.EscapedCodeBase != null && name.EscapedCodeBase.Length > 0) {
                        Uri codeBase = new Uri(name.EscapedCodeBase);
                        if (codeBase.Scheme == "file") {
                            fileVer = FileVersionInfo.GetVersionInfo(NativeMethods.GetLocalPath(name.EscapedCodeBase)).FileVersion;
                        }
                    }
                    ListViewItem item = new ListViewItem(new string[] {
                                                             name.Name,
                                                             fileVer,
                                                             name.Version.ToString(),
                                                             name.EscapedCodeBase});
                    loadedAssemblyList.Items.Add(item);
                }
                catch (Exception) {
                    // ignore any exceptions... this dialog should never cause a fault...
                    //
                    loadedAssemblyList.Items.Add(new ListViewItem(new string[] {asm.GetName().Name, "Exception loading information"}));
                }
            }
        }

        private void PopulateApplicationInfo() {
            appProps.SelectedObject = new AppInfo();
        }

        private void WriteBugReport(TextWriter writer) {
            XmlTextWriter xml = new XmlTextWriter(writer);
            xml.Formatting = Formatting.Indented;

            xml.WriteStartElement("bug"); {
                xml.WriteAttributeString("product", ".NET Frameworks SDK");

                xml.WriteStartElement("problem"); {
                    xml.WriteString(bugReportDescription.Text);
                }
                xml.WriteEndElement();
                
                if (includeApplicationInformation.Checked) {
                    xml.WriteStartElement("assemblies"); {
                        foreach (Assembly asm in AppDomain.CurrentDomain.GetAssemblies()) {
                            AssemblyName name = asm.GetName();
                            xml.WriteStartElement("assembly"); {
                                xml.WriteAttributeString("name", name.Name);
                                xml.WriteAttributeString("codebase", name.CodeBase);
                                xml.WriteAttributeString("version", name.Version.ToString());
                                
                                string fileVer = "n/a";
                                if (name.EscapedCodeBase != null && name.EscapedCodeBase.Length > 0) {
                                    Uri codeBase = new Uri(name.EscapedCodeBase);
                                    if (codeBase.Scheme == "file") {
                                        fileVer = FileVersionInfo.GetVersionInfo(NativeMethods.GetLocalPath(name.EscapedCodeBase)).FileVersion;
                                    }
                                }
                                xml.WriteAttributeString("win32version", fileVer);
                            }
                            xml.WriteEndElement();
                        }
                    }
                    xml.WriteEndElement();
                }

                if (includeSystemInformation.Checked) {
                    xml.WriteStartElement("system"); {
                        xml.WriteAttributeString("os", Environment.OSVersion.Platform.ToString("G") + " " + Environment.OSVersion.Version.ToString());
                    }
                    xml.WriteEndElement();
                }
            }
            xml.WriteEndElement();
        }

        private void SubmitBugReport(object sender, EventArgs e) {
            UnsafeNativeMethods.ShellExecute(NativeMethods.NullHandleRef, null, SR.GetString(SR.SecuritySubmitBugUrl), null, null, NativeMethods.SW_NORMAL);
        }

        private void SaveBugReport(object sender, EventArgs e) {
            SaveFileDialog dialog = new SaveFileDialog();
            dialog.Filter = SR.GetString(SR.SecuritySaveFilter);
            if (dialog.ShowDialog() == DialogResult.OK) {
                Stream output = dialog.OpenFile();
                StreamWriter writer = new StreamWriter(output);
                try {
                    WriteBugReport(writer);
                }
                finally {
                    writer.Flush();
                    writer.Close();
                }
            }
        }

        private void PopulateSwitchesInfo() {

            // grab it in a local in case assembly load causes static to null out
            // Until we start listening to assembly load events, we should not cache!
            Switch[] switchesLocal = null;  // switches
            if (switchesLocal == null) {
                switchesLocal = GetSwitchesFromLoadedAssemblies();
                switches = switchesLocal;
                Array.Sort(switchesLocal, new SwitchSorter());
            }

            foreach (Switch sw in switchesLocal) {
                bool value;
                if (sw is TraceSwitch)
                    value = ((TraceSwitch)sw).Level > TraceLevel.Off;
                else if (sw is BooleanSwitch)
                    value =  ((BooleanSwitch)sw).Enabled;
                else
                    continue; 

                ListViewItem item = new SwitchItem(sw);
                item.Checked = value;
                switchesList.Items.Add(item);
            }
        }

        private void SwitchChecked(object sender, ItemCheckEventArgs e) {
            SwitchItem item = (SwitchItem)switchesList.Items[e.Index];
            Switch sw = item.Value;
            bool value = e.NewValue == CheckState.Checked;
            if (sw is TraceSwitch) {
                ((TraceSwitch)sw).Level = (value ? TraceLevel.Verbose : TraceLevel.Off);
            }
            else if (sw is BooleanSwitch) {
                ((BooleanSwitch)sw).Enabled = value;
            }
        }

        void TabSelectionChanged(object sender, EventArgs e) {
            if (tabControl1.SelectedTab == switchInfo) {
                if (switchesList.Items.Count == 0) {
                    try {
                        PopulateSwitchesInfo();
                    }
                    catch {
                    }
                }
            }
            else if (tabControl1.SelectedTab == sysInfo) {
                if (loadedAssemblyList.Items.Count == 0) {
                    try {
                        PopulateAssemblyInfo();
                    }
                    catch {
                    }
                }
            }
            else if (tabControl1.SelectedTab == appInfo) {
                if (appProps.SelectedObject == null) {
                    try {
                        PopulateApplicationInfo();
                    }
                    catch {
                    }
                }
            }
        }

        /// <include file='doc\SysInfoForm.uex' path='docs/doc[@for="SysInfoForm.InitializeComponent"]/*' />
        /// <devdoc>
        ///    Required method for Designer support - do not modify
        ///    the contents of this method with an editor
        /// </devdoc>
        private void InitializeComponent() {
            this.components = new Container();
            this.sysInfo = new TabPage();
            this.versionColumn = new ColumnHeader();
            this.fileVersionColumn = new ColumnHeader();
            this.loadedAssemblyList = new ListView();
            this.switchesList = new ListView();
            this.appInfo = new TabPage();
            this.tabControl1 = new TabControl();
            this.asmNameColumn = new ColumnHeader();
            this.codeBaseColumn = new ColumnHeader();
            this.switchNameColumn = new ColumnHeader();
            this.displayNameColumn = new ColumnHeader();
            this.secInfo = new TabPage();
            this.bugReportInfo = new TabPage();
            this.bugReportLabel = new Label();
            this.switchInfo = new TabPage();
            this.closeButton = new Button();
            this.appProps = new PropertyGrid();
            this.securityLabel = new Label();
            this.bugReportDescription = new TextBox();
            this.includeSystemInformation = new CheckBox();
            this.includeApplicationInformation = new CheckBox();
            this.saveBugReport = new Button();
            this.submitBugReport = new Button();
            this.switchLabel = new Label();
            this.bugReportPanel = new Panel();


            //@design this.TrayLargeIcon = false;
            //@design this.TrayAutoArrange = true;
            //@design this.TrayHeight = 0;
            //@design this.GridSize = new System.Drawing.Size(4, 4);
            this.Text = SR.GetString(SR.SecurityAboutDialog);
            this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
            this.ClientSize = new System.Drawing.Size(442, 273);
            this.MinimizeBox = false;
            this.MaximizeBox = false;
            this.ControlBox = false;
            this.CancelButton = closeButton;
            this.Font = new Font("Tahoma", 8);

            sysInfo.Size = new System.Drawing.Size(428, 210);
            sysInfo.TabIndex = 1;
            sysInfo.Text = SR.GetString(SR.SecurityAssembliesTab);

            versionColumn.Text = SR.GetString(SR.SecurityVersionColumn);
            versionColumn.Width = 100;
            versionColumn.TextAlign = HorizontalAlignment.Left;

            fileVersionColumn.Text = SR.GetString(SR.SecurityFileVersionColumn);
            fileVersionColumn.Width = 100;
            fileVersionColumn.TextAlign = HorizontalAlignment.Left;

            loadedAssemblyList.Size = new System.Drawing.Size(428, 210);
            loadedAssemblyList.Dock = DockStyle.Fill;
            loadedAssemblyList.TabIndex = 0;
            loadedAssemblyList.FullRowSelect = true;
            loadedAssemblyList.View = View.Details;
            loadedAssemblyList.Columns.Clear();
            loadedAssemblyList.Columns.AddRange(new ColumnHeader[] {asmNameColumn,
                fileVersionColumn,
                versionColumn,
                codeBaseColumn});

            switchLabel.Size = new Size(428, 25);
            switchLabel.Dock = DockStyle.Bottom;
            switchLabel.Text = SR.GetString(SR.SecuritySwitchLabel);

            switchesList.Size = new System.Drawing.Size(428, 210);
            switchesList.Dock = DockStyle.Fill;
            switchesList.ItemCheck += new ItemCheckEventHandler(SwitchChecked);
            switchesList.TabIndex = 0;
            switchesList.CheckBoxes = true;
            switchesList.FullRowSelect = true;
            switchesList.View = View.Details;
            switchesList.Columns.Clear();
            switchesList.Columns.AddRange(new ColumnHeader[] {switchNameColumn,
                displayNameColumn});

            appInfo.Size = new System.Drawing.Size(428, 210);
            appInfo.TabIndex = 2;
            appInfo.Text = SR.GetString(SR.SecurityApplication);
            appInfo.DockPadding.All = 2;

            switchInfo.Size = new System.Drawing.Size(428, 210);
            switchInfo.TabIndex = 4;
            switchInfo.Text = SR.GetString(SR.SecuritySwitchesTab);
            
            bugReportDescription.Multiline = true;
            bugReportDescription.Dock = DockStyle.Fill;
            bugReportDescription.WordWrap = true;

            bugReportLabel.Dock = DockStyle.Top;
            bugReportLabel.Size = new System.Drawing.Size(428, 36);
            bugReportLabel.Text = SR.GetString(SR.SecurityBugReportLabel);

            includeSystemInformation.Checked = true;
            includeSystemInformation.Dock = DockStyle.Bottom;
            includeSystemInformation.FlatStyle = FlatStyle.System;
            includeSystemInformation.Text = SR.GetString(SR.SecurityIncludeSysInfo);

            includeApplicationInformation.Checked = true;
            includeApplicationInformation.Dock = DockStyle.Bottom;
            includeApplicationInformation.FlatStyle = FlatStyle.System;
            includeApplicationInformation.Text = SR.GetString(SR.SecurityIncludeAppInfo);
            
            saveBugReport.Text = SR.GetString(SR.SecuritySaveBug);
            saveBugReport.Location = new Point(2, 2);
            saveBugReport.FlatStyle = FlatStyle.System;
            saveBugReport.Size = new Size(75, 23);
            saveBugReport.Click += new EventHandler(SaveBugReport);

            submitBugReport.Text = SR.GetString(SR.SecuritySubmitBug);
            submitBugReport.Location = new Point(79, 2);
            submitBugReport.FlatStyle = FlatStyle.System;
            submitBugReport.Size = new Size(75, 23);
            submitBugReport.Click += new EventHandler(SubmitBugReport);

            bugReportPanel.Dock = DockStyle.Bottom;
            bugReportPanel.Size = new Size(428, 27);

            appProps.Dock = DockStyle.Fill;
            appProps.ToolbarVisible = false;

            tabControl1.Location = new System.Drawing.Point(4, 4);
            tabControl1.Size = new System.Drawing.Size(436, 236);
            tabControl1.Anchor = AnchorStyles.Left | AnchorStyles.Right | AnchorStyles.Top | AnchorStyles.Bottom;
            tabControl1.SelectedIndex = 0;
            tabControl1.TabIndex = 0;
            tabControl1.SelectedIndexChanged += new EventHandler(TabSelectionChanged);

            asmNameColumn.Text = SR.GetString(SR.SecurityAsmNameColumn);
            asmNameColumn.Width = 150;
            asmNameColumn.TextAlign = HorizontalAlignment.Left;

            switchNameColumn.Text = SR.GetString(SR.SecuritySwitchNameColumn);
            switchNameColumn.Width = 150;
            switchNameColumn.TextAlign = HorizontalAlignment.Left;

            displayNameColumn.Text = SR.GetString(SR.SecuritySwitchDescrColumn);
            displayNameColumn.Width = 300;
            displayNameColumn.TextAlign = HorizontalAlignment.Left;

            codeBaseColumn.Text = SR.GetString(SR.SecurityCodeBaseColumn);
            codeBaseColumn.Width = 400;
            codeBaseColumn.TextAlign = HorizontalAlignment.Left;

            secInfo.Size = new System.Drawing.Size(428, 210);
            secInfo.TabIndex = 0;
            secInfo.Text = SR.GetString(SR.SecurityInfoTab);

            bugReportInfo.Size = new System.Drawing.Size(428, 210);
            bugReportInfo.TabIndex = 0;
            bugReportInfo.Text = SR.GetString(SR.SecurityBugReportTab);

            securityLabel.Dock = DockStyle.Fill;

            closeButton.Size = new System.Drawing.Size(75, 23);
            closeButton.FlatStyle = FlatStyle.System;
            closeButton.TabIndex = 1;
            closeButton.Location = new System.Drawing.Point(344, 248);
            closeButton.Text = SR.GetString(SR.SecurityClose);
            closeButton.Anchor = AnchorStyles.Right | AnchorStyles.Bottom;
            closeButton.DialogResult = DialogResult.OK;

            this.Controls.Add(closeButton);
            this.Controls.Add(tabControl1);
            switchInfo.Controls.Add(switchesList);
            switchInfo.Controls.Add(switchLabel);
            sysInfo.Controls.Add(loadedAssemblyList);
            secInfo.Controls.Add(securityLabel);
            appInfo.Controls.Add(appProps);
            bugReportPanel.Controls.Add(saveBugReport);
            bugReportPanel.Controls.Add(submitBugReport);
            bugReportInfo.Controls.Add(bugReportDescription);
            bugReportInfo.Controls.Add(bugReportLabel);
            bugReportInfo.Controls.Add(includeSystemInformation);
            bugReportInfo.Controls.Add(includeApplicationInformation);
            bugReportInfo.Controls.Add(bugReportPanel);
            tabControl1.Controls.Add(secInfo);
            tabControl1.Controls.Add(appInfo);
            tabControl1.Controls.Add(sysInfo);
            tabControl1.Controls.Add(switchInfo);
            tabControl1.Controls.Add(bugReportInfo);
        }

        [DefaultProperty("CompanyName")]
        public class AppInfo {
            AssemblyName assemblyName;

            public AppInfo() {
                assemblyName = Assembly.GetEntryAssembly().GetName();
            }

            [Category("Entry Assembly")]
            public Version Version {
                get {
                    return assemblyName.Version;
                }
            }

            [Category("Entry Assembly")]
            public string Name {
                get {
                    return assemblyName.Name;
                }
            }

            [Category("Entry Assembly")]
            public string CodeBase {
                get {
                    return assemblyName.CodeBase;
                }
            }

            [Category("Directories")]
            public string MyDocuments {
                get {
                    return Environment.GetFolderPath(Environment.SpecialFolder.Personal);
                }
            }

            [Category("Directories")]
            public string UserAppDataPath {
                get {
                    return Application.UserAppDataPath;
                }
            }

            [Category("Directories")]
            public string CommonUserAppDataPath {
                get {
                    return Application.CommonAppDataPath;
                }
            }

            [Category("Directories")]
            public string LocalUserAppDataPath {
                get {
                    return Application.LocalUserAppDataPath;
                }
            }

            [Category("Application")]
            public string CompanyName {
                get {
                    return Application.CompanyName;
                }
            }

            [Category("Directories")]
            public string AppBase {
                get {
                    return AppDomain.CurrentDomain.SetupInformation.ApplicationBase;
                }
            }

            [Category("Application")]
            public string ConfigurationFile {
                get {
                    return AppDomain.CurrentDomain.SetupInformation.ConfigurationFile;
                }
            }

            [Category("Application")]
            public string ProductName {
                get {
                    return Application.ProductName;
                }
            }

            [Category("Application")]
            public string ProductVersion {
                get {
                    return Application.ProductVersion;
                }
            }

            [Category("Startup")]
            public string CommandLine {
                get {
                    return Environment.CommandLine;
                }
            }

            [Category("Startup")]
            public string[] CommandLineArgs {
                get {
                    return Environment.GetCommandLineArgs();
                }
            }

            [Category("Startup")]
            public string StartupPath {
                get {
                    return Application.StartupPath;
                }
            }

            [Category("Application")]
            public string ExecutablePath {
                get {
                    return Application.ExecutablePath;
                }
            }
        }


        class SwitchSorter : IComparer {
            public int Compare(object x, object y) {
                return String.Compare(((Switch)x).DisplayName, ((Switch)y).DisplayName, false, CultureInfo.InvariantCulture);
            }
        }

        class SwitchItem : ListViewItem {
            Switch value;

            internal SwitchItem(Switch value) : base(new string[] {value.DisplayName, value.Description}) {
                this.value = value;
            }

            public Switch Value {
                get {
                    return value;
                }
            }

        }
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\tabcontrol.cs ===
//------------------------------------------------------------------------------
// <copyright file="TabControl.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */



namespace System.Windows.Forms {
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Configuration.Assemblies;
    using Microsoft.Win32;
    using System.Diagnostics;
    using System.Drawing;
    using System.Runtime.InteropServices;
    using System.Runtime.Remoting;
    using System.Runtime.Serialization.Formatters;
    using System.Security;
    using System.Security.Permissions;
    using System.Windows.Forms;

    /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl"]/*' />
    /// <devdoc>
    ///     The TabControl.  This control has a lot of the functionality of a TabStrip
    ///     but manages a list of TabPages which are the 'pages' that appear on each tab.
    /// </devdoc>
    [
    DefaultProperty("TabPages"),
    DefaultEvent("SelectedIndexChanged"),
    Designer("System.Windows.Forms.Design.TabControlDesigner, " + AssemblyRef.SystemDesign)
    ]
    public class TabControl : Control {

        private static readonly Size DEFAULT_ITEMSIZE = Size.Empty;
        private static readonly Point DEFAULT_PADDING = new Point(6, 3);

        //properties
        private TabPageCollection tabCollection;
        private TabAlignment alignment         = TabAlignment.Top;
        private TabDrawMode  drawMode          = TabDrawMode.Normal;
        private bool hotTrack                   = false;
        private ImageList imageList                = null;
        private Size itemSize                     = DEFAULT_ITEMSIZE;
        private bool multiline                  = false;
        private Point padding                      = DEFAULT_PADDING;
        private bool showToolTips               = false;
        private TabSizeMode   sizeMode         = TabSizeMode.Normal;
        private TabAppearance appearance       = TabAppearance.Normal;
        private Rectangle cachedDisplayRect        = Rectangle.Empty;
        private bool UISelection                = false;
        private int selectedIndex = -1;
        
        //subhag
        private bool getTabRectfromItemSize = false;
        private bool fromCreateHandles = false;

        //events
        private EventHandler onSelectedIndexChanged;
        private DrawItemEventHandler onDrawItem;

        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.tabBaseReLayoutMessage"]/*' />
        /// <devdoc>
        ///     This message is posted by the control to itself after a TabPage is
        ///     added to it.  On certain occasions, after items are added to a
        ///     TabControl in quick succession, TCM_ADJUSTRECT calls return the wrong
        ///     display rectangle.  When the message is received, the control calls
        ///     updateTabSelection() to layout the TabPages correctly.
        /// </devdoc>
        /// <internalonly/>
        private readonly int tabBaseReLayoutMessage = SafeNativeMethods.RegisterWindowMessage(Application.WindowMessagesVersion + "_TabBaseReLayout");

        //state
        private TabPage[] tabPages;
        private int tabPageCount;

        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.TabControl"]/*' />
        /// <devdoc>
        ///     Constructs a TabBase object, usually as the base class for a TabStrip or TabControl.
        /// </devdoc>
        public TabControl()
        : base() {
            tabCollection = new TabPageCollection(this);
            SetStyle(ControlStyles.UserPaint, false);
        }

        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.Alignment"]/*' />
        /// <devdoc>
        ///     Returns on what area of the control the tabs reside on (A TabAlignment value).
        ///     The possibilities are Top (the default), Bottom, Left, and Right.  When alignment
        ///     is left or right, the multiline property is ignored and multiline is implicitly on.
        ///     If the alignment is anything other than top, TabAppearance.FlatButtons degenerates
        ///     to TabAppearance.Buttons.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        Localizable(true),
        DefaultValue(TabAlignment.Top),
        RefreshProperties(RefreshProperties.All),
        SRDescription(SR.TabBaseAlignmentDescr)
        ]
        public TabAlignment Alignment {
            get {
                return alignment;
            }

            set {
                if (this.alignment != value) {
                    if (!Enum.IsDefined(typeof(TabAlignment), value)) {
                        throw new InvalidEnumArgumentException("value", (int)value, typeof(TabAlignment));
                    }

                    this.alignment = value;
                    if (this.alignment == TabAlignment.Left || this.alignment == TabAlignment.Right)
                        multiline = true;
                    RecreateHandle();
                }
            }
        }

        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.Appearance"]/*' />
        /// <devdoc>
        ///     Indicates whether the tabs in the tabstrip look like regular tabs, or if they look 
        ///     like butttons as seen in the Windows 95 taskbar.
        ///     If the alignment is anything other than top, TabAppearance.FlatButtons degenerates
        ///     to TabAppearance.Buttons.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        Localizable(true),
        DefaultValue(TabAppearance.Normal),
        SRDescription(SR.TabBaseAppearanceDescr)
        ]
        public TabAppearance Appearance {
            get {
                if (appearance == TabAppearance.FlatButtons && alignment != TabAlignment.Top) {
                    return TabAppearance.Buttons;
                }
                else {
                    return appearance;
                }
            }

            set {
                if (this.appearance != value) {
                    if (!Enum.IsDefined(typeof(TabAppearance), value)) {
                        throw new InvalidEnumArgumentException("value", (int)value, typeof(TabAppearance));
                    }

                    this.appearance = value;
                    UpdateStyles();
                    
                    // When switching appearance to FlatButtons, it seems that a handle recreate is necessary
                    // to ensure consistent appearance.
                    //
                    if (value == TabAppearance.FlatButtons) {
                        RecreateHandle();
                    }
                }
            }
        }



        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.BackColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override Color BackColor {
            get {
                //The tab control can only be rendered in 1 color: System's Control color.
                //So, always return this value... otherwise, we're inheriting the forms backcolor
                //and passing it on to the pab pages.
                return SystemColors.Control;
            }
            set {
            }
        }

        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.BackColorChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler BackColorChanged {
            add {
                base.BackColorChanged += value;
            }
            remove {
                base.BackColorChanged -= value;
            }
        }

        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.BackgroundImage"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override Image BackgroundImage {
            get {
                return base.BackgroundImage;
            }
            set {
                base.BackgroundImage = value;
            }
        }
        
        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.BackgroundImageChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler BackgroundImageChanged {
            add {
                base.BackgroundImageChanged += value;
            }
            remove {
                base.BackgroundImageChanged -= value;
            }
        }

        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.DefaultSize"]/*' />
        /// <devdoc>
        ///     Deriving classes can override this to configure a default size for their control.
        ///     This is more efficient than setting the size in the control's constructor.
        /// </devdoc>
        protected override Size DefaultSize {
            get {
                return new Size(200, 100);
            }
        }

        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.ForeColor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override Color ForeColor {
            get {
                return base.ForeColor;
            }
            set {
                base.ForeColor = value;
            }
        }

        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.ForeColorChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler ForeColorChanged {
            add {
                base.ForeColorChanged += value;
            }
            remove {
                base.ForeColorChanged -= value;
            }
        }

        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.CreateParams"]/*' />
        /// <devdoc>
        ///     Returns the parameters needed to create the handle.  Inheriting classes
        ///     can override this to provide extra functionality.  They should not,
        ///     however, forget to call base.getCreateParams() first to get the struct
        ///     filled up with the basic info.
        /// </devdoc>
        /// <internalonly/>
        protected override CreateParams CreateParams {
            [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
            get {
                CreateParams cp = base.CreateParams;
                cp.ClassName = NativeMethods.WC_TABCONTROL;

                // set up window styles
                //
                if (multiline == true) cp.Style |= NativeMethods.TCS_MULTILINE;
                if (drawMode == TabDrawMode.OwnerDrawFixed) cp.Style |= NativeMethods.TCS_OWNERDRAWFIXED;
                if (showToolTips && !DesignMode) {
                    cp.Style |= NativeMethods.TCS_TOOLTIPS;
                }

                if (alignment == TabAlignment.Bottom ||
                    alignment == TabAlignment.Right)
                    cp.Style |= NativeMethods.TCS_BOTTOM;

                if (alignment == TabAlignment.Left ||
                    alignment == TabAlignment.Right)
                    cp.Style |= NativeMethods.TCS_VERTICAL | NativeMethods.TCS_MULTILINE;

                if (hotTrack) {
                    cp.Style |= NativeMethods.TCS_HOTTRACK;
                }

                if (appearance == TabAppearance.Normal)
                    cp.Style |= NativeMethods.TCS_TABS;
                else {
                    cp.Style |= NativeMethods.TCS_BUTTONS;
                    if (appearance == TabAppearance.FlatButtons && alignment == TabAlignment.Top)
                        cp.Style |= NativeMethods.TCS_FLATBUTTONS;
                }

                switch (sizeMode) {
                    case TabSizeMode.Normal:
                        cp.Style |= NativeMethods.TCS_RAGGEDRIGHT;
                        break;
                    case TabSizeMode.FillToRight:
                        cp.Style |= NativeMethods.TCS_RIGHTJUSTIFY;
                        break;
                    case TabSizeMode.Fixed:
                        cp.Style |= NativeMethods.TCS_FIXEDWIDTH;
                        break;
                }

                return cp;
            }
        }

        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.DisplayRectangle"]/*' />
        /// <devdoc>
        ///     The rectangle that represents the Area of the tab strip not
        ///     taken up by the tabs, borders, or anything else owned by the Tab.  This
        ///     is typically the rectangle you want to use to place the individual
        ///     children of the tab strip.
        /// </devdoc>
        public override Rectangle DisplayRectangle {
            get {

                // Null out cachedDisplayRect whenever we do anything to change it...
                //
                if (!cachedDisplayRect.IsEmpty)
                    return cachedDisplayRect;

                Rectangle bounds = Bounds;
                NativeMethods.RECT rect = NativeMethods.RECT.FromXYWH(bounds.X, bounds.Y, bounds.Width, bounds.Height);

                // We force a handle creation here, because otherwise the DisplayRectangle will be wildly inaccurate
                //
                if (!IsHandleCreated) {
                    CreateHandle();
                }
                SendMessage(NativeMethods.TCM_ADJUSTRECT, 0, ref rect);
                
                Rectangle r = Rectangle.FromLTRB(rect.left, rect.top, rect.right, rect.bottom);

                Point p = this.Location;
                r.X -= p.X;
                r.Y -= p.Y;

                cachedDisplayRect = r;
                return r;
            }
        }


        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.DrawMode"]/*' />
        /// <devdoc>
        ///     The drawing mode of the tabs in the tab strip.  This will indicate
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(TabDrawMode.Normal),
        SRDescription(SR.TabBaseDrawModeDescr)
        ]
        public TabDrawMode DrawMode {
            get {
                return drawMode;
            }

            set {
                if (!Enum.IsDefined(typeof(TabDrawMode), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(TabDrawMode));
                }

                if (drawMode != value) {
                    drawMode = value;
                    RecreateHandle();
                }
            }
        }

        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.HotTrack"]/*' />
        /// <devdoc>
        ///     Indicates whether the tabs visually change when the mouse passes over them.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(false),
        SRDescription(SR.TabBaseHotTrackDescr)
        ]
        public bool HotTrack {
            get {
                return hotTrack;
            }

            set {
                if (this.hotTrack != value) {
                    this.hotTrack = value;
                    if (IsHandleCreated) {
                        RecreateHandle();
                    }
                }
            }
        }

        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.ImageList"]/*' />
        /// <devdoc>
        ///     Returns the imageList the control points at.  This is where tabs that have imageIndex
        ///     set will get there images from.
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        DefaultValue(null),
        SRDescription(SR.TabBaseImageListDescr)
        ]
        public ImageList ImageList {
            get {
                return imageList;
            }
            set {
                if (this.imageList != value) {
                    EventHandler recreateHandler = new EventHandler(ImageListRecreateHandle);
                    EventHandler disposedHandler = new EventHandler(DetachImageList);

                    if (imageList != null) {
                        imageList.RecreateHandle -= recreateHandler;
                        imageList.Disposed -= disposedHandler;
                    }

                    this.imageList = value;
                    IntPtr handle = (value != null) ? value.Handle : IntPtr.Zero;
                    if (IsHandleCreated)
                        SendMessage(NativeMethods.TCM_SETIMAGELIST, IntPtr.Zero, handle);

                    if (value != null) {
                        value.RecreateHandle += recreateHandler;
                        value.Disposed += disposedHandler;
                    }
                }
            }
        }

        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.ItemSize"]/*' />
        /// <devdoc>
        ///     By default, tabs will automatically size themselves to fit their icon, if any, and their label.
        ///     However, the tab size can be explicity set by setting this property.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        Localizable(true),
        SRDescription(SR.TabBaseItemSizeDescr)
        ]
        public Size ItemSize {
            get {
                if (itemSize.IsEmpty) {
                
                    // Obtain the current itemsize of the first tab from the winctl control
                    //
                    if (IsHandleCreated) {
                        getTabRectfromItemSize = true;
                        return GetTabRect(0).Size;
                    }
                    else {
                        return DEFAULT_ITEMSIZE;
                    }
                }
                else {
                    return itemSize;                    
                }
            }

            set {
                if (value.Width < 0 || value.Height < 0) {
                    throw new ArgumentException(SR.GetString(SR.InvalidArgument, "ItemSize", value.ToString()));
                }
                itemSize = value;
                ApplyItemSize();
                UpdateSize();
                Invalidate();
            }
        }

        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.Multiline"]/*' />
        /// <devdoc>
        ///     Indicates if there can be more than one row of tabs.  By default [when
        ///     this property is false], if there are more tabs than available display
        ///     space, arrows are shown to let the user navigate between the extra
        ///     tabs, but only one row is shown.  If this property is set to true, then
        ///     Windows spills extra tabs over on to second rows.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(false),
        SRDescription(SR.TabBaseMultilineDescr)
        ]
        public bool Multiline {
            get {
                return multiline;
            }
            set {
                if (value == multiline) return;
                multiline = value;
                //subhag
                //
                if (multiline == false && (this.alignment == TabAlignment.Left || this.alignment == TabAlignment.Right))
                    this.alignment = TabAlignment.Top;                
                RecreateHandle();
            }
        }

        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.Padding"]/*' />
        /// <devdoc>
        ///     The amount of padding around the items in the individual tabs.
        ///     You can specify both horizontal and vertical padding.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        Localizable(true),
        SRDescription(SR.TabBasePaddingDescr)
        ]
        public Point Padding {
            get {
                return padding;
            }
            set {
                //do some validation checking here, against min & max GridSize
                //
                if ( value.X < 0 || value.Y < 0 )
                    throw new ArgumentException(SR.GetString(SR.InvalidArgument,
                                                              "Padding",
                                                              value.ToString()));

                if (padding != value) {
                    padding = value;
                    if (IsHandleCreated) {
                        RecreateHandle();
                    }
                }
            }
        }

        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.RowCount"]/*' />
        /// <devdoc>
        ///     The number of rows currently being displayed in
        ///     the tab strip.  This is most commonly used when the Multline property
        ///     is 'true' and you want to know how many rows the tabs are currently
        ///     taking up.
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.TabBaseRowCountDescr)
        ]
        public int RowCount {
            get {
                int n;
                n = (int)SendMessage(NativeMethods.TCM_GETROWCOUNT, 0, 0);
                return n;
            }
        }

        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.SelectedIndex"]/*' />
        /// <devdoc>
        ///     The index of the currently selected tab in the strip, if there
        ///     is one.  If the value is -1, there is currently no selection.  If the
        ///     value is 0 or greater, than the value is the index of the currently
        ///     selected tab.
        /// </devdoc>
        [
        Browsable(false),
        SRCategory(SR.CatBehavior),
        DefaultValue(-1),
        SRDescription(SR.selectedIndexDescr)
        ]
        public int SelectedIndex {
            get {
                if (IsHandleCreated) {
                    int n;
                    n = (int)SendMessage(NativeMethods.TCM_GETCURSEL, 0, 0);
                    return n;
                }
                else {
                    return selectedIndex;
                }
            }
            set {
                if (value < -1) {
                    throw new ArgumentException(SR.GetString(SR.InvalidLowBoundArgumentEx, "value", value.ToString(), "-1"));
                }
                
                if (SelectedIndex != value) {
                    if (IsHandleCreated) {
                        SendMessage(NativeMethods.TCM_SETCURSEL, value, 0);
                    }
                    else {
                        selectedIndex = value;
                    }
                    if (!fromCreateHandles) {
                        UISelection = true;
                        OnSelectedIndexChanged(EventArgs.Empty);
                    }
                }
            }
        }

        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.SelectedTab"]/*' />
        /// <devdoc>
        ///      The selection to the given tab, provided it .equals a tab in the
        ///      list.  The return value is the index of the tab that was selected,
        ///      or -1 if no tab was selected.
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.TabControlSelectedTabDescr)
        ]
        public TabPage SelectedTab {
            get {
                return SelectedTabInternal;
            }
            set {
                SelectedTabInternal = value;
            }
        }

        internal TabPage SelectedTabInternal {
            get {
                int index = SelectedIndex;
                if (index == -1) {
                    return null;
                }
                else {
                    Debug.Assert(0 <= index && index < tabPages.Length, "SelectedIndex returned an invalid index");
                    return tabPages[index];
                }
            }
            set {
                int index = FindTabPage(value);
                SelectedIndex = index;
            }
        }

        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.SizeMode"]/*' />
        /// <devdoc>
        ///     By default, tabs are big enough to display their text, and any space
        ///     on the right of the strip is left as such.  However, you can also
        ///     set it such that the tabs are stretched to fill out the right extent
        ///     of the strip, if necessary, or you can set it such that all tabs
        ///     the same width.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(TabSizeMode.Normal),
        SRDescription(SR.TabBaseSizeModeDescr),
        RefreshProperties(RefreshProperties.Repaint)
        ]
        public TabSizeMode SizeMode {
            get {
                return sizeMode;
            }
            set {
                if (sizeMode == value) return;

                if (!Enum.IsDefined(typeof(TabSizeMode), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(TabSizeMode));
                }

                sizeMode = value;
                RecreateHandle();
            }
        }

        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.ShowToolTips"]/*' />
        /// <devdoc>
        ///     Indicates whether tooltips are being shown for tabs that have tooltips set on
        ///     them.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(false),
        Localizable(true),
        SRDescription(SR.TabBaseShowToolTipsDescr)
        ]
        public bool ShowToolTips {
            get {
                return showToolTips;
            }
            set {
                if (this.showToolTips != value) {
                    this.showToolTips = value;
                    RecreateHandle();
                }
            }
        }

        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.TabCount"]/*' />
        /// <devdoc>
        ///     Returns the number of tabs in the strip
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.TabBaseTabCountDescr)
        ]
        public int TabCount {
            get { return tabPageCount;}
        }

        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.TabPages"]/*' />
        /// <devdoc>
        ///     Returns the Collection of TabPages.
        /// </devdoc>
        [
        SRDescription(SR.TabControlTabsDescr),
        DefaultValue(null),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        MergableProperty(false)
        ]
        public TabPageCollection TabPages {
            get {
                return tabCollection;
            }
        }
        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.Text"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>        
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never), Bindable(false)]        
        public override string Text {
            get {
                return base.Text;
            }
            set {
                base.Text = value;
            }
        }

        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.TextChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler TextChanged {
            add {
                base.TextChanged += value;
            }
            remove {
                base.TextChanged -= value;
            }
        }
        
        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.DrawItem"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatBehavior), SRDescription(SR.drawItemEventDescr)]
        public event DrawItemEventHandler DrawItem {
            add {
                onDrawItem += value;
            }
            remove {
                onDrawItem -= value;
            }
        }
                

        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.SelectedIndexChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatBehavior), SRDescription(SR.selectedIndexChangedEventDescr)]
        public event EventHandler SelectedIndexChanged {
            add {
                onSelectedIndexChanged += value;
            }
            remove {
                onSelectedIndexChanged -= value;
            }
        }

        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.OnPaint"]/*' />
        /// <devdoc>
        ///     TabControl Onpaint.
        /// </devdoc>
        /// <internalonly/><hideinheritance/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event PaintEventHandler Paint {
            add {
                base.Paint += value;
            }
            remove {
                base.Paint -= value;
            }
        }
        
        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.AddItem"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        internal int AddTabPage(TabPage tabPage, NativeMethods.TCITEM_T tcitem) {
            int index = AddNativeTabPage(tcitem);
            if (index >= 0) Insert(index, tabPage);
            return index;
        }
        
        internal int AddNativeTabPage(NativeMethods.TCITEM_T tcitem) {
            int index = (int)UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.TCM_INSERTITEM, tabPageCount + 1, tcitem);
            UnsafeNativeMethods.PostMessage(new HandleRef(this, Handle), tabBaseReLayoutMessage, IntPtr.Zero, IntPtr.Zero);
            return index;
        }

        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.ApplySize"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        internal void ApplyItemSize() {             
            if (IsHandleCreated && ShouldSerializeItemSize()) {                 
                SendMessage(NativeMethods.TCM_SETITEMSIZE, 0, (int)NativeMethods.Util.MAKELPARAM(itemSize.Width, itemSize.Height));
            }
            cachedDisplayRect = Rectangle.Empty;
        }

        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.BeginUpdate"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        internal void BeginUpdate() {
            BeginUpdateInternal();
        }
        
        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.CreateControlsInstance"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        protected override Control.ControlCollection CreateControlsInstance() {
            return new ControlCollection(this);
        }

        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.CreateHandle"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        protected override void CreateHandle() {
            if (!RecreatingHandle) {
                NativeMethods.INITCOMMONCONTROLSEX icc = new NativeMethods.INITCOMMONCONTROLSEX();
                icc.dwICC = NativeMethods.ICC_TAB_CLASSES;
                SafeNativeMethods.InitCommonControlsEx(icc);
            }
            base.CreateHandle();
        }

        private void DetachImageList(object sender, EventArgs e) {
            ImageList = null;
        }

        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.Dispose"]/*' />
        protected override void Dispose(bool disposing) {
            if (disposing) {
                if (imageList != null) {
                    imageList.Disposed -= new EventHandler(this.DetachImageList);
                }
            }
            base.Dispose(disposing);
        }

        internal void EndUpdate() {
            EndUpdate(true);
        }

        internal void EndUpdate(bool invalidate) {
            EndUpdateInternal(invalidate);
        }

        internal int FindTabPage(TabPage tabPage) {
            if (tabPages != null) {
                for (int i = 0; i < tabPageCount; i++) {
                    if (tabPages[i].Equals(tabPage)) {
                        return i;
                    }
                }
            }
            return -1;
        }
        
        internal int FindTabPageExact(TabPage tabPage) {
            if (tabPages != null) {
                for (int i = 0; i < tabPageCount; i++) {
                    if (tabPages[i] == tabPage) {
                        return i;
                    }
                }
            }
            return -1;
        }

        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.GetControl"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        public Control GetControl(int index) {
            return(Control) GetTabPage(index);
        }

        internal TabPage GetTabPage(int index) {

            if (index < 0 || index >= tabPageCount) {
                throw new ArgumentOutOfRangeException(SR.GetString(SR.InvalidArgument,
                                                          "index",
                                                          index.ToString()));
            }
            return tabPages[index];
        }

        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.GetItems"]/*' />
        /// <devdoc>
        ///     This has package scope so that TabStrip and TabControl can call it.
        /// </devdoc>
        /// <internalonly/>
        protected virtual object[] GetItems() {
            TabPage[] result = new TabPage[tabPageCount];
            if (tabPageCount > 0) Array.Copy(tabPages, 0, result, 0, tabPageCount);
            return result;
        }

        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.GetItems1"]/*' />
        /// <devdoc>
        ///     This has package scope so that TabStrip and TabControl can call it.
        /// </devdoc>
        /// <internalonly/>
        protected virtual object[] GetItems(Type baseType) {
            object[] result = (object[]) Array.CreateInstance(baseType, tabPageCount);
            if (tabPageCount > 0) Array.Copy(tabPages, 0, result, 0, tabPageCount);
            return result;
        }

        internal TabPage[] GetTabPages() {
            return (TabPage[])GetItems();
        }

        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.GetTabRect"]/*' />
        /// <devdoc>
        ///     Retrieves the bounding rectangle for the given tab in the tab strip.
        /// </devdoc>
        public Rectangle GetTabRect(int index) {
            if (index < 0 || (index >= tabPageCount && !getTabRectfromItemSize)) {
                throw new ArgumentOutOfRangeException(SR.GetString(SR.InvalidArgument,"index",index.ToString()));
            }
            getTabRectfromItemSize = false ;
            NativeMethods.RECT rect = new NativeMethods.RECT();

            // normally, we would not want to create the handle for this, but since
            // it is dependent on the actual physical display, we simply must.
            if (!IsHandleCreated)
                CreateHandle();

            SendMessage(NativeMethods.TCM_GETITEMRECT, index, ref rect);
            return Rectangle.FromLTRB(rect.left, rect.top, rect.right, rect.bottom);
        }
        
        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.GetTCITEM"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        internal NativeMethods.TCITEM_T GetTCITEM(object item) {
            return ((TabPage)item).GetTCITEM();
        }

        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.GetToolTipText"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        protected string GetToolTipText(object item) {
            return((TabPage)item).ToolTipText;
        }

        private void ImageListRecreateHandle(object sender, EventArgs e) {
            if (IsHandleCreated)
                SendMessage(NativeMethods.TCM_SETIMAGELIST, 0, ImageList.Handle);
        }

        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.Insert"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        internal void Insert(int index, TabPage tabPage) {
            if (tabPages == null) {
                tabPages = new TabPage[4];
            }
            else if (tabPages.Length == tabPageCount) {
                TabPage[] newTabPages = new TabPage[tabPageCount * 2];
                Array.Copy(tabPages, 0, newTabPages, 0, tabPageCount);
                tabPages = newTabPages;
            }
            if (index < tabPageCount) {
                Array.Copy(tabPages, index, tabPages, index + 1, tabPageCount - index);
            }
            tabPages[index] = tabPage;
            tabPageCount++;
            cachedDisplayRect = Rectangle.Empty;
            ApplyItemSize();
            if (Appearance == TabAppearance.FlatButtons) {
                Invalidate();
            }
        }

        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.InsertItem"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        internal int InsertItem(int index, TabPage tabPage, NativeMethods.TCITEM_T tcitem) {

            if (index < 0 || index >= tabPageCount)
                throw new ArgumentOutOfRangeException(SR.GetString(SR.InvalidArgument,
                                                          "index",
                                                          index.ToString()));

            int retIndex;
            retIndex = (int)UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.TCM_INSERTITEM, index, tcitem);
            if (retIndex >= 0) Insert(retIndex, tabPage);
            return retIndex;
        }

        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.IsInputKey"]/*' />
        /// <devdoc>
        ///      Handling special input keys, such as pgup, pgdown, home, end, etc...
        /// </devdoc>
        protected override bool IsInputKey(Keys keyData) {
            if ((keyData & Keys.Alt) == Keys.Alt) return false;
            switch (keyData & Keys.KeyCode) {
                case Keys.PageUp:
                case Keys.PageDown:
                case Keys.Home:
                case Keys.End:
                    return true;
            }
            return base.IsInputKey(keyData);
        }
  
        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.OnHandleCreated"]/*' />
        /// <devdoc>
        ///     This is a notification that the handle has been created.
        ///     We do some work here to configure the handle.
        ///     Overriders should call base.OnHandleCreated()
        /// </devdoc>
        /// <internalonly/>
        protected override void OnHandleCreated(EventArgs e) {
            
            //Add the handle to hashtable for Ids ..
            window.AddWindowToIDTable(this.Handle);

            base.OnHandleCreated(e);
            cachedDisplayRect = Rectangle.Empty;
            ApplyItemSize();
            if (imageList != null) {
                SendMessage(NativeMethods.TCM_SETIMAGELIST, 0, imageList.Handle);
            }

            if (!padding.IsEmpty) {
                SendMessage(NativeMethods.TCM_SETPADDING, 0, NativeMethods.Util.MAKELPARAM(padding.X, padding.Y));
            }
            if (showToolTips) {
                IntPtr tooltipHwnd;
                tooltipHwnd = SendMessage(NativeMethods.TCM_GETTOOLTIPS, 0, 0);
                if (tooltipHwnd != IntPtr.Zero) {
                    SafeNativeMethods.SetWindowPos(new HandleRef(this, tooltipHwnd),
                                         NativeMethods.HWND_TOPMOST,
                                         0, 0, 0, 0,
                                         NativeMethods.SWP_NOMOVE | NativeMethods.SWP_NOSIZE |
                                         NativeMethods.SWP_NOACTIVATE);
                }
            }
            
            // Add the pages
            //
            foreach(TabPage page in TabPages) {
                AddNativeTabPage(page.GetTCITEM());
            }
            
            // Resize the pages
            //
            ResizePages();
            
            if (selectedIndex != -1) {
                try {
                    fromCreateHandles = true;
                    SelectedIndex = selectedIndex;
                }
                finally {
                    fromCreateHandles = false;
                }
                selectedIndex = -1;
            }
            UpdateTabSelection(false);
        }
        
        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.OnHandleDestroyed"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnHandleDestroyed(EventArgs e) {
            if (!Disposing) {
                selectedIndex = SelectedIndex;
            }
            //Remove the Handle from NativewIndow....
            window.RemoveWindowFromIDTable(this.Handle);
            base.OnHandleDestroyed(e);
        }

        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.OnDrawItem"]/*' />
        /// <devdoc>
        ///     Actually goes and fires the OnDrawItem event.  Inheriting controls
        ///     should use this to know when the event is fired [this is preferable to
        ///     adding an event handler on yourself for this event].  They should,
        ///     however, remember to call base.onDrawItem(e); to ensure the event is
        ///     still fired to external listeners
        /// </devdoc>
        protected virtual void OnDrawItem(DrawItemEventArgs e) {
            if (onDrawItem != null) onDrawItem(this, e);
        }

        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.OnKeyDown"]/*' />
        /// <devdoc>
        ///     We override this to get tabbing functionality.
        ///     If overriding this, remember to call base.onKeyDown.
        /// </devdoc>
        /// <internalonly/>
        protected override void OnKeyDown(KeyEventArgs ke) {
            if (ke.KeyCode == Keys.Tab && (ke.KeyData & Keys.Control) !=0) {
                bool forward = (ke.KeyData & Keys.Shift) == 0;

                int sel = SelectedIndex;
                if (sel != -1) {
                    int count = TabCount;
                    if (forward)
                        sel = (sel + 1) % count;
                    else
                        sel = (sel + count - 1) % count;
                    UISelection = true;
                    SelectedIndex = sel;
                    ke.Handled = true;
                }
            }
            base.OnKeyDown(ke);
        }

        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.OnResize"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        protected override void OnResize(EventArgs e) {
            base.OnResize(e);
            cachedDisplayRect = Rectangle.Empty;
            UpdateTabSelection(false);
        }

        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.OnSelectedIndexChanged"]/*' />
        /// <devdoc>
        ///     Actually goes and fires the onSelectedIndexChanged event.  Inheriting controls
        ///     should use this to know when the event is fired [this is preferable to
        ///     adding an event handler on yourself for this event].  They should,
        ///     however, remember to call base.onSelectedIndexChanged(e); to ensure the event is
        ///     still fired to external listeners
        /// </devdoc>
        protected virtual void OnSelectedIndexChanged(EventArgs e) {
            int index = SelectedIndex;
            cachedDisplayRect = Rectangle.Empty;
            UpdateTabSelection(UISelection);
            UISelection = false;
            if (onSelectedIndexChanged != null) onSelectedIndexChanged.Invoke(this, e);
        }

        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.ProcessKeyPreview"]/*' />
        /// <devdoc>
        ///     We override this to get the Ctrl and Ctrl-Shift Tab functionality.
        /// </devdoc>
        /// <internalonly/>
        [
            SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)
        ]
        protected override bool ProcessKeyPreview(ref Message m) {
            if (ProcessKeyEventArgs(ref m)) return true;
            return base.ProcessKeyPreview(ref m);
        }

        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.UpdateSize"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        internal void UpdateSize() {
            // the spin control (left right arrows) won't update without resizing.
            // the most correct thing would be to recreate the handle, but this works
            // and is cheaper.
            //
            BeginUpdate();
            Size size = Size;
            Size = new Size(size.Width + 1, size.Height);
            Size = size;
            EndUpdate();
        }

        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.OnFontChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnFontChanged(EventArgs e) {
            base.OnFontChanged(e);
            cachedDisplayRect = Rectangle.Empty;
            UpdateSize();
        }

        internal override void RecreateHandleCore() {
            // CONSIDER: can this be moved into OnHandleCreated/OnHandleDestroyed?
            TabPage[] tabPages = GetTabPages();

            int index = ((tabPages.Length > 0) && (SelectedIndex == -1)) ? 0: SelectedIndex;

            // We don't actually want to remove the windows forms Tabpages - we only
            // want to remove the corresponding TCITEM structs.
            // So, no RemoveAll()
            if (IsHandleCreated) {
                SendMessage(NativeMethods.TCM_DELETEALLITEMS, 0, 0);
            }
            this.tabPages = null;
            tabPageCount = 0;

            base.RecreateHandleCore();
            
            for (int i = 0; i < tabPages.Length; i++) {
                TabPages.Add(tabPages[i]);                
            }
            try {
                fromCreateHandles = true;
                SelectedIndex = index;
            }
            finally {
                fromCreateHandles = false;
            }
            
            // The comctl32 TabControl seems to have some painting glitches. Briefly
            // resizing the control seems to fix these.
            //                               
            UpdateSize();            
        }

        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl._RemoveAll"]/*' />
        /// <devdoc>
        ///     Removes all tabs from the tabstrip.  All values and data are discarded.
        /// </devdoc>
        // Removes all child controls from the tab control when you remove all the tabs.
        internal void _RemoveAll() {
            RemoveAll();
        }

        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.RemoveAll"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected void RemoveAll() {
            this.Controls.Clear();

            SendMessage(NativeMethods.TCM_DELETEALLITEMS, 0, 0);
            tabPages = null;
            tabPageCount = 0;
        }

        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.RemoveItem"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        internal void RemoveTabPage(int index) {
            if (index < 0 || index >= tabPageCount)
                throw new ArgumentOutOfRangeException(SR.GetString(SR.InvalidArgument,
                                                          "index",
                                                          index.ToString()));
            tabPageCount--;
            if (index < tabPageCount) {
                Array.Copy(tabPages, index + 1, tabPages, index, tabPageCount - index);
            }
            tabPages[tabPageCount] = null;
            if (IsHandleCreated) {
                SendMessage(NativeMethods.TCM_DELETEITEM, index, 0);
            }
            cachedDisplayRect = Rectangle.Empty;
        }

        private void ResizePages() {
            Rectangle rect = DisplayRectangle;
            TabPage[] pages = GetTabPages();
            for (int i = 0; i < pages.Length; i++) {
                pages[i].Bounds = rect;
            }
        }

        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.SetItem"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        internal void SetTabPage(int index, TabPage tabPage, NativeMethods.TCITEM_T tcitem) {
            if (index < 0 || index >= tabPageCount)
                throw new ArgumentOutOfRangeException(SR.GetString(SR.InvalidArgument,
                                                          "index",
                                                          index.ToString()));
            if (IsHandleCreated)
                UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.TCM_SETITEM, index, tcitem);
            
            tabPages[index] = tabPage;
        }

        private bool ShouldSerializeItemSize() {
            return !itemSize.Equals(DEFAULT_ITEMSIZE);
        }

        private bool ShouldSerializePadding() {
            return !padding.Equals(DEFAULT_PADDING);
        }
        
        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.ToString"]/*' />
        /// <devdoc>
        ///     Returns a string representation for this control.
        /// </devdoc>
        /// <internalonly/>
        public override string ToString() {

            string s = base.ToString();
            if (TabPages != null) {
                s += ", TabPages.Count: " + TabPages.Count.ToString();
                if (TabPages.Count > 0)
                    s += ", TabPages[0]: " + TabPages[0].ToString();
            }
            return s;
        }


        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.UpdateTabSelection"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        /// <devdoc>
        ///     Set the panel selections appropriately
        /// </devdoc>
        /// <internalonly/>
        protected void UpdateTabSelection(bool uiselected) {
            if (IsHandleCreated) {
                int index = SelectedIndex;

                // make current panel invisible
                TabPage[] tabPages = GetTabPages();
                if (index != -1) {
                    tabPages[index].Bounds = DisplayRectangle;
                    tabPages[index].Visible = true;
                    if (uiselected) {
                        if (!Focused) {
                            bool selectNext = false;
                            
                            IntSecurity.ModifyFocus.Assert();
                            try {
                                selectNext = tabPages[index].SelectNextControl(null, true, true, false, false);
                            }
                            finally {
                                CodeAccessPermission.RevertAssert();
                            }

                            if (!selectNext) {
                                IContainerControl c = GetContainerControlInternal();
                                if (c != null) {
                                    if (c is ContainerControl) {
                                        ((ContainerControl)c).SetActiveControlInternal(this);
                                    }
                                    else {
                                        IntSecurity.ModifyFocus.Assert();
                                        try {
                                            c.ActiveControl = this;
                                        }
                                        finally {
                                            CodeAccessPermission.RevertAssert();
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                for (int i = 0; i < tabPages.Length; i++) {
                    if (i != index) {
                        tabPages[i].Visible = false;
                    }
                }
            }
        }

        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.OnStyleChanged"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        protected override void OnStyleChanged(EventArgs e) {
            base.OnStyleChanged(e);
            cachedDisplayRect = Rectangle.Empty;
            UpdateTabSelection(false);
        }



        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.UpdateTab"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        internal void UpdateTab(TabPage tabPage) {
            int index = FindTabPage(tabPage);
            SetTabPage(index, tabPage, tabPage.GetTCITEM());

            // It's possible that changes to this TabPage will change the DisplayRectangle of the
            // TabControl (e.g. ASURT 99087), so invalidate and resize the size of this page.
            //
            cachedDisplayRect = Rectangle.Empty;
            UpdateTabSelection(false);
        }


        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.WmNeedText"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        private void WmNeedText(ref Message m) {
            NativeMethods.TOOLTIPTEXT ttt = (NativeMethods.TOOLTIPTEXT) m.GetLParam(typeof(NativeMethods.TOOLTIPTEXT));

            int commandID = ttt.hdr.idFrom;

            string tipText = GetToolTipText(GetTabPage(commandID));
            if (tipText != null)
                ttt.szText = tipText;
            else
                ttt.szText = null;

            ttt.hinst = IntPtr.Zero;
            
            // RightToLeft reading order
            //
            if (RightToLeft == RightToLeft.Yes) {
                ttt.uFlags |= NativeMethods.TTF_RTLREADING;
            }
            
            Marshal.StructureToPtr(ttt, m.LParam, true);
        }

        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.WmReflectDrawItem"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        private void WmReflectDrawItem(ref Message m) {

            NativeMethods.DRAWITEMSTRUCT dis = (NativeMethods.DRAWITEMSTRUCT)m.GetLParam(typeof(NativeMethods.DRAWITEMSTRUCT));
            IntPtr oldPal = SetUpPalette(dis.hDC, false /*force*/, false /*realize*/);
            using (Graphics g = Graphics.FromHdcInternal(dis.hDC)) {
                OnDrawItem(new DrawItemEventArgs(g, Font, Rectangle.FromLTRB(dis.rcItem.left, dis.rcItem.top, dis.rcItem.right, dis.rcItem.bottom), dis.itemID, (DrawItemState)dis.itemState));
            }
            if (oldPal != IntPtr.Zero) {
                SafeNativeMethods.SelectPalette(new HandleRef(null, dis.hDC), new HandleRef(null, oldPal), 0);
            }
            m.Result = (IntPtr)1;
        }

        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.WmSelChange"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        private void WmSelChange(ref Message m) {
            OnSelectedIndexChanged(EventArgs.Empty);
        }

        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.WmSelChanging"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        private void WmSelChanging(ref Message m) {
            IContainerControl c = GetContainerControlInternal();
            if (c != null) {
                if (c is ContainerControl) {
                    ((ContainerControl)c).SetActiveControlInternal(this);
                }
                else {
                    IntSecurity.ModifyFocus.Assert();
                    try {
                        c.ActiveControl = this;
                    }
                    finally {
                        CodeAccessPermission.RevertAssert();
                    }
                }
            }
        }

        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.WmTabBaseReLayout"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        private void WmTabBaseReLayout(ref Message m) {
            BeginUpdate();
            cachedDisplayRect = Rectangle.Empty;
            UpdateTabSelection(false);
            EndUpdate();

            // Remove other TabBaseReLayout messages from the message queue
            NativeMethods.MSG msg = new NativeMethods.MSG();
            IntPtr hwnd = Handle;
            while (UnsafeNativeMethods.PeekMessage(ref msg, new HandleRef(this, hwnd),
                                       tabBaseReLayoutMessage,
                                       tabBaseReLayoutMessage,
                                       NativeMethods.PM_REMOVE)) {
                ; // NULL loop
            }
        }

        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.WndProc"]/*' />
        /// <devdoc>
        ///     The tab's window procedure.  Inheritng classes can override this
        ///     to add extra functionality, but should not forget to call
        ///     base.wndProc(m); to ensure the tab continues to function properly.
        /// </devdoc>
        /// <internalonly/>
        [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        protected override void WndProc(ref Message m) {

            switch (m.Msg) {
                case NativeMethods.WM_REFLECT + NativeMethods.WM_DRAWITEM:
                    WmReflectDrawItem(ref m);
                    break;

                case NativeMethods.WM_REFLECT + NativeMethods.WM_MEASUREITEM:
                    // We use TCM_SETITEMSIZE instead
                    break;

                case NativeMethods.WM_NOTIFY:
                case NativeMethods.WM_REFLECT + NativeMethods.WM_NOTIFY:
                    NativeMethods.NMHDR nmhdr = (NativeMethods.NMHDR) m.GetLParam(typeof(NativeMethods.NMHDR));
                    switch (nmhdr.code) {
                        // new switch added to prevent the TabControl from changing to next TabPage ...
                        //in case of validation cancelled...
                        //Turn  UISelection = false and Return So that no WmSelChange() gets fired.
                        //If validation not cancelled then UISelection is turned ON to set the focus on to the ...
                        //next TabPage..

                        case NativeMethods.TCN_SELCHANGING:
                            WmSelChanging(ref m);
                            if(ValidationCancelled) {
                                m.Result = (IntPtr)1;
                                UISelection = false;
                                return;
                            }
                            else {
                                UISelection = true;
                            }
                            break;
                        case NativeMethods.TCN_SELCHANGE:
                            WmSelChange(ref m);
                            break;
                        case NativeMethods.TTN_GETDISPINFOA:
                        case NativeMethods.TTN_GETDISPINFOW:
                            WmNeedText(ref m);
                            m.Result = (IntPtr)1;
                            return;
                    }
                    break;
            }
            if (m.Msg == tabBaseReLayoutMessage) {
                WmTabBaseReLayout(ref m);
                return;
            }
            base.WndProc(ref m);
        }


        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.TabPageCollection"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public class TabPageCollection : IList {
            private TabControl owner;

            /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.TabPageCollection.TabPageCollection"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public TabPageCollection( TabControl owner ) {
                if (owner == null) {
                    throw new ArgumentNullException("owner");
                }
                this.owner = owner;
            }
            
            /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.TabPageCollection.this"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public virtual TabPage this[int index] {
                get {
                    return owner.GetTabPage(index);
                }
                set {
                    owner.SetTabPage(index, value, value.GetTCITEM());
                }
            }
            
            /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabPageCollection.IList.this"]/*' />
            /// <internalonly/>
            object IList.this[int index] {
                get {
                    return this[index];
                }
                set {
                    if (value is TabPage) {
                        this[index] = (TabPage)value;
                    }
                    else {  
                        throw new ArgumentException("value");
                    }
                }
            }

            /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.TabPageCollection.Count"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            [Browsable(false)]
            public int Count {
                get {
                    return owner.tabPageCount;
                }
            }

            /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabPageCollection.ICollection.SyncRoot"]/*' />
            /// <internalonly/>
            object ICollection.SyncRoot {
                get {
                    return this;
                }
            }

            /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabPageCollection.ICollection.IsSynchronized"]/*' />
            /// <internalonly/>
            bool ICollection.IsSynchronized {
                get {
                    return false;
                }
            }
            
            /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabPageCollection.IList.IsFixedSize"]/*' />
            /// <internalonly/>
            bool IList.IsFixedSize {
                get {
                    return false;
                }
            }
           
            /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.TabPageCollection.IsReadOnly"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public bool IsReadOnly {
                get {
                    return false;
                }
            }

            /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.TabPageCollection.Add"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public void Add(TabPage value) {
                
                if (value == null) {
                    throw new ArgumentNullException("value");
                }
                
                owner.Controls.Add(value);
            }
            
            /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabPageCollection.IList.Add"]/*' />
            /// <internalonly/>
            int IList.Add(object value) {
                if (value is TabPage) {
                    Add((TabPage)value);                    
                    return IndexOf((TabPage)value);
                }
                else {  
                    throw new ArgumentException("value");
                }
            }
            
            /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.TabPageCollection.AddRange"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public void AddRange(TabPage[] pages) {
                if (pages == null) {
                    throw new ArgumentNullException("pages");
                }
                foreach(TabPage page in pages) {
                    Add(page);
                }
            }
            
            /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.TabPageCollection.Contains"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public bool Contains(TabPage page) {

                //check for the page not to be null
                if (page == null) 
                    throw new ArgumentNullException("value");
                //end check

                return IndexOf(page) != -1;
            }
        
            /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabPageCollection.IList.Contains"]/*' />
            /// <internalonly/>
            bool IList.Contains(object page) {
                if (page is TabPage) {
                    return Contains((TabPage)page);
                }
                else {  
                    return false;
                }
            }
            
            /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.TabPageCollection.IndexOf"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public int IndexOf(TabPage page) {

                //check for the page not to be null
                if (page == null) 
                    throw new ArgumentNullException("value");
                //end check

                for(int index=0; index < Count; ++index) {
                    if (this[index] == page) {
                        return index;
                    } 
                }
                return -1;
            }
            
            /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabPageCollection.IList.IndexOf"]/*' />
            /// <internalonly/>
            int IList.IndexOf(object page) {
                if (page is TabPage) {
                    return IndexOf((TabPage)page);
                }
                else {  
                    return -1;
                }
            }
            
            /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabPageCollection.IList.Insert"]/*' />
            /// <internalonly/>
            void IList.Insert(int index, object value) {
                throw new NotSupportedException();
            }

            /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.TabPageCollection.Clear"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public virtual void Clear() {
                owner.RemoveAll();
            }

            /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabPageCollection.ICollection.CopyTo"]/*' />
            /// <internalonly/>
            void ICollection.CopyTo(Array dest, int index) {
                if (Count > 0) {
                    System.Array.Copy(owner.GetTabPages(), 0, dest, index, Count);
                }
            }
            
            /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.TabPageCollection.GetEnumerator"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public IEnumerator GetEnumerator() {
                TabPage[] tabPages = owner.GetTabPages();
                if (tabPages != null) {
                    return tabPages.GetEnumerator();
                }
                else {
                    return new TabPage[0].GetEnumerator();
                }
            }

            /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.TabPageCollection.Remove"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public void Remove(TabPage value) {

                //check for the value not to be null
                if (value == null) 
                    throw new ArgumentNullException("value");
                //end check


                owner.Controls.Remove(value);
            }

            /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabPageCollection.IList.Remove"]/*' />
            /// <internalonly/>
            void IList.Remove(object value) {
                if (value is TabPage) {
                    Remove((TabPage)value);
                }                
            }
            
            /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.TabPageCollection.RemoveAt"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public void RemoveAt(int index) {
                owner.Controls.RemoveAt(index);
            }

        }


        /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.ControlCollection"]/*' />
        /// <devdoc>
        ///     Collection of controls...
        /// </devdoc>
        public new class ControlCollection : Control.ControlCollection {

            private TabControl owner;

            /*C#r: protected*/

            /// <internalonly/>
            /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.ControlCollection.ControlCollection"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public ControlCollection(TabControl owner)
            : base(owner) {
                this.owner = owner;
            }

            /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.ControlCollection.Add"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public override void Add(Control value) {
                if (!(value is TabPage)) {
                    throw new ArgumentException(SR.GetString(SR.TabControlInvalidTabPageType, value.GetType().Name));
                }

                TabPage tabPage = (TabPage)value;

                if (owner.IsHandleCreated) {
                    owner.AddTabPage(tabPage, tabPage.GetTCITEM());
                }
                else {
                    owner.Insert(owner.TabCount, tabPage);
                }
                
                base.Add(tabPage);
                tabPage.Visible = false;

                // Without this check, we force handle creation on the tabcontrol
                // which is not good at all of there are any OCXs on it.
                //
                if (owner.IsHandleCreated) {
                    tabPage.Bounds = owner.DisplayRectangle;
                }

                // site the tabPage if necessary.
                ISite site = owner.Site;
                if (site != null) {
                    ISite siteTab = tabPage.Site;
                    if (siteTab == null) {
                        IContainer container = site.Container;
                        container.Add(tabPage);
                    }
                }
                owner.ApplyItemSize();
                owner.UpdateTabSelection(false);
            }

            /// <include file='doc\TabControl.uex' path='docs/doc[@for="TabControl.ControlCollection.Remove"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public override void Remove(Control value) {
                base.Remove(value);
                if (!(value is TabPage)) {
                    return;
                }
                int index = owner.FindTabPage((TabPage)value);
                if (index != -1) {
                    owner.RemoveTabPage(index);
                    owner.SelectedIndex = Math.Max(index - 1, 0);
                }
                owner.UpdateTabSelection(false);
            }
        }


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\textbox.cs ===
//------------------------------------------------------------------------------
// <copyright file="TextBox.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {
    using System.Runtime.Remoting;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using SecurityManager = System.Security.SecurityManager;
    using System.Security.Permissions;
    using System.Windows.Forms;
    using System.ComponentModel.Design;    
    using System.Drawing;
    using Microsoft.Win32;
    using System.Reflection;
    using System.Text;
    using System.Runtime.InteropServices;
    
        /// <include file='doc\TextBox.uex' path='docs/doc[@for="TextBox"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents
    ///       a Windows text box control.
    ///    </para>
    /// </devdoc>
    public class TextBox : TextBoxBase {
    
        private static readonly object EVENT_TEXTALIGNCHANGED = new object();
    
        /// <devdoc>
        ///     Controls whether or not the edit box consumes/respects ENTER key
        ///     presses.  While this is typically desired by multiline edits, this
        ///     can interfere with normal key processing in a dialog.
        /// </devdoc>
        private bool acceptsReturn = false;

        /// <devdoc>
        ///     Indicates what the current special password character is.  This is
        ///     displayed instead of any other text the user might enter.
        /// </devdoc>
        private char passwordChar;

        /// <devdoc>
        ///     Controls whether or not the case of characters entered into the edit
        ///     box is forced to a specific case.
        /// </devdoc>
        private CharacterCasing characterCasing = System.Windows.Forms.CharacterCasing.Normal;

        /// <devdoc>
        ///     Controls which scrollbars appear by default.
        /// </devdoc>
        private ScrollBars scrollBars = System.Windows.Forms.ScrollBars.None;

        /// <devdoc>
        ///     Controls text alignment in the edit box.
        /// </devdoc>
        private HorizontalAlignment textAlign = HorizontalAlignment.Left;

        /// <devdoc>
        ///     Controls firing of click event.
        /// </devdoc>
        private bool doubleClickFired = false;

        /// <devdoc>
        ///     True if the selection has been set by the user.  If the selection has
        ///     never been set and we get focus, we focus all the text in the control
        ///     so we mimic the Windows dialog manager.
        /// </devdoc>
        private bool selectionSet = false;

        /// <include file='doc\TextBox.uex' path='docs/doc[@for="TextBox.TextBox"]/*' />
        public TextBox() : base() {
              SetStyle(ControlStyles.StandardClick | ControlStyles.StandardDoubleClick, false);
        }

        
        /// <include file='doc\TextBox.uex' path='docs/doc[@for="TextBox.AcceptsReturn"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether pressing ENTER
        ///       in a multiline <see cref='System.Windows.Forms.TextBox'/>
        ///       control creates a new line of text in the control or activates the default button
        ///       for the form.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(false),
        SRDescription(SR.TextBoxAcceptsReturnDescr)
        ]
        public bool AcceptsReturn {
            get {
                return acceptsReturn;
            }

            set {
                acceptsReturn = value;
            }
        }

        /// <include file='doc\TextBox.uex' path='docs/doc[@for="TextBox.CharacterCasing"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets whether the TextBox control
        ///       modifies the case of characters as they are typed.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(CharacterCasing.Normal),
        SRDescription(SR.TextBoxCharacterCasingDescr)
        ]
        public CharacterCasing CharacterCasing {
            get {
                return characterCasing;
            }
            set {
                if (characterCasing != value) {
                    //verify that 'value' is a valid enum type...

                    if (!Enum.IsDefined(typeof(CharacterCasing), value)) {
                        throw new InvalidEnumArgumentException("value", (int)value, typeof(CharacterCasing));
                    }

                    characterCasing = value;
                    RecreateHandle();
                }
            }
        }

        //new addition
         /// <include file='doc\TextBox.uex' path='docs/doc[@for="TextBox.SelectionLength"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the number of characters selected in the text
        ///       box.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.TextBoxSelectionLengthDescr)
        ]
        public override int SelectionLength {
            get {
                if (!IsHandleCreated) return base.SelectionLength;

                int start = 0;
                int end = 0;
                UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.EM_GETSEL, ref start, ref end);

                //Here, we return the max of either 0 or the # returned by
                //the windows call.  This eliminates a problem on nt4 where
                //a huge negative # is being returned.
                //
                start = Math.Max(0, start);
                // ditto for end
                end = Math.Max(0, end);

                if (Marshal.SystemDefaultCharSize == 1) {
                    ToUnicodeOffsets(Text, ref start, ref end);
                }
#if DEBUG
                string t = WindowText;
                int len;
                if (t == null) {
                    len = 0;
                }
                else {
                    len = t.Length;
                }
                Debug.Assert(end <= len, "SelectionEnd is outside the set of valid caret positions for the current WindowText (end =" 
                             + end + ", WindowText.Length =" + len +")");
#endif
                return end - start;
            }
            set {
                base.SelectionLength = value;
            }
        }

        /// <include file='doc\TextBox.uex' path='docs/doc[@for="TextBox.CreateParams"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Returns the parameters needed to create the handle. Inheriting classes
        ///       can override this to provide extra functionality. They should not,
        ///       however, forget to call base.getCreateParams() first to get the struct
        ///       filled up with the basic info.
        ///    </para>
        /// </devdoc>
        protected override CreateParams CreateParams {
            [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
            get {
                CreateParams cp = base.CreateParams;
                switch (characterCasing) {
                    case CharacterCasing.Lower:
                        cp.Style |= NativeMethods.ES_LOWERCASE;
                        break;
                    case CharacterCasing.Upper:
                        cp.Style |= NativeMethods.ES_UPPERCASE;
                        break;
                }

                // Translate for Rtl if necessary
                //
                HorizontalAlignment align = RtlTranslateHorizontal(textAlign);
                cp.ExStyle &= ~NativeMethods.WS_EX_RIGHT;   // WS_EX_RIGHT overrides the ES_XXXX alignment styles
                switch (align) {
                    case HorizontalAlignment.Left:
                        cp.Style |= NativeMethods.ES_LEFT;
                        break;
                    case HorizontalAlignment.Center:
                        cp.Style |= NativeMethods.ES_CENTER;
                        break;
                    case HorizontalAlignment.Right:
                        cp.Style |= NativeMethods.ES_RIGHT;
                        break;
                }
                
                if (Multiline) {
                    // vs 59731: Don't show horizontal scroll bars which won't do anything
                    if ((scrollBars & ScrollBars.Horizontal) == ScrollBars.Horizontal
                        && textAlign == HorizontalAlignment.Left
                        && !WordWrap) {
                        cp.Style |= NativeMethods.WS_HSCROLL;
                    }
                    if ((scrollBars & ScrollBars.Vertical) == ScrollBars.Vertical) {
                        cp.Style |= NativeMethods.WS_VSCROLL;
                    }
                }
                
                return cp;
            }
        }
        
        /// <include file='doc\TextBox.uex' path='docs/doc[@for="TextBox.DefaultImeMode"]/*' />
        protected override ImeMode DefaultImeMode {
            get {
                if (PasswordChar != (char)0) {
                    return ImeMode.Disable;
                }
                return base.DefaultImeMode;
            }
        }

        /// <include file='doc\TextBox.uex' path='docs/doc[@for="TextBox.PasswordChar"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the character used to mask characters in a single-line text box
        ///       control used to enter passwords.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue((char)0),
        Localizable(true),
        SRDescription(SR.TextBoxPasswordCharDescr)
        ]
        public char PasswordChar {
            get {
                return passwordChar;
            }
            set {
                if (passwordChar != value) {
                    passwordChar = value;
                    if (IsHandleCreated) {
                        SendMessage(NativeMethods.EM_SETPASSWORDCHAR, value, 0);
                        Invalidate();
                    }
                }
            }
        }

        /// <include file='doc\TextBox.uex' path='docs/doc[@for="TextBox.ScrollBars"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets which scroll bars should
        ///       appear in a multiline <see cref='System.Windows.Forms.TextBox'/>
        ///       control.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        Localizable(true),
        DefaultValue(ScrollBars.None),
        SRDescription(SR.TextBoxScrollBarsDescr)
        ]
        public ScrollBars ScrollBars {
            get {
                return scrollBars;
            }
            set {
                if (scrollBars != value) {
                    //verify that 'value' is a valid enum type...

                    if (!Enum.IsDefined(typeof(ScrollBars), value)) {
                        throw new InvalidEnumArgumentException("value", (int)value, typeof(ScrollBars));
                    }

                    scrollBars = value;
                    RecreateHandle();
                }
            }
        }

        /// <include file='doc\TextBox.uex' path='docs/doc[@for="TextBox.Text"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets
        ///       the current text in the text box.
        ///    </para>
        /// </devdoc>
        public override string Text {
            get {
                return base.Text;
            }
            set {
                base.Text = value;
                selectionSet = false;
            }
        }

        /// <include file='doc\TextBox.uex' path='docs/doc[@for="TextBox.TextAlign"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets how text is
        ///       aligned in a <see cref='System.Windows.Forms.TextBox'/>
        ///       control.
        ///    </para>
        /// </devdoc>
        [
        Localizable(true),
        SRCategory(SR.CatAppearance),
        DefaultValue(HorizontalAlignment.Left),
        SRDescription(SR.TextBoxTextAlignDescr)
        ]
        public HorizontalAlignment TextAlign {
            get {
                return textAlign;
            }
            set {
                if (textAlign != value) {
                    //verify that 'value' is a valid enum type...

                    if (!Enum.IsDefined(typeof(HorizontalAlignment), value)) {
                        throw new InvalidEnumArgumentException("value", (int)value, typeof(HorizontalAlignment));
                    }

                    textAlign = value;
                    RecreateHandle();
                    OnTextAlignChanged(EventArgs.Empty);
                }
            }
        }

        /// <include file='doc\TextBox.uex' path='docs/doc[@for="TextBox.TextAlignChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatPropertyChanged), SRDescription(SR.RadioButtonOnTextAlignChangedDescr)]
        public event EventHandler TextAlignChanged {
            add {
                Events.AddHandler(EVENT_TEXTALIGNCHANGED, value);
            }

            remove {
                Events.RemoveHandler(EVENT_TEXTALIGNCHANGED, value);
            }
        }

        internal override int GetSelectionStart()
        {
            int start = 0;
            int end = 0;
            UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.EM_GETSEL, ref start, ref end);
            //Here, we return the max of either 0 or the # returned by
            //the windows call.  This eliminates a problem on nt4 where
            //a huge negative # is being returned.
            //
            start = Math.Max(0, start);
            if (Marshal.SystemDefaultCharSize == 1 && start != 0) {
                ToUnicodeOffsets(Text, ref start, ref end);
            }
            return start;

        }

        internal override int GetLength() {
            int start = 0;
            int end = 0;
            
            UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.EM_GETSEL, ref start, ref end);
            //Here, we return the max of either 0 or the # returned by
            //the windows call.  This eliminates a problem on nt4 where
            //a huge negative # is being returned.
            //
            start = Math.Max(0, start);
            // ditto for end
            end = Math.Max(0, end);

            if (Marshal.SystemDefaultCharSize == 1) {
                ToUnicodeOffsets(Text, ref start, ref end);
            }
            return(end - start);
        }

        /// <include file='doc\TextBox.uex' path='docs/doc[@for="TextBox.IsInputKey"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Overridden to handle RETURN key.
        ///    </para>
        /// </devdoc>
        protected override bool IsInputKey(Keys keyData) {
            if (Multiline && (keyData & Keys.Alt) == 0) {
                switch (keyData & Keys.KeyCode) {
                    case Keys.Return:
                        return acceptsReturn;
                }
            }
            return base.IsInputKey(keyData);
        }

        /// <include file='doc\TextBox.uex' path='docs/doc[@for="TextBox.OnGotFocus"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    Overrideen to focus the text on first focus.
        /// </devdoc>
        protected override void OnGotFocus(EventArgs e) {
            base.OnGotFocus(e);
            if (!selectionSet) {
                // We get one shot at selecting when we first get focus.  If we don't
                // do it, we still want to act like the selection was set.
                selectionSet = true;

                // If the user didn't provide a selection, force one in.
                if (SelectionLength == 0 && Control.MouseButtons == MouseButtons.None) {
                    SelectAll();
                }
            }
        }

        /// <include file='doc\TextBox.uex' path='docs/doc[@for="TextBox.OnHandleCreated"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    Overridden to update the newly created handle with the settings of the
        ///    PasswordChar properties.
        /// </devdoc>
        protected override void OnHandleCreated(EventArgs e) {
            base.OnHandleCreated(e);
            if (passwordChar != 0) {
                SendMessage(NativeMethods.EM_SETPASSWORDCHAR, passwordChar, 0);
            }
        }
        
        /// <include file='doc\TextBox.uex' path='docs/doc[@for="TextBox.OnTextAlignChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OnTextAlignChanged(EventArgs e) {
            EventHandler eh = Events[EVENT_TEXTALIGNCHANGED] as EventHandler;
            if (eh != null) {
                 eh(this, e);
            }
        }

        /// <include file='doc\TextBox.uex' path='docs/doc[@for="TextBox.OnMouseUp"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Windows.Forms.TextBox.OnMouseUp'/> event.
        ///       
        ///    </para>
        /// </devdoc>
        protected override void OnMouseUp(MouseEventArgs mevent) {
            Point pt = new Point(mevent.X,mevent.Y);
            pt = PointToScreen(pt);

            if (mevent.Button == MouseButtons.Left) {
                if (!ValidationCancelled && UnsafeNativeMethods.WindowFromPoint(pt.X, pt.Y) == Handle) {
                    if (!doubleClickFired) {
                        OnClick(EventArgs.Empty);
                    }
                    else {
                        doubleClickFired = false;
                        OnDoubleClick(EventArgs.Empty);
                    }
                }
                doubleClickFired = false;
            }
            base.OnMouseUp(mevent);
        }

        /// <devdoc>
        ///     Performs the actual select without doing arg checking.
        /// </devdoc>        
        internal override void SelectInternal(int start, int length) {
            // If user set selection into text box, mark it so we don't
            // clobber it when we get focus.
            selectionSet = true;
            int end = start + length;

            //if our handle is created - send message...
            if (IsHandleCreated) {
                if (Marshal.SystemDefaultCharSize == 1) {
                    ToDbcsOffsets(Text, ref start, ref end);
                    SendMessage(NativeMethods.EM_SETSEL, start, end);
                }
                else {
                    SendMessage(NativeMethods.EM_SETSEL, start, end);
                }
                // CONSIDER: Both TextBox and RichTextBox will scroll to insure the caret is visible,
                // but they differ in whether they tried to make the rest of the selection visible.
            }
            else {
                //otherwise, wait until handle is created to send this message.
                //Store the indices until then...
                base.SelectionStart = start;
                base.SelectionLength = length;
            }
        }


        static void ToUnicodeOffsets(string str, ref int start, ref int end) {
            Encoding e = Encoding.Default;
        
            // Acutally, we may get away with this call if we can get the bytes from Win9x.  Dont know if it is possible.
            // This can be expensive since start/end could be small, but str.Length can be quite big.
            byte[] bytes = e.GetBytes(str);

            // Make sure start and end are within the byte array
            //
            if (start < 0) {
                start = 0;
            }
            if (start > bytes.Length) {
                start = bytes.Length;
            }
            if (end < start) {
                end = start;
            }
            if (end > bytes.Length) {
                end = bytes.Length;
            }
            
            // IMPORTANT: Avoid off-by-1 errors! 
            // The end value passed in is the character immediately after the last character selected.
            
            int newStart = start;
            if (start != 0) {
                newStart = e.GetCharCount(bytes, 0, start);
            }
            end = newStart + e.GetCharCount(bytes, start, end - start);
            start = newStart;
        }

        //-------------------------------------------------------------------------------------------------
        
        /// <include file='doc\TextBox.uex' path='docs/doc[@for="TextBox.WndProc"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    The edits window procedure.  Inheritng classes can override this
        ///    to add extra functionality, but should not forget to call
        ///    base.wndProc(m); to ensure the combo continues to function properly.
        /// </devdoc>
        [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        protected override void WndProc(ref Message m) {
            switch (m.Msg) {
                // Work around a very obscure Windows issue. See ASURT 45255.
                case NativeMethods.WM_LBUTTONDOWN:
                    MouseButtons realState = MouseButtons;
                    FocusInternal();
                    if (realState == MouseButtons && !ValidationCancelled) {
                        base.WndProc(ref m);
                    }
                    break;
                case NativeMethods.WM_LBUTTONDBLCLK:
                    doubleClickFired = true;
                    base.WndProc(ref m);
                    break;
                //for readability ... so that we know whats happening ...
                // case WM_LBUTTONUP is included here eventhough it just calls the base.
                case NativeMethods.WM_LBUTTONUP:  
                    base.WndProc(ref m);
                    break;
                default:
                    base.WndProc(ref m);
                    break;
            }
            
        }
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\tabdrawmode.cs ===
//------------------------------------------------------------------------------
// <copyright file="TabDrawMode.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;
    using System;
    using System.ComponentModel;
    using System.Drawing;
    using Microsoft.Win32;



    /// <include file='doc\TabDrawMode.uex' path='docs/doc[@for="TabDrawMode"]/*' />
    /// <devdoc>
    ///     The TabStrip and TabControl both support ownerdraw functionality, but
    ///     only one type, in which you can paint the tabs individually.  This
    ///     enumeration contains the valid values for it's drawMode property.
    /// </devdoc>
    public enum TabDrawMode {

        /// <include file='doc\TabDrawMode.uex' path='docs/doc[@for="TabDrawMode.Normal"]/*' />
        /// <devdoc>
        ///     All the items in the control are painted by the system and are of the
        ///     same size
        /// </devdoc>
        Normal = 0,

        /// <include file='doc\TabDrawMode.uex' path='docs/doc[@for="TabDrawMode.OwnerDrawFixed"]/*' />
        /// <devdoc>
        ///     The user paints the items in the control manually
        /// </devdoc>
        OwnerDrawFixed = 1,

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\tabpage.cs ===
//------------------------------------------------------------------------------
// <copyright file="TabPage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Drawing;
    using System.Drawing.Design;    
    using System.ComponentModel.Design;
    using System.Text;
    using System.Windows.Forms;
    using System.Security.Permissions;
    using Microsoft.Win32;

    /// <include file='doc\TabPage.uex' path='docs/doc[@for="TabPage"]/*' />
    /// <devdoc>
    ///     TabPage implements a single page of a tab control.  It is essentially
    ///     a Panel with TabItem properties.
    /// </devdoc>
    [
    Designer("System.Windows.Forms.Design.TabPageDesigner, " + AssemblyRef.SystemDesign),
    ToolboxItem(false),
    DesignTimeVisible(false),
    DefaultEvent("Click"),
    DefaultProperty("Text")
    ]
    public class TabPage : Panel {

        private int imageIndex = -1;
        private string toolTipText = "";

        /// <include file='doc\TabPage.uex' path='docs/doc[@for="TabPage.TabPage"]/*' />
        /// <devdoc>
        ///     Constructs an empty TabPage.
        /// </devdoc>
        public TabPage()
        : base() {
            SetStyle(ControlStyles.CacheText, true);
            Text = null;
        }

        /// <include file='doc\TabPage.uex' path='docs/doc[@for="TabPage.CreateControlsInstance"]/*' />
        /// <devdoc>
        ///     Constructs the new instance of the Controls collection objects. Subclasses
        ///     should not call base.CreateControlsInstance.  Our version creates a control
        ///     collection that does not support
        /// </devdoc>
        protected override Control.ControlCollection CreateControlsInstance() {
            return new TabPageControlCollection(this);
        }

        /// <include file='doc\TabPage.uex' path='docs/doc[@for="TabPage.ImageIndex"]/*' />
        /// <devdoc>
        ///     Returns the imageIndex for the tabPage.  This should point to an image
        ///     in the TabControl's associated imageList that will appear on the tab, or be -1.
        /// </devdoc>
        [
        TypeConverterAttribute(typeof(ImageIndexConverter)),
        Editor("System.Windows.Forms.Design.ImageIndexEditor, " + AssemblyRef.SystemDesign, typeof(UITypeEditor)),
        Localizable(true),
        DefaultValue(-1),
        SRDescription(SR.TabItemImageIndexDescr)
        ]
        public int ImageIndex {
            get { 
                return imageIndex;
            }
            set {
                if (value < -1)
                    throw new ArgumentException(SR.GetString(SR.InvalidLowBoundArgumentEx,
                                                              "imageIndex",
                                                              (value).ToString(),
                                                              "-1"));

                this.imageIndex = value;
                UpdateParent();
            }
        }

        /// <include file='doc\TabPage.uex' path='docs/doc[@for="TabPage.TabPage1"]/*' />
        /// <devdoc>
        ///     Constructs a TabPage with text for the tab.
        /// </devdoc>
        public TabPage(string text) : this() {
            Text = text;
        }

        /// <include file='doc\TabPage.uex' path='docs/doc[@for="TabPage.Anchor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override AnchorStyles Anchor {
            get {
                return base.Anchor;
            }
            set {
                base.Anchor = value;
            }
        }

        /// <include file='doc\TabPage.uex' path='docs/doc[@for="TabPage.Dock"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override DockStyle Dock {
            get {
                return base.Dock;
            }
            set {
                base.Dock = value;
            }
        }

        /// <include file='doc\TabPage.uex' path='docs/doc[@for="TabPage.DockChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler DockChanged {
            add {
                base.DockChanged += value;
            }
            remove {
                base.DockChanged -= value;
            }
        }

        /// <include file='doc\TabPage.uex' path='docs/doc[@for="TabPage.Enabled"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public bool Enabled {
            get {
                return base.Enabled;
            }

            set {
                base.Enabled = value;
            }
        }

        /// <include file='doc\TabPage.uex' path='docs/doc[@for="TabPage.EnabledChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler EnabledChanged {
            add {
                base.EnabledChanged += value;
            }
            remove {
                base.EnabledChanged -= value;
            }
        }
        
        /// <include file='doc\TabPage.uex' path='docs/doc[@for="TabPage.TabIndex"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public int TabIndex {
            get {
                return base.TabIndex;
            }
            set {
                base.TabIndex = value;
            }
        }

        /// <include file='doc\TabPage.uex' path='docs/doc[@for="TabPage.TabIndexChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler TabIndexChanged {
            add {
                base.TabIndexChanged += value;
            }
            remove {
                base.TabIndexChanged -= value;
            }
        }

        /// <include file='doc\TabPage.uex' path='docs/doc[@for="TabPage.TabStop"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public bool TabStop {
            get {
                return base.TabStop;
            }
            set {
                base.TabStop = value;
            }
        }

        /// <include file='doc\TabPage.uex' path='docs/doc[@for="TabPage.TabStopChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler TabStopChanged {
            add {
                base.TabStopChanged += value;
            }
            remove {
                base.TabStopChanged -= value;
            }
        }

        /// <include file='doc\TabPage.uex' path='docs/doc[@for="TabPage.Text"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        Localizable(true),
        Browsable(true)
        ]
        public override string Text {
            get {
                return base.Text;
            }
            set {
                base.Text = value;
                UpdateParent();
            }
        }

        /// <include file='doc\TabPage.uex' path='docs/doc[@for="TabPage.ToolTipText"]/*' />
        /// <devdoc>
        ///     The toolTipText for the tab, that will appear when the mouse hovers
        ///     over the tab and the TabControl's showToolTips property is true.
        /// </devdoc>
        [
        DefaultValue(""),
        Localizable(true),
        SRDescription(SR.TabItemToolTipTextDescr)
        ]
        public string ToolTipText {
            get {
                return toolTipText;
            }
            set {
                if (value == null) {
                    value = "";
                }

                if (value == toolTipText)
                    return;

                toolTipText = value;

                UpdateParent();
            }
        }

        /// <include file='doc\TabPage.uex' path='docs/doc[@for="TabPage.Visible"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public bool Visible {
            get {
                return base.Visible;
            }
            set {
                base.Visible = value;
            }
        }

        /// <include file='doc\TabPage.uex' path='docs/doc[@for="TabPage.VisibleChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler VisibleChanged {
            add {
                base.VisibleChanged += value;
            }
            remove {
                base.VisibleChanged -= value;
            }
        }
        
        /// <devdoc>
        ///     Assigns a new parent control. Sends out the appropriate property change
        ///     notifications for properties that are affected by the change of parent.
        /// </devdoc>
        [UIPermission(SecurityAction.LinkDemand, Window=UIPermissionWindow.AllWindows)]
        internal override void AssignParent(Control value) {
            if (value != null && !(value is TabControl)) {
                throw new ArgumentException(SR.GetString(SR.TABCONTROLTabPageNotOnTabControl, value.GetType().FullName));
            }

            base.AssignParent(value);
        }

        /// <include file='doc\TabPage.uex' path='docs/doc[@for="TabPage.GetTabPageOfComponent"]/*' />
        /// <devdoc>
        ///     Given a component, this retrieves the tab page that it's parented to, or
        /// null if it's not parented to any tab page.
        /// </devdoc>
        public static TabPage GetTabPageOfComponent(Object comp) {
            if (!(comp is Control)) {
                return null;
            }

            Control c = (Control)comp;
            while (c != null && !(c is TabPage)) {
                c = c.ParentInternal;
            }
            return(TabPage)c;
        }

        /// <include file='doc\TabPage.uex' path='docs/doc[@for="TabPage.GetTCITEM"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        internal NativeMethods.TCITEM_T GetTCITEM() {
            NativeMethods.TCITEM_T tcitem = new NativeMethods.TCITEM_T();

            tcitem.mask = 0;
            tcitem.pszText = null;
            tcitem.cchTextMax = 0;
            tcitem.lParam = IntPtr.Zero;

            string text = Text;
            PrefixAmpersands(ref text);

            if (text != null) {
                tcitem.mask |= NativeMethods.TCIF_TEXT;
                tcitem.pszText = text;
                tcitem.cchTextMax = text.Length;
            }

            int imageIndex = ImageIndex;

            tcitem.mask |= NativeMethods.TCIF_IMAGE;
            tcitem.iImage = imageIndex;

            return tcitem;
        }
        
        private void PrefixAmpersands(ref string value) {
            // Due to a comctl32 problem, ampersands underline the next letter in the 
            // text string, but the accelerators don't work.
            // So in this function, we prefix ampersands with another ampersand
            // so that they actually appear as ampersands.
            //
            
            // Sanity check parameter
            //
            if (value == null || value.Length == 0) {
                return;
            }
            
            // If there are no ampersands, we don't need to do anything here
            //
            if (value.IndexOf('&') < 0) {
                return;
            }
            
            // Insert extra ampersands
            //
            StringBuilder newString = new StringBuilder();
            for(int i=0; i < value.Length; ++i) {
                if (value[i] == '&') { 
                    if (i < value.Length - 1 && value[i+1] == '&') {
                        ++i;    // Skip the second ampersand
                    }
                    newString.Append("&&");
                }
                else {
                    newString.Append(value[i]);    
                }
            }
            
            value = newString.ToString();
        }

        /// <include file='doc\TabPage.uex' path='docs/doc[@for="TabPage.SetBoundsCore"]/*' />
        /// <devdoc>
        ///     overrides main setting of our bounds so that we can control our size and that of our
        ///     TabPages...
        /// </devdoc>
        /// <internalonly/>
        protected override void SetBoundsCore(int x, int y, int width, int height, BoundsSpecified specified) {
            Control parent = ParentInternal;

            if (parent is TabControl && parent.IsHandleCreated) {
                Rectangle r = parent.DisplayRectangle;
                base.SetBoundsCore(r.X, r.Y, r.Width, r.Height, BoundsSpecified.All);
            }
            else {
                base.SetBoundsCore(x, y, width, height, specified);
            }
        }

        /// <devdoc>
        ///     Determines if the Location property needs to be persisted.
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Never)]
        private bool ShouldSerializeLocation() {
            return Left != 0 || Top != 0;
        }

        /// <include file='doc\TabPage.uex' path='docs/doc[@for="TabPage.ToString"]/*' />
        /// <devdoc>
        ///     The text property is what is returned for the TabPages default printing.
        /// </devdoc>
        public override string ToString() {
            return "TabPage: {" + Text + "}";
        }

        /// <include file='doc\TabPage.uex' path='docs/doc[@for="TabPage.UpdateParent"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        internal void UpdateParent() {
            TabControl parent = ParentInternal as TabControl;
            if (parent != null) {
                parent.UpdateTab(this);
            }
        }

        /// <include file='doc\TabPage.uex' path='docs/doc[@for="TabPage.TabPageControlCollection"]/*' />
        /// <devdoc>
        ///      Our control collection will throw an exception if you try to add other tab pages.
        /// </devdoc>
        public class TabPageControlCollection : Control.ControlCollection {

            /// <internalonly/>
            /// <include file='doc\TabPage.uex' path='docs/doc[@for="TabPage.TabPageControlCollection.TabPageControlCollection"]/*' />
            /// <devdoc>
            ///      Creates a new TabPageControlCollection.
            /// </devdoc>
            public TabPageControlCollection(TabPage owner) : base(owner) {
            }

            /// <include file='doc\TabPage.uex' path='docs/doc[@for="TabPage.TabPageControlCollection.Add"]/*' />
            /// <devdoc>
            ///     Adds a child control to this control. The control becomes the last control
            ///     in the child control list. If the control is already a child of another
            ///     control it is first removed from that control.  The tab page overrides
            ///     this method to ensure that child tab pages are not added to it, as these
            ///     are illegal.
            /// </devdoc>
            public override void Add(Control value) {
                if (value is TabPage) {
                    throw new ArgumentException(SR.GetString(SR.TABCONTROLTabPageOnTabPage));
                }
                base.Add(value);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\tabsizemode.cs ===
//------------------------------------------------------------------------------
// <copyright file="TabSizeMode.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {

    using System.Diagnostics;
    using System;
    using System.ComponentModel;
    using System.Drawing;
    using Microsoft.Win32;



    /// <include file='doc\TabSizeMode.uex' path='docs/doc[@for="TabSizeMode"]/*' />
    /// <devdoc>
    ///     Controls the automatic sizing of certain objects.  This is typically
    ///     used for the sizing of Tabs in a TabStrip control.
    /// </devdoc>
    public enum TabSizeMode {

        /// <include file='doc\TabSizeMode.uex' path='docs/doc[@for="TabSizeMode.Normal"]/*' />
        /// <devdoc>
        ///     Indicates that items are only as wide as they need to be to display
        ///     their information.  Empty space on the right is left as such
        /// </devdoc>
        Normal = 0,

        /// <include file='doc\TabSizeMode.uex' path='docs/doc[@for="TabSizeMode.FillToRight"]/*' />
        /// <devdoc>
        ///     indicates that the tags are stretched to ensure they reach the far
        ///     right of the strip, if necesary.  This is only applicable to tab
        ///     strips with more than one row.
        /// </devdoc>
        FillToRight = 1,

        /// <include file='doc\TabSizeMode.uex' path='docs/doc[@for="TabSizeMode.Fixed"]/*' />
        /// <devdoc>
        ///     Indicates that all tabs are the same width. period.
        /// </devdoc>
        Fixed = 2,

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\textboxbase.cs ===
//------------------------------------------------------------------------------
// <copyright file="TextBoxBase.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {
    using System.Text;
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.InteropServices;
    using System.Runtime.Remoting;
    using System.Diagnostics;
    using System;
    using System.Collections;
    using System.Collections.Specialized;
    using SecurityManager = System.Security.SecurityManager;
    using System.Security.Permissions;
    using System.Windows.Forms;
    using System.ComponentModel.Design;
    using System.ComponentModel;
    using System.Drawing;
    using System.Drawing.Design;
    using Microsoft.Win32;
    using System.Reflection;

    /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Implements the basic functionality required by text
    ///       controls.
    ///    </para>
    /// </devdoc>
    [
    DefaultEvent("TextChanged"),
    Designer("System.Windows.Forms.Design.TextBoxBaseDesigner, " + AssemblyRef.SystemDesign)
    ]
    public abstract class TextBoxBase : Control {

        // The boolean properties for this control are contained in the textBoxFlags bit 
        // vector.  We can store up to 32 boolean values in this one vector.  Here we
        // create the bitmasks for each bit in the vector.
        //
        private static readonly int autoSize         = BitVector32.CreateMask();
        private static readonly int hideSelection    = BitVector32.CreateMask(autoSize);
        private static readonly int multiline        = BitVector32.CreateMask(hideSelection);
        private static readonly int modified         = BitVector32.CreateMask(multiline);
        private static readonly int readOnly         = BitVector32.CreateMask(modified);
        private static readonly int acceptsTab       = BitVector32.CreateMask(readOnly);
        private static readonly int wordWrap         = BitVector32.CreateMask(acceptsTab);
        private static readonly int creatingHandle   = BitVector32.CreateMask(wordWrap);
        private static readonly int codeUpdateText   = BitVector32.CreateMask(creatingHandle);

        private static readonly object EVENT_ACCEPTSTABCHANGED      = new object();
        private static readonly object EVENT_AUTOSIZECHANGED        = new object();
        private static readonly object EVENT_BORDERSTYLECHANGED     = new object();
        private static readonly object EVENT_HIDESELECTIONCHANGED   = new object();
        private static readonly object EVENT_MODIFIEDCHANGED        = new object();
        private static readonly object EVENT_MULTILINECHANGED       = new object();
        private static readonly object EVENT_READONLYCHANGED        = new object();

        private short prefHeightCache=-1;        

        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.borderStyle"]/*' />
        /// <devdoc>
        ///     The current border for this edit control.
        /// </devdoc>
        private BorderStyle borderStyle = System.Windows.Forms.BorderStyle.Fixed3D;

        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.maxLength"]/*' />
        /// <devdoc>
        ///     Controls the maximum length of text in the edit control.
        /// </devdoc>
        private int maxLength = 32767; // Win9X default, used for consistency

        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.requestedHeight"]/*' />
        /// <devdoc>
        ///     Used by the autoSizing code to help figure out the desired height of
        ///     the edit box.
        /// </devdoc>
        private int requestedHeight;
        bool integralHeightAdjust = false;
        //these indices are used to cache the values of the selection, by doing this
        //if the handle isn't created yet, we don't force a creation.
        private int selectionStart = -1;
        private int selectionLength   = -1;

        // We store all boolean properties in here.
        //
        private BitVector32 textBoxFlags = new BitVector32();

        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.TextBoxBase"]/*' />
        /// <devdoc>
        ///     Creates a new TextBox control.  Uses the parent's current font and color
        ///     set.
        ///     Note: If you change this constructor, be sure to change the one below in the
        ///     exact same way.
        /// </devdoc>
        internal TextBoxBase() : base() {
            textBoxFlags[autoSize | hideSelection | wordWrap] = true;
            SetStyle(ControlStyles.UserPaint, false);
            SetStyle(ControlStyles.FixedHeight, textBoxFlags[autoSize]);
            requestedHeight = DefaultSize.Height;
            
            requestedHeight = Height;
        }
        
        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.AcceptsTab"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets
        ///       a value indicating whether pressing the TAB key
        ///       in a multiline text box control types
        ///       a TAB character in the control instead of moving the focus to the next control
        ///       in the tab order.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(false),
        SRDescription(SR.TextBoxAcceptsTabDescr)
        ]
        public bool AcceptsTab {
            get {
                return textBoxFlags[acceptsTab];
            }
            set {
                if (textBoxFlags[acceptsTab] != value) {
                    textBoxFlags[acceptsTab] = value;
                    OnAcceptsTabChanged(EventArgs.Empty);
                }
            }
        }

        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.AcceptsTabChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatPropertyChanged), SRDescription(SR.TextBoxBaseOnAcceptsTabChangedDescr)]
        public event EventHandler AcceptsTabChanged {
            add {
                Events.AddHandler(EVENT_ACCEPTSTABCHANGED, value);
            }
            remove {
                Events.RemoveHandler(EVENT_ACCEPTSTABCHANGED, value);
            }
        }

        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.AutoSize"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating
        ///       whether the size
        ///       of the control automatically adjusts when the font assigned to the control
        ///       is changed is changed.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(true),
        Localizable(true),
        SRDescription(SR.TextBoxAutoSizeDescr),
        RefreshProperties(RefreshProperties.Repaint),
        ]
        public virtual bool AutoSize {
            get {
                return textBoxFlags[autoSize];
            }
            set {
                if (textBoxFlags[autoSize] != value) {
                    textBoxFlags[autoSize] = value;

                    // AutoSize's effects are ignored for a multi-line textbox
                    //                        
                    if (!Multiline) {
                        SetStyle(ControlStyles.FixedHeight, value);
                        AdjustHeight();                         
                    }

                    OnAutoSizeChanged(EventArgs.Empty);
                }
            }
        }

        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.AutoSizeChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatPropertyChanged), SRDescription(SR.TextBoxBaseOnAutoSizeChangedDescr)]
        public event EventHandler AutoSizeChanged {
            add {
                Events.AddHandler(EVENT_AUTOSIZECHANGED, value);
            }
            remove {
                Events.RemoveHandler(EVENT_AUTOSIZECHANGED, value);
            }
        }

        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.BackColor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets
        ///       the background color of the control.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        DispId(NativeMethods.ActiveX.DISPID_BACKCOLOR),
        SRDescription(SR.ControlBackColorDescr)
        ]
        public override Color BackColor {
            get {
                if (ShouldSerializeBackColor()) {
                    return base.BackColor;
                }
                else {
                    return SystemColors.Window;
                }
            }
            set {
                base.BackColor = value;
            }
        }


        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.BackgroundImage"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override Image BackgroundImage {
            get {
                return base.BackgroundImage;
            }
            set {
                base.BackgroundImage = value;
            }
        }

        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.BackgroundImageChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler BackgroundImageChanged {
            add {
                base.BackgroundImageChanged += value;
            }
            remove {
                base.BackgroundImageChanged -= value;
            }
        }

        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.BorderStyle"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the border type
        ///       of the text box control.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        DefaultValue(BorderStyle.Fixed3D),
        DispId(NativeMethods.ActiveX.DISPID_BORDERSTYLE),
        SRDescription(SR.TextBoxBorderDescr)
        ]
        public BorderStyle BorderStyle {
            get {
                return borderStyle;
            }

            set {
                if (borderStyle != value) {
                    //verify that 'value' is a valid enum type...

                    if (!Enum.IsDefined(typeof(BorderStyle), value)) {
                        throw new InvalidEnumArgumentException("value", (int)value, typeof(BorderStyle));
                    }

                    borderStyle = value;
                    prefHeightCache = -1;  //reset the cached height value - forcing it to recalculate
                    UpdateStyles();
                    RecreateHandle();
                    OnBorderStyleChanged(EventArgs.Empty);
                }
            }
        }
        
        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.BorderStyleChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatPropertyChanged), SRDescription(SR.TextBoxBaseOnBorderStyleChangedDescr)]
        public event EventHandler BorderStyleChanged {
            add {
                Events.AddHandler(EVENT_BORDERSTYLECHANGED, value);
            }
            remove {
                Events.RemoveHandler(EVENT_BORDERSTYLECHANGED, value);
            }
        }

        internal virtual bool CanRaiseTextChangedEvent {
            get {
                return true;
            }
        }

        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.CanUndo"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value
        ///       indicating whether the user can undo the previous operation in a text box control.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.TextBoxCanUndoDescr)
        ]
        public bool CanUndo {
            get {
                if (IsHandleCreated) {
                    bool b;
                    b = (int)SendMessage(NativeMethods.EM_CANUNDO, 0, 0) != 0;

                    return b;
                }
                return false;
            }
        }

        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.CreateParams"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Returns the parameters needed to create the handle. Inheriting classes
        ///       can override this to provide extra functionality. They should not,
        ///       however, forget to call base.getCreateParams() first to get the struct
        ///       filled up with the basic info.
        ///    </para>
        /// </devdoc>
        protected override CreateParams CreateParams {
            [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
            get {
                CreateParams cp = base.CreateParams;
                cp.ClassName = "EDIT";
                cp.Style |= NativeMethods.ES_AUTOHSCROLL | NativeMethods.ES_AUTOVSCROLL;
                if (!textBoxFlags[hideSelection]) cp.Style |= NativeMethods.ES_NOHIDESEL;
                if (textBoxFlags[readOnly]) cp.Style |= NativeMethods.ES_READONLY;
                cp.ExStyle &= (~NativeMethods.WS_EX_CLIENTEDGE);
                cp.Style &= (~NativeMethods.WS_BORDER);
                
                switch (borderStyle) {
                    case BorderStyle.Fixed3D:
                        cp.ExStyle |= NativeMethods.WS_EX_CLIENTEDGE;
                        break;
                    case BorderStyle.FixedSingle:
                        cp.Style |= NativeMethods.WS_BORDER;
                        break;
                }
                if (textBoxFlags[multiline]) {
                    cp.Style |= NativeMethods.ES_MULTILINE;
                    if (textBoxFlags[wordWrap]) cp.Style &= ~NativeMethods.ES_AUTOHSCROLL;
                }
                return cp;
            }
        }

        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.Click"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced)]
        public new event EventHandler Click {
            add {
                base.Click += value;
            }
            remove {
                base.Click -= value;
            }
        }

        internal override Cursor DefaultCursor {
            get {
                return Cursors.IBeam;
            }
        }

        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.DefaultSize"]/*' />
        /// <devdoc>
        ///     Deriving classes can override this to configure a default size for their control.
        ///     This is more efficient than setting the size in the control's constructor.
        /// </devdoc>
        protected override Size DefaultSize {
            get {
                return new Size(100, PreferredHeight);
            }
        }

        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.ForeColor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the foreground color of the control.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        DispId(NativeMethods.ActiveX.DISPID_FORECOLOR),
        SRDescription(SR.ControlForeColorDescr)
        ]
        public override Color ForeColor {
            get {
                if (ShouldSerializeForeColor()) {
                    return base.ForeColor;
                }
                else {
                    return SystemColors.WindowText;
                }
            }
            set {
                base.ForeColor = value;
            }
        }

        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.HideSelection"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the selected
        ///       text in the text box control remains highlighted when the control loses focus.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(true),
        SRDescription(SR.TextBoxHideSelectionDescr)
        ]
        public bool HideSelection {
            get {
                return textBoxFlags[hideSelection];
            }

            set {
                if (textBoxFlags[hideSelection] != value) {
                    textBoxFlags[hideSelection] = value;
                    RecreateHandle();
                    OnHideSelectionChanged(EventArgs.Empty);
                }
            }
        }

        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.HideSelectionChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatPropertyChanged), SRDescription(SR.TextBoxBaseOnHideSelectionChangedDescr)]
        public event EventHandler HideSelectionChanged {
            add {
                Events.AddHandler(EVENT_HIDESELECTIONCHANGED, value);
            }
            remove {
                Events.RemoveHandler(EVENT_HIDESELECTIONCHANGED, value);
            }
        }

        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.Lines"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or
        ///       sets the lines of text in an text box control.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        Localizable(true),
        SRDescription(SR.TextBoxLinesDescr),
        Editor("System.Windows.Forms.Design.StringArrayEditor, " + AssemblyRef.SystemDesign, typeof(UITypeEditor))
        ]
        public string[] Lines {
            get {
                string text = Text;
                ArrayList list = new ArrayList();

                int lineStart = 0;
                while (lineStart < text.Length) {
                    int lineEnd = lineStart;
                    for (; lineEnd < text.Length; lineEnd++) {
                        char c = text[lineEnd];
                        if (c == '\r' || c == '\n')
                            break;
                    }

                    string line = text.Substring(lineStart, lineEnd - lineStart);
                    list.Add(line);

                    // Treat "\r", "\r\n", and "\n" as new lines
                    if (lineEnd < text.Length && text[lineEnd] == '\r')
                        lineEnd++;
                    if (lineEnd < text.Length && text[lineEnd] == '\n')
                        lineEnd++;

                    lineStart = lineEnd;
                }

                // Corner case -- last character in Text is a new line; need to add blank line to list
                if (text.Length > 0 && (text[text.Length - 1] == '\r' || text[text.Length - 1] == '\n'))
                    list.Add("");

                return(string[]) list.ToArray(typeof(string));
            }
            set {
                //unparse this string list...
                if (value != null && value.Length > 0) {

                    // Work Item #40689:
                    // Using a StringBuilder instead of a String
                    // speeds things up approx 150 times
                    StringBuilder text = new StringBuilder(value[0]);
                    for (int i=1; i < value.Length; ++i) {
                        text.Append("\r\n");
                        text.Append(value[i]);
                    }
                    Text = text.ToString();
                }
                else {
                    Text = "";
                }
            }
        }

        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.MaxLength"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the maximum number of
        ///       characters the user can type into the text box control.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(32767),
        Localizable(true),
        SRDescription(SR.TextBoxMaxLengthDescr)
        ]
        public virtual int MaxLength {
            get {
                return maxLength;
            }
            set {
                if (value < 0) {
                    throw new ArgumentException(SR.GetString(SR.InvalidLowBoundArgumentEx, "MaxLength",
                                                             (value).ToString(), "0"));
                }

                if (maxLength != value) {
                    maxLength = value;
                    UpdateMaxLength();
                }
            }
        }

        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.Modified"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value that indicates that the text box control has been modified by the user since
        ///       the control was created or its contents were last set.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.TextBoxModifiedDescr)
        ]
        public bool Modified {
            get {
                if (IsHandleCreated)
                    return(0 != (int)SendMessage(NativeMethods.EM_GETMODIFY, 0, 0));
                else
                    return textBoxFlags[modified];

            }

            set {
                if (Modified != value) {
                    if (IsHandleCreated)
                        SendMessage(NativeMethods.EM_SETMODIFY, value ? 1 : 0, 0);
                    else
                        textBoxFlags[modified] = value;

                    OnModifiedChanged(EventArgs.Empty);
                }
            }
        }

        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.ModifiedChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatPropertyChanged), SRDescription(SR.TextBoxBaseOnModifiedChangedDescr)]
        public event EventHandler ModifiedChanged {
            add {
                Events.AddHandler(EVENT_MODIFIEDCHANGED, value);
            }
            remove {
                Events.RemoveHandler(EVENT_MODIFIEDCHANGED, value);
            }
        }

        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.Multiline"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether this
        ///       is a multiline text box control.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(false),
        Localizable(true),
        SRDescription(SR.TextBoxMultilineDescr),
        RefreshProperties(RefreshProperties.All)
        ]
        public virtual bool Multiline {
            get {
                return textBoxFlags[multiline];
            }
            set {
                if (textBoxFlags[multiline] != value) {
                    textBoxFlags[multiline] = value;

                    if (value) {
                        // Multi-line textboxes do not have fixed height
                        //
                        SetStyle(ControlStyles.FixedHeight, false);
                    }
                    else {
                        // Single-line textboxes may have fixed height, depending on AutoSize
                        SetStyle(ControlStyles.FixedHeight, AutoSize);
                    }

                    RecreateHandle();
                    AdjustHeight();
                    OnMultilineChanged(EventArgs.Empty);
                }
            }
        }

        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.MultilineChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatPropertyChanged), SRDescription(SR.TextBoxBaseOnMultilineChangedDescr)]
        public event EventHandler MultilineChanged {
            add {
                Events.AddHandler(EVENT_MULTILINECHANGED, value);
            }
            remove {
                Events.RemoveHandler(EVENT_MULTILINECHANGED, value);
            }
        }

        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.PreferredHeight"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the preferred
        ///       height for a single-line text box.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatLayout),
        Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.TextBoxPreferredHeightDescr)
        ]
        public int PreferredHeight {
            get {
                if (prefHeightCache > -1)
                    return(int)prefHeightCache;

                int height = FontHeight;

                if (borderStyle != BorderStyle.None) {
                    height += SystemInformation.BorderSize.Height * 4 + 3;
                }

                prefHeightCache = (short)height;
                return height;
            }
        }

        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.ReadOnly"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether text in the text box is read-only.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(false),
        SRDescription(SR.TextBoxReadOnlyDescr)
        ]
        public bool ReadOnly {
            get {
                return textBoxFlags[readOnly];
            }
            set {
                if (textBoxFlags[readOnly] != value) {
                    textBoxFlags[readOnly] = value;
                    if (IsHandleCreated) {
                        SendMessage(NativeMethods.EM_SETREADONLY, value? -1: 0, 0);
                    }
                    OnReadOnlyChanged(EventArgs.Empty);
                }
            }
        }

        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.ReadOnlyChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatPropertyChanged), SRDescription(SR.TextBoxBaseOnReadOnlyChangedDescr)]
        public event EventHandler ReadOnlyChanged {
            add {
                Events.AddHandler(EVENT_READONLYCHANGED, value);
            }
            remove {
                Events.RemoveHandler(EVENT_READONLYCHANGED, value);
            }
        }

        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.SelectedText"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The currently selected text in the control.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.TextBoxSelectedTextDescr)
        ]
        public virtual string SelectedText {
            get {
                string returnString;

                if (SelectionStart != -1 ) {
                    returnString = Text.Substring(SelectionStart, SelectionLength);
                }
                else 
                    returnString = null;

                return returnString;
            }
            set {
                if (IsHandleCreated) {
                    
                    SendMessage(NativeMethods.EM_LIMITTEXT, 32767, 0);
                    
                    SendMessage(NativeMethods.EM_REPLACESEL, -1, value == null? "": value);
                    
                    // For consistency with Text, we clear the modified flag
                    SendMessage(NativeMethods.EM_SETMODIFY, 0, 0);
                    
                    SendMessage(NativeMethods.EM_LIMITTEXT, maxLength, 0);
                    
                }
                else {
                    // looks like SelectionStart & SelectionLength have to be at least 0
                    //
                    string before = Text.Substring(0, SelectionStart);
                    string after = "";

                    if (SelectionStart + SelectionLength < Text.Length) {
                        Text.Substring(SelectionStart + SelectionLength);
                    }
                    base.Text =  before + value + after;
                }
                ClearUndo();
            }
        }

        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.SelectionLength"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the number of characters selected in the text
        ///       box.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.TextBoxSelectionLengthDescr)
        ]
        public virtual int SelectionLength {
            get {
                if (!IsHandleCreated) return selectionLength;

                int start = 0;
                int end = 0;
                UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.EM_GETSEL, ref start, ref end);

                //Here, we return the max of either 0 or the # returned by
                //the windows call.  This eliminates a problem on nt4 where
                //a huge negative # is being returned.
                //
                start = Math.Max(0, start);
                // ditto for end
                end = Math.Max(0, end);
               
#if DEBUG
                string t = WindowText;
                int len;
                if (t == null) {
                    len = 0;
                }
                else {
                    len = t.Length;
                }
                Debug.Assert(end <= len, "SelectionEnd is outside the set of valid caret positions for the current WindowText (end =" 
                             + end + ", WindowText.Length =" + len +")");
#endif
                return end - start;
            }
            set {
                if (value < 0)
                    throw new ArgumentException(SR.GetString(SR.InvalidArgument, "value", value.ToString()));
                
                if (value != selectionLength) {
                    if (SelectionStart != -1 )
                        Select(SelectionStart, value);
                    else
                        Select(0, value);

                }
            }
        }

        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.SelectionStart"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the starting
        ///       point of text selected in the text
        ///       box.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.TextBoxSelectionStartDescr)
        ]
        public int SelectionStart {
            get {
                if (!IsHandleCreated) return selectionStart;
                return GetSelectionStart();

            }
            set {
                if (value < 0)
                    throw new ArgumentException(SR.GetString(SR.InvalidArgument, "value", "" + value.ToString()));
                    
                int length = GetLength();
                Select(value, Math.Max(length, 0));
            }
        }

        // Call SetSelectionOnHandle inside CreateHandle()
        internal virtual bool SetSelectionInCreateHandle {
            get {
                return true;
            }
        }

        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.Text"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets
        ///       the current text in the text box.
        ///    </para>
        /// </devdoc>
        [
        Localizable(true)
        ]
        public override string Text {
            get {
                return base.Text;
            }
            set {
                if (value != base.Text) {
                    base.Text = value;
                    if (IsHandleCreated) {
                        // clear the modified flag
                        SendMessage(NativeMethods.EM_SETMODIFY, 0, 0);
                    }
                }
            }
        }

        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.TextLength"]/*' />
        [Browsable(false)]
        public virtual int TextLength {
            get {
                if (IsHandleCreated && Marshal.SystemDefaultCharSize == 2) {
                    return SafeNativeMethods.GetWindowTextLength(new HandleRef(this, Handle));
                }
                else {
                    return Text.Length;
                }
            }
        }

        // Since setting the WindowText while the handle is created
        // generates a WM_COMMAND message, we must trap that case
        // and prevent the event from getting fired, or we get
        // double "TextChanged" events.
        //
        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.WindowText"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        internal override string WindowText {
            [PermissionSetAttribute(SecurityAction.LinkDemand, Name="FullTrust")]
            get {
                return base.WindowText;
            }
            
            [PermissionSetAttribute(SecurityAction.LinkDemand, Name="FullTrust")]
            set {
                if (value == null) value = "";
                if (!WindowText.Equals(value)) {
                    textBoxFlags[codeUpdateText] = true;
                    try {
                        base.WindowText = value;
                    }
                    finally {
                        textBoxFlags[codeUpdateText] = false;
                    }
                }
            }
        }

        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.WordWrap"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether a
        ///       multiline text box control automatically wraps words to the beginning of the next
        ///       line when necessary.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior), 
        Localizable(true),
        DefaultValue(true),
        SRDescription(SR.TextBoxWordWrapDescr)
        ]
        public bool WordWrap {
            get {
                return textBoxFlags[wordWrap];
            }
            set {
                SetWordWrapInternal(value);
            }
        }
        
        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.AdjustHeight"]/*' />
        /// <devdoc>
        ///     Adjusts the height of a single-line edit control to match the height of
        ///     the control's font.
        /// </devdoc>
        /// <internalonly/>
        private void AdjustHeight() {

            // If we're anchored to two opposite sides of the form, don't adjust the size because
            // we'll lose our anchored size by resetting to the requested width.
            //
            if ((this.Anchor & (AnchorStyles.Top | AnchorStyles.Bottom)) == (AnchorStyles.Top | AnchorStyles.Bottom)) {                
                return;
            }

            prefHeightCache = -1;//clear the height cache
            FontHeight = -1;//clear the font height cache

            int saveHeight = requestedHeight;
            try {
                if (textBoxFlags[autoSize] && !textBoxFlags[multiline]) {
                    Height = PreferredHeight;
                }
                else {

                    int curHeight = Height;

                    // Changing the font of a multi-line textbox can sometimes cause a painting problem
                    // The only workaround I can find is to size the textbox big enough for the font, and
                    // then restore its correct size.
                    //
                    if (textBoxFlags[multiline]) {
                        Height = Math.Max(saveHeight, PreferredHeight + 2); // 2 = fudge factor
                    
                    }
                    
                    integralHeightAdjust = true;
                    try {
                         Height = saveHeight;
                    }
                    finally {
                             integralHeightAdjust = false;
                    }
                    
                }
            }
            finally {
                requestedHeight = saveHeight;
            }
        }

        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.AppendText"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Append text to the current text of text box.
        ///    </para>
        /// </devdoc>
        public void AppendText( string text ) {
            // +1 because RichTextBox has this funny EOF pseudo-character after all the text.
            // This enables you to use SelectionColor to AppendText in color.
            int endOfText;
             
            if (IsHandleCreated) {
                endOfText = SafeNativeMethods.GetWindowTextLength(new HandleRef(this, Handle)) + 1;
            }
            else {
                endOfText = TextLength;
            }
            SelectInternal(endOfText, endOfText);
            SelectedText = text;
        }

        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.Clear"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Clears all text from the text box control.
        ///    </para>
        /// </devdoc>
        public void Clear() {
            Text = null;
        }

        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.ClearUndo"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Clears information about the most recent operation
        ///       from the undo buffer of the text box.
        ///    </para>
        /// </devdoc>
        public void ClearUndo() {
            if (IsHandleCreated) {
                SendMessage(NativeMethods.EM_EMPTYUNDOBUFFER, 0, 0);
            }
        }

        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.Copy"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Copies the current selection in the text box to the Clipboard.
        ///    </para>
        /// </devdoc>
        public void Copy() {
            SendMessage(NativeMethods.WM_COPY, 0, 0);
        }
        
        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.CreateHandle"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        protected override void CreateHandle() {
            // This "creatingHandle" stuff is to avoid property change events
            // when we set the Text property.
            textBoxFlags[creatingHandle] = true;
            try {
                base.CreateHandle();

                if (SetSelectionInCreateHandle) {
                    // send EM_SETSEL message
                    SetSelectionOnHandle();
                }
            }
            finally {
                textBoxFlags[creatingHandle] = false;
            }
        }

        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.Cut"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Moves the current selection in the text box to the Clipboard.
        ///    </para>
        /// </devdoc>
        public void Cut() {
            SendMessage(NativeMethods.WM_CUT, 0, 0);
        }

        [PermissionSetAttribute(SecurityAction.InheritanceDemand, Name="FullTrust")]
        [PermissionSetAttribute(SecurityAction.LinkDemand, Name="FullTrust")]
        internal virtual int GetSelectionStart()
        {
            int start = 0;
            int end = 0;
            UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.EM_GETSEL, ref start, ref end);
            //Here, we return the max of either 0 or the # returned by
            //the windows call.  This eliminates a problem on nt4 where
            //a huge negative # is being returned.
            //
            start = Math.Max(0, start);
            return start;
        }

        [PermissionSetAttribute(SecurityAction.InheritanceDemand, Name="FullTrust")]
        [PermissionSetAttribute(SecurityAction.LinkDemand, Name="FullTrust")]
        internal virtual int GetLength() {
            
            int start = 0;
            int end = 0;
            UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.EM_GETSEL, ref start, ref end);
            return (end - start);
        }

        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.IsInputKey"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    Overridden to handle TAB key.
        /// </devdoc>
        protected override bool IsInputKey(Keys keyData) {
            if ((keyData & Keys.Alt) != Keys.Alt) {
                switch (keyData & Keys.KeyCode) {
                    case Keys.Tab:
                        // Single-line RichEd's want tab characters (see WM_GETDLGCODE), 
                        // so we don't ask it
                        return Multiline && textBoxFlags[acceptsTab] && ((keyData & Keys.Control) == 0);
                    case Keys.Escape:
                        if (Multiline)
                            return false;
                        break;
                    case Keys.PageUp:
                    case Keys.PageDown:
                    case Keys.Home:
                    case Keys.End:
                        return true;

                        // else fall through to base
                }
            }
            return base.IsInputKey(keyData);
        }

        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.OnHandleCreated"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    Overridden to update the newly created handle with the settings of the
        ///    MaxLength and PasswordChar properties.
        /// </devdoc>
        protected override void OnHandleCreated(EventArgs e) {
            base.OnHandleCreated(e);
            AdjustHeight();
            
            UpdateMaxLength();
            if (textBoxFlags[modified])
                SendMessage(NativeMethods.EM_SETMODIFY, 1, 0);
        }

        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.OnHandleDestroyed"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        protected override void OnHandleDestroyed(EventArgs e) {
            textBoxFlags[modified] = Modified;
            selectionStart = SelectionStart;
            selectionLength = SelectionLength;
            base.OnHandleDestroyed(e);
        }

        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.Paste"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Replaces the current selection in the text box with the contents of the Clipboard.
        ///    </para>
        /// </devdoc>
        public void Paste() {
            Debug.WriteLineIf(IntSecurity.SecurityDemand.TraceVerbose, "ClipboardRead Demanded");
            IntSecurity.ClipboardRead.Demand();

            SendMessage(NativeMethods.WM_PASTE, 0, 0);
        }

        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.ProcessDialogKey"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override bool ProcessDialogKey(Keys keyData) {
            Debug.WriteLineIf(ControlKeyboardRouting.TraceVerbose, "TextBoxBase.ProcessDialogKey [" + keyData.ToString() + "]");
            if ((keyData & Keys.Alt) == 0 && (keyData & Keys.Control) != 0) {
                Keys keyCode = (Keys)keyData & Keys.KeyCode;
                switch (keyCode) {
                    case Keys.Tab:
                        if (ProcessTabKey((keyData & Keys.Shift) == Keys.None))
                            return true;
                        break;
                }
            }
            return base.ProcessDialogKey(keyData);
        }

        // Actually processes ctrl-tab.  The usual implementation -- go to the next control in the tab order.
        private bool ProcessTabKey(bool forward) {
            if (Parent.SelectNextControl(this, forward, true, true, true))
                return true;
            return false;
        }

        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.OnPaint"]/*' />
        /// <devdoc>
        ///     TextBox / RichTextBox Onpaint.
        /// </devdoc>
        /// <internalonly/><hideinheritance/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event PaintEventHandler Paint {
            add {
                base.Paint += value;
            }
            remove {
                base.Paint -= value;
            }
        }
        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.OnAutoSizeChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OnAutoSizeChanged(EventArgs e) {
            EventHandler eh = Events[EVENT_AUTOSIZECHANGED] as EventHandler;
            if (eh != null) {
                 eh(this, e);
            }
        }
        
        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.OnAcceptsTabChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OnAcceptsTabChanged(EventArgs e) {
            EventHandler eh = Events[EVENT_ACCEPTSTABCHANGED] as EventHandler;
            if (eh != null) {
                 eh(this, e);
            }
        }

        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.OnBorderStyleChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OnBorderStyleChanged(EventArgs e) {
            EventHandler eh = Events[EVENT_BORDERSTYLECHANGED] as EventHandler;
            if (eh != null) {
                 eh(this, e);
            }
        }

        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.OnFontChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override void OnFontChanged(EventArgs e) {
            base.OnFontChanged(e);
            AdjustHeight();
        }

        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.OnHideSelectionChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OnHideSelectionChanged(EventArgs e) {
            EventHandler eh = Events[EVENT_HIDESELECTIONCHANGED] as EventHandler;
            if (eh != null) {
                 eh(this, e);
            }
        }

        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.OnModifiedChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OnModifiedChanged(EventArgs e) {
            EventHandler eh = Events[EVENT_MODIFIEDCHANGED] as EventHandler;
            if (eh != null) {
                 eh(this, e);
            }
        }

        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.OnMultilineChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OnMultilineChanged(EventArgs e) {
            EventHandler eh = Events[EVENT_MULTILINECHANGED] as EventHandler;
            if (eh != null) {
                 eh(this, e);
            }
        }

        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.OnReadOnlyChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OnReadOnlyChanged(EventArgs e) {
            EventHandler eh = Events[EVENT_READONLYCHANGED] as EventHandler;
            if (eh != null) {
                 eh(this, e);
            }
        }
        
        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.ScrollToCaret"]/*' />
        /// <devdoc>
        ///     Ensures that the caret is visible in the TextBox window, by scrolling the
        ///     TextBox control surface if necessary.
        /// </devdoc>
        public void ScrollToCaret() {
            SendMessage(NativeMethods.EM_SCROLLCARET, 0, 0);
        }

        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.Select"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Selects a range of text in the text box.
        ///    </para>
        /// </devdoc>
        public void Select(int start, int length) {
            if (start < 0)
                throw new ArgumentException(SR.GetString(SR.InvalidArgument, "start", start.ToString()));
            if (length < 0)
                throw new ArgumentException(SR.GetString(SR.InvalidArgument, "length", length.ToString()));

            int textLen = TextLength;

            if (start > textLen) {
                start = textLen;
                length = 0;
            }
            
            SelectInternal(start, length);
        }

        /// <devdoc>
        ///     Performs the actual select without doing arg checking.
        /// </devdoc>        
        internal virtual void SelectInternal(int start, int length) {
            int end = start + length;

            //if our handle is created - send message...
            if (IsHandleCreated) {

                //This method is overridden for TEXTBOXES !!
                //this code Runs for RichEdit .. 
                SendMessage(NativeMethods.EM_SETSEL, start, end);
                // CONSIDER: Both TextBox and RichTextBox will scroll to insure the caret is visible,
                // but they differ in whether they tried to make the rest of the selection visible.
            }
            else {
                //otherwise, wait until handle is created to send this message.
                //Store the indices until then...
                selectionStart = start;
                selectionLength = length;
            }
        }

        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.SelectAll"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Selects all text in the text box.
        ///    </para>
        /// </devdoc>
        public void SelectAll() {
            SelectInternal(0, TextLength);
        }

        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.SetBoundsCore"]/*' />
        /// <devdoc>
        ///    Overrides Control.setBoundsCore to enforce autoSize.
        /// </devdoc>
        /// <internalonly/>
        protected override void SetBoundsCore(int x, int y, int width, int height, BoundsSpecified specified) {
            
            if (!integralHeightAdjust && height != Height)
                requestedHeight = height;
            
            // For performance, someone once added a "&& Parent != null" 
            // clause to this if statement.  Well, you can't do that, because then autosizing won't kick in
            // unless you set Size or Location _after_ the control is added to its parent.
            if (textBoxFlags[autoSize] && !textBoxFlags[multiline] /* && Parent != null */)
                height = PreferredHeight;
            
            base.SetBoundsCore(x, y, width, height, specified);
        }

        // Called by CreateHandle or OnHandleCreated
        internal void SetSelectionOnHandle() {
            Debug.Assert(IsHandleCreated, "Don't call this method until the handle is created.");
            if (selectionStart > -1) {
                if (Marshal.SystemDefaultCharSize == 1) {
                    int start = selectionStart;
                    int end = selectionStart + selectionLength;
                    //this Code Runs only for TextBox...
                    ToDbcsOffsets(Text, ref start, ref end);
                    SendMessage(NativeMethods.EM_SETSEL, start, end);
                }
                else {
                    SendMessage(NativeMethods.EM_SETSEL, selectionStart, selectionStart + selectionLength);
                }

                selectionStart = -1;
                selectionLength   = -1;
            }
        }

        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.SetWordWrapInternal"]/*' />
        /// <devdoc>
        ///     RichTextBox overwrites this.
        /// </devdoc>
        internal virtual void SetWordWrapInternal(bool value) {
            if (textBoxFlags[wordWrap] != value) {
                textBoxFlags[wordWrap] = value;
                RecreateHandle();
            }
        }

        internal static void ToDbcsOffsets(string str, ref int start, ref int end) {
            Encoding e = Encoding.Default;
            int newStart = start;
            
            // Make sure start and end are within the string
            //
            if (start < 0) {
                start = 0;
            }
            if (start > str.Length) {
                start = str.Length;
            }
            if (end < start) {
                end = start;
            }
            if (end > str.Length) {
                end = str.Length;
            }
            
            // IMPORTANT: Avoid off-by-1 errors! 
            // The end value passed in is the character immediately after the last character selected.
            
            if (start != 0) {
                newStart = e.GetByteCount(str.Substring(0, start));
            }
            end = newStart + e.GetByteCount(str.Substring(start, end - start));
            start = newStart;
        }

        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.ToString"]/*' />
        /// <devdoc>
        ///    Provides some interesting information for the TextBox control in
        ///    String form.
        /// </devdoc>
        /// <internalonly/>
        public override string ToString() {

            string s = base.ToString();

            string txt = Text;
            if (txt.Length > 40) txt = txt.Substring(0, 40) + "...";
            return s + ", Text: " + txt.ToString();
        }

        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.Undo"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Undoes the last edit operation in the text box.
        ///    </para>
        /// </devdoc>
        public void Undo() {
            SendMessage(NativeMethods.EM_UNDO, 0, 0);
        }

        internal virtual void UpdateMaxLength() {
            if (IsHandleCreated) {
                SendMessage(NativeMethods.EM_LIMITTEXT, maxLength, 0);
            }
        }

        internal override IntPtr InitializeDCForWmCtlColor(IntPtr dc, int msg) {

            if ((msg == NativeMethods.WM_CTLCOLORSTATIC) && !ShouldSerializeBackColor()) {
                // Let the Win32 Edit control handle background colors itself.
                // This is necessary because a disabled edit control will display a different
                // BackColor than when enabled.
                return IntPtr.Zero;
            }
            else {
                return base.InitializeDCForWmCtlColor(dc, msg);
            }
        }

        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.WmReflectCommand"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        private void WmReflectCommand(ref Message m) {
            if (!textBoxFlags[codeUpdateText] && (int)m.WParam >> 16 == NativeMethods.EN_CHANGE && !textBoxFlags[creatingHandle] && CanRaiseTextChangedEvent) {
                OnTextChanged(EventArgs.Empty);
            }
        }

        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.WmSetFont"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        void WmSetFont(ref Message m) {
            base.WndProc(ref m);
            if (!textBoxFlags[multiline]) {
                SendMessage(NativeMethods.EM_SETMARGINS, NativeMethods.EC_LEFTMARGIN | NativeMethods.EC_RIGHTMARGIN, 0);
            }
        }

        void WmGetDlgCode(ref Message m) {
            base.WndProc(ref m);
            if (AcceptsTab) {
                Debug.WriteLineIf(Control.ControlKeyboardRouting.TraceVerbose, "TextBox wants tabs");
                m.Result = (IntPtr)((int)m.Result | NativeMethods.DLGC_WANTTAB);
            }
            else {
                Debug.WriteLineIf(Control.ControlKeyboardRouting.TraceVerbose, "TextBox doesn't want tabs");
                m.Result = (IntPtr)((int)m.Result & ~(NativeMethods.DLGC_WANTTAB | NativeMethods.DLGC_WANTALLKEYS));
            }
        }

        /// <include file='doc\TextBoxBase.uex' path='docs/doc[@for="TextBoxBase.WndProc"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    The edits window procedure.  Inheritng classes can override this
        ///    to add extra functionality, but should not forget to call
        ///    base.wndProc(m); to ensure the combo continues to function properly.
        /// </devdoc>
        [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        protected override void WndProc(ref Message m) {
            switch (m.Msg) {
                case NativeMethods.WM_REFLECT + NativeMethods.WM_COMMAND:
                    WmReflectCommand(ref m);
                    break;
                case NativeMethods.WM_GETDLGCODE:
                    WmGetDlgCode(ref m);
                    break;
                case NativeMethods.WM_SETFONT:
                    WmSetFont(ref m);
                    break;
                default:
                    base.WndProc(ref m);
                    break;
            }
        }        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\threadexceptiondialog.cs ===
//------------------------------------------------------------------------------
// <copyright file="ThreadExceptionDialog.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {
    using System.Threading;
    using System.Runtime.Remoting;
    using System.Diagnostics;
    using System;
    using System.Text;
    using System.ComponentModel;
    using System.Drawing;
    using System.Windows.Forms;
    using System.Reflection;
    using System.Security;
    using System.Security.Permissions;

    /// <include file='doc\ThreadExceptionDialog.uex' path='docs/doc[@for="ThreadExceptionDialog"]/*' />
    /// <internalonly/>
    /// <devdoc>
    ///    <para>
    ///       Implements a dialog box that is displayed when an unhandled exception occurs in
    ///       a thread.
    ///    </para>
    /// </devdoc>
    [
        SecurityPermission(SecurityAction.InheritanceDemand, Flags=SecurityPermissionFlag.UnmanagedCode),
        SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode),
        UIPermission(SecurityAction.Assert, Window=UIPermissionWindow.AllWindows)]
    public class ThreadExceptionDialog : Form {
        private const int MAXWIDTH = 440;
        private const int MAXHEIGHT = 325;

        // private const int IDI_ERROR = 32513;

        private PictureBox pictureBox = new PictureBox();
        private Label message = new Label();
        private Button continueButton = new Button();
        private Button quitButton = new Button();
        private Button detailsButton = new Button();
        private Button helpButton = new Button();
        private TextBox details = new TextBox();
        private Bitmap expandImage = null;
        private Bitmap collapseImage = null;
        private bool detailsVisible = false;

        /// <include file='doc\ThreadExceptionDialog.uex' path='docs/doc[@for="ThreadExceptionDialog.ThreadExceptionDialog"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Windows.Forms.ThreadExceptionDialog'/> class.
        ///       
        ///    </para>
        /// </devdoc>
        public ThreadExceptionDialog(Exception t) {

            string messageRes;
            string messageText;
            Button[] buttons;
            bool detailAnchor = false;

            if (t is WarningException) {
                WarningException w = (WarningException)t;
                messageRes = SR.ExDlgWarningText;
                messageText = w.Message;
                if (w.HelpUrl == null) {
                    buttons = new Button[] {continueButton};
                }
                else {
                    buttons = new Button[] {continueButton, helpButton};
                }
            }
            else {
                messageText = t.Message;

                detailAnchor = true;
                
                if (Application.AllowQuit) {
                    if (t is SecurityException) {
                        messageRes = "ExDlgSecurityErrorText";
                    }
                    else {
                        messageRes = "ExDlgErrorText";
                    }
                    buttons = new Button[] {detailsButton, continueButton, quitButton};
                }
                else {
                    if (t is SecurityException) {
                        messageRes = "ExDlgSecurityContinueErrorText";
                    }
                    else {
                        messageRes = "ExDlgContinueErrorText";
                    }
                    buttons = new Button[] {detailsButton, continueButton};
                }
            }

            if (messageText.Length == 0) {
                messageText = t.GetType().Name;
            }
            if (t is SecurityException) {
                messageText = SR.GetString(messageRes, t.GetType().Name, Trim(messageText));
            }
            else {
                messageText = SR.GetString(messageRes, Trim(messageText));
            }

            StringBuilder detailsTextBuilder = new StringBuilder();
            string newline = "\r\n";
            string separator = SR.GetString(SR.ExDlgMsgSeperator);
            string sectionseparator = SR.GetString(SR.ExDlgMsgSectionSeperator);
            if (Application.CustomThreadExceptionHandlerAttached) {
                detailsTextBuilder.Append(SR.GetString(SR.ExDlgMsgHeaderNonSwitchable));
            }
            else {
                detailsTextBuilder.Append(SR.GetString(SR.ExDlgMsgHeaderSwitchable));
            }
            detailsTextBuilder.Append(string.Format(sectionseparator, SR.GetString(SR.ExDlgMsgExceptionSection)));
            detailsTextBuilder.Append(t.ToString());
            detailsTextBuilder.Append(newline);
            detailsTextBuilder.Append(newline);
            detailsTextBuilder.Append(string.Format(sectionseparator, SR.GetString(SR.ExDlgMsgLoadedAssembliesSection)));
            new FileIOPermission(PermissionState.Unrestricted).Assert();
            try {
                foreach (Assembly asm in AppDomain.CurrentDomain.GetAssemblies()) {
                    AssemblyName name = asm.GetName();
                    string fileVer = SR.GetString(SR.NotAvailable);

                    try {
                        
                        // bug 113573 -- if there's a path with an escaped value in it 
                        // like c:\temp\foo%2fbar, the AssemblyName call will unescape it to
                        // c:\temp\foo\bar, which is wrong, and this will fail.   It doesn't look like the 
                        // assembly name class handles this properly -- even the "CodeBase" property is un-escaped
                        // so we can't circumvent this.
                        //
                        if (name.EscapedCodeBase != null && name.EscapedCodeBase.Length > 0) {
                            Uri codeBase = new Uri(name.EscapedCodeBase);
                            if (codeBase.Scheme == "file") {
                                fileVer = FileVersionInfo.GetVersionInfo(NativeMethods.GetLocalPath(name.EscapedCodeBase)).FileVersion;
                            }
                        }
                    }
                    catch(System.IO.FileNotFoundException){
                    }
                    detailsTextBuilder.Append(SR.GetString(SR.ExDlgMsgLoadedAssembliesEntry, name.Name, name.Version, fileVer, name.EscapedCodeBase));
                    detailsTextBuilder.Append(separator);
                }
            }
            finally {
                CodeAccessPermission.RevertAssert();
            }
            
            detailsTextBuilder.Append(string.Format(sectionseparator, SR.GetString(SR.ExDlgMsgJITDebuggingSection)));
            if (Application.CustomThreadExceptionHandlerAttached) {
                detailsTextBuilder.Append(SR.GetString(SR.ExDlgMsgFooterNonSwitchable));
            }
            else {
                detailsTextBuilder.Append(SR.GetString(SR.ExDlgMsgFooterSwitchable));
            }

            detailsTextBuilder.Append(newline);
            detailsTextBuilder.Append(newline);

            string detailsText = detailsTextBuilder.ToString();

            Graphics g = message.CreateGraphicsInternal();
            
            Size textSize = Size.Ceiling(g.MeasureString(messageText, Font, MAXWIDTH - 80));
            g.Dispose();

            if (textSize.Width < 180) textSize.Width = 180;
            if (textSize.Height > MAXHEIGHT) textSize.Height = MAXHEIGHT;

            int width = textSize.Width + 80;
            int buttonTop = Math.Max(textSize.Height, 40) + 26;

            // SECREVIEW : We must get a hold of the parent to get at it's text
            //           : to make this dialog look like the parent.
            //
            IntSecurity.GetParent.Assert();
            try {
                Form activeForm = Form.ActiveForm;
                if (activeForm == null || activeForm.Text.Length == 0) {
                    Text = SR.GetString(SR.ExDlgCaption);
                }
                else {
                    Text = SR.GetString(SR.ExDlgCaption2, activeForm.Text);
                }
            }
            finally {
                CodeAccessPermission.RevertAssert();
            }
            AcceptButton = continueButton;
            CancelButton = continueButton;
            FormBorderStyle = FormBorderStyle.FixedDialog;
            MaximizeBox = false;
            MinimizeBox = false;
            StartPosition = FormStartPosition.CenterScreen;
            Icon = null;
            ClientSize = new Size(width, buttonTop + 31);
            TopMost = true;

            pictureBox.Location = new Point(0, 0);
            pictureBox.Size = new Size(64, 64);
            pictureBox.SizeMode = PictureBoxSizeMode.CenterImage;
            if (t is SecurityException) {
                pictureBox.Image = SystemIcons.Information.ToBitmap();
            }
            else {
                pictureBox.Image = SystemIcons.Error.ToBitmap();
            }
            Controls.Add(pictureBox);
            message.SetBounds(64, 
                              8 + (40 - Math.Min(textSize.Height, 40)) / 2,
                              textSize.Width, textSize.Height);
            message.Text = messageText;
            Controls.Add(message);

            continueButton.Text = SR.GetString(SR.ExDlgContinue);
            continueButton.FlatStyle = FlatStyle.Standard;
            continueButton.DialogResult = DialogResult.Cancel;

            quitButton.Text = SR.GetString(SR.ExDlgQuit);
            quitButton.FlatStyle = FlatStyle.Standard;
            quitButton.DialogResult = DialogResult.Abort;

            helpButton.Text = SR.GetString(SR.ExDlgHelp);
            helpButton.FlatStyle = FlatStyle.Standard;
            helpButton.DialogResult = DialogResult.Yes;

            detailsButton.Text = SR.GetString(SR.ExDlgShowDetails);
            detailsButton.FlatStyle = FlatStyle.Standard;
            detailsButton.Click += new EventHandler(DetailsClick);

            Button b = null;
            int startIndex = 0;
            
            if (detailAnchor) {
                b = detailsButton;

                expandImage = new Bitmap(this.GetType(), "down.bmp");
                expandImage.MakeTransparent();
                collapseImage = new Bitmap(this.GetType(), "up.bmp");
                collapseImage.MakeTransparent();

                b.SetBounds( 8, buttonTop, 100, 23 );
                b.Image = expandImage;
                b.ImageAlign = ContentAlignment.MiddleLeft;
                Controls.Add(b);
                startIndex = 1;
            }
            
            int buttonLeft = (width - 8 - ((buttons.Length - startIndex) * 105 - 5));
            
            for (int i = startIndex; i < buttons.Length; i++) {
                b = buttons[i];
                b.SetBounds(buttonLeft, buttonTop, 100, 23);
                Controls.Add(b);
                buttonLeft += 105;
            }

            details.Text = detailsText;
            details.ScrollBars = ScrollBars.Both;
            details.Multiline = true;
            details.ReadOnly = true;
            details.WordWrap = false;
            details.TabStop = false;
            details.AcceptsReturn = false;
            
            details.SetBounds(8, buttonTop + 31, width - 16,154);
            Controls.Add(details);
        }

        /// <include file='doc\ThreadExceptionDialog.uex' path='docs/doc[@for="ThreadExceptionDialog.DetailsClick"]/*' />
        /// <devdoc>
        ///     Called when the details button is clicked.
        /// </devdoc>
        private void DetailsClick(object sender, EventArgs eventargs) {
            int delta = details.Height + 8;
            if (detailsVisible) delta = -delta;
            Height = Height + delta;
            detailsVisible = !detailsVisible;
            detailsButton.Image = detailsVisible ? collapseImage : expandImage;
        }

        private static string Trim(string s) {
            if (s == null) return s;
            int i = s.Length;
            while (i > 0 && s[i - 1] == '.') i--;
            return s.Substring(0, i);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\toolbarbutton.cs ===
//------------------------------------------------------------------------------
// <copyright file="ToolBarButton.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.InteropServices;
    using System.Runtime.Remoting;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System;
    using System.Drawing;
    using System.Text;
    using System.Drawing.Design;
    using Marshal = System.Runtime.InteropServices.Marshal;
    using System.Windows.Forms;    
    using Microsoft.Win32;


    /// <include file='doc\ToolBarButton.uex' path='docs/doc[@for="ToolBarButton"]/*' />
    /// <devdoc>
    ///    <para> 
    ///       Represents a Windows toolbar button.</para>
    /// </devdoc>
    [
    Designer("System.Windows.Forms.Design.ToolBarButtonDesigner, " + AssemblyRef.SystemDesign),
    DefaultProperty("Text"),
    ToolboxItem(false),
    DesignTimeVisible(false),
    ]
    public class ToolBarButton : Component {

        string text;
        string tooltipText;
        bool enabled = true;
        bool visible = true;
        bool pushed = false;
        bool partialPush = false;
        int imageIndex = -1;
        ToolBarButtonStyle style = ToolBarButtonStyle.PushButton;

        object userData;

        // These variables below are used by the ToolBar control to help
        // it manage some information about us.

        /// <include file='doc\ToolBarButton.uex' path='docs/doc[@for="ToolBarButton.stringIndex"]/*' />
        /// <devdoc>
        ///     If this button has a string, what it's index is in the ToolBar's
        ///     internal list of strings.  Needs to be package protected.
        /// </devdoc>
        /// <internalonly/>
        internal int stringIndex = -1;

        /// <include file='doc\ToolBarButton.uex' path='docs/doc[@for="ToolBarButton.parent"]/*' />
        /// <devdoc>
        ///     Our parent ToolBar control.
        /// </devdoc>
        /// <internalonly/>
        internal ToolBar parent;

        /// <include file='doc\ToolBarButton.uex' path='docs/doc[@for="ToolBarButton.dropDownMenu"]/*' />
        /// <devdoc>
        ///     For DropDown buttons, we can optionally show a
        ///     context menu when the button is dropped down.
        /// </devdoc>
        internal Menu dropDownMenu = null;

        /// <include file='doc\ToolBarButton.uex' path='docs/doc[@for="ToolBarButton.ToolBarButton"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Windows.Forms.ToolBarButton'/> class.</para>
        /// </devdoc>
        public ToolBarButton() {

        }
        
        /// <include file='doc\ToolBarButton.uex' path='docs/doc[@for="ToolBarButton.ToolBarButton1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ToolBarButton(string text) : base() {
            this.Text = text;
        }

        /// <include file='doc\ToolBarButton.uex' path='docs/doc[@for="ToolBarButton.DropDownMenu"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Indicates the menu to be displayed in
        ///       the drop-down toolbar button.</para>
        /// </devdoc>
        [
        DefaultValue(null),
        TypeConverterAttribute(typeof(ReferenceConverter)),
        SRDescription(SR.ToolBarButtonMenuDescr)
        ]
        public Menu DropDownMenu {
            get {
                return dropDownMenu;
            }

            set {
                //The dropdownmenu must be of type ContextMenu, Main & Items are invalid.
                //
                if (value != null && !(value is ContextMenu)) {
                    throw new ArgumentException(SR.GetString(SR.ToolBarButtonInvalidDropDownMenuType));
                }
                dropDownMenu = value;
            }
        }

        /// <include file='doc\ToolBarButton.uex' path='docs/doc[@for="ToolBarButton.Enabled"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether the button is enabled or not.</para>
        /// </devdoc>
        [
        DefaultValue(true),
        Localizable(true),
        SRDescription(SR.ToolBarButtonEnabledDescr)
        ]
        public bool Enabled {
            get {
                return enabled;
            }

            set {
                if (enabled != value) {

                    enabled = value;

                    if (parent != null && parent.IsHandleCreated) {
                        parent.SendMessage(NativeMethods.TB_ENABLEBUTTON, FindButtonIndex(),
                            enabled ? 1 : 0);
                    }
                }
            }
        }

        /// <include file='doc\ToolBarButton.uex' path='docs/doc[@for="ToolBarButton.ImageIndex"]/*' />
        /// <devdoc>
        ///    <para> Indicates the index
        ///       value of the image assigned to the button.</para>
        /// </devdoc>
        [
        TypeConverterAttribute(typeof(ImageIndexConverter)),
        Editor("System.Windows.Forms.Design.ImageIndexEditor, " + AssemblyRef.SystemDesign, typeof(UITypeEditor)),
        DefaultValue(-1),
        Localizable(true),
        SRDescription(SR.ToolBarButtonImageIndexDescr)
        ]
        public int ImageIndex {
            get {
                return imageIndex;
            }
            set {
                if (imageIndex != value) {
                    if (value < -1)
                        throw new ArgumentException(SR.GetString(SR.InvalidLowBoundArgumentEx,
                                                                  "value",
                                                                  (value).ToString(),
                                                                  -1));

                    imageIndex = value;
                    UpdateButton(false);
                }
            }
        }

        /// <include file='doc\ToolBarButton.uex' path='docs/doc[@for="ToolBarButton.Parent"]/*' />
        /// <devdoc>
        ///    <para>Indicates the toolbar control that the toolbar button is assigned to. This property is 
        ///       read-only.</para>
        /// </devdoc>
        [
            Browsable(false),
        ]
        public ToolBar Parent {
            get {
                return parent;
            }
        }

        /// <include file='doc\ToolBarButton.uex' path='docs/doc[@for="ToolBarButton.PartialPush"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Indicates whether a toggle-style toolbar button
        ///       is partially pushed.</para>
        /// </devdoc>
        [
        DefaultValue(false),
        SRDescription(SR.ToolBarButtonPartialPushDescr)
        ]
        public bool PartialPush {
            get {
                if (parent == null || !parent.IsHandleCreated)
                    return partialPush;
                else {
                    if ((int)parent.SendMessage(NativeMethods.TB_ISBUTTONINDETERMINATE, FindButtonIndex(), 0) != 0)
                        partialPush = true;
                    else
                        partialPush = false;

                    return partialPush;
                }
            }
            set {
                if (partialPush != value) {
                    partialPush = value;
                    UpdateButton(false);
                }
            }
        }

        /// <include file='doc\ToolBarButton.uex' path='docs/doc[@for="ToolBarButton.Pushed"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether a toggle-style toolbar button is currently in the pushed state.</para>
        /// </devdoc>
        [
        DefaultValue(false),
        SRDescription(SR.ToolBarButtonPushedDescr)
        ]
        public bool Pushed {
            get {
                if (parent == null || !parent.IsHandleCreated)
                    return pushed;
                else {
                    return GetPushedState();
                }
            }
            set {
                if (value != Pushed) { // Getting property Pushed updates pushed member variable
                    pushed = value;
                    UpdateButton(false, false, false);
                }
            }
        }

        /// <include file='doc\ToolBarButton.uex' path='docs/doc[@for="ToolBarButton.Rectangle"]/*' />
        /// <devdoc>
        ///    <para>Indicates the bounding rectangle for a toolbar button. This property is 
        ///       read-only.</para>
        /// </devdoc>
        public Rectangle Rectangle {
            get {
                if (parent != null) {
                    NativeMethods.RECT rc = new NativeMethods.RECT();
                    UnsafeNativeMethods.SendMessage(new HandleRef(parent, parent.Handle), NativeMethods.TB_GETRECT, FindButtonIndex(), ref rc);
                    return Rectangle.FromLTRB(rc.left, rc.top, rc.right, rc.bottom);
                }
                return Rectangle.Empty;
            }
        }

        /// <include file='doc\ToolBarButton.uex' path='docs/doc[@for="ToolBarButton.Style"]/*' />
        /// <devdoc>
        ///    <para> Indicates the style of the
        ///       toolbar button.</para>
        /// </devdoc>
        [
        DefaultValue(ToolBarButtonStyle.PushButton),
        SRDescription(SR.ToolBarButtonStyleDescr),
        RefreshProperties(RefreshProperties.Repaint)
        ]
        public ToolBarButtonStyle Style {
            get {
                return style;
            }
            set {
                if (!Enum.IsDefined(typeof(ToolBarButtonStyle), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(ToolBarButtonStyle));
                }
                if (style == value) return;
                style = value;
                UpdateButton(true);
            }
        }

        /// <include file='doc\ToolBarButton.uex' path='docs/doc[@for="ToolBarButton.Tag"]/*' />
        [
        SRCategory(SR.CatData),
        Localizable(false),
        Bindable(true),
        SRDescription(SR.ControlTagDescr),
        DefaultValue(null),
        TypeConverter(typeof(StringConverter)),
        ]
        public object Tag {
            get {
                return userData;
            }
            set {
                userData = value;
            }
        }

        /// <include file='doc\ToolBarButton.uex' path='docs/doc[@for="ToolBarButton.Text"]/*' />
        /// <devdoc>
        ///    <para> Indicates the text that is displayed on the toolbar button.</para>
        /// </devdoc>
        [
        Localizable(true),
        DefaultValue(""),
        SRDescription(SR.ToolBarButtonTextDescr)
        ]
        public string Text {
            get {
                return(text == null) ? "" : text;
            }
            set {
                if (value == "") {
                    value = null;
                }
                
                if ( (value == null && text != null) ||
                     (value != null && (text == null || !text.Equals(value)))) {
                    text = value;
                    UpdateButton(false, true, true);
                }
            }
        }

        /// <include file='doc\ToolBarButton.uex' path='docs/doc[@for="ToolBarButton.ToolTipText"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Indicates
        ///       the text that appears as a tool tip for a control.</para>
        /// </devdoc>
        [
        Localizable(true),
        DefaultValue(""),
        SRDescription(SR.ToolBarButtonToolTipTextDescr)
        ]
        public string ToolTipText {
            get {
                return tooltipText == null ? "" : tooltipText;
            }
            set {
                tooltipText = value;
            }
        }

        /// <include file='doc\ToolBarButton.uex' path='docs/doc[@for="ToolBarButton.Visible"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Indicates whether the toolbar button
        ///       is visible.</para>
        /// </devdoc>
        [
        DefaultValue(true),
        Localizable(true),
        SRDescription(SR.ToolBarButtonVisibleDescr)
        ]
        public bool Visible {
            get {
                return visible;
            }
            set {
                if (visible != value) {
                    visible = value;
                    UpdateButton(false);
                }
            }
        }

        /// <include file='doc\ToolBarButton.uex' path='docs/doc[@for="ToolBarButton.Width"]/*' />
        /// <devdoc>
        ///     This is somewhat nasty -- by default, the windows ToolBar isn't very
        ///     clever about setting the width of buttons, and has a very primitive
        ///     algorithm that doesn't include for things like drop down arrows, etc.
        ///     We need to do a bunch of work here to get all the widths correct. Ugh.
        /// </devdoc>
        /// <internalonly/>
        internal short Width {
            get {
                Debug.Assert(parent != null, "Parent should be non-null when button width is requested");
                
                int width = 0;
                ToolBarButtonStyle style = Style;

                Size edge = SystemInformation.Border3DSize;
                if (style != ToolBarButtonStyle.Separator) {

                    // CONSIDER: this will force handle creation.  Is there any way to delay this calculation?
                    Graphics g = this.parent.CreateGraphicsInternal();

                    Size buttonSize = this.parent.buttonSize;                                                      
                    if (!(buttonSize.IsEmpty)) {
                        width = buttonSize.Width;
                    }
                    else {
                        if (this.parent.ImageList != null || Text != "") {
                            Size imageSize = this.parent.ImageSize;
                            Size textSize = Size.Ceiling(g.MeasureString(Text, parent.Font));
                            if (this.parent.TextAlign == ToolBarTextAlign.Right) {
                                if (textSize.Width == 0)
                                    width = imageSize.Width + edge.Width * 4;
                                else
                                    width = imageSize.Width + textSize.Width + edge.Width * 6;
                            }
                            else {
                                if (imageSize.Width > textSize.Width)
                                    width = imageSize.Width + edge.Width * 4;
                                else
                                    width = textSize.Width + edge.Width * 4;
                            }
                            if (style == ToolBarButtonStyle.DropDownButton && this.parent.DropDownArrows) {
                                width += ToolBar.DDARROW_WIDTH;
                            }
                        }
                        else
                            width = this.parent.ButtonSize.Width;                                                      
                    }
                    g.Dispose();
                }
                else {
                    width = edge.Width * 2;
                }

                return(short)width;
            }

        }

        /// <include file='doc\ToolBarButton.uex' path='docs/doc[@for="ToolBarButton.Dispose"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        protected override void Dispose(bool disposing) {
            if (disposing) {
                if (parent != null) {
                    int index = FindButtonIndex();
                    if (index != -1) {
                        parent.Buttons.RemoveAt(index);
                    }
                }
            }
            base.Dispose(disposing);
        }

        /// <include file='doc\ToolBarButton.uex' path='docs/doc[@for="ToolBarButton.FindButtonIndex"]/*' />
        /// <devdoc>
        ///     Finds out index in the parent.
        /// </devdoc>
        /// <internalonly/>
        private int FindButtonIndex() {
            for (int x = 0; x < parent.Buttons.Count; x++) {
                if (parent.Buttons[x] == this) {
                    return x;
                }
            }
            return -1;
        }

        private bool GetPushedState()
        {
            if ((int)parent.SendMessage(NativeMethods.TB_ISBUTTONCHECKED, FindButtonIndex(), 0) != 0) {
                pushed = true;
            }
            else {
                pushed = false;
            }

            return pushed;
        }

        /// <include file='doc\ToolBarButton.uex' path='docs/doc[@for="ToolBarButton.GetTBBUTTON"]/*' />
        /// <devdoc>
        ///     Returns a TBBUTTON object that represents this ToolBarButton.
        /// </devdoc>
        internal NativeMethods.TBBUTTON GetTBBUTTON() {

            NativeMethods.TBBUTTON button = new NativeMethods.TBBUTTON();

            button.iBitmap = imageIndex;

            // set up the state of the button
            //
            button.fsState = 0;
            if (enabled) button.fsState |= NativeMethods.TBSTATE_ENABLED;
            if (partialPush && style == ToolBarButtonStyle.ToggleButton) button.fsState |= NativeMethods.TBSTATE_INDETERMINATE;
            if (pushed) button.fsState |= NativeMethods.TBSTATE_CHECKED;
            if (!visible) button.fsState |= NativeMethods.TBSTATE_HIDDEN;

            // set the button style
            //
            switch (style) {
                case ToolBarButtonStyle.PushButton:
                    button.fsStyle = NativeMethods.TBSTYLE_BUTTON;
                    break;
                case ToolBarButtonStyle.ToggleButton:
                    button.fsStyle = NativeMethods.TBSTYLE_CHECK;
                    break;
                case ToolBarButtonStyle.Separator:
                    button.fsStyle = NativeMethods.TBSTYLE_SEP;
                    break;
                case ToolBarButtonStyle.DropDownButton:
                    button.fsStyle = NativeMethods.TBSTYLE_DROPDOWN;
                    break;

            }

            button.dwData = 0;
            button.iString = this.stringIndex;

            return button;
        }

        /// <include file='doc\ToolBarButton.uex' path='docs/doc[@for="ToolBarButton.GetTBBUTTONINFO"]/*' />
        /// <devdoc>
        ///     Returns a TBBUTTONINFO object that represents this ToolBarButton.
        /// </devdoc>
        internal NativeMethods.TBBUTTONINFO GetTBBUTTONINFO(bool updateText) {

            NativeMethods.TBBUTTONINFO button = new NativeMethods.TBBUTTONINFO();
            button.cbSize = Marshal.SizeOf(typeof(NativeMethods.TBBUTTONINFO));
            button.dwMask = NativeMethods.TBIF_COMMAND | NativeMethods.TBIF_IMAGE
                            | NativeMethods.TBIF_STATE | NativeMethods.TBIF_STYLE;

            // Comctl on Win98 interprets null strings as empty strings, which forces
            // the button to leave space for text.  The only workaround is to avoid having comctl 
            // update the text.
            if (updateText) {
                button.dwMask |= NativeMethods.TBIF_TEXT;
            }

            button.iImage = imageIndex;

            // set up the state of the button
            //
            button.fsState = 0;
            if (enabled) button.fsState |= NativeMethods.TBSTATE_ENABLED;
            if (partialPush && style == ToolBarButtonStyle.ToggleButton) button.fsState |= NativeMethods.TBSTATE_INDETERMINATE;
            if (pushed) button.fsState |= NativeMethods.TBSTATE_CHECKED;
            if (!visible) button.fsState |= NativeMethods.TBSTATE_HIDDEN;

            // set the button style
            //
            switch (style) {
                case ToolBarButtonStyle.PushButton:
                    button.fsStyle = NativeMethods.TBSTYLE_BUTTON;
                    break;
                case ToolBarButtonStyle.ToggleButton:
                    button.fsStyle = NativeMethods.TBSTYLE_CHECK;
                    break;
                case ToolBarButtonStyle.Separator:
                    button.fsStyle = NativeMethods.TBSTYLE_SEP;
                    break;
            }


            if (text == null) {
                button.pszText = Marshal.StringToHGlobalAuto("\0\0");
            }
            else {
                string textValue = this.text;
                PrefixAmpersands(ref textValue);
                button.pszText = Marshal.StringToHGlobalAuto(textValue);
            }

            return button;
        }
        
        private void PrefixAmpersands(ref string value) {
            // Due to a comctl32 problem, ampersands underline the next letter in the 
            // text string, but the accelerators don't work.
            // So in this function, we prefix ampersands with another ampersand
            // so that they actually appear as ampersands.
            //
            
            // Sanity check parameter
            //
            if (value == null || value.Length == 0) {
                return;
            }
            
            // If there are no ampersands, we don't need to do anything here
            //
            if (value.IndexOf('&') < 0) {
                return;
            }
            
            // Insert extra ampersands
            //
            StringBuilder newString = new StringBuilder();
            for(int i=0; i < value.Length; ++i) {
                if (value[i] == '&') { 
                    if (i < value.Length - 1 && value[i+1] == '&') {
                        ++i;    // Skip the second ampersand
                    }
                    newString.Append("&&");
                }
                else {
                    newString.Append(value[i]);    
                }
            }
            
            value = newString.ToString();
        }

        /// <include file='doc\ToolBarButton.uex' path='docs/doc[@for="ToolBarButton.ToString"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        public override string ToString() {
            return "ToolBarButton: " + Text + ", Style: " + Style.ToString("G");
        }

        /// <include file='doc\ToolBarButton.uex' path='docs/doc[@for="ToolBarButton.UpdateButton"]/*' />
        /// <devdoc>
        ///     When a button property changes and the parent control is created,
        ///     we need to make sure it gets the new button information.
        ///     If Text was changed, call the next overload.
        /// </devdoc>
        internal void UpdateButton(bool recreate) {
            UpdateButton(recreate, false, true);        
        }

        /// <include file='doc\ToolBarButton.uex' path='docs/doc[@for="ToolBarButton.UpdateButton1"]/*' />
        /// <devdoc>
        ///     When a button property changes and the parent control is created,
        ///     we need to make sure it gets the new button information.
        /// </devdoc>
        private void UpdateButton(bool recreate, bool updateText, bool updatePushedState) {
            // It looks like ToolBarButtons with a DropDownButton tend to
            // lose the DropDownButton very easily - so we need to recreate
            // the button each time it changes just to be sure.
            //                                           
            if (style == ToolBarButtonStyle.DropDownButton && parent != null && parent.DropDownArrows) {
                recreate = true;
            }

            // we just need to get the Pushed state : this asks the Button its states and sets 
            // the private member "pushed" to right value..

            // this member is used in "InternalSetButton" which calls GetTBBUTTONINFO(bool updateText)
            // the GetButtonInfo method uses the "pushed" variable..

            //rather than setting it ourselves .... we asks the button to set it for us..
            if (updatePushedState && parent != null && parent.IsHandleCreated) {
                GetPushedState();
            }
            if (parent != null) {
                int index = FindButtonIndex();
                if (index != -1)
                    parent.InternalSetButton(index, this, recreate, updateText);
            }
        }    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\toolbarappearance.cs ===
//------------------------------------------------------------------------------
// <copyright file="ToolBarAppearance.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    using System.Drawing;
    using Microsoft.Win32;


    /// <include file='doc\ToolBarAppearance.uex' path='docs/doc[@for="ToolBarAppearance"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the type of toolbar to display.
    ///    </para>
    /// </devdoc>
    public enum ToolBarAppearance {

        /// <include file='doc\ToolBarAppearance.uex' path='docs/doc[@for="ToolBarAppearance.Normal"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The
        ///       toolbar and buttons appear as standard three dimensional controls.
        ///    </para>
        /// </devdoc>
        Normal      = 0,

        /// <include file='doc\ToolBarAppearance.uex' path='docs/doc[@for="ToolBarAppearance.Flat"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The toolbar and buttons appear flat, but the buttons change to three
        ///       dimensional as the mouse pointer moves over them.
        ///    </para>
        /// </devdoc>
        Flat        = 1,


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\timer.cs ===
//------------------------------------------------------------------------------
// <copyright file="Timer.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {
    using System.Threading;
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Windows.Forms.Design;
    using System;        

    /// <include file='doc\Timer.uex' path='docs/doc[@for="Timer"]/*' />
    /// <devdoc>
    ///    <para>Implements a Windows-based timer that raises an event at user-defined intervals. This timer is optimized for 
    ///       use in Win Forms
    ///       applications and must be used in a window.</para>
    /// </devdoc>
    [
    DefaultProperty("Interval"),
    DefaultEvent("Tick"),
    ToolboxItemFilter("System.Windows.Forms")
    ]
    public class Timer : Component {

        // CONSIDER: What's the point of using @hidden on private fields?

        /// <include file='doc\Timer.uex' path='docs/doc[@for="Timer.interval"]/*' />
        /// <devdoc>
        /// </devdoc>
        private int interval;

        /// <include file='doc\Timer.uex' path='docs/doc[@for="Timer.enabled"]/*' />
        /// <devdoc>
        /// </devdoc>
        private bool enabled;

        /// <include file='doc\Timer.uex' path='docs/doc[@for="Timer.onTimer"]/*' />
        /// <devdoc>
        /// </devdoc>
        private EventHandler onTimer;

        /// <include file='doc\Timer.uex' path='docs/doc[@for="Timer.timerProcRoot"]/*' />
        /// <devdoc>
        /// </devdoc>
        private GCHandle timerProcRoot;

        /// <include file='doc\Timer.uex' path='docs/doc[@for="Timer.timerID"]/*' />
        /// <devdoc>
        /// </devdoc>
        private int timerID;

        /// <include file='doc\Timer.uex' path='docs/doc[@for="Timer.inTimerEnable"]/*' />
        /// <devdoc>
	/// Set to true while we are pumping messages after after a KillTimer call
        /// </devdoc>
	private bool  inTimerEnable;

        /// <include file='doc\Timer.uex' path='docs/doc[@for="Timer.Timer"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Windows.Forms.Timer'/>
        /// class.</para>
        /// </devdoc>
        public Timer()
        : base() {
            interval = 100;
        }

        /// <include file='doc\Timer.uex' path='docs/doc[@for="Timer.Timer1"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Windows.Forms.Timer'/> class with the specified container.</para>
        /// </devdoc>
        public Timer(IContainer container) : this() {
            container.Add(this);
        }

        /// <include file='doc\Timer.uex' path='docs/doc[@for="Timer.Tick"]/*' />
        /// <devdoc>
        ///    <para>Occurs when the specified timer
        ///       interval has elapsed and the timer is enabled.</para>
        /// </devdoc>
        [SRCategory(SR.CatBehavior), SRDescription(SR.TimerTimerDescr)]
        public event EventHandler Tick {
            add {
                onTimer += value;
            }
            remove {
                onTimer -= value;
            }
        }

        // <devdoc>
        //     Timer callback.  This callback receives timer events from Win32.
        // </devdoc>
        private void Callback(IntPtr hWnd, int msg, IntPtr idEvent, IntPtr dwTime) {
            try {
                OnTick(EventArgs.Empty);
            }
            catch (Exception e) {
                Application.OnThreadException(e);
            }
        }

        // <devdoc>
        //     Timer callback when debugging.  This callback receives timer events from Win32.
        // </devdoc>
        private void DebuggableCallback(IntPtr hWnd, int msg, IntPtr idEvent, IntPtr dwTime) {
            // We have to have a try-catch here because the native timer
            // that calls this function seems to have a catch around it's
            // call to this function, and none of the exceptions bubble up
            // to the runtime exception handler. So, we call
            // Application.OnThreadException here explicitly.
            try {
                OnTick(EventArgs.Empty);
            }
            catch (Exception e) {
                Application.OnThreadException(e);
            }
        }

        /// <include file='doc\Timer.uex' path='docs/doc[@for="Timer.Dispose"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Disposes of the resources (other than memory) used by the timer.
        ///    </para>
        /// </devdoc>
        protected override void Dispose(bool disposing) {
            if (disposing) {
                Enabled = false;
            }
            base.Dispose(disposing);
        }

        /// <include file='doc\Timer.uex' path='docs/doc[@for="Timer.Enabled"]/*' />
        /// <devdoc>
        ///    <para> Indicates whether the timer is
        ///       running.</para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(false),
        SRDescription(SR.TimerEnabledDescr)
        ]
        public virtual bool Enabled {
            get {
                return enabled;
            }

            set {
                lock(this) {
			
	            if (inTimerEnable) {
                        return;
                    }                    

                    if (enabled != value) {
			enabled = value;
                    
                        // At runtime, enable or disable the corresponding Windows timer
                        //
                        if (!DesignMode) {
                            if (value) {
                                NativeMethods.TimerProc proc;
                                if (NativeWindow.WndProcShouldBeDebuggable) {
                                    proc = new NativeMethods.TimerProc(this.DebuggableCallback);
                                }
                                else {
                                    proc = new NativeMethods.TimerProc(this.Callback);
                                }
                                timerProcRoot = GCHandle.Alloc(proc);
                                timerID = (int) SafeNativeMethods.SetTimer(NativeMethods.NullHandleRef, 0, interval, proc);
                            }
                            else {
                                if (timerID != 0) {
                                    SafeNativeMethods.KillTimer(NativeMethods.NullHandleRef, timerID);

				    try {
                                        inTimerEnable = true;

                                        // qfe 508 -- make sure there aren't any timer messages left in the queue.
                                        // what can happen is that a WM_TIMER is in the queue, KillTimer is called,
                                        // and we free the root (below).  If GC pressure is high, the runtime
                                        // can then GC the proc before the message gets dispatched, which will
                                        // crash the process.  This will get 'em out of there.
                                        //
                                        NativeMethods.MSG msg = new NativeMethods.MSG();
                                        while (UnsafeNativeMethods.PeekMessage(ref msg, NativeMethods.NullHandleRef, NativeMethods.WM_TIMER, NativeMethods.WM_TIMER, NativeMethods.PM_REMOVE)) {
                                            // always call the ansi variant because it'll work on all platforms.   Since
                                            // we need to get all of these out of the queue, we remove and dispatch them as we come across them.
                                            // otherwise, it would be better to only pick out *our* WM_TIMER messages, but since they don't have
                                            // an hwnd on them (NULL means all hwnds), we can't do that filtering).
                                            //
                                            UnsafeNativeMethods.DispatchMessageA(ref msg);
                                        }
                                    }
                                    finally {
                                        inTimerEnable = false;
                                    }                                    
				    timerID = 0;
                                }
                                timerProcRoot.Free();
                            }
                        }
                    }
                }

            }
        }

        /// <include file='doc\Timer.uex' path='docs/doc[@for="Timer.Interval"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Indicates the time, in milliseconds, between timer ticks.</para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(100),
        SRDescription(SR.TimerIntervalDescr)
        ]
        public int Interval {
            get {
                return interval;
            }
            set {
                lock(this) {
                    if (value < 1)
                        throw new ArgumentException(SR.GetString(SR.TimerInvalidInterval, value, "0"));

                    if (interval != value) {
                        bool saveEnabled = enabled;
                        Enabled = false;
                        interval = value;
                        Enabled = saveEnabled;
                    }
                }
            }
        }

        /// <include file='doc\Timer.uex' path='docs/doc[@for="Timer.OnTick"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Windows.Forms.Timer.Tick'/>
        /// event.</para>
        /// </devdoc>
        protected virtual void OnTick(EventArgs e) {
            if (onTimer != null) onTimer.Invoke(this, e);
        }

        /// <include file='doc\Timer.uex' path='docs/doc[@for="Timer.Start"]/*' />
        /// <devdoc>
        ///    <para>Starts the
        ///       timer.</para>
        /// </devdoc>
        public void Start() {
            Enabled = true;
        }

        /// <include file='doc\Timer.uex' path='docs/doc[@for="Timer.Stop"]/*' />
        /// <devdoc>
        ///    <para>Stops the
        ///       timer.</para>
        /// </devdoc>
        public void Stop() {
            Enabled = false;
        }

        /// <include file='doc\Timer.uex' path='docs/doc[@for="Timer.ToString"]/*' />
        /// <devdoc>
        ///     returns us as a string.
        /// </devdoc>
        /// <internalonly/>
        public override string ToString() {
            string s = base.ToString();
            return s + ", Interval: " + Interval.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\tickstyle.cs ===
//------------------------------------------------------------------------------
// <copyright file="TickStyle.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    using System.Drawing;
    using Microsoft.Win32;


    /// <include file='doc\TickStyle.uex' path='docs/doc[@for="TickStyle"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the
    ///       location of tick marks in a <see cref='System.Windows.Forms.TrackBar'/>
    ///       control.
    ///    </para>
    /// </devdoc>
    public enum TickStyle {

        /// <include file='doc\TickStyle.uex' path='docs/doc[@for="TickStyle.None"]/*' />
        /// <devdoc>
        ///    <para>
        ///       No tick marks appear in the control.
        ///    </para>
        /// </devdoc>
        None = 0,

        /// <include file='doc\TickStyle.uex' path='docs/doc[@for="TickStyle.TopLeft"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Tick
        ///       marks are located on the top of horizontal control or on the left of a vertical control.
        ///    </para>
        /// </devdoc>
        TopLeft = 1,

        /// <include file='doc\TickStyle.uex' path='docs/doc[@for="TickStyle.BottomRight"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Tick marks are
        ///       located on the bottom of a horizontal control or on the right side of a vertical control.
        ///    </para>
        /// </devdoc>
        BottomRight = 2,

        /// <include file='doc\TickStyle.uex' path='docs/doc[@for="TickStyle.Both"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Tick
        ///       marks are located on both sides of the control.
        ///    </para>
        /// </devdoc>
        Both = 3,

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\toolbarbuttonclickevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="ToolBarButtonClickEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.Drawing;
    using System.ComponentModel;
    using Microsoft.Win32;

    /// <include file='doc\ToolBarButtonClickEvent.uex' path='docs/doc[@for="ToolBarButtonClickEventArgs"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides data for the <see cref='System.Windows.Forms.ToolBar.ButtonClick'/>
    ///       event.
    ///    </para>
    /// </devdoc>
    public class ToolBarButtonClickEventArgs : EventArgs {

        private ToolBarButton button;

        /// <include file='doc\ToolBarButtonClickEvent.uex' path='docs/doc[@for="ToolBarButtonClickEventArgs.ToolBarButtonClickEventArgs"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Windows.Forms.ToolBarButtonClickEventArgs'/>
        ///       class.
        ///    </para>
        /// </devdoc>
        public ToolBarButtonClickEventArgs(ToolBarButton button) {
            this.button = button;
        }

        /// <include file='doc\ToolBarButtonClickEvent.uex' path='docs/doc[@for="ToolBarButtonClickEventArgs.Button"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies the <see cref='System.Windows.Forms.ToolBarButton'/>
        ///       that was clicked.
        ///    </para>
        /// </devdoc>
        public ToolBarButton Button {
            get { return button;}
            set { button = value;}
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\trackbar.cs ===
//------------------------------------------------------------------------------
// <copyright file="TrackBar.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.InteropServices;
    using System.Runtime.Remoting;

    using System.Diagnostics;

    using System;
    using System.Security.Permissions;
    using Microsoft.Win32;
    using System.ComponentModel;
    using System.Drawing;
    using System.Windows.Forms;
    using System.ComponentModel.Design;

    /// <include file='doc\TrackBar.uex' path='docs/doc[@for="TrackBar"]/*' />
    /// <devdoc>
    ///     The TrackBar is a scrollable control similar to the ScrollBar, but
    ///     has a different UI.  You can configure ranges through which it should
    ///     scroll, and also define increments for off-button clicks.  It can be
    ///     aligned horizontally or vertically.  You can also configure how many
    ///     'ticks' are shown for the total range of values
    /// </devdoc>
    [
    DefaultProperty("Value"),
    DefaultEvent("Scroll"),
    Designer("System.Windows.Forms.Design.TrackBarDesigner, " + AssemblyRef.SystemDesign)
    ]
    public class TrackBar : Control, ISupportInitialize {

        private static readonly object EVENT_SCROLL = new object();
        private static readonly object EVENT_VALUECHANGED = new object();

        private bool autoSize = true;
        private int largeChange = 5;
        private int maximum = 10;
        private int minimum = 0;
        private Orientation orientation = System.Windows.Forms.Orientation.Horizontal;
        private int value = 0;
        private int smallChange = 1;
        private int tickFrequency = 1;
        private TickStyle tickStyle = System.Windows.Forms.TickStyle.BottomRight;

        private int requestedDim;

        // Disable value range checking while initializing the control
        private bool initializing = false;

        /// <include file='doc\TrackBar.uex' path='docs/doc[@for="TrackBar.TrackBar"]/*' />
        /// <devdoc>
        ///     Creates a new TrackBar control with a default range of 0..10 and
        ///     ticks shown every value.
        /// </devdoc>
        public TrackBar()
        : base() {
            SetStyle(ControlStyles.UserPaint, false);
            requestedDim = PreferredDimension;
        }
        
        /// <include file='doc\TrackBar.uex' path='docs/doc[@for="TrackBar.AutoSize"]/*' />
        /// <devdoc>
        ///     Indicates if the control is being auto-sized.  If true, the
        ///     TrackBar will adjust either it's height or width [depending on
        ///     orientation] to make sure that only the required amount of
        ///     space is used.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(true),
        SRDescription(SR.TrackBarAutoSizeDescr)
        ]
        public bool AutoSize {
            get {
                return autoSize;
            }

            set {
                if (autoSize != value) {
                    autoSize = value;
                    if (orientation == Orientation.Horizontal) {
                        SetStyle(ControlStyles.FixedHeight, autoSize);
                        SetStyle(ControlStyles.FixedWidth, false);
                    }
                    else {
                        SetStyle(ControlStyles.FixedWidth, autoSize);
                        SetStyle(ControlStyles.FixedHeight, false);
                    }
                    AdjustSize();
                    
                }
            }
        }

        /// <include file='doc\TrackBar.uex' path='docs/doc[@for="TrackBar.BackgroundImage"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override Image BackgroundImage {
            get {
                return base.BackgroundImage;
            }
            set {
                base.BackgroundImage = value;
            }
        }

        /// <include file='doc\TrackBar.uex' path='docs/doc[@for="TrackBar.BackgroundImageChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler BackgroundImageChanged {
            add {
                base.BackgroundImageChanged += value;
            }
            remove {
                base.BackgroundImageChanged -= value;
            }
        }

        /// <include file='doc\TrackBar.uex' path='docs/doc[@for="TrackBar.CreateParams"]/*' />
        /// <devdoc>
        ///     This is called when creating a window.  Inheriting classes can ovveride
        ///     this to add extra functionality, but should not forget to first call
        ///     base.getCreateParams() to make sure the control continues to work
        ///     correctly.
        /// </devdoc>
        /// <internalonly/>
        protected override CreateParams CreateParams {
            [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
            get {
                CreateParams cp = base.CreateParams;
                cp.ClassName = NativeMethods.WC_TRACKBAR;

                switch (tickStyle) {
                    case TickStyle.None:
                        cp.Style |= NativeMethods.TBS_NOTICKS;
                        break;
                    case TickStyle.TopLeft:
                        cp.Style |= (NativeMethods.TBS_AUTOTICKS | NativeMethods.TBS_TOP);
                        break;
                    case TickStyle.BottomRight:
                        cp.Style |= (NativeMethods.TBS_AUTOTICKS | NativeMethods.TBS_BOTTOM);
                        break;
                    case TickStyle.Both:
                        cp.Style |= (NativeMethods.TBS_AUTOTICKS | NativeMethods.TBS_BOTH);
                        break;
                }

                if (orientation == Orientation.Vertical) {
                    cp.Style |= NativeMethods.TBS_VERT; // HORIZ == 0
                }

                return cp;
            }
        }
        
        /// <include file='doc\TrackBar.uex' path='docs/doc[@for="TrackBar.DefaultImeMode"]/*' />
        /// <internalonly/>
        protected override ImeMode DefaultImeMode {
            get {
                return ImeMode.Disable;
            }
        }

        /// <include file='doc\TrackBar.uex' path='docs/doc[@for="TrackBar.DefaultSize"]/*' />
        /// <devdoc>
        ///     Deriving classes can override this to configure a default size for their control.
        ///     This is more efficient than setting the size in the control's constructor.
        /// </devdoc>
        protected override Size DefaultSize {
            get {
                return new Size(104, 42);
            }
        }

        /// <include file='doc\TrackBar.uex' path='docs/doc[@for="TrackBar.Font"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override Font Font {
            get {
                return base.Font;
            }
            set {
                base.Font = value;
            }
        }

        /// <include file='doc\TrackBar.uex' path='docs/doc[@for="TrackBar.FontChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler FontChanged {
            add {
                base.FontChanged += value;
            }
            remove {
                base.FontChanged -= value;
            }
        }

        /// <include file='doc\TrackBar.uex' path='docs/doc[@for="TrackBar.ForeColor"]/*' />
        /// <devdoc>
        ///     The current foreground color of the TrackBar.  Note that users
        ///     are unable to change this.  It is always Color.WINDOWTEXT
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override Color ForeColor {
            get {
                return SystemColors.WindowText;
            }
            set {
            }
        }
        
        /// <include file='doc\TrackBar.uex' path='docs/doc[@for="TrackBar.ForeColorChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler ForeColorChanged {
            add {
                base.ForeColorChanged += value;
            }
            remove {
                base.ForeColorChanged -= value;
            }
        }

        /// <include file='doc\TrackBar.uex' path='docs/doc[@for="TrackBar.ImeMode"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public ImeMode ImeMode {
            get {
                return base.ImeMode;
            }
            set {
                base.ImeMode = value;
            }
        }

        /// <include file='doc\TrackBar.uex' path='docs/doc[@for="TrackBar.ImeModeChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event EventHandler ImeModeChanged {
            add {
                base.ImeModeChanged += value;
            }
            remove {
                base.ImeModeChanged -= value;
            }
        }

        /// <include file='doc\TrackBar.uex' path='docs/doc[@for="TrackBar.LargeChange"]/*' />
        /// <devdoc>
        ///     The number of ticks by which the TrackBar will change when an
        ///     event considered a "large change" occurs.  These include, Clicking the
        ///     mouse to the side of the button, or using the PgUp/PgDn keys on the
        ///     keyboard.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(5),
        SRDescription(SR.TrackBarLargeChangeDescr)
        ]
        public int LargeChange {
            get {
                return largeChange;
            }
            set {
                if (value < 0) {
                    throw new ArgumentException(SR.GetString(SR.TrackBarLargeChangeError, value), "value");
                }

                if (largeChange != value) {
                    largeChange = value;
                    if (IsHandleCreated)
                        SendMessage(NativeMethods.TBM_SETPAGESIZE, 0, value);
                }
            }
        }

        /// <include file='doc\TrackBar.uex' path='docs/doc[@for="TrackBar.Maximum"]/*' />
        /// <devdoc>
        ///     The upper limit of the range this TrackBar is working with.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(10),
        RefreshProperties(RefreshProperties.All),
        SRDescription(SR.TrackBarMaximumDescr)
        ]
        public int Maximum {
            get {
                return maximum;
            }
            set {
                if (maximum != value) {
                    if (value < minimum) {
                        minimum = value;
                    }
                    SetRange(minimum, value);
                }
            }
        }

        /// <include file='doc\TrackBar.uex' path='docs/doc[@for="TrackBar.Minimum"]/*' />
        /// <devdoc>
        ///     The lower limit of the range this TrackBar is working with.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(0),
        RefreshProperties(RefreshProperties.All),
        SRDescription(SR.TrackBarMinimumDescr)
        ]
        public int Minimum {
            get {
                return minimum;
            }
            set {
                if (minimum != value) {
                    if (value > maximum) {
                        maximum = value;
                    }
                    SetRange(value, maximum);
                }
            }
        }

        /// <include file='doc\TrackBar.uex' path='docs/doc[@for="TrackBar.Orientation"]/*' />
        /// <devdoc>
        ///    <para>The orientation for this TrackBar. Valid values are from
        ///       the Orientation enumeration. The control currently supports being
        ///       oriented horizontally and vertically.</para>
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        DefaultValue(Orientation.Horizontal),
        Localizable(true),
        SRDescription(SR.TrackBarOrientationDescr)
        ]
        public Orientation Orientation {
            get {
                return orientation;
            }
            set {
                // Confirm that value is a valid enum
                if (!Enum.IsDefined(typeof(Orientation), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(Orientation));
                }

                if (orientation != value) {
                    orientation = value;

                    if (orientation == Orientation.Horizontal) {
                        SetStyle(ControlStyles.FixedHeight, autoSize);
                        SetStyle(ControlStyles.FixedWidth, false);
                    }
                    else {
                        SetStyle(ControlStyles.FixedHeight, false);
                        SetStyle(ControlStyles.FixedWidth, autoSize);
                    }

                    if (IsHandleCreated) {
                        Rectangle r = Bounds;
                        RecreateHandle();
                        SetBounds(r.X, r.Y, r.Height, r.Width, BoundsSpecified.All);
                        AdjustSize();
                    }
                }
            }
        }

        /// <include file='doc\TrackBar.uex' path='docs/doc[@for="TrackBar.PreferredDimension"]/*' />
        /// <devdoc>
        ///     Little private routine that helps with auto-sizing.
        /// </devdoc>
        /// <internalonly/>
        private int PreferredDimension {
            get {
                int cyhscroll = UnsafeNativeMethods.GetSystemMetrics(NativeMethods.SM_CYHSCROLL);

                // this is our preferred size
                //
                return((cyhscroll * 8) / 3);
            }
        }

        /// <include file='doc\TrackBar.uex' path='docs/doc[@for="TrackBar.SmallChange"]/*' />
        /// <devdoc>
        ///     The number of ticks by which the TrackBar will change when an
        ///     event considered a "small change" occurs.  These are most commonly
        ///     seen by using the arrow keys to move the TrackBar thumb around.
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        DefaultValue(1),
        SRDescription(SR.TrackBarSmallChangeDescr)
        ]
        public int SmallChange {
            get {
                return smallChange;
            }
            set {
                if (value < 0) {
                    throw new ArgumentException(SR.GetString(SR.TrackBarSmallChangeError, value), "value");
                }
                if (smallChange != value) {
                    smallChange = value;
                    if (IsHandleCreated)
                        SendMessage(NativeMethods.TBM_SETLINESIZE, 0, value);
                }
            }
        }
        
        /// <include file='doc\TrackBar.uex' path='docs/doc[@for="TrackBar.Text"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>        
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never), Bindable(false)]        
        public override string Text {
            get {
                return base.Text;
            }
            set {
                base.Text = value;
            }
        }

        /// <include file='doc\TrackBar.uex' path='docs/doc[@for="TrackBar.TextChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler TextChanged {
            add {
                base.TextChanged += value;
            }
            remove {
                base.TextChanged -= value;
            }
        }
        
        /// <include file='doc\TrackBar.uex' path='docs/doc[@for="TrackBar.TickStyle"]/*' />
        /// <devdoc>
        ///     Indicates how the TrackBar control will draw itself.  This affects
        ///     both where the ticks will be drawn in relation to the moveable thumb,
        ///     and how the thumb itself will be drawn.  values are taken from the
        ///     TickStyle enumeration.
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        DefaultValue(TickStyle.BottomRight),
        SRDescription(SR.TrackBarTickStyleDescr)
        ]
        public TickStyle TickStyle {
            get {
                return tickStyle;
            }
            set {
                // Confirm that value is a valid enum
                if (!Enum.IsDefined(typeof(TickStyle), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(TickStyle));
                }

                if (tickStyle != value) {
                    tickStyle = value;
                    RecreateHandle();
                }
            }
        }

        /// <include file='doc\TrackBar.uex' path='docs/doc[@for="TrackBar.TickFrequency"]/*' />
        /// <devdoc>
        ///     Indicates just how many ticks will be drawn.  For a TrackBar with a
        ///     range of 0..100, it might be impractical to draw all 100 ticks for a
        ///     very small control.  Passing in a value of 5 here would only draw
        ///     20 ticks -- i.e. Each tick would represent 5 units in the TrackBars
        ///     range of values.
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        DefaultValue(1),
        SRDescription(SR.TrackBarTickFrequencyDescr)
        ]
        public int TickFrequency {
            get {
                return tickFrequency;
            }
            set {
                if (tickFrequency != value) {
                    tickFrequency = value;
                    if (IsHandleCreated) {
                        SendMessage(NativeMethods.TBM_SETTICFREQ, value, 0);
                        Invalidate();
                    }
                }
            }
        }

        /// <include file='doc\TrackBar.uex' path='docs/doc[@for="TrackBar.Value"]/*' />
        /// <devdoc>
        ///     The current location of the TrackBar thumb.  This value must
        ///     be between the lower and upper limits of the TrackBar range, of course.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(0),
        Bindable(true),
        SRDescription(SR.TrackBarValueDescr)
        ]
        public int Value {
            get {
                GetTrackBarValue();
                return value;
            }
            set {
                if (this.value != value) {
                    if (!initializing && ((value < minimum) || (value > maximum)))
                        throw new ArgumentException(SR.GetString(SR.InvalidBoundArgument,
                                                                  "Value", (value).ToString(),
                                                                  "'Minimum'", "'Maximum'"));
                    this.value = value;
                    SetTrackBarPosition();
                    OnValueChanged(EventArgs.Empty);
                }
            }
        }    

        /// <include file='doc\TrackBar.uex' path='docs/doc[@for="TrackBar.Click"]/*' />
        /// <internalonly/><hideinheritance/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event EventHandler Click {
            add {
                base.Click += value;
            }
            remove {
                base.Click -= value;
            }
        }

        /// <include file='doc\TrackBar.uex' path='docs/doc[@for="TrackBar.DoubleClick"]/*' />
        /// <internalonly/><hideinheritance/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event EventHandler DoubleClick {
            add {
                base.DoubleClick += value;
            }
            remove {
                base.DoubleClick -= value;
            }
        }

        /// <include file='doc\TrackBar.uex' path='docs/doc[@for="TrackBar.Scroll"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatBehavior), SRDescription(SR.TrackBarOnScrollDescr)]
        public event EventHandler Scroll {
            add {
                Events.AddHandler(EVENT_SCROLL, value);
            }
            remove {
                Events.RemoveHandler(EVENT_SCROLL, value);
            }
        }

        /// <include file='doc\TrackBar.uex' path='docs/doc[@for="TrackBar.OnPaint"]/*' />
        /// <devdoc>
        ///     TrackBar Onpaint.
        /// </devdoc>
        /// <internalonly/><hideinheritance/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event PaintEventHandler Paint {
            add {
                base.Paint += value;
            }
            remove {
                base.Paint -= value;
            }
        }

        /// <include file='doc\TrackBar.uex' path='docs/doc[@for="TrackBar.ValueChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatAction), SRDescription(SR.valueChangedEventDescr)]
        public event EventHandler ValueChanged {
            add {
                Events.AddHandler(EVENT_VALUECHANGED, value);
            }
            remove {
                Events.RemoveHandler(EVENT_VALUECHANGED, value);
            }
        }

        /// <include file='doc\TrackBar.uex' path='docs/doc[@for="TrackBar.AdjustSize"]/*' />
        /// <devdoc>
        ///     Enforces autoSizing
        /// </devdoc>
        /// <internalonly/>
        private void AdjustSize() {
            if (IsHandleCreated) {
                int saveDim = requestedDim;
                try {
                    if (orientation == Orientation.Horizontal)
                        Height = autoSize ? PreferredDimension : saveDim;
                    else
                        Width = autoSize ? PreferredDimension : saveDim;
                }
                finally {
                    requestedDim = saveDim;
                }
            }
        }

        /// <include file='doc\TrackBar.uex' path='docs/doc[@for="TrackBar.BeginInit"]/*' />
        /// <devdoc>
        ///      Handles tasks required when the control is being initialized.
        /// </devdoc>
        /// <internalonly/>
        public void BeginInit() {
            initializing = true;
        }

        // Constrain the current value of the control to be within
        // the minimum and maximum.
        //
        private void ConstrainValue() {

            // Don't constrain the value while we're initializing the control
            if (initializing) {
                return;
            }

            Debug.Assert(minimum <= maximum, "Minimum should be <= Maximum");

            // Keep the current value within the minimum and maximum
            if (Value < minimum) {
                Value = minimum;
            }
            if (Value > maximum) {
                Value = maximum;
            }
        }

        /// <include file='doc\TrackBar.uex' path='docs/doc[@for="TrackBar.CreateHandle"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        protected override void CreateHandle() {
            if (!RecreatingHandle) {
                NativeMethods.INITCOMMONCONTROLSEX icc = new NativeMethods.INITCOMMONCONTROLSEX();
                icc.dwICC = NativeMethods.ICC_BAR_CLASSES;
                SafeNativeMethods.InitCommonControlsEx(icc);
            }
            base.CreateHandle();
        }
        
        /// <include file='doc\TrackBar.uex' path='docs/doc[@for="TrackBar.EndInit"]/*' />
        /// <devdoc>
        ///      Called when initialization of the control is complete.
        /// </devdoc>
        /// <internalonly/>
        public void EndInit() {
            initializing = false;

            // Make sure the value is constrained by the minimum and maximum
            ConstrainValue();
        }

        private void GetTrackBarValue() {
            if (IsHandleCreated) {
                value = (int)SendMessage(NativeMethods.TBM_GETPOS, 0, 0);
                
                // See SetTrackBarValue() for a description of why we sometimes reflect the trackbar value
                //                   
                   
                if (orientation == Orientation.Vertical) {
                    // Reflect value
                    value = Minimum + Maximum - value;
                }
                
                // Reflect for a RightToLeft horizontal trackbar
                //
                if (orientation == Orientation.Horizontal && RightToLeft == RightToLeft.Yes) {
                    value = Minimum + Maximum - value;
                }
            }
        }                                               

        /// <include file='doc\TrackBar.uex' path='docs/doc[@for="TrackBar.IsInputKey"]/*' />
        /// <devdoc>
        ///      Handling special input keys, such as pgup, pgdown, home, end, etc...
        /// </devdoc>
        protected override bool IsInputKey(Keys keyData) {
            if ((keyData & Keys.Alt) == Keys.Alt) return false;
            switch (keyData & Keys.KeyCode) {
                case Keys.PageUp:
                case Keys.PageDown:
                case Keys.Home:
                case Keys.End:
                    return true;
            }
            return base.IsInputKey(keyData);
        }
        
        /// <include file='doc\TrackBar.uex' path='docs/doc[@for="TrackBar.OnHandleCreated"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        protected override void OnHandleCreated(EventArgs e) {
            base.OnHandleCreated(e);
            SendMessage(NativeMethods.TBM_SETRANGEMIN, 0, minimum);
            SendMessage(NativeMethods.TBM_SETRANGEMAX, 0, maximum);
            SendMessage(NativeMethods.TBM_SETTICFREQ, tickFrequency, 0);
            SendMessage(NativeMethods.TBM_SETPAGESIZE, 0, largeChange);
            SendMessage(NativeMethods.TBM_SETLINESIZE, 0, smallChange);
            SetTrackBarPosition();
            AdjustSize();
        }

        /// <include file='doc\TrackBar.uex' path='docs/doc[@for="TrackBar.OnScroll"]/*' />
        /// <devdoc>
        ///     Actually fires the "scroll" event.  Inheriting classes should override
        ///     this method in favor of actually adding an EventHandler for this
        ///     event.  Inheriting classes should not forget to call
        ///     base.onScroll(e)
        /// </devdoc>
        protected virtual void OnScroll(EventArgs e) {
            EventHandler handler = (EventHandler)Events[EVENT_SCROLL];
            if (handler != null) handler(this,e);
        }


        /// <include file='doc\Trackbar.uex' path='docs/doc[@for="Trackbar.OnMouseWheel"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Windows.Forms.Control.MouseWheel'/> event.</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected override void OnMouseWheel(MouseEventArgs e) {
            base.OnMouseWheel( e );
            if (e.Delta != Value) {
                OnScroll(EventArgs.Empty);
                OnValueChanged(EventArgs.Empty);
            }
        }


        /// <include file='doc\TrackBar.uex' path='docs/doc[@for="TrackBar.OnValueChanged"]/*' />
        /// <devdoc>
        ///     Actually fires the "valueChanged" event.
        /// </devdoc>
        /// <internalonly/>
        protected virtual void OnValueChanged(EventArgs e) {
            EventHandler handler = (EventHandler)Events[EVENT_VALUECHANGED];
            if (handler != null) handler(this,e);
        }

        /// <include file='doc\TrackBar.uex' path='docs/doc[@for="TrackBar.OnBackColorChanged"]/*' />
        /// <devdoc>
        ///     This method is called by the control when any property changes. Inheriting
        ///     controls can overide this method to get property change notification on
        ///     basic properties. Inherting controls must call base.propertyChanged.
        /// </devdoc>
        protected override void OnBackColorChanged(EventArgs e) {
            base.OnBackColorChanged(e);

            // Trackbar uses a double buffered bitmap, and we must
            // somehow convince it to totally redraw.  This works and is
            // pretty cheap.
            //
            UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.WM_WININICHANGE, 0, 0);
        }

        /// <include file='doc\TrackBar.uex' path='docs/doc[@for="TrackBar.SetBoundsCore"]/*' />
        /// <devdoc>
        ///     Overrides Control.setBoundsCore to enforce autoSize.
        /// </devdoc>
        protected override void SetBoundsCore(int x, int y, int width, int height, BoundsSpecified specified) {
            //SetBoundsCore .. sets the height for a control in designer .. we should obey the requested 
            //height is Autosize is false..
            //if (IsHandleCreated) {
                requestedDim = (orientation == Orientation.Horizontal)
                               ? height
                               : width;

                if (autoSize) {
                    if (orientation == Orientation.Horizontal) {
                        if ((specified & BoundsSpecified.Height) != BoundsSpecified.None)
                            height = PreferredDimension;
                    }
                    else {
                        if ((specified & BoundsSpecified.Width) != BoundsSpecified.None)
                            width = PreferredDimension;
                    }
                }
            //}
            base.SetBoundsCore(x, y, width, height, specified);
        }

        /// <include file='doc\TrackBar.uex' path='docs/doc[@for="TrackBar.SetRange"]/*' />
        /// <devdoc>
        ///     Lets you set the the entire range for the TrackBar control at once.
        ///     The values passed are both the lower and upper limits to the range
        ///     with which the control will work.
        /// </devdoc>
        public void SetRange(int minValue, int maxValue) {
            if (minimum != minValue || maximum != maxValue) {
            
                // The Minimum and Maximum properties contain the logic for
                // ensuring that minValue <= maxValue. It is possible, however,
                // that this function will be called somewhere other than from
                // these two properties, so we'll check that here anyway.
                // CONSIDER: Perhaps there's a better way of doing this
                if (minValue > maxValue) {
                    // We'll just adjust maxValue to match minValue
                    maxValue = minValue;
                }

                minimum = minValue;
                maximum = maxValue;

                if (IsHandleCreated) {
                    SendMessage(NativeMethods.TBM_SETRANGEMIN, 0, minimum);

                    // We must repaint the trackbar after changing
                    // the range. The '1' in the call to
                    // SendMessage below indicates that the trackbar
                    // should be redrawn (see TBM_SETRANGEMAX in MSDN)
                    SendMessage(NativeMethods.TBM_SETRANGEMAX, 1, maximum);

                    Invalidate();
                }
                
                // When we change the range, the comctl32 trackbar's internal position can change 
                // (because of the reflection that occurs with vertical trackbars)
                // so we make sure to explicitly set the trackbar position.
                //
                if (value < minimum) {
                    value = minimum;
                }
                if (value > maximum) {
                    value = maximum;
                }
                SetTrackBarPosition();
            }
        }
        
        private void SetTrackBarPosition() {
            if (IsHandleCreated) {
            
                // There are two situations where we want to reflect the track bar position:
                //
                // 1. For a vertical trackbar, it seems to make more sense for the trackbar to increase in value
                //    as the slider moves up the trackbar (this is opposite what the underlying winctl control does)
                //
                // 2. For a RightToLeft horizontal trackbar, we want to reflect the position.
                //
                int reflectedValue = value;
                
                // 1. Reflect for a vertical trackbar
                //
                if (orientation == Orientation.Vertical) {
                    reflectedValue = Minimum + Maximum - value;
                }
                
                // 2. Reflect for a RightToLeft horizontal trackbar
                //
                if (orientation == Orientation.Horizontal && RightToLeft == RightToLeft.Yes) {
                    reflectedValue = Minimum + Maximum - value;
                }
                
                SendMessage(NativeMethods.TBM_SETPOS, 1, reflectedValue);
            }
        }

        /// <include file='doc\TrackBar.uex' path='docs/doc[@for="TrackBar.ToString"]/*' />
        /// <devdoc>
        ///     Returns a string representation for this control.
        /// </devdoc>
        /// <internalonly/>
        public override string ToString() {

            string s = base.ToString();
            return s + ", Minimum: " + Minimum.ToString() + ", Maximum: " + Maximum.ToString() + ", Value: " + Value.ToString();
        }

        /// <include file='doc\TrackBar.uex' path='docs/doc[@for="TrackBar.WndProc"]/*' />
        /// <devdoc>
        ///     The button's window procedure.  Inheriting classes can override this
        ///     to add extra functionality, but should not forget to call
        ///     base.wndProc(m); to ensure the button continues to function properly.
        /// </devdoc>
        /// <internalonly/>
        [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        protected override void WndProc(ref Message m) {
            switch (m.Msg) {
                case NativeMethods.WM_REFLECT+NativeMethods.WM_HSCROLL:
                case NativeMethods.WM_REFLECT+NativeMethods.WM_VSCROLL:
                    switch ((int)m.WParam & 0x0000FFFF) {
                        case NativeMethods.TB_LINEUP:
                        case NativeMethods.TB_LINEDOWN:
                        case NativeMethods.TB_PAGEUP:
                        case NativeMethods.TB_PAGEDOWN:
                            //case NativeMethods.TB_THUMBPOSITION:
                        case NativeMethods.TB_THUMBTRACK:
                        case NativeMethods.TB_TOP:
                        case NativeMethods.TB_BOTTOM:
                        case NativeMethods.TB_ENDTRACK:
                            if (value != Value) {
                                OnScroll(EventArgs.Empty);
                                OnValueChanged(EventArgs.Empty);
                            }
                            break;
                    }
                    break;
                default:
                    base.WndProc(ref m);
                    break;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\toolbarbuttonstyle.cs ===
//------------------------------------------------------------------------------
// <copyright file="ToolBarButtonStyle.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    using System.Drawing;
    using Microsoft.Win32;


    /// <include file='doc\ToolBarButtonStyle.uex' path='docs/doc[@for="ToolBarButtonStyle"]/*' />
    /// <devdoc>
    ///    <para>Specifies the button style within a toolbar.</para>
    /// </devdoc>
    public enum ToolBarButtonStyle {

        /// <include file='doc\ToolBarButtonStyle.uex' path='docs/doc[@for="ToolBarButtonStyle.PushButton"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A
        ///       standard, three-dimensional
        ///       button.
        ///    </para>
        /// </devdoc>
        PushButton     = 1,

        /// <include file='doc\ToolBarButtonStyle.uex' path='docs/doc[@for="ToolBarButtonStyle.ToggleButton"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A toggle button that appears sunken when clicked
        ///       and retains the sunken appearance until
        ///       clicked again.
        ///    </para>
        /// </devdoc>
        ToggleButton   = 2,

        /// <include file='doc\ToolBarButtonStyle.uex' path='docs/doc[@for="ToolBarButtonStyle.Separator"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A space or
        ///       line between toolbar buttons. The appearance depends on the
        ///       value of the <see cref='System.Windows.Forms.ToolBar.Appearance'/>
        ///       property.
        ///    </para>
        /// </devdoc>
        Separator      = 3,

        /// <include file='doc\ToolBarButtonStyle.uex' path='docs/doc[@for="ToolBarButtonStyle.DropDownButton"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A drop down control that displays a menu or other window
        ///       when
        ///       clicked.
        ///    </para>
        /// </devdoc>
        DropDownButton = 4,

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\toolbartextalign.cs ===
//------------------------------------------------------------------------------
// <copyright file="ToolBarTextAlign.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {

    using System.Diagnostics;
    using System;
    using System.ComponentModel;
    using System.Drawing;
    using Microsoft.Win32;



    /// <include file='doc\ToolBarTextAlign.uex' path='docs/doc[@for="ToolBarTextAlign"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies
    ///       the alignment of text on the toolbar button control.
    ///    </para>
    /// </devdoc>
    public enum ToolBarTextAlign {

        /// <include file='doc\ToolBarTextAlign.uex' path='docs/doc[@for="ToolBarTextAlign.Underneath"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The text
        ///       is aligned underneath the toolbar button image.
        ///    </para>
        /// </devdoc>
        Underneath = 0,

        /// <include file='doc\ToolBarTextAlign.uex' path='docs/doc[@for="ToolBarTextAlign.Right"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The text
        ///       is aligned to the right of the toolbar button image.
        ///    </para>
        /// </devdoc>
        Right = 1,

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\toolbarbuttonclickeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="ToolBarButtonClickEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   ToolBarButtonClickEventHandler.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;


    /// <include file='doc\ToolBarButtonClickEventHandler.uex' path='docs/doc[@for="ToolBarButtonClickEventHandler"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents the method that will handle the <see cref='System.Windows.Forms.ToolBar.ButtonClick'/> event of a
    ///    <see cref='System.Windows.Forms.ToolBar'/> .
    ///    </para>
    /// </devdoc>
    public delegate void ToolBarButtonClickEventHandler(object sender, ToolBarButtonClickEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\trayicon.cs ===
//------------------------------------------------------------------------------
// <copyright file="TrayIcon.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {
    using System.Runtime.Remoting;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System;
    using System.Runtime.InteropServices;
    using System.Windows.Forms;    
    using System.Windows.Forms.Design;
    using Microsoft.Win32;
    using System.Drawing;

    /// <include file='doc\TrayIcon.uex' path='docs/doc[@for="NotifyIcon"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies a component that creates
    ///       an icon in the Windows System Tray. This class cannot be inherited.
    ///    </para>
    /// </devdoc>
    [
    DefaultProperty("Text"),
    DefaultEvent("MouseDown"),
    Designer("System.Windows.Forms.Design.NotifyIconDesigner, " + AssemblyRef.SystemDesign),
    ToolboxItemFilter("System.Windows.Forms")
    ]
    public sealed class NotifyIcon : Component {
        static readonly object EVENT_MOUSEDOWN  = new object();
        static readonly object EVENT_MOUSEMOVE  = new object();
        static readonly object EVENT_MOUSEUP    = new object();
        static readonly object EVENT_CLICK      = new object();
        static readonly object EVENT_DOUBLECLICK = new object();
        
        const int WM_TRAYMOUSEMESSAGE = NativeMethods.WM_USER + 1024;
        static int WM_TASKBARCREATED = SafeNativeMethods.RegisterWindowMessage("TaskbarCreated");

        Icon icon = null;
        string text = "";
        int id = 0;
        bool added = false;
        NotifyIconNativeWindow window = null;
        ContextMenu contextMenu = null;

        static int nextId = 0;

        bool doubleClick = false; // checks if doubleclick is fired

        // Visible defaults to false, but the NotifyIconDesigner makes it seem like the default is 
        // true.  We do this because while visible is the more common case, if it was a true default,
        // there would be no way to create a hidden NotifyIcon without being visible for a moment.
        private bool visible = false;

        /// <include file='doc\TrayIcon.uex' path='docs/doc[@for="NotifyIcon.NotifyIcon"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Windows.Forms.NotifyIcon'/> class.
        ///    </para>
        /// </devdoc>
        public NotifyIcon() {
            id = ++nextId;
            window = new NotifyIconNativeWindow(this);
            UpdateIcon(visible);
        }

        /// <include file='doc\TrayIcon.uex' path='docs/doc[@for="NotifyIcon.NotifyIcon1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Windows.Forms.NotifyIcon'/> class.
        ///    </para>
        /// </devdoc>
        public NotifyIcon(IContainer container) : this() {
            container.Add(this);
        }

        /// <include file='doc\TrayIcon.uex' path='docs/doc[@for="NotifyIcon.ContextMenu"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets context menu
        ///       for the tray icon.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(null),
        WinCategory( "Behavior" ),
        SRDescription(SR.NotifyIconMenuDescr)
        ]
        public ContextMenu ContextMenu {
            get {
                return contextMenu;
            }

            set {
                this.contextMenu = value;
            }
        }

        /// <include file='doc\TrayIcon.uex' path='docs/doc[@for="NotifyIcon.Icon"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the current
        ///       icon.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        Localizable(true),
        DefaultValue(null),
        SRDescription(SR.NotifyIconIconDescr)
        ]
        public Icon Icon {
            get {
                return icon;
            }
            set {
                if (icon != value) {
                    this.icon = value;
                    UpdateIcon(visible);
                }
            }
        }

        /// <include file='doc\TrayIcon.uex' path='docs/doc[@for="NotifyIcon.Text"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the ToolTip text displayed when
        ///       the mouse hovers over a system tray icon.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        Localizable(true),
        SRDescription(SR.NotifyIconTextDescr)
        ]
        public string Text {
            get {
                return text;
            }
            set {
                if (value == null) value = "";
                if (value != null && !value.Equals(this.text)) {
                    if (value != null && value.Length > 63) {
                        throw new ArgumentException(SR.GetString(SR.TrayIcon_TextTooLong));
                    }
                    this.text = value;
                    if (added) {
                        UpdateIcon(true);
                    }
                }
            }
        }

        /// <include file='doc\TrayIcon.uex' path='docs/doc[@for="NotifyIcon.Visible"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the icon is visible in the Windows System Tray.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        Localizable(true),
        DefaultValue(false),
        SRDescription(SR.NotifyIconVisDescr)
        ]
        public bool Visible {
            get {
                return visible;
            }
            set {
                if (visible != value) {
                    UpdateIcon(value);
                    visible = value;
                }
            }
        }

        /// <include file='doc\TrayIcon.uex' path='docs/doc[@for="NotifyIcon.Click"]/*' />
        /// <devdoc>
        ///     Occurs when the user clicks the icon in the system tray.
        /// </devdoc>
        [Category("Action"), SRDescription(SR.ControlOnClickDescr)]
        public event EventHandler Click {
            add {
                Events.AddHandler(EVENT_CLICK, value);
            }
            remove {
                Events.RemoveHandler(EVENT_CLICK, value);
            }
        }

        /// <include file='doc\TrayIcon.uex' path='docs/doc[@for="NotifyIcon.DoubleClick"]/*' />
        /// <devdoc>
        ///     Occurs when the user double-clicks the icon in the system tray.
        /// </devdoc>
        [Category("Action"), SRDescription(SR.ControlOnDoubleClickDescr)]
        public event EventHandler DoubleClick {
            add {
                Events.AddHandler(EVENT_DOUBLECLICK, value);
            }
            remove {
                Events.RemoveHandler(EVENT_DOUBLECLICK, value);
            }
        }

        /// <include file='doc\TrayIcon.uex' path='docs/doc[@for="NotifyIcon.MouseDown"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Occurs when the
        ///       user presses a mouse button while the pointer is over the icon in the system tray.
        ///    </para>
        /// </devdoc>
        [SRCategory(SR.CatMouse), SRDescription(SR.ControlOnMouseDownDescr)]
        public event MouseEventHandler MouseDown {
            add {
                Events.AddHandler(EVENT_MOUSEDOWN, value);
            }
            remove {
                Events.RemoveHandler(EVENT_MOUSEDOWN, value);
            }
        }        

        /// <include file='doc\TrayIcon.uex' path='docs/doc[@for="NotifyIcon.MouseMove"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Occurs
        ///       when the user moves the mouse pointer over the icon in the system tray.
        ///    </para>
        /// </devdoc>
        [SRCategory(SR.CatMouse), SRDescription(SR.ControlOnMouseMoveDescr)]
        public event MouseEventHandler MouseMove {
            add {
                Events.AddHandler(EVENT_MOUSEMOVE, value);
            }
            remove {
                Events.RemoveHandler(EVENT_MOUSEMOVE, value);
            }
        }        

        /// <include file='doc\TrayIcon.uex' path='docs/doc[@for="NotifyIcon.MouseUp"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Occurs when the
        ///       user releases the mouse button while the pointer
        ///       is over the icon in the system tray.
        ///    </para>
        /// </devdoc>
        [SRCategory(SR.CatMouse), SRDescription(SR.ControlOnMouseUpDescr)]
        public event MouseEventHandler MouseUp {
            add {
                Events.AddHandler(EVENT_MOUSEUP, value);
            }
            remove {
                Events.RemoveHandler(EVENT_MOUSEUP, value);
            }
        }        

        /// <include file='doc\TrayIcon.uex' path='docs/doc[@for="NotifyIcon.Dispose"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Disposes of the resources (other than memory) used by the
        ///    <see cref='System.Windows.Forms.NotifyIcon'/>.
        ///    </para>
        /// </devdoc>
        protected override void Dispose(bool disposing) {
            if (disposing) {
                if (window != null) {
                    this.icon = null;
                    this.Text = "";
                    UpdateIcon(false);
                    window.DestroyHandle();
                    window = null;
                    contextMenu = null;
                }
            }
            else {
                // This same post is done in ControlNativeWindow's finalize method, so if you change
                // it, change it there too.
                //
                if (window != null && window.Handle != IntPtr.Zero) {
                    UnsafeNativeMethods.PostMessage(new HandleRef(window, window.Handle), NativeMethods.WM_CLOSE, 0, 0);
                    window.ReleaseHandle();
                }
            }
            base.Dispose(disposing);
        }

        /// <include file='doc\TrayIcon.uex' path='docs/doc[@for="NotifyIcon.OnClick"]/*' />
        /// <devdoc>
        ///    <para>
        ///       This method actually raises the Click event. Inheriting classes should
        ///       override this if they wish to be notified of a Click event. (This is far
        ///       preferable to actually adding an event handler.) They should not,
        ///       however, forget to call base.onClick(e); before exiting, to ensure that
        ///       other recipients do actually get the event.
        ///    </para>
        /// </devdoc>
        private void OnClick(EventArgs e) {
            EventHandler handler = (EventHandler) Events[ EVENT_CLICK ];
            if (handler != null)
                handler( this, e );
        }

        /// <include file='doc\TrayIcon.uex' path='docs/doc[@for="NotifyIcon.OnDoubleClick"]/*' />
        /// <devdoc>
        ///     Inheriting classes should override this method to handle this event.
        ///     Call base.onDoubleClick to send this event to any registered event listeners.
        /// </devdoc>
        private void OnDoubleClick(EventArgs e) {
            EventHandler handler = (EventHandler) Events[ EVENT_DOUBLECLICK ];
            if (handler != null)
                handler( this, e );
        }

        /// <include file='doc\TrayIcon.uex' path='docs/doc[@for="NotifyIcon.OnMouseDown"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raises the <see cref='System.Windows.Forms.NotifyIcon.MouseDown'/> event.
        ///       Inheriting classes should override this method to handle this event.
        ///       Call base.onMouseDown to send this event to any registered event listeners.
        ///       
        ///    </para>
        /// </devdoc>
        private void OnMouseDown(MouseEventArgs e) {
            MouseEventHandler handler = (MouseEventHandler)Events[EVENT_MOUSEDOWN];
            if (handler != null)
                handler(this,e);
        }

        /// <include file='doc\TrayIcon.uex' path='docs/doc[@for="NotifyIcon.OnMouseMove"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Inheriting classes should override this method to handle this event.
        ///       Call base.onMouseMove to send this event to any registered event listeners.
        ///       
        ///    </para>
        /// </devdoc>
        private void OnMouseMove(MouseEventArgs e) {
            MouseEventHandler handler = (MouseEventHandler)Events[EVENT_MOUSEMOVE];
            if (handler != null)
                handler(this,e);
        }

        /// <include file='doc\TrayIcon.uex' path='docs/doc[@for="NotifyIcon.OnMouseUp"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Inheriting classes should override this method to handle this event.
        ///       Call base.onMouseUp to send this event to any registered event listeners.
        ///       
        ///    </para>
        /// </devdoc>
        private void OnMouseUp(MouseEventArgs e) {
            MouseEventHandler handler = (MouseEventHandler)Events[EVENT_MOUSEUP];
            if (handler != null)
                handler(this,e);
        }

        /// <include file='doc\TrayIcon.uex' path='docs/doc[@for="NotifyIcon.ShowContextMenu"]/*' />
        /// <devdoc>
        ///     Shows the context menu for the tray icon.
        /// </devdoc>
        /// <internalonly/>
        private void ShowContextMenu() {

            if (contextMenu != null) {

                NativeMethods.POINT pt = new NativeMethods.POINT();
                UnsafeNativeMethods.GetCursorPos(pt);

                // VS7 #38994
                // The solution to this problem was found in MSDN Article ID: Q135788.
                // Summary: the current window must be made the foreground window
                // before calling TrackPopupMenuEx, and a task switch must be
                // forced after the call.

                UnsafeNativeMethods.SetForegroundWindow(new HandleRef(window, window.Handle));

                contextMenu.OnPopup( EventArgs.Empty );

                SafeNativeMethods.TrackPopupMenuEx(new HandleRef(contextMenu, contextMenu.Handle),
                                         NativeMethods.TPM_VERTICAL,
                                         pt.x,
                                         pt.y,
                                         new HandleRef(window, window.Handle),
                                         null);

                // Force task switch (see above)
                UnsafeNativeMethods.PostMessage(new HandleRef(window, window.Handle), NativeMethods.WM_NULL, IntPtr.Zero, IntPtr.Zero);
            }
        }

        /// <include file='doc\TrayIcon.uex' path='docs/doc[@for="NotifyIcon.UpdateIcon"]/*' />
        /// <devdoc>
        ///     Updates the icon in the system tray.
        /// </devdoc>
        /// <internalonly/>
        private void UpdateIcon(bool showIconInTray) {
            lock(this) {

                // Bail if in design mode...
                //
                if (DesignMode) {
                    return;
                }

                IntSecurity.UnrestrictedWindows.Demand();

                window.LockReference(showIconInTray);

                NativeMethods.NOTIFYICONDATA data = new NativeMethods.NOTIFYICONDATA();
                data.uCallbackMessage = WM_TRAYMOUSEMESSAGE;
                data.uFlags = NativeMethods.NIF_MESSAGE;
                if (showIconInTray) {
                    if (window.Handle == IntPtr.Zero) {
                        window.CreateHandle(new CreateParams());
                    }
                }
                data.hWnd = window.Handle;
                data.uID = id;
                data.hIcon = IntPtr.Zero;
                data.szTip = null;
                if (icon != null) {
                    data.uFlags |= NativeMethods.NIF_ICON;
                    data.hIcon = icon.Handle;
                }
                data.uFlags |= NativeMethods.NIF_TIP;
                data.szTip = text;

                if (showIconInTray && icon != null) {
                    if (!added) {
                        UnsafeNativeMethods.Shell_NotifyIcon(NativeMethods.NIM_ADD, data);
                        added = true;
                    }
                    else {
                        UnsafeNativeMethods.Shell_NotifyIcon(NativeMethods.NIM_MODIFY, data);
                    }
                }
                else if (added) {
                    UnsafeNativeMethods.Shell_NotifyIcon(NativeMethods.NIM_DELETE, data);
                    added = false;
                }
            }
        }

        /// <include file='doc\TrayIcon.uex' path='docs/doc[@for="NotifyIcon.WmMouseDown"]/*' />
        /// <devdoc>
        ///     Handles the mouse-down event
        /// </devdoc>
        /// <internalonly/>
        private void WmMouseDown(ref Message m, MouseButtons button, int clicks) {
            if (clicks == 2) {
                OnDoubleClick(EventArgs.Empty);
                doubleClick = true;
            }
            OnMouseDown(new MouseEventArgs(button, clicks, 0, 0, 0));
            
        }

        /// <include file='doc\TrayIcon.uex' path='docs/doc[@for="NotifyIcon.WmMouseMove"]/*' />
        /// <devdoc>
        ///     Handles the mouse-move event
        /// </devdoc>
        /// <internalonly/>
        private void WmMouseMove(ref Message m) {
            OnMouseMove(new MouseEventArgs(Control.MouseButtons, 0, 0, 0, 0));
        }

        /// <include file='doc\TrayIcon.uex' path='docs/doc[@for="NotifyIcon.WmMouseUp"]/*' />
        /// <devdoc>
        ///     Handles the mouse-up event
        /// </devdoc>
        /// <internalonly/>
        private void WmMouseUp(ref Message m, MouseButtons button) {
            OnMouseUp(new MouseEventArgs(button, 0, 0, 0, 0));
            //subhag
            if(!doubleClick)
               OnClick(EventArgs.Empty);
            doubleClick = false;
        }

        private void WmTaskbarCreated(ref Message m) {
            added = false;
            UpdateIcon(visible);
        }

        /// <include file='doc\TrayIcon.uex' path='docs/doc[@for="NotifyIcon.WndProc"]/*' />
        /// <devdoc>
        ///     The NotifyIcon's window procedure.  Inheriting classes can override this
        ///     to add extra functionality, but should not forget to call
        ///     base.wndProc(msg); to ensure the NotifyIcon continues to function properly.
        /// </devdoc>
        /// <internalonly/>
        private void WndProc(ref Message msg) {

            switch (msg.Msg) {
                case WM_TRAYMOUSEMESSAGE:
                    switch ((int)msg.LParam) {
                        case NativeMethods.WM_LBUTTONDBLCLK:
                            WmMouseDown(ref msg, MouseButtons.Left, 2);
                            break;
                        case NativeMethods.WM_LBUTTONDOWN:
                            WmMouseDown(ref msg, MouseButtons.Left, 1);
                            break;
                        case NativeMethods.WM_LBUTTONUP:
                            WmMouseUp(ref msg, MouseButtons.Left);
                            break;
                        case NativeMethods.WM_MBUTTONDBLCLK:
                            WmMouseDown(ref msg, MouseButtons.Middle, 2);
                            break;
                        case NativeMethods.WM_MBUTTONDOWN:
                            WmMouseDown(ref msg, MouseButtons.Middle, 1);
                            break;
                        case NativeMethods.WM_MBUTTONUP:
                            WmMouseUp(ref msg, MouseButtons.Middle);
                            break;
                        case NativeMethods.WM_MOUSEMOVE:
                            WmMouseMove(ref msg);
                            break;
                        case NativeMethods.WM_RBUTTONDBLCLK:
                            WmMouseDown(ref msg, MouseButtons.Right, 2);
                            break;
                        case NativeMethods.WM_RBUTTONDOWN:
                            WmMouseDown(ref msg, MouseButtons.Right, 1);
                            break;
                        case NativeMethods.WM_RBUTTONUP:
                            if (contextMenu != null) {
                                ShowContextMenu();
                            }
                            WmMouseUp(ref msg, MouseButtons.Right);
                            break;
                    }
                    break;
                case NativeMethods.WM_COMMAND:
                    if (IntPtr.Zero == msg.LParam) {
                        if (Command.DispatchID((int)msg.WParam & 0xFFFF)) return;
                    }
                    else {
                        window.DefWndProc(ref msg);
                    }
                    break;
                default:
                    if (msg.Msg == WM_TASKBARCREATED) {
                        WmTaskbarCreated(ref msg);
                    }
                    window.DefWndProc(ref msg);
                    break;
            }
        }

        /// <include file='doc\TrayIcon.uex' path='docs/doc[@for="NotifyIcon.NotifyIconNativeWindow"]/*' />
        /// <devdoc>
        ///     Defines a placeholder window that the NotifyIcon is attached to.
        /// </devdoc>
        /// <internalonly/>
        private class NotifyIconNativeWindow : NativeWindow {
            internal NotifyIcon reference;
            private  GCHandle   rootRef;   // We will root the control when we do not want to be elligible for garbage collection.

            /// <include file='doc\TrayIcon.uex' path='docs/doc[@for="NotifyIcon.NotifyIconNativeWindow.NotifyIconNativeWindow"]/*' />
            /// <devdoc>
            ///     Create a new NotifyIcon, and bind the window to the NotifyIcon component.
            /// </devdoc>
            /// <internalonly/>
            internal NotifyIconNativeWindow(NotifyIcon control) {
                reference = control;
            }

            ~NotifyIconNativeWindow() {
                // This same post is done in Control's Dispose method, so if you change
                // it, change it there too.
                //
                if (Handle != IntPtr.Zero) {
                    UnsafeNativeMethods.PostMessage(new HandleRef(this, Handle), NativeMethods.WM_CLOSE, 0, 0);
                }
                
                // This releases the handle from our window proc, re-routing it back to
                // the system.
                //
            }

            public void LockReference(bool locked) {
                if (locked) {
                    if (!rootRef.IsAllocated) {
                        rootRef = GCHandle.Alloc(reference, GCHandleType.Normal);
                    }
                }
                else {
                    if (rootRef.IsAllocated) {
                        rootRef.Free();
                    }
                }
            }

            protected override void OnThreadException(Exception e) {
                Application.OnThreadException(e);
            }

            /// <include file='doc\TrayIcon.uex' path='docs/doc[@for="NotifyIcon.NotifyIconNativeWindow.WndProc"]/*' />
            /// <devdoc>
            ///     Pass messages on to the NotifyIcon object's wndproc handler.
            /// </devdoc>
            /// <internalonly/>
            protected override void WndProc(ref Message m) {
                Debug.Assert(reference != null, "NotifyIcon was garbage collected while it was still visible.  How did we let that happen?");
                reference.WndProc(ref m);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\toolbar.cs ===
//------------------------------------------------------------------------------
// <copyright file="ToolBar.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Security.Permissions;
    using System.Drawing;   
    using System.Windows.Forms;    
    using System.Collections;
    using System.ComponentModel.Design;
    using Microsoft.Win32;

    /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar"]/*' />
    /// <devdoc>
    ///    <para>Represents a Windows toolbar.</para>
    /// </devdoc>
    [
    DefaultEvent("ButtonClick"),
    Designer("System.Windows.Forms.Design.ToolBarDesigner, " + AssemblyRef.SystemDesign),
    DefaultProperty("Buttons")
    ]
    public class ToolBar : Control {

        private ToolBarButtonCollection buttonsCollection;

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.buttonSize"]/*' />
        /// <devdoc>
        ///     The size of a button in the ToolBar
        /// </devdoc>
        internal Size buttonSize = System.Drawing.Size.Empty;

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.requestedSize"]/*' />
        /// <devdoc>
        ///     This is used by our autoSizing support.
        /// </devdoc>
        private int requestedSize;
        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.DDARROW_WIDTH"]/*' />
        /// <devdoc>
        ///     This represents the width of the drop down arrow we have if the
        ///     dropDownArrows property is true.  this value is used by the ToolBarButton
        ///     objects to compute their size
        /// </devdoc>
        internal const int DDARROW_WIDTH = 15;

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.wrappable"]/*' />
        /// <devdoc>
        ///     ToolBar buttons can "wrap" to the next line when the ToolBar becomes
        ///     too narrow to include all buttons on the same line. Wrapping occurs on
        ///     separation and nongroup boundaries. This controls whether this is
        ///     turned on.
        /// </devdoc>
        private bool wrappable = true;

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.appearance"]/*' />
        /// <devdoc>
        ///     Indicates what our appearance will be.  This will either be normal
        ///     or flat.
        /// </devdoc>
        private ToolBarAppearance appearance = ToolBarAppearance.Normal;

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.borderStyle"]/*' />
        /// <devdoc>
        ///     Indicates whether or not we have a border
        /// </devdoc>
        private BorderStyle borderStyle = System.Windows.Forms.BorderStyle.None;

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.buttons"]/*' />
        /// <devdoc>
        ///     The array of buttons we're working with.
        /// </devdoc>
        private ToolBarButton [] buttons;

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.buttonCount"]/*' />
        /// <devdoc>
        ///     The number of buttons we're working with
        /// </devdoc>
        private int buttonCount = 0;

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.dropDownArrows"]/*' />
        /// <devdoc>
        ///     Indicates if dropdown buttons will have little arrows next to them
        ///     when we display them.
        /// </devdoc>
        private bool dropDownArrows = true;

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.textAlign"]/*' />
        /// <devdoc>
        ///     Indicates if text captions should go underneath images in buttons or
        ///     to the right of them
        /// </devdoc>
        private ToolBarTextAlign textAlign = ToolBarTextAlign.Underneath;

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.divider"]/*' />
        /// <devdoc>
        ///     Controls whether we will display a divider at the top of the ToolBar.
        /// </devdoc>
        private bool divider = true;

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.showToolTips"]/*' />
        /// <devdoc>
        ///     Controls whether or not we'll show tooltips for individual buttons
        /// </devdoc>
        private bool showToolTips = true;

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.autoSize"]/*' />
        /// <devdoc>
        ///     Controls whether or not the control will foce it's height based on the
        ///     Image height
        /// </devdoc>
        private bool autoSize = true;

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.imageList"]/*' />
        /// <devdoc>
        ///     The ImageList object that contains the main images for our control.
        /// </devdoc>
        private ImageList imageList = null;
        
        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.maxWidth"]/*' />
        /// <devdoc>
        ///     The maximum width of buttons currently being displayed.  This is needed
        ///     by our autoSizing code.  If this value is -1, it needs to be recomputed.
        /// </devdoc>
        private int maxWidth = -1;

        // event handlers
        //
        private ToolBarButtonClickEventHandler onButtonClick = null;
        private ToolBarButtonClickEventHandler onButtonDropDown = null;


        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.ToolBar"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Windows.Forms.ToolBar'/> class.</para>
        /// </devdoc>
        public ToolBar()
        : base() {
            SetStyle(ControlStyles.UserPaint, false);
            SetStyle(ControlStyles.FixedHeight, autoSize);
            SetStyle(ControlStyles.FixedWidth, false);
            TabStop = false;
            Dock = DockStyle.Top;
            buttonsCollection = new ToolBarButtonCollection(this);
        }

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.Appearance"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the appearance of the toolbar
        ///       control and its buttons.</para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(ToolBarAppearance.Normal),
        Localizable(true),
        SRDescription(SR.ToolBarAppearanceDescr)
        ]
        public ToolBarAppearance Appearance {
            get {
                return appearance;
            }

            set {
                if (!Enum.IsDefined(typeof(ToolBarAppearance), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(ToolBarAppearance));
                }

                if (value != appearance) {
                    appearance = value;
                    RecreateHandle();
                }
            }
        }

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.AutoSize"]/*' />
        /// <devdoc>
        ///    <para> Indicates whether the toolbar
        ///       adjusts its size automatically based on the size of the buttons and the
        ///       dock style.</para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(true),
        Localizable(true),
        SRDescription(SR.ToolBarAutoSizeDescr)
        ]
        public bool AutoSize {
            get {
                return autoSize;
            }

            set {
                if (value != autoSize) {
                    autoSize = value;
                    if (Dock == DockStyle.Left || Dock == DockStyle.Right) {
                        SetStyle(ControlStyles.FixedWidth, autoSize);
                        SetStyle(ControlStyles.FixedHeight, false);
                    }
                    else {
                        SetStyle(ControlStyles.FixedHeight, autoSize);
                        SetStyle(ControlStyles.FixedWidth, false);
                    }
                    AdjustSize(Dock);
                }
            }
        }

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.BackColor"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override Color BackColor {
            get {
                return base.BackColor;
            }
            set {
                base.BackColor = value;
            }
        }

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.BackColorChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler BackColorChanged {
            add {
                base.BackColorChanged += value;
            }
            remove {
                base.BackColorChanged -= value;
            }
        }

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.BackgroundImage"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override Image BackgroundImage {
            get {
                return base.BackgroundImage;
            }
            set {
                base.BackgroundImage = value;
            }
        }

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.BackgroundImageChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler BackgroundImageChanged {
            add {
                base.BackgroundImageChanged += value;
            }
            remove {
                base.BackgroundImageChanged -= value;
            }
        }

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.BorderStyle"]/*' />
        /// <devdoc>
        ///    <para> Gets or sets
        ///       the border style of the toolbar control.</para>
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        DefaultValue(BorderStyle.None),
        DispId(NativeMethods.ActiveX.DISPID_BORDERSTYLE),
        SRDescription(SR.ToolBarBorderStyleDescr)
        ]
        public BorderStyle BorderStyle {
            get {
                return borderStyle;
            }

            set {
                if (!Enum.IsDefined(typeof(BorderStyle), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(BorderStyle));
                }


                if (borderStyle != value) {
                    borderStyle = value;
                    
                    //UpdateStyles();
                    RecreateHandle();   // Looks like we need to recreate the handle to avoid painting glitches
                }
            }
        }

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.Buttons"]/*' />
        /// <devdoc>
        /// <para> A collection of <see cref='System.Windows.Forms.ToolBarButton'/> controls assigned to the 
        ///    toolbar control. The property is read-only.</para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Content),
        Localizable(true),
        SRDescription(SR.ToolBarButtonsDescr),
        MergableProperty(false)
        ]
        public ToolBarButtonCollection Buttons {
            get {
                return buttonsCollection;
            }
        }

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.ButtonSize"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets
        ///       the size of the buttons on the toolbar control.</para>
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        RefreshProperties(RefreshProperties.All),
        Localizable(true),
        SRDescription(SR.ToolBarButtonSizeDescr)
        ]
        public Size ButtonSize {
            get {
                if (buttonSize.IsEmpty) {

                    // Obtain the current buttonsize of the first button from the winctl control
                    //
                    if (IsHandleCreated && buttons != null && buttonCount > 0) {
                        int result = (int)SendMessage(NativeMethods.TB_GETBUTTONSIZE, 0, 0);
                        if (result > 0) {
                            return new Size(NativeMethods.Util.LOWORD(result), NativeMethods.Util.HIWORD(result));                        
                        }
                    }
                    if (TextAlign == ToolBarTextAlign.Underneath) {
                        return new Size(39, 36);    // Default button size                    
                    }
                    else {
                        return new Size(23, 22);    // Default button size                    
                    }
                }
                else {
                    return buttonSize;
                }               
            }

            set {

                if (value.Width < 0 || value.Height < 0)
                    throw new ArgumentException(SR.GetString(SR.InvalidArgument,
                                                              "value",
                                                              value.ToString()));

                if (buttonSize != value) {
                    buttonSize = value;
                    maxWidth = -1; // Force recompute of maxWidth
                    RecreateHandle();
                    AdjustSize(Dock);
                }
            }
        }

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.CreateParams"]/*' />
        /// <devdoc>
        ///     Returns the parameters needed to create the handle.  Inheriting classes
        ///     can override this to provide extra functionality.  They should not,
        ///     however, forget to get base.CreateParams first to get the struct
        ///     filled up with the basic info.
        /// </devdoc>
        /// <internalonly/>
        protected override CreateParams CreateParams {
            [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
            get {
                CreateParams cp = base.CreateParams;
                cp.ClassName = NativeMethods.WC_TOOLBAR;

                // windows forms has it's own docking code.
                //
                cp.Style |= NativeMethods.CCS_NOPARENTALIGN
                            | NativeMethods.CCS_NORESIZE;
                // | NativeMethods.WS_CHILD was commented out since setTopLevel should be able to work.

                if (!divider) cp.Style |= NativeMethods.CCS_NODIVIDER ;
                if (wrappable) cp.Style |= NativeMethods.TBSTYLE_WRAPPABLE;
                if (showToolTips && !DesignMode) cp.Style |= NativeMethods.TBSTYLE_TOOLTIPS;

                cp.ExStyle &= (~NativeMethods.WS_EX_CLIENTEDGE);
                cp.Style &= (~NativeMethods.WS_BORDER);
                switch (borderStyle) {
                    case BorderStyle.Fixed3D:
                        cp.ExStyle |= NativeMethods.WS_EX_CLIENTEDGE;
                        break;
                    case BorderStyle.FixedSingle:
                        cp.Style |= NativeMethods.WS_BORDER;
                        break;
                }

                switch (appearance) {
                    case ToolBarAppearance.Normal:
                        break;
                    case ToolBarAppearance.Flat:
                        cp.Style |= NativeMethods.TBSTYLE_FLAT;
                        break;
                }

                switch (textAlign) {
                    case ToolBarTextAlign.Underneath:
                        break;
                    case ToolBarTextAlign.Right:
                        cp.Style |= NativeMethods.TBSTYLE_LIST;
                        break;
                }

                return cp;
            }
        }
        
        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.DefaultImeMode"]/*' />
        protected override ImeMode DefaultImeMode {
            get {
                return ImeMode.Disable;
            }
        }

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.DefaultSize"]/*' />
        /// <devdoc>
        ///     Deriving classes can override this to configure a default size for their control.
        ///     This is more efficient than setting the size in the control's constructor.
        /// </devdoc>
        protected override Size DefaultSize {
            get {
                return new Size(100, 22);
            }
        }

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.Divider"]/*' />
        /// <devdoc>
        ///    <para> Gets or sets a value indicating
        ///       whether the toolbar displays a divider.</para>
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        DefaultValue(true),
        SRDescription(SR.ToolBarDividerDescr)
        ]
        public bool Divider {
            get {
                return divider;
            }

            set {
                if (divider == value) return;
                divider = value;
                RecreateHandle();
            }
        }

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.Dock"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Sets the way in which this ToolBar is docked to its parent. We need to
        ///       override this to ensure autoSizing works correctly
        ///    </para>
        /// </devdoc>
        [
        Localizable(true),
        DefaultValue(DockStyle.Top)
        ]
        public override DockStyle Dock {
            get { return base.Dock;}

            set {
                if (!Enum.IsDefined(typeof(DockStyle), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(DockStyle));
                }

                if (Dock != value) {
                    if (value == DockStyle.Left || value == DockStyle.Right) {
                        SetStyle(ControlStyles.FixedWidth, autoSize);
                        SetStyle(ControlStyles.FixedHeight, false);
                    }
                    else {
                        SetStyle(ControlStyles.FixedHeight, autoSize);
                        SetStyle(ControlStyles.FixedWidth, false);
                    }
                    AdjustSize(value);
                    base.Dock = value;
                }
            }
        }

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.DropDownArrows"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets a value indicating whether drop-down buttons on a
        ///       toolbar display down arrows.</para>
        /// </devdoc>
        [
        DefaultValue(false),
        SRCategory(SR.CatAppearance),
        Localizable(true),
        SRDescription(SR.ToolBarDropDownArrowsDescr)
        ]
        public bool DropDownArrows {
            get {
                return dropDownArrows;
            }

            set {

                if (dropDownArrows != value) {
                    dropDownArrows = value;
                    RecreateHandle();
                }
            }
        }

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.ForeColor"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override Color ForeColor {
            get {
                return base.ForeColor;
            }
            set {
                base.ForeColor = value;
            }
        }

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.ForeColorChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler ForeColorChanged {
            add {
                base.ForeColorChanged += value;
            }
            remove {
                base.ForeColorChanged -= value;
            }
        }

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.ImageList"]/*' />
        /// <devdoc>
        ///    <para> Gets or sets the collection of images available to the toolbar button
        ///       controls.</para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(null),
        SRDescription(SR.ToolBarImageListDescr)
        ]
        public ImageList ImageList {
            get {
                return this.imageList;
            }
            set {
                if (value != imageList) {
                    EventHandler recreateHandler = new EventHandler(ImageListRecreateHandle);
                    EventHandler disposedHandler = new EventHandler(DetachImageList);

                    if (imageList != null) {
                        imageList.Disposed -= disposedHandler;
                        imageList.RecreateHandle -= recreateHandler;
                    }

                    imageList = value;

                    if (value != null) {
                        value.Disposed += disposedHandler;
                        value.RecreateHandle += recreateHandler;
                    }

                    if (IsHandleCreated)
                        RecreateHandle();
                }
            }
        }

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.ImageSize"]/*' />
        /// <devdoc>
        ///    <para>Gets the size of the images in the image list assigned to the
        ///       toolbar.</para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.ToolBarImageSizeDescr)
        ]
        public Size ImageSize {
            get {
                if (this.imageList != null) {
                    return this.imageList.ImageSize;
                }
                else {
                    return new Size(0, 0);
                }                
            }
        }
        
        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.ImeMode"]/*' />
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public ImeMode ImeMode {
            get {
                return base.ImeMode;
            }
            set {
                base.ImeMode = value;
            }
        }

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.ImeModeChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event EventHandler ImeModeChanged {
            add {
                base.ImeModeChanged += value;
            }
            remove {
                base.ImeModeChanged -= value;
            }
        }

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.PreferredHeight"]/*' />
        /// <devdoc>
        ///     The preferred height for this ToolBar control.  This is
        ///     used by the AutoSizing code.
        /// </devdoc>
        internal int PreferredHeight {
            get {
                int height = 0;

                if (buttons == null || buttonCount == 0 || !IsHandleCreated) {
                    height = ButtonSize.Height;
                }
                else {
                    // get the first visible button and get it's height
                    //
                    NativeMethods.RECT rect = new NativeMethods.RECT();
                    int firstVisible;
    
                    for (firstVisible = 0; firstVisible < buttons.Length; firstVisible++) {
                        if (buttons[firstVisible] != null && buttons[firstVisible].Visible) {
                            break;
                        }
                    }
                    if (firstVisible == buttons.Length) {
                        firstVisible = 0;
                    }
    
                    SendMessage(NativeMethods.TB_GETRECT, firstVisible, ref rect);
    
                    // height is the button's height plus some extra goo
                    //
                    height = rect.bottom - rect.top;
                }

                // if the ToolBar is wrappable, and there is more than one row, make
                // sure the height is correctly adjusted
                //
                if (wrappable && IsHandleCreated) {
                    height = height * (int)SendMessage(NativeMethods.TB_GETROWS, 0, 0);
                }

                height = (height > 0) ? height : 1;
                
                switch(borderStyle) {
                    case BorderStyle.FixedSingle:
                        height += SystemInformation.BorderSize.Height;
                        break;
                    case BorderStyle.Fixed3D:
                        height += SystemInformation.Border3DSize.Height;
                        break;
                }

                if (divider) height += 2;

                height += 4;
                
                return height;
            }

        }

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.PreferredWidth"]/*' />
        /// <devdoc>
        ///     The preferred width for this ToolBar control.  This is
        ///     used by AutoSizing code.
        ///     NOTE!!!!!!!!! This function assumes it's only going to get called
        ///     if the control is docked left or right [ie, it really
        ///     just returns a max width]
        /// </devdoc>
        internal int PreferredWidth {
            get {
                int width;

                // fortunately, we compute this value sometimes, so we can just
                // use it if we have it.
                //
                if (maxWidth == -1) {
                    // don't have it, have to recompute
                    //
                    if (buttons == null)
                        maxWidth = ButtonSize.Width;
                    else {

                        NativeMethods.RECT rect = new NativeMethods.RECT();

                        for (int x = 0; x < buttonCount; x++) {
                            SendMessage(NativeMethods.TB_GETRECT, 0, ref rect);
                            if ((rect.right - rect.left) > maxWidth)
                                maxWidth = rect.right - rect.left;
                        }
                    }
                }

                width = maxWidth;

                if (borderStyle != BorderStyle.None) {
                    width += SystemInformation.BorderSize.Height * 4 + 3;
                }
                
                return width;
            }
        }

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.RightToLeft"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override RightToLeft RightToLeft {
            get {
                return base.RightToLeft;
            }
            set {
                base.RightToLeft = value;
            }
        }

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.RightToLeftChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event EventHandler RightToLeftChanged {
            add {
                base.RightToLeftChanged += value;
            }
            remove {
                base.RightToLeftChanged -= value;
            }
        }

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.ShowToolTips"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Gets or sets a value indicating whether the toolbar displays a
        ///       tool tip for each button.</para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(false),
        Localizable(true),
        SRDescription(SR.ToolBarShowToolTipsDescr)
        ]
        public bool ShowToolTips {
            get {
                return showToolTips;
            }
            set {
                if (value != showToolTips) {
                    showToolTips = value;
                    RecreateHandle();
                }
            }
        }

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.TabStop"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        [DefaultValue(false)]
        new public bool TabStop {
            get {
                return base.TabStop;
            }
            set {
                base.TabStop = value;
            }
        }

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.Text"]/*' />
        /// <internalonly/>        
        /// <devdoc>
        /// </devdoc>
        [
        Browsable(false), EditorBrowsable(EditorBrowsableState.Never), 
        Bindable(false), 
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]                
        public override string Text {
            get {
                return base.Text;
            }
            set {
                base.Text = value;
            }
        }

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.TextChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler TextChanged {
            add {
                base.TextChanged += value;
            }
            remove {
                base.TextChanged -= value;
            }
        }
        
        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.TextAlign"]/*' />
        /// <devdoc>
        ///    <para> Gets or sets the alignment of text in relation to each
        ///       image displayed on
        ///       the toolbar button controls.</para>
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        DefaultValue(ToolBarTextAlign.Underneath),
        Localizable(true),
        SRDescription(SR.ToolBarTextAlignDescr)
        ]
        public ToolBarTextAlign TextAlign {
            get {
                return textAlign;
            }
            set {
                if (!Enum.IsDefined(typeof(ToolBarTextAlign), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(ToolBarTextAlign));
                }

                if (textAlign == value) return;
                textAlign = value;
                RecreateHandle();
            }
        }

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.Wrappable"]/*' />
        /// <devdoc>
        ///    <para> Gets
        ///       or sets a value
        ///       indicating whether the toolbar buttons wrap to the next line if the
        ///       toolbar becomes too small to display all the buttons
        ///       on the same line.</para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(true),
        Localizable(true),
        SRDescription(SR.ToolBarWrappableDescr)
        ]
        public bool Wrappable {
            get {
                return wrappable;
            }
            set {
                wrappable = value;
                RecreateHandle();
            }
        }

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.ButtonClick"]/*' />
        /// <devdoc>
        /// <para>Occurs when a <see cref='System.Windows.Forms.ToolBarButton'/> on the <see cref='System.Windows.Forms.ToolBar'/> is clicked.</para>
        /// </devdoc>
        [SRCategory(SR.CatBehavior), SRDescription(SR.ToolBarButtonClickDescr)]
        public event ToolBarButtonClickEventHandler ButtonClick {
            add {
                onButtonClick += value;
            }
            remove {
                onButtonClick -= value;
            }
        }

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.ButtonDropDown"]/*' />
        /// <devdoc>
        /// <para>Occurs when a drop-down style <see cref='System.Windows.Forms.ToolBarButton'/> or its down arrow is clicked.</para>
        /// </devdoc>
        [SRCategory(SR.CatBehavior), SRDescription(SR.ToolBarButtonDropDownDescr)]
        public event ToolBarButtonClickEventHandler ButtonDropDown {
            add {
                onButtonDropDown += value;
            }
            remove {
                onButtonDropDown -= value;
            }
        }

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.OnPaint"]/*' />
        /// <devdoc>
        ///     ToolBar Onpaint.
        /// </devdoc>
        /// <internalonly/><hideinheritance/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event PaintEventHandler Paint {
            add {
                base.Paint += value;
            }
            remove {
                base.Paint -= value;
            }
        }

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.AdjustSize"]/*' />
        /// <devdoc>
        ///     Adjusts the height or width of the ToolBar to make sure we have enough
        ///     room to show the buttons.
        /// </devdoc>
        /// <internalonly/>
        // VS 30082 -- we pass in a value for dock rather than calling Dock ourselves
        // because we can't change Dock until the size has been properly adjusted.
        private void AdjustSize(DockStyle dock) {
            int saveSize = requestedSize;
            try {
                if (dock == DockStyle.Left || dock == DockStyle.Right) {
                    Width = autoSize ? PreferredWidth : saveSize;
                }
                else {
                    Height = autoSize ? PreferredHeight : saveSize;
                }
            }
            finally {
                requestedSize = saveSize;
            }
        }

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.BeginUpdate"]/*' />
        /// <devdoc>
        ///     This routine lets us change a bunch of things about the toolbar without
        ///     having each operation wait for the paint to complete.  This must be
        ///     matched up with a call to endUpdate().
        /// </devdoc>
        internal void BeginUpdate() {
            BeginUpdateInternal();
        }

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.CreateHandle"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        protected override void CreateHandle() {
            if (!RecreatingHandle) {
                NativeMethods.INITCOMMONCONTROLSEX icc = new NativeMethods.INITCOMMONCONTROLSEX();
                icc.dwICC = NativeMethods.ICC_BAR_CLASSES;
                SafeNativeMethods.InitCommonControlsEx(icc);
            }
            base.CreateHandle();
        }

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.DetachImageList"]/*' />
        /// <devdoc>
        ///     Resets the imageList to null.  We wire this method up to the imageList's
        ///     Dispose event, so that we don't hang onto an imageList that's gone away.
        /// </devdoc>
        private void DetachImageList(object sender, EventArgs e) {
            ImageList = null;
        }

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.Dispose"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        protected override void Dispose(bool disposing) {
            if (disposing) {
                lock(this) {
                    if (imageList != null) {
                        imageList.Disposed -= new EventHandler(DetachImageList);
                        imageList = null;
                    }

                    if (buttonsCollection != null) {
                        ToolBarButton[] buttonCopy = new ToolBarButton[buttonsCollection.Count];
                        ((ICollection)buttonsCollection).CopyTo(buttonCopy, 0);
                        buttonsCollection.Clear();

                        foreach(ToolBarButton b in buttonCopy) {
                            b.Dispose();
                        }
                    }
                }
            }

            base.Dispose(disposing);
        }

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.EndUpdate"]/*' />
        /// <devdoc>
        ///     This routine lets us change a bunch of things about the toolbar without
        ///     having each operation wait for the paint to complete.  This must be
        ///     matched up with a call to beginUpdate().
        /// </devdoc>
        internal void EndUpdate() {
            EndUpdateInternal();
        }

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.ForceButtonWidths"]/*' />
        /// <devdoc>
        ///     Forces the button sizes based on various different things.  The default
        ///     ToolBar button sizing rules are pretty primitive and this tends to be
        ///     a little better, and lets us actually show things like DropDown Arrows
        ///     for ToolBars
        /// </devdoc>
        /// <internalonly/>
        private void ForceButtonWidths() {
            
            if (buttons != null && buttonSize.IsEmpty && IsHandleCreated) {

                // force ourselves to re-compute this each time
                //
                maxWidth = -1;

                for (int x = 0; x < buttonCount; x++) {

                    NativeMethods.TBBUTTONINFO tbbi = new NativeMethods.TBBUTTONINFO();
                    tbbi.cbSize = Marshal.SizeOf(typeof(NativeMethods.TBBUTTONINFO));
                    tbbi.cx = buttons[x].Width;

                    if (tbbi.cx > maxWidth) {
                        maxWidth = tbbi.cx;
                    }
                    
                    tbbi.dwMask = NativeMethods.TBIF_SIZE;
                    UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.TB_SETBUTTONINFO, x, ref tbbi);
                }
            }
        }

        private void ImageListRecreateHandle(object sender, EventArgs e) {
            if (IsHandleCreated)
                RecreateHandle();
        }

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.Insert"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        private void Insert(int index, ToolBarButton button) {

            button.parent = this;

            if (buttons == null) {
                buttons = new ToolBarButton[4];
            }
            else if (buttons.Length == buttonCount) {
                ToolBarButton[] newButtons = new ToolBarButton[buttonCount + 4];
                System.Array.Copy(buttons, 0, newButtons, 0, buttonCount);
                buttons = newButtons;
            }

            if (index < buttonCount)
                System.Array.Copy(buttons, index, buttons, index + 1, buttonCount - index);

            buttons[index] = button;
            buttonCount++;
        }

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.InsertButton"]/*' />
        /// <devdoc>
        ///    <para>Inserts a button at a given location on the toolbar control.</para>
        /// </devdoc>
        private void InsertButton(int index, ToolBarButton value) {

            if (value == null)
                throw new ArgumentNullException(SR.GetString(SR.InvalidArgument,
                                                          "value",
                                                          value.ToString()));
            if (index < 0 || ((buttons != null) && (index > buttonCount)))
                throw new ArgumentOutOfRangeException(SR.GetString(SR.InvalidArgument,
                                                          "index",
                                                          index.ToString()));

            // insert the button into our local array, and then into the
            // real windows ToolBar control
            //
            Insert(index, value);
            if (IsHandleCreated) {
                NativeMethods.TBBUTTON tbbutton = value.GetTBBUTTON();
                UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.TB_INSERTBUTTON, index, ref tbbutton);
            }
            UpdateButtons();
        }

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.InternalAddButton"]/*' />
        /// <devdoc>
        ///     Adds a button to the ToolBar
        /// </devdoc>
        /// <internalonly/>
        private int InternalAddButton(ToolBarButton button) {
            if (button == null)
                throw new ArgumentNullException(SR.GetString(SR.InvalidNullArgument, "button"));
            int index = buttonCount;
            Insert(index, button);
            return index;
        }

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.InternalSetButton"]/*' />
        /// <devdoc>
        ///     Changes the data for a button in the ToolBar, and then does the appropriate
        ///     work to update the ToolBar control.
        /// </devdoc>
        /// <internalonly/>
        internal void InternalSetButton(int index, ToolBarButton value, bool recreate, bool updateText) {

            // tragically, there doesn't appear to be a way to remove the
            // string for the button if it has one, so we just have to leave
            // it in there.
            //
            buttons[index].parent = null;
            buttons[index].stringIndex = -1;
            buttons[index] = value;
            buttons[index].parent = this;

            if (IsHandleCreated) {
                NativeMethods.TBBUTTONINFO tbbi = value.GetTBBUTTONINFO(updateText);
                tbbi.idCommand = index;
                UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.TB_SETBUTTONINFO, index, ref tbbi);
                
                if (tbbi.pszText != IntPtr.Zero) {
                    Marshal.FreeHGlobal(tbbi.pszText);
                }

                if (recreate) {
                    UpdateButtons();
                }
                else {
                    // after doing anything with the comctl ToolBar control, this
                    // appears to be a good idea.
                    //
                    SendMessage(NativeMethods.TB_AUTOSIZE, 0, 0);
                    
                    ForceButtonWidths();
                    this.Invalidate();
                }
            }
        }

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.OnButtonClick"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Windows.Forms.ToolBar.ButtonClick'/> 
        /// event.</para>
        /// </devdoc>
        protected virtual void OnButtonClick(ToolBarButtonClickEventArgs e) {
            if (onButtonClick != null) onButtonClick(this, e);
        }

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.OnButtonDropDown"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Windows.Forms.ToolBar.ButtonDropDown'/> 
        /// event.</para>
        /// </devdoc>
        protected virtual void OnButtonDropDown(ToolBarButtonClickEventArgs e) {
            if (onButtonDropDown != null) onButtonDropDown(this, e);
        }

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.OnHandleCreated"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Overridden from the control class so we can add all the buttons
        ///       and do whatever work needs to be done.
        ///       Don't forget to call base.OnHandleCreated.
        ///    </para>
        /// </devdoc>
        protected override void OnHandleCreated(EventArgs e) {
            base.OnHandleCreated(e);

            // we have to set the button struct size, because they don't.
            //
            SendMessage(NativeMethods.TB_BUTTONSTRUCTSIZE, Marshal.SizeOf(typeof(NativeMethods.TBBUTTON)), 0);

            // set up some extra goo
            //
            if (dropDownArrows)
                SendMessage(NativeMethods.TB_SETEXTENDEDSTYLE, 0, NativeMethods.TBSTYLE_EX_DRAWDDARROWS);

            // if we have an imagelist, add it in now.
            //
            if (imageList != null)
                SendMessage(NativeMethods.TB_SETIMAGELIST, 0, imageList.Handle);

            RealizeButtons();

            // Force a repaint, as occasionally the ToolBar border does not paint properly
            // (comctl ToolBar is flaky)
            //                
            BeginUpdate();
            try {
                Size size = Size;
                Size = new Size(size.Width + 1, size.Height);
                Size = size;
            }
            finally {
                EndUpdate();
            }
        }

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.OnResize"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       The control is being resized. Make sure the width/height are correct.
        ///    </para>
        /// </devdoc>
        protected override void OnResize(EventArgs e) {
            base.OnResize(e);
            if (wrappable) AdjustSize(Dock);
        }

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.OnFontChanged"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Overridden to ensure that the buttons and the control resize properly
        ///       whenever the font changes.
        ///    </para>
        /// </devdoc>
        protected override void OnFontChanged(EventArgs e) {
            base.OnFontChanged(e);

            if (!buttonSize.IsEmpty) {
                SendMessage(NativeMethods.TB_SETBUTTONSIZE, 0, NativeMethods.Util.MAKELPARAM(buttonSize.Width, buttonSize.Height));
            }
            else {
                AdjustSize(Dock);
                ForceButtonWidths();
            }
        }

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.RealizeButtons"]/*' />
        /// <devdoc>
        ///     Sets all the button data into the ToolBar control
        /// </devdoc>
        /// <internalonly/>
        private void RealizeButtons() {
            if (buttons != null) {

                try {
                    BeginUpdate();
                    //  go and add in all the strings for all of our buttons
                    //
                    for (int x = 0; x < buttonCount; x++) {
                        if (buttons[x].Text.Length > 0) {
                            string addString = buttons[x].Text + '\0'.ToString();
                            buttons[x].stringIndex = (int)SendMessage(NativeMethods.TB_ADDSTRING, 0, addString);
                        }
                        else {
                            buttons[x].stringIndex = -1;
                        }
                    }
    
                    // insert the buttons and set their parent pointers
                    //
                    IntPtr ptbbuttons = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(NativeMethods.TBBUTTON)) * buttonCount);
    
                    for (int x = 0; x < buttonCount; x++) {
    
                        NativeMethods.TBBUTTON tbbutton = buttons[x].GetTBBUTTON();
                        tbbutton.idCommand = x;
    
                        int cb = Marshal.SizeOf(typeof(NativeMethods.TBBUTTON));
                        Marshal.StructureToPtr(tbbutton, (IntPtr)((long)ptbbuttons + (cb * x)), true);
                        buttons[x].parent = this;
                    }
    
                    SendMessage(NativeMethods.TB_ADDBUTTONS, buttonCount, ptbbuttons);
                    Marshal.FreeHGlobal(ptbbuttons);
    
                    // after doing anything with the comctl ToolBar control, this
                    // appears to be a good idea.
                    //
                    SendMessage(NativeMethods.TB_AUTOSIZE, 0, 0);
    
                    // The win32 ToolBar control is somewhat unpredictable here. We
                    // have to set the button size after we've created all the
                    // buttons.  Otherwise, we need to manually set the width of all
                    // the buttons so they look reasonable
                    //
                    if (!buttonSize.IsEmpty) {
                        SendMessage(NativeMethods.TB_SETBUTTONSIZE, 0, NativeMethods.Util.MAKELPARAM(buttonSize.Width, buttonSize.Height));
                    }
                    else {
                        ForceButtonWidths();
                    }
                    AdjustSize(Dock);
                }
                finally {
                    EndUpdate();
                }
            }
        }

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.RemoveAt"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        private void RemoveAt(int index) {
            buttons[index].parent = null;
            buttons[index].stringIndex = -1;
            buttonCount--;

            if (index < buttonCount)
                System.Array.Copy(buttons, index + 1, buttons, index, buttonCount - index);

            buttons[buttonCount] = null;
        }

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.ResetButtonSize"]/*' />
        /// <devdoc>
        ///    <para> Resets the toolbar buttons to the minimum 
        ///       size. </para>
        /// </devdoc>
        private void ResetButtonSize() {
            buttonSize = Size.Empty;
            RecreateHandle();            
        }

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.SetBoundsCore"]/*' />
        /// <devdoc>
        ///     Overrides Control.setBoundsCore to enforce autoSize.
        /// </devdoc>
        /// <internalonly/>
        protected override void SetBoundsCore(int x, int y, int width, int height, BoundsSpecified specified) {
            int originalHeight = height;
            int originalWidth = width;

            base.SetBoundsCore(x, y, width, height, specified);
                        
            Rectangle bounds = Bounds;
            if (Dock == DockStyle.Left || Dock == DockStyle.Right) {
                if ((specified & BoundsSpecified.Width) != BoundsSpecified.None) requestedSize = width;
                if (autoSize) width = PreferredWidth;
                
                if (width != originalWidth && Dock == DockStyle.Right) {
                    int deltaWidth =  originalWidth - width;
                    x += deltaWidth;
                }
                
            }
            else {
                if ((specified & BoundsSpecified.Height) != BoundsSpecified.None) requestedSize = height;
                if (autoSize) height = PreferredHeight;
                
                if (height != originalHeight && Dock == DockStyle.Bottom) {
                    int deltaHeight =  originalHeight - height;
                    y += deltaHeight;
                }
                
            }

            base.SetBoundsCore(x, y, width, height, specified);
        }

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.ShouldSerializeButtonSize"]/*' />
        /// <devdoc>
        /// <para>Determines if the <see cref='System.Windows.Forms.ToolBar.ButtonSize'/> property needs to be persisted.</para>
        /// </devdoc>
        private bool ShouldSerializeButtonSize() {
            return !buttonSize.IsEmpty;
        }

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.ToString"]/*' />
        /// <devdoc>
        ///     Returns a string representation for this control.
        /// </devdoc>
        /// <internalonly/>
        public override string ToString() {

            string s = base.ToString();
            s += ", Buttons.Count: " + buttonCount.ToString();
            if (buttonCount > 0)
                s += ", Buttons[0]: " + buttons[0].ToString();
            return s;
        }

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.UpdateButtons"]/*' />
        /// <devdoc>
        ///     Updates all the information in the ToolBar.  Tragically, the win32
        ///     control is pretty flakey, and the only real choice here is to recreate
        ///     the handle and re-realize all the buttons.  Very lame.
        /// </devdoc>
        /// <internalonly/>
        internal void UpdateButtons() {
            if (IsHandleCreated) {
                RecreateHandle();                
            }
        }

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.WmNotifyDropDown"]/*' />
        /// <devdoc>
        ///     The button clicked was a dropdown button.  If it has a menu specified,
        ///     show it now.  Otherwise, fire an onButtonDropDown event.
        /// </devdoc>
        /// <internalonly/>
        private void WmNotifyDropDown(ref Message m) {
            NativeMethods.NMTOOLBAR nmTB = (NativeMethods.NMTOOLBAR)m.GetLParam(typeof(NativeMethods.NMTOOLBAR));

            ToolBarButton tbb = (ToolBarButton)buttons[nmTB.iItem];
            if (tbb == null)
                throw new InvalidOperationException(SR.GetString(SR.ToolBarButtonNotFound));

            OnButtonDropDown(new ToolBarButtonClickEventArgs(tbb));
            
            Menu menu = tbb.DropDownMenu;
            if (menu != null) {
                NativeMethods.RECT rc = new NativeMethods.RECT();
                NativeMethods.TPMPARAMS tpm = new NativeMethods.TPMPARAMS();

                SendMessage(NativeMethods.TB_GETRECT, nmTB.iItem, ref rc);

                if ((menu.GetType()).IsAssignableFrom(typeof(ContextMenu))) {
                    ((ContextMenu)menu).Show(this, new Point(rc.left, rc.bottom));
                }
                else {
                    Menu main = menu.GetMainMenu();
                    if (main != null) {
                        main.ProcessInitMenuPopup(menu.Handle);
                    }

                    UnsafeNativeMethods.MapWindowPoints(new HandleRef(nmTB.hdr, nmTB.hdr.hwndFrom), NativeMethods.NullHandleRef, ref rc, 2);

                    tpm.rcExclude_left = rc.left;
                    tpm.rcExclude_top = rc.top;
                    tpm.rcExclude_right = rc.right;
                    tpm.rcExclude_bottom = rc.bottom;

                    SafeNativeMethods.TrackPopupMenuEx(
                                                  new HandleRef(menu, menu.Handle),
                                                  NativeMethods.TPM_LEFTALIGN |
                                                  NativeMethods.TPM_LEFTBUTTON |
                                                  NativeMethods.TPM_VERTICAL,
                                                  rc.left, rc.bottom,
                                                  new HandleRef(this, Handle), tpm);
                }
            }            
        }

        private void WmNotifyNeedText(ref Message m) {
            NativeMethods.TOOLTIPTEXT ttt = (NativeMethods.TOOLTIPTEXT) m.GetLParam(typeof(NativeMethods.TOOLTIPTEXT));
            int commandID = ttt.hdr.idFrom;
            ToolBarButton tbb = (ToolBarButton) buttons[commandID];

            if (tbb != null && tbb.ToolTipText != null)
                ttt.szText = tbb.ToolTipText;
            else
                ttt.szText = null;

            ttt.hinst = IntPtr.Zero;
            
            // RightToLeft reading order
            //
            if (RightToLeft == RightToLeft.Yes) {
                ttt.uFlags |= NativeMethods.TTF_RTLREADING;
            }
            
            Marshal.StructureToPtr(ttt, m.LParam, true);
        }
        
        private void WmNotifyNeedTextA(ref Message m) {
        
            NativeMethods.TOOLTIPTEXTA ttt = (NativeMethods.TOOLTIPTEXTA) m.GetLParam(typeof(NativeMethods.TOOLTIPTEXTA));
            int commandID = ttt.hdr.idFrom;
            ToolBarButton tbb = (ToolBarButton) buttons[commandID];

            if (tbb != null && tbb.ToolTipText != null)
                ttt.szText = tbb.ToolTipText;
            else
                ttt.szText = null;

            ttt.hinst = IntPtr.Zero;
            
            // RightToLeft reading order
            //
            if (RightToLeft == RightToLeft.Yes) {
                ttt.uFlags |= NativeMethods.TTF_RTLREADING;
            }
            
            Marshal.StructureToPtr(ttt, m.LParam, true);
        }


        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.WmReflectCommand"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        private void WmReflectCommand(ref Message m) {

            int id = (int)m.WParam & 0xFFFF;
            ToolBarButton tbb = buttons[id];

            if (tbb != null) {
                ToolBarButtonClickEventArgs e = new ToolBarButtonClickEventArgs(tbb);
                OnButtonClick(e);
            }
            
            base.WndProc(ref m);

            ResetMouseEventArgs();
        }

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.WndProc"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        protected override void WndProc(ref Message m) {
            switch (m.Msg) {
                case NativeMethods.WM_COMMAND + NativeMethods.WM_REFLECT:
                    WmReflectCommand(ref m);
                    break;

                case NativeMethods.WM_NOTIFY:
                case NativeMethods.WM_NOTIFY + NativeMethods.WM_REFLECT:
                    NativeMethods.NMHDR note = (NativeMethods.NMHDR) m.GetLParam(typeof(NativeMethods.NMHDR));
                    switch (note.code) {
                        case NativeMethods.TTN_NEEDTEXTA:
                            WmNotifyNeedTextA(ref m);
                            m.Result = (IntPtr)1;
                            return;

                        case NativeMethods.TTN_NEEDTEXTW:
                            // On Win 98/IE 5,we still get W messages.  If we ignore them, it will send the A version.
                            if (Marshal.SystemDefaultCharSize == 2) {
                                WmNotifyNeedText(ref m);
                                m.Result = (IntPtr)1;
                                return;
                            }
                            break;

                        case NativeMethods.TBN_QUERYINSERT:
                            m.Result = (IntPtr)1;
                            break;

                        case NativeMethods.TBN_DROPDOWN:
                            WmNotifyDropDown(ref m);
                            break;
                    }
                    break;

            }
            base.WndProc(ref m);
        }

        /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.ToolBarButtonCollection"]/*' />
        /// <devdoc>
        /// <para>Encapsulates a collection of <see cref='System.Windows.Forms.ToolBarButton'/> controls for use by the
        /// <see cref='System.Windows.Forms.ToolBar'/> class. </para>
        /// </devdoc>
        public class ToolBarButtonCollection : IList {

            private ToolBar owner;
            private bool    suspendUpdate;

            /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.ToolBarButtonCollection.ToolBarButtonCollection"]/*' />
            /// <devdoc>
            /// <para>Initializes a new instance of the <see cref='System.Windows.Forms.ToolBar.ToolBarButtonCollection'/> class and assigns it to the specified toolbar.</para>
            /// </devdoc>
            public ToolBarButtonCollection(ToolBar owner) {
                this.owner = owner;
            }
            
            /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.ToolBarButtonCollection.this"]/*' />
            /// <devdoc>
            ///    <para>Gets or sets the toolbar button at the specified indexed location in the
            ///       toolbar button collection.</para>
            /// </devdoc>
            public virtual ToolBarButton this[int index] {
                get {
                    if (index < 0 || ((owner.buttons != null) && (index >= owner.buttonCount)))
                        throw new ArgumentOutOfRangeException(SR.GetString(SR.InvalidArgument,
                                                                  "index",
                                                                  index.ToString()));
                    return owner.buttons[index];
                }
                set {

                    // Sanity check parameters
                    //
                    if (index < 0 || ((owner.buttons != null) && index >= owner.buttonCount)) {
                        throw new ArgumentOutOfRangeException(SR.GetString(SR.InvalidArgument, "index", index.ToString()));
                    }
                    if (value == null) {
                        throw new ArgumentNullException(SR.GetString(SR.InvalidNullArgument, "value"));
                    }

                    owner.InternalSetButton(index, value, true, true);
                }
            }
            
            /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBarButtonCollection.IList.this"]/*' />
            /// <internalonly/>
            object IList.this[int index] {
                get {
                    return this[index];
                }
                set {
                    if (value is ToolBarButton) {
                        this[index] = (ToolBarButton)value;
                    }
                    else {  
                        throw new ArgumentException("value");
                    }
                }
            }

            /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.ToolBarButtonCollection.Count"]/*' />
            /// <devdoc>
            ///    <para> Gets the number of buttons in the toolbar button collection.</para>
            /// </devdoc>
            [Browsable(false)]
            public int Count {
                get {
                    return owner.buttonCount;
                }
            }

            /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBarButtonCollection.ICollection.SyncRoot"]/*' />
            /// <internalonly/>
            object ICollection.SyncRoot {
                get {
                    return this;
                }
            }

            /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBarButtonCollection.ICollection.IsSynchronized"]/*' />
            /// <internalonly/>
            bool ICollection.IsSynchronized {
                get {
                    return false;
                }
            }
            
            /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBarButtonCollection.IList.IsFixedSize"]/*' />
            /// <internalonly/>
            bool IList.IsFixedSize {
                get {   
                    return false;
                }
            }
            
            /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.ToolBarButtonCollection.IsReadOnly"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public bool IsReadOnly {
                get {
                    return false;
                }
            }

            /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.ToolBarButtonCollection.Add"]/*' />
            /// <devdoc>
            ///    <para>Adds a new toolbar button to
            ///       the end of the toolbar button collection.</para>
            /// </devdoc>
            public int Add(ToolBarButton button) {

                int index = owner.InternalAddButton(button);

                if (!suspendUpdate) {
                    owner.UpdateButtons();
                }
                
                return index;
            }
            
            /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.ToolBarButtonCollection.Add1"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public int Add(string text) {
                ToolBarButton button = new ToolBarButton(text);
                return Add(button);
            }
            
            /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBarButtonCollection.IList.Add"]/*' />
            /// <internalonly/>
            int IList.Add(object button) {
                if (button is ToolBarButton) {
                    return Add((ToolBarButton)button);
                }
                else {
                    throw new ArgumentException("button");
                }
            }

            /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.ToolBarButtonCollection.AddRange"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public void AddRange(ToolBarButton[] buttons) {
                if (buttons == null) {
                    throw new ArgumentNullException("buttons");
                }
                try {
                    suspendUpdate = true;
                    foreach(ToolBarButton button in buttons) {
                        Add(button);
                    }
                }
                finally {
                    suspendUpdate = false;
                    owner.UpdateButtons();
                }
            }                       


            /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.ToolBarButtonCollection.Clear"]/*' />
            /// <devdoc>
            ///    <para>Removes
            ///       all buttons from the toolbar button collection.</para>
            /// </devdoc>
            public void Clear() {

                if (owner.buttons == null) {
                    return;
                }

                for (int x = owner.buttonCount; x > 0; x--) {
                    if (owner.IsHandleCreated) {
                        owner.SendMessage(NativeMethods.TB_DELETEBUTTON, x - 1, 0);
                    }
                    owner.RemoveAt(x - 1);
                }

                owner.buttons = null;
                owner.buttonCount = 0;

                owner.UpdateButtons();
            }
            
            /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.ToolBarButtonCollection.Contains"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public bool Contains(ToolBarButton button) {
                return IndexOf(button) != -1;
            }
            
            /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBarButtonCollection.IList.Contains"]/*' />
            /// <internalonly/>
            bool IList.Contains(object button) {
                if (button is ToolBarButton) {
                    return Contains((ToolBarButton)button);
                }
                else {
                    return false;
                }
            }

            /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBarButtonCollection.ICollection.CopyTo"]/*' />
            /// <internalonly/>
            void ICollection.CopyTo(Array dest, int index) {
                if (owner.buttonCount > 0) {
                    System.Array.Copy(owner.buttons, 0, dest, index, owner.buttonCount);
                }
            }
            
            /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.ToolBarButtonCollection.IndexOf"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public int IndexOf(ToolBarButton button) {
                for(int index=0; index < Count; ++index) {
                    if (this[index] == button) {
                        return index;
                    }
                }
                return -1;
            }
            
            /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBarButtonCollection.IList.IndexOf"]/*' />
            /// <internalonly/>
            int IList.IndexOf(object button) {
                if (button is ToolBarButton) {
                    return IndexOf((ToolBarButton)button);
                }
                else {
                    return -1;
                }
            }
            
            /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.ToolBarButtonCollection.Insert"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public void Insert(int index, ToolBarButton button) {
                owner.InsertButton(index, button);
            }
            
            /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBarButtonCollection.IList.Insert"]/*' />
            /// <internalonly/>
            void IList.Insert(int index, object button) {
                if (button is ToolBarButton) {
                    Insert(index, (ToolBarButton)button);
                }
                else {
                    throw new ArgumentException("button");
                }
            }

            /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.ToolBarButtonCollection.RemoveAt"]/*' />
            /// <devdoc>
            ///    <para>Removes
            ///       a given button from the toolbar button collection.</para>
            /// </devdoc>
            public void RemoveAt(int index) {
                int count = (owner.buttons == null) ? 0 : owner.buttonCount;

                if (index < 0 || index >= count)
                    throw new ArgumentOutOfRangeException(SR.GetString(SR.InvalidArgument,
                                                              "index",
                                                              index.ToString()));

                if (owner.IsHandleCreated) {
                    owner.SendMessage(NativeMethods.TB_DELETEBUTTON, index, 0);
                }

                owner.RemoveAt(index);
                owner.UpdateButtons();

            }
            
            /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.ToolBarButtonCollection.Remove"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public void Remove(ToolBarButton button) {
                int index = IndexOf(button);
                if (index != -1) {
                    RemoveAt(index);
                }                
            }
            
            /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBarButtonCollection.IList.Remove"]/*' />
            /// <internalonly/>
            void IList.Remove(object button) {
                if (button is ToolBarButton) {
                    Remove((ToolBarButton)button);
                }                
            }

            /// <include file='doc\ToolBar.uex' path='docs/doc[@for="ToolBar.ToolBarButtonCollection.GetEnumerator"]/*' />
            /// <devdoc>
            ///    <para>Returns an enumerator that can be used to iterate
            ///       through the toolbar button collection.</para>
            /// </devdoc>
            public IEnumerator GetEnumerator() {
                return new WindowsFormsUtils.ArraySubsetEnumerator(owner.buttons, owner.buttonCount);
            }
        }
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\tooltip.cs ===
//------------------------------------------------------------------------------
// <copyright file="ToolTip.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {
    using System.Runtime.Serialization.Formatters;
    using System.Threading;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;
    using Hashtable = System.Collections.Hashtable;
    using System.Drawing;
    using Microsoft.Win32;


    /// <include file='doc\ToolTip.uex' path='docs/doc[@for="ToolTip"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides a small pop-up window containing a line of text
    ///       that describes the purpose of a tool or control (usually represented as a
    ///       graphical
    ///       object) in a program.
    ///    </para>
    /// </devdoc>
    [
    ProvideProperty("ToolTip", typeof(Control)),
    ToolboxItemFilter("System.Windows.Forms")
    ]
    public sealed class ToolTip : Component, IExtenderProvider {

        const int DEFAULT_DELAY = 500;
        const int RESHOW_RATIO = 5;
        const int AUTOPOP_RATIO = 10;

        Hashtable           tools = new Hashtable();
        int[]               delayTimes = new int[4];
        bool                auto = true;        
        bool                showAlways = false;
        ToolTipNativeWindow window = null;
        Control             topLevelControl = null;
        bool                active = true;

        // Adding a tool twice screws up the ToolTip, so we need to track which
        // tools are created to prevent this...
        //
        Hashtable           created = new Hashtable();

        /// <include file='doc\ToolTip.uex' path='docs/doc[@for="ToolTip.ToolTip"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Windows.Forms.ToolTip'/> class, given the container.
        ///    </para>
        /// </devdoc>
        public ToolTip(IContainer cont) : this() {
            cont.Add(this);
        }

        /// <include file='doc\ToolTip.uex' path='docs/doc[@for="ToolTip.ToolTip1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Windows.Forms.ToolTip'/> class in its default state.
        ///    </para>
        /// </devdoc>
        public ToolTip() {
            window = new ToolTipNativeWindow(this);
            auto = true;
            delayTimes[NativeMethods.TTDT_AUTOMATIC] = DEFAULT_DELAY;
            AdjustBaseFromAuto();
        }

        /// <include file='doc\ToolTip.uex' path='docs/doc[@for="ToolTip.Active"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the <see cref='System.Windows.Forms.ToolTip'/> control is currently active.
        ///    </para>
        /// </devdoc>
        [
        SRDescription(SR.ToolTipActiveDescr),
        DefaultValue(true)
        ]
        public bool Active {
            get {
                return active;
            }

            set {
                if (active != value) {
                    active = value;

                    //lets not actually activate the tooltip if we're in the designer (just set the value)
                    if (!DesignMode && GetHandleCreated()) {
                        UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.TTM_ACTIVATE, (value==true)? 1: 0, 0);
                    }
                }
            }
        }

        /// <include file='doc\ToolTip.uex' path='docs/doc[@for="ToolTip.AutomaticDelay"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets
        ///       the time (in milliseconds) that passes before the <see cref='System.Windows.Forms.ToolTip'/> appears.
        ///    </para>
        /// </devdoc>
        [
        RefreshProperties(RefreshProperties.All),
        SRDescription(SR.ToolTipAutomaticDelayDescr),
        DefaultValue(DEFAULT_DELAY)
        ]
        public int AutomaticDelay {
            get {
                return delayTimes[NativeMethods.TTDT_AUTOMATIC];
            }

            set {
                if (value < 0) {
                    throw new ArgumentException(SR.GetString(SR.InvalidLowBoundArgumentEx, "value", (value).ToString(), "0"));
                }
                SetDelayTime(NativeMethods.TTDT_AUTOMATIC, value);
            }
        }

        /// <include file='doc\ToolTip.uex' path='docs/doc[@for="ToolTip.AutoPopDelay"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the initial delay for the <see cref='System.Windows.Forms.ToolTip'/> control.
        ///    </para>
        /// </devdoc>
        [
        RefreshProperties(RefreshProperties.All),
        SRDescription(SR.ToolTipAutoPopDelayDescr)
        ]
        public int AutoPopDelay {
            get {
                return delayTimes[NativeMethods.TTDT_AUTOPOP];
            }

            set {
                if (value < 0) {
                    throw new ArgumentException(SR.GetString(SR.InvalidLowBoundArgumentEx, "value", (value).ToString(), "0"));
                }
                SetDelayTime(NativeMethods.TTDT_AUTOPOP, value);
            }
        }

        /// <include file='doc\ToolTip.uex' path='docs/doc[@for="ToolTip.CreateParams"]/*' />
        /// <devdoc>
        ///     The createParams to create the window.
        /// </devdoc>
        /// <internalonly/>
        private CreateParams CreateParams {
            get {
                CreateParams cp = new CreateParams();
                cp.Parent = TopLevelControl.Handle;
                cp.ClassName = NativeMethods.TOOLTIPS_CLASS;
                if (showAlways) {
                    cp.Style = NativeMethods.TTS_ALWAYSTIP;
                }
                cp.ExStyle = 0;
                cp.Caption = null;
                return cp;
            }
        }

        private IntPtr Handle {
            get {
                if (!GetHandleCreated()) {
                    CreateHandle();
                }
                return window.Handle;
            }
        }

        /// <include file='doc\ToolTip.uex' path='docs/doc[@for="ToolTip.InitialDelay"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the initial delay for
        ///       the <see cref='System.Windows.Forms.ToolTip'/>
        ///       control.
        ///    </para>
        /// </devdoc>
        [
        RefreshProperties(RefreshProperties.All),
        SRDescription(SR.ToolTipInitialDelayDescr)
        ]
        public int InitialDelay {
            get {
                return delayTimes[NativeMethods.TTDT_INITIAL];
            }

            set {
                if (value < 0) {
                    throw new ArgumentException(SR.GetString(SR.InvalidLowBoundArgumentEx, "value", (value).ToString(), "0"));
                }
                SetDelayTime(NativeMethods.TTDT_INITIAL, value);
            }
        }

        /// <include file='doc\ToolTip.uex' path='docs/doc[@for="ToolTip.ReshowDelay"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the length of time (in milliseconds) that
        ///       it takes subsequent ToolTip instances to appear as the mouse pointer moves from
        ///       one ToolTip region to
        ///       another.
        ///    </para>
        /// </devdoc>
        [
        RefreshProperties(RefreshProperties.All),
        SRDescription(SR.ToolTipReshowDelayDescr)
        ]
        public int ReshowDelay {
            get {
                return delayTimes[NativeMethods.TTDT_RESHOW];
            }
            set {
                if (value < 0) {
                    throw new ArgumentException(SR.GetString(SR.InvalidLowBoundArgumentEx, "value", (value).ToString(), "0"));
                }
                SetDelayTime(NativeMethods.TTDT_RESHOW, value);
            }
        }

        /// <include file='doc\ToolTip.uex' path='docs/doc[@for="ToolTip.ShowAlways"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the <see cref='System.Windows.Forms.ToolTip'/>
        ///       appears even when its parent control is not active.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(false),
        SRDescription(SR.ToolTipShowAlwaysDescr)
        ]
        public bool ShowAlways {
            get {
                return showAlways;
            }
            set {
                if (showAlways != value) {
                    showAlways = value;
                    if (GetHandleCreated()) {
                        RecreateHandle();
                    }
                }
            }
        }

        private Control TopLevelControl {
            get {
                Control baseVar = null;
                if (topLevelControl == null) {
                    Control[] regions = new Control[tools.Keys.Count];
                    tools.Keys.CopyTo(regions, 0);
                    if (regions != null && regions.Length > 0) {
                        for (int i=0; i<regions.Length; i++) {
                            Control ctl = regions[i];

                            // 52023 - a topLevel Form counts as the top level
                            // control...
                            //
                            if (ctl != null && ctl is Form) {
                                Form f = (Form)ctl;
                                if (f.TopLevel) {
                                    baseVar = ctl;
                                    break;
                                }
                            }

                            if (ctl != null && ctl.ParentInternal != null) {
                                while (ctl.ParentInternal != null) {
                                    ctl = ctl.ParentInternal;
                                }
                                baseVar = ctl;
                                if (baseVar != null) {
                                    break;
                                }
                            }
                        }
                    }
                    topLevelControl = baseVar;
                    if (baseVar != null) {
                        baseVar.HandleCreated += new EventHandler(this.TopLevelCreated);
                        baseVar.HandleDestroyed += new EventHandler(this.TopLevelDestroyed);
                        if (baseVar.IsHandleCreated) {
                            TopLevelCreated(baseVar, EventArgs.Empty);
                        }
                        baseVar.ParentChanged += new EventHandler(this.OnTopLevelPropertyChanged);
                    }
                }
                else {
                    baseVar = topLevelControl;
                }
                return baseVar;
            }
        }

        /// <include file='doc\ToolTip.uex' path='docs/doc[@for="ToolTip.AdjustBaseFromAuto"]/*' />
        /// <devdoc>
        ///     Adjusts the other delay values based on the Automatic value.
        /// </devdoc>
        /// <internalonly/>
        private void AdjustBaseFromAuto() {
            delayTimes[NativeMethods.TTDT_RESHOW] = delayTimes[NativeMethods.TTDT_AUTOMATIC] / RESHOW_RATIO;
            delayTimes[NativeMethods.TTDT_AUTOPOP] = delayTimes[NativeMethods.TTDT_AUTOMATIC] * AUTOPOP_RATIO;
            delayTimes[NativeMethods.TTDT_INITIAL] = delayTimes[NativeMethods.TTDT_AUTOMATIC];
        }

        private void HandleCreated(object sender, EventArgs eventargs) {
            CreateRegion((Control)sender);
        }
        private void HandleDestroyed(object sender, EventArgs eventargs) {
            DestroyRegion((Control)sender);
        }

        private void TopLevelCreated(object sender, EventArgs eventargs) {
            CreateHandle();
            CreateAllRegions();
        }
        private void TopLevelDestroyed(object sender, EventArgs eventargs) {
            DestroyHandle();
        }

        /// <include file='doc\ToolTip.uex' path='docs/doc[@for="ToolTip.CanExtend"]/*' />
        /// <devdoc>
        ///    Returns true if the tooltip can offer an extender property to the
        ///    specified target component.
        /// </devdoc>
        /// <internalonly/>
        public bool CanExtend(object target) {
            if (target is Control &&
                !(target is ToolTip)) {

                return true;
            }
            return false;
        }

        /// <include file='doc\ToolTip.uex' path='docs/doc[@for="ToolTip.CreateHandle"]/*' />
        /// <devdoc>
        ///     Creates the handle for the control.
        /// </devdoc>
        /// <internalonly/>
        private void CreateHandle() {
            if (GetHandleCreated()) {
                return;
            }

            NativeMethods.INITCOMMONCONTROLSEX icc = new NativeMethods.INITCOMMONCONTROLSEX();
            icc.dwICC = NativeMethods.ICC_TAB_CLASSES;
            SafeNativeMethods.InitCommonControlsEx(icc);

            window.CreateHandle(CreateParams);
            SafeNativeMethods.SetWindowPos(new HandleRef(this, Handle), NativeMethods.HWND_TOPMOST,
                                 0, 0, 0, 0,
                                 NativeMethods.SWP_NOMOVE | NativeMethods.SWP_NOSIZE |
                                 NativeMethods.SWP_NOACTIVATE);

            // Setting the max width has the added benefit of enabling multiline
            // tool tips!
            //
            UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.TTM_SETMAXTIPWIDTH, 0, SystemInformation.MaxWindowTrackSize.Width);

            Debug.Assert(NativeMethods.TTDT_AUTOMATIC == 0, "TTDT_AUTOMATIC != 0");

            if (auto) {
                SetDelayTime(NativeMethods.TTDT_AUTOMATIC, delayTimes[NativeMethods.TTDT_AUTOMATIC]);
                delayTimes[NativeMethods.TTDT_AUTOPOP] = GetDelayTime(NativeMethods.TTDT_AUTOPOP);
                delayTimes[NativeMethods.TTDT_INITIAL] = GetDelayTime(NativeMethods.TTDT_INITIAL);
                delayTimes[NativeMethods.TTDT_RESHOW] = GetDelayTime(NativeMethods.TTDT_RESHOW);
            }
            else {
                for (int i=1; i < delayTimes.Length; i++) {
                    if (delayTimes[i] >= 1) {
                        SetDelayTime(i, delayTimes[i]);
                    }
                }
            }
            
            // Set active status
            //
            UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.TTM_ACTIVATE, (active == true) ? 1 : 0, 0);
        }

        private void CreateAllRegions() {
            Control[] ctls = new Control[tools.Keys.Count];
            tools.Keys.CopyTo(ctls, 0);
            for (int i=0; i<ctls.Length; i++) {
                CreateRegion(ctls[i]);
            }
        }

        private void CreateRegion(Control ctl) {
            string caption = GetToolTip(ctl);
            bool captionValid = caption != null
                                && caption.Length > 0;
            bool handlesCreated = ctl.IsHandleCreated
                                  && TopLevelControl != null
                                  && TopLevelControl.IsHandleCreated;
            if (!created.ContainsKey(ctl) && captionValid
                && handlesCreated && !DesignMode) {

                int ret = (int)UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.TTM_ADDTOOL, 0, GetTOOLINFO(ctl, caption));
                if (ret == 0) {
                    throw new InvalidOperationException(SR.GetString(SR.ToolTipAddFailed));
                }
                created[ctl] = ctl;
            }
            if (ctl.IsHandleCreated && topLevelControl == null) {
                // Remove first to purge any duplicates...
                //
                ctl.MouseMove -= new MouseEventHandler(this.MouseMove);
                ctl.MouseMove += new MouseEventHandler(this.MouseMove);
            }
        }

        private void MouseMove(object sender, MouseEventArgs me) {
            Control ctl = (Control)sender;

            if (!created.ContainsKey(ctl)
                && ctl.IsHandleCreated
                && TopLevelControl != null) {

                CreateRegion(ctl);
            }

            if (created.ContainsKey(ctl)) {
                ctl.MouseMove -= new MouseEventHandler(this.MouseMove);
            }
        }


        /// <include file='doc\ToolTip.uex' path='docs/doc[@for="ToolTip.DestroyHandle"]/*' />
        /// <devdoc>
        ///     Destroys the handle for this control.
        /// </devdoc>
        /// <internalonly/>
        private void DestroyHandle() {

            if (GetHandleCreated()) {
                window.DestroyHandle();
            }
        }

        private void DestroyRegion(Control ctl) {
        
            bool handlesCreated = ctl.IsHandleCreated
                                  && GetHandleCreated()
                                  && topLevelControl != null
                                  && topLevelControl.IsHandleCreated;
            if (created.ContainsKey(ctl)
                && handlesCreated && !DesignMode) {

                UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.TTM_DELTOOL, 0, GetMinTOOLINFO(ctl));
                created.Remove(ctl);
            }
        }

        /// <include file='doc\ToolTip.uex' path='docs/doc[@for="ToolTip.Dispose"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Disposes of the <see cref='System.Windows.Forms.ToolTip'/>
        ///       component.
        ///    </para>
        /// </devdoc>
        protected override void Dispose(bool disposing) {
            // always destroy the handle...
            //
            DestroyHandle();

            base.Dispose(disposing);
        }

        /// <include file='doc\ToolTip.uex' path='docs/doc[@for="ToolTip.GetDelayTime"]/*' />
        /// <devdoc>
        ///     Returns the delayTime based on the NativeMethods.TTDT_* values.
        /// </devdoc>
        /// <internalonly/>
        private int GetDelayTime(int type) {
            if (GetHandleCreated()) {
                return (int)UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.TTM_GETDELAYTIME, type, 0);
            }
            else {
                return delayTimes[type];
            }
        }

        // Can't be a property -- there is another method called GetHandleCreated
        private bool GetHandleCreated() {
            return window.Handle != IntPtr.Zero;
        }

        /// <include file='doc\ToolTip.uex' path='docs/doc[@for="ToolTip.GetMinTOOLINFO"]/*' />
        /// <devdoc>
        ///     Returns a new instance of the TOOLINFO_T structure with the minimum
        ///     required data to uniquely identify a region. This is used primarily
        ///     for delete operations. NOTE: This cannot force the creation of a handle.
        /// </devdoc>
        /// <internalonly/>
        private NativeMethods.TOOLINFO_T GetMinTOOLINFO(Control ctl) {
            NativeMethods.TOOLINFO_T ti = new NativeMethods.TOOLINFO_T();
            ti.cbSize = Marshal.SizeOf(typeof(NativeMethods.TOOLINFO_T));
            ti.hwnd = IntPtr.Zero;
            ti.uFlags |= NativeMethods.TTF_IDISHWND;
            ti.uId = ctl.Handle;
            return ti;
        }

        /// <include file='doc\ToolTip.uex' path='docs/doc[@for="ToolTip.GetTOOLINFO"]/*' />
        /// <devdoc>
        ///     Returns a detailed TOOLINFO_T structure that represents the specified
        ///     region. NOTE: This may force the creation of a handle.
        /// </devdoc>
        /// <internalonly/>
        private NativeMethods.TOOLINFO_T GetTOOLINFO(Control ctl, string caption) {
            NativeMethods.TOOLINFO_T ti = GetMinTOOLINFO(ctl);
            ti.cbSize = Marshal.SizeOf(typeof(NativeMethods.TOOLINFO_T));
            ti.uFlags |= NativeMethods.TTF_TRANSPARENT | NativeMethods.TTF_SUBCLASS;
            
            // RightToLeft reading order
            //
            Control richParent = TopLevelControl;
            if (richParent != null && richParent.RightToLeft == RightToLeft.Yes) {
                ti.uFlags |= NativeMethods.TTF_RTLREADING;
            }
            
            ti.lpszText = caption;
            return ti;
        }


        /// <include file='doc\ToolTip.uex' path='docs/doc[@for="ToolTip.GetToolTip"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Retrieves the <see cref='System.Windows.Forms.ToolTip'/> text associated with the specified control.
        ///    </para>
        /// </devdoc>
        [
        DefaultValue(""),
        Localizable(true),
        SRDescription(SR.ToolTipToolTipDescr)
        ]
        public string GetToolTip(Control control) {
            string caption = (string)tools[control];
            if (caption == null) {
                return "";
            }
            else {
                return caption;
            }
        }

        /// <include file='doc\ToolTip.uex' path='docs/doc[@for="ToolTip.GetWindowFromPoint"]/*' />
        /// <devdoc>
        ///     Returns the HWND of the window that is at the specified point. This
        ///     handles special cases where one Control owns multiple HWNDs (i.e. ComboBox).
        /// </devdoc>
        /// <internalonly/>
        private IntPtr GetWindowFromPoint(Point screenCoords, ref bool success) {
            Control baseVar = TopLevelControl;
            IntPtr baseHwnd = IntPtr.Zero;

            if (baseVar != null) {
                baseHwnd = baseVar.Handle;
            }

            IntPtr hwnd = IntPtr.Zero;
            bool finalMatch = false;
            while (!finalMatch) {
                Point pt = screenCoords;
                if (baseVar != null) {
                    pt = baseVar.PointToClientInternal(screenCoords);
                }
                IntPtr found = UnsafeNativeMethods.ChildWindowFromPointEx(new HandleRef(null, baseHwnd), pt.X, pt.Y, NativeMethods.CWP_SKIPINVISIBLE);

                if (found == baseHwnd) {
                    hwnd = found;
                    finalMatch = true;
                }
                else if (found == IntPtr.Zero) {
                    finalMatch = true;
                }
                else {
                    baseVar = Control.FromHandleInternal(found);
                    if (baseVar == null) {
                        baseVar = Control.FromChildHandleInternal(found);
                        if (baseVar != null) {
                            hwnd = baseVar.Handle;
                        }
                        finalMatch = true;
                    }
                    else {
                        baseHwnd = baseVar.Handle;
                    }
                }
            }

            if (hwnd != IntPtr.Zero) {
                Control ctl = Control.FromHandleInternal(hwnd);
                if (ctl != null) {
                    Control current = ctl;
                    while (current != null && current.Visible) {
                        current = current.ParentInternal;
                    }
                    if (current != null) {
                        hwnd = IntPtr.Zero;
                    }
                    success = true;
                }
            }

            return hwnd;
        }

        private void OnTopLevelPropertyChanged(object s, EventArgs e) {
            this.topLevelControl.ParentChanged -= new EventHandler(this.OnTopLevelPropertyChanged);
            this.topLevelControl.HandleCreated -= new EventHandler(this.TopLevelCreated);
            this.topLevelControl.HandleDestroyed -= new EventHandler(this.TopLevelDestroyed);
            this.topLevelControl = null;
            
            // We must re-aquire this control.  If the existing top level control's handle
            // was never created, but the new parent has a handle, if we don't re-get
            // the top level control here we won't ever create the tooltip handle.
            //
            this.topLevelControl = TopLevelControl;
        }

        /// <include file='doc\ToolTip.uex' path='docs/doc[@for="ToolTip.RecreateHandle"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        private void RecreateHandle() {
            if (!DesignMode) {
                if (GetHandleCreated()) {
                    DestroyHandle();
                }
                created.Clear();
                CreateHandle();
                CreateAllRegions();
            }
        }


        /// <include file='doc\ToolTip.uex' path='docs/doc[@for="ToolTip.RemoveAll"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Removes all of the tooltips currently associated
        ///       with the <see cref='System.Windows.Forms.ToolTip'/> control.
        ///    </para>
        /// </devdoc>
        public void RemoveAll() {
            Control[] regions = new Control[tools.Keys.Count];
            tools.Keys.CopyTo(regions, 0);
            for (int i=0; i<regions.Length; i++) {
                if (regions[i].IsHandleCreated) {
                    DestroyRegion(regions[i]);
                }
            }

            tools.Clear();
        }

        /// <include file='doc\ToolTip.uex' path='docs/doc[@for="ToolTip.SetDelayTime"]/*' />
        /// <devdoc>
        ///     Sets the delayTime based on the NativeMethods.TTDT_* values.
        /// </devdoc>
        /// <internalonly/>
        private void SetDelayTime(int type, int time) {
            if (type == NativeMethods.TTDT_AUTOMATIC) {
                auto = true;
            }
            else {
                auto = false;
            }
            
            delayTimes[type] = time;

            if (GetHandleCreated() && time >= 0) {
                UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.TTM_SETDELAYTIME, type, time);

                // Update everyone else if automatic is set... we need to do this
                // to preserve value in case of handle recreation.
                //
                if (auto) {
                    delayTimes[NativeMethods.TTDT_AUTOPOP] = GetDelayTime(NativeMethods.TTDT_AUTOPOP);
                    delayTimes[NativeMethods.TTDT_INITIAL] = GetDelayTime(NativeMethods.TTDT_INITIAL);
                    delayTimes[NativeMethods.TTDT_RESHOW] = GetDelayTime(NativeMethods.TTDT_RESHOW);
                }
            }
            else if (auto) {
                AdjustBaseFromAuto();
            }
        }

        /// <include file='doc\ToolTip.uex' path='docs/doc[@for="ToolTip.SetToolTip"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Associates <see cref='System.Windows.Forms.ToolTip'/> text with the specified control.
        ///    </para>
        /// </devdoc>
        public void SetToolTip(Control control, string caption) {
        
            // Sanity check the function parameters
            if (control == null) {
                throw new ArgumentException(SR.GetString(SR.InvalidArgument, "control", "null"));
            }
        
            bool exists = false;
            bool empty = false;

            if (tools.ContainsKey(control)) {
                exists = true;         
            }

            if (caption == null || caption.Length == 0) {
                empty = true;
            }

            if (exists && empty) {
                tools.Remove(control);
            }
            else if (!empty) {
                tools[control] = caption;
            }

            if (!empty && !exists) {
                control.HandleCreated += new EventHandler(this.HandleCreated);
                control.HandleDestroyed += new EventHandler(this.HandleDestroyed);

                if (control.IsHandleCreated) {
                    HandleCreated(control, EventArgs.Empty);
                }
            }
            else {
                bool handlesCreated = control.IsHandleCreated
                                      && TopLevelControl != null
                                      && TopLevelControl.IsHandleCreated;

                if (exists && !empty && handlesCreated && !DesignMode) {
                    int ret = (int)UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.TTM_SETTOOLINFO,
                                                  0, GetTOOLINFO(control, caption));
                    if (ret != 0) {
                        throw new InvalidOperationException(SR.GetString(SR.ToolTipAddFailed));
                    }
                }
                else if (empty && exists && !DesignMode) {
                        
                    control.HandleCreated += new EventHandler(this.HandleCreated);
                    control.HandleDestroyed += new EventHandler(this.HandleDestroyed);

                    if (control.IsHandleCreated) {
                        HandleDestroyed(control, EventArgs.Empty);
                    }
                }
            }
        }

        /// <include file='doc\ToolTip.uex' path='docs/doc[@for="ToolTip.ShouldSerializeAutomaticDelay"]/*' />
        /// <devdoc>
        ///    Returns true if the AutomaticDelay property should be persisted.
        /// </devdoc>
        /// <internalonly/>
        private bool ShouldSerializeAutomaticDelay() {
            if (auto) {
                if (AutomaticDelay != DEFAULT_DELAY) {
                    return true;
                }
            }
            return false;
        }

        /// <include file='doc\ToolTip.uex' path='docs/doc[@for="ToolTip.ShouldSerializeAutoPopDelay"]/*' />
        /// <devdoc>
        ///    Returns true if the AutoPopDelay property should be persisted.
        /// </devdoc>
        /// <internalonly/>
        private bool ShouldSerializeAutoPopDelay() {
            return !auto;
        }

        /// <include file='doc\ToolTip.uex' path='docs/doc[@for="ToolTip.ShouldSerializeInitialDelay"]/*' />
        /// <devdoc>
        ///    Returns true if the InitialDelay property should be persisted.
        /// </devdoc>
        /// <internalonly/>
        private bool ShouldSerializeInitialDelay() {
            return !auto;
        }

        /// <include file='doc\ToolTip.uex' path='docs/doc[@for="ToolTip.ShouldSerializeReshowDelay"]/*' />
        /// <devdoc>
        ///    Returns true if the ReshowDelay property should be persisted.
        /// </devdoc>
        /// <internalonly/>
        private bool ShouldSerializeReshowDelay() {
            return !auto;
        }

        /// <include file='doc\ToolTip.uex' path='docs/doc[@for="ToolTip.Finalize"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Finalizes garbage collection.
        ///    </para>
        /// </devdoc>
        ~ToolTip() {
            DestroyHandle();
        }

        /// <include file='doc\ToolTip.uex' path='docs/doc[@for="ToolTip.ToString"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Returns a string representation for this control.
        ///    </para>
        /// </devdoc>
        public override string ToString() {

            string s = base.ToString();
            return s + " InitialDelay: " + InitialDelay.ToString() + ", ShowAlways: " + ShowAlways.ToString();
        }

        /// <include file='doc\ToolTip.uex' path='docs/doc[@for="ToolTip.WmWindowFromPoint"]/*' />
        /// <devdoc>
        ///     Handles the WM_WINDOWFROMPOINT message.
        /// </devdoc>
        /// <internalonly/>
        private void WmWindowFromPoint(ref Message msg) {
            NativeMethods.POINT sc = (NativeMethods.POINT)msg.GetLParam(typeof(NativeMethods.POINT));
            Point screenCoords = new Point(sc.x, sc.y);
            bool result = false;
            msg.Result = GetWindowFromPoint(screenCoords, ref result);
        }

        /// <include file='doc\ToolTip.uex' path='docs/doc[@for="ToolTip.WndProc"]/*' />
        /// <devdoc>
        ///     WNDPROC
        /// </devdoc>
        /// <internalonly/>
        private void WndProc(ref Message msg) {
            switch (msg.Msg) {
                case NativeMethods.TTM_WINDOWFROMPOINT:
                    WmWindowFromPoint(ref msg);
                    break;
                default:
                    window.DefWndProc(ref msg);
                    break;
            }
        }

        /// <include file='doc\ToolTip.uex' path='docs/doc[@for="ToolTip.ToolTipNativeWindow"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        private class ToolTipNativeWindow : NativeWindow {
            ToolTip control;

            internal ToolTipNativeWindow(ToolTip control) {
                this.control = control;
            }
            protected override void WndProc(ref Message m) {
                if (control != null) {
                    control.WndProc(ref m);
                }
            }
        }
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\treenodecollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="TreeNodeCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
*/
namespace System.Windows.Forms {
    using System.Runtime.InteropServices;

    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Drawing.Design;
    using System.Windows.Forms;

    /// <include file='doc\TreeNodeCollection.uex' path='docs/doc[@for="TreeNodeCollection"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [
    Editor("System.Windows.Forms.Design.TreeNodeCollectionEditor, " + AssemblyRef.SystemDesign, typeof(UITypeEditor))
    ]
    public class TreeNodeCollection : IList {
        private TreeNode owner;

        internal TreeNodeCollection(TreeNode owner) {
            this.owner = owner;
        }
        
        /// <include file='doc\TreeNodeCollection.uex' path='docs/doc[@for="TreeNodeCollection.this"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual TreeNode this[int index] {
            get {
                if (index < 0 || index >= owner.childCount) {
                    throw new ArgumentOutOfRangeException("index");
                }
                return owner.children[index];
            }
            set {
                if (index < 0 || index >= owner.childCount)
                    throw new ArgumentOutOfRangeException(SR.GetString(SR.InvalidArgument,
                                                              "index",
                                                              (index).ToString()));
                value.parent = owner;
                value.index = index;
                owner.children[index] = value;
                value.Realize();
            }
        }
        
        /// <include file='doc\TreeNodeCollection.uex' path='docs/doc[@for="TreeNodeCollection.IList.this"]/*' />
        /// <internalonly/>
        object IList.this[int index] {
            get {
                return this[index];
            }
            set {
                if (value is TreeNode) {
                    this[index] = (TreeNode)value;
                }
                else { 
                    throw new ArgumentException("value");
                }
            }
        }

        /// <include file='doc\TreeNodeCollection.uex' path='docs/doc[@for="TreeNodeCollection.Count"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced)
        ]
        public int Count {
            get {
                return owner.childCount;
            }
        }

        /// <include file='doc\TreeNodeCollection.uex' path='docs/doc[@for="TreeNodeCollection.ICollection.SyncRoot"]/*' />
        /// <internalonly/>
        object ICollection.SyncRoot {
            get {
                return this;
            }
        }

        /// <include file='doc\TreeNodeCollection.uex' path='docs/doc[@for="TreeNodeCollection.ICollection.IsSynchronized"]/*' />
        /// <internalonly/>
        bool ICollection.IsSynchronized {
            get {
                return false;
            }
        }
        
        /// <include file='doc\TreeNodeCollection.uex' path='docs/doc[@for="TreeNodeCollection.IList.IsFixedSize"]/*' />
        /// <internalonly/>
        bool IList.IsFixedSize {
            get {
                return false;
            }
        }
        
        /// <include file='doc\TreeNodeCollection.uex' path='docs/doc[@for="TreeNodeCollection.IsReadOnly"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool IsReadOnly {
            get {  
                return false;
            }
        }

        /// <include file='doc\TreeNodeCollection.uex' path='docs/doc[@for="TreeNodeCollection.Add"]/*' />
        /// <devdoc>
        ///     Creates a new child node under this node.  Child node is positioned after siblings.
        /// </devdoc>
        public virtual TreeNode Add(string text) {
            TreeNode tn = new TreeNode(text);
            Add(tn);
            return tn;
        }
        
        /// <include file='doc\TreeNodeCollection.uex' path='docs/doc[@for="TreeNodeCollection.AddRange"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual void AddRange(TreeNode[] nodes) {
            if (nodes == null) {
                throw new ArgumentNullException("nodes");
            }
            foreach(TreeNode node in nodes) {
                Add(node);
            }
        }

        /// <include file='doc\TreeNodeCollection.uex' path='docs/doc[@for="TreeNodeCollection.Add1"]/*' />
        /// <devdoc>
        ///     Adds a new child node to this node.  Child node is positioned after siblings.
        /// </devdoc>
        public virtual int Add(TreeNode node) {
            if (node == null) {
                throw new ArgumentNullException("node");
            }
            if (node.handle != IntPtr.Zero)
                throw new ArgumentException(SR.GetString(SR.OnlyOneControl, node.Text), "node");

            // If the TreeView is sorted, index is ignored
            TreeView tv = owner.TreeView;
            if (tv != null && tv.Sorted) {
                return owner.AddSorted(node);                
            }

            owner.EnsureCapacity();
            node.parent = owner;
            node.index = owner.childCount++;
            owner.children[node.index] = node;
            node.Realize();

            if (tv != null && node == tv.selectedNode)
                tv.SelectedNode = node; // communicate this to the handle
                
            return node.index;
        }
        
        /// <include file='doc\TreeNodeCollection.uex' path='docs/doc[@for="TreeNodeCollection.IList.Add"]/*' />
        /// <internalonly/>
        int IList.Add(object node) {
            if (node == null) {
                throw new ArgumentNullException("node");
            }
            else if (node is TreeNode) {
                return Add((TreeNode)node);
            }            
            else
            {
                return Add(node.ToString()).index;
            }
        }
        
        /// <include file='doc\TreeNodeCollection.uex' path='docs/doc[@for="TreeNodeCollection.Contains"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool Contains(TreeNode node) {
            return IndexOf(node) != -1;
        }
        
        /// <include file='doc\TreeNodeCollection.uex' path='docs/doc[@for="TreeNodeCollection.IList.Contains"]/*' />
        /// <internalonly/>
        bool IList.Contains(object node) {
            if (node is TreeNode) {
                return Contains((TreeNode)node);
            }
            else {  
                return false;
            }
        }
        
        /// <include file='doc\TreeNodeCollection.uex' path='docs/doc[@for="TreeNodeCollection.IndexOf"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int IndexOf(TreeNode node) {
            for(int index=0; index < Count; ++index) {
                if (this[index] == node) {
                    return index;
                } 
            }
            return -1;
        }
        
        /// <include file='doc\TreeNodeCollection.uex' path='docs/doc[@for="TreeNodeCollection.IList.IndexOf"]/*' />
        /// <internalonly/>
        int IList.IndexOf(object node) {
            if (node is TreeNode) {
                return IndexOf((TreeNode)node);
            }
            else {  
                return -1;
            }
        }

        /// <include file='doc\TreeNodeCollection.uex' path='docs/doc[@for="TreeNodeCollection.Insert"]/*' />
        /// <devdoc>
        ///     Inserts a new child node on this node.  Child node is positioned as specified by index.
        /// </devdoc>
        public virtual void Insert(int index, TreeNode node) {
            if (node.handle != IntPtr.Zero)
                throw new ArgumentException(SR.GetString(SR.OnlyOneControl, node.Text), "node");

            // If the TreeView is sorted, index is ignored
            TreeView tv = owner.TreeView;
            if (tv != null && tv.Sorted) {
                owner.AddSorted(node);
                return;
            }

            if (index < 0) index = 0;
            if (index > owner.childCount) index = owner.childCount;
            owner.InsertNodeAt(index, node);
        }
        
        /// <include file='doc\TreeNodeCollection.uex' path='docs/doc[@for="TreeNodeCollection.IList.Insert"]/*' />
        /// <internalonly/>
        void IList.Insert(int index, object node) {
            if (node is TreeNode) {
                Insert(index, (TreeNode)node);
            }
            else {  
                throw new ArgumentException("node");
            }
        }

        /// <include file='doc\TreeNodeCollection.uex' path='docs/doc[@for="TreeNodeCollection.Clear"]/*' />
        /// <devdoc>
        ///     Remove all nodes from the tree view.
        /// </devdoc>
        public virtual void Clear() {
            owner.Clear();
        }

        /// <include file='doc\TreeNodeCollection.uex' path='docs/doc[@for="TreeNodeCollection.CopyTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void CopyTo(Array dest, int index) {
            if (owner.childCount > 0) {
                System.Array.Copy(owner.children, 0, dest, index, owner.childCount);
            }
        }
        
        /// <include file='doc\TreeNodeCollection.uex' path='docs/doc[@for="TreeNodeCollection.Remove"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Remove(TreeNode node) {
            node.Remove();
        }
        
        /// <include file='doc\TreeNodeCollection.uex' path='docs/doc[@for="TreeNodeCollection.IList.Remove"]/*' />
        /// <internalonly/>
        void IList.Remove(object node) {
            if (node is TreeNode ) {
                Remove((TreeNode)node);
            }
        }

        /// <include file='doc\TreeNodeCollection.uex' path='docs/doc[@for="TreeNodeCollection.RemoveAt"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual void RemoveAt(int index) {
            this[index].Remove();
        }

        /// <include file='doc\TreeNodeCollection.uex' path='docs/doc[@for="TreeNodeCollection.GetEnumerator"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public IEnumerator GetEnumerator() {
            return new WindowsFormsUtils.ArraySubsetEnumerator(owner.children, owner.childCount);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\treenode.cs ===
//------------------------------------------------------------------------------
// <copyright file="TreeNode.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

namespace System.Windows.Forms {
    using System.Text;
    using System.Runtime.Serialization;
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.InteropServices;
    using System.Runtime.Remoting;

    using System.Diagnostics;

    using System;
    
    using System.Collections;
    using System.Globalization;
    using System.Windows.Forms;
    using System.ComponentModel;
    using System.IO;
    using System.Drawing;
    using Microsoft.Win32;

    /// <include file='doc\TreeNode.uex' path='docs/doc[@for="TreeNode"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Implements a node of a <see cref='System.Windows.Forms.TreeView'/>.
    ///
    ///    </para>
    /// </devdoc>
    [
    TypeConverterAttribute(typeof(TreeNodeConverter)), Serializable
    ]
    public class TreeNode : MarshalByRefObject, ICloneable, ISerializable {
        private const int CHECKED = 2 << 12;
        private const int UNCHECKED = 1 << 12;

        // we use it to store font and color data in a minimal-memory-cost manner
        // ie. nodes which don't use fancy fonts or colors (ie. that use the TreeView settings for these)
        //     will take up less memory than those that do.
        internal OwnerDrawPropertyBag propBag = null;
        internal IntPtr handle;
        internal string text;

        // note: as the checked state of a node is user controlled, and this variable is simply for
        // state caching when a node hasn't yet been realized, you should use the Checked property to
        // find out the check state of a node, and not this member variable.
        internal bool isChecked = false;
        internal int imageIndex = -1;
        internal int selectedImageIndex = -1;

        internal int index;                  // our index into our parents child array
        internal int childCount;
        internal TreeNode[] children;
        internal TreeNode parent;
        internal TreeView treeView;
        private bool expandOnRealization = false;
        private TreeNodeCollection nodes = null;
        object userData;
        
        private readonly static int insertMask = 
                               NativeMethods.TVIF_TEXT
                             | NativeMethods.TVIF_IMAGE
                             | NativeMethods.TVIF_SELECTEDIMAGE;

        /// <include file='doc\TreeNode.uex' path='docs/doc[@for="TreeNode.TreeNode"]/*' />
        /// <devdoc>
        ///     Creates a TreeNode object.
        /// </devdoc>
        public TreeNode() {
        }

        internal TreeNode(TreeView treeView) {
            this.treeView = treeView;
        }

        /// <include file='doc\TreeNode.uex' path='docs/doc[@for="TreeNode.TreeNode1"]/*' />
        /// <devdoc>
        ///     Creates a TreeNode object.
        /// </devdoc>
        public TreeNode(string text) {
            this.text = text;
        }

        /// <include file='doc\TreeNode.uex' path='docs/doc[@for="TreeNode.TreeNode2"]/*' />
        /// <devdoc>
        ///     Creates a TreeNode object.
        /// </devdoc>
        public TreeNode(string text, TreeNode[] children) {
            this.text = text;
            this.Nodes.AddRange(children);
        }

        /// <include file='doc\TreeNode.uex' path='docs/doc[@for="TreeNode.TreeNode3"]/*' />
        /// <devdoc>
        ///     Creates a TreeNode object.
        /// </devdoc>
        public TreeNode(string text, int imageIndex, int selectedImageIndex) {
            this.text = text;
            this.imageIndex = imageIndex;
            this.selectedImageIndex = selectedImageIndex;
        }

        /// <include file='doc\TreeNode.uex' path='docs/doc[@for="TreeNode.TreeNode4"]/*' />
        /// <devdoc>
        ///     Creates a TreeNode object.
        /// </devdoc>
        public TreeNode(string text, int imageIndex, int selectedImageIndex, TreeNode[] children) {
            this.text = text;
            this.imageIndex = imageIndex;
            this.selectedImageIndex = selectedImageIndex;
            this.Nodes.AddRange(children);
        }

        /**
         * Constructor used in deserialization
         */
        internal TreeNode(SerializationInfo si, StreamingContext context) {
            
            int childCount = 0;

            foreach (SerializationEntry entry in si) {
                switch (entry.Name) {
                    case "PropBag":
                        propBag = (OwnerDrawPropertyBag)entry.Value;
                        break;
                    case "Text":
                        text = (string)entry.Value;
                        break;
                    case "IsChecked":
                        isChecked = (bool)entry.Value;
                        break;
                    case "ImageIndex":
                        imageIndex = (int)entry.Value;
                        break;
                    case "SelectedImageIndex":
                        selectedImageIndex = (int)entry.Value;
                        break;
                    case "ChildCount":

                        childCount = si.GetInt32("ChildCount");
                        break;
                    case "UserData":
                        userData = entry.Value;
                        break;
                }
            } 

            if (childCount > 0) {
                TreeNode[] childNodes = new TreeNode[childCount];

                for (int i = 0; i < childCount; i++) {
                    childNodes[i] = (TreeNode)si.GetValue("children" + i, typeof(TreeNode));
                }
                Nodes.AddRange(childNodes);
            }
        }

        /// <include file='doc\TreeNode.uex' path='docs/doc[@for="TreeNode.BackColor"]/*' />
        /// <devdoc>
        ///     The background color of this node.
        ///     If null, the color used will be the default color from the TreeView control that this
        ///     node is attached to
        /// </devdoc>
        public Color BackColor {
            get {
                if (propBag==null) return Color.Empty;
                return propBag.BackColor;
            }
            set {
                // get the old value
                Color oldbk = this.BackColor;
                // If we're setting the color to the default again, delete the propBag if it doesn't contain
                // useful data.
                if (value.IsEmpty) {
                    if (propBag!=null) {
                        propBag.BackColor = Color.Empty;
                        RemovePropBagIfEmpty();
                    }
                    if (!oldbk.IsEmpty) InvalidateHostTree();
                    return;
                }

                // Not the default, so if necessary create a new propBag, and fill it with the backcolor

                if (propBag==null) propBag = new OwnerDrawPropertyBag();
                propBag.BackColor = value;
                if (!value.Equals(oldbk)) InvalidateHostTree();
            }
        }

        /// <include file='doc\TreeNode.uex' path='docs/doc[@for="TreeNode.Bounds"]/*' />
        /// <devdoc>
        ///     The bounding rectangle for the node. The coordinates
        ///     are relative to the upper left corner of the TreeView control.
        /// </devdoc>
        public Rectangle Bounds {
            get {
                NativeMethods.RECT rc = new NativeMethods.RECT();
                rc.left = (int)Handle;
                // wparam: 0=include only text, 1=include entire line
                if ((int)UnsafeNativeMethods.SendMessage(new HandleRef(TreeView, TreeView.Handle), NativeMethods.TVM_GETITEMRECT, 1, ref rc) == 0) {
                    // This means the node is not visible
                    //
                    return Rectangle.Empty;
                }
                return Rectangle.FromLTRB(rc.left, rc.top, rc.right, rc.bottom);
            }
        }

        /// <include file='doc\TreeNode.uex' path='docs/doc[@for="TreeNode.CheckedInternal"]/*' />
        /// <devdoc>
        ///      Indicates whether the node's checkbox is checked (internal property) .
        /// </devdoc>
        /// <internalonly/>
        internal bool CheckedInternal {
            get {
                if (handle == IntPtr.Zero)
                    return isChecked;

                TreeView tv = TreeView;
                if (tv == null || !tv.IsHandleCreated)
                    return isChecked;

                NativeMethods.TV_ITEM item = new NativeMethods.TV_ITEM();
                item.mask = NativeMethods.TVIF_HANDLE | NativeMethods.TVIF_STATE;
                item.hItem = handle;                         
                item.stateMask = NativeMethods.TVIS_STATEIMAGEMASK;
                UnsafeNativeMethods.SendMessage(new HandleRef(tv, tv.Handle), NativeMethods.TVM_GETITEM, 0, ref item);
                isChecked = ((item.state >> 12) > 1) ;
                return isChecked;
            }
            set {
                
                isChecked = value;
                
                if (handle == IntPtr.Zero)
                    return;

                TreeView tv = TreeView;
                if (tv == null || !tv.IsHandleCreated)
                    return;

                NativeMethods.TV_ITEM item = new NativeMethods.TV_ITEM();
                item.mask = NativeMethods.TVIF_HANDLE | NativeMethods.TVIF_STATE;
                item.hItem = handle;
                item.stateMask = NativeMethods.TVIS_STATEIMAGEMASK;
                item.state = ((value ? 2 : 1) << 12);
                UnsafeNativeMethods.SendMessage(new HandleRef(tv, tv.Handle), NativeMethods.TVM_SETITEM, 0, ref item);
            }
            

        }
        /// <include file='doc\TreeNode.uex' path='docs/doc[@for="TreeNode.Checked"]/*' />
        /// <devdoc>
        ///     Indicates whether the node's checkbox is checked.
        /// </devdoc>
        public bool Checked {
            get {
                return  CheckedInternal;
            }
            set {
                TreeView tv = TreeView;
                if (tv != null) {
                    bool eventReturn = tv.TreeViewBeforeCheck(this, TreeViewAction.Unknown);
                    if (!eventReturn) {
                        CheckedInternal = value;
                        tv.TreeViewAfterCheck(this, TreeViewAction.Unknown);
                    }
                }
                else {
                    CheckedInternal = value;
                }
            }
        }
        
        /// <include file='doc\TreeNode.uex' path='docs/doc[@for="TreeNode.FirstNode"]/*' />
        /// <devdoc>
        ///     The first child node of this node.
        /// </devdoc>
        public TreeNode FirstNode {
            get {
                if (childCount == 0) return null;
                return children[0];
            }
        }
        
        private TreeNode FirstVisibleParent {
            get {
                TreeNode node = this;
                while (node != null && node.Bounds.IsEmpty) {
                    node = node.Parent;
                }
                return node;
            }
        }

        /// <include file='doc\TreeNode.uex' path='docs/doc[@for="TreeNode.ForeColor"]/*' />
        /// <devdoc>
        ///     The foreground color of this node.
        ///     If null, the color used will be the default color from the TreeView control that this
        ///     node is attached to
        /// </devdoc>
        public Color ForeColor {
            get {
                if (propBag == null) return Color.Empty;
                return propBag.ForeColor;
            }
            set {
                Color oldfc = this.ForeColor;
                // If we're setting the color to the default again, delete the propBag if it doesn't contain
                // useful data.
                if (value.IsEmpty) {
                    if (propBag != null) {
                        propBag.ForeColor = Color.Empty;
                        RemovePropBagIfEmpty();
                    }
                    if (!oldfc.IsEmpty) InvalidateHostTree();
                    return;
                }

                // Not the default, so if necessary create a new propBag, and fill it with the new forecolor

                if (propBag == null) propBag = new OwnerDrawPropertyBag();
                propBag.ForeColor = value;
                if (!value.Equals(oldfc)) InvalidateHostTree();
            }
        }

        /// <include file='doc\TreeNode.uex' path='docs/doc[@for="TreeNode.FullPath"]/*' />
        /// <devdoc>
        ///     Returns the full path of this node.
        ///     The path consists of the labels of each of the nodes from the root to this node,
        ///     each separated by the pathSeperator.
        /// </devdoc>
        public string FullPath {
            get {
                TreeView tv = TreeView;
                if (tv != null) {
                    StringBuilder path = new StringBuilder();
                    GetFullPath(path, tv.PathSeparator);
                    return path.ToString();
                }
                else 
                    throw new Exception(SR.GetString(SR.TreeNodeNoParent));
            }
        }

        /// <include file='doc\TreeNode.uex' path='docs/doc[@for="TreeNode.Handle"]/*' />
        /// <devdoc>
        ///     The HTREEITEM handle associated with this node.  If the handle
        ///     has not yet been created, this will force handle creation.
        /// </devdoc>
        public IntPtr Handle {
            get {
                if (handle == IntPtr.Zero) {
                    TreeView.CreateControl(); // force handle creation
                }
                return handle;
            }
        }

        /// <include file='doc\TreeNode.uex' path='docs/doc[@for="TreeNode.ImageIndex"]/*' />
        /// <devdoc>
        ///     The index of the image to be displayed when the node is in the unselected state.
        ///     The image is contained in the ImageList referenced by the imageList property.
        /// </devdoc>
        [
        Localizable(true)
        ]
        public int ImageIndex {
            get { return imageIndex;}
            set {
                imageIndex = value;
                UpdateNode(NativeMethods.TVIF_IMAGE);
            }
        }

        /// <include file='doc\TreeNode.uex' path='docs/doc[@for="TreeNode.Index"]/*' />
        /// <devdoc>
        ///     Returns the position of this node in relation to its siblings
        /// </devdoc>
        public int Index {
            get { return index;}
        }

        /// <include file='doc\TreeNode.uex' path='docs/doc[@for="TreeNode.IsEditing"]/*' />
        /// <devdoc>
        ///     Specifies whether this node is being edited by the user.
        /// </devdoc>
        public bool IsEditing {
            get {
                TreeView tv = TreeView;

                if (tv != null)
                    return tv.editNode == this;

                return false;
            }
        }

        /// <include file='doc\TreeNode.uex' path='docs/doc[@for="TreeNode.IsExpanded"]/*' />
        /// <devdoc>
        ///     Specifies whether this node is in the expanded state.
        /// </devdoc>
        public bool IsExpanded {
            get {
                if (handle == IntPtr.Zero) {
                    return expandOnRealization;
                }
                return(State & NativeMethods.TVIS_EXPANDED) != 0;
            }
        }

        /// <include file='doc\TreeNode.uex' path='docs/doc[@for="TreeNode.IsSelected"]/*' />
        /// <devdoc>
        ///     Specifies whether this node is in the selected state.
        /// </devdoc>
        public bool IsSelected {
            get {
                if (handle == IntPtr.Zero) return false;
                return(State & NativeMethods.TVIS_SELECTED) != 0;
            }
        }

        /// <include file='doc\TreeNode.uex' path='docs/doc[@for="TreeNode.IsVisible"]/*' />
        /// <devdoc>
        ///     Specifies whether this node is visible.
        /// </devdoc>
        public bool IsVisible {
            get {
                if (handle == IntPtr.Zero) return false;
                TreeView tv = TreeView;
                NativeMethods.RECT rc = new NativeMethods.RECT();
                rc.left = (int)handle;

                bool visible = ((int)UnsafeNativeMethods.SendMessage(new HandleRef(tv, tv.Handle), NativeMethods.TVM_GETITEMRECT, 1, ref rc) != 0);
                if (visible) {
                    Size size = tv.ClientSize;
                    visible = (rc.bottom > 0 && rc.right > 0 && rc.top < size.Height && rc.left < size.Width);
                }
                return visible;
            }
        }

        /// <include file='doc\TreeNode.uex' path='docs/doc[@for="TreeNode.LastNode"]/*' />
        /// <devdoc>
        ///     The last child node of this node.
        /// </devdoc>
        public TreeNode LastNode {
            get {
                if (childCount == 0) return null;
                return children[childCount-1];
            }
        }

        /// <include file='doc\TreeNode.uex' path='docs/doc[@for="TreeNode.NextNode"]/*' />
        /// <devdoc>
        ///     The next sibling node.
        /// </devdoc>
        public TreeNode NextNode {
            get {
                if (index+1 < parent.Nodes.Count) {
                    return parent.Nodes[index+1];
                }
                else {
                    return null;
                }
            }
        }

        /// <include file='doc\TreeNode.uex' path='docs/doc[@for="TreeNode.NextVisibleNode"]/*' />
        /// <devdoc>
        ///     The next visible node.  It may be a child, sibling,
        ///     or a node from another branch.
        /// </devdoc>
        public TreeNode NextVisibleNode {
            get {
                // TVGN_NEXTVISIBLE can only be sent if the specified node is visible.
                // So before sending, we check if this node is visible. If not, we find the first visible parent.
                //
                TreeNode node = FirstVisibleParent;
                
                if (node != null) {
                    IntPtr next = UnsafeNativeMethods.SendMessage(new HandleRef(TreeView, TreeView.Handle),
                                               NativeMethods.TVM_GETNEXTITEM, NativeMethods.TVGN_NEXTVISIBLE, node.Handle);
                    if (next != IntPtr.Zero) {
                        return TreeView.NodeFromHandle(next);
                    }
                }
                
                return null;
            }
        }

        /// <include file='doc\TreeNode.uex' path='docs/doc[@for="TreeNode.NodeFont"]/*' />
        /// <devdoc>
        ///     The font that will be used to draw this node
        ///     If null, the font used will be the default font from the TreeView control that this
        ///     node is attached to.
        ///     NOTE: If the node font is larger than the default font from the TreeView control, then
        ///     the node will be clipped.
        /// </devdoc>
        [
        Localizable(true)
        ]
        public Font NodeFont {
            get {
                if (propBag==null) return null;
                return propBag.Font;
            }
            set {
                Font oldfont = this.NodeFont;
                // If we're setting the font to the default again, delete the propBag if it doesn't contain
                // useful data.
                if (value==null) {
                    if (propBag!=null) {
                        propBag.Font = null;
                        RemovePropBagIfEmpty();
                    }
                    if (oldfont != null) InvalidateHostTree();
                    return;
                }

                // Not the default, so if necessary create a new propBag, and fill it with the font

                if (propBag==null) propBag = new OwnerDrawPropertyBag();
                propBag.Font = value;
                if (!value.Equals(oldfont)) InvalidateHostTree();
            }
        }

        /// <include file='doc\TreeNode.uex' path='docs/doc[@for="TreeNode.Nodes"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [ListBindable(false)]
        public TreeNodeCollection Nodes {
            get {
                if (nodes == null) {
                    nodes = new TreeNodeCollection(this);
                }
                return nodes;
            }
        }

        /// <include file='doc\TreeNode.uex' path='docs/doc[@for="TreeNode.Parent"]/*' />
        /// <devdoc>
        ///     Retrieves parent node.
        /// </devdoc>
        public TreeNode Parent {
            get {
                TreeView tv = TreeView;

                // Don't expose the virtual root publicly
                if (tv != null && parent == tv.root) {
                    return null;
                }

                return parent;
            }
        }

        /// <include file='doc\TreeNode.uex' path='docs/doc[@for="TreeNode.PrevNode"]/*' />
        /// <devdoc>
        ///     The previous sibling node.
        /// </devdoc>
        public TreeNode PrevNode {
            get {
                if (index > 0 && index <= parent.Nodes.Count) {
                    return parent.Nodes[index-1];
                }
                else {  
                    return null;
                }
            }
        }

        /// <include file='doc\TreeNode.uex' path='docs/doc[@for="TreeNode.PrevVisibleNode"]/*' />
        /// <devdoc>
        ///     The next visible node.  It may be a parent, sibling,
        ///     or a node from another branch.
        /// </devdoc>
        public TreeNode PrevVisibleNode {
            get {
                // TVGN_PREVIOUSVISIBLE can only be sent if the specified node is visible.
                // So before sending, we check if this node is visible. If not, we find the first visible parent.
                //
                TreeNode node = FirstVisibleParent;
                
                if (node != null) {
                    IntPtr prev = UnsafeNativeMethods.SendMessage(new HandleRef(TreeView, TreeView.Handle),
                                               NativeMethods.TVM_GETNEXTITEM,
                                               NativeMethods.TVGN_PREVIOUSVISIBLE, node.Handle);
                    if (prev != IntPtr.Zero) {
                        return TreeView.NodeFromHandle(prev);
                    }
                }
                
                return null;
            }
        }

        /// <include file='doc\TreeNode.uex' path='docs/doc[@for="TreeNode.SelectedImageIndex"]/*' />
        /// <devdoc>
        ///     The index of the image displayed when the node is in the selected state.
        ///     The image is contained in the ImageList referenced by the imageList property.
        /// </devdoc>
        [
        Localizable(true)
        ]
        public int SelectedImageIndex {
            get {
                return selectedImageIndex;
            }
            set {
                selectedImageIndex = value;
                UpdateNode(NativeMethods.TVIF_SELECTEDIMAGE);
            }
        }

        /// <include file='doc\TreeNode.uex' path='docs/doc[@for="TreeNode.State"]/*' />
        /// <devdoc>
        ///     Retrieve state bits for this node
        /// </devdoc>
        /// <internalonly/>
        internal int State {
            get {
                if (handle == IntPtr.Zero)
                    return 0;

                NativeMethods.TV_ITEM item = new NativeMethods.TV_ITEM();
                item.hItem = Handle;
                item.mask = NativeMethods.TVIF_HANDLE | NativeMethods.TVIF_STATE;
                item.stateMask = NativeMethods.TVIS_SELECTED | NativeMethods.TVIS_EXPANDED;
                UnsafeNativeMethods.SendMessage(new HandleRef(TreeView, TreeView.Handle), NativeMethods.TVM_GETITEM, 0, ref item);
                return item.state;
            }
        }


        /// <include file='doc\TreeNode.uex' path='docs/doc[@for="TreeNode.Tag"]/*' />
        [
        SRCategory(SR.CatData),
        Localizable(false),
        Bindable(true),
        SRDescription(SR.ControlTagDescr),
        DefaultValue(null),
        TypeConverter(typeof(StringConverter)),
        ]
        public object Tag {
            get {
                return userData;
            }
            set {
                userData = value;
            }
        }

        /// <include file='doc\TreeNode.uex' path='docs/doc[@for="TreeNode.Text"]/*' />
        /// <devdoc>
        ///     The label text for the tree node
        /// </devdoc>
        [
        Localizable(true)
        ]
        public string Text {
            get {
                return text == null ? "" : text;;
            }
            set {
                this.text = value;
                UpdateNode(NativeMethods.TVIF_TEXT);
            }
        }

        /// <include file='doc\TreeNode.uex' path='docs/doc[@for="TreeNode.TreeView"]/*' />
        /// <devdoc>
        ///     Return the TreeView control this node belongs to.
        /// </devdoc>
        public TreeView TreeView {
            get {
                if (treeView == null)
                    treeView = FindTreeView();
                return treeView;
            }
        }

        /// <include file='doc\TreeNode.uex' path='docs/doc[@for="TreeNode.AddSorted"]/*' />
        /// <devdoc>
        ///     Adds a new child node at the appropriate sorted position
        /// </devdoc>
        /// <internalonly/>
        internal int AddSorted(TreeNode node) {
            int index = 0;
            int iMin, iLim, iT;
            string nodeText = node.Text;

            if (childCount > 0) {
                CompareInfo compare = Application.CurrentCulture.CompareInfo;

                // Optimize for the case where they're already sorted
                if (compare.Compare(children[childCount-1].Text, nodeText) <= 0)
                    index = childCount;
                else {
                    // Insert at appropriate sorted spot
                    for (iMin = 0, iLim = childCount; iMin < iLim;) {
                        iT = (iMin + iLim) / 2;
                        if (compare.Compare(children[iT].Text, nodeText) <= 0)
                            iMin = iT + 1;
                        else
                            iLim = iT;
                    }
                    index = iMin;
                }
            }

            node.SortChildren();
            InsertNodeAt(index, node);
            
            return index;
        }

        /// <include file='doc\TreeNode.uex' path='docs/doc[@for="TreeNode.FromHandle"]/*' />
        /// <devdoc>
        ///     Returns a TreeNode object for the given HTREEITEM handle
        /// </devdoc>
        public static TreeNode FromHandle(TreeView tree, IntPtr handle) {
            return tree.NodeFromHandle(handle);
        }

        private void SortChildren() {
            // REVIEW: This could be optimized some
            if (childCount > 0) {
                TreeNode[] newOrder = new TreeNode[childCount];
                CompareInfo compare = Application.CurrentCulture.CompareInfo;
                for (int i = 0; i < childCount; i++) {
                    int min = -1;
                    for (int j = 0; j < childCount; j++) {
                        if (children[j] == null)
                            continue;
                        if (min == -1) {
                            min = j;
                            continue;
                        }
                        if (compare.Compare(children[j].Text, children[min].Text) < 0)
                            min = j;
                    }
                    Debug.Assert(min != -1, "Bad sorting");
                    newOrder[i] = children[min];
                    children[min] = null;
                    newOrder[i].index = i;
                    newOrder[i].SortChildren();
                }
                children = newOrder;
            }
        }

        /// <include file='doc\TreeNode.uex' path='docs/doc[@for="TreeNode.BeginEdit"]/*' />
        /// <devdoc>
        ///     Initiate editing of the node's label.
        ///     Only effective if LabelEdit property is true.
        /// </devdoc>
        public void BeginEdit() {
            if (handle != IntPtr.Zero) {
                TreeView tv = TreeView;
                if (tv.LabelEdit == false)
                    throw new Exception(SR.GetString(SR.TreeNodeBeginEditFailed));
                if (!tv.Focused)
                    tv.FocusInternal();
                UnsafeNativeMethods.SendMessage(new HandleRef(tv, tv.Handle), NativeMethods.TVM_EDITLABEL, 0, handle);
            }
        }
        
        /// <devdoc>
        ///     Called by the tree node collection to clear all nodes.  We optimize here if
        ///     this is the root node.
        /// </devdoc>
        internal void Clear() {
            // This is a node that is a child of some other node.  We have
            // to selectively remove children here.
            //
            while(childCount > 0) {
                children[childCount - 1].Remove(true);
            }
            children = null;
        }

        /// <include file='doc\TreeNode.uex' path='docs/doc[@for="TreeNode.Clone"]/*' />
        /// <devdoc>
        ///     Clone the entire subtree rooted at this node.
        /// </devdoc>
        public virtual object Clone() {
            Type clonedType = this.GetType();
            TreeNode node = null;

            if (clonedType == typeof(TreeNode)) 
                node = new TreeNode(text, imageIndex, selectedImageIndex);
            else
                node = (TreeNode)Activator.CreateInstance(clonedType);
            
            node.Text = text;
            node.ImageIndex = imageIndex;
            node.SelectedImageIndex = selectedImageIndex;

            if (childCount > 0) {
                node.children = new TreeNode[childCount];
                for (int i = 0; i < childCount; i++)
                    node.Nodes.Add((TreeNode)children[i].Clone());
            }
            
            // Clone properties
            //
            if (propBag != null) {                 
                node.propBag = OwnerDrawPropertyBag.Copy(propBag);
            }
            node.Checked = this.Checked;
            node.Tag = this.Tag;
            
            return node;
        }

        /// <include file='doc\TreeNode.uex' path='docs/doc[@for="TreeNode.Collapse"]/*' />
        /// <devdoc>
        ///     Collapse the node.
        /// </devdoc>
        public void Collapse() {
            TreeView tv = TreeView;
            bool setSelection = false;

            if (tv == null || !tv.IsHandleCreated) {
                expandOnRealization = false;
                return;
            }

            //terminating condition for recursion...
            //
            if (childCount > 0) {
                // Virtual root should collapse all its children
                for (int i = 0; i < childCount; i++) {
                     if (tv.SelectedNode == children[i]) {
                         setSelection = true;
                     }
                     children[i].DoCollapse(tv);
                     children[i].Collapse();

                    }
                }
            DoCollapse(tv);
            if (setSelection)
                tv.SelectedNode  = this;
            tv.Invalidate();
        }

        /// <include file='doc\TreeNode.uex' path='docs/doc[@for="TreeNode.DoCollapse"]/*' />
        /// <devdoc>
        ///     Windows TreeView doesn't send the proper notifications on collapse, so we do it manually.
        /// </devdoc>
        private void DoCollapse(TreeView tv) {
            if (IsExpanded) {
                TreeViewCancelEventArgs e = new TreeViewCancelEventArgs(this, false, TreeViewAction.Collapse);
                tv._OnBeforeCollapse(e);
                if (!e.Cancel) {
                    UnsafeNativeMethods.SendMessage(new HandleRef(tv, tv.Handle), NativeMethods.TVM_EXPAND, NativeMethods.TVE_COLLAPSE, Handle);
                    tv._OnAfterCollapse(new TreeViewEventArgs(this));
                }
            }
        }

        /// <include file='doc\TreeNode.uex' path='docs/doc[@for="TreeNode.EndEdit"]/*' />
        /// <devdoc>
        ///     Terminate the editing of any tree view item's label.
        /// </devdoc>
        public void EndEdit(bool cancel) {
            UnsafeNativeMethods.SendMessage(new HandleRef(TreeView, TreeView.Handle), NativeMethods.TVM_ENDEDITLABELNOW, cancel?1:0, 0);
        }

        /// <include file='doc\TreeNode.uex' path='docs/doc[@for="TreeNode.EnsureCapacity"]/*' />
        /// <devdoc>
        ///     Makes sure there is enough room to add one more child
        /// </devdoc>
        /// <internalonly/>
        internal void EnsureCapacity() {
            if (children == null) {
                children = new TreeNode[4];
            }
            else if (childCount == children.Length) {
                TreeNode[] bigger = new TreeNode[childCount * 2];
                System.Array.Copy(children, 0, bigger, 0, childCount);
                children = bigger;
            }
        }

        /// <include file='doc\TreeNode.uex' path='docs/doc[@for="TreeNode.EnsureVisible"]/*' />
        /// <devdoc>
        ///     Ensure that the node is visible, expanding nodes and scrolling the
        ///     TreeView control as necessary.
        /// </devdoc>
        public void EnsureVisible() {
            UnsafeNativeMethods.SendMessage(new HandleRef(TreeView, TreeView.Handle), NativeMethods.TVM_ENSUREVISIBLE, 0, Handle);
        }

        /// <include file='doc\TreeNode.uex' path='docs/doc[@for="TreeNode.Expand"]/*' />
        /// <devdoc>
        ///     Expand the node.
        /// </devdoc>
        public void Expand() {
            TreeView tv = TreeView;
            if (tv == null || !tv.IsHandleCreated) {
                expandOnRealization = true;
                return;
            }
            expandOnRealization = false;

            ResetExpandedState(tv);
            if (!IsExpanded) {
                UnsafeNativeMethods.SendMessage(new HandleRef(tv, tv.Handle), NativeMethods.TVM_EXPAND, NativeMethods.TVE_EXPAND, Handle);
            }
        }


        /// <include file='doc\TreeNode.uex' path='docs/doc[@for="TreeNode.ExpandAll"]/*' />
        /// <devdoc>
        ///     Expand the node.
        /// </devdoc>
        public void ExpandAll() {
            Expand();
            for (int i = 0; i < childCount; i++) {
                 children[i].ExpandAll();
            }
            
        }
        /// <include file='doc\TreeNode.uex' path='docs/doc[@for="TreeNode.FindTreeView"]/*' />
        /// <devdoc>
        ///     Locate this tree node's containing tree view control by scanning
        ///     up to the virtual root, whose treeView pointer we know to be
        ///     correct
        /// </devdoc>
        internal TreeView FindTreeView() {
            TreeNode node = this;
            while (node.parent != null)
                node = node.parent;
            return node.treeView;
        }

        /// <include file='doc\TreeNode.uex' path='docs/doc[@for="TreeNode.GetFullPath"]/*' />
        /// <devdoc>
        ///     Helper function for getFullPath().
        /// </devdoc>
        private void GetFullPath(StringBuilder path, string pathSeparator) {
            if (parent != null) {
                parent.GetFullPath(path, pathSeparator);
                if (parent.parent != null)
                    path.Append(pathSeparator);
                path.Append(this.text);
            }
        }

        /// <include file='doc\TreeNode.uex' path='docs/doc[@for="TreeNode.GetNodeCount"]/*' />
        /// <devdoc>
        ///     Returns number of child nodes.
        /// </devdoc>
        public int GetNodeCount(bool includeSubTrees) {
            int total = childCount;
            if (includeSubTrees) {
                for (int i = 0; i < childCount; i++)
                    total += children[i].GetNodeCount(true);
            }
            return total;
        }

        /// <include file='doc\TreeNode.uex' path='docs/doc[@for="TreeNode.InsertNodeAt"]/*' />
        /// <devdoc>
        ///     Helper function to add node at a given index after all validation has been done
        /// </devdoc>
        /// <internalonly/>
        internal void InsertNodeAt(int index, TreeNode node) {
            EnsureCapacity();
            node.parent = this;
            node.index = index;
            for (int i = childCount; i > index; --i) {
                (children[i] = children[i-1]).index = i;
            }
            children[index] = node;
            childCount++;
            node.Realize();

            if (TreeView != null && node == TreeView.selectedNode)
                TreeView.SelectedNode = node; // communicate this to the handle
        }

        /// <include file='doc\TreeNode.uex' path='docs/doc[@for="TreeNode.InvalidateHostTree"]/*' />
        /// <devdoc>
        ///     Invalidates the treeview control that is hosting this node
        /// </devdoc>
        private void InvalidateHostTree() {
            if (treeView != null && treeView.IsHandleCreated) treeView.Invalidate();
        }

        /// <include file='doc\TreeNode.uex' path='docs/doc[@for="TreeNode.Realize"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        internal void Realize() {
            // Debug.assert(handle == 0, "Node already realized");
            TreeView tv = TreeView;
            if (tv == null || !tv.IsHandleCreated)
                return;

            if (parent != null) { // Never realize the virtual root

                if (tv.InvokeRequired) {
                    throw new InvalidOperationException(SR.GetString(SR.InvalidCrossThreadControlCall));
                }

                NativeMethods.TV_INSERTSTRUCT tvis = new NativeMethods.TV_INSERTSTRUCT();
                tvis.item_mask = insertMask;
                tvis.hParent = parent.handle;
                TreeNode prev = PrevNode;
                if (prev == null) {
                    tvis.hInsertAfter = (IntPtr)NativeMethods.TVI_FIRST;
                }
                else {
                    tvis.hInsertAfter = prev.handle;
                    // Debug.assert(tvis.hInsertAfter != 0);
                }
                tvis.item_pszText = Marshal.StringToHGlobalAuto(text);
                tvis.item_iImage = (imageIndex==-1)? tv.imageIndex: imageIndex;
                tvis.item_iSelectedImage = (selectedImageIndex==-1)? tv.selectedImageIndex: selectedImageIndex;
                tvis.item_mask = NativeMethods.TVIF_TEXT;
                tvis.item_stateMask = 0;
                tvis.item_state = 0;
                if (tv.CheckBoxes) {
                    tvis.item_mask |= NativeMethods.TVIF_STATE;
                    tvis.item_stateMask |= NativeMethods.TVIS_STATEIMAGEMASK;
                    tvis.item_state |= isChecked ? CHECKED : UNCHECKED;
                }
                if (tvis.item_iImage >= 0) tvis.item_mask |= NativeMethods.TVIF_IMAGE;
                if (tvis.item_iSelectedImage >= 0) tvis.item_mask |= NativeMethods.TVIF_SELECTEDIMAGE;

                // If you are editing when you add a new node, then the edit control
                // gets placed in the wrong place. You must restore the edit mode
                // asynchronously (PostMessage) after the add is complete
                // to get the expected behavior.
                //
                bool editing = false;
                IntPtr editHandle = UnsafeNativeMethods.SendMessage(new HandleRef(TreeView, TreeView.Handle), NativeMethods.TVM_GETEDITCONTROL, 0, 0);
                if (editHandle != IntPtr.Zero) {
                    // currently editing...
                    //
                    editing = true;
                    UnsafeNativeMethods.SendMessage(new HandleRef(TreeView, TreeView.Handle), NativeMethods.TVM_ENDEDITLABELNOW, 0 /* fCancel==FALSE */, 0); 
                }

                handle = UnsafeNativeMethods.SendMessage(new HandleRef(TreeView, TreeView.Handle), NativeMethods.TVM_INSERTITEM, 0, ref tvis);
                tv.nodeTable[handle] = this;
                Marshal.FreeHGlobal(tvis.item_pszText);
                
                if (editing) {
                    UnsafeNativeMethods.PostMessage(new HandleRef(TreeView, TreeView.Handle), NativeMethods.TVM_EDITLABEL, IntPtr.Zero, handle); 
                }
                
                SafeNativeMethods.InvalidateRect(new HandleRef(tv, tv.Handle), null, false);
            }

            for (int i = 0; i < childCount; ++i)
                children[i].Realize();

            // If node expansion was requested before the handle was created,
            // we can expand it now.
            if (expandOnRealization) {
                Expand();
            }
        }

        /// <include file='doc\TreeNode.uex' path='docs/doc[@for="TreeNode.Remove"]/*' />
        /// <devdoc>
        ///     Remove this node from the TreeView control.  Child nodes are also removed from the
        ///     TreeView, but are still attached to this node.
        /// </devdoc>
        public void Remove() {
            Remove(true);
        }

        /// <include file='doc\TreeNode.uex' path='docs/doc[@for="TreeNode.Remove1"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        internal void Remove(bool notify) {
            bool expanded = IsExpanded;
            // unlink our children
            // REVIEW: (patkr) we shouldn't dismantle the whole subtree below us though.
            //         But we need to null out their handles
            for (int i = 0; i < childCount; i++)
                children[i].Remove(false);
            // children = null;

            // unrealize ourself
            if (handle != IntPtr.Zero) {
                if (notify && TreeView.IsHandleCreated)
                    UnsafeNativeMethods.SendMessage(new HandleRef(TreeView, TreeView.Handle), NativeMethods.TVM_DELETEITEM, 0, handle);
                treeView.nodeTable.Remove(handle);
                handle = IntPtr.Zero;
                // Expand when we are realized the next time.
                expandOnRealization = expanded;
            }

            // unlink ourself
            if (notify) {
                for (int i = index; i < parent.childCount-1; ++i) {
                    (parent.children[i] = parent.children[i+1]).index = i;
                }
                parent.childCount--;
                parent = null;
            }
            treeView = null;
        }

        /// <include file='doc\TreeNode.uex' path='docs/doc[@for="TreeNode.RemovePropBagIfEmpty"]/*' />
        /// <devdoc>
        ///     Removes the propBag object if it's now devoid of useful data
        /// </devdoc>
        /// <internalonly/>
        private void RemovePropBagIfEmpty() {
            if (propBag==null) return;
            if (propBag.IsEmpty()) propBag = null;
            return;
        }

        private void ResetExpandedState(TreeView tv) {
            Debug.Assert(tv.IsHandleCreated, "nonexistent handle");

            NativeMethods.TV_ITEM item = new NativeMethods.TV_ITEM();
            item.mask = NativeMethods.TVIF_HANDLE | NativeMethods.TVIF_STATE;
            item.hItem = handle;
            item.stateMask = NativeMethods.TVIS_EXPANDEDONCE;
            item.state = 0;
            UnsafeNativeMethods.SendMessage(new HandleRef(tv, tv.Handle), NativeMethods.TVM_SETITEM, 0, ref item);
        }

        /// <include file='doc\TreeNode.uex' path='docs/doc[@for="TreeNode.Toggle"]/*' />
        /// <devdoc>
        ///     Toggle the state of the node. Expand if collapsed or collapse if
        ///     expanded.
        /// </devdoc>
        public void Toggle() {
            Debug.Assert(parent != null, "toggle on virtual root");

            // I don't use the TVE_TOGGLE message 'cuz Windows TreeView doesn't send the appropriate
            // notifications when collapsing.
            if (IsExpanded) {
                Collapse();
            }
            else {
                Expand();
            }
        }

        
        /// <include file='doc\TreeNode.uex' path='docs/doc[@for="TreeNode.ToString"]/*' />
        /// <devdoc>
        ///     Returns the label text for the tree node
        /// </devdoc>
        public override string ToString() {
            return "TreeNode: " + (text == null ? "" : text);
        }

        /// <include file='doc\TreeNode.uex' path='docs/doc[@for="TreeNode.UpdateNode"]/*' />
        /// <devdoc>
        ///     Tell the TreeView to refresh this node
        /// </devdoc>
        private void UpdateNode(int mask) {
            if (handle == IntPtr.Zero) return;
            TreeView tv = TreeView;
            Debug.Assert(tv != null, "TreeNode has handle but no TreeView");

            NativeMethods.TV_ITEM item = new NativeMethods.TV_ITEM();
            item.mask = NativeMethods.TVIF_HANDLE | mask;
            item.hItem = handle;
            if ((mask & NativeMethods.TVIF_TEXT) != 0)
                item.pszText = Marshal.StringToHGlobalAuto(text);
            if ((mask & NativeMethods.TVIF_IMAGE) != 0)
                item.iImage = (imageIndex == -1) ? tv.imageIndex: imageIndex;
            if ((mask & NativeMethods.TVIF_SELECTEDIMAGE) != 0)
                item.iSelectedImage = (selectedImageIndex == -1) ? tv.selectedImageIndex: selectedImageIndex;
            UnsafeNativeMethods.SendMessage(new HandleRef(tv, tv.Handle), NativeMethods.TVM_SETITEM, 0, ref item);
            if ((mask & NativeMethods.TVIF_TEXT) != 0) {
                Marshal.FreeHGlobal(item.pszText);
                if (tv.Scrollable)
                    tv.ForceScrollbarUpdate(false);
            }
        }

        /// <include file='doc\TreeNode.uex' path='docs/doc[@for="TreeNode.ISerializable.GetObjectData"]/*' />
        /// <devdoc>
        /// ISerializable private implementation
        /// </devdoc>
        /// <internalonly/>
        void ISerializable.GetObjectData(SerializationInfo si, StreamingContext context) {
            if (propBag != null) {
                si.AddValue("PropBag", propBag, typeof(OwnerDrawPropertyBag));
            }

            si.AddValue("Text", text);
            si.AddValue("IsChecked", isChecked);
            si.AddValue("ImageIndex", imageIndex);
            si.AddValue("SelectedImageIndex", selectedImageIndex);
            si.AddValue("ChildCount",  childCount);
            
            if (childCount > 0) {
                for (int i = 0; i < childCount; i++) {
                    si.AddValue("children" + i, children[i], typeof(TreeNode));
                }
            }
            
            if (userData != null && userData.GetType().IsSerializable) {
                si.AddValue("UserData", userData, userData.GetType());
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\treeviewaction.cs ===
//------------------------------------------------------------------------------
// <copyright file="TreeViewAction.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------


/*
 */
namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    using System.Drawing;
    using Microsoft.Win32;


    /// <include file='doc\TreeViewAction.uex' path='docs/doc[@for="TreeViewAction"]/*' />
    /// <devdoc>
    ///     This enum is used to specify the action that caused a TreeViewEventArgs.
    /// </devdoc>
    public enum TreeViewAction {

        /// <include file='doc\TreeViewAction.uex' path='docs/doc[@for="TreeViewAction.Unknown"]/*' />
        /// <devdoc>
        ///     The action is unknown.
        /// </devdoc>
        Unknown = 0,

        /// <include file='doc\TreeViewAction.uex' path='docs/doc[@for="TreeViewAction.ByKeyboard"]/*' />
        /// <devdoc>
        ///     The event was caused by a keystroke.
        /// </devdoc>
        ByKeyboard = 1,

        /// <include file='doc\TreeViewAction.uex' path='docs/doc[@for="TreeViewAction.ByMouse"]/*' />
        /// <devdoc>
        ///     The event was caused by a mouse click.
        /// </devdoc>
        ByMouse = 2,
        
        /// <include file='doc\TreeViewAction.uex' path='docs/doc[@for="TreeViewAction.Collapse"]/*' />
        /// <devdoc>
        ///     The tree node is collapsing.
        /// </devdoc>
        Collapse = 3,
        
        /// <include file='doc\TreeViewAction.uex' path='docs/doc[@for="TreeViewAction.Expand"]/*' />
        /// <devdoc>
        ///     The tree node is expanding.
        /// </devdoc>
        Expand = 4,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\treenodeconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="TreeNodeConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;

    using Microsoft.Win32;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design.Serialization;
    using System.Drawing;
    using System.Diagnostics;
    using System.Globalization;
    using System.Reflection;

    /// <include file='doc\TreeNodeConverter.uex' path='docs/doc[@for="TreeNodeConverter"]/*' />
    /// <devdoc>
    ///      TreeNodeConverter is a class that can be used to convert
    ///      TreeNode objects from one data type to another.  Access this
    ///      class through the TypeDescriptor.
    /// </devdoc>
    public class TreeNodeConverter : TypeConverter {
    
        /// <include file='doc\TreeNodeConverter.uex' path='docs/doc[@for="TreeNodeConverter.CanConvertTo"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether this converter can
        ///       convert an object to the given destination type using the context.</para>
        /// </devdoc>
        public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType) {
            if (destinationType == typeof(InstanceDescriptor)) {
                return true;
            }
            return base.CanConvertTo(context, destinationType);
        }
        
        /// <include file='doc\TreeNodeConverter.uex' path='docs/doc[@for="TreeNodeConverter.ConvertTo"]/*' />
        /// <devdoc>
        ///      Converts the given object to another type.  The most common types to convert
        ///      are to and from a string object.  The default implementation will make a call
        ///      to ToString on the object if the object is valid and if the destination
        ///      type is string.  If this cannot convert to the desitnation type, this will
        ///      throw a NotSupportedException.
        /// </devdoc>
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == null) {
                throw new ArgumentNullException("destinationType");
            }

            if (destinationType == typeof(InstanceDescriptor) && value is TreeNode) {
                TreeNode node = (TreeNode)value;
                MemberInfo info = null;
                object[] args = null;
                
                if (node.ImageIndex == -1 || node.SelectedImageIndex == -1) {
                    if (node.Nodes.Count == 0) {
                        info = typeof(TreeNode).GetConstructor(new Type[] {typeof(string)});
                        args = new object[] {node.Text};
                    }
                    else {
                        info = typeof(TreeNode).GetConstructor(new Type[] {typeof(string), typeof(TreeNode[])});
                        
                        TreeNode[] nodesArray = new TreeNode[node.Nodes.Count];
                        node.Nodes.CopyTo(nodesArray, 0);
                        
                        args = new object[] {node.Text, nodesArray};
                    }
                }
                else {
                    if (node.Nodes.Count == 0) {
                        info = typeof(TreeNode).GetConstructor(new Type[] {
                            typeof(string),
                            typeof(int),
                            typeof(int)});
                        args = new object[] {
                            node.Text,
                            node.ImageIndex,
                            node.SelectedImageIndex};
                    }
                    else {
                        info = typeof(TreeNode).GetConstructor(new Type[] {
                            typeof(string),
                            typeof(int),
                            typeof(int),
                            typeof(TreeNode[])});
                            
                        TreeNode[] nodesArray = new TreeNode[node.Nodes.Count];
                        node.Nodes.CopyTo(nodesArray, 0);    
                            
                        args = new object[] {
                            node.Text,
                            node.ImageIndex,
                            node.SelectedImageIndex,
                            nodesArray};
                    }
                }
                
                if (info != null) {
                    return new InstanceDescriptor(info, args);
                }
            }
            
            return base.ConvertTo(context, culture, value, destinationType);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\treeviewcancelevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="TreeViewCancelEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    using System.Drawing;
    using Microsoft.Win32;


    /// <include file='doc\TreeViewCancelEvent.uex' path='docs/doc[@for="TreeViewCancelEventArgs"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides data for the <see cref='System.Windows.Forms.TreeView.OnBeforeCheck'/>,
    ///    <see cref='System.Windows.Forms.TreeView.OnBeforeCollapse'/>,
    ///    <see cref='System.Windows.Forms.TreeView.OnBeforeExpand'/>,
    ///       or <see cref='System.Windows.Forms.TreeView.OnBeforeSelect'/> event.
    ///
    ///    </para>
    /// </devdoc>
    public class TreeViewCancelEventArgs : CancelEventArgs {
        private TreeNode node;
        private TreeViewAction action;

        /// <include file='doc\TreeViewCancelEvent.uex' path='docs/doc[@for="TreeViewCancelEventArgs.TreeViewCancelEventArgs"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public TreeViewCancelEventArgs(TreeNode node, bool cancel, TreeViewAction action)
        : base(cancel) {
            this.node = node;                                           
            this.action = action;
        }

        /// <include file='doc\TreeViewCancelEvent.uex' path='docs/doc[@for="TreeViewCancelEventArgs.Node"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public TreeNode Node {
            get {
                return node;
            }
        }
        
        /// <include file='doc\TreeViewCancelEvent.uex' path='docs/doc[@for="TreeViewCancelEventArgs.Action"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public TreeViewAction Action {
            get {
                return action;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\treeviewcanceleventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="TreeViewCancelEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;


    /// <include file='doc\TreeViewCancelEventHandler.uex' path='docs/doc[@for="TreeViewCancelEventHandler"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents the method that will
    ///       handle the <see cref='System.Windows.Forms.TreeView.OnBeforeCheck'/>, <see cref='System.Windows.Forms.TreeView.OnBeforeCollapse'/>, <see cref='System.Windows.Forms.TreeView.BeforeExpand'/>, or <see cref='System.Windows.Forms.TreeView.BeforeSelect'/> event of a <see cref='System.Windows.Forms.TreeView'/>
    ///       .
    ///       
    ///    </para>
    /// </devdoc>
    public delegate void TreeViewCancelEventHandler(object sender, TreeViewCancelEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\treeviewevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="TreeViewEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    using System.Drawing;
    using Microsoft.Win32;


    /// <include file='doc\TreeViewEvent.uex' path='docs/doc[@for="TreeViewEventArgs"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides data for the <see cref='System.Windows.Forms.TreeView.OnAfterCheck'/>, <see cref='System.Windows.Forms.TreeView.AfterCollapse'/>, <see cref='System.Windows.Forms.TreeView.AfterExpand'/>, or <see cref='System.Windows.Forms.TreeView.AfterSelect'/> event.
    ///    </para>
    /// </devdoc>
    public class TreeViewEventArgs : EventArgs {
        TreeNode node;
        TreeViewAction action = TreeViewAction.Unknown;
        
        /// <include file='doc\TreeViewEvent.uex' path='docs/doc[@for="TreeViewEventArgs.TreeViewEventArgs"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public TreeViewEventArgs(TreeNode node) {
            this.node = node;
        }
        
        /// <include file='doc\TreeViewEvent.uex' path='docs/doc[@for="TreeViewEventArgs.TreeViewEventArgs1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public TreeViewEventArgs(TreeNode node, TreeViewAction action) {
            this.node = node;                                           
            this.action = action;
        }
        
        /// <include file='doc\TreeViewEvent.uex' path='docs/doc[@for="TreeViewEventArgs.Node"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public TreeNode Node {
            get {
                return node;
            }
        }

        /// <include file='doc\TreeViewEvent.uex' path='docs/doc[@for="TreeViewEventArgs.Action"]/*' />
        /// <devdoc>
        ///      An event specific action-flag.
        /// </devdoc>
        public TreeViewAction Action {
            get {
                return action;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\triangle.cs ===
//------------------------------------------------------------------------------
// <copyright file="Triangle.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;
    using System;
    
    using System.Windows.Forms;
    using System.Drawing;
    using Microsoft.Win32;

    /// <include file='doc\Triangle.uex' path='docs/doc[@for="Triangle"]/*' />
    /// <devdoc>
    ///      This class fully encapsulates the painting logic for a triangle.  (Used by DataGrid)
    /// </devdoc>
    internal class Triangle {
        private const double TRI_HEIGHT_RATIO = 2.5;
        private const double TRI_WIDTH_RATIO  = 0.8;

        public static void Paint(Graphics g, Rectangle bounds, TriangleDirection dir, Brush backBr, Pen backPen) {
            Paint(g, bounds, dir, backBr, backPen, true);
        }

        public static void Paint(Graphics g, Rectangle bounds, TriangleDirection dir,
                                  Brush backBr, Pen backPen, bool opaque) {
            // build an equilateral triangle centered on the midpoint of the rect.
            Point[] points = BuildTrianglePoints(dir, bounds);

            if (opaque)
                g.FillPolygon(backBr, points);
            g.DrawPolygon(backPen, points);
        }

        public static void Paint(Graphics g, Rectangle bounds, TriangleDirection dir, Brush backBr,
                                 Pen backPen1, Pen backPen2, Pen backPen3, bool opaque)
        {
            // build an equilateral triangle centered on the midpoint of the rect.
            Point[] points = BuildTrianglePoints(dir, bounds);

            g.DrawLine(backPen1, points[0], points[1]);
            g.DrawLine(backPen2, points[1], points[2]);
            g.DrawLine(backPen3, points[2], points[0]);
        }

        private static Point[] BuildTrianglePoints(TriangleDirection dir,
                                                    Rectangle bounds)
        {
            Point[] points = new Point[3];

            int updnWidth =(int)(bounds.Width * TRI_WIDTH_RATIO);
            if (updnWidth % 2 == 1)
                updnWidth++;
            int updnHeight =(int)Math.Ceiling((updnWidth/2) * TRI_HEIGHT_RATIO);

            int lrWidth =(int)(bounds.Height * TRI_WIDTH_RATIO);
            if (lrWidth % 2 == 0)
                lrWidth++;
            int lrHeight =(int)Math.Ceiling((lrWidth/2) * TRI_HEIGHT_RATIO);

            switch (dir) {
                case TriangleDirection.Up:
                    {
                        points[0] = new Point(0, updnHeight);
                        points[1] = new Point(updnWidth, updnHeight);
                        points[2] = new Point(updnWidth / 2, 0);
                    }
                    break;
                case TriangleDirection.Down:
                    {
                        points[0] = new Point(0, 0);
                        points[1] = new Point(updnWidth, 0);
                        points[2] = new Point(updnWidth / 2, updnHeight);
                    }
                    break;
                case TriangleDirection.Left:
                    {
                        points[0] = new Point(lrWidth, 0);
                        points[1] = new Point(lrWidth, lrHeight);
                        points[2] = new Point(0, lrHeight / 2);
                    }
                    break;
                case TriangleDirection.Right:
                    {
                        points[0] = new Point(0, 0);
                        points[1] = new Point(0, lrHeight);
                        points[2] = new Point(lrWidth, lrHeight / 2);
                    }
                    break;
                default:
                    Debug.Fail("Wrong triangle enum");
                    break;
            }

            // we need to center our triangles into the bounds given.
            // NOTE: On the up/down case, the offsets are different!
            switch (dir) {
                case TriangleDirection.Up:
                case TriangleDirection.Down:
                    OffsetPoints(points,
                                  bounds.X +(bounds.Width - updnHeight)/2,
                                  bounds.Y +(bounds.Height - updnWidth)/2);
                    break;
                case TriangleDirection.Left:
                case TriangleDirection.Right:
                    OffsetPoints(points,
                                  bounds.X +(bounds.Width - lrWidth)/2,
                                  bounds.Y +(bounds.Height - lrHeight)/2);
                    break;
            }
            return points;
        }

        private static void OffsetPoints(Point[] points, int xOffset, int yOffset) {
            for (int i = 0; i < points.Length; i++) {
                points[i].X += xOffset;
                points[i].Y += yOffset;
            }
        }
    }

    /// <include file='doc\Triangle.uex' path='docs/doc[@for="TriangleDirection"]/*' />
    /// <internalonly/>
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    internal enum TriangleDirection {
        /// <include file='doc\Triangle.uex' path='docs/doc[@for="TriangleDirection.Up"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Up,
        /// <include file='doc\Triangle.uex' path='docs/doc[@for="TriangleDirection.Down"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Down,
        /// <include file='doc\Triangle.uex' path='docs/doc[@for="TriangleDirection.Left"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Left,
        /// <include file='doc\Triangle.uex' path='docs/doc[@for="TriangleDirection.Right"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Right
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\treevieweventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="TreeViewEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;


    /// <include file='doc\TreeViewEventHandler.uex' path='docs/doc[@for="TreeViewEventHandler"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents the method that will handle the <see cref='System.Windows.Forms.TreeView.OnAfterCheck'/>, <see cref='System.Windows.Forms.TreeView.OnAfterCollapse'/>, <see cref='System.Windows.Forms.TreeView.OnAfterExpand'/>, or <see cref='System.Windows.Forms.TreeView.OnAfterSelect'/>
    ///       event of a <see cref='System.Windows.Forms.TreeView'/>
    ///       .
    ///    </para>
    /// </devdoc>
    public delegate void TreeViewEventHandler(object sender, TreeViewEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\treeviewimageindexconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="TreeViewImageIndexConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {
    
    /// <include file='doc\TreeViewImageIndexConverter.uex' path='docs/doc[@for="TreeViewImageIndexConverter"]/*' />
    /// <devdoc>
    ///      TreeViewImageIndexConverter is a class that can be used to convert
    ///      image index values one data type to another.
    /// </devdoc>
    public class TreeViewImageIndexConverter : ImageIndexConverter {

        /// <include file='doc\TreeViewImageIndexConverter.uex' path='docs/doc[@for="TreeViewImageIndexConverter.IncludeNoneAsStandardValue"]/*' />
        protected override bool IncludeNoneAsStandardValue {
            get {
                return false;
            }
        }                                
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\uicuesevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="UICuesEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {
    /// <include file='doc\UICuesEvent.uex' path='docs/doc[@for="UICues"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies UI state.
    ///    </para>
    /// </devdoc>
    [Flags]
    public enum UICues {
    
        /// <include file='doc\UICuesEvent.uex' path='docs/doc[@for="UICues.ShowFocus"]/*' />
        /// <devdoc>
        ///     Focus rectangles are shown after the change.
        /// </devdoc>
        ShowFocus = 0x01,
        
        /// <include file='doc\UICuesEvent.uex' path='docs/doc[@for="UICues.ShowKeyboard"]/*' />
        /// <devdoc>
        ///     Keyboard cues are underlined after the change.
        /// </devdoc>
        ShowKeyboard = 0x02,
        
        /// <include file='doc\UICuesEvent.uex' path='docs/doc[@for="UICues.Shown"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Shown = ShowFocus | ShowKeyboard,
        
        /// <include file='doc\UICuesEvent.uex' path='docs/doc[@for="UICues.ChangeFocus"]/*' />
        /// <devdoc>
        ///     The state of the focus cues has changed.
        /// </devdoc>
        ChangeFocus = 0x04,
        
        /// <include file='doc\UICuesEvent.uex' path='docs/doc[@for="UICues.ChangeKeyboard"]/*' />
        /// <devdoc>
        ///     The state of the keyboard cues has changed.
        /// </devdoc>
        ChangeKeyboard = 0x08,
        
        /// <include file='doc\UICuesEvent.uex' path='docs/doc[@for="UICues.Changed"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Changed = ChangeFocus | ChangeKeyboard,
        
        /// <include file='doc\UICuesEvent.uex' path='docs/doc[@for="UICues.None"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        None = 0x00,
    }

    /// <include file='doc\UICuesEvent.uex' path='docs/doc[@for="UICuesEventArgs"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides data for the <see cref='System.Windows.Forms.Control.ChangeUICues'/> event.
    ///    </para>
    /// </devdoc>
    public class UICuesEventArgs : EventArgs {
        
        private readonly UICues uicues;
        
        /// <include file='doc\UICuesEvent.uex' path='docs/doc[@for="UICuesEventArgs.UICuesEventArgs"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public UICuesEventArgs(UICues uicues) {
            this.uicues = uicues;
        }
        
        /// <include file='doc\UICuesEvent.uex' path='docs/doc[@for="UICuesEventArgs.ShowFocus"]/*' />
        /// <devdoc>
        ///     Focus rectangles are shown after the change.
        /// </devdoc>
        public bool ShowFocus {
            get {
                return (uicues & UICues.ShowFocus) != 0;
            }
        }
           
        /// <include file='doc\UICuesEvent.uex' path='docs/doc[@for="UICuesEventArgs.ShowKeyboard"]/*' />
        /// <devdoc>
        ///     Keyboard cues are underlined after the change.
        /// </devdoc>
        public bool ShowKeyboard {
            get {
                return (uicues & UICues.ShowKeyboard) != 0;
            }
        }
        
        /// <include file='doc\UICuesEvent.uex' path='docs/doc[@for="UICuesEventArgs.ChangeFocus"]/*' />
        /// <devdoc>
        ///     The state of the focus cues has changed.
        /// </devdoc>
        public bool ChangeFocus {
            get {
                return (uicues & UICues.ChangeFocus) != 0;
            }
        }
        
        /// <include file='doc\UICuesEvent.uex' path='docs/doc[@for="UICuesEventArgs.ChangeKeyboard"]/*' />
        /// <devdoc>
        ///     The state of the keyboard cues has changed.
        /// </devdoc>
        public bool ChangeKeyboard {
            get {
                return (uicues & UICues.ChangeKeyboard) != 0;
            }
        }
        
        /// <include file='doc\UICuesEvent.uex' path='docs/doc[@for="UICuesEventArgs.Changed"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public UICues Changed {
            get {
                return (uicues & UICues.Changed);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\uicueseventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="UICuesEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {    
    /// <include file='doc\UICuesEventHandler.uex' path='docs/doc[@for="UICuesEventHandler"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a method that will handle the <see cref='System.Windows.Forms.Control.ChangeUICues'/> event of a <see cref='System.Windows.Forms.Control'/>.
    ///    </para>
    /// </devdoc>
    public delegate void UICuesEventHandler(object sender, UICuesEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\updownevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="UpDownEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------


namespace System.Windows.Forms {

    using System.Diagnostics;
    using System;

    /// <include file='doc\UpDownEvent.uex' path='docs/doc[@for="UpDownEventArgs"]/*' />
    /// <internalonly/>
    /// <devdoc>
    ///    <para>
    ///       Provides data for the UpDownEvent
    ///    </para>
    /// </devdoc>
    public class UpDownEventArgs : EventArgs {

        int buttonID;

        /// <include file='doc\UpDownEvent.uex' path='docs/doc[@for="UpDownEventArgs.UpDownEventArgs"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public UpDownEventArgs(int buttonPushed) {
            buttonID = buttonPushed;
        }

        /// <include file='doc\UpDownEvent.uex' path='docs/doc[@for="UpDownEventArgs.ButtonID"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int ButtonID {
            get {
                return buttonID;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\updowneventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="UpDownEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;
    using System;

    /// <include file='doc\UpDownEventHandler.uex' path='docs/doc[@for="UpDownEventHandler"]/*' />
    /// <internalonly/>
    /// <devdoc>
    ///    <para>
    ///       UpDownEventHandler
    ///       A delegate for an updown event handler.
    ///    </para>
    /// </devdoc>
    public delegate void UpDownEventHandler(object source, UpDownEventArgs e);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\unsafenativemethods.cs ===
//------------------------------------------------------------------------------
// <copyright file="UnsafeNativeMethods.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {
    using Accessibility;
    using System.Runtime.InteropServices;
    using System;
    using System.Security.Permissions;
    using System.Collections;
    using System.IO;
    using System.Text;
    using System.Security;

    [
    SuppressUnmanagedCodeSecurity()
    ]
    internal class UnsafeNativeMethods {
        [DllImport(ExternDll.Ole32)]
        public static extern int ReadClassStg(HandleRef pStg, [In, Out] ref Guid pclsid);

        [DllImport(ExternDll.User32)]
        public static extern int GetClassName(HandleRef hwnd, StringBuilder lpClassName, int nMaxCount);

        [DllImport(ExternDll.Ole32, ExactSpelling=true, PreserveSig=false)]
        public static extern UnsafeNativeMethods.IClassFactory2 CoGetClassObject(
            [In]
            ref Guid clsid,
            int dwContext,
            int serverInfo,
            [In]
            ref Guid refiid);

        [return: MarshalAs(UnmanagedType.Interface)][DllImport(ExternDll.Ole32, ExactSpelling=true, PreserveSig=false)]
        public static extern object CoCreateInstance(
            [In]
            ref Guid clsid,
            [MarshalAs(UnmanagedType.Interface)]
            object punkOuter,
            int context,
            [In]
            ref Guid iid);


        private struct POINTSTRUCT {
            public int x;
            public int y;

            public POINTSTRUCT(int x, int y) {
                this.x = x;
                this.y = y;
            }
        }
        
        [DllImport(ExternDll.Comdlg32, CharSet=CharSet.Auto, SetLastError=true)]
        public static extern bool PageSetupDlg([In, Out] NativeMethods.PAGESETUPDLG lppsd);
        [DllImport(ExternDll.Comdlg32, CharSet=CharSet.Auto, SetLastError=true)]
        public static extern bool PrintDlg([In, Out] NativeMethods.PRINTDLG lppd);
        [DllImport(ExternDll.Ole32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern int OleGetClipboard([In, Out] ref UnsafeNativeMethods.IOleDataObject data);
        [DllImport(ExternDll.Ole32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern int OleSetClipboard(UnsafeNativeMethods.IOleDataObject pDataObj);
        [DllImport(ExternDll.Ole32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern int OleFlushClipboard();
        [DllImport(ExternDll.Olepro32, ExactSpelling=true)]
        public static extern void OleCreatePropertyFrameIndirect(OCPFIPARAMS p);
        [DllImport(ExternDll.Oleaut32, ExactSpelling=true)]
        public static extern int VarFormat(ref object pvarIn, HandleRef pstrFormat, int iFirstDay, int iFirstWeek, uint dwFlags, [In, Out]ref IntPtr pbstr);
        [DllImport(ExternDll.Shell32, CharSet=CharSet.Auto)]
        public static extern int DragQueryFile(HandleRef hDrop, int iFile, StringBuilder lpszFile, int cch);
        [DllImport(ExternDll.User32, ExactSpelling=true)]
        public static extern bool EnumChildWindows(HandleRef hwndParent, NativeMethods.EnumChildrenCallback lpEnumFunc, HandleRef lParam);
        [DllImport(ExternDll.Shell32, CharSet=CharSet.Auto)]
        public static extern IntPtr ShellExecute(HandleRef hwnd, string lpOperation, string lpFile, string lpParameters, string lpDirectory, int nShowCmd);
        [DllImport(ExternDll.Shell32, CharSet=CharSet.Auto, EntryPoint="ShellExecute", BestFitMapping = false)]
        public static extern IntPtr ShellExecute_NoBFM(HandleRef hwnd, string lpOperation, string lpFile, string lpParameters, string lpDirectory, int nShowCmd);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto, SetLastError=true)]
        public static extern int SetScrollPos(HandleRef hWnd, int nBar, int nPos, bool bRedraw);
        [DllImport(ExternDll.User32, ExactSpelling=true)]
        public static extern bool EnumChildWindows(HandleRef hwndParent, NativeMethods.EnumChildrenProc lpEnumFunc, HandleRef lParam);
        [DllImport(ExternDll.Shell32, CharSet=CharSet.Auto)]
        public static extern int Shell_NotifyIcon(int message, NativeMethods.NOTIFYICONDATA pnid);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public extern static bool InsertMenuItem(HandleRef hMenu, int uItem, bool fByPosition, NativeMethods.MENUITEMINFO_T lpmii);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern bool GetMenuItemInfo(HandleRef hMenu, int uItem, bool fByPosition, [In, Out] NativeMethods.MENUITEMINFO_T lpmii);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public extern static bool SetMenuItemInfo(HandleRef hMenu, int uItem, bool fByPosition, NativeMethods.MENUITEMINFO_T lpmii);
        [DllImport(ExternDll.User32, ExactSpelling=true, EntryPoint="CreateMenu", CharSet=CharSet.Auto)]
        private static extern IntPtr IntCreateMenu();
        public static IntPtr CreateMenu() {
            return HandleCollector.Add(IntCreateMenu(), NativeMethods.CommonHandles.Menu);
        }
        
        [DllImport(ExternDll.Comdlg32, CharSet=CharSet.Auto)]
        public static extern bool GetOpenFileName([In, Out] NativeMethods.OPENFILENAME_I ofn);

        [DllImport(ExternDll.Kernel32, ExactSpelling=true, CharSet=CharSet.Unicode)]
        public static extern int WideCharToMultiByte(int codePage, int flags, [MarshalAs(UnmanagedType.LPWStr)]string wideStr, int chars, [In,Out]byte[] pOutBytes, int bufferBytes, IntPtr defaultChar, IntPtr pDefaultUsed);


        [DllImport(ExternDll.Kernel32, ExactSpelling=true, EntryPoint="RtlMoveMemory", CharSet=CharSet.Unicode)]
        public static extern void CopyMemoryW(IntPtr pdst, string psrc, int cb);
        [DllImport(ExternDll.Kernel32, ExactSpelling=true, EntryPoint="RtlMoveMemory", CharSet=CharSet.Unicode)]
        public static extern void CopyMemoryW(IntPtr pdst, char[] psrc, int cb);
        [DllImport(ExternDll.Kernel32, ExactSpelling=true, EntryPoint="RtlMoveMemory", CharSet=CharSet.Unicode)]
        public static extern void CopyMemoryW(StringBuilder pdst, HandleRef psrc, int cb);
        [DllImport(ExternDll.Kernel32, ExactSpelling=true, EntryPoint="RtlMoveMemory", CharSet=CharSet.Unicode)]
        public static extern void CopyMemoryW(char[] pdst, HandleRef psrc, int cb);
        [DllImport(ExternDll.Kernel32, ExactSpelling=true, EntryPoint="RtlMoveMemory", CharSet=CharSet.Ansi)]
        public static extern void CopyMemoryA(IntPtr pdst, string psrc, int cb);
        [DllImport(ExternDll.Kernel32, ExactSpelling=true, EntryPoint="RtlMoveMemory", CharSet=CharSet.Ansi)]
        public static extern void CopyMemoryA(IntPtr pdst, char[] psrc, int cb);
        [DllImport(ExternDll.Kernel32, ExactSpelling=true, EntryPoint="RtlMoveMemory", CharSet=CharSet.Ansi)]
        public static extern void CopyMemoryA(StringBuilder pdst, HandleRef psrc, int cb);
        [DllImport(ExternDll.Kernel32, ExactSpelling=true, EntryPoint="RtlMoveMemory", CharSet=CharSet.Ansi)]
        public static extern void CopyMemoryA(char[] pdst, HandleRef psrc, int cb);

        [DllImport(ExternDll.Kernel32, ExactSpelling=true, EntryPoint="RtlMoveMemory")]
        public static extern void CopyMemory(IntPtr pdst, byte[] psrc, int cb);
        [DllImport(ExternDll.Kernel32, ExactSpelling=true, EntryPoint="RtlMoveMemory")]
        public static extern void CopyMemory(byte[] pdst, HandleRef psrc, int cb);
        [DllImport(ExternDll.Kernel32, ExactSpelling=true, EntryPoint="RtlMoveMemory")]
        public static extern void CopyMemory(IntPtr pdst, HandleRef psrc, int cb);
        [DllImport(ExternDll.Kernel32, ExactSpelling=true, EntryPoint="RtlMoveMemory")]
        public static extern void CopyMemory(IntPtr pdst, string psrc, int cb);
        [DllImport(ExternDll.Kernel32, ExactSpelling=true, EntryPoint="DuplicateHandle", SetLastError=true)]
        private static extern IntPtr IntDuplicateHandle(HandleRef processSource, HandleRef handleSource, HandleRef processTarget, ref IntPtr handleTarget, int desiredAccess, bool inheritHandle, int options);
        public static IntPtr DuplicateHandle(HandleRef processSource, HandleRef handleSource, HandleRef processTarget, ref IntPtr handleTarget, int desiredAccess, bool inheritHandle, int options) {
            IntPtr ret = IntDuplicateHandle(processSource, handleSource, processTarget, ref handleTarget,
                                         desiredAccess, inheritHandle, options);
            HandleCollector.Add(handleTarget, NativeMethods.CommonHandles.Kernel);
            return ret;
        }
        
        [DllImport(ExternDll.Ole32, PreserveSig=false)]
        public static extern UnsafeNativeMethods.IStorage StgOpenStorageOnILockBytes(UnsafeNativeMethods.ILockBytes iLockBytes, UnsafeNativeMethods.IStorage pStgPriority, int grfMode, int sndExcluded, int reserved);
        [DllImport(ExternDll.Ole32, PreserveSig=false)]
        public static extern IntPtr GetHGlobalFromILockBytes(UnsafeNativeMethods.ILockBytes pLkbyt);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern IntPtr SetWindowsHookEx(int hookid, NativeMethods.HookProc pfnhook, HandleRef hinst, int threadid);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern int GetKeyboardState(byte [] keystate);
        [DllImport(ExternDll.User32, ExactSpelling=true, EntryPoint="keybd_event", CharSet=CharSet.Auto)]
        public static extern void Keybd_event(byte vk, byte scan, int flags, int extrainfo);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern int SetKeyboardState(byte [] keystate);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern bool UnhookWindowsHookEx(HandleRef hhook);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern short GetAsyncKeyState(int vkey);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern IntPtr CallNextHookEx(HandleRef hhook, int code, IntPtr wparam, IntPtr lparam);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern int ScreenToClient( HandleRef hWnd, [In, Out] NativeMethods.POINT pt );
        [DllImport(ExternDll.Kernel32, CharSet=CharSet.Auto)]
        public static extern int GetModuleFileName(HandleRef hModule, StringBuilder buffer, int length);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern bool TranslateMessage([In, Out] ref NativeMethods.MSG msg);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern IntPtr DispatchMessage([In] ref NativeMethods.MSG msg);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Ansi)]
        public static extern IntPtr DispatchMessageA([In] ref NativeMethods.MSG msg);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Unicode)]
        public static extern IntPtr DispatchMessageW([In] ref NativeMethods.MSG msg);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern int PostThreadMessage(int id, int msg, IntPtr wparam, IntPtr lparam);
        [DllImport(ExternDll.Ole32, ExactSpelling=true)]
        public static extern int CoRegisterMessageFilter(HandleRef newFilter, ref IntPtr oldMsgFilter);
        [DllImport(ExternDll.Ole32, ExactSpelling=true, EntryPoint="OleInitialize", SetLastError=true)]
        private static extern int IntOleInitialize(int val);
        public static int OleInitialize() {
            return IntOleInitialize(0);
        }
        
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public extern static bool EnumThreadWindows(int dwThreadId, NativeMethods.EnumThreadWindowsCallback lpfn, HandleRef lParam);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public extern static IntPtr SendDlgItemMessage(HandleRef hDlg, int nIDDlgItem, int Msg, IntPtr wParam, IntPtr lParam);
        [DllImport(ExternDll.Ole32, ExactSpelling=true, CharSet=CharSet.Auto, SetLastError=true)]
        public static extern int OleUninitialize();
        [DllImport(ExternDll.Comdlg32, CharSet=CharSet.Auto)]
        public static extern bool GetSaveFileName([In, Out] NativeMethods.OPENFILENAME_I ofn);
        [DllImport(ExternDll.User32, EntryPoint="ChildWindowFromPointEx", ExactSpelling=true, CharSet=CharSet.Auto)]
        private static extern IntPtr _ChildWindowFromPointEx(HandleRef hwndParent, POINTSTRUCT pt, int uFlags);
        public static IntPtr ChildWindowFromPointEx(HandleRef hwndParent, int x, int y, int uFlags) {
            POINTSTRUCT ps = new POINTSTRUCT(x, y);
            return _ChildWindowFromPointEx(hwndParent, ps, uFlags);
        }
        [DllImport(ExternDll.Kernel32, EntryPoint="CloseHandle", ExactSpelling=true, CharSet=CharSet.Auto, SetLastError=true)]
        private static extern bool IntCloseHandle(HandleRef handle);
        public static bool CloseHandle(HandleRef handle) {
            HandleCollector.Remove((IntPtr)handle, NativeMethods.CommonHandles.Kernel);
            return IntCloseHandle(handle);
        }
        
        [DllImport(ExternDll.Gdi32, ExactSpelling=true, EntryPoint="CreateCompatibleDC", CharSet=CharSet.Auto)]
        private static extern IntPtr IntCreateCompatibleDC(HandleRef hDC);
        public static IntPtr CreateCompatibleDC(HandleRef hDC) {
            return HandleCollector.Add(IntCreateCompatibleDC(hDC), NativeMethods.CommonHandles.GDI);
        }
        
        [DllImport(ExternDll.User32, ExactSpelling=true, EntryPoint="GetDCEx", CharSet=CharSet.Auto)]
        private static extern IntPtr IntGetDCEx(HandleRef hWnd, HandleRef hrgnClip, int flags);
        public static IntPtr GetDCEx(HandleRef hWnd, HandleRef hrgnClip, int flags) {
            return HandleCollector.Add(IntGetDCEx(hWnd, hrgnClip, flags), NativeMethods.CommonHandles.HDC);
        }
        
        // GetObject stuff
        [DllImport(ExternDll.Gdi32, CharSet=CharSet.Auto)]
        public static extern int GetObject(HandleRef hObject, int nSize, [In, Out] NativeMethods.BITMAP bm);
        [DllImport(ExternDll.Gdi32, CharSet=CharSet.Auto)]
        public static extern int GetObject(HandleRef hObject, int nSize, [In, Out] NativeMethods.DIBSECTION ds);
        [DllImport(ExternDll.Gdi32, CharSet=CharSet.Auto)]
        public static extern int GetObject(HandleRef hObject, int nSize, [In, Out] NativeMethods.LOGPEN lp);
        public static int GetObject(HandleRef hObject, NativeMethods.LOGPEN lp) {
            return GetObject(hObject, Marshal.SizeOf(typeof(NativeMethods.LOGPEN)), lp);
        }
        
        [DllImport(ExternDll.Gdi32, CharSet=CharSet.Auto)]
        public static extern int GetObject(HandleRef hObject, int nSize, [In, Out] NativeMethods.LOGBRUSH lb);
        public static int GetObject(HandleRef hObject, NativeMethods.LOGBRUSH lb) {
            return GetObject(hObject, Marshal.SizeOf(typeof(NativeMethods.LOGBRUSH)), lb);
        }
        
        [DllImport(ExternDll.Gdi32, CharSet=CharSet.Auto)]
        public static extern int GetObject(HandleRef hObject, int nSize, [In, Out] NativeMethods.LOGFONT lf);
        public static int GetObject(HandleRef hObject, NativeMethods.LOGFONT lp) {
            return GetObject(hObject, Marshal.SizeOf(typeof(NativeMethods.LOGFONT)), lp);
        }
        
        //HPALETTE
        [DllImport(ExternDll.Gdi32, CharSet=CharSet.Auto)]
        public static extern int GetObject(HandleRef hObject, int nSize, ref int nEntries);
        [DllImport(ExternDll.Gdi32, CharSet=CharSet.Auto)]
        public static extern int GetObject(HandleRef hObject, int nSize, int[] nEntries);
        [DllImport(ExternDll.User32, EntryPoint="CreateAcceleratorTable", CharSet=CharSet.Auto)]
        private static extern IntPtr IntCreateAcceleratorTable(/*ACCEL*/ HandleRef pentries, int cCount);
        public static IntPtr CreateAcceleratorTable(/*ACCEL*/ HandleRef pentries, int cCount) {
            return HandleCollector.Add(IntCreateAcceleratorTable(pentries, cCount), NativeMethods.CommonHandles.Accelerator);
        }
        
        [DllImport(ExternDll.User32, ExactSpelling=true, EntryPoint="DestroyAcceleratorTable", CharSet=CharSet.Auto)]
        private static extern bool IntDestroyAcceleratorTable(HandleRef hAccel);
        public static bool DestroyAcceleratorTable(HandleRef hAccel) {
            HandleCollector.Remove((IntPtr)hAccel, NativeMethods.CommonHandles.Accelerator);
            return IntDestroyAcceleratorTable(hAccel);
        }

        [DllImport(ExternDll.Gdi32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern int GetObjectType(HandleRef hObject);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern short VkKeyScan(char key);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern IntPtr GetCapture();
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern IntPtr SetCapture(HandleRef hwnd);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern IntPtr GetFocus();
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern bool GetCursorPos([In, Out] NativeMethods.POINT pt);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern short GetKeyState(int keyCode);
        [DllImport(ExternDll.User32, ExactSpelling=true, EntryPoint="SetWindowRgn", CharSet=CharSet.Auto)]
        private static extern int IntSetWindowRgn(HandleRef hwnd, HandleRef hrgn, bool fRedraw);
        public static int SetWindowRgn(HandleRef hwnd, HandleRef hrgn, bool fRedraw) {
            if ((IntPtr)hrgn != IntPtr.Zero) {
                HandleCollector.Remove((IntPtr)hrgn, NativeMethods.CommonHandles.GDI);
            }
            return IntSetWindowRgn(hwnd, hrgn, fRedraw);
        }
        
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern int GetWindowText(HandleRef hWnd, StringBuilder lpString, int nMaxCount);
        
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern bool SetWindowText(HandleRef hWnd, string text);
        [DllImport(ExternDll.Kernel32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern IntPtr GlobalAlloc(int uFlags, int dwBytes);
        [DllImport(ExternDll.Kernel32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern IntPtr GlobalReAlloc(HandleRef handle, int bytes, int flags);
        [DllImport(ExternDll.Kernel32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern IntPtr GlobalLock(HandleRef handle);
        [DllImport(ExternDll.Kernel32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern bool GlobalUnlock(HandleRef handle);
        [DllImport(ExternDll.Kernel32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern IntPtr GlobalFree(HandleRef handle);
        [DllImport(ExternDll.Kernel32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern int GlobalSize(HandleRef handle);
        [DllImport(ExternDll.Imm32, CharSet=CharSet.Auto)]
        public static extern bool ImmSetConversionStatus(HandleRef hIMC, int conversion, int sentence);
        [DllImport(ExternDll.Imm32, CharSet=CharSet.Auto)]
        public static extern bool ImmGetConversionStatus(HandleRef hIMC, ref int conversion, ref int sentence);
        [DllImport(ExternDll.Imm32, CharSet=CharSet.Auto)]
        public static extern IntPtr ImmGetContext(HandleRef hWnd);
        [DllImport(ExternDll.Imm32, CharSet=CharSet.Auto)]
        public static extern bool ImmReleaseContext(HandleRef hWnd, HandleRef hIMC);
        [DllImport(ExternDll.Imm32, CharSet=CharSet.Auto)]
        public static extern IntPtr ImmAssociateContext(HandleRef hWnd, HandleRef hIMC);
        [DllImport(ExternDll.Imm32, CharSet=CharSet.Auto)]
        public static extern bool ImmDestroyContext(HandleRef hIMC);
        [DllImport(ExternDll.Imm32, CharSet=CharSet.Auto)]
        public static extern IntPtr ImmCreateContext();
        [DllImport(ExternDll.Imm32, CharSet=CharSet.Auto)]
        public static extern bool ImmSetOpenStatus(HandleRef hIMC, bool open);
        [DllImport(ExternDll.Imm32, CharSet=CharSet.Auto)]
        public static extern bool ImmGetOpenStatus(HandleRef hIMC);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern IntPtr SetFocus(HandleRef hWnd);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern IntPtr GetParent(HandleRef hWnd);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern bool IsChild(HandleRef hWndParent, HandleRef hwnd);
        [DllImport(ExternDll.User32, EntryPoint="ChildWindowFromPoint", ExactSpelling=true, CharSet=CharSet.Auto)]
        private static extern IntPtr _ChildWindowFromPoint(HandleRef hwndParent, POINTSTRUCT pt);
        public static IntPtr ChildWindowFromPoint(HandleRef hwndParent, int x, int y) {
            POINTSTRUCT ps = new POINTSTRUCT(x, y);
            return _ChildWindowFromPoint(hwndParent, ps);
        }
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern IntPtr FindWindow(string className, string windowName);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern int MapWindowPoints(HandleRef hWndFrom, HandleRef hWndTo, [In, Out] ref NativeMethods.RECT rect, int cPoints);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern int MapWindowPoints(HandleRef hWndFrom, HandleRef hWndTo, [In, Out] NativeMethods.POINT pt, int cPoints);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern IntPtr SendMessage(HandleRef hWnd, int msg, bool wParam, int lParam);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern IntPtr SendMessage(HandleRef hWnd, int msg, int wParam, int[] lParam);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern IntPtr SendMessage(HandleRef hWnd, int msg, int[] wParam, int[] lParam);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern IntPtr SendMessage(HandleRef hWnd, int msg, ref int wParam, ref int lParam);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern IntPtr SendMessage(HandleRef hWnd, int msg, int wParam, string lParam);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern IntPtr SendMessage(HandleRef hWnd, int msg, IntPtr wParam, string lParam);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern IntPtr SendMessage(HandleRef hWnd, int msg, int wParam, StringBuilder lParam);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern IntPtr SendMessage(HandleRef hWnd, int msg, int wParam, NativeMethods.TOOLINFO_T lParam);        
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern IntPtr SendMessage(HandleRef hWnd, int msg, int wParam, ref NativeMethods.TBBUTTON lParam);        
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern IntPtr SendMessage(HandleRef hWnd, int msg, int wParam, ref NativeMethods.TBBUTTONINFO lParam);        
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern IntPtr SendMessage(HandleRef hWnd, int msg, int wParam, ref NativeMethods.TV_ITEM lParam);        
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern IntPtr SendMessage(HandleRef hWnd, int msg, int wParam, ref NativeMethods.TV_INSERTSTRUCT lParam);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern IntPtr SendMessage(HandleRef hWnd, int msg, int wParam, NativeMethods.TV_HITTESTINFO lParam);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern IntPtr SendMessage(HandleRef hWnd, int msg, int wParam, NativeMethods.TCITEM_T lParam);
        
        // For RichTextBox
        //
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern IntPtr SendMessage(HandleRef hWnd, int msg, int wParam, [In, Out, MarshalAs(UnmanagedType.LPStruct)] NativeMethods.PARAFORMAT lParam);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern IntPtr SendMessage(HandleRef hWnd, int msg, int wParam, [In, Out, MarshalAs(UnmanagedType.LPStruct)] NativeMethods.CHARFORMATA lParam);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern IntPtr SendMessage(HandleRef hWnd, int msg, int wParam, [In, Out, MarshalAs(UnmanagedType.LPStruct)] NativeMethods.CHARFORMATW lParam);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern IntPtr SendMessage(HandleRef hWnd, int msg, int wParam, NativeMethods.CHARRANGE lParam);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern IntPtr SendMessage(HandleRef hWnd, int msg, int wParam, NativeMethods.FINDTEXT lParam);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern IntPtr SendMessage(HandleRef hWnd, int msg, int wParam, NativeMethods.TEXTRANGE lParam);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern IntPtr SendMessage(HandleRef hWnd, int msg, int wParam, NativeMethods.POINT lParam);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern IntPtr SendMessage(HandleRef hWnd, int msg, NativeMethods.POINT wParam, int lParam);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern IntPtr SendMessage(HandleRef hWnd, int msg, int wParam, NativeMethods.REPASTESPECIAL lParam);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern IntPtr SendMessage(HandleRef hWnd, int msg, int wParam, NativeMethods.EDITSTREAM lParam);
        
        // For ListView
        //
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern IntPtr SendMessage(HandleRef hWnd, int msg, int wParam, [In, Out] ref NativeMethods.LVFINDINFO lParam);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern IntPtr SendMessage(HandleRef hWnd, int msg, int wParam, NativeMethods.LVHITTESTINFO lParam);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern IntPtr SendMessage(HandleRef hWnd, int msg, int wParam, NativeMethods.LVCOLUMN_T lParam);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern IntPtr SendMessage(HandleRef hWnd, int msg, int wParam, [In, Out] ref NativeMethods.LVITEM lParam);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern IntPtr SendMessage(HandleRef hWnd, int msg, int wParam, NativeMethods.LVCOLUMN lParam);
        
        // For MonthCalendar
        //
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern IntPtr SendMessage(HandleRef hWnd, int msg, int wParam, NativeMethods.MCHITTESTINFO lParam);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern IntPtr SendMessage(HandleRef hWnd, int msg, int wParam, NativeMethods.SYSTEMTIME lParam);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern IntPtr SendMessage(HandleRef hWnd, int msg, int wParam, NativeMethods.SYSTEMTIMEARRAY lParam);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern IntPtr SendMessage(HandleRef hWnd, int msg, int wParam, [In, Out] NativeMethods.LOGFONT lParam);        
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern IntPtr SendMessage(HandleRef hWnd, int msg, int wParam, NativeMethods.MSG lParam);        
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern IntPtr SendMessage(HandleRef hWnd, int msg, int wParam, int lParam);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern IntPtr SendMessage(HandleRef hWnd, int msg, IntPtr wParam, IntPtr lParam);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public extern static IntPtr SendMessage(HandleRef hWnd, int Msg, IntPtr wParam, [In, Out] ref NativeMethods.RECT lParam);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public extern static IntPtr SendMessage(HandleRef hWnd, int Msg, ref short wParam, ref short lParam);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public extern static IntPtr SendMessage(HandleRef hWnd, int Msg, [In, Out, MarshalAs(UnmanagedType.Bool)] ref bool wParam, IntPtr lParam);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public extern static IntPtr SendMessage(HandleRef hWnd, int Msg, int wParam, IntPtr lParam);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public extern static IntPtr SendMessage(HandleRef hWnd, int Msg, int wParam, [In, Out] ref NativeMethods.RECT lParam);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public extern static IntPtr SendMessage(HandleRef hWnd, int Msg, IntPtr wParam, NativeMethods.ListViewCompareCallback pfnCompare);
        
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern IntPtr SetParent(HandleRef hWnd, HandleRef hWndParent);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern bool GetWindowRect(HandleRef hWnd, [In, Out] ref NativeMethods.RECT rect);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern IntPtr GetWindow(HandleRef hWnd, int uCmd);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern IntPtr GetDlgItem(HandleRef hWnd, int nIDDlgItem);
        [DllImport(ExternDll.Kernel32, CharSet=CharSet.Auto)]
        public static extern IntPtr GetModuleHandle(string modName);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern IntPtr DefWindowProc(IntPtr hWnd, int msg, IntPtr wParam, IntPtr lParam);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern IntPtr DefMDIChildProc(IntPtr hWnd, int msg, IntPtr wParam, IntPtr lParam);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern IntPtr CallWindowProc(IntPtr wndProc, IntPtr hWnd, int msg,
                                                IntPtr wParam, IntPtr lParam);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern IntPtr GetProp(HandleRef hWnd, int atom);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern IntPtr GetProp(HandleRef hWnd, string name);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern IntPtr RemoveProp(HandleRef hWnd, int atom);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern IntPtr RemoveProp(HandleRef hWnd, string propName);
        [DllImport(ExternDll.Kernel32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern short GlobalDeleteAtom(short atom);
        [DllImport(ExternDll.Kernel32, ExactSpelling=true, CharSet=CharSet.Ansi)]
        public static extern IntPtr GetProcAddress(HandleRef hModule, string lpProcName);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern bool GetClassInfo(HandleRef hInst, string lpszClass, [In, Out] NativeMethods.WNDCLASS wc);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern bool GetClassInfo(HandleRef hInst, string lpszClass, [In, Out] NativeMethods.WNDCLASS_I wc);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern bool GetClassInfo(HandleRef hInst, string lpszClass, IntPtr h);
        [DllImport(ExternDll.Shfolder, CharSet=CharSet.Auto)]
        public static extern int SHGetFolderPath(HandleRef hwndOwner, int nFolder, HandleRef hToken, int dwFlags, StringBuilder lpszPath);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern int GetSystemMetrics(int nIndex);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern bool SystemParametersInfo(int nAction, int nParam, ref NativeMethods.RECT rc, int nUpdate);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern bool SystemParametersInfo(int nAction, int nParam, ref int value, int ignore);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern bool SystemParametersInfo(int nAction, int nParam, ref bool value, int ignore);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern bool SystemParametersInfo(int nAction, int nParam, ref NativeMethods.HIGHCONTRAST_I rc, int nUpdate);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern bool SystemParametersInfo(int nAction, int nParam, [In, Out] NativeMethods.NONCLIENTMETRICS metrics, int nUpdate);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern bool SystemParametersInfo(int nAction, int nParam, bool [] flag, bool nUpdate);
        [DllImport(ExternDll.Kernel32, CharSet=CharSet.Auto)]
        public static extern bool GetComputerName(StringBuilder lpBuffer, int[] nSize);
        [DllImport(ExternDll.Advapi32, CharSet=CharSet.Auto)]
        public static extern bool GetUserName(StringBuilder lpBuffer, int[] nSize);
        [DllImport(ExternDll.Advapi32, CharSet=CharSet.Auto, SetLastError=true)]
        public static extern bool LookupAccountName(string machineName, string accountName, byte[] sid,
                                                     ref int sidLen, StringBuilder domainName, ref int domainNameLen, out int peUse);
        [DllImport(ExternDll.User32, ExactSpelling=true)]
        public static extern IntPtr GetProcessWindowStation();
        [DllImport(ExternDll.User32, SetLastError=true)]
        public static extern bool GetUserObjectInformation(HandleRef hObj, int nIndex, [MarshalAs(UnmanagedType.LPStruct)] NativeMethods.USEROBJECTFLAGS pvBuffer, int nLength, ref int lpnLengthNeeded);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern int ClientToScreen( HandleRef hWnd, [In, Out] NativeMethods.POINT pt );
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern IntPtr GetForegroundWindow();
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern int MsgWaitForMultipleObjects(int nCount, int pHandles, bool fWaitAll, int dwMilliseconds, int dwWakeMask);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern IntPtr GetDesktopWindow();
        [DllImport(ExternDll.Ole32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern int RegisterDragDrop(HandleRef hwnd, UnsafeNativeMethods.IOleDropTarget target);
        [DllImport(ExternDll.Ole32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern int RevokeDragDrop(HandleRef hwnd);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern bool PeekMessage([In, Out] ref NativeMethods.MSG msg, HandleRef hwnd, int msgMin, int msgMax, int remove);
        [DllImport(ExternDll.User32, CharSet=CharSet.Unicode)]
        public static extern bool PeekMessageW([In, Out] ref NativeMethods.MSG msg, HandleRef hwnd, int msgMin, int msgMax, int remove);
        [DllImport(ExternDll.User32, CharSet=CharSet.Ansi)]
        public static extern bool PeekMessageA([In, Out] ref NativeMethods.MSG msg, HandleRef hwnd, int msgMin, int msgMax, int remove);

        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern bool SetProp(HandleRef hWnd, int atom, HandleRef data);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern bool SetProp(HandleRef hWnd, string propName, HandleRef data);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern bool PostMessage(HandleRef hwnd, int msg, IntPtr wparam, IntPtr lparam);
        [DllImport(ExternDll.Kernel32, CharSet=CharSet.Auto, SetLastError=true)]
        public static extern short GlobalAddAtom(string atomName);
        [DllImport(ExternDll.Oleacc, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern IntPtr LresultFromObject(ref Guid refiid, IntPtr wParam, HandleRef pAcc);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern void NotifyWinEvent(int winEvent, HandleRef hwnd, int objType, int objID);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern int GetMenuItemID(HandleRef hMenu, int nPos);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern IntPtr GetSubMenu(HandleRef hwnd, int index);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern int GetMenuItemCount(HandleRef hMenu);
        [DllImport(ExternDll.Oleaut32, PreserveSig=false)]
        public static extern void GetErrorInfo(int reserved, [In, Out] ref UnsafeNativeMethods.IErrorInfo errorInfo);
        [DllImport(ExternDll.User32, ExactSpelling=true, EntryPoint="BeginPaint", CharSet=CharSet.Auto)]
        private static extern IntPtr IntBeginPaint(HandleRef hWnd, [In, Out] ref NativeMethods.PAINTSTRUCT lpPaint);
        public static IntPtr BeginPaint(HandleRef hWnd, [In, Out, MarshalAs(UnmanagedType.LPStruct)] ref NativeMethods.PAINTSTRUCT lpPaint) {
            return HandleCollector.Add(IntBeginPaint(hWnd, ref lpPaint), NativeMethods.CommonHandles.HDC);
        }
        
        [DllImport(ExternDll.User32, ExactSpelling=true, EntryPoint="EndPaint", CharSet=CharSet.Auto)]
        private static extern bool IntEndPaint(HandleRef hWnd, ref NativeMethods.PAINTSTRUCT lpPaint);
        public static bool EndPaint(HandleRef hWnd, [In, MarshalAs(UnmanagedType.LPStruct)] ref NativeMethods.PAINTSTRUCT lpPaint) {
            HandleCollector.Remove(lpPaint.hdc, NativeMethods.CommonHandles.HDC);
            return IntEndPaint(hWnd, ref lpPaint);
        }

        [DllImport(ExternDll.User32, ExactSpelling=true, EntryPoint="GetDC", CharSet=CharSet.Auto)]
        private static extern IntPtr IntGetDC(HandleRef hWnd);
        public static IntPtr GetDC(HandleRef hWnd) {
            return HandleCollector.Add(IntGetDC(hWnd), NativeMethods.CommonHandles.HDC);
        }
        
        [DllImport(ExternDll.User32, ExactSpelling=true, EntryPoint="ReleaseDC", CharSet=CharSet.Auto)]
        private static extern int IntReleaseDC(HandleRef hWnd, HandleRef hDC);
        public static int ReleaseDC(HandleRef hWnd, HandleRef hDC) {
            HandleCollector.Remove((IntPtr)hDC, NativeMethods.CommonHandles.HDC);
            return IntReleaseDC(hWnd, hDC);
        }

        [DllImport(ExternDll.Gdi32, EntryPoint="CreateDC", CharSet=CharSet.Auto)]
        private static extern IntPtr IntCreateDC(string lpszDriver, string lpszDeviceName, string lpszOutput, HandleRef devMode);
        
        public static IntPtr CreateDC(string lpszDriver) {
            return HandleCollector.Add(IntCreateDC(lpszDriver, null, null, NativeMethods.NullHandleRef), NativeMethods.CommonHandles.HDC);
        }
        
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern bool SystemParametersInfo(int nAction, int nParam, [In, Out]int[] rc, int nUpdate);
        [DllImport(ExternDll.User32, EntryPoint="SendMessage", CharSet=CharSet.Auto)]
        //public extern static IntPtr SendCallbackMessage(HandleRef hWnd, int Msg, IntPtr wParam, UnsafeNativeMethods.IRichTextBoxOleCallback lParam);
        public extern static IntPtr SendCallbackMessage(HandleRef hWnd, int Msg, IntPtr wParam, IntPtr lParam);
        [DllImport(ExternDll.Shell32, ExactSpelling=true, CharSet=CharSet.Ansi)]
        public static extern void DragAcceptFiles(HandleRef hWnd, bool fAccept);
        [DllImport(ExternDll.Gdi32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern int GetDeviceCaps(HandleRef hDC, int nIndex);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern int SetScrollInfo(HandleRef hWnd, int fnBar, NativeMethods.SCROLLINFO si, bool redraw);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern IntPtr GetActiveWindow();
        [DllImport(ExternDll.Kernel32, CharSet=CharSet.Auto, SetLastError=true)]
        public static extern IntPtr LoadLibrary(string libname);
        [DllImport(ExternDll.Kernel32, CharSet=CharSet.Auto)]
        public static extern bool FreeLibrary(HandleRef hModule);
        
        [DllImport(ExternDll.User32,
#if WIN64
         EntryPoint="GetWindowLongPtr",
#endif
         CharSet=CharSet.Auto)
        ]
        public static extern IntPtr GetWindowLong(HandleRef hWnd, int nIndex);
        
        [DllImport(ExternDll.User32,
#if WIN64
         EntryPoint="SetWindowLongPtr",
#endif
         CharSet=CharSet.Auto)
        ]
        public static extern IntPtr SetWindowLong(HandleRef hWnd, int nIndex, HandleRef dwNewLong);
        
        [DllImport(ExternDll.User32,
#if WIN64
         EntryPoint="SetWindowLongPtr",
#endif
         CharSet=CharSet.Auto)
        ]
        public static extern IntPtr SetWindowLong(HandleRef hWnd, int nIndex, NativeMethods.WndProc wndproc);
        [DllImport(ExternDll.Ole32, PreserveSig=false)]
        public static extern UnsafeNativeMethods.ILockBytes CreateILockBytesOnHGlobal(HandleRef hGlobal, bool fDeleteOnRelease);
        [DllImport(ExternDll.Ole32, PreserveSig=false)]
        public static extern UnsafeNativeMethods.IStorage StgCreateDocfileOnILockBytes(UnsafeNativeMethods.ILockBytes iLockBytes, int grfMode, int reserved);
        [DllImport(ExternDll.User32, ExactSpelling=true, EntryPoint="CreatePopupMenu", CharSet=CharSet.Auto)]
        private static extern IntPtr IntCreatePopupMenu();
        public static IntPtr CreatePopupMenu() {
            return HandleCollector.Add(IntCreatePopupMenu(), NativeMethods.CommonHandles.Menu);
        }
        
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern bool RemoveMenu(HandleRef hMenu, int uPosition, int uFlags);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern bool DeleteMenu(HandleRef hMenu, int uPosition, int uFlags);
        [DllImport(ExternDll.User32, ExactSpelling=true, EntryPoint="DestroyMenu", CharSet=CharSet.Auto)]
        private static extern bool IntDestroyMenu(HandleRef hMenu);
        public static bool DestroyMenu(HandleRef hMenu) {
            HandleCollector.Remove((IntPtr)hMenu, NativeMethods.CommonHandles.Menu);
            return IntDestroyMenu(hMenu);
        }
        
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern bool SetForegroundWindow(HandleRef hWnd);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern IntPtr GetSystemMenu(HandleRef hWnd, bool bRevert);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern IntPtr DefFrameProc(IntPtr hWnd, IntPtr hWndClient, int msg, IntPtr wParam, IntPtr lParam);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern bool TranslateMDISysAccel(IntPtr hWndClient, [In, Out] ref NativeMethods.MSG msg);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto, SetLastError=true)]
        public static extern bool SetLayeredWindowAttributes(HandleRef hwnd, int crKey, byte bAlpha, int dwFlags);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public extern static bool SetMenu(HandleRef hWnd, HandleRef hMenu);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern int GetWindowPlacement(HandleRef hWnd, ref NativeMethods.WINDOWPLACEMENT placement);
        [DllImport(ExternDll.Kernel32, CharSet=CharSet.Auto)]
        public static extern void GetStartupInfo([In, Out] NativeMethods.STARTUPINFO startupinfo);
        [DllImport(ExternDll.Kernel32, CharSet=CharSet.Auto)]
        public static extern void GetStartupInfo([In, Out] NativeMethods.STARTUPINFO_I startupinfo_i);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern bool SetMenuDefaultItem(HandleRef hwnd, int nIndex, bool pos);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern bool EnableMenuItem(HandleRef hMenu, int UIDEnabledItem, int uEnable);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern IntPtr SetActiveWindow(HandleRef hWnd);
        [DllImport(ExternDll.Gdi32, EntryPoint="CreateIC", CharSet=CharSet.Auto)]
        private static extern IntPtr IntCreateIC(String lpszDriverName, String lpszDeviceName, String lpszOutput, int /*DEVMODE*/ lpInitData);
        public static IntPtr CreateIC(String lpszDriverName, String lpszDeviceName, String lpszOutput, int /*DEVMODE*/ lpInitData) {
            return HandleCollector.Add(IntCreateIC(lpszDriverName, lpszDeviceName, lpszOutput, lpInitData), NativeMethods.CommonHandles.HDC);
        }
        
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern bool ClipCursor(ref NativeMethods.RECT rcClip);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern bool ClipCursor(NativeMethods.COMRECT rcClip);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern IntPtr SetCursor(HandleRef hcursor);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern bool SetCursorPos(int x, int y);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public extern static int ShowCursor(bool bShow);
        [DllImport(ExternDll.User32, ExactSpelling=true, EntryPoint="DestroyCursor", CharSet=CharSet.Auto)]
        private static extern bool IntDestroyCursor(HandleRef hCurs);
        public static bool DestroyCursor(HandleRef hCurs) {
            HandleCollector.Remove((IntPtr)hCurs, NativeMethods.CommonHandles.Cursor);
            return IntDestroyCursor(hCurs);
        }
        
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern bool IsWindow(HandleRef hWnd);
        [DllImport(ExternDll.Gdi32, ExactSpelling=true, EntryPoint="DeleteDC", CharSet=CharSet.Auto)]
        private static extern bool IntDeleteDC(HandleRef hDC);
        public static bool DeleteDC(HandleRef hDC) {
            HandleCollector.Remove((IntPtr)hDC, NativeMethods.CommonHandles.GDI);
            return IntDeleteDC(hDC);
        }
        
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Ansi)]
        public static extern bool GetMessageA([In, Out] ref NativeMethods.MSG msg, HandleRef hWnd, int uMsgFilterMin, int uMsgFilterMax);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Unicode)]
        public static extern bool GetMessageW([In, Out] ref NativeMethods.MSG msg, HandleRef hWnd, int uMsgFilterMin, int uMsgFilterMax);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern IntPtr PostMessage(HandleRef hwnd, int msg, int wparam, int lparam);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern bool GetClientRect(HandleRef hWnd, [In, Out] ref NativeMethods.RECT rect);
        [DllImport(ExternDll.User32, EntryPoint="WindowFromPoint", ExactSpelling=true, CharSet=CharSet.Auto)]
        private static extern IntPtr _WindowFromPoint(POINTSTRUCT pt);
        public static IntPtr WindowFromPoint(int x, int y) {
            POINTSTRUCT ps = new POINTSTRUCT(x, y);
            return _WindowFromPoint(ps);
        }
        [DllImport(ExternDll.User32, EntryPoint="CreateWindowEx", CharSet=CharSet.Auto, SetLastError=true)]
        public static extern IntPtr IntCreateWindowEx(int  dwExStyle, string lpszClassName,
                                                   string lpszWindowName, int style, int x, int y, int width, int height,
                                                   HandleRef hWndParent, HandleRef hMenu, HandleRef hInst, [MarshalAs(UnmanagedType.AsAny)] object pvParam);
        public static IntPtr CreateWindowEx(int  dwExStyle, string lpszClassName,
                                         string lpszWindowName, int style, int x, int y, int width, int height,
                                         HandleRef hWndParent, HandleRef hMenu, HandleRef hInst, [MarshalAs(UnmanagedType.AsAny)]object pvParam) {
            return IntCreateWindowEx(dwExStyle, lpszClassName,
                                         lpszWindowName, style, x, y, width, height, hWndParent, hMenu,
                                         hInst, pvParam);
            
        }
        
        [DllImport(ExternDll.User32, ExactSpelling=true, EntryPoint="DestroyWindow", CharSet=CharSet.Auto)]
        public static extern bool IntDestroyWindow(HandleRef hWnd);
        public static bool DestroyWindow(HandleRef hWnd) {
            return IntDestroyWindow(hWnd);
        }
        
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto, SetLastError=true)]
        public static extern bool UnregisterClass(string className, HandleRef hInstance);
        [DllImport(ExternDll.Gdi32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern IntPtr GetStockObject(int nIndex);
        [DllImport(ExternDll.User32, CharSet=CharSet.Auto, SetLastError=true)]
        public static extern IntPtr RegisterClass(NativeMethods.WNDCLASS_D wc);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern void PostQuitMessage(int nExitCode);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern void WaitMessage();
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern bool SetWindowPlacement(HandleRef hWnd, [In] ref NativeMethods.WINDOWPLACEMENT placement);

        [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Unicode)]
        public class OCPFIPARAMS {
            public int cbSizeOfStruct = Marshal.SizeOf(typeof(OCPFIPARAMS));
            public IntPtr hwndOwner;
            public int x = 0;
            public int y = 0;
            public string lpszCaption;
            public int cObjects = 1;
            public IntPtr ppUnk;
            public int pageCount = 1;
            public IntPtr uuid;
            public int lcid = Application.CurrentCulture.LCID;
            public int dispidInitial;
        }

        // for GetUserNameEx    
        public enum EXTENDED_NAME_FORMAT {
            NameUnknown = 0,
            NameFullyQualifiedDN = 1,
            NameSamCompatible = 2,
            NameDisplay = 3,
            NameUniqueId = 6,
            NameCanonical = 7,
            NameUserPrincipal = 8,
            NameCanonicalEx = 9,
            NameServicePrincipal = 10
        }
        
        [ComImport(), Guid("00000122-0000-0000-C000-000000000046"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        public interface IOleDropTarget {
            
            [PreserveSig]
            int OleDragEnter(
                [In, MarshalAs(UnmanagedType.Interface)]
                object pDataObj,
                [In, MarshalAs(UnmanagedType.U4)]
                int grfKeyState,
                [In, MarshalAs(UnmanagedType.U8)]
                long pt,
                [In, Out]
                ref int pdwEffect);
            
            [PreserveSig]
            int OleDragOver(
                [In, MarshalAs(UnmanagedType.U4)]
                int grfKeyState,
                [In, MarshalAs(UnmanagedType.U8)]
                long pt,
                [In, Out]
                ref int pdwEffect);
            
            [PreserveSig]
            int OleDragLeave();
            
            [PreserveSig]
            int OleDrop(
                [In, MarshalAs(UnmanagedType.Interface)]
                object pDataObj,
                [In, MarshalAs(UnmanagedType.U4)]
                int grfKeyState,
                [In, MarshalAs(UnmanagedType.U8)]
                long pt,
                [In, Out]
                ref int pdwEffect);
        }

        [
            ComImport(), Guid("0000010E-0000-0000-C000-000000000046"), 
            InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown),
            SuppressUnmanagedCodeSecurity
        ]
        public interface IOleDataObject {
            
            [PreserveSig]
            int OleGetData(
                NativeMethods.FORMATETC pFormatetc,
                [Out] 
                NativeMethods.STGMEDIUM pMedium);
            
            [PreserveSig]
            int OleGetDataHere(
                NativeMethods.FORMATETC pFormatetc,
                [In, Out] 
                NativeMethods.STGMEDIUM pMedium);
            
            [PreserveSig]
            int OleQueryGetData(
                NativeMethods.FORMATETC pFormatetc);

            [PreserveSig]
            int OleGetCanonicalFormatEtc(
                NativeMethods.FORMATETC pformatectIn,
                [Out] 
                NativeMethods.FORMATETC pformatetcOut);

            [PreserveSig]
            int OleSetData(
                NativeMethods.FORMATETC pFormatectIn,
                NativeMethods.STGMEDIUM pmedium,
                int fRelease);

            [return: MarshalAs(UnmanagedType.Interface)]
            UnsafeNativeMethods.IEnumFORMATETC OleEnumFormatEtc(
                [In, MarshalAs(UnmanagedType.U4)] 
                int dwDirection);

            [PreserveSig]
            int OleDAdvise(
                NativeMethods.FORMATETC pFormatetc,
                [In, MarshalAs(UnmanagedType.U4)] 
                int advf,
                [In, MarshalAs(UnmanagedType.Interface)] 
                object pAdvSink,
                [Out, MarshalAs(UnmanagedType.LPArray)] 
                int[] pdwConnection);

            [PreserveSig]
            int OleDUnadvise(
                [In, MarshalAs(UnmanagedType.U4)] 
                int dwConnection);

            [PreserveSig]
            int OleEnumDAdvise(
                [Out, MarshalAs(UnmanagedType.LPArray)] 
                object[] ppenumAdvise);
        }
        
        [ComImport(), Guid("00000121-0000-0000-C000-000000000046"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        public interface IOleDropSource {
            
            [PreserveSig]
            int OleQueryContinueDrag(
                int fEscapePressed,
                [In, MarshalAs(UnmanagedType.U4)]
                int grfKeyState);

            [PreserveSig]
            int OleGiveFeedback(
                [In, MarshalAs(UnmanagedType.U4)]
                int dwEffect);
        }
        
        [ComImport(), Guid("00000016-0000-0000-C000-000000000046"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        public interface IOleMessageFilter {
        
            [PreserveSig]
            int HandleInComingCall(
                int dwCallType,
                IntPtr hTaskCaller,
                int dwTickCount,
                /* LPINTERFACEINFO */ IntPtr lpInterfaceInfo);

            [PreserveSig]
            int RetryRejectedCall(
                IntPtr hTaskCallee,
                int dwTickCount,
                int dwRejectType);
            
            [PreserveSig]
            int MessagePending(
                IntPtr hTaskCallee,
                int dwTickCount,
                int dwPendingType);
        }
        
        [
        ComImport(), 
        Guid("B196B289-BAB4-101A-B69C-00AA00341D07"),
        InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown),
        CLSCompliantAttribute(false)
        ]
        public interface IOleControlSite {
            
            [PreserveSig]
            int OnControlInfoChanged();
            
            [PreserveSig]
            int LockInPlaceActive(int fLock);
            
            [PreserveSig]
            int GetExtendedControl(
                [Out, MarshalAs(UnmanagedType.IDispatch)]
                out object ppDisp);
            
            [PreserveSig]
            int TransformCoords(
                [In, Out]
                NativeMethods._POINTL pPtlHimetric,
                [In, Out]
                NativeMethods.tagPOINTF pPtfContainer,
                [In, MarshalAs(UnmanagedType.U4)]
                int dwFlags);
            
            [PreserveSig]
            int TranslateAccelerator(
                [In]
                ref NativeMethods.MSG pMsg,
                [In, MarshalAs(UnmanagedType.U4)]
                int grfModifiers);

            [PreserveSig]
            int OnFocus(int fGotFocus);
            
            [PreserveSig]
            int ShowPropertyFrame();

        }
        
        [ComImport(), Guid("00000118-0000-0000-C000-000000000046"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        public interface IOleClientSite {
            
            [PreserveSig]
            int SaveObject();

            [PreserveSig]
            int GetMoniker(
                [In, MarshalAs(UnmanagedType.U4)]
                int dwAssign,
                [In, MarshalAs(UnmanagedType.U4)]
                int dwWhichMoniker,
                [Out, MarshalAs(UnmanagedType.Interface)]
                out object moniker);

            [return: MarshalAs(UnmanagedType.Interface)]
            IOleContainer GetContainer();
            
            [PreserveSig]
            int ShowObject();
            
            [PreserveSig]
            int OnShowWindow(int fShow);
            
            [PreserveSig]
            int RequestNewObjectLayout();
        }
        
        [ComImport(), Guid("00000119-0000-0000-C000-000000000046"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        public interface IOleInPlaceSite {
            
            IntPtr GetWindow();
            
            [PreserveSig]
            int ContextSensitiveHelp(int fEnterMode);
            
            [PreserveSig]
            int CanInPlaceActivate();
            
            [PreserveSig]
            int OnInPlaceActivate();
            
            [PreserveSig]
            int OnUIActivate();
            
            [PreserveSig]
            int GetWindowContext(
                [Out, MarshalAs(UnmanagedType.Interface)] 
                out UnsafeNativeMethods.IOleInPlaceFrame ppFrame,
                [Out, MarshalAs(UnmanagedType.Interface)] 
                out UnsafeNativeMethods.IOleInPlaceUIWindow ppDoc,
                [Out] 
                NativeMethods.COMRECT lprcPosRect,
                [Out] 
                NativeMethods.COMRECT lprcClipRect,
                [In, Out] 
                NativeMethods.tagOIFI lpFrameInfo);
            
            [PreserveSig]
            int Scroll(
                [In, MarshalAs(UnmanagedType.U4)] 
                NativeMethods.tagSIZE scrollExtant);
            
            [PreserveSig]
            int OnUIDeactivate(
                int fUndoable);
                
            [PreserveSig]
            int OnInPlaceDeactivate();
            
            [PreserveSig]
            int DiscardUndoState();
            
            [PreserveSig]
            int DeactivateAndUndo();
            
            [PreserveSig]
            int OnPosRectChange(
                [In] 
                NativeMethods.COMRECT lprcPosRect);
        }
        
        [ComImport(), Guid("742B0E01-14E6-101B-914E-00AA00300CAB"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        public interface ISimpleFrameSite {

            [PreserveSig]
                int PreMessageFilter(
                IntPtr hwnd,
                [In, MarshalAs(UnmanagedType.U4)] 
                int msg,
                IntPtr wp,
                IntPtr lp,
                [In, Out] 
                ref IntPtr plResult,
                [In, Out, MarshalAs(UnmanagedType.U4)] 
                ref int pdwCookie);
            
            [PreserveSig]
            int PostMessageFilter(
                IntPtr hwnd,
                [In, MarshalAs(UnmanagedType.U4)] 
                int msg,
                IntPtr wp,
                IntPtr lp,
                [In, Out] 
                ref IntPtr plResult,
                [In, MarshalAs(UnmanagedType.U4)] 
                int dwCookie);
        }
        
        [ComImport(), Guid("40A050A0-3C31-101B-A82E-08002B2B2337"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        public interface IVBGetControl {
        
            [PreserveSig]
            int EnumControls(
                int dwOleContF,
                int dwWhich,
                [Out] 
                out IEnumUnknown ppenum);
        }
        
        [ComImport(), Guid("91733A60-3F4C-101B-A3F6-00AA0034E4E9"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        public interface IGetVBAObject {
            
           [PreserveSig]
           int GetObject(
                [In] 
                ref Guid riid,
                [Out, MarshalAs(UnmanagedType.LPArray)] 
                IVBFormat[] rval,
                int dwReserved);
        }
        
        [ComImport(), Guid("9BFBBC02-EFF1-101A-84ED-00AA00341D07"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        public interface IPropertyNotifySink {
            void OnChanged(int dispID);
            
            [PreserveSig]
            int OnRequestEdit(int dispID);
        }
        
        [ComImport(), Guid("9849FD60-3768-101B-8D72-AE6164FFE3CF"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        public interface IVBFormat {
            
            [PreserveSig]
            int Format(
                [In] 
                ref object var,
                IntPtr pszFormat,
                IntPtr lpBuffer,
                short cpBuffer,
                int lcid,
                short firstD,
                short firstW,
                [Out, MarshalAs(UnmanagedType.LPArray)] 
                short[] result);
        }
        
        [ComImport(), Guid("00000100-0000-0000-C000-000000000046"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        public interface IEnumUnknown {
                
            [PreserveSig]
            int Next(
                [In, MarshalAs(UnmanagedType.U4)] 
                int celt,
                [Out] 
                IntPtr rgelt,
                IntPtr pceltFetched);
                
            [PreserveSig]
                int Skip(
                [In, MarshalAs(UnmanagedType.U4)] 
                int celt);
                
            void Reset();
            
            void Clone(
                [Out] 
                out IEnumUnknown ppenum);
        }
        
        [ComImport(), Guid("0000011B-0000-0000-C000-000000000046"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        public interface IOleContainer {
            
            [PreserveSig]
            int ParseDisplayName(
                [In, MarshalAs(UnmanagedType.Interface)] 
                object pbc,
                [In, MarshalAs(UnmanagedType.BStr)] 
                string pszDisplayName,
                [Out, MarshalAs(UnmanagedType.LPArray)] 
                int[] pchEaten,
                [Out, MarshalAs(UnmanagedType.LPArray)] 
                object[] ppmkOut);
                
            [PreserveSig]
            int EnumObjects(
                [In, MarshalAs(UnmanagedType.U4)] 
                int grfFlags,
                [Out] 
                out IEnumUnknown ppenum);
                
            [PreserveSig]
            int LockContainer(
                int fLock);
        }
        
        [ComImport(), Guid("00000116-0000-0000-C000-000000000046"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        public interface IOleInPlaceFrame {
            
            IntPtr GetWindow();
            
            [PreserveSig]
            int ContextSensitiveHelp(int fEnterMode);
            
            [PreserveSig]
            int GetBorder(
                [Out]
                NativeMethods.COMRECT lprectBorder);
            
            [PreserveSig]
            int RequestBorderSpace(
                [In]
                NativeMethods.COMRECT pborderwidths);
            
            [PreserveSig]
            int SetBorderSpace(
                [In]
                NativeMethods.COMRECT pborderwidths);
            
            [PreserveSig]
            int SetActiveObject(
                [In, MarshalAs(UnmanagedType.Interface)]
                UnsafeNativeMethods.IOleInPlaceActiveObject pActiveObject,
                [In, MarshalAs(UnmanagedType.LPWStr)]
                string pszObjName);
            
            [PreserveSig]
            int InsertMenus(
                [In]
                IntPtr hmenuShared,
                [In, Out]
                NativeMethods.tagOleMenuGroupWidths lpMenuWidths);
            
            [PreserveSig]
            int SetMenu(
                [In]
                IntPtr hmenuShared,
                [In]
                IntPtr holemenu,
                [In]
                IntPtr hwndActiveObject);
            
            [PreserveSig]
            int RemoveMenus(
                [In]
                IntPtr hmenuShared);
            
            [PreserveSig]
            int SetStatusText(
                [In, MarshalAs(UnmanagedType.BStr)]
                string pszStatusText);
            
            [PreserveSig]
            int EnableModeless(
                int fEnable);
            
            [PreserveSig]
                int TranslateAccelerator(
                [In]
                ref NativeMethods.MSG lpmsg,
                [In, MarshalAs(UnmanagedType.U2)]
                short wID);
        }
        
        [ComImport(),
         Guid("39088D7E-B71E-11D1-8F39-00C04FD946D0"),
         InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)
        ]
        public interface IExtender {
            
            int Align {get; set;}
            
            bool Enabled {get; set;}
            
            int Height {get; set;}
            
            int Left {get; set;}
            
            bool TabStop {get; set;}
            
            int Top {get; set;}
            
            bool Visible {get; set;}
            
            int Width {get; set;}
            
            string Name {[return: MarshalAs(UnmanagedType.BStr)]get;}
            
            object Parent {[return: MarshalAs(UnmanagedType.Interface)]get;}
            
            IntPtr Hwnd {get;}
            
            object Container {[return: MarshalAs(UnmanagedType.Interface)]get;}
            
            void Move(
                [In, MarshalAs(UnmanagedType.Interface)] 
                object left,
                [In, MarshalAs(UnmanagedType.Interface)] 
                object top,
                [In, MarshalAs(UnmanagedType.Interface)] 
                object width,
                [In, MarshalAs(UnmanagedType.Interface)] 
                object height);
        }
        
        [ComImport(), 
         Guid("8A701DA0-4FEB-101B-A82E-08002B2B2337"), 
         InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)
        ]
        public interface IGetOleObject {
            [return: MarshalAs(UnmanagedType.Interface)]
            object GetOleObject(ref Guid riid);
        }

        [ComImport(), 
        Guid("000C0601-0000-0000-C000-000000000046"), 
        InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)
        ]
        public interface IMsoComponentManager {

        /// <include file='doc\UnsafeNativeMethods.uex' path='docs/doc[@for="UnsafeNativeMethods.IMsoComponentManager.QueryService"]/*' />
        /// <devdoc>
        ///      Return in *ppvObj an implementation of interface iid for service
        ///      guidService (same as IServiceProvider::QueryService).
        ///      Return NOERROR if the requested service is supported, otherwise return
        ///      NULL in *ppvObj and an appropriate error (eg E_FAIL, E_NOINTERFACE).
        /// </devdoc>
        [PreserveSig]
        int QueryService(
            ref Guid guidService,
            ref Guid iid,
            [MarshalAs(UnmanagedType.Interface)] 
            out object ppvObj);

        /// <include file='doc\UnsafeNativeMethods.uex' path='docs/doc[@for="UnsafeNativeMethods.IMsoComponentManager.FDebugMessage"]/*' />
        /// <devdoc>
        ///      Standard FDebugMessage method.
        ///      Since IMsoComponentManager is a reference counted interface, 
        ///      MsoDWGetChkMemCounter should be used when processing the 
        ///      msodmWriteBe message.
        /// </devdoc>
        [PreserveSig]
        bool FDebugMessage(
            IntPtr hInst, 
            int msg, 
            IntPtr wParam, 
            IntPtr lParam);

        /// <include file='doc\UnsafeNativeMethods.uex' path='docs/doc[@for="UnsafeNativeMethods.IMsoComponentManager.FRegisterComponent"]/*' />
        /// <devdoc>
        ///      Register component piComponent and its registration info pcrinfo with
        ///      this component manager.  Return in *pdwComponentID a cookie which will
        ///      identify the component when it calls other IMsoComponentManager
        ///      methods.
        ///      Return TRUE if successful, FALSE otherwise.
        /// </devdoc>
        [PreserveSig]
        bool FRegisterComponent(
            IMsoComponent component,
            NativeMethods.MSOCRINFOSTRUCT pcrinfo,
            out int dwComponentID);

        /// <include file='doc\UnsafeNativeMethods.uex' path='docs/doc[@for="UnsafeNativeMethods.IMsoComponentManager.FRevokeComponent"]/*' />
        /// <devdoc>
        ///      Undo the registration of the component identified by dwComponentID
        ///      (the cookie returned from the FRegisterComponent method).
        ///      Return TRUE if successful, FALSE otherwise.
        /// </devdoc>
        [PreserveSig]
        bool FRevokeComponent(int dwComponentID);

        /// <include file='doc\UnsafeNativeMethods.uex' path='docs/doc[@for="UnsafeNativeMethods.IMsoComponentManager.FUpdateComponentRegistration"]/*' />
        /// <devdoc>
        ///      Update the registration info of the component identified by
        ///      dwComponentID (the cookie returned from FRegisterComponent) with the
        ///      new registration information pcrinfo.
        ///      Typically this is used to update the idle time registration data, but
        ///      can be used to update other registration data as well.
        ///      Return TRUE if successful, FALSE otherwise.
        /// </devdoc>
        [PreserveSig]
        bool FUpdateComponentRegistration(int dwComponentID,NativeMethods.MSOCRINFOSTRUCT pcrinfo);

        /// <include file='doc\UnsafeNativeMethods.uex' path='docs/doc[@for="UnsafeNativeMethods.IMsoComponentManager.FOnComponentActivate"]/*' />
        /// <devdoc>
        ///      Notify component manager that component identified by dwComponentID
        ///      (cookie returned from FRegisterComponent) has been activated.
        ///      The active component gets the  chance to process messages before they
        ///      are dispatched (via IMsoComponent::FPreTranslateMessage) and typically
        ///      gets first chance at idle time after the host.
        ///      This method fails if another component is already Exclusively Active.
        ///      In this case, FALSE is returned and SetLastError is set to 
        ///      msoerrACompIsXActive (comp usually need not take any special action
        ///      in this case).
        ///      Return TRUE if successful.
        /// </devdoc>
        [PreserveSig]
        bool FOnComponentActivate(int dwComponentID);

        /// <include file='doc\UnsafeNativeMethods.uex' path='docs/doc[@for="UnsafeNativeMethods.IMsoComponentManager.FSetTrackingComponent"]/*' />
        /// <devdoc>
        ///      Called to inform component manager that  component identified by 
        ///      dwComponentID (cookie returned from FRegisterComponent) wishes
        ///      to perform a tracking operation (such as mouse tracking).
        ///      The component calls this method with fTrack == TRUE to begin the
        ///      tracking operation and with fTrack == FALSE to end the operation.
        ///      During the tracking operation the component manager routes messages
        ///      to the tracking component (via IMsoComponent::FPreTranslateMessage)
        ///      rather than to the active component.  When the tracking operation ends,
        ///      the component manager should resume routing messages to the active
        ///      component.  
        ///      Note: component manager should perform no idle time processing during a
        ///              tracking operation other than give the tracking component idle
        ///              time via IMsoComponent::FDoIdle.
        ///      Note: there can only be one tracking component at a time.
        ///      Return TRUE if successful, FALSE otherwise.
        /// </devdoc>
        [PreserveSig]
        bool FSetTrackingComponent(int dwComponentID,bool fTrack);

        /// <include file='doc\UnsafeNativeMethods.uex' path='docs/doc[@for="UnsafeNativeMethods.IMsoComponentManager.OnComponentEnterState"]/*' />
        /// <devdoc>
        ///      Notify component manager that component identified by dwComponentID
        ///      (cookie returned from FRegisterComponent) is entering the state
        ///      identified by uStateID (msocstateXXX value).  (For convenience when
        ///      dealing with sub CompMgrs, the host can call this method passing 0 for
        ///      dwComponentID.)  
        ///      Component manager should notify all other interested components within
        ///      the state context indicated by uContext (a msoccontextXXX value),
        ///      excluding those within the state context of a CompMgr in rgpicmExclude,
        ///      via IMsoComponent::OnEnterState (see "Comments on State Contexts", 
        ///      above).
        ///      Component Manager should also take appropriate action depending on the 
        ///      value of uStateID (see msocstate comments, above).
        ///      dwReserved is reserved for future use and should be zero.
        ///      
        ///      rgpicmExclude (can be NULL) is an array of cpicmExclude CompMgrs (can
        ///      include root CompMgr and/or sub CompMgrs); components within the state
        ///      context of a CompMgr appearing in this array should NOT be notified of 
        ///      the state change (note: if uContext    is msoccontextMine, the only 
        ///      CompMgrs in rgpicmExclude that are checked for exclusion are those that 
        ///      are sub CompMgrs of this Component Manager, since all other CompMgrs 
        ///      are outside of this Component Manager's state context anyway.)
        ///      
        ///      Note: Calls to this method are symmetric with calls to 
        ///      FOnComponentExitState. 
        ///      That is, if n OnComponentEnterState calls are made, the component is
        ///      considered to be in the state until n FOnComponentExitState calls are
        ///      made.  Before revoking its registration a component must make a 
        ///      sufficient number of FOnComponentExitState calls to offset any
        ///      outstanding OnComponentEnterState calls it has made.
        ///      
        ///      Note: inplace objects should not call this method with
        ///      uStateID == msocstateModal when entering modal state. Such objects
        ///      should call IOleInPlaceFrame::EnableModeless instead.
        /// </devdoc>
        [PreserveSig]
        void OnComponentEnterState(int dwComponentID,int uStateID,int uContext,int cpicmExclude,/* IMsoComponentManger** */ int rgpicmExclude,int dwReserved);

        /// <include file='doc\UnsafeNativeMethods.uex' path='docs/doc[@for="UnsafeNativeMethods.IMsoComponentManager.FOnComponentExitState"]/*' />
        /// <devdoc>
        ///      Notify component manager that component identified by dwComponentID
        ///      (cookie returned from FRegisterComponent) is exiting the state
        ///      identified by uStateID (a msocstateXXX value).  (For convenience when
        ///      dealing with sub CompMgrs, the host can call this method passing 0 for
        ///      dwComponentID.)
        ///      uContext, cpicmExclude, and rgpicmExclude are as they are in 
        ///      OnComponentEnterState.
        ///      Component manager      should notify all appropriate interested components
        ///      (taking into account uContext, cpicmExclude, rgpicmExclude) via
        ///      IMsoComponent::OnEnterState (see "Comments on State Contexts", above). 
        ///      Component Manager should also take appropriate action depending on
        ///      the value of uStateID (see msocstate comments, above).
        ///      Return TRUE if, at the end of this call, the state is still in effect
        ///      at the root of this component manager's state context
        ///      (because the host or some other component is still in the state),
        ///      otherwise return FALSE (ie. return what FInState would return).
        ///      Caller can normally ignore the return value.
        ///      
        ///      Note: n calls to this method are symmetric with n calls to 
        ///      OnComponentEnterState (see OnComponentEnterState comments, above).
        /// </devdoc>
        [PreserveSig]
        bool FOnComponentExitState(
            int dwComponentID,
            int uStateID,     
            int uContext,     
            int cpicmExclude, 
            /* IMsoComponentManager** */ int rgpicmExclude);

        /// <include file='doc\UnsafeNativeMethods.uex' path='docs/doc[@for="UnsafeNativeMethods.IMsoComponentManager.FInState"]/*' />
        /// <devdoc>
        ///      Return TRUE if the state identified by uStateID (a msocstateXXX value)
        ///      is in effect at the root of this component manager's state context, 
        ///      FALSE otherwise (see "Comments on State Contexts", above).
        ///      pvoid is reserved for future use and should be NULL.
        /// </devdoc>
        [PreserveSig]
        bool FInState(int uStateID,/* PVOID */ IntPtr pvoid);

        /// <include file='doc\UnsafeNativeMethods.uex' path='docs/doc[@for="UnsafeNativeMethods.IMsoComponentManager.FContinueIdle"]/*' />
        /// <devdoc>
        ///      Called periodically by a component during IMsoComponent::FDoIdle.
        ///      Return TRUE if component can continue its idle time processing, 
        ///      FALSE if not (in which case component returns from FDoIdle.) 
        /// </devdoc>
        [PreserveSig]
        bool FContinueIdle();

        /// <include file='doc\UnsafeNativeMethods.uex' path='docs/doc[@for="UnsafeNativeMethods.IMsoComponentManager.FPushMessageLoop"]/*' />
        /// <devdoc>
        ///      Component identified by dwComponentID (cookie returned from 
        ///      FRegisterComponent) wishes to push a message loop for reason uReason.
        ///      uReason is one the values from the msoloop enumeration (above).
        ///      pvLoopData is data private to the component.
        ///      The component manager should push its message loop, 
        ///      calling IMsoComponent::FContinueMessageLoop(uReason, pvLoopData)
        ///      during each loop iteration (see IMsoComponent::FContinueMessageLoop
        ///      comments).  When IMsoComponent::FContinueMessageLoop returns FALSE, the
        ///      component manager terminates the loop.
        ///      Returns TRUE if component manager terminates loop because component
        ///      told it to (by returning FALSE from IMsoComponent::FContinueMessageLoop),
        ///      FALSE if it had to terminate the loop for some other reason.  In the 
        ///      latter case, component should perform any necessary action (such as 
        ///      cleanup).
        /// </devdoc>
        [PreserveSig]
        bool FPushMessageLoop(int dwComponentID,int uReason,/* PVOID */ int pvLoopData);

        /// <include file='doc\UnsafeNativeMethods.uex' path='docs/doc[@for="UnsafeNativeMethods.IMsoComponentManager.FCreateSubComponentManager"]/*' />
        /// <devdoc>
        ///      Cause the component manager to create a "sub" component manager, which
        ///      will be one of its children in the hierarchical tree of component
        ///      managers used to maintiain state contexts (see "Comments on State
        ///      Contexts", above).
        ///      piunkOuter is the controlling unknown (can be NULL), riid is the
        ///      desired IID, and *ppvObj returns       the created sub component manager.
        ///      piunkServProv (can be NULL) is a ptr to an object supporting
        ///      IServiceProvider interface to which the created sub component manager
        ///      will delegate its IMsoComponentManager::QueryService calls. 
        ///      (see objext.h or docobj.h for definition of IServiceProvider).
        ///      Returns TRUE if successful.
        /// </devdoc>
        [PreserveSig]
        bool FCreateSubComponentManager(
            [MarshalAs(UnmanagedType.Interface)]
            object punkOuter,
            [MarshalAs(UnmanagedType.Interface)]
            object punkServProv,
            ref Guid riid,
            out IntPtr ppvObj);

        /// <include file='doc\UnsafeNativeMethods.uex' path='docs/doc[@for="UnsafeNativeMethods.IMsoComponentManager.FGetParentComponentManager"]/*' />
        /// <devdoc>
        ///      Return in *ppicm an AddRef'ed ptr to this component manager's parent
        ///      in the hierarchical tree of component managers used to maintain state
        ///      contexts (see "Comments on State       Contexts", above).
        ///      Returns TRUE if the parent is returned, FALSE if no parent exists or
        ///      some error occurred.
        /// </devdoc>
        [PreserveSig]
        bool FGetParentComponentManager(
            out IMsoComponentManager ppicm);

        /// <include file='doc\UnsafeNativeMethods.uex' path='docs/doc[@for="UnsafeNativeMethods.IMsoComponentManager.FGetActiveComponent"]/*' />
        /// <devdoc>
        ///      Return in *ppic an AddRef'ed ptr to the current active or tracking
        ///      component (as indicated by dwgac (a msogacXXX value)), and
        ///      its registration information in *pcrinfo.  ppic and/or pcrinfo can be
        ///      NULL if caller is not interested these values.  If pcrinfo is not NULL,
        ///      caller should set pcrinfo->cbSize before calling this method.
        ///      Returns TRUE if the component indicated by dwgac exists, FALSE if no 
        ///      such component exists or some error occurred.
        ///      dwReserved is reserved for future use and should be zero.
        /// </devdoc>
        [PreserveSig]
        bool FGetActiveComponent(
        int dwgac,
            [Out, MarshalAs(UnmanagedType.LPArray)]
            IMsoComponent[] ppic,
            NativeMethods.MSOCRINFOSTRUCT pcrinfo,
            int dwReserved);
        }
        
        [ComImport(), 
        Guid("000C0600-0000-0000-C000-000000000046"),
        InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)
        ]
        public interface IMsoComponent {

            /// <include file='doc\UnsafeNativeMethods.uex' path='docs/doc[@for="UnsafeNativeMethods.IMsoComponent.FDebugMessage"]/*' />
            /// <devdoc>
            ///      Standard FDebugMessage method.
            ///      Since IMsoComponentManager is a reference counted interface, 
            ///      MsoDWGetChkMemCounter should be used when processing the 
            ///      msodmWriteBe message.
            /// </devdoc>
            [PreserveSig]
            bool FDebugMessage(
                IntPtr hInst, 
                int msg, 
                IntPtr wParam, 
                IntPtr lParam);

            /// <include file='doc\UnsafeNativeMethods.uex' path='docs/doc[@for="UnsafeNativeMethods.IMsoComponent.FPreTranslateMessage"]/*' />
            /// <devdoc>
            ///      Give component a chance to process the message pMsg before it is
            ///      translated and dispatched. Component can do TranslateAccelerator
            ///      do IsDialogMessage, modify pMsg, or take some other action.
            ///      Return TRUE if the message is consumed, FALSE otherwise.
            /// </devdoc>
            [PreserveSig]
            bool FPreTranslateMessage(ref NativeMethods.MSG msg);            

            /// <include file='doc\UnsafeNativeMethods.uex' path='docs/doc[@for="UnsafeNativeMethods.IMsoComponent.OnEnterState"]/*' />
            /// <devdoc>  
            ///      Notify component when app enters or exits (as indicated by fEnter)
            ///      the state identified by uStateID (a value from olecstate enumeration).
            ///      Component should take action depending on value of uStateID
            ///       (see olecstate comments, above).
            ///
            ///      Note: If n calls are made with TRUE fEnter, component should consider 
            ///      the state to be in effect until n calls are made with FALSE fEnter.
            ///     
            ///     Note: Components should be aware that it is possible for this method to
            ///     be called with FALSE fEnter more    times than it was called with TRUE 
            ///     fEnter (so, for example, if component is maintaining a state counter
            ///     (incremented when this method is called with TRUE fEnter, decremented
            ///     when called with FALSE fEnter), the counter should not be decremented
            ///     for FALSE fEnter if it is already at zero.)  
            /// </devdoc>
            [PreserveSig]
            void OnEnterState(
                int uStateID,
                bool fEnter);

            /// <include file='doc\UnsafeNativeMethods.uex' path='docs/doc[@for="UnsafeNativeMethods.IMsoComponent.OnAppActivate"]/*' />
            /// <devdoc>  
            ///      Notify component when the host application gains or loses activation.
            ///     If fActive is TRUE, the host app is being activated and dwOtherThreadID
            ///      is the ID of the thread owning the window being deactivated.
            ///      If fActive is FALSE, the host app is being deactivated and 
            ///      dwOtherThreadID is the ID of the thread owning the window being 
            ///      activated.
            ///      Note: this method is not called when both the window being activated
            ///      and the one being deactivated belong to the host app.
            /// </devdoc>
            [PreserveSig]
            void OnAppActivate(
                bool fActive,
                int dwOtherThreadID);                

            /// <include file='doc\UnsafeNativeMethods.uex' path='docs/doc[@for="UnsafeNativeMethods.IMsoComponent.OnLoseActivation"]/*' />
            /// <devdoc>      
            ///      Notify the active component that it has lost its active status because
            ///      the host or another component has become active.
            /// </devdoc>
            [PreserveSig]
            void OnLoseActivation();

            /// <include file='doc\UnsafeNativeMethods.uex' path='docs/doc[@for="UnsafeNativeMethods.IMsoComponent.OnActivationChange"]/*' />
            /// <devdoc> 
            ///      Notify component when a new object is being activated.
            ///      If pic is non-NULL, then it is the component that is being activated.
            ///      In this case, fSameComponent is TRUE if pic is the same component as
            ///      the callee of this method, and pcrinfo is the reg info of pic.
            ///      If pic is NULL and fHostIsActivating is TRUE, then the host is the
            ///      object being activated, and pchostinfo is its host info.
            ///      If pic is NULL and fHostIsActivating is FALSE, then there is no current
            ///      active object.
            ///
            ///      If pic is being activated and pcrinfo->grf has the 
            ///      olecrfExclusiveBorderSpace bit set, component should hide its border
            ///      space tools (toolbars, status bars, etc.);
            ///      component should also do this if host is activating and 
            ///      pchostinfo->grfchostf has the olechostfExclusiveBorderSpace bit set.
            ///      In either of these cases, component should unhide its border space
            ///      tools the next time it is activated.
            ///
            ///      if pic is being activated and pcrinfo->grf has the
            ///      olecrfExclusiveActivation bit is set, then pic is being activated in
            ///      "ExclusiveActive" mode.  
            ///      Component should retrieve the top frame window that is hosting pic
            ///      (via pic->HwndGetWindow(olecWindowFrameToplevel, 0)).  
            ///      If this window is different from component's own top frame window, 
            ///         component should disable its windows and do other things it would do
            ///         when receiving OnEnterState(olecstateModal, TRUE) notification. 
            ///      Otherwise, if component is top-level, 
            ///         it should refuse to have its window activated by appropriately
            ///         processing WM_MOUSEACTIVATE (but see WM_MOUSEACTIVATE NOTE, above).
            ///      Component should remain in one of these states until the 
            ///      ExclusiveActive mode ends, indicated by a future call to 
            ///      OnActivationChange with ExclusiveActivation bit not set or with NULL
            ///      pcrinfo.
            /// </devdoc>
            [PreserveSig]
            void OnActivationChange(
                IMsoComponent component,
                bool fSameComponent,
                int pcrinfo,
                bool fHostIsActivating,
                int pchostinfo,
                int dwReserved);

            /// <include file='doc\UnsafeNativeMethods.uex' path='docs/doc[@for="UnsafeNativeMethods.IMsoComponent.FDoIdle"]/*' />
            /// <devdoc> 
            ///      Give component a chance to do idle time tasks.  grfidlef is a group of
            ///      bit flags taken from the enumeration of oleidlef values (above),
            ///      indicating the type of idle tasks to perform.  
            ///      Component may periodically call IOleComponentManager::FContinueIdle; 
            ///      if this method returns FALSE, component should terminate its idle 
            ///      time processing and return.  
            ///      Return TRUE if more time is needed to perform the idle time tasks, 
            ///      FALSE otherwise.
            ///      Note: If a component reaches a point where it has no idle tasks
            ///      and does not need FDoIdle calls, it should remove its idle task
            ///      registration via IOleComponentManager::FUpdateComponentRegistration.
            ///      Note: If this method is called on while component is performing a 
            ///      tracking operation, component should only perform idle time tasks that
            ///      it deems are appropriate to perform during tracking.
            /// </devdoc>
            [PreserveSig]
            bool FDoIdle(
                int grfidlef);            


            /// <include file='doc\UnsafeNativeMethods.uex' path='docs/doc[@for="UnsafeNativeMethods.IMsoComponent.FContinueMessageLoop"]/*' />
            /// <devdoc>         
            ///      Called during each iteration of a message loop that the component
            ///      pushed. uReason and pvLoopData are the reason and the component private 
            ///      data that were passed to IOleComponentManager::FPushMessageLoop.
            ///      This method is called after peeking the next message in the queue
            ///      (via PeekMessage) but before the message is removed from the queue.
            ///      The peeked message is passed in the pMsgPeeked param (NULL if no
            ///      message is in the queue).  This method may be additionally called when
            ///      the next message has already been removed from the queue, in which case
            ///      pMsgPeeked is passed as NULL.
            ///      Return TRUE if the message loop should continue, FALSE otherwise.
            ///      If FALSE is returned, the component manager terminates the loop without
            ///      removing pMsgPeeked from the queue. 
            /// </devdoc>
            [PreserveSig]
            bool FContinueMessageLoop(
                int uReason,
                int pvLoopData,
                ref NativeMethods.MSG pMsgPeeked);            


            /// <include file='doc\UnsafeNativeMethods.uex' path='docs/doc[@for="UnsafeNativeMethods.IMsoComponent.FQueryTerminate"]/*' />
            /// <devdoc> 
            ///      Called when component manager wishes to know if the component is in a
            ///      state in which it can terminate.  If fPromptUser is FALSE, component
            ///      should simply return TRUE if it can terminate, FALSE otherwise.
            ///      If fPromptUser is TRUE, component should return TRUE if it can
            ///      terminate without prompting the user; otherwise it should prompt the
            ///      user, either 1.) asking user if it can terminate and returning TRUE
            ///      or FALSE appropriately, or 2.) giving an indication as to why it
            ///      cannot terminate and returning FALSE. 
            /// </devdoc>
            [PreserveSig]
            bool FQueryTerminate(
                bool fPromptUser);

            /// <include file='doc\UnsafeNativeMethods.uex' path='docs/doc[@for="UnsafeNativeMethods.IMsoComponent.Terminate"]/*' />
            /// <devdoc>     
            ///      Called when component manager wishes to terminate the component's
            ///      registration.  Component should revoke its registration with component
            ///      manager, release references to component manager and perform any
            ///      necessary cleanup. 
            /// </devdoc>
            [PreserveSig]
            void Terminate();

            /// <include file='doc\UnsafeNativeMethods.uex' path='docs/doc[@for="UnsafeNativeMethods.IMsoComponent.HwndGetWindow"]/*' />
            /// <devdoc> 
            ///      Called to retrieve a window associated with the component, as specified
            ///      by dwWhich, a olecWindowXXX value (see olecWindow, above).
            ///      dwReserved is reserved for future use and should be zero.
            ///      Component should return the desired window or NULL if no such window
            ///      exists. 
            /// </devdoc>
            
            [PreserveSig]
            IntPtr HwndGetWindow(
                int dwWhich,
                int dwReserved);
        }

        [ComImport(), Guid("00020D03-0000-0000-C000-000000000046"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        public interface IRichEditOleCallback {
        }

        [ComImport(), Guid("00020D03-0000-0000-C000-000000000046"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        public interface IRichTextBoxOleCallback {
        
            [PreserveSig]
            int GetNewStorage(out IStorage ret);
            
            [PreserveSig]
            int GetInPlaceContext(IntPtr lplpFrame, IntPtr lplpDoc, IntPtr lpFrameInfo);
            
            [PreserveSig]
            int ShowContainerUI(int fShow);
            
            [PreserveSig]
            int QueryInsertObject(ref Guid lpclsid, IntPtr lpstg, int cp);
            
            [PreserveSig]
            int DeleteObject(IntPtr lpoleobj);
            
            [PreserveSig]
            int QueryAcceptData(IOleDataObject lpdataobj, /* CLIPFORMAT* */ IntPtr lpcfFormat, int reco, int fReally, IntPtr hMetaPict);
            
            [PreserveSig]
            int ContextSensitiveHelp(int fEnterMode);
            
            [PreserveSig]
            int GetClipboardData(NativeMethods.CHARRANGE lpchrg, int reco, IntPtr lplpdataobj);

            [PreserveSig]
            int GetDragDropEffect(bool fDrag, int grfKeyState, ref int pdwEffect);
            
            [PreserveSig]
            int GetContextMenu(short seltype, IntPtr lpoleobj, NativeMethods.CHARRANGE lpchrg, out IntPtr hmenu);
        }
        
        [ComImport(), Guid("00000115-0000-0000-C000-000000000046"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        public interface IOleInPlaceUIWindow {
             
             IntPtr GetWindow();
            
             void ContextSensitiveHelp(
                     
                     int fEnterMode);

            
             void GetBorder(
                    [Out] 
                      NativeMethods.COMRECT lprectBorder);

            
             void RequestBorderSpace(
                    [In] 
                      NativeMethods.COMRECT pborderwidths);

            
             void SetBorderSpace(
                    [In] 
                      NativeMethods.COMRECT pborderwidths);

            
             void SetActiveObject(
                    [In, MarshalAs(UnmanagedType.Interface)] 
                      UnsafeNativeMethods.IOleInPlaceActiveObject pActiveObject,
                    [In, MarshalAs(UnmanagedType.LPWStr)] 
                      string pszObjName);


        }
        [ComImport(), Guid("00000117-0000-0000-C000-000000000046"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        public interface IOleInPlaceActiveObject {

             [PreserveSig]
             int GetWindow( out IntPtr hwnd );

            
             void ContextSensitiveHelp(
                    
                     int fEnterMode);

            
             [PreserveSig]
             int TranslateAccelerator(
                    [In]
                      ref NativeMethods.MSG lpmsg);

            
             void OnFrameWindowActivate(
                    
                     int fActivate);

            
             void OnDocWindowActivate(
                    
                     int fActivate);

            
             void ResizeBorder(
                    [In]
                      NativeMethods.COMRECT prcBorder,
                    [In]
                      UnsafeNativeMethods.IOleInPlaceUIWindow pUIWindow,
                    
                     int fFrameWindow);

            
             void EnableModeless(
                    
                     int fEnable);


        }
        [ComImport(), Guid("00000114-0000-0000-C000-000000000046"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        public interface IOleWindow {

             [PreserveSig]
             int GetWindow( [Out]out IntPtr hwnd );

            
             void ContextSensitiveHelp(
                     
                     int fEnterMode);
        }
        [ComImport(), Guid("00000113-0000-0000-C000-000000000046"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        public interface IOleInPlaceObject {

             [PreserveSig]
             int GetWindow( [Out]out IntPtr hwnd );

            
             void ContextSensitiveHelp(
                     
                     int fEnterMode);

            
             void InPlaceDeactivate();

            
             [PreserveSig]
             int UIDeactivate();

            
             void SetObjectRects(
                    [In] 
                      NativeMethods.COMRECT lprcPosRect,
                    [In] 
                      NativeMethods.COMRECT lprcClipRect);

            
             void ReactivateAndUndo();


        }
        [ComImport(), Guid("00000112-0000-0000-C000-000000000046"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        public interface IOleObject {

             [PreserveSig]
             int SetClientSite(
                    [In, MarshalAs(UnmanagedType.Interface)]
                      UnsafeNativeMethods.IOleClientSite pClientSite);

             
             UnsafeNativeMethods.IOleClientSite GetClientSite();

             [PreserveSig]
             int SetHostNames(
                    [In, MarshalAs(UnmanagedType.LPWStr)]
                      string szContainerApp,
                    [In, MarshalAs(UnmanagedType.LPWStr)]
                      string szContainerObj);

             [PreserveSig]
             int Close(
                    
                     int dwSaveOption);

             [PreserveSig]
             int SetMoniker(
                    [In, MarshalAs(UnmanagedType.U4)]
                     int dwWhichMoniker,
                    [In, MarshalAs(UnmanagedType.Interface)]
                     object pmk);

              [PreserveSig]
              int GetMoniker(
                    [In, MarshalAs(UnmanagedType.U4)]
                     int dwAssign,
                    [In, MarshalAs(UnmanagedType.U4)]
                     int dwWhichMoniker,
                    [Out, MarshalAs(UnmanagedType.Interface)]
                     out object moniker);

             [PreserveSig]
             int InitFromData(
                    [In, MarshalAs(UnmanagedType.Interface)]
                     UnsafeNativeMethods.IOleDataObject pDataObject,
                    
                     int fCreation,
                    [In, MarshalAs(UnmanagedType.U4)]
                     int dwReserved);

             [PreserveSig]
             int GetClipboardData(
                    [In, MarshalAs(UnmanagedType.U4)]
                     int dwReserved,
                     out UnsafeNativeMethods.IOleDataObject data);

             [PreserveSig]
             int DoVerb(
                    
                     int iVerb,
                    [In]
                     IntPtr lpmsg,
                    [In, MarshalAs(UnmanagedType.Interface)]
                      UnsafeNativeMethods.IOleClientSite pActiveSite,
                    
                     int lindex,
                    
                     IntPtr hwndParent,
                    [In]
                     NativeMethods.COMRECT lprcPosRect);

             [PreserveSig]
             int EnumVerbs(out UnsafeNativeMethods.IEnumOLEVERB e);

             [PreserveSig]
             int OleUpdate();

             [PreserveSig]
             int IsUpToDate();

             [PreserveSig]
             int GetUserClassID(
                    [In, Out]
                      ref Guid pClsid);

             [PreserveSig]
             int GetUserType(
                    [In, MarshalAs(UnmanagedType.U4)]
                     int dwFormOfType,
                    [Out, MarshalAs(UnmanagedType.LPWStr)]
                     out string userType);

             [PreserveSig]
             int SetExtent(
                    [In, MarshalAs(UnmanagedType.U4)]
                     int dwDrawAspect,
                    [In]
                     NativeMethods.tagSIZEL pSizel);

             [PreserveSig]
             int GetExtent(
                    [In, MarshalAs(UnmanagedType.U4)]
                     int dwDrawAspect,
                    [Out]
                     NativeMethods.tagSIZEL pSizel);

             [PreserveSig]
             int Advise(
                    [In, MarshalAs(UnmanagedType.Interface)]
                     UnsafeNativeMethods.IAdviseSink pAdvSink,
                     out int cookie);

             [PreserveSig]
             int Unadvise(
                    [In, MarshalAs(UnmanagedType.U4)]
                     int dwConnection);

              [PreserveSig]
              int EnumAdvise(out UnsafeNativeMethods.IEnumSTATDATA e);

             [PreserveSig]
             int GetMiscStatus(
                    [In, MarshalAs(UnmanagedType.U4)]
                     int dwAspect,
                     out int misc);

             [PreserveSig]
             int SetColorScheme(
                    [In]
                      NativeMethods.tagLOGPALETTE pLogpal);
        }
        
        [ComImport(), Guid("1C2056CC-5EF4-101B-8BC8-00AA003E3B29"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        public interface IOleInPlaceObjectWindowless {

             [PreserveSig]
             int SetClientSite(
                    [In, MarshalAs(UnmanagedType.Interface)]
                      UnsafeNativeMethods.IOleClientSite pClientSite);

             [PreserveSig]
             int GetClientSite(out UnsafeNativeMethods.IOleClientSite site);

             [PreserveSig]
             int SetHostNames(
                    [In, MarshalAs(UnmanagedType.LPWStr)]
                      string szContainerApp,
                    [In, MarshalAs(UnmanagedType.LPWStr)]
                      string szContainerObj);

             [PreserveSig]
             int Close(
                    
                     int dwSaveOption);

             [PreserveSig]
             int SetMoniker(
                    [In, MarshalAs(UnmanagedType.U4)]
                     int dwWhichMoniker,
                    [In, MarshalAs(UnmanagedType.Interface)]
                     object pmk);

              [PreserveSig]
              int GetMoniker(
                    [In, MarshalAs(UnmanagedType.U4)]
                     int dwAssign,
                    [In, MarshalAs(UnmanagedType.U4)]
                     int dwWhichMoniker,
                    [Out, MarshalAs(UnmanagedType.Interface)]
                     out object moniker);

             [PreserveSig]
             int InitFromData(
                    [In, MarshalAs(UnmanagedType.Interface)]
                     UnsafeNativeMethods.IOleDataObject pDataObject,
                    
                     int fCreation,
                    [In, MarshalAs(UnmanagedType.U4)]
                     int dwReserved);

             [PreserveSig]
             int GetClipboardData(
                    [In, MarshalAs(UnmanagedType.U4)]
                     int dwReserved,
                     out UnsafeNativeMethods.IOleDataObject data);

             [PreserveSig]
             int DoVerb(
                    
                     int iVerb,
                    [In]
                     IntPtr lpmsg,
                    [In, MarshalAs(UnmanagedType.Interface)]
                      UnsafeNativeMethods.IOleClientSite pActiveSite,
                    
                     int lindex,
                    
                     IntPtr hwndParent,
                    [In]
                     NativeMethods.COMRECT lprcPosRect);

             [PreserveSig]
             int EnumVerbs(out UnsafeNativeMethods.IEnumOLEVERB e);

             [PreserveSig]
             int OleUpdate();

             [PreserveSig]
             int IsUpToDate();

             [PreserveSig]
             int GetUserClassID(
                    [In, Out]
                      ref Guid pClsid);

             [PreserveSig]
             int GetUserType(
                    [In, MarshalAs(UnmanagedType.U4)]
                     int dwFormOfType,
                    [Out, MarshalAs(UnmanagedType.LPWStr)]
                     out string userType);

             [PreserveSig]
             int SetExtent(
                    [In, MarshalAs(UnmanagedType.U4)]
                     int dwDrawAspect,
                    [In]
                     NativeMethods.tagSIZEL pSizel);

             [PreserveSig]
             int GetExtent(
                    [In, MarshalAs(UnmanagedType.U4)]
                     int dwDrawAspect,
                    [Out]
                     NativeMethods.tagSIZEL pSizel);

             [PreserveSig]
             int Advise(
                    [In, MarshalAs(UnmanagedType.Interface)]
                     UnsafeNativeMethods.IAdviseSink pAdvSink,
                     out int cookie);

             [PreserveSig]
             int Unadvise(
                    [In, MarshalAs(UnmanagedType.U4)]
                     int dwConnection);

              [PreserveSig]
                  int EnumAdvise(out UnsafeNativeMethods.IEnumSTATDATA e);

             [PreserveSig]
             int GetMiscStatus(
                    [In, MarshalAs(UnmanagedType.U4)]
                     int dwAspect,
                     out int misc);

             [PreserveSig]
             int SetColorScheme(
                    [In]
                      NativeMethods.tagLOGPALETTE pLogpal);
            
             [PreserveSig]
             int OnWindowMessage( 
                [In, MarshalAs(UnmanagedType.U4)]  int msg,
                [In, MarshalAs(UnmanagedType.U4)]  int wParam,
                [In, MarshalAs(UnmanagedType.U4)]  int lParam,
                [Out, MarshalAs(UnmanagedType.U4)] int plResult);

             [PreserveSig]
             int GetDropTarget( 
                [Out, MarshalAs(UnmanagedType.Interface)] object ppDropTarget);

        };

        
        [ComImport(), Guid("B196B288-BAB4-101A-B69C-00AA00341D07"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        public interface IOleControl {

            
             [PreserveSig]
             int GetControlInfo(
                    [Out]
                      NativeMethods.tagCONTROLINFO pCI);

             [PreserveSig]
             int OnMnemonic(
                    [In]
                      ref NativeMethods.MSG pMsg);

             [PreserveSig]
             int OnAmbientPropertyChange(
                    
                     int dispID);

             [PreserveSig]
             int FreezeEvents(
                    
                     int bFreeze);

        }
        [ComImport(), Guid("6D5140C1-7436-11CE-8034-00AA006009FA"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        public interface IOleServiceProvider {


             [PreserveSig]
             int QueryService(
                  [In]
                      ref Guid guidService,
                  [In]
                  ref Guid riid,
                  out IntPtr ppvObject);
        }
        [ComImport(), Guid("0000010d-0000-0000-C000-000000000046"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        public interface IViewObject {

            
            void Draw(
                [In, MarshalAs(UnmanagedType.U4)]
                int dwDrawAspect,

                int lindex,

                IntPtr pvAspect,
                [In]
                NativeMethods.tagDVTARGETDEVICE ptd,

                IntPtr hdcTargetDev,

                IntPtr hdcDraw,
                [In]
                NativeMethods.COMRECT lprcBounds,
                [In]
                NativeMethods.COMRECT lprcWBounds,

                IntPtr pfnContinue,
                [In]
                int dwContinue);

            
            [PreserveSig]
            int GetColorSet(
                [In, MarshalAs(UnmanagedType.U4)]
                int dwDrawAspect,

                int lindex,

                IntPtr pvAspect,
                [In]
                NativeMethods.tagDVTARGETDEVICE ptd,

                IntPtr hicTargetDev,
                [Out]
                NativeMethods.tagLOGPALETTE ppColorSet);

            [PreserveSig]
            int Freeze(
                [In, MarshalAs(UnmanagedType.U4)]
                int dwDrawAspect,

                int lindex,

                IntPtr pvAspect,
                [Out]
                IntPtr pdwFreeze);

            [PreserveSig]
            int Unfreeze(
                [In, MarshalAs(UnmanagedType.U4)]
                int dwFreeze);

            
            void SetAdvise(
                [In, MarshalAs(UnmanagedType.U4)]
                int aspects,
                [In, MarshalAs(UnmanagedType.U4)]
                int advf,
                [In, MarshalAs(UnmanagedType.Interface)]
                IAdviseSink pAdvSink);

            
            void GetAdvise(
                // These can be NULL if caller doesn't want them
                [In, Out, MarshalAs(UnmanagedType.LPArray)]
                int[] paspects,
                // These can be NULL if caller doesn't want them
                [In, Out, MarshalAs(UnmanagedType.LPArray)]
                int[] advf,
                // These can be NULL if caller doesn't want them
                [In, Out, MarshalAs(UnmanagedType.LPArray)]
                UnsafeNativeMethods.IAdviseSink[] pAdvSink);
        }
        [ComImport(), Guid("00000127-0000-0000-C000-000000000046"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        public interface IViewObject2 /* : IViewObject */ {

            
            void Draw(
                [In, MarshalAs(UnmanagedType.U4)]
                int dwDrawAspect,

                int lindex,

                IntPtr pvAspect,
                [In]
                NativeMethods.tagDVTARGETDEVICE ptd,

                IntPtr hdcTargetDev,

                IntPtr hdcDraw,
                [In]
                NativeMethods.COMRECT lprcBounds,
                [In]
                NativeMethods.COMRECT lprcWBounds,

                IntPtr pfnContinue,
                [In]
                int dwContinue);

            
            [PreserveSig]
            int GetColorSet(
                [In, MarshalAs(UnmanagedType.U4)]
                int dwDrawAspect,

                int lindex,

                IntPtr pvAspect,
                [In]
                NativeMethods.tagDVTARGETDEVICE ptd,

                IntPtr hicTargetDev,
                [Out]
                NativeMethods.tagLOGPALETTE ppColorSet);

            
            [PreserveSig]
            int Freeze(
                [In, MarshalAs(UnmanagedType.U4)]
                int dwDrawAspect,

                int lindex,

                IntPtr pvAspect,
                [Out]
                IntPtr pdwFreeze);

            
            [PreserveSig]
            int Unfreeze(
                [In, MarshalAs(UnmanagedType.U4)]
                int dwFreeze);

            
            void SetAdvise(
                [In, MarshalAs(UnmanagedType.U4)]
                int aspects,
                [In, MarshalAs(UnmanagedType.U4)]
                int advf,
                [In, MarshalAs(UnmanagedType.Interface)]
                IAdviseSink pAdvSink);

            
            void GetAdvise(
                // These can be NULL if caller doesn't want them
                [In, Out, MarshalAs(UnmanagedType.LPArray)]
                int[] paspects,
                // These can be NULL if caller doesn't want them
                [In, Out, MarshalAs(UnmanagedType.LPArray)]
                int[] advf,
                // These can be NULL if caller doesn't want them
                [In, Out, MarshalAs(UnmanagedType.LPArray)]
                UnsafeNativeMethods.IAdviseSink[] pAdvSink);

            
            void GetExtent(
                [In, MarshalAs(UnmanagedType.U4)]
                int dwDrawAspect,

                int lindex,
                [In]
                NativeMethods.tagDVTARGETDEVICE ptd,
                [Out]
                NativeMethods.tagSIZEL lpsizel);
        }
        [ComImport(), Guid("0000010C-0000-0000-C000-000000000046"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        public interface IPersist {

            [ System.Security.SuppressUnmanagedCodeSecurityAttribute()]
            void GetClassID(
                           [Out] 
                           out Guid pClassID);
        }
        [ComImport(), Guid("37D84F60-42CB-11CE-8135-00AA004BB851"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
        public interface IPersistPropertyBag {

            
            void GetClassID(
                [Out]
                out Guid pClassID);

            
            void InitNew();

            
            void Load(
                [In, MarshalAs(UnmanagedType.Interface)]
                IPropertyBag pPropBag,
                [In, MarshalAs(UnmanagedType.Interface)]
                IErrorLog pErrorLog);

            
            void Save(
                [In, MarshalAs(UnmanagedType.Interface)]
                IPropertyBag pPropBag,
                [In, MarshalAs(UnmanagedType.Bool)]
                bool fClearDirty,
                [In, MarshalAs(UnmanagedType.Bool)]
                bool fSaveAllProperties);
        }
        [
            ComImport(), 
        Guid("CF51ED10-62FE-11CF-BF86-00A0C9034836"),
        InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown),
        CLSCompliantAttribute(false)
        ]
        public interface IQuickActivate {

            
            void QuickActivate(
                              [In] 
                              UnsafeNativeMethods.tagQACONTAINER pQaContainer,
                              [Out] 
                              UnsafeNativeMethods.tagQACONTROL pQaControl);

            
            void SetContentExtent(
                                 [In] 
                                 NativeMethods.tagSIZEL pSizel);

            
            void GetContentExtent(
                                 [Out] 
                                 NativeMethods.tagSIZEL pSizel);

        }
        [ComImport(), Guid("000C060B-0000-0000-C000-000000000046")]
        public class SMsoComponentManager {
        }
        [
        
            ComImport(), 
        Guid("55272A00-42CB-11CE-8135-00AA004BB851"), 
        InterfaceType(ComInterfaceType.InterfaceIsIUnknown)
        ]
        public interface IPropertyBag {
            [PreserveSig]
            int Read(
                [In, MarshalAs(UnmanagedType.LPWStr)]
                string pszPropName,
                [In, Out]
                ref object pVar,
                [In]
                IErrorLog pErrorLog);

            [PreserveSig]
            int Write(
                [In, MarshalAs(UnmanagedType.LPWStr)]
                string pszPropName,
                [In]
                ref object pVar);
        }
    [ComImport(), Guid("3127CA40-446E-11CE-8135-00AA004BB851"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
            public interface  IErrorLog {

                    
                     void AddError(
                            [In, MarshalAs(UnmanagedType.LPWStr)] 
                             string pszPropName_p0,
                            [In, MarshalAs(UnmanagedType.Struct)] 
                              NativeMethods.tagEXCEPINFO pExcepInfo_p1);

            }
    [ComImport(), Guid("00000109-0000-0000-C000-000000000046"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    public interface IPersistStream {

         void GetClassID([Out] out Guid pClassId);

         [PreserveSig]
         int IsDirty();

        
         void Load(
                [In, MarshalAs(UnmanagedType.Interface)] 
                  UnsafeNativeMethods.IStream pstm);

        
         void Save(
                [In, MarshalAs(UnmanagedType.Interface)] 
                  UnsafeNativeMethods.IStream pstm,
                [In, MarshalAs(UnmanagedType.Bool)] 
                 bool fClearDirty);

        
         long GetSizeMax();


    }
    [ComImport(), Guid("7FD52380-4E07-101B-AE2D-08002B2EC713"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    public interface IPersistStreamInit {

        
         void GetClassID(
                [Out] 
                  out Guid pClassID);


         [PreserveSig]
         int IsDirty();

        
         void Load(
                [In, MarshalAs(UnmanagedType.Interface)] 
                  UnsafeNativeMethods.IStream pstm);

            
             void Save(
                    [In, MarshalAs(UnmanagedType.Interface)] 
                      IStream pstm,
                    [In, MarshalAs(UnmanagedType.Bool)] 
                     bool fClearDirty);

        
         void GetSizeMax(
                [Out, MarshalAs(UnmanagedType.LPArray)] 
                 long pcbSize);

        
         void InitNew();


    }
    [ComImport(), Guid("B196B286-BAB4-101A-B69C-00AA00341D07"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    public interface IConnectionPoint {

        [PreserveSig]
        int GetConnectionInterface(out Guid iid);


        [PreserveSig]
        int GetConnectionPointContainer(
            [MarshalAs(UnmanagedType.Interface)]
            ref IConnectionPointContainer pContainer);


         [PreserveSig]
         int Advise(
                [In, MarshalAs(UnmanagedType.Interface)] 
                  object pUnkSink,
              ref int cookie);


        [PreserveSig]
        int Unadvise(

                 int cookie);

        [PreserveSig]
        int EnumConnections(out object pEnum);

    }
    [ComImport(), Guid("0000010A-0000-0000-C000-000000000046"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    public interface IPersistStorage {

        
         void GetClassID(
                [Out] 
                  out Guid pClassID);

         [PreserveSig]
         int IsDirty();

         void InitNew(IStorage pstg);
        
         [PreserveSig]
         int Load(IStorage pstg);
        
         void Save(IStorage pStgSave, int fSameAsLoad);
        
         void SaveCompleted(IStorage pStgNew);
        
         void HandsOffStorage();
    }
    [ComImport(), Guid("00020404-0000-0000-C000-000000000046"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    public interface IEnumVariant {
         [PreserveSig]
         int Next(
                [In, MarshalAs(UnmanagedType.U4)] 
                 int celt,
                [In, Out] 
                 IntPtr rgvar,
                [Out, MarshalAs(UnmanagedType.LPArray)] 
                 int[] pceltFetched);
        
         void Skip(
                [In, MarshalAs(UnmanagedType.U4)] 
                 int celt);

         void Reset();
        
         void Clone(
                [Out, MarshalAs(UnmanagedType.LPArray)] 
                   UnsafeNativeMethods.IEnumVariant[] ppenum);
    }

    [ComImport(), Guid("00000103-0000-0000-C000-000000000046"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    public interface IEnumFORMATETC {


         [PreserveSig]
         int Next(
                [In, MarshalAs(UnmanagedType.U4)] 
                 int celt,
                [Out] 
                  NativeMethods.FORMATETC rgelt,
                [In, Out, MarshalAs(UnmanagedType.LPArray)] 
                  int[] pceltFetched);


         [PreserveSig]
         int Skip(
                [In, MarshalAs(UnmanagedType.U4)] 
                 int celt);


         [PreserveSig]
         int Reset();


         [PreserveSig]
         int Clone(
                [Out, MarshalAs(UnmanagedType.LPArray)] 
                   UnsafeNativeMethods.IEnumFORMATETC[] ppenum);


    }
    [ComImport(), Guid("00000104-0000-0000-C000-000000000046"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    public interface IEnumOLEVERB {


         [PreserveSig]
         int Next(
                [MarshalAs(UnmanagedType.U4)] 
                int celt,
                [Out]
                NativeMethods.tagOLEVERB rgelt,
                [Out, MarshalAs(UnmanagedType.LPArray)]
                int[] pceltFetched);

         [PreserveSig]
         int Skip(
                [In, MarshalAs(UnmanagedType.U4)] 
                 int celt);

        
         void Reset();

        
         void Clone(
            out IEnumOLEVERB ppenum);


    }
    [ComImport(), Guid("0000010F-0000-0000-C000-000000000046"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    public interface IAdviseSink {

         [PreserveSig]
         void OnDataChange(
                        [In]
                  NativeMethods.FORMATETC pFormatetc,
                        [In]
                  NativeMethods.STGMEDIUM pStgmed);

         [PreserveSig]
         void OnViewChange(
                [In, MarshalAs(UnmanagedType.U4)]
                 int dwAspect,

                 int lindex);

         [PreserveSig]
         void OnRename(
                [In, MarshalAs(UnmanagedType.Interface)]
                  object pmk);

         [PreserveSig]
         void OnSave();

        
         void OnClose();


    }
    [ComImport(), Guid("00000105-0000-0000-C000-000000000046"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    public interface IEnumSTATDATA {

        
         void Next(
                [In, MarshalAs(UnmanagedType.U4)] 
                 int celt,
                [Out] 
                  NativeMethods.STATDATA rgelt,
                [Out, MarshalAs(UnmanagedType.LPArray)] 
                  int[] pceltFetched);

        
         void Skip(
                [In, MarshalAs(UnmanagedType.U4)] 
                 int celt);

        
         void Reset();

        
         void Clone(
                [Out, MarshalAs(UnmanagedType.LPArray)] 
                   UnsafeNativeMethods.IEnumSTATDATA[] ppenum);


    }
    [ComImport(), Guid("0000000C-0000-0000-C000-000000000046"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    public interface IStream {

         int Read(

                 IntPtr buf,

                 int len);

        
         int Write(

                 IntPtr buf,

                 int len);

        [return: MarshalAs(UnmanagedType.I8)]
         long Seek(
                [In, MarshalAs(UnmanagedType.I8)] 
                 long dlibMove,

                 int dwOrigin);

        
         void SetSize(
                [In, MarshalAs(UnmanagedType.I8)] 
                 long libNewSize);

        [return: MarshalAs(UnmanagedType.I8)]
         long CopyTo(
                [In, MarshalAs(UnmanagedType.Interface)] 
                  UnsafeNativeMethods.IStream pstm,
                [In, MarshalAs(UnmanagedType.I8)] 
                 long cb,
                [Out, MarshalAs(UnmanagedType.LPArray)] 
                 long[] pcbRead);

        
         void Commit(

                 int grfCommitFlags);

        
         void Revert();

        
         void LockRegion(
                [In, MarshalAs(UnmanagedType.I8)] 
                 long libOffset,
                [In, MarshalAs(UnmanagedType.I8)] 
                 long cb,

                 int dwLockType);

        
         void UnlockRegion(
                [In, MarshalAs(UnmanagedType.I8)] 
                 long libOffset,
                [In, MarshalAs(UnmanagedType.I8)] 
                 long cb,

                 int dwLockType);

        
         void Stat(
                 [Out] 
                 NativeMethods.STATSTG pStatstg,
                 int grfStatFlag);

        [return: MarshalAs(UnmanagedType.Interface)]
          UnsafeNativeMethods.IStream Clone();
    }

    public class ComStreamFromDataStream : IStream {
        protected Stream dataStream;

        // to support seeking ahead of the stream length...
        private long virtualPosition = -1;

        public ComStreamFromDataStream(Stream dataStream) {
            if (dataStream == null) throw new ArgumentNullException("dataStream");
            this.dataStream = dataStream;
        }

        // Don't forget to set dataStream before using this object
        protected ComStreamFromDataStream() {
        }

        private void ActualizeVirtualPosition() {
            if (virtualPosition == -1) return;
            
            if (virtualPosition > dataStream.Length)
                dataStream.SetLength(virtualPosition);
            
            dataStream.Position = virtualPosition;
            
            virtualPosition = -1;
        }

        public IStream Clone() {
            NotImplemented();
            return null;
        }

        public void Commit(int grfCommitFlags) {
            dataStream.Flush();
            // Extend the length of the file if needed.
            ActualizeVirtualPosition();
        }

        public long CopyTo(IStream pstm, long cb, long[] pcbRead) {
            int bufsize = 4096; // one page
            IntPtr buffer = Marshal.AllocHGlobal(bufsize);
            if (buffer == IntPtr.Zero) throw new OutOfMemoryException();
            long written = 0;
            try {
                while (written < cb) {
                    int toRead = bufsize;
                    if (written + toRead > cb) toRead  = (int) (cb - written);
                    int read = Read(buffer, toRead);
                    if (read == 0) break;
                    if (pstm.Write(buffer, read) != read) {
                        throw EFail("Wrote an incorrect number of bytes");
                    }
                    written += read;
                }
            }
            finally {
                Marshal.FreeHGlobal(buffer);
            }
            if (pcbRead != null && pcbRead.Length > 0) {
                pcbRead[0] = written;
            }

            return written;
        }

        public Stream GetDataStream() {
            return dataStream;
        }

        public void LockRegion(long libOffset, long cb, int dwLockType) {
        }

        protected static ExternalException EFail(string msg) {
            ExternalException e = new ExternalException(msg, NativeMethods.E_FAIL);
            throw e;
        }
        
        protected static void NotImplemented() {
            ExternalException e = new ExternalException("Not implemented.", NativeMethods.E_NOTIMPL);
            throw e;
        }

        public int Read(IntPtr buf, /* cpr: int offset,*/  int length) {
            //        System.Text.Out.WriteLine("IStream::Read(" + length + ")");
            byte[] buffer = new byte[length];
            int count = Read(buffer, length);
            Marshal.Copy(buffer, 0, buf, length);
            return count;
        }

        public int Read(byte[] buffer, /* cpr: int offset,*/  int length) {
            ActualizeVirtualPosition();
            return dataStream.Read(buffer, 0, length);
        }

        public void Revert() {
            NotImplemented();
        }

        public long Seek(long offset, int origin) {
            // Console.WriteLine("IStream::Seek("+ offset + ", " + origin + ")");
            long pos = virtualPosition;
            if (virtualPosition == -1) {
                pos = dataStream.Position;
            }
            long len = dataStream.Length;
            switch (origin) {
                case NativeMethods.STREAM_SEEK_SET:
                    if (offset <= len) {
                        dataStream.Position = offset;
                        virtualPosition = -1;
                    }
                    else {
                        virtualPosition = offset;
                    }
                    break;
                case NativeMethods.STREAM_SEEK_END:
                    if (offset <= 0) {
                        dataStream.Position = len + offset;
                        virtualPosition = -1;
                    }
                    else {
                        virtualPosition = len + offset;
                    }
                    break;
                case NativeMethods.STREAM_SEEK_CUR:
                    if (offset+pos <= len) {
                        dataStream.Position = pos + offset;
                        virtualPosition = -1;
                    }
                    else {
                        virtualPosition = offset + pos;
                    }
                    break;
            }
            if (virtualPosition != -1) {
                return virtualPosition;
            }
            else {
                return dataStream.Position;
            }
        }

        public void SetSize(long value) {
            dataStream.SetLength(value);
        }

        public void Stat(NativeMethods.STATSTG pstatstg, int grfStatFlag) {
            pstatstg.type = 2; // STGTY_STREAM
            pstatstg.cbSize = dataStream.Length;
            pstatstg.grfLocksSupported = 2; //LOCK_EXCLUSIVE
        }

        public void UnlockRegion(long libOffset, long cb, int dwLockType) {
        }

        public int Write(IntPtr buf, /* cpr: int offset,*/ int length) {
            byte[] buffer = new byte[length];
            Marshal.Copy(buf, buffer, 0, length);
            return Write(buffer, length);
        }

        public int Write(byte[] buffer, /* cpr: int offset,*/ int length) {
            ActualizeVirtualPosition();
            dataStream.Write(buffer, 0, length);
            return length;
        }
    }
    [ComImport(), Guid("0000000B-0000-0000-C000-000000000046"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    public interface IStorage {

        [return: MarshalAs(UnmanagedType.Interface)]
          UnsafeNativeMethods.IStream CreateStream(
                [In, MarshalAs(UnmanagedType.BStr)] 
                 string pwcsName,
                [In, MarshalAs(UnmanagedType.U4)] 
                 int grfMode,
                [In, MarshalAs(UnmanagedType.U4)] 
                 int reserved1,
                [In, MarshalAs(UnmanagedType.U4)] 
                 int reserved2);

        [return: MarshalAs(UnmanagedType.Interface)]
          UnsafeNativeMethods.IStream OpenStream(
                [In, MarshalAs(UnmanagedType.BStr)] 
                 string pwcsName,

                 IntPtr reserved1,
                [In, MarshalAs(UnmanagedType.U4)] 
                 int grfMode,
                [In, MarshalAs(UnmanagedType.U4)] 
                 int reserved2);

        [return: MarshalAs(UnmanagedType.Interface)]
          UnsafeNativeMethods.IStorage CreateStorage(
                [In, MarshalAs(UnmanagedType.BStr)] 
                 string pwcsName,
                [In, MarshalAs(UnmanagedType.U4)] 
                 int grfMode,
                [In, MarshalAs(UnmanagedType.U4)] 
                 int reserved1,
                [In, MarshalAs(UnmanagedType.U4)] 
                 int reserved2);

        [return: MarshalAs(UnmanagedType.Interface)]
          UnsafeNativeMethods.IStorage OpenStorage(
                [In, MarshalAs(UnmanagedType.BStr)] 
                 string pwcsName,

                 IntPtr pstgPriority,   // must be null
                [In, MarshalAs(UnmanagedType.U4)] 
                 int grfMode,

                 IntPtr snbExclude,
                [In, MarshalAs(UnmanagedType.U4)] 
                 int reserved);

        
         void CopyTo(

                 int ciidExclude,
                [In, MarshalAs(UnmanagedType.LPArray)] 
                 Guid[] pIIDExclude,

                 IntPtr snbExclude,
                [In, MarshalAs(UnmanagedType.Interface)] 
                 UnsafeNativeMethods.IStorage stgDest);

        
         void MoveElementTo(
                [In, MarshalAs(UnmanagedType.BStr)] 
                 string pwcsName,
                [In, MarshalAs(UnmanagedType.Interface)] 
                 UnsafeNativeMethods.IStorage stgDest,
                [In, MarshalAs(UnmanagedType.BStr)] 
                 string pwcsNewName,
                [In, MarshalAs(UnmanagedType.U4)] 
                 int grfFlags);

        
         void Commit(

                 int grfCommitFlags);

        
         void Revert();

        
         void EnumElements(
                [In, MarshalAs(UnmanagedType.U4)] 
                 int reserved1,
                     // void *
                 IntPtr reserved2,
                [In, MarshalAs(UnmanagedType.U4)] 
                 int reserved3,
                [Out, MarshalAs(UnmanagedType.Interface)]
                 out object ppVal);                     // IEnumSTATSTG

        
         void DestroyElement(
                [In, MarshalAs(UnmanagedType.BStr)] 
                 string pwcsName);

        
         void RenameElement(
                [In, MarshalAs(UnmanagedType.BStr)] 
                 string pwcsOldName,
                [In, MarshalAs(UnmanagedType.BStr)] 
                 string pwcsNewName);

        
         void SetElementTimes(
                [In, MarshalAs(UnmanagedType.BStr)] 
                 string pwcsName,
                [In] 
                 NativeMethods.FILETIME pctime,
                [In] 
                 NativeMethods.FILETIME patime,
                [In] 
                 NativeMethods.FILETIME pmtime);

        
         void SetClass(
                [In] 
                 ref Guid clsid);

        
         void SetStateBits(

                 int grfStateBits,

                 int grfMask);

        
         void Stat(
                [Out] 
                 NativeMethods.STATSTG pStatStg,
                 int grfStatFlag);
    }

    [ComImport(), Guid("B196B28F-BAB4-101A-B69C-00AA00341D07"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    public interface IClassFactory2 {

        
         void CreateInstance(
                [In, MarshalAs(UnmanagedType.Interface)] 
                  object unused,
                        [In]
                  ref Guid refiid,
                [Out, MarshalAs(UnmanagedType.LPArray)] 
                  object[] ppunk);

        
         void LockServer(

                 int fLock);

        
         void GetLicInfo(
                [Out] 
                  NativeMethods.tagLICINFO licInfo);

        
         void RequestLicKey(
                [In, MarshalAs(UnmanagedType.U4)] 
                 int dwReserved,
                [Out, MarshalAs(UnmanagedType.LPArray)] 
                   string[] pBstrKey);

        
         void CreateInstanceLic(
                [In, MarshalAs(UnmanagedType.Interface)] 
                  object pUnkOuter,
                [In, MarshalAs(UnmanagedType.Interface)] 
                  object pUnkReserved,
                        [In]
                  ref Guid riid,
                [In, MarshalAs(UnmanagedType.BStr)] 
                  string bstrKey,
                [Out, MarshalAs(UnmanagedType.Interface)]
                  out object ppVal);
    }
    [ComImport(), Guid("B196B284-BAB4-101A-B69C-00AA00341D07"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    public interface IConnectionPointContainer {

        [return: MarshalAs(UnmanagedType.Interface)]
          object EnumConnectionPoints();

        [return: MarshalAs(UnmanagedType.Interface)]
          IConnectionPoint FindConnectionPoint(
                        [In]
                  ref Guid guid);

    }

    [ComImport(), Guid("B196B285-BAB4-101A-B69C-00AA00341D07"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    public interface IEnumConnectionPoints {
        [PreserveSig]
        int Next(int cConnections, out IConnectionPoint pCp, out int pcFetched);
        
        [PreserveSig]
        int Skip(int cSkip);

        void Reset();

        IEnumConnectionPoints Clone();
    }


    [ComImport(), Guid("00020400-0000-0000-C000-000000000046"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    public interface IDispatch {

        
         int GetTypeInfoCount();

        [return: MarshalAs(UnmanagedType.Interface)]
         ITypeInfo GetTypeInfo(
                [In, MarshalAs(UnmanagedType.U4)] 
                 int iTInfo,
                [In, MarshalAs(UnmanagedType.U4)] 
                 int lcid);


         [PreserveSig]
         int GetIDsOfNames(
                [In]
                 ref Guid riid,
                [In, MarshalAs(UnmanagedType.LPArray)] 
                 string[] rgszNames,
                [In, MarshalAs(UnmanagedType.U4)] 
                 int cNames,
                [In, MarshalAs(UnmanagedType.U4)] 
                 int lcid,
                [Out, MarshalAs(UnmanagedType.LPArray)]
                 int[] rgDispId);


         [PreserveSig]
         int Invoke(

                 int dispIdMember,
                [In] 
                 ref Guid riid,
                [In, MarshalAs(UnmanagedType.U4)] 
                 int lcid,
                [In, MarshalAs(UnmanagedType.U4)] 
                 int dwFlags,
                [Out, In] 
                  NativeMethods.tagDISPPARAMS pDispParams,
                [Out, MarshalAs(UnmanagedType.LPArray)] 
                  object[] pVarResult,
                [Out, In] 
                  NativeMethods.tagEXCEPINFO pExcepInfo,
                [Out, MarshalAs(UnmanagedType.LPArray)] 
                  IntPtr [] pArgErr);

    }
[ComImport(), Guid("00020401-0000-0000-C000-000000000046"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    public interface  ITypeInfo {


            [PreserveSig]
            int GetTypeAttr(ref IntPtr pTypeAttr);


            [PreserveSig]
            int GetTypeComp(
                    [Out, MarshalAs(UnmanagedType.LPArray)] 
                       UnsafeNativeMethods.ITypeComp[] ppTComp);


            [PreserveSig]
            int GetFuncDesc(
                    [In, MarshalAs(UnmanagedType.U4)] 
                     int index, ref IntPtr pFuncDesc);


             [PreserveSig]
             int GetVarDesc(
                    [In, MarshalAs(UnmanagedType.U4)] 
                     int index, ref IntPtr pVarDesc);


             [PreserveSig]
             int GetNames(

                     int memid,
                    [Out, MarshalAs(UnmanagedType.LPArray)] 
                      string[] rgBstrNames,
                    [In, MarshalAs(UnmanagedType.U4)] 
                     int cMaxNames,
                    [Out, MarshalAs(UnmanagedType.LPArray)] 
                      int[] pcNames);


            [PreserveSig]
            int GetRefTypeOfImplType(
                    [In, MarshalAs(UnmanagedType.U4)] 
                     int index,
                    [Out, MarshalAs(UnmanagedType.LPArray)] 
                      int[] pRefType);


            [PreserveSig]
            int GetImplTypeFlags(
                    [In, MarshalAs(UnmanagedType.U4)] 
                     int index,
                    [Out, MarshalAs(UnmanagedType.LPArray)] 
                      int[] pImplTypeFlags);


            [PreserveSig]
            int GetIDsOfNames(IntPtr rgszNames, int cNames, IntPtr pMemId);


            [PreserveSig]
            int Invoke();


            [PreserveSig]
            int GetDocumentation(

                     int memid,
                      ref string pBstrName,
                      ref string pBstrDocString,
                    [Out, MarshalAs(UnmanagedType.LPArray)] 
                      int[] pdwHelpContext,
                    [Out, MarshalAs(UnmanagedType.LPArray)] 
                      string[] pBstrHelpFile);


            [PreserveSig]
            int GetDllEntry(

                     int memid,

                      NativeMethods.tagINVOKEKIND invkind,
                    [Out, MarshalAs(UnmanagedType.LPArray)] 
                      string[] pBstrDllName,
                    [Out, MarshalAs(UnmanagedType.LPArray)] 
                      string[] pBstrName,
                    [Out, MarshalAs(UnmanagedType.LPArray)] 
                      short[] pwOrdinal);


             [PreserveSig]
             int GetRefTypeInfo(

                     IntPtr hreftype,
                     ref ITypeInfo pTypeInfo);


            [PreserveSig]
            int AddressOfMember();


            [PreserveSig]
            int CreateInstance(
                    [In] 
                      ref Guid riid,
                    [Out, MarshalAs(UnmanagedType.LPArray)] 
                      object[] ppvObj);


             [PreserveSig]
             int GetMops(

                     int memid,
                    [Out, MarshalAs(UnmanagedType.LPArray)] 
                     string[] pBstrMops);


            [PreserveSig]
            int GetContainingTypeLib(
                    [Out, MarshalAs(UnmanagedType.LPArray)] 
                       UnsafeNativeMethods.ITypeLib[] ppTLib,
                    [Out, MarshalAs(UnmanagedType.LPArray)] 
                      int[] pIndex);

             [PreserveSig]
             void ReleaseTypeAttr(IntPtr typeAttr);

             [PreserveSig]
             void ReleaseFuncDesc(IntPtr funcDesc);

             [PreserveSig]
             void ReleaseVarDesc(IntPtr varDesc);

    }
    [ComImport(), Guid("00020403-0000-0000-C000-000000000046"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    public interface  ITypeComp {

        
         void RemoteBind(
                [In, MarshalAs(UnmanagedType.LPWStr)] 
                 string szName,
                [In, MarshalAs(UnmanagedType.U4)] 
                 int lHashVal,
                [In, MarshalAs(UnmanagedType.U2)] 
                 short wFlags,
                [Out, MarshalAs(UnmanagedType.LPArray)] 
                   UnsafeNativeMethods.ITypeInfo[] ppTInfo,
                [Out, MarshalAs(UnmanagedType.LPArray)] 
                  NativeMethods.tagDESCKIND[] pDescKind,
                [Out, MarshalAs(UnmanagedType.LPArray)] 
                   NativeMethods.tagFUNCDESC[] ppFuncDesc,
                [Out, MarshalAs(UnmanagedType.LPArray)] 
                   NativeMethods.tagVARDESC[] ppVarDesc,
                [Out, MarshalAs(UnmanagedType.LPArray)] 
                   UnsafeNativeMethods.ITypeComp[] ppTypeComp,
                [Out, MarshalAs(UnmanagedType.LPArray)] 
                  int[] pDummy);

        
         void RemoteBindType(
                [In, MarshalAs(UnmanagedType.LPWStr)] 
                 string szName,
                [In, MarshalAs(UnmanagedType.U4)] 
                 int lHashVal,
                [Out, MarshalAs(UnmanagedType.LPArray)] 
                   UnsafeNativeMethods.ITypeInfo[] ppTInfo);

    }
    [ComImport(), Guid("00020402-0000-0000-C000-000000000046"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    public interface  ITypeLib {

        
         void RemoteGetTypeInfoCount(
                [Out, MarshalAs(UnmanagedType.LPArray)] 
                  int[] pcTInfo);

        
         void GetTypeInfo(
                [In, MarshalAs(UnmanagedType.U4)] 
                 int index,
                [Out, MarshalAs(UnmanagedType.LPArray)] 
                   UnsafeNativeMethods.ITypeInfo[] ppTInfo);

        
         void GetTypeInfoType(
                [In, MarshalAs(UnmanagedType.U4)] 
                 int index,
                [Out, MarshalAs(UnmanagedType.LPArray)] 
                  NativeMethods.tagTYPEKIND[] pTKind);

        
         void GetTypeInfoOfGuid(
                [In] 
                  ref Guid guid,
                [Out, MarshalAs(UnmanagedType.LPArray)] 
                   UnsafeNativeMethods.ITypeInfo[] ppTInfo);

        
         void RemoteGetLibAttr(
                [Out, MarshalAs(UnmanagedType.LPArray)] 
                   NativeMethods.tagTLIBATTR[] ppTLibAttr,
                [Out, MarshalAs(UnmanagedType.LPArray)] 
                  int[] pDummy);

        
         void GetTypeComp(
                [Out, MarshalAs(UnmanagedType.LPArray)] 
                   UnsafeNativeMethods.ITypeComp[] ppTComp);

        
         void RemoteGetDocumentation(
                 
                 int index,
                [In, MarshalAs(UnmanagedType.U4)] 
                 int refPtrFlags,
                [Out, MarshalAs(UnmanagedType.LPArray)] 
                 string[] pBstrName,
                [Out, MarshalAs(UnmanagedType.LPArray)] 
                 string[] pBstrDocString,
                [Out, MarshalAs(UnmanagedType.LPArray)] 
                 int[] pdwHelpContext,
                [Out, MarshalAs(UnmanagedType.LPArray)] 
                 string[] pBstrHelpFile);

        
         void RemoteIsName(
                [In, MarshalAs(UnmanagedType.LPWStr)] 
                 string szNameBuf,
                [In, MarshalAs(UnmanagedType.U4)] 
                 int lHashVal,
                [Out, MarshalAs(UnmanagedType.LPArray)] 
                 IntPtr [] pfName,
                [Out, MarshalAs(UnmanagedType.LPArray)] 
                 string[] pBstrLibName);

        
         void RemoteFindName(
                [In, MarshalAs(UnmanagedType.LPWStr)] 
                 string szNameBuf,
                [In, MarshalAs(UnmanagedType.U4)] 
                 int lHashVal,
                [Out, MarshalAs(UnmanagedType.LPArray)] 
                 UnsafeNativeMethods.ITypeInfo[] ppTInfo,
                [Out, MarshalAs(UnmanagedType.LPArray)] 
                 int[] rgMemId,
                [In, Out, MarshalAs(UnmanagedType.LPArray)] 
                 short[] pcFound,
                [Out, MarshalAs(UnmanagedType.LPArray)] 
                 string[] pBstrLibName);

        
         void LocalReleaseTLibAttr();
    }

    [ComImport(), 
     
     Guid("DF0B3D60-548F-101B-8E65-08002B2BD119"), 
     InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    public interface ISupportErrorInfo {

        int InterfaceSupportsErrorInfo(
                [In] ref Guid riid);


    }
    [ComImport(), 
     
     Guid("1CF2B120-547D-101B-8E65-08002B2BD119"), 
     InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    public interface IErrorInfo {

        [ System.Security.SuppressUnmanagedCodeSecurityAttribute()]
        [PreserveSig]
        int GetGUID(
                   [Out]
                   out Guid pguid);

        [ System.Security.SuppressUnmanagedCodeSecurityAttribute()]
        [PreserveSig]
        int GetSource(
                     [In, Out, MarshalAs(UnmanagedType.BStr)] 
                     ref string pBstrSource);

        [ System.Security.SuppressUnmanagedCodeSecurityAttribute()]
        [PreserveSig]
        int GetDescription(
                          [In, Out, MarshalAs(UnmanagedType.BStr)] 
                          ref string pBstrDescription);

        [ System.Security.SuppressUnmanagedCodeSecurityAttribute()]
        [PreserveSig]
        int GetHelpFile(
                       [In, Out, MarshalAs(UnmanagedType.BStr)] 
                       ref string pBstrHelpFile);

        [ System.Security.SuppressUnmanagedCodeSecurityAttribute()]
        [PreserveSig]
        int GetHelpContext(
                          [In, Out, MarshalAs(UnmanagedType.U4)] 
                          ref int pdwHelpContext);

    }
    [StructLayout(LayoutKind.Sequential), CLSCompliantAttribute(false)]
    public sealed class tagQACONTAINER
    {
      [MarshalAs(UnmanagedType.U4)]
      public int cbSize = Marshal.SizeOf(typeof(tagQACONTAINER));

      public UnsafeNativeMethods.IOleClientSite pClientSite;

      [MarshalAs(UnmanagedType.Interface)]
      public object pAdviseSink;

      public UnsafeNativeMethods.IPropertyNotifySink pPropertyNotifySink;

      [MarshalAs(UnmanagedType.Interface)]
      public object pUnkEventSink;

      [MarshalAs(UnmanagedType.U4)]
      public int dwAmbientFlags;

      [MarshalAs(UnmanagedType.U4)]
      public UInt32 colorFore;

      [MarshalAs(UnmanagedType.U4)]
      public UInt32 colorBack;

      [MarshalAs(UnmanagedType.Interface)]
      public object pFont;

      [MarshalAs(UnmanagedType.Interface)]
      public object pUndoMgr;

      [MarshalAs(UnmanagedType.U4)]
      public int dwAppearance;

      public int lcid;

      public IntPtr hpal;

      [MarshalAs(UnmanagedType.Interface)]
      public object pBindHost;
    
      // visual basic6 uses a old version of the struct that is missing these two fields.
      // So, ActiveX sourcing does not work, with the EE trying to read off the
      // end of the stack to get to these variables. If I do not define these,
      // Office or any of the other hosts will hopefully get nulls, otherwise they
      // will crash.
      //
      //public UnsafeNativeMethods.IOleControlSite pControlSite;
    
      //public UnsafeNativeMethods.IOleServiceProvider pServiceProvider;
    }

    [StructLayout(LayoutKind.Sequential)/*leftover(noAutoOffset)*/]
    public sealed class tagQACONTROL
    {
      [MarshalAs(UnmanagedType.U4)/*leftover(offset=0, cbSize)*/]
      public int cbSize = Marshal.SizeOf(typeof(tagQACONTROL));

      [MarshalAs(UnmanagedType.U4)/*leftover(offset=4, dwMiscStatus)*/]
      public int dwMiscStatus;

      [MarshalAs(UnmanagedType.U4)/*leftover(offset=8, dwViewStatus)*/]
      public int dwViewStatus;

      [MarshalAs(UnmanagedType.U4)/*leftover(offset=12, dwEventCookie)*/]
      public int dwEventCookie;

      [MarshalAs(UnmanagedType.U4)/*leftover(offset=16, dwPropNotifyCookie)*/]
      public int dwPropNotifyCookie;

      [MarshalAs(UnmanagedType.U4)/*leftover(offset=20, dwPointerActivationPolicy)*/]
      public int dwPointerActivationPolicy;

    }
    [ComImport(), Guid("0000000A-0000-0000-C000-000000000046"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    public interface ILockBytes {

        
         void ReadAt(
                [In, MarshalAs(UnmanagedType.U8)] 
                 long ulOffset,
                [Out] 
                 IntPtr pv,
                [In, MarshalAs(UnmanagedType.U4)] 
                 int cb,
                [Out, MarshalAs(UnmanagedType.LPArray)] 
                 int[] pcbRead);

        
         void WriteAt(
                [In, MarshalAs(UnmanagedType.U8)] 
                 long ulOffset,

                 IntPtr pv,
                [In, MarshalAs(UnmanagedType.U4)] 
                 int cb,
                [Out, MarshalAs(UnmanagedType.LPArray)] 
                 int[] pcbWritten);

        
         void Flush();

        
         void SetSize(
                [In, MarshalAs(UnmanagedType.U8)] 
                 long cb);

        
         void LockRegion(
                [In, MarshalAs(UnmanagedType.U8)] 
                 long libOffset,
                [In, MarshalAs(UnmanagedType.U8)] 
                 long cb,
                [In, MarshalAs(UnmanagedType.U4)] 
                 int dwLockType);

        
         void UnlockRegion(
                [In, MarshalAs(UnmanagedType.U8)] 
                 long libOffset,
                [In, MarshalAs(UnmanagedType.U8)] 
                 long cb,
                [In, MarshalAs(UnmanagedType.U4)] 
                 int dwLockType);

        
         void Stat(
                [Out] 
                  NativeMethods.STATSTG pstatstg,
                [In, MarshalAs(UnmanagedType.U4)] 
                 int grfStatFlag);

    }
    
    [StructLayout(LayoutKind.Sequential),
        SuppressUnmanagedCodeSecurity()]
    public class OFNOTIFY
    {
        // hdr was a by-value NMHDR structure
        public IntPtr hdr_hwndFrom;
        public int  hdr_idFrom;
        public int  hdr_code;
    
        public IntPtr lpOFN;
        public IntPtr pszFile;
    }
    
    // SECUNDONE : For some reason "PtrToStructure" requires super high permission.. put this 
    //           : assert here until we can get a resolution on this.
    //
    [ReflectionPermission(SecurityAction.Assert, Unrestricted=true),
        SecurityPermission(SecurityAction.Assert, Flags=SecurityPermissionFlag.UnmanagedCode)]
    public static object PtrToStructure(IntPtr lparam, Type cls) {
        return Marshal.PtrToStructure(lparam, cls);
    }
    
    // SECUNDONE : For some reason "PtrToStructure" requires super high permission.. put this 
    //           : assert here until we can get a resolution on this.
    //
    [ReflectionPermission(SecurityAction.Assert, Unrestricted=true),
        SecurityPermission(SecurityAction.Assert, Flags=SecurityPermissionFlag.UnmanagedCode)]
    public static void PtrToStructure(IntPtr lparam, object data) {
        Marshal.PtrToStructure(lparam, data);
    }

        public delegate int BrowseCallbackProc(
            IntPtr hwnd,
            int msg, 
            IntPtr lParam, 
            IntPtr lpData);

        [System.Runtime.InteropServices.ComVisible(false), Flags]    
        public enum BrowseInfos
        {
            NewDialogStyle      = 0x0040,   // Use the new dialog layout with the ability to resize
            HideNewFolderButton = 0x0200    // Don't display the 'New Folder' button
        }

        [System.Runtime.InteropServices.ComVisible(false), StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto)]
        public class BROWSEINFO 
        {
            public IntPtr             hwndOwner;       //HWND        hwndOwner;            // HWND of the owner for the dialog
            public IntPtr             pidlRoot;        //LPCITEMIDLIST pidlRoot;           // Root ITEMIDLIST
    
            // For interop purposes, send over a buffer of MAX_PATH size. 
            public IntPtr             pszDisplayName;  //LPWSTR       pszDisplayName;      // Return display name of item selected.
    
            public string             lpszTitle;       //LPCWSTR      lpszTitle;           // text to go in the banner over the tree.
            public int                ulFlags;         //UINT         ulFlags;             // Flags that control the return stuff
            public BrowseCallbackProc lpfn;            //BFFCALLBACK  lpfn;                // Call back pointer
            public IntPtr             lParam;          //LPARAM       lParam;              // extra info that's passed back in callbacks
            public int                iImage;          //int          iImage;              // output var: where to return the Image index.
        }

        [
        System.Runtime.InteropServices.ComVisible(false),
        SuppressUnmanagedCodeSecurity()
        ]
        internal class Shell32 
        {
            [DllImport(ExternDll.Shell32)]
            public static extern int SHGetSpecialFolderLocation(IntPtr hwnd, int csidl, ref IntPtr ppidl);
            //SHSTDAPI SHGetSpecialFolderLocation(HWND hwnd, int csidl, LPITEMIDLIST *ppidl);
    
            [DllImport(ExternDll.Shell32, CharSet=CharSet.Auto)]
            public static extern bool SHGetPathFromIDList(IntPtr pidl, IntPtr pszPath);        
            //SHSTDAPI_(BOOL) SHGetPathFromIDListW(LPCITEMIDLIST pidl, LPWSTR pszPath);
            
            [DllImport(ExternDll.Shell32, CharSet=CharSet.Auto)]
            public static extern IntPtr SHBrowseForFolder([In] BROWSEINFO lpbi);        
            //SHSTDAPI_(LPITEMIDLIST) SHBrowseForFolderW(LPBROWSEINFOW lpbi);
    
            [DllImport(ExternDll.Shell32)]
            public static extern int SHGetMalloc([Out, MarshalAs(UnmanagedType.LPArray)] UnsafeNativeMethods.IMalloc[] ppMalloc);
            //SHSTDAPI SHGetMalloc(LPMALLOC * ppMalloc);
        }

        [
        ComImport(), 
        Guid("00000002-0000-0000-c000-000000000046"), 
        System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown),
        SuppressUnmanagedCodeSecurity()
        ]
        public interface IMalloc 
        {
    
            IntPtr Alloc(
    
                int cb);
    
            void Free(
    
                IntPtr pv);
    
    
            IntPtr Realloc(
    
                IntPtr pv,
    
                int cb);
    
    
            int GetSize(
    
                IntPtr pv);
    
    
            int DidAlloc(
    
                IntPtr pv);
    
            void HeapMinimize();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\treeview.cs ===
//------------------------------------------------------------------------------
// <copyright file="TreeView.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;
    using System.Security.Permissions;

    using System.Drawing;
    using System.Drawing.Design;
    using System.Windows.Forms;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Collections;
    using Microsoft.Win32;
    using System.Reflection;

    /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Displays a hierarchical list of items, or nodes. Each
    ///       node includes a caption and an optional bitmap. The user can select a node. If
    ///       it has sub-nodes, the user can collapse or expand the node.
    ///
    ///    </para>
    /// </devdoc>
    [
    DefaultProperty("Nodes"),
    DefaultEvent("AfterSelect"),
    Designer("System.Windows.Forms.Design.TreeViewDesigner, " + AssemblyRef.SystemDesign)
    ]
    public class TreeView : Control {

        private static readonly int MaxIndent = 32000;      // Maximum allowable TreeView indent                               
        private static readonly string backSlash = "\\";
        private const int DefaultTreeViewIndent = 19;
                     
        private NodeLabelEditEventHandler onBeforeLabelEdit;
        private NodeLabelEditEventHandler onAfterLabelEdit;
        private TreeViewCancelEventHandler onBeforeCheck;
        private TreeViewEventHandler onAfterCheck;
        private TreeViewCancelEventHandler onBeforeCollapse;
        private TreeViewEventHandler onAfterCollapse;
        private TreeViewCancelEventHandler onBeforeExpand;
        private TreeViewEventHandler onAfterExpand;
        private TreeViewCancelEventHandler onBeforeSelect;
        private TreeViewEventHandler onAfterSelect;
        private ItemDragEventHandler onItemDrag;

        internal TreeNode selectedNode = null;
        internal int selectedImageIndex = 0;
        private bool hideSelection = true;
        internal int imageIndex = 0;
        private ImageList imageList;
        private int indent = -1;
        private int itemHeight = -1;
        private string pathSeparator = backSlash;
        private bool labelEdit = false;
        private bool scrollable = true;
        private BorderStyle borderStyle = System.Windows.Forms.BorderStyle.Fixed3D;
        private bool checkBoxes = false;
        private bool showLines = true;
        private bool showPlusMinus = true;
        private bool showRootLines = true;
        private bool sorted = false;
        private bool hotTracking = false;
        private bool fullRowSelect = false;

        internal TreeNodeCollection nodes;
        internal TreeNode editNode;
        internal TreeNode root;
        internal Hashtable nodeTable = new Hashtable();
        private int updateCount;
        private MouseButtons downButton;
        private bool doubleclickFired = false;
        private bool mouseUpFired = false;
        
        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.TreeView"]/*' />
        /// <devdoc>
        ///     Creates a TreeView control
        /// </devdoc>
        public TreeView()
        : base() {

            root = new TreeNode(this);
            nodes = new TreeNodeCollection(root);
            SetStyle(ControlStyles.UserPaint, false);
            SetStyle(ControlStyles.StandardClick, false);            
        }

        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.BackColor"]/*' />
        /// <devdoc>
        ///     The background color for this control. Specifying null for
        ///     this parameter sets the
        ///     control's background color to its parent's background color.
        /// </devdoc>
        public override Color BackColor {
            get {
                if (ShouldSerializeBackColor()) {
                    return base.BackColor;
                }
                else {
                    return SystemColors.Window;
                }
            }

            set {
                base.BackColor = value;
                if (IsHandleCreated) {
                    SendMessage(NativeMethods.TVM_SETBKCOLOR, 0, ColorTranslator.ToWin32(BackColor));

                    // This is to get around a problem in the comctl control where the lines
                    // connecting nodes don't get the new BackColor.  This messages forces
                    // reconstruction of the line bitmaps without changing anything else.
                    SendMessage(NativeMethods.TVM_SETINDENT, Indent, 0);
                }                
            }
        }

        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.BackgroundImage"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override Image BackgroundImage {
            get {
                return base.BackgroundImage;
            }
            set {
                base.BackgroundImage = value;
            }
        }

        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.BackgroundImageChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler BackgroundImageChanged {
            add {
                base.BackgroundImageChanged += value;
            }
            remove {
                base.BackgroundImageChanged -= value;
            }
        }

        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.BorderStyle"]/*' />
        /// <devdoc>
        ///     The border style of the window.
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        DefaultValue(BorderStyle.Fixed3D),
        DispId(NativeMethods.ActiveX.DISPID_BORDERSTYLE),
        SRDescription(SR.borderStyleDescr)
        ]
        public BorderStyle BorderStyle {
            get {
                return borderStyle;
            }

            set {
                if (borderStyle != value) {
                    //verify that 'value' is a valid enum type...

                    if ( !Enum.IsDefined(typeof(BorderStyle), value)) {
                        throw new InvalidEnumArgumentException("value", (int)value, typeof(BorderStyle));
                    }

                    borderStyle = value;
                    UpdateStyles();
                }
            }
        }

        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.CheckBoxes"]/*' />
        /// <devdoc>
        ///     The value of the CheckBoxes property. The CheckBoxes
        ///     property determines if check boxes are shown next to node in the
        ///     tree view.
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        DefaultValue(false),
        SRDescription(SR.TreeViewCheckBoxesDescr)
        ]
        public bool CheckBoxes {
            get {
                return checkBoxes;
            }

            set {
                if (checkBoxes != value) {
                    checkBoxes = value;
                    if (IsHandleCreated) {
                        // Going from true to false requires recreation
                        if (checkBoxes)
                            UpdateStyles();
                        else
                            RecreateHandle();
                    }
                }
            }
        }

        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.CreateParams"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        protected override CreateParams CreateParams {
            [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
            get {
                CreateParams cp = base.CreateParams;
                cp.ClassName = NativeMethods.WC_TREEVIEW;

                // V#45599 Keep the scrollbar if we are just updating styles...
                //
                if (IsHandleCreated) {
                    int currentStyle = (int)UnsafeNativeMethods.GetWindowLong(new HandleRef(this, Handle), NativeMethods.GWL_STYLE);
                    cp.Style |= (currentStyle & (NativeMethods.WS_HSCROLL | NativeMethods.WS_VSCROLL));
                }

                switch (borderStyle) {
                    case BorderStyle.Fixed3D:
                        cp.ExStyle |= NativeMethods.WS_EX_CLIENTEDGE;
                        break;
                    case BorderStyle.FixedSingle:
                        cp.Style |= NativeMethods.WS_BORDER;
                        break;
                }

                if (RightToLeft == RightToLeft.Yes) {
                    cp.Style |= NativeMethods.TVS_RTLREADING;
                }

                if (!scrollable)
                    cp.Style |= NativeMethods.LVS_NOSCROLL;

                if (!hideSelection)
                    cp.Style |= NativeMethods.TVS_SHOWSELALWAYS;
                if (labelEdit)
                    cp.Style |= NativeMethods.TVS_EDITLABELS;
                if (showLines)
                    cp.Style |= NativeMethods.TVS_HASLINES;
                if (showPlusMinus)
                    cp.Style |= NativeMethods.TVS_HASBUTTONS;
                if (showRootLines)
                    cp.Style |= NativeMethods.TVS_LINESATROOT;
                if (hotTracking)
                    cp.Style |= NativeMethods.TVS_TRACKSELECT;
                if (fullRowSelect)
                    cp.Style |= NativeMethods.TVS_FULLROWSELECT;

                // Don't set TVS_CHECKBOXES here if the window isn't created yet.
                // See OnHandleCreated for explaination
                if (checkBoxes && IsHandleCreated)
                    cp.Style |= NativeMethods.TVS_CHECKBOXES;

                return cp;
            }
        }
        
        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.DefaultSize"]/*' />
        /// <devdoc>
        ///     Deriving classes can override this to configure a default size for their control.
        ///     This is more efficient than setting the size in the control's constructor.
        /// </devdoc>
        protected override Size DefaultSize {
            get {
                return new Size(121, 97);
            }
        }

        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.ForeColor"]/*' />
        /// <devdoc>
        ///     The current foreground color for this control, which is the
        ///     color the control uses to draw its text.
        /// </devdoc>
        public override Color ForeColor {
            get { 
                if (ShouldSerializeForeColor()) {
                    return base.ForeColor;
                }
                else {
                    return SystemColors.WindowText;
                }
            }

            set {
                base.ForeColor = value;
                if (IsHandleCreated)
                    SendMessage(NativeMethods.TVM_SETTEXTCOLOR, 0, ColorTranslator.ToWin32(ForeColor));
            }
        }

        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.FullRowSelect"]/*' />
        /// <devdoc>
        ///     Determines whether the selection highlight spans across the width of the TreeView.
        ///     This property will have no effect if ShowLines is true.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(false),
        SRDescription(SR.TreeViewFullRowSelectDescr)
        ]
        public bool FullRowSelect {
            get { return fullRowSelect;}
            set {
                if (fullRowSelect != value) {
                    fullRowSelect = value;
                    if (IsHandleCreated) {
                        UpdateStyles();
                    }
                }
            }
        }

        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.HideSelection"]/*' />
        /// <devdoc>
        ///     The hideSelection property specifies whether the selected node will
        ///     be highlighted even when the TreeView loses focus.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(true),
        SRDescription(SR.TreeViewHideSelectionDescr)
        ]
        public bool HideSelection {
            get {
                return hideSelection;
            }

            set {
                if (hideSelection != value) {
                    hideSelection = value;
                    if (IsHandleCreated) {
                        UpdateStyles();
                    }
                }
            }
        }

        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.HotTracking"]/*' />
        /// <devdoc>
        ///     The value of the HotTracking property. The HotTracking
        ///     property determines if nodes are highlighted as the mousepointer
        ///     passes over them.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(false),
        SRDescription(SR.TreeViewHotTrackingDescr)
        ]
        public bool HotTracking {
            get {
                return hotTracking;
            }

            set {
                if (hotTracking != value) {
                    hotTracking = value;
                    if (IsHandleCreated) {
                        UpdateStyles();
                    }
                }
            }
        }

        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.ImageIndex"]/*' />
        /// <devdoc>
        ///     The default image index for nodes in the tree view.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        Localizable(true),
        TypeConverterAttribute(typeof(TreeViewImageIndexConverter)),
        Editor("System.Windows.Forms.Design.ImageIndexEditor, " + AssemblyRef.SystemDesign, typeof(UITypeEditor)),
        DefaultValue(0),
        SRDescription(SR.TreeViewImageIndexDescr)
        ]
        public int ImageIndex {
            get {
                if (imageList == null) {
                    return -1;
                }
                if (imageIndex >= imageList.Images.Count) {
                    return Math.Max(0, imageList.Images.Count - 1);
                }
                return imageIndex;
            }

            set {
                // If (none) is selected in the image index editor, we'll just adjust this to
                // mean image index 0. This is because a treeview must always have an image index -
                // even if no imagelist exists we want the image index to be 0.
                //
                if (value == -1) {
                    value = 0;
                }
                
                if (value < 0) {
                    throw new ArgumentException(SR.GetString(SR.InvalidLowBoundArgumentEx, "value", value.ToString(), "0"));
                }
                
                if (imageIndex != value) {
                    imageIndex = value;
                    if (IsHandleCreated) {
                        RecreateHandle();
                    }
                }
            }
        }

        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.ImageList"]/*' />
        /// <devdoc>
        ///     Returns the image list control that is bound to the tree view.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(null),
        SRDescription(SR.TreeViewImageListDescr)
        ]
        public ImageList ImageList {
            get {
                return imageList;
            }
            set {
                if (value != imageList) {
                    EventHandler recreateHandler = new EventHandler(ImageListRecreateHandle);
                    EventHandler disposedHandler = new EventHandler(DetachImageList);

                    // Detach old event handlers
                    //
                    if (imageList != null) {
                        imageList.RecreateHandle -= recreateHandler;
                        imageList.Disposed -= disposedHandler;                        
                    }

                    imageList = value;

                    // Wire up new event handlers
                    //
                    if (value != null) {
                        value.RecreateHandle += recreateHandler;
                        value.Disposed += disposedHandler;                                               
                    }

                    // Update TreeView's images
                    //
                    if (IsHandleCreated) {
                        SendMessage(NativeMethods.TVM_SETIMAGELIST, 0,
                                    value==null? IntPtr.Zero: value.Handle);
                    }
                }
            }
        }

        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.Indent"]/*' />
        /// <devdoc>
        ///     The indentation level in pixels.
        /// </devdoc>
        [
        Localizable(true),
        SRCategory(SR.CatBehavior),
        SRDescription(SR.TreeViewIndentDescr)
        ]
        public int Indent {
            get {
                if (indent != -1) {
                    return indent;
                }
                else if (IsHandleCreated) {
                    return (int)SendMessage(NativeMethods.TVM_GETINDENT, 0, 0);
                }
                return DefaultTreeViewIndent;
            }

            set {
                if (indent != value) {
                    if (value < 0) {
                        throw new ArgumentException(SR.GetString(SR.InvalidLowBoundArgumentEx, "Indent",
                                                                 (value).ToString(), "0"));
                    }
                    if (value > MaxIndent) {
                        throw new ArgumentException(SR.GetString(SR.InvalidHighBoundArgumentEx, "Indent",
                                                                 (value).ToString(), (MaxIndent).ToString()));
                    }
                    indent = value;
                    if (IsHandleCreated) {
                        SendMessage(NativeMethods.TVM_SETINDENT, value, 0);
                        indent = (int)SendMessage(NativeMethods.TVM_GETINDENT, 0, 0);
                    }
                }
            }
        }

        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.ItemHeight"]/*' />
        /// <devdoc>
        ///     The height of every item in the tree view, in pixels.
        /// </devdoc>
        [
        Localizable(true),
        SRCategory(SR.CatAppearance),
        SRDescription(SR.TreeViewItemHeightDescr)
        ]
        public int ItemHeight {
            get {
                if (itemHeight != -1) {
                    return itemHeight;
                }
                
                if (IsHandleCreated) {
                    return (int)SendMessage(NativeMethods.TVM_GETITEMHEIGHT, 0, 0);
                }
                else {
                    return FontHeight + 3;
                }
            }

            set {
                if (itemHeight != value) {
                    if (value < 1) {
                        throw new ArgumentException(SR.GetString(SR.InvalidLowBoundArgumentEx, "ItemHeight",
                                                                 (value).ToString(), "1"));
                    }
                    if (value >= Int16.MaxValue) {
                        throw new ArgumentException(SR.GetString(SR.InvalidHighBoundArgument, "ItemHeight",
                                                                 (value).ToString(), Int16.MaxValue.ToString()));
                    }
                    itemHeight = value;
                    if (IsHandleCreated) {
                        SendMessage(NativeMethods.TVM_SETITEMHEIGHT, value, 0);
                        itemHeight = (int)SendMessage(NativeMethods.TVM_GETITEMHEIGHT, 0, 0);
                    }
                }
            }
        }

        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.LabelEdit"]/*' />
        /// <devdoc>
        ///     The LabelEdit property determines if the label text
        ///     of nodes in the tree view is editable.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(false),
        SRDescription(SR.TreeViewLabelEditDescr)
        ]
        public bool LabelEdit {
            get {
                return labelEdit;
            }
            set {
                if (labelEdit != value) {
                    labelEdit = value;
                    if (IsHandleCreated) {
                        UpdateStyles();
                    }
                }
            }
        }

        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.Nodes"]/*' />
        /// <devdoc>
        ///     The collection of nodes associated with this TreeView control
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Content),
        Localizable(true),
        SRDescription(SR.TreeViewNodesDescr),
        MergableProperty(false)
        ]
        public TreeNodeCollection Nodes {
            get {
                return nodes;
            }
        }

        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.PathSeparator"]/*' />
        /// <devdoc>
        ///     The delimeter string used by TreeNode.getFullPath().
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue("\\"),
        SRDescription(SR.TreeViewPathSeparatorDescr)
        ]
        public string PathSeparator {
            get {
                return pathSeparator;
            }
            set {
                pathSeparator = value;
            }
        }

        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.Scrollable"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(true),
        SRDescription(SR.TreeViewScrollableDescr)
        ]
        public bool Scrollable {
            get {
                return scrollable;
            }
            set {
                if (scrollable != value) {
                    scrollable = value;
                    RecreateHandle();
                }
            }
        }

        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.SelectedImageIndex"]/*' />
        /// <devdoc>
        ///     The image index that a node will display when selected.
        ///     The index applies to the ImageList referred to by the imageList property,
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        TypeConverterAttribute(typeof(TreeViewImageIndexConverter)),
        Localizable(true),
        Editor("System.Windows.Forms.Design.ImageIndexEditor, " + AssemblyRef.SystemDesign, typeof(UITypeEditor)),
        DefaultValue(0),
        SRDescription(SR.TreeViewSelectedImageIndexDescr)
        ]
        public int SelectedImageIndex {
            get {
                if (imageList == null) {
                    return -1;
                }
                if (selectedImageIndex >= imageList.Images.Count) {
                    return Math.Max(0, imageList.Images.Count - 1);
                }
                return selectedImageIndex;
            }
            set {
                // If (none) is selected in the image index editor, we'll just adjust this to
                // mean image index 0. This is because a treeview must always have an image index -
                // even if no imagelist exists we want the image index to be 0.
                //
                if (value == -1) {
                    value = 0;
                }
                
                if (value < 0) {
                    throw new ArgumentException(SR.GetString(SR.InvalidLowBoundArgumentEx, "value", value.ToString(), "0"));
                }
                if (selectedImageIndex != value) {
                    selectedImageIndex = value;
                    if (IsHandleCreated) {
                        RecreateHandle();
                    }
                }
            }
        }

        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.SelectedNode"]/*' />
        /// <devdoc>
        ///     The currently selected tree node, or null if nothing is selected.
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.TreeViewSelectedNodeDescr)
        ]
        public TreeNode SelectedNode {
            get {
                if (IsHandleCreated) {
                    Debug.Assert(selectedNode == null || selectedNode.TreeView != this, "handle is created, but we're still caching selectedNode");
                    IntPtr hItem = SendMessage(NativeMethods.TVM_GETNEXTITEM, NativeMethods.TVGN_CARET, 0);
                    if (hItem == IntPtr.Zero)
                        return null;
                    return NodeFromHandle(hItem);
                }
                else if (selectedNode != null && selectedNode.TreeView == this) {
                    return selectedNode;
                }
                else {
                    return null;
                }
            }
            set {
                if (IsHandleCreated && (value == null || value.TreeView == this)) {
                    // This class invariant is not quite correct -- if the selected node does not belong to this Treeview,
                    // selectedNode != null even though the handle is created.  We will call set_SelectedNode
                    // to inform the handle that the selected node has been added to the TreeView.
                    Debug.Assert(selectedNode == null || selectedNode.TreeView != this, "handle is created, but we're still caching selectedNode");
                    
                    IntPtr hnode = (value == null ? IntPtr.Zero : value.Handle);
                    SendMessage(NativeMethods.TVM_SELECTITEM, NativeMethods.TVGN_CARET, hnode);
                    selectedNode = null;
                }
                else {
                    selectedNode = value;
                }
            }
        }

        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.ShowLines"]/*' />
        /// <devdoc>
        ///     The ShowLines property determines if lines are drawn between
        ///     nodes in the tree view.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(true),
        SRDescription(SR.TreeViewShowLinesDescr)
        ]
        public bool ShowLines {
            get {
                return showLines;
            }
            set {
                if (showLines != value) {
                    showLines = value;
                    if (IsHandleCreated) {
                        UpdateStyles();
                    }
                }
            }
        }

        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.ShowPlusMinus"]/*' />
        /// <devdoc>
        ///     The ShowPlusMinus property determines if the "plus/minus"
        ///     expand button is shown next to tree nodes that have children.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(true),
        SRDescription(SR.TreeViewShowPlusMinusDescr)
        ]
        public bool ShowPlusMinus {
            get {
                return showPlusMinus;
            }
            set {
                if (showPlusMinus != value) {
                    showPlusMinus = value;
                    if (IsHandleCreated) {
                        UpdateStyles();
                    }
                }
            }
        }

        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.ShowRootLines"]/*' />
        /// <devdoc>
        ///     Determines if lines are draw between nodes at the root of
        ///     the tree view.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(true),
        SRDescription(SR.TreeViewShowRootLinesDescr)
        ]
        public bool ShowRootLines {
            get { return showRootLines;}
            set {
                if (showRootLines != value) {
                    showRootLines = value;
                    if (IsHandleCreated) {
                        UpdateStyles();
                    }
                }
            }
        }

        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.Sorted"]/*' />
        /// <devdoc>
        ///     The Sorted property determines if nodes in the tree view are sorted.
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(false),
        SRDescription(SR.TreeViewSortedDescr)
        ]
        public bool Sorted {
            get {
                return sorted;
            }
            set {
                if (sorted != value) {
                    sorted = value;
                    if (sorted && Nodes.Count > 1) {
                        RefreshNodes();
                    }
                }
            }
        }
        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.Text"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>        
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never), Bindable(false)]        
        public override string Text {
            get {
                return base.Text;
            }
            set {
                base.Text = value;
            }
        }

        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.TextChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler TextChanged {
            add {
                base.TextChanged += value;
            }
            remove {
                base.TextChanged -= value;
            }
        }
        
        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.TopNode"]/*' />
        /// <devdoc>
        ///     The first visible node in the TreeView. Initially
        ///     the first root node is at the top of the TreeView, but if the
        ///     contents have been scrolled another node may be at the top.
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.TreeViewTopNodeDescr)
        ]
        public TreeNode TopNode {
            get {
                if (IsHandleCreated) {
                    IntPtr hitem = SendMessage(NativeMethods.TVM_GETNEXTITEM, NativeMethods.TVGN_FIRSTVISIBLE, 0);
                    return(hitem == IntPtr.Zero ? null : NodeFromHandle(hitem));
                }

                return null;
            }
        }

        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.VisibleCount"]/*' />
        /// <devdoc>
        ///     The count of fully visible nodes in the tree view.  This number
        ///     may be greater than the number of nodes in the control.
        ///     The control calculates this value by dividing the height of the
        ///     client window by the height of an item
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.TreeViewVisibleCountDescr)
        ]
        public int VisibleCount {
            get {
                if (IsHandleCreated)
                    return (int)SendMessage(NativeMethods.TVM_GETVISIBLECOUNT, 0, 0);

                return 0;
            }
        }


        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.BeforeLabelEdit"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatBehavior), SRDescription(SR.TreeViewBeforeEditDescr)]
        public event NodeLabelEditEventHandler BeforeLabelEdit {
            add {
                onBeforeLabelEdit += value;
            }
            remove {
                onBeforeLabelEdit -= value;
            }
        }        


        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.AfterLabelEdit"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatBehavior), SRDescription(SR.TreeViewAfterEditDescr)]
        public event NodeLabelEditEventHandler AfterLabelEdit {
            add {
                onAfterLabelEdit += value;
            }
            remove {
                onAfterLabelEdit -= value;
            }
        }        


        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.BeforeCheck"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatBehavior), SRDescription(SR.TreeViewBeforeCheckDescr)]
        public event TreeViewCancelEventHandler BeforeCheck {
            add {
                onBeforeCheck += value;
            }
            remove {
                onBeforeCheck -= value;
            }
        }        


        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.AfterCheck"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatBehavior), SRDescription(SR.TreeViewAfterCheckDescr)]
        public event TreeViewEventHandler AfterCheck {
            add {
                onAfterCheck += value;
            }
            remove {
                onAfterCheck -= value;
            }
        }        


        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.BeforeCollapse"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatBehavior), SRDescription(SR.TreeViewBeforeCollapseDescr)]
        public event TreeViewCancelEventHandler BeforeCollapse {
            add {
                onBeforeCollapse += value;
            }
            remove {
                onBeforeCollapse -= value;
            }
        }        


        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.AfterCollapse"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatBehavior), SRDescription(SR.TreeViewAfterCollapseDescr)]
        public event TreeViewEventHandler AfterCollapse {
            add {
                onAfterCollapse += value;
            }
            remove {
                onAfterCollapse -= value;
            }
        }        


        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.BeforeExpand"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatBehavior), SRDescription(SR.TreeViewBeforeExpandDescr)]
        public event TreeViewCancelEventHandler BeforeExpand {
            add {
                onBeforeExpand += value;
            }
            remove {
                onBeforeExpand -= value;
            }
        }        


        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.AfterExpand"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatBehavior), SRDescription(SR.TreeViewAfterExpandDescr)]
        public event TreeViewEventHandler AfterExpand {
            add {
                onAfterExpand += value;
            }
            remove {
                onAfterExpand -= value;
            }
        }        


        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.ItemDrag"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatAction), SRDescription(SR.ListViewItemDragDescr)]
        public event ItemDragEventHandler ItemDrag {
            add {
                onItemDrag += value;
            }
            remove {
                onItemDrag -= value;
            }
        }        


        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.BeforeSelect"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatBehavior), SRDescription(SR.TreeViewBeforeSelectDescr)]
        public event TreeViewCancelEventHandler BeforeSelect {
            add {
                onBeforeSelect += value;
            }
            remove {
                onBeforeSelect -= value;
            }
        }        


        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.AfterSelect"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [SRCategory(SR.CatBehavior), SRDescription(SR.TreeViewAfterSelectDescr)]
        public event TreeViewEventHandler AfterSelect {
            add {
                onAfterSelect += value;
            }
            remove {
                onAfterSelect -= value;
            }
        }

        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.OnPaint"]/*' />
        /// <devdoc>
        ///     TreeView Onpaint.
        /// </devdoc>
        /// <internalonly/><hideinheritance/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event PaintEventHandler Paint {
            add {
                base.Paint += value;
            }
            remove {
                base.Paint -= value;
            }
        }


        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.BeginUpdate"]/*' />
        /// <devdoc>
        ///     Disables redrawing of the tree view. A call to beginUpdate() must be
        ///     balanced by a following call to endUpdate(). Following a call to
        ///     beginUpdate(), any redrawing caused by operations performed on the
        ///     tree view is deferred until the call to endUpdate().
        /// </devdoc>
        public void BeginUpdate() {
            BeginUpdateInternal();
        }

        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.CollapseAll"]/*' />
        /// <devdoc>
        ///     Collapses all nodes at the root level.
        /// </devdoc>
        public void CollapseAll() {
            root.Collapse();
        }

        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.CreateHandle"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        protected override void CreateHandle() {
            if (!RecreatingHandle) {
                NativeMethods.INITCOMMONCONTROLSEX icc = new NativeMethods.INITCOMMONCONTROLSEX();
                icc.dwICC = NativeMethods.ICC_TREEVIEW_CLASSES;
                SafeNativeMethods.InitCommonControlsEx(icc);
            }
            base.CreateHandle();
        }

        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.DetachImageList"]/*' />
        /// <devdoc>
        ///     Resets the imageList to null.  We wire this method up to the imageList's
        ///     Dispose event, so that we don't hang onto an imageList that's gone away.
        /// </devdoc>
        /// <internalonly/>
        private void DetachImageList(object sender, EventArgs e) {
            ImageList = null;
        }

        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.Dispose"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        protected override void Dispose(bool disposing) {
            if (disposing) {
                lock(this) {
                    if (imageList != null) {
                        imageList.Disposed -= new EventHandler(this.DetachImageList);                        
                        imageList = null;
                    }
                }
            }
            base.Dispose(disposing);
        }

        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.EndUpdate"]/*' />
        /// <devdoc>
        ///     Reenables redrawing of the tree view. A call to beginUpdate() must be
        ///     balanced by a following call to endUpdate(). Following a call to
        ///     beginUpdate(), any redrawing caused by operations performed on the
        ///     combo box is deferred until the call to endUpdate().
        /// </devdoc>
        public void EndUpdate() {
            EndUpdateInternal();
        }

        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.ExpandAll"]/*' />
        /// <devdoc>
        ///     Expands all nodes at the root level.
        /// </devdoc>
        public void ExpandAll() {
            root.ExpandAll();
        }

        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.ForceScrollbarUpdate"]/*' />
        /// <devdoc>
        ///     Forces the TreeView to recalculate all its nodes widths so that it updates the
        ///     scrollbars as appropriate.
        /// </devdoc>
        /// <internalonly/>
        internal void ForceScrollbarUpdate(bool delayed) {
            if (updateCount == 0 && IsHandleCreated) {
                SendMessage(NativeMethods.WM_SETREDRAW, 0, 0);
                if (delayed)
                    UnsafeNativeMethods.PostMessage(new HandleRef(this, Handle), NativeMethods.WM_SETREDRAW, (IntPtr)1, IntPtr.Zero);
                else
                    SendMessage(NativeMethods.WM_SETREDRAW, 1, 0);
            }
        }

        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.TreeViewBeforeAfterCheck"]/*' />
        /// <devdoc>
        ///     Defined so that a  tree node can use it
        ///     
        /// </devdoc>
        /// <internalonly/>
        
        internal bool TreeViewBeforeCheck(TreeNode node, TreeViewAction actionTaken) { 
            TreeViewCancelEventArgs tvce = new TreeViewCancelEventArgs(node, false, actionTaken);
            OnBeforeCheck(tvce);
            return (tvce.Cancel);
        }
        
        internal void TreeViewAfterCheck(TreeNode node, TreeViewAction actionTaken) {
            OnAfterCheck(new TreeViewEventArgs(node, actionTaken));
        }


        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.GetNodeCount"]/*' />
        /// <devdoc>
        ///     Returns count of nodes at root, optionally including all subtrees.
        /// </devdoc>
        public int GetNodeCount(bool includeSubTrees) {
            return root.GetNodeCount(includeSubTrees);
        }

        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.GetNodeAt"]/*' />
        /// <devdoc>
        ///     Returns the TreeNode at the given location in tree view coordinates.
        /// </devdoc>
        public TreeNode GetNodeAt(Point pt) {
            return GetNodeAt(pt.X, pt.Y);
        }

        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.GetNodeAt1"]/*' />
        /// <devdoc>
        ///     Returns the TreeNode at the given location in tree view coordinates.
        /// </devdoc>
        public TreeNode GetNodeAt(int x, int y) {
            NativeMethods.TV_HITTESTINFO tvhi = new NativeMethods.TV_HITTESTINFO();

            tvhi.pt_x = x;
            tvhi.pt_y = y;

            IntPtr hnode = UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.TVM_HITTEST, 0, tvhi);

            return(hnode == IntPtr.Zero ? null : NodeFromHandle(hnode));
        }

        private void ImageListRecreateHandle(object sender, EventArgs e) {
            if (IsHandleCreated) {
                IntPtr handle = (ImageList == null) ? IntPtr.Zero : ImageList.Handle;
                SendMessage(NativeMethods.TVM_SETIMAGELIST, 0, handle);
            }
        }

        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.IsInputKey"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Overridden to handle RETURN key.
        ///    </para>
        /// </devdoc>
        protected override bool IsInputKey(Keys keyData) {
            // If in edit mode, treat Return as an input key, so the form doesn't grab it
            // and treat it as clicking the Form.AcceptButton.  Similarly for Escape 
            // and Form.CancelButton.
            if (editNode != null && (keyData & Keys.Alt) == 0) {
                switch (keyData & Keys.KeyCode) {
                    case Keys.Return:
                    case Keys.Escape:
                    case Keys.PageUp:
                    case Keys.PageDown:
                    case Keys.Home:
                    case Keys.End:
                        return true;
                }
            }
            return base.IsInputKey(keyData);
        }

        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.NodeFromHandle"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        internal TreeNode NodeFromHandle(IntPtr handle) {
            TreeNode node = (TreeNode)nodeTable[handle];
            Debug.Assert(node != null, "node not found in node table");
            return node;
        }

        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.OnHandleCreated"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        protected override void OnHandleCreated(EventArgs e) {
            TreeNode savedSelectedNode = this.selectedNode;
            this.selectedNode = null;
            
            base.OnHandleCreated(e);

            // Workaround for problem in TreeView where it doesn't recognize the TVS_CHECKBOXES
            // style if it is set before the window is created.  To get around the problem,
            // we set it here after the window is created, and we make sure we don't set it
            // in getCreateParams so that this will actually change the value of the bit.
            // This seems to make the Treeview happy.
            if (checkBoxes) {
                int style = (int)UnsafeNativeMethods.GetWindowLong(new HandleRef(this, Handle), NativeMethods.GWL_STYLE);
                style |= NativeMethods.TVS_CHECKBOXES;
                UnsafeNativeMethods.SetWindowLong(new HandleRef(this, Handle), NativeMethods.GWL_STYLE, new HandleRef(null, (IntPtr)style));
            }

            updateCount = 0;
            Color c;
            c = BackColor;
            if (c != SystemColors.Window)
                SendMessage(NativeMethods.TVM_SETBKCOLOR, 0, ColorTranslator.ToWin32(c));
            c = ForeColor;
            if (c != SystemColors.WindowText)
                SendMessage(NativeMethods.TVM_SETTEXTCOLOR, 0, ColorTranslator.ToWin32(c));

            if (imageList != null)
                SendMessage(NativeMethods.TVM_SETIMAGELIST, 0, imageList.Handle);
                
            if (indent != -1) {
                SendMessage(NativeMethods.TVM_SETINDENT, indent, 0);
            }

            if (itemHeight != -1) {
                SendMessage(NativeMethods.TVM_SETITEMHEIGHT, itemHeight, 0);
            }

            root.Realize();
            
            SelectedNode = savedSelectedNode;
        }

        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.OnHandleDestroyed"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        protected override void OnHandleDestroyed(EventArgs e) {
            selectedNode = SelectedNode;
            base.OnHandleDestroyed(e);
        }
        
        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.OnBeforeLabelEdit"]/*' />
        /// <devdoc>
        ///     Fires the beforeLabelEdit event.
        /// </devdoc>
        protected virtual void OnBeforeLabelEdit(NodeLabelEditEventArgs e) {
            if (onBeforeLabelEdit != null) onBeforeLabelEdit(this, e);
        }

        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.OnAfterLabelEdit"]/*' />
        /// <devdoc>
        ///     Fires the afterLabelEdit event.
        /// </devdoc>
        protected virtual void OnAfterLabelEdit(NodeLabelEditEventArgs e) {
            if (onAfterLabelEdit != null) onAfterLabelEdit(this, e);
        }

        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.OnBeforeCheck"]/*' />
        /// <devdoc>
        ///     Fires the beforeCheck event.
        /// </devdoc>
        protected virtual void OnBeforeCheck(TreeViewCancelEventArgs e) {
            if (onBeforeCheck != null) onBeforeCheck(this, e);
        }

        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.OnAfterCheck"]/*' />
        /// <devdoc>
        ///     Fires the afterCheck event.
        /// </devdoc>
        protected virtual void OnAfterCheck(TreeViewEventArgs e) {
            if (onAfterCheck != null) onAfterCheck(this, e);
        }

        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.OnBeforeCollapse"]/*' />
        /// <devdoc>
        ///     Fires the beforeCollapse event.
        /// </devdoc>
        protected virtual void OnBeforeCollapse(TreeViewCancelEventArgs e) {
            if (onBeforeCollapse != null) onBeforeCollapse(this, e);
        }

        // C#r
        internal virtual void _OnBeforeCollapse(TreeViewCancelEventArgs e) {
            OnBeforeCollapse( e );
        }

        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.OnAfterCollapse"]/*' />
        /// <devdoc>
        ///     Fires the afterCollapse event.
        /// </devdoc>
        protected virtual void OnAfterCollapse(TreeViewEventArgs e) {
            if (onAfterCollapse != null) onAfterCollapse(this, e);
        }

        // C#r
        internal virtual void _OnAfterCollapse( TreeViewEventArgs e ) {
            OnAfterCollapse( e );
        }

        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.OnBeforeExpand"]/*' />
        /// <devdoc>
        ///     Fires the beforeExpand event.
        /// </devdoc>
        protected virtual void OnBeforeExpand(TreeViewCancelEventArgs e) {
            if (onBeforeExpand != null) onBeforeExpand(this, e);
        }

        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.OnAfterExpand"]/*' />
        /// <devdoc>
        ///     Fires the afterExpand event.
        /// </devdoc>
        protected virtual void OnAfterExpand(TreeViewEventArgs e) {
            if (onAfterExpand != null) onAfterExpand(this, e);
        }

        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.OnItemDrag"]/*' />
        /// <devdoc>
        ///     Fires the ItemDrag event.
        /// </devdoc>
        protected virtual void OnItemDrag(ItemDragEventArgs e) {
            if (onItemDrag != null) onItemDrag(this, e);
        }

        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.OnBeforeSelect"]/*' />
        /// <devdoc>
        ///     Fires the beforeSelect event.
        /// </devdoc>
        protected virtual void OnBeforeSelect(TreeViewCancelEventArgs e) {
            if (onBeforeSelect != null) onBeforeSelect(this, e);
        }

        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.OnAfterSelect"]/*' />
        /// <devdoc>
        ///     Fires the afterSelect event.
        /// </devdoc>
        protected virtual void OnAfterSelect(TreeViewEventArgs e) {
            if (onAfterSelect != null) onAfterSelect(this, e);
        }

        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.OnKeyDown"]/*' />
        /// <devdoc>
        ///     Handles the OnBeforeCheck / OnAfterCheck for keyboard clicks
        /// </devdoc>
        /// <internalonly/>
        protected override void OnKeyDown(KeyEventArgs e) {
            base.OnKeyDown(e);
            if (e.Handled) return;
            // if it's a space, send the check notifications and toggle the checkbox if we're not
            // cancelled.
            if (CheckBoxes && (e.KeyData & Keys.KeyCode) == Keys.Space) {
                TreeNode node = this.SelectedNode;
                if (node != null) {
                    bool eventReturn = TreeViewBeforeCheck(node, TreeViewAction.ByKeyboard);
                    if (!eventReturn) {
                        node.CheckedInternal = !node.CheckedInternal;
                        TreeViewAfterCheck(node, TreeViewAction.ByKeyboard);
                    }
                    e.Handled = true;
                    return;
                }
            }
        }

        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.OnKeyUp"]/*' />
        /// <devdoc>
        ///     Handles the OnBeforeCheck / OnAfterCheck for keyboard clicks
        /// </devdoc>
        /// <internalonly/>
        protected override void OnKeyUp(KeyEventArgs e) {
            base.OnKeyUp(e);
            if (e.Handled) return;
            // eat the space key
            if ((e.KeyData & Keys.KeyCode) == Keys.Space) {
                e.Handled = true;
                return;
            }
        }

        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.OnKeyPress"]/*' />
        /// <devdoc>
        ///     Handles the OnBeforeCheck / OnAfterCheck for keyboard clicks
        /// </devdoc>
        /// <internalonly/>
        protected override void OnKeyPress(KeyPressEventArgs e) {
            base.OnKeyPress(e);
            if (e.Handled) return;
            // eat the space key
            if (e.KeyChar == ' ') e.Handled = true;
        }
        
        // Refresh the nodes by clearing the tree and adding the nodes back again
        //
        private void RefreshNodes() {
            TreeNode[] nodes = new TreeNode[Nodes.Count];
            Nodes.CopyTo(nodes, 0);
            
            Nodes.Clear();
            Nodes.AddRange(nodes);
        }

        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.ResetIndent"]/*' />
        /// <devdoc>
        ///     This resets the indentation to the system default.
        /// </devdoc>
        private void ResetIndent() {
            indent = -1;
            // is this overkill?
            RecreateHandle();
        }

        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.ResetItemHeight"]/*' />
        /// <devdoc>
        ///     This resets the item height to the system default.
        /// </devdoc>
        private void ResetItemHeight() {
            itemHeight = -1;
            RecreateHandle();
        }
        
        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.ShouldSerializeIndent"]/*' />
        /// <devdoc>
        ///     Retrieves true if the indent should be persisted in code gen.
        /// </devdoc>
        private bool ShouldSerializeIndent() {
            return(indent != -1);
        }

        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.ShouldSerializeItemHeight"]/*' />
        /// <devdoc>
        ///     Retrieves true if the itemHeight should be persisted in code gen.
        /// </devdoc>
        private bool ShouldSerializeItemHeight() {
            return(itemHeight != -1);
        }

        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.ToString"]/*' />
        /// <devdoc>
        ///     Returns a string representation for this control.
        /// </devdoc>
        /// <internalonly/>
        public override string ToString() {

            string s = base.ToString();
            if (Nodes != null) {
                s += ", Nodes.Count: " + Nodes.Count.ToString();
                if (Nodes.Count > 0)
                    s += ", Nodes[0]: " + Nodes[0].ToString();
            }
            return s;
        }
        
        private unsafe void TvnBeginDrag(MouseButtons buttons, NativeMethods.NMTREEVIEW* nmtv) {
            NativeMethods.TV_ITEM item = nmtv->itemNew;
            
            // Check for invalid node handle
            if (item.hItem == IntPtr.Zero) {
                return;
            }

            TreeNode node = NodeFromHandle(item.hItem);

            OnItemDrag(new ItemDragEventArgs(buttons, node));
        }

        private unsafe IntPtr TvnExpanding(NativeMethods.NMTREEVIEW* nmtv) {
            NativeMethods.TV_ITEM item = nmtv->itemNew;

            // Check for invalid node handle
            if (item.hItem == IntPtr.Zero) {
                return IntPtr.Zero;
            }

            TreeViewCancelEventArgs e = null;
            if ((item.state & NativeMethods.TVIS_EXPANDED) == 0) {
                e = new TreeViewCancelEventArgs(NodeFromHandle(item.hItem), false, TreeViewAction.Expand);
                OnBeforeExpand(e);
            }
            else {
                e = new TreeViewCancelEventArgs(NodeFromHandle(item.hItem), false, TreeViewAction.Collapse);
                OnBeforeCollapse(e);
            }
            return (IntPtr)(e.Cancel? 1: 0);
        }

        private unsafe void TvnExpanded(NativeMethods.NMTREEVIEW* nmtv) {
            NativeMethods.TV_ITEM item = nmtv->itemNew;

            // Check for invalid node handle
            if (item.hItem == IntPtr.Zero) {
                return;
            }

            TreeViewEventArgs e; 
            if ((item.state & NativeMethods.TVIS_EXPANDED) == 0) {
                e = new TreeViewEventArgs(NodeFromHandle(item.hItem), TreeViewAction.Collapse);
                OnAfterCollapse(e);
            }
            else {
                e = new TreeViewEventArgs(NodeFromHandle(item.hItem), TreeViewAction.Expand);
                OnAfterExpand(e);
            }
        }

        private unsafe IntPtr TvnSelecting(NativeMethods.NMTREEVIEW* nmtv) {
            // Check for invalid node handle
            if (nmtv->itemNew.hItem == IntPtr.Zero) {
                return IntPtr.Zero;
            }
            
            TreeNode node = NodeFromHandle(nmtv->itemNew.hItem);
            
            TreeViewAction action = TreeViewAction.Unknown;
            switch(nmtv->action) {
                case NativeMethods.TVC_BYKEYBOARD:
                    action = TreeViewAction.ByKeyboard;
                    break;
                case NativeMethods.TVC_BYMOUSE:
                    action = TreeViewAction.ByMouse;
                    break;
            }
            
            TreeViewCancelEventArgs e = new TreeViewCancelEventArgs(node, false, action);
            OnBeforeSelect(e);
            
            return (IntPtr)(e.Cancel? 1: 0);
        }

        private unsafe void TvnSelected(NativeMethods.NMTREEVIEW* nmtv) {
            if (nmtv->itemNew.hItem != IntPtr.Zero) {
                TreeViewAction action = TreeViewAction.Unknown;
                switch(nmtv->action) {
                    case NativeMethods.TVC_BYKEYBOARD:
                        action = TreeViewAction.ByKeyboard;
                        break;
                    case NativeMethods.TVC_BYMOUSE:
                        action = TreeViewAction.ByMouse;
                        break;
                }
                OnAfterSelect(new TreeViewEventArgs(NodeFromHandle(nmtv->itemNew.hItem), action));
            }

            // TreeView doesn't properly revert back to the unselected image
            // if the unselected image is blank.
            //
            NativeMethods.RECT rc = new NativeMethods.RECT();
            rc.left = (int)nmtv->itemOld.hItem;
            if (rc.left != 0) {
                if ((int)UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.TVM_GETITEMRECT, 1, ref rc) != 0)
                    SafeNativeMethods.InvalidateRect(new HandleRef(this, Handle), ref rc, true);
            }
        }

        private IntPtr TvnBeginLabelEdit(NativeMethods.NMTVDISPINFO nmtvdi) {

            // Check for invalid node handle
            if (nmtvdi.item.hItem == IntPtr.Zero) {
                return IntPtr.Zero;
            }

            TreeNode editingNode = NodeFromHandle(nmtvdi.item.hItem);
            NodeLabelEditEventArgs e = new NodeLabelEditEventArgs(editingNode);
            OnBeforeLabelEdit(e);
            if (!e.CancelEdit)
                editNode = editingNode;
            return (IntPtr)(e.CancelEdit ? 1 : 0);
        }

        private IntPtr TvnEndLabelEdit(NativeMethods.NMTVDISPINFO nmtvdi) {
            editNode = null;

            // Check for invalid node handle
            if (nmtvdi.item.hItem == IntPtr.Zero) {
                return (IntPtr)1;
            }

            TreeNode node = NodeFromHandle(nmtvdi.item.hItem);
            string newText = (nmtvdi.item.pszText == IntPtr.Zero ? null : Marshal.PtrToStringAuto(nmtvdi.item.pszText));
            NodeLabelEditEventArgs e = new NodeLabelEditEventArgs(node, newText);
            OnAfterLabelEdit(e);
            if (newText != null && !e.CancelEdit) {
                node.text = newText;
                if (scrollable)
                    ForceScrollbarUpdate(true);
            }
            return (IntPtr)(e.CancelEdit ? 0 : 1);
        }

        private void WmMouseDown(ref Message m, MouseButtons button, int clicks) {
            // Windows TreeView pushes its own message loop in WM_xBUTTONDOWN, so fire the
            // event before calling defWndProc or else it won't get fired until the button
            // comes back up.
            OnMouseDown(new MouseEventArgs(button, clicks, (int)(short)m.LParam, (int)m.LParam >> 16, 0));
            DefWndProc(ref m);
        }

        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.CustomDraw"]/*' />
        /// <devdoc>
        ///     Performs custom draw handling
        /// </devdoc>
        /// <internalonly/>
        private void CustomDraw(ref Message m) {
            NativeMethods.NMTVCUSTOMDRAW nmcd = (NativeMethods.NMTVCUSTOMDRAW)m.GetLParam(typeof(NativeMethods.NMTVCUSTOMDRAW));

            // Find out which stage we're drawing
            switch (nmcd.nmcd.dwDrawStage) {
                // Do we want OwnerDraw for this paint cycle?
                case NativeMethods.CDDS_PREPAINT:
                    m.Result = (IntPtr)NativeMethods.CDRF_NOTIFYITEMDRAW; // yes, we do...
                    return;
                    // We've got opt-in on owner draw for items - so handle each one.
                case NativeMethods.CDDS_ITEMPREPAINT:
                    // get the node
                    Debug.Assert(nmcd.nmcd.dwItemSpec != 0, "Invalid node handle in ITEMPREPAINT");
                    TreeNode node = NodeFromHandle((IntPtr)nmcd.nmcd.dwItemSpec);
                    // shouldn't be null - but just in case...
                    Debug.Assert(node!=null,"Node was null in ITEMPREPAINT");

                    int state = nmcd.nmcd.uItemState;
                    // Diagnostic output
                    //Console.Out.WriteLine("Itemstate: "+state);
                    /*Console.Out.WriteLine("Itemstate: "+
                                          "DISABLED" + (((state & NativeMethods.CDIS_DISABLED) != 0) ? "TRUE" : "FALSE") +
                                          "HOT" + (((state & NativeMethods.CDIS_HOT) != 0) ? "TRUE" : "FALSE") +
                                          "GRAYED" + (((state & NativeMethods.CDIS_GRAYED) != 0) ? "TRUE" : "FALSE") +
                                          "SELECTED" + (((state & NativeMethods.CDIS_SELECTED) != 0) ? "TRUE" : "FALSE") +
                                          "FOCUS" + (((state & NativeMethods.CDIS_FOCUS) != 0) ? "TRUE" : "FALSE") +
                                          "DEFAULT" + (((state & NativeMethods.CDIS_DEFAULT) != 0) ? "TRUE" : "FALSE") +
                                          "MARKED" + (((state & NativeMethods.CDIS_MARKED) != 0) ? "TRUE" : "FALSE") +
                                          "INDETERMINATE" + (((state & NativeMethods.CDIS_INDETERMINATE) != 0) ? "TRUE" : "FALSE"));*/
                    OwnerDrawPropertyBag renderinfo = GetItemRenderStyles(node,state);

                    // TreeView has problems with drawing items at times; it gets confused
                    // as to which colors apply to which items (see focus rectangle shifting;
                    // when one item is selected, click and hold on another). This needs to be fixed.

                    bool colordelta = false;
                    Color riFore = renderinfo.ForeColor;
                    Color riBack = renderinfo.BackColor;
                    if (renderinfo != null && !riFore.IsEmpty) {
                        nmcd.clrText = ColorTranslator.ToWin32(riFore);
                        colordelta = true;
                    }
                    if (renderinfo != null && !riBack.IsEmpty) {
                        nmcd.clrTextBk = ColorTranslator.ToWin32(riBack);
                        colordelta = true;
                    }
                    if (colordelta) {
                        Marshal.StructureToPtr(nmcd, m.LParam, true);
                    }
                    if (renderinfo != null && renderinfo.Font != null) {
                        // Mess with the DC directly...
                        SafeNativeMethods.SelectObject(new HandleRef(nmcd.nmcd, nmcd.nmcd.hdc), new HandleRef(renderinfo, renderinfo.FontHandle));
                        // There is a problem in winctl that clips node fonts if the fontsize
                        // is larger than the treeview font size. But we're not going
                        // to fix it.
                        m.Result = (IntPtr)NativeMethods.CDRF_NEWFONT;
                        return;
                    }

                    // fall through and do the default drawing work
                    goto default;
                default:
                    // just in case we get a spurious message, tell it to do the right thing
                    m.Result = (IntPtr)NativeMethods.CDRF_DODEFAULT;
                    return;
            }
        }

        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.GetItemRenderStyles"]/*' />
        /// <devdoc>
        ///     Generates colors for each item. This can be overridden to provide colors on a per state/per node
        ///     basis, rather than using the ForeColor/BackColor/NodeFont properties on TreeNode.
        ///
        /// </devdoc>
        /// <internalonly/>
        protected OwnerDrawPropertyBag GetItemRenderStyles(TreeNode node, int state) {
            OwnerDrawPropertyBag retval = new OwnerDrawPropertyBag();
            if (node == null || node.propBag == null) return retval;

            // we only change colors if we're displaying things normally
            if ((state & (NativeMethods.CDIS_SELECTED | NativeMethods.CDIS_GRAYED | NativeMethods.CDIS_HOT | NativeMethods.CDIS_DISABLED))==0) {
                retval.ForeColor = node.propBag.ForeColor;
                retval.BackColor = node.propBag.BackColor;
            }
            retval.Font = node.propBag.Font;
            return retval;
        }

        private unsafe void WmNotify(ref Message m) {
            NativeMethods.NMHDR* nmhdr = (NativeMethods.NMHDR *)m.LParam;
            
            // Custom draw code is handled separately.
            //
            if (nmhdr->code ==  NativeMethods.NM_CUSTOMDRAW) {
                CustomDraw(ref m);
            }
            else {
                NativeMethods.NMTREEVIEW* nmtv = (NativeMethods.NMTREEVIEW*)m.LParam;
    
                switch (nmtv->nmhdr.code) {
                    case NativeMethods.TVN_ITEMEXPANDINGA:
                    case NativeMethods.TVN_ITEMEXPANDINGW:
                        m.Result = TvnExpanding(nmtv);
                        break;
                    case NativeMethods.TVN_ITEMEXPANDEDA:
                    case NativeMethods.TVN_ITEMEXPANDEDW:
                        TvnExpanded(nmtv);
                        break;
                    case NativeMethods.TVN_SELCHANGINGA:
                    case NativeMethods.TVN_SELCHANGINGW:
                        m.Result = TvnSelecting(nmtv);
                        break;
                    case NativeMethods.TVN_SELCHANGEDA:
                    case NativeMethods.TVN_SELCHANGEDW:
                        TvnSelected(nmtv);
                        break;
                    case NativeMethods.TVN_BEGINDRAGA:
                    case NativeMethods.TVN_BEGINDRAGW:
                        TvnBeginDrag(MouseButtons.Left, nmtv);
                        break;
                    case NativeMethods.TVN_BEGINRDRAGA:
                    case NativeMethods.TVN_BEGINRDRAGW:
                        TvnBeginDrag(MouseButtons.Right, nmtv);
                        break;
                    case NativeMethods.TVN_BEGINLABELEDITA:
                    case NativeMethods.TVN_BEGINLABELEDITW:
                        m.Result = TvnBeginLabelEdit((NativeMethods.NMTVDISPINFO)m.GetLParam(typeof(NativeMethods.NMTVDISPINFO)));
                        break;
                    case NativeMethods.TVN_ENDLABELEDITA:
                    case NativeMethods.TVN_ENDLABELEDITW:
                        m.Result = TvnEndLabelEdit((NativeMethods.NMTVDISPINFO)m.GetLParam(typeof(NativeMethods.NMTVDISPINFO)));
                        break;
                    case NativeMethods.NM_CLICK:
                    case NativeMethods.NM_RCLICK:
                        
                        NativeMethods.TV_HITTESTINFO tvhip = new NativeMethods.TV_HITTESTINFO();
                        Point pos = Cursor.Position;
                        pos = PointToClientInternal(pos);
                        tvhip.pt_x = pos.X;
                        tvhip.pt_y = pos.Y;
                        IntPtr hnode = UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.TVM_HITTEST, 0, tvhip);
                        // The treeview's WndProc doesn't get the WM_LBUTTONUP messages when
                        // LBUTTONUP happens on TVHT_ONITEM. This is a comctl quirk.
                        // We work around that by calling OnMouseUp here.
                        if (nmtv->nmhdr.code != NativeMethods.NM_CLICK
                            || (tvhip.flags & NativeMethods.TVHT_ONITEM) != 0) {
                            if (hnode != IntPtr.Zero && !ValidationCancelled) {
                                OnClick(EventArgs.Empty);
                            }
                        }
                        if (nmtv->nmhdr.code == NativeMethods.NM_RCLICK) {
                            SendMessage(NativeMethods.WM_CONTEXTMENU, Handle, SafeNativeMethods.GetMessagePos());
                            m.Result = (IntPtr)1;
                        }

                        if (!mouseUpFired) {
                            // The treeview's WndProc doesn't get the WM_LBUTTONUP messages when
                            // LBUTTONUP happens on TVHT_ONITEM. This is a comctl quirk.
                            // We work around that by calling OnMouseUp here.
                            if (nmtv->nmhdr.code != NativeMethods.NM_CLICK
                                    || (tvhip.flags & NativeMethods.TVHT_ONITEM) != 0) {
                                MouseButtons button = nmtv->nmhdr.code == NativeMethods.NM_CLICK
                                    ? MouseButtons.Left : MouseButtons.Right;
                                OnMouseUp(new MouseEventArgs(button, 1, pos.X, pos.Y, 0));
                                mouseUpFired = true;
                            }
                        }
                        break;
                }
            }
        }

        /// <include file='doc\TreeView.uex' path='docs/doc[@for="TreeView.WndProc"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        protected override void WndProc(ref Message m) {
            switch (m.Msg) {
                case NativeMethods.WM_REFLECT + NativeMethods.WM_NOTIFY:
                    WmNotify(ref m);
                    break;
                case NativeMethods.WM_LBUTTONDBLCLK:
                    WmMouseDown(ref m, MouseButtons.Left, 2);
                    //just maintain state and fire double click.. in final mouseUp...
                    doubleclickFired = true;
                    //fire Up in the Wndproc !!
                    mouseUpFired = false;
                    //problem getting the UP... outside the control...
                    //
                    CaptureInternal = true;
                    break;
                case NativeMethods.WM_LBUTTONDOWN:
                    //Always Reset the MouseupFired....
                    mouseUpFired = false;
                    NativeMethods.TV_HITTESTINFO tvhip = new NativeMethods.TV_HITTESTINFO();
                    tvhip.pt_x = (int)(short)m.LParam;
                    tvhip.pt_y = ((int)m.LParam >> 16);
                    IntPtr handlenode = UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.TVM_HITTEST, 0, tvhip);
                    // This gets around the TreeView behavior of temporarily moving the selection
                    // highlight to a node when the user clicks on its checkbox.
                    if ((tvhip.flags & NativeMethods.TVHT_ONITEMSTATEICON) != 0) {
                        //We donot pass the Message to the Control .. so fire MouseDowm ...
                        OnMouseDown(new MouseEventArgs(MouseButtons.Left, 1, (int)(short)m.LParam, (int)m.LParam >> 16, 0));
                        if (CheckBoxes) 
                        {
                            TreeNode node = NodeFromHandle(handlenode);
                            bool eventReturn = TreeViewBeforeCheck(node, TreeViewAction.ByMouse);
                            if (!eventReturn) {
                                node.CheckedInternal = !node.CheckedInternal;
                                TreeViewAfterCheck(node, TreeViewAction.ByMouse);
                            }
                        }
                        m.Result = IntPtr.Zero;
                    }
                    else {
                        WmMouseDown(ref m, MouseButtons.Left, 1);
                        downButton = MouseButtons.Left;
                    }
                    break;
                case NativeMethods.WM_LBUTTONUP:
                case NativeMethods.WM_RBUTTONUP:
                    NativeMethods.TV_HITTESTINFO tvhi = new NativeMethods.TV_HITTESTINFO();
                    tvhi.pt_x = (int)(short)m.LParam;
                    tvhi.pt_y = ((int)m.LParam >> 16);
                    IntPtr hnode = UnsafeNativeMethods.SendMessage(new HandleRef(this, Handle), NativeMethods.TVM_HITTEST, 0, tvhi);
                    //Important for checkBoxes ... click needs to be fired ...
                    //
                    if(hnode != IntPtr.Zero) {
                        if (!ValidationCancelled && !doubleclickFired & !mouseUpFired) {
                            OnClick(EventArgs.Empty);
                        }
                    
                        if (doubleclickFired) {
                            doubleclickFired = false;
                            if (!ValidationCancelled) {
                                OnDoubleClick(EventArgs.Empty);
                            }
                        }
                    }
                    
                    if (!mouseUpFired)
                        OnMouseUp(new MouseEventArgs(downButton, 1, (int)(short)m.LParam, (int)m.LParam >> 16, 0));
                    doubleclickFired = false;
                    mouseUpFired = false;
                    CaptureInternal = false;
                    break;
                case NativeMethods.WM_MBUTTONDBLCLK:
                    //fire Up in the Wndproc !!
                    mouseUpFired = false;
                    WmMouseDown(ref m, MouseButtons.Middle, 2);
                    break;
                case NativeMethods.WM_MBUTTONDOWN:
                    //Always Reset the MouseupFired....
                    mouseUpFired = false;
                    WmMouseDown(ref m, MouseButtons.Middle, 1);
                    downButton = MouseButtons.Middle;
                    break;
                case NativeMethods.WM_RBUTTONDBLCLK:
                    WmMouseDown(ref m, MouseButtons.Right, 2);
                    //just maintain state and fire double click.. in final mouseUp...
                    doubleclickFired = true;
                    //fire Up in the Wndproc !!
                    mouseUpFired = false;
                    //problem getting the UP... outside the control...
                    //
                    CaptureInternal = true;
                    break;
                case NativeMethods.WM_RBUTTONDOWN:
                    //Always Reset the MouseupFired....
                    mouseUpFired = false;
                    WmMouseDown(ref m, MouseButtons.Right, 1);
                    downButton = MouseButtons.Right;
                    break;
                    //# VS7 15052
                case NativeMethods.WM_SYSCOLORCHANGE:
                    SendMessage(NativeMethods.TVM_SETINDENT, Indent, 0);
                    base.WndProc(ref m);
                    break;
                default:
                    base.WndProc(ref m);
                    break;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\updownbase.cs ===
//------------------------------------------------------------------------------
// <copyright file="UpDownBase.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {
    using System.Runtime.Serialization.Formatters;
    using System.Threading;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;    
    using System.Security.Permissions;
    using System.Windows.Forms;
    using System.Drawing;
    using Microsoft.Win32;

    /// <include file='doc\UpDownBase.uex' path='docs/doc[@for="UpDownBase"]/*' />
    /// <devdoc>
    ///    <para>Implements the basic
    ///       functionality required by an up-down control.</para>
    /// </devdoc>
    [
    Designer("System.Windows.Forms.Design.UpDownBaseDesigner, " + AssemblyRef.SystemDesign)
    ]
    public abstract class UpDownBase : ContainerControl {

        private const int                       DefaultButtonsWidth = 16;
        private const int                       DefaultControlWidth = 120;
        private const BorderStyle               DefaultBorderStyle = BorderStyle.Fixed3D;
        private static readonly bool            DefaultInterceptArrowKeys = true;
        private const LeftRightAlignment        DefaultUpDownAlign = LeftRightAlignment.Right;
        private const int                       TimerInterval = 500;

        ////////////////////////////////////////////////////////////////////////
        // Member variables
        //
        ////////////////////////////////////////////////////////////////////////

        // Child controls
        private UpDownEdit upDownEdit; // See nested class at end of this file
        private UpDownButtons upDownButtons; // See nested class at end of this file

        // Intercept arrow keys?
        private bool interceptArrowKeys = DefaultInterceptArrowKeys;

        // If true, the updown buttons will be drawn on the left-hand side of the control.
        private LeftRightAlignment upDownAlign = DefaultUpDownAlign;

        // userEdit is true when the text of the control has been changed,
        // and the internal value of the control has not yet been updated.
        // We do not always want to keep the internal value up-to-date,
        // hence this variable.
        private bool userEdit = false;

        /// <include file='doc\UpDownBase.uex' path='docs/doc[@for="UpDownBase.borderStyle"]/*' />
        /// <devdoc>
        ///     The current border for this edit control.
        /// </devdoc>
        private BorderStyle borderStyle = DefaultBorderStyle;

        // Mouse wheel movement
        private int wheelDelta = 0;

        // Indicates if the edit text is being changed
        private bool changingText = false;

        /// <include file='doc\UpDownBase.uex' path='docs/doc[@for="UpDownBase.UpDownBase"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Windows.Forms.UpDownBase'/>
        ///       class.
        ///    </para>
        /// </devdoc>
        public UpDownBase() {

            upDownButtons = new UpDownButtons(this);
            upDownEdit = new UpDownEdit(this);
            upDownEdit.BorderStyle = BorderStyle.None;
            upDownEdit.AutoSize = false;
            upDownEdit.KeyDown += new KeyEventHandler(this.OnTextBoxKeyDown);
            upDownEdit.KeyPress += new KeyPressEventHandler(this.OnTextBoxKeyPress);
            upDownEdit.TextChanged += new EventHandler(this.OnTextBoxTextChanged);
            upDownEdit.LostFocus += new EventHandler(this.OnTextBoxLostFocus);
            upDownEdit.Resize += new EventHandler(this.OnTextBoxResize);
            upDownButtons.TabStop = false;
            upDownButtons.Size = new Size(DefaultButtonsWidth, PreferredHeight);
            upDownButtons.UpDown += new UpDownEventHandler(this.OnUpDown);

            Controls.AddRange(new Control[] { upDownButtons, upDownEdit} );
            
            SetStyle(ControlStyles.FixedHeight, true);
            
            SystemEvents.UserPreferenceChanged += new UserPreferenceChangedEventHandler(this.UserPreferenceChanged);
        }

        ////////////////////////////////////////////////////////////////////////
        // Properties
        //
        ////////////////////////////////////////////////////////////////////////

        // AutoScroll is not relevant to an UpDownBase
        /// <include file='doc\UpDownBase.uex' path='docs/doc[@for="UpDownBase.AutoScroll"]/*' />
        /// <hideinheritance/>
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public override bool AutoScroll {
            get {
                return false;
            }
            set {
                // Don't allow AutoScroll to be set to anything
            }
        }

        // AutoScrollMargin is not relevant to an UpDownBase
        /// <include file='doc\UpDownBase.uex' path='docs/doc[@for="UpDownBase.AutoScrollMargin"]/*' />
        /// <internalonly/>
        /// <hideinheritance/>
        /// <devdoc>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        new public Size AutoScrollMargin {
            get {
                return base.AutoScrollMargin;
            }
            set {
                base.AutoScrollMargin = value;
            }
        }

        // AutoScrollMinSize is not relevant to an UpDownBase
        /// <include file='doc\UpDownBase.uex' path='docs/doc[@for="UpDownBase.AutoScrollMinSize"]/*' />
        /// <internalonly/>
        /// <hideinheritance/>
        /// <devdoc>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        new public Size AutoScrollMinSize {
            get {
                return base.AutoScrollMinSize;
            }
            set {
                base.AutoScrollMinSize = value;
            }
        }

        /// <include file='doc\UpDownBase.uex' path='docs/doc[@for="UpDownBase.BackColor"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the background color for the
        ///       text box portion of the up-down control.
        ///    </para>
        /// </devdoc>
        public override Color BackColor {
            get {
                return upDownEdit.BackColor;
            }
            set {
                base.BackColor = value;
                upDownEdit.BackColor = value;
            }
        }

        /// <include file='doc\UpDownBase.uex' path='docs/doc[@for="UpDownBase.BackgroundImage"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public override Image BackgroundImage {
            get {
                return base.BackgroundImage;
            }
            set {
                base.BackgroundImage = value;
            }
        }

        /// <include file='doc\UpDownBase.uex' path='docs/doc[@for="UpDownBase.BackgroundImageChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler BackgroundImageChanged {
            add {
                base.BackgroundImageChanged += value;
            }
            remove {
                base.BackgroundImageChanged -= value;
            }
        }

        /// <include file='doc\UpDownBase.uex' path='docs/doc[@for="UpDownBase.BorderStyle"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the border style for
        ///       the up-down control.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatAppearance),
        DefaultValue(BorderStyle.Fixed3D),
        DispId(NativeMethods.ActiveX.DISPID_BORDERSTYLE),
        SRDescription(SR.UpDownBaseBorderStyleDescr)
        ]
        public BorderStyle BorderStyle {
            get {
                return borderStyle;
            }

            set {
                if (!Enum.IsDefined(typeof(BorderStyle), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(BorderStyle));
                }

                if (borderStyle != value) {
                    borderStyle = value;
                    RecreateHandle();
                }
            }
        }

        /// <include file='doc\UpDownBase.uex' path='docs/doc[@for="UpDownBase.ChangingText"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the text
        ///       property is being changed internally by its parent class.
        ///    </para>
        /// </devdoc>
        protected bool ChangingText {
            get {
                return changingText;
            }

            set {
                changingText = value;
            }
        }

        /// <include file='doc\UpDownBase.uex' path='docs/doc[@for="UpDownBase.ContextMenu"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        public override ContextMenu ContextMenu {
            get {
                return base.ContextMenu;
            }
            set {
                base.ContextMenu = value;
                this.upDownEdit.ContextMenu = value;
            }
        }


        /// <include file='doc\UpDownBase.uex' path='docs/doc[@for="UpDownBase.CreateParams"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Returns the parameters needed to create the handle. Inheriting classes
        ///       can override this to provide extra functionality. They should not,
        ///       however, forget to call base.getCreateParams() first to get the struct
        ///       filled up with the basic info.
        ///    </para>
        /// </devdoc>
        protected override CreateParams CreateParams {
            [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
            get {
                CreateParams cp = base.CreateParams;

                cp.Style &= (~NativeMethods.WS_BORDER);
                switch (borderStyle) {
                    case BorderStyle.Fixed3D:
                        cp.ExStyle |= NativeMethods.WS_EX_CLIENTEDGE;
                        break;
                    case BorderStyle.FixedSingle:
                        cp.Style |= NativeMethods.WS_BORDER;
                        break;
                }
                return cp;
            }
        }

        /// <include file='doc\UpDownBase.uex' path='docs/doc[@for="UpDownBase.DefaultSize"]/*' />
        /// <devdoc>
        ///     Deriving classes can override this to configure a default size for their control.
        ///     This is more efficient than setting the size in the control's constructor.
        /// </devdoc>
        protected override Size DefaultSize {
            get {
                return new Size(DefaultControlWidth, PreferredHeight);
            }
        }

        // DockPadding is not relevant to UpDownBase
        /// <include file='doc\UpDownBase.uex' path='docs/doc[@for="UpDownBase.DockPadding"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        new public DockPaddingEdges DockPadding {
            get {
                return base.DockPadding;
            }
        }
        
        /// <include file='doc\UpDownBase.uex' path='docs/doc[@for="UpDownBase.Focused"]/*' />
        /// <devdoc>
        ///     Returns true if this control has focus.
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.ControlFocusedDescr)
        ]
        public override bool Focused {
            get {
                return upDownEdit.Focused;
            }
        }

        /// <include file='doc\UpDownBase.uex' path='docs/doc[@for="UpDownBase.ForeColor"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Indicates the foreground color for the control.
        ///    </para>
        /// </devdoc>
        public override Color ForeColor {
            get {
                return upDownEdit.ForeColor;
            }
            set {
                base.ForeColor = value;
                upDownEdit.ForeColor = value;
            }
        }

        /// <include file='doc\UpDownBase.uex' path='docs/doc[@for="UpDownBase.InterceptArrowKeys"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether
        ///       the user can use the UP
        ///       ARROW and DOWN ARROW keys to select values.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(true),
        SRDescription(SR.UpDownBaseInterceptArrowKeysDescr)
        ]
        public bool InterceptArrowKeys {

            get {
                return interceptArrowKeys;
            }

            set {
                interceptArrowKeys = value;
            }
        }
        
        /// <include file='doc\UpDownBase.uex' path='docs/doc[@for="UpDownBase.MouseEnter"]/*' />
        /// <internalonly/><hideinheritance/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event EventHandler MouseEnter {
            add {
                base.MouseEnter += value;
            }
            remove {
                base.MouseEnter -= value;
            }
        }

        /// <include file='doc\UpDownBase.uex' path='docs/doc[@for="UpDownBase.MouseLeave"]/*' />
        /// <internalonly/><hideinheritance/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event EventHandler MouseLeave {
            add {
                base.MouseLeave += value;
            }
            remove {
                base.MouseLeave -= value;
            }
        }

        /// <include file='doc\UpDownBase.uex' path='docs/doc[@for="UpDownBase.MouseHover"]/*' />
        /// <internalonly/><hideinheritance/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event EventHandler MouseHover {
            add {
                base.MouseHover += value;
            }
            remove {
                base.MouseHover -= value;
            }
        }

        /// <include file='doc\UpDownBase.uex' path='docs/doc[@for="UpDownBase.MouseMove"]/*' />
        /// <internalonly/><hideinheritance/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event MouseEventHandler MouseMove {
            add {
                base.MouseMove += value;
            }
            remove {
                base.MouseMove -= value;
            }
        }

        /// <include file='doc\UpDownBase.uex' path='docs/doc[@for="UpDownBase.PreferredHeight"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the height of
        ///       the up-down control.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatLayout),
        Browsable(false), EditorBrowsable(EditorBrowsableState.Advanced),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.UpDownBasePreferredHeightDescr)
        ]
        public int PreferredHeight {
            get {

                int height = FontHeight;

                // Adjust for the border style
                if (borderStyle != BorderStyle.None) {
                    height += SystemInformation.BorderSize.Height * 4 + 3;
                }

                return height;
            }
        }

        /// <include file='doc\UpDownBase.uex' path='docs/doc[@for="UpDownBase.ReadOnly"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets
        ///       a
        ///       value
        ///       indicating whether the text may only be changed by the
        ///       use
        ///       of the up or down buttons.
        ///    </para>
        /// </devdoc>
        [
        SRCategory(SR.CatBehavior),
        DefaultValue(false),
        SRDescription(SR.UpDownBaseReadOnlyDescr)
        ]
        public bool ReadOnly {

            get {
                return upDownEdit.ReadOnly;
            }

            set {
                upDownEdit.ReadOnly = value;
            }
        }

        /// <include file='doc\UpDownBase.uex' path='docs/doc[@for="UpDownBase.Text"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the text
        ///       displayed in the up-down control.
        ///    </para>
        /// </devdoc>
        [
        Localizable(true)
        ]
        public override string Text {
            get {
                return upDownEdit.Text;
            }

            set {
                upDownEdit.Text = value;
                // The text changed event will at this point be triggered.
                // After returning, the value of UserEdit will reflect
                // whether or not the current upDownEditbox text is in sync
                // with any internally stored values. If UserEdit is true,
                // we must validate the text the user typed or set.

                ChangingText = false;
                // Details: Usually, the code in the Text changed event handler
                // sets ChangingText back to false.
                // If the text hasn't actually changed though, the event handler
                // never fires. ChangingText should always be false on exit from
                // this property.

                if (UserEdit) {
                    ValidateEditText();
                }
            }
        }

        /// <include file='doc\UpDownBase.uex' path='docs/doc[@for="UpDownBase.TextAlign"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or
        ///       sets the alignment of the text in the up-down
        ///       control.
        ///    </para>
        /// </devdoc>
        [
        Localizable(true),
        SRCategory(SR.CatAppearance),
        DefaultValue(HorizontalAlignment.Left),
        SRDescription(SR.UpDownBaseTextAlignDescr)
        ]
        public HorizontalAlignment TextAlign {
            get {
                return upDownEdit.TextAlign;
            }
            set {
                if (!Enum.IsDefined(typeof(HorizontalAlignment), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(HorizontalAlignment));
                }
                upDownEdit.TextAlign = value;
            }
        }
        
        internal TextBox TextBox {
            get {
                return upDownEdit;
            }
        }

        /// <include file='doc\UpDownBase.uex' path='docs/doc[@for="UpDownBase.UpDownAlign"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       or sets the
        ///       alignment
        ///       of the up and down buttons on the up-down control.
        ///    </para>
        /// </devdoc>
        [
        Localizable(true),
        SRCategory(SR.CatAppearance),
        DefaultValue(LeftRightAlignment.Right),
        SRDescription(SR.UpDownBaseAlignmentDescr)
        ]
        public LeftRightAlignment UpDownAlign {

            get {
                return upDownAlign;
            }

            set {
                if (!Enum.IsDefined(typeof(LeftRightAlignment), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(LeftRightAlignment));
                }

                if (upDownAlign != value) {

                    upDownAlign = value;
                    PositionControls();
                    Invalidate();
                }
            }
        }
        
        internal UpDownButtons UpDownButtonsInternal {
            get {
                return upDownButtons;
            }
        }
        
        /// <include file='doc\UpDownBase.uex' path='docs/doc[@for="UpDownBase.UserEdit"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       or sets a value indicating whether a value has been entered by the
        ///       user.
        ///    </para>
        /// </devdoc>
        protected bool UserEdit {
            get {
                return userEdit;
            }

            set {
                userEdit = value;
            }
        }

        ////////////////////////////////////////////////////////////////////////
        // Methods
        //
        ////////////////////////////////////////////////////////////////////////
        
        /// <include file='doc\UpDownBase.uex' path='docs/doc[@for="UpDownBase.Dispose"]/*' />
        protected override void Dispose(bool disposing) 
        {
            if (disposing) 
            {
                SystemEvents.UserPreferenceChanged -= new UserPreferenceChangedEventHandler(this.UserPreferenceChanged);
            }
            base.Dispose(disposing);
        }

        /// <include file='doc\UpDownBase.uex' path='docs/doc[@for="UpDownBase.DownButton"]/*' />
        /// <devdoc>
        ///    <para>
        ///       When overridden in a derived class, handles the pressing of the down button
        ///       on the up-down control.
        ///    </para>
        /// </devdoc>
        public abstract void DownButton();
        
        /// <include file='doc\UpDownBase.uex' path='docs/doc[@for="UpDownBase.OnChanged"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para>When overridden in a derived class, raises the Changed event.
        /// event.</para>        
        /// </devdoc>
        protected virtual void OnChanged(object source, EventArgs e) {
        }

        /// <include file='doc\UpDownBase.uex' path='docs/doc[@for="UpDownBase.OnHandleCreated"]/*' />        
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Initialise the updown. Adds the upDownEdit and updown buttons.
        ///    </para>
        /// </devdoc>
        protected override void OnHandleCreated(EventArgs e) {
            base.OnHandleCreated(e);
            PositionControls();
        }

        /// <include file='doc\UpDownBase.uex' path='docs/doc[@for="UpDownBase.OnTextBoxKeyDown"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Windows.Forms.Control.KeyDown'/>
        /// event.</para>
        /// </devdoc>
        protected virtual void OnTextBoxKeyDown(object source, KeyEventArgs e) {
            this.OnKeyDown(e);
            if (interceptArrowKeys) {

                // Intercept up arrow
                if (e.KeyData == Keys.Up) {
                    UpButton();
                    e.Handled = true;
                }

                // Intercept down arrow
                else if (e.KeyData == Keys.Down) {
                    DownButton();
                    e.Handled = true;
                }
            } 
            
            // Perform text validation if ENTER is pressed
            //
            if (e.KeyCode == Keys.Return && UserEdit) {
                ValidateEditText();
            }
        }

        /// <include file='doc\UpDownBase.uex' path='docs/doc[@for="UpDownBase.OnTextBoxKeyPress"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Windows.Forms.Control.KeyPress'/>
        /// event.</para>
        /// </devdoc>
        protected virtual void OnTextBoxKeyPress(object source, KeyPressEventArgs e) {
            this.OnKeyPress(e);
        
        }
       
        /// <include file='doc\UpDownBase.uex' path='docs/doc[@for="UpDownBase.OnTextBoxLostFocus"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Windows.Forms.Control.LostFocus'/> event.</para>
        /// </devdoc>
        protected virtual void OnTextBoxLostFocus(object source, EventArgs e) {
            if (UserEdit) {
                ValidateEditText();
            }
        }

        /// <include file='doc\UpDownBase.uex' path='docs/doc[@for="UpDownBase.OnTextBoxResize"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Windows.Forms.Control.Resize'/> event.</para>
        /// </devdoc>
        protected virtual void OnTextBoxResize(object source, EventArgs e) {
            this.Height = PreferredHeight;
            PositionControls();
        }

        /// <include file='doc\UpDownBase.uex' path='docs/doc[@for="UpDownBase.OnTextBoxTextChanged"]/*' />
        /// <devdoc>
        /// <para>Raises the TextBoxTextChanged event.
        /// event.</para>
        /// </devdoc>
        protected virtual void OnTextBoxTextChanged(object source, EventArgs e) {
            if (changingText) {
                Debug.Assert(UserEdit == false, "OnTextBoxTextChanged() - UserEdit == true");
                ChangingText = false;
            }
            else {
                UserEdit = true;
            }

            this.OnTextChanged(e);
            OnChanged(source, new EventArgs());
        }
        
        /// <include file='doc\UpDownBase.uex' path='docs/doc[@for="UpDownBase.OnMouseWheel"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.Windows.Forms.Control.OnMouseWheel'/> event.</para>
        /// </devdoc>
        protected override void OnMouseWheel(MouseEventArgs e) {

            bool directionUp = true;

            // Increment the wheel delta
            wheelDelta += e.Delta;

            // If the delta has grown large enough, simulate an up/down
            // button press.
            //
            if (Math.Abs(wheelDelta) >= NativeMethods.WHEEL_DELTA) {

                if (wheelDelta < 0) {
                    directionUp = false;
                }

                if (directionUp) {
                    UpButton();
                }
                else {
                    DownButton();
                }

                wheelDelta = 0;
            }
            
            base.OnMouseWheel(e);
        }


        /// <include file='doc\UpDownBase.uex' path='docs/doc[@for="UpDownBase.OnLayout"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    Handle the layout event. The size of the upDownEdit control, and the
        ///    position of the UpDown control must be modified.
        /// </devdoc>
        protected override void OnLayout(LayoutEventArgs e) {               
               
            PositionControls();
            base.OnLayout(e);
        }

        /// <include file='doc\UpDownBase.uex' path='docs/doc[@for="UpDownBase.OnFontChanged"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Raises the FontChanged event.
        ///    </para>
        /// </devdoc>
        protected override void OnFontChanged(EventArgs e) {
            // Clear the font height cache
            FontHeight = -1;           
            
            Height = PreferredHeight;
            PositionControls();

            base.OnFontChanged(e);
        }



        /// <include file='doc\UpDownBase.uex' path='docs/doc[@for="UpDownBase.OnUpDown"]/*' />
        /// <devdoc>
        ///
        ///     Handles UpDown events, which are generated by clicking on
        ///     the updown buttons in the child updown control.
        ///
        /// </devdoc>
        private void OnUpDown(object source, UpDownEventArgs e) {

            // Modify the value

            if (e.ButtonID == (int)ButtonID.Up)
                UpButton();
            else if (e.ButtonID == (int)ButtonID.Down)
                DownButton();
        }

        /// <include file='doc\UpDownBase.uex' path='docs/doc[@for="UpDownBase.PositionControls"]/*' />
        /// <devdoc>
        ///     Calculates the size and position of the upDownEdit control and
        ///     the updown buttons.
        /// </devdoc>
        private void PositionControls() {

            // Determine the size of the control

            Size newSize = ClientSize;

            // Translate UpDownAlign
            LeftRightAlignment translatedUpDownAlign = RtlTranslateLeftRight(upDownAlign);

            // Reposition and resize the upDownEdit control
            //
            if (upDownEdit != null) {
                upDownEdit.Size = new Size(newSize.Width - DefaultButtonsWidth, newSize.Height);
            
                if (translatedUpDownAlign == LeftRightAlignment.Left) {
                    upDownEdit.Location = new Point(DefaultButtonsWidth, 0);
                }
                else {
                    upDownEdit.Location = new Point(0, 0);
                }
            }

            // Reposition and resize the updown buttons
            //
            if (upDownButtons != null) {
                if (translatedUpDownAlign == LeftRightAlignment.Left) {
                    upDownButtons.Location = new Point(0, 0);
                }
                else {
                    upDownButtons.Location = new Point(newSize.Width - DefaultButtonsWidth, 0);
                }
            }
            upDownButtons.Size = new Size(upDownButtons.Size.Width, newSize.Height);
            upDownButtons.Invalidate();
        }    

        /// <include file='doc\UpDownBase.uex' path='docs/doc[@for="UpDownBase.Select"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Selects a range of
        ///       text in the up-down control.
        ///    </para>
        /// </devdoc>
        public void Select(int start, int length) {
            upDownEdit.Select(start, length);
        }
        
        /// <include file='doc\UpDownBase.uex' path='docs/doc[@for="UpDownBase.SetBoundsCore"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Restricts the vertical size of the control
        ///    </para>
        /// </devdoc>
        protected override void SetBoundsCore(int x, int y, int width, int height, BoundsSpecified specified) {
            base.SetBoundsCore(x, y, width, PreferredHeight, specified);
        }
        
        /// <include file='doc\UpDownBase.uex' path='docs/doc[@for="UpDownBase.UpButton"]/*' />
        /// <devdoc>
        ///    <para>
        ///       When overridden in a derived class, handles the pressing of the up button on the up-down control.
        ///    </para>
        /// </devdoc>
        public abstract void UpButton();
        
        /// <include file='doc\UpDownBase.uex' path='docs/doc[@for="UpDownBase.UpdateEditText"]/*' />
        /// <devdoc>
        ///    <para>
        ///       When overridden
        ///       in a derived class, updates the text displayed in the up-down control.
        ///    </para>
        /// </devdoc>
        protected abstract void UpdateEditText();
        
        private void UserPreferenceChanged(object sender, UserPreferenceChangedEventArgs pref) {
            if (pref.Category == UserPreferenceCategory.Locale) {
                UpdateEditText();
            }
        }
        
        /// <include file='doc\UpDownBase.uex' path='docs/doc[@for="UpDownBase.ValidateEditText"]/*' />
        /// <devdoc>
        ///    <para>
        ///       When overridden in a
        ///       derived class, validates the text displayed in the up-down control.
        ///    </para>
        /// </devdoc>
        protected virtual void ValidateEditText() {
        }
        
        /// <include file='doc\UpDownBase.uex' path='docs/doc[@for="UpDownBase.WndProc"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        protected override void WndProc(ref Message m) 
        {
            switch (m.Msg) 
            {
                case NativeMethods.WM_SETFOCUS:
                    if (!HostedInWin32DialogManager) {
                        if (ActiveControl == null) {
                            SetActiveControlInternal(TextBox);
                        }
                        else {
                            FocusActiveControlInternal();
                        }
                    }
                    else {
                        base.WndProc(ref m);
                    }
                    break;
                case NativeMethods.WM_KILLFOCUS:
                    DefWndProc(ref m);
                    break;
                default:
                    base.WndProc(ref m);
                    break;
            }
        }

        internal class UpDownEdit:TextBox{
            /////////////////////////////////////////////////////////////////////
            // Member variables
            //
            /////////////////////////////////////////////////////////////////////

            // Parent control
            private UpDownBase parent;
            private bool doubleClickFired = false;
            /////////////////////////////////////////////////////////////////////
            // Constructors
            //
            /////////////////////////////////////////////////////////////////////

            internal UpDownEdit(UpDownBase parent)
            : base() {
            
                SetStyle(ControlStyles.FixedHeight |
                         ControlStyles.FixedWidth, true);

                SetStyle(ControlStyles.Selectable, false);

                this.parent = parent;
            }


            protected override void OnMouseDown(MouseEventArgs e) {
                if (e.Clicks == 2 ) {
                    doubleClickFired = true;
                }                

                parent.OnMouseDown(e);

            }

            /// <include file='doc\UpDownBase.uex' path='docs/doc[@for="UpDownBase.UpDownButtons.OnMouseUp"]/*' />
            /// <devdoc>
            ///
            ///     Handles detecting when the mouse button is released.
            ///
            /// </devdoc>
            protected override void OnMouseUp(MouseEventArgs e) {
                
                Point pt = new Point(e.X,e.Y);
                pt = PointToScreen(pt);
    
                if (e.Button == MouseButtons.Left) {
                    if (!parent.ValidationCancelled && UnsafeNativeMethods.WindowFromPoint(pt.X, pt.Y) == Handle) {
                        if (!doubleClickFired) {
                            parent.OnClick(EventArgs.Empty);
                        }
                        else {
                            doubleClickFired = false;
                            parent.OnDoubleClick(EventArgs.Empty);
                        }
                    }
                    doubleClickFired = false;
                }
                
                parent.OnMouseUp(e);
            }

            
            /// <include file='doc\UpDownBase.uex' path='docs/doc[@for="UpDownBase.OnTextBoxKeyUp"]/*' />
            /// <devdoc>
            /// <para>Raises the <see cref='System.Windows.Forms.Control.KeyUp'/>
            /// event.</para>
            /// </devdoc>
            protected override void OnKeyUp(KeyEventArgs e) {
                parent.OnKeyUp(e);
            }
        
            protected override void OnGotFocus(EventArgs e) {
                parent.SetActiveControlInternal(this);
                parent.OnGotFocus(e);
            }

            protected override void OnLostFocus(EventArgs e) {
                parent.OnLostFocus(e);
            }

            // REGISB: Focus fixes. The XXXUpDown control will
            //         also fire a Leave event. We don't want
            //         to fire two of them.
            // protected override void OnLeave(EventArgs e) {
            //     parent.OnLeave(e);
            // }
        }
        /// <include file='doc\UpDownBase.uex' path='docs/doc[@for="UpDownBase.UpDownButtons"]/*' />
        /// <devdoc>
        ///
        ///     Nested class UpDownButtons
        ///
        ///     A control representing the pair of buttons on the end of the upDownEdit control.
        ///     This class handles drawing the updown buttons, and detecting mouse actions
        ///     on these buttons. Acceleration on the buttons is handled. The control
        ///     sends UpDownEventArgss to the parent UpDownBase class when a button is pressed,
        ///     or when the acceleration determines that another event should be generated.
        /// </devdoc>
        internal class UpDownButtons : Control {
            // CONSIDER: Use ScrollButtons instead of this class.

            /////////////////////////////////////////////////////////////////////
            // Member variables
            //
            /////////////////////////////////////////////////////////////////////

            // Parent control
            private UpDownBase parent;

            // Button state
            private ButtonID pushed = ButtonID.None;
            private ButtonID captured = ButtonID.None;

            // UpDown event handler
            private UpDownEventHandler upDownEventHandler;

            // Timer
            private Timer timer;                    // generates UpDown events
            private int timerInterval;              // milliseconds between events

            private bool doubleClickFired = false;

            /////////////////////////////////////////////////////////////////////
            // Constructors
            //
            /////////////////////////////////////////////////////////////////////

            internal UpDownButtons(UpDownBase parent)

            : base() {
            
                SetStyle(ControlStyles.FixedHeight |
                         ControlStyles.FixedWidth, true);

                SetStyle(ControlStyles.Selectable, false);

                this.parent = parent;
            }


            /////////////////////////////////////////////////////////////////////
            // Methods
            //
            /////////////////////////////////////////////////////////////////////

            /// <include file='doc\UpDownBase.uex' path='docs/doc[@for="UpDownBase.UpDownButtons.UpDown"]/*' />
            /// <devdoc>
            ///
            ///     Adds a handler for the updown button event.
            /// </devdoc>
            public event UpDownEventHandler UpDown {
                add {
                    upDownEventHandler += value;
                }
                remove {
                    upDownEventHandler -= value;
                }
            }   
            
            // Called when the mouse button is pressed - we need to start
            // spinning the value of the updown.
            //
            private void BeginButtonPress(MouseEventArgs e) {
                
                int half_height = Size.Height / 2;

                if (e.Y < half_height) {

                    // Up button
                    //
                    pushed = captured = ButtonID.Up;
                    Invalidate();

                }
                else {

                    // Down button
                    //
                    pushed = captured = ButtonID.Down;
                    Invalidate();
                }

                // Capture the mouse
                //
                CaptureInternal = true;
                
                // Generate UpDown event
                //
                OnUpDown(new UpDownEventArgs((int)pushed));

                // Start the timer for new updown events
                //
                StartTimer();
            }
            
            protected override AccessibleObject CreateAccessibilityInstance() {
                return new UpDownButtonsAccessibleObject(this);
            }
            
            // Called when the mouse button is released - we need to stop
            // spinning the value of the updown.
            //
            private void EndButtonPress() {
                
                pushed = ButtonID.None;
                captured = ButtonID.None;

                // Stop the timer
                StopTimer();

                // Release the mouse
                CaptureInternal = false;

                // Redraw the buttons
                Invalidate();
            }
            
            /// <include file='doc\UpDownBase.uex' path='docs/doc[@for="UpDownBase.UpDownButtons.OnMouseDown"]/*' />
            /// <devdoc>
            ///
            ///     Handles detecting mouse hits on the buttons. This method
            ///     detects which button was hit (up or down), fires a
            ///     updown event, captures the mouse, and starts a timer
            ///     for repeated updown events.
            ///
            /// </devdoc>
            protected override void OnMouseDown(MouseEventArgs e) {
                // Begin spinning the value
                //
                
                // Focus the parent
                //
                this.parent.FocusInternal();

                if (!parent.ValidationCancelled && e.Button == MouseButtons.Left) {
                    BeginButtonPress(e);                                        
                }
                if (e.Clicks == 2 ) {
                    doubleClickFired = true;
                }
                // At no stage should a button be pushed, and the mouse
                // not captured.
                //
                Debug.Assert(!(pushed != ButtonID.None && captured == ButtonID.None),
                             "Invalid button pushed/captured combination");
                
                parent.OnMouseDown(e);
            }

            /// <include file='doc\UpDownBase.uex' path='docs/doc[@for="UpDownBase.UpDownButtons.OnMouseMove"]/*' />
            /// <devdoc>
            ///
            ///     Handles detecting mouse movement.
            ///
            /// </devdoc>
            protected override void OnMouseMove(MouseEventArgs e) {

                // If the mouse is captured by the buttons (i.e. an updown button
                // was pushed, and the mouse button has not yet been released),
                // determine the new state of the buttons depending on where
                // the mouse pointer has moved.

                if (Capture) {

                    // Determine button area

                    Rectangle rect = ClientRectangle;
                    rect.Height /= 2;

                    if (captured == ButtonID.Down) {
                        rect.Y += rect.Height;
                    }

                    // Test if the mouse has moved outside the button area

                    if (rect.Contains(e.X, e.Y)) {

                        // Inside button
                        // Repush the button if necessary

                        if (pushed != captured) {

                            // Restart the timer
                            StartTimer();

                            pushed = captured;
                            Invalidate();
                        }

                    }
                    else {

                        // Outside button
                        // Retain the capture, but pop the button up whilst
                        // the mouse remains outside the button and the
                        // mouse button remains pressed.

                        if (pushed != ButtonID.None) {

                            // Stop the timer for updown events
                            StopTimer();

                            pushed = ButtonID.None;
                            Invalidate();
                        }
                    }
                }

                // At no stage should a button be pushed, and the mouse
                // not captured.
                Debug.Assert(!(pushed != ButtonID.None && captured == ButtonID.None),
                             "Invalid button pushed/captured combination");
               
                parent.OnMouseMove(e);
            }

            /// <include file='doc\UpDownBase.uex' path='docs/doc[@for="UpDownBase.UpDownButtons.OnMouseUp"]/*' />
            /// <devdoc>
            ///
            ///     Handles detecting when the mouse button is released.
            ///
            /// </devdoc>
            protected override void OnMouseUp(MouseEventArgs e) {

                if (!parent.ValidationCancelled && e.Button == MouseButtons.Left) {
                    EndButtonPress();                           
                }

                // At no stage should a button be pushed, and the mouse
                // not captured.
                Debug.Assert(!(pushed != ButtonID.None && captured == ButtonID.None),
                             "Invalid button pushed/captured combination");
                
                Point pt = new Point(e.X,e.Y);
                pt = PointToScreen(pt);
    
                if (e.Button == MouseButtons.Left) {
                    if (!parent.ValidationCancelled && UnsafeNativeMethods.WindowFromPoint(pt.X, pt.Y) == Handle) {
                        if (!doubleClickFired) {
                            this.parent.OnClick(EventArgs.Empty);
                        }
                        else {
                            doubleClickFired = false;
                            this.parent.OnDoubleClick(EventArgs.Empty);
                        }
                    }
                    doubleClickFired = false;
                }
                
                parent.OnMouseUp(e);
            }

            /// <include file='doc\UpDownBase.uex' path='docs/doc[@for="UpDownBase.UpDownButtons.OnPaint"]/*' />
            /// <devdoc>
            ///     Handles painting the buttons on the control.
            ///
            /// </devdoc>
            protected override void OnPaint(PaintEventArgs e) {

                int half_height = ClientSize.Height / 2;

                /* Draw the up and down buttons */

                ControlPaint.DrawScrollButton(e.Graphics,
                                              new Rectangle(0, 0, DefaultButtonsWidth, half_height),
                                              ScrollButton.Up,
                                              pushed == ButtonID.Up ? ButtonState.Pushed : ButtonState.Normal);

                ControlPaint.DrawScrollButton(e.Graphics,
                                              new Rectangle(0, half_height, DefaultButtonsWidth, half_height),
                                              ScrollButton.Down,
                                              pushed == ButtonID.Down ? ButtonState.Pushed : ButtonState.Normal);
            
                base.OnPaint(e); // raise paint event, just in case this inner class goes public some day
            }

            /// <include file='doc\UpDownBase.uex' path='docs/doc[@for="UpDownBase.UpDownButtons.OnUpDown"]/*' />
            /// <devdoc>
            ///     Occurs when the UpDown buttons are pressed.
            /// </devdoc>
            protected virtual void OnUpDown(UpDownEventArgs upevent) {
                if (upDownEventHandler != null)
                    upDownEventHandler(this, upevent);
            }

            /// <include file='doc\UpDownBase.uex' path='docs/doc[@for="UpDownBase.UpDownButtons.StartTimer"]/*' />
            /// <devdoc>
            ///     Starts the timer for generating updown events
            /// </devdoc>
            protected void StartTimer() {

                if (timer == null) {
                    timer = new Timer();      // generates UpDown events
                    // Add the timer handler
                    timer.Tick += new EventHandler(TimerHandler);
                }
                
                timerInterval = TimerInterval;
                timer.Interval = timerInterval;
                timer.Start();
            }

            /// <include file='doc\UpDownBase.uex' path='docs/doc[@for="UpDownBase.UpDownButtons.StopTimer"]/*' />
            /// <devdoc>
            ///     Stops the timer for generating updown events
            /// </devdoc>
            protected void StopTimer() {
                if (timer != null) {
                    timer.Stop();
                    timer.Dispose();
                    timer = null;
                }
            }
            
            /// <include file='doc\UpDownBase.uex' path='docs/doc[@for="UpDownBase.UpDownButtons.TimerHandler"]/*' />
            /// <devdoc>
            ///     Generates updown events when the timer calls this function.
            /// </devdoc>
            private void TimerHandler(object source, EventArgs args) {
            
                // Make sure we've got mouse capture
                if (!Capture) {
                    EndButtonPress();
                    return;
                }
            
                OnUpDown(new UpDownEventArgs((int)pushed));

                timerInterval *= 7; timerInterval /= 10;

                if (timerInterval < 1) {
                    timerInterval = 1;
                }
                
                timer.Interval = timerInterval;
            }
            
            internal class UpDownButtonsAccessibleObject : ControlAccessibleObject {
            
                private DirectionButtonAccessibleObject upButton;
                private DirectionButtonAccessibleObject downButton;
                
                public UpDownButtonsAccessibleObject(UpDownButtons owner) : base(owner) {                    
                }
                
                public override string Name {
                    get {
                        string baseName = base.Name;
                        if (baseName == null || baseName.Length == 0) {
                            return "Spinner";
                        }
                        return baseName;
                    }
                    set {
                        base.Name = value;
                    }
                }
                
                /// <include file='doc\DomainUpDown.uex' path='docs/doc[@for="DomainUpDown.DomainUpDownAccessibleObject.Role"]/*' />
                /// <devdoc>
                ///    <para>[To be supplied.]</para>
                /// </devdoc>
                public override AccessibleRole Role {
                    get {
                        return AccessibleRole.SpinButton;
                    }
                }
                
                private DirectionButtonAccessibleObject UpButton {
                    get {
                        if (upButton == null) {
                            upButton = new DirectionButtonAccessibleObject(this, true);
                        }
                        return upButton;
                    }
                }
                
                private DirectionButtonAccessibleObject DownButton {
                    get {
                        if (downButton == null) {
                            downButton = new DirectionButtonAccessibleObject(this, false);
                        }
                        return downButton;
                    }
                }
                
                
    
                /// <include file='doc\DomainUpDown.uex' path='docs/doc[@for="DomainUpDown.DomainUpDownAccessibleObject.GetChild"]/*' />
                /// <devdoc>
                /// </devdoc>
                public override AccessibleObject GetChild(int index) {
                        
                    // Up button
                    //
                    if (index == 0) {
                        return UpButton;
                    }
                    
                    // Down button
                    //
                    if (index == 1) {
                        return DownButton;
                    }
                    
                    return null;
                }
    
                /// <include file='doc\DomainUpDown.uex' path='docs/doc[@for="DomainUpDown.DomainUpDownAccessibleObject.GetChildCount"]/*' />
                /// <devdoc>
                /// </devdoc>
                public override int GetChildCount() {
                    return 2;
                }
                
                internal class DirectionButtonAccessibleObject : AccessibleObject {
                    private bool up;
                    private UpDownButtonsAccessibleObject parent;
                    
                    public DirectionButtonAccessibleObject(UpDownButtonsAccessibleObject parent, bool up) {
                        this.parent = parent;
                        this.up = up;
                    }
                    
                    public override Rectangle Bounds {
                        get {
                            // Get button bounds
                            //
                            Rectangle bounds = ((UpDownButtons)parent.Owner).Bounds;
                            bounds.Height /= 2;
                            if (!up) {
                                bounds.Y += bounds.Height;
                            }
                            
                            // Convert to screen co-ords
                            //
                            return (((UpDownButtons)parent.Owner).ParentInternal).RectangleToScreen(bounds);
                        }
                    }
                    
                    public override string Name {
                        get {
                            if (up) {
                                return SR.GetString(SR.UpDownBaseUpButtonAccName);
                            }
                            return SR.GetString(SR.UpDownBaseDownButtonAccName);
                        }
                        set {
                        }
                    }
                    
                    public override AccessibleObject Parent {
                        get {
                            return parent;
                        }
                    }                                    
                                    
                    public override AccessibleRole Role {
                        get {
                            return AccessibleRole.PushButton;
                        }
                    }
                }
            }

        } // end class UpDownButtons
        
        // Button identifiers

        internal enum ButtonID {
            None = 0,
            Up = 1,
            Down = 2,
        }
    } // end class UpDownBase
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\view.cs ===
//------------------------------------------------------------------------------
// <copyright file="View.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {

    using System.Diagnostics;
    using System;
    using System.ComponentModel;
    using System.Drawing;
    using Microsoft.Win32;



    /// <include file='doc\View.uex' path='docs/doc[@for="View"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies how list items are displayed in
    ///       a <see cref='System.Windows.Forms.ListView'/> control.
    ///    </para>
    /// </devdoc>
    public enum View {

        /// <include file='doc\View.uex' path='docs/doc[@for="View.LargeIcon"]/*' />
        /// <devdoc>
        ///     Each item appears as a full-sized icon with a label below it.
        /// </devdoc>
        LargeIcon = NativeMethods.LVS_ICON,

        /// <include file='doc\View.uex' path='docs/doc[@for="View.Details"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Each item appears on a seperate line with further
        ///       information about each item arranged in columns. The left
        ///       most column
        ///       contains a small icon and
        ///       label, and subsequent columns contain subitems as specified by the application. A
        ///       column displays a header which can display a caption for the
        ///       column. The user can resize each column at runtime.
        ///    </para>
        /// </devdoc>
        Details = NativeMethods.LVS_REPORT,

        /// <include file='doc\View.uex' path='docs/doc[@for="View.SmallIcon"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Each item appears as a small icon with a label to its right.
        ///    </para>
        /// </devdoc>
        SmallIcon = NativeMethods.LVS_SMALLICON,

        /// <include file='doc\View.uex' path='docs/doc[@for="View.List"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Each item
        ///       appears as a small icon with a label to its right.
        ///       Items are arranged in columns with no column headers.
        ///    </para>
        /// </devdoc>
        List = NativeMethods.LVS_LIST,

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\vscrollbar.cs ===
//------------------------------------------------------------------------------
// <copyright file="VScrollBar.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {

    using System.Diagnostics;

    using System;
    using System.Security.Permissions;
    using System.Windows.Forms;
    using System.ComponentModel;
    using System.Drawing;
    using Microsoft.Win32;

    /// <include file='doc\VScrollBar.uex' path='docs/doc[@for="VScrollBar"]/*' />
    /// <devdoc>
    ///    <para>Represents
    ///       a standard Windows vertical scroll bar.</para>
    /// </devdoc>
    public class VScrollBar : ScrollBar {

        /// <include file='doc\VScrollBar.uex' path='docs/doc[@for="VScrollBar.CreateParams"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Returns the parameters needed to create the handle. Inheriting classes
        ///       can override this to provide extra functionality. They should not,
        ///       however, forget to call base.getCreateParams() first to get the struct
        ///       filled up with the basic info.
        ///    </para>
        /// </devdoc>
        protected override CreateParams CreateParams {
            [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
            get {
                CreateParams cp = base.CreateParams;
                cp.Style |= NativeMethods.SBS_VERT;
                return cp;
            }
        }
        
        /// <include file='doc\VScrollBar.uex' path='docs/doc[@for="VScrollBar.DefaultSize"]/*' />
        /// <devdoc>
        ///     Deriving classes can override this to configure a default size for their control.
        ///     This is more efficient than setting the size in the control's constructor.
        /// </devdoc>
        protected override Size DefaultSize {
            get {
                return new Size(SystemInformation.VerticalScrollBarWidth, 80);
            }
        }

        /// <include file='doc\VScrollBar.uex' path='docs/doc[@for="VScrollBar.RightToLeft"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public override RightToLeft RightToLeft {
            get {
                return RightToLeft.No;
            }
            set {
            }
        }
        /// <include file='doc\VScrollBar.uex' path='docs/doc[@for="VScrollBar.RightToLeftChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public new event EventHandler RightToLeftChanged {
            add {
                base.RightToLeftChanged += value;
            }
            remove {
                base.RightToLeftChanged -= value;
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\usercontrol.cs ===
//------------------------------------------------------------------------------
// <copyright file="UserControl.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {

    using Microsoft.Win32;
    using System;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.ComponentModel.Design.Serialization;
    using System.Diagnostics;
    using System.Drawing;    
    using System.Runtime.InteropServices;
    using System.Runtime.Remoting;
    using System.Security.Permissions;
    using System.Windows.Forms.Design;

    /// <include file='doc\UserControl.uex' path='docs/doc[@for="UserControl"]/*' />
    /// <devdoc>
    ///     Represents an empty control that can be used in the Forms Designer to create other  controls.   By extending form, UserControl inherits all of
    ///     the standard positioning and mnemonic handling code that is necessary
    ///     in a user control.
    /// </devdoc>
    [
    Designer("System.Windows.Forms.Design.UserControlDocumentDesigner, " + AssemblyRef.SystemDesign, typeof(IRootDesigner)),
    Designer("System.Windows.Forms.Design.ControlDesigner, " + AssemblyRef.SystemDesign),
    DesignerCategory("UserControl"),
    DefaultEvent("Load"),
    ]
    public class UserControl : ContainerControl {
        private static readonly object EVENT_LOAD = new object();

        /// <include file='doc\UserControl.uex' path='docs/doc[@for="UserControl.UserControl"]/*' />
        /// <devdoc>
        ///    Creates a new UserControl object. A vast majority of people
        ///    will not want to instantiate this class directly, but will be a
        ///    sub-class of it.
        /// </devdoc>
        public UserControl() {
            SetScrollState(ScrollStateAutoScrolling, false);
            SetState(STATE_VISIBLE, true);
            SetState(STATE_TOPLEVEL, false);
        }
        
        /// <include file='doc\UserControl.uex' path='docs/doc[@for="UserControl.DefaultSize"]/*' />
        /// <devdoc>
        ///     The default size for this user control.
        /// </devdoc>
        protected override Size DefaultSize {
            get {
                return new Size(150, 150);
            }
        }

        /// <include file='doc\UserControl.uex' path='docs/doc[@for="UserControl.Load"]/*' />
        /// <devdoc>
        ///    <para>Occurs before the control becomes visible.</para>
        /// </devdoc>
        [SRCategory(SR.CatBehavior), SRDescription(SR.UserControlOnLoadDescr)]
        public event EventHandler Load {
            add {
                Events.AddHandler(EVENT_LOAD, value);
            }
            remove {
                Events.RemoveHandler(EVENT_LOAD, value);
            }
        }

        /// <include file='doc\UserControl.uex' path='docs/doc[@for="UserControl.Text"]/*' />
        [
        Browsable(false), EditorBrowsable(EditorBrowsableState.Never), 
        Bindable(false), 
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]                
        public override string Text {
            get {
                return base.Text;
            }
            set {
                base.Text = value;
            }
        }

        /// <include file='doc\UserControl.uex' path='docs/doc[@for="UserControl.TextChanged"]/*' />
        /// <internalonly/>
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        new public event EventHandler TextChanged {
            add {
                base.TextChanged += value;
            }
            remove {
                base.TextChanged -= value;
            }
        }
        
        private bool FocusInside() {
            if (!IsHandleCreated) return false;

            IntPtr hwndFocus = UnsafeNativeMethods.GetFocus();
            if (hwndFocus == IntPtr.Zero) return false;

            IntPtr hwnd = Handle;
            if (hwnd == hwndFocus || SafeNativeMethods.IsChild(new HandleRef(this, hwnd), new HandleRef(null, hwndFocus)))
                return true;

            return false;
        }

        /// <include file='doc\UserControl.uex' path='docs/doc[@for="UserControl.OnCreateControl"]/*' />
        /// <devdoc>
        ///    <para> Raises the CreateControl event.</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected override void OnCreateControl() {
            base.OnCreateControl();
            
            OnLoad(EventArgs.Empty);
        }

        /// <include file='doc\UserControl.uex' path='docs/doc[@for="UserControl.OnLoad"]/*' />
        /// <devdoc>
        ///    <para>The Load event is fired before the control becomes visible for the first time.</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void OnLoad(EventArgs e) {
            // There is no good way to explain this event except to say
            // that it's just another name for OnControlCreated.
            EventHandler handler = (EventHandler)Events[EVENT_LOAD];
            if (handler != null) handler(this,e);
        }

        /// <include file='doc\UserControl.uex' path='docs/doc[@for="UserControl.OnMouseDown"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected override void OnMouseDown(MouseEventArgs e) {
            if (!FocusInside())
                FocusInternal();
            base.OnMouseDown(e);
        }

        private void WmSetFocus(ref Message m) {
            if (!HostedInWin32DialogManager) {
                IntSecurity.ModifyFocus.Assert();
                try {
                    if (ActiveControl == null)
                        SelectNextControl(null, true, true, true, false);
                }
                finally {
                    System.Security.CodeAccessPermission.RevertAssert();
                }
            }
            base.WndProc(ref m);
        }

        /// <include file='doc\UserControl.uex' path='docs/doc[@for="UserControl.WndProc"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
        protected override void WndProc(ref Message m) {
            switch (m.Msg) {
                case NativeMethods.WM_SETFOCUS:
                    WmSetFocus(ref m);
                    break;
                default:
                    base.WndProc(ref m);
                    break;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\wincategoryattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="WinCategoryAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {
    
    using System;
    using System.ComponentModel;   
    using System.Diagnostics;

    /// <include file='doc\WinCategoryAttribute.uex' path='docs/doc[@for="WinCategoryAttribute"]/*' />
    /// <internalonly/>
    /// <devdoc>
    ///    <para>
    ///       CategoryAttribute that can access WinForms localized strings.
    ///    </para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.All)]
    internal sealed class WinCategoryAttribute : CategoryAttribute {

        /// <include file='doc\WinCategoryAttribute.uex' path='docs/doc[@for="WinCategoryAttribute.WinCategoryAttribute"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.ComponentModel.CategoryAttribute'/> class.
        ///    </para>
        /// </devdoc>
        public WinCategoryAttribute(string category) : base(category) {
        }

        /// <include file='doc\WinCategoryAttribute.uex' path='docs/doc[@for="WinCategoryAttribute.GetLocalizedString"]/*' />
        /// <devdoc>
        ///     This method is called the first time the category property
        ///     is accessed.  It provides a way to lookup a localized string for
        ///     the given category.  Classes may override this to add their
        ///     own localized names to categories.  If a localized string is
        ///     available for the given value, the method should return it.
        ///     Otherwise, it should return null.
        /// </devdoc>
        protected override string GetLocalizedString(string value) {
            string localizedValue = base.GetLocalizedString(value);
            if (localizedValue == null) {
                localizedValue = (string)SR.GetObject("WinFormsCategory" + value);
            }
            // This attribute is internal, and we should never have a missing resource string.
            //
            Debug.Assert(localizedValue != null, "All Windows Forms category attributes should have localized strings.  Category '" + value + "' not found.");
            return localizedValue;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\windowsformssectionhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="WindowsFormsSectionHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   WindowsFormsSectionHandler.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.Windows.Forms {

    using System;
    using System.Diagnostics;
    using System.Configuration;
    using System.Collections;
    using System.Xml;

    // don't implement IDictionary... makes anyone able to read this data...
    //
    internal class ConfigData {
        internal const bool JitDebuggingDefault = false;

        internal static bool JitDebugging {
            get {
                ConfigData config = null;
                try {
                    config = (ConfigData)System.Configuration.ConfigurationSettings.GetConfig("system.windows.forms");
                }
                catch {
                    Debug.Fail("Exception loading config for windows forms");
                }

                if (config != null) {
                    return (bool)config["jitDebugging"];
                }
                else {
                    return JitDebuggingDefault;
                }
            }
        }

        internal Hashtable data;

        internal ConfigData(Hashtable data) {
            this.data = data;
        }

        internal object this[object key] {
            get {
                return data[key];
            }
        }
    }
    /// <include file='doc\WindowsFormsSectionHandler.uex' path='docs/doc[@for="WindowsFormsSectionHandler"]/*' />
    internal class WindowsFormsSectionHandler : IConfigurationSectionHandler {

        /// <include file='doc\WindowsFormsSectionHandler.uex' path='docs/doc[@for="WindowsFormsSectionHandler.Create"]/*' />
        public object Create(object parent, object configContext, XmlNode section) {
            Hashtable res;

            // start res off as a shallow clone of the parent
            if (parent == null)
                res = new Hashtable();
            else
                res = (Hashtable)((ConfigData)parent).data.Clone();

            XmlNode node = section.Attributes.RemoveNamedItem("jitDebugging");
            if (node != null) {

                // don't use bool.Parse - we only want to honor these exact strings.
                //
                switch (node.Value) {
                    case "true":
                        res["jitDebugging"] = true;
                        break;
                    case "false":
                        res["jitDebugging"] = false;
                        break;
                    default:
                        throw new ConfigurationException(SR.GetString(SR.Invalid_boolean_attribute, node.Name), node);
                }
            }
            else {
                if (!res.ContainsKey("jitDebugging")) {
                    res["jitDebugging"] = ConfigData.JitDebuggingDefault;
                }
            }

            if (section.Attributes.Count > 0) {
                throw new ConfigurationException(SR.GetString(SR.Config_base_unrecognized_attribute, section.Attributes[0].Name), section);                
            }

            return new ConfigData(res);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\componentmodel\icomponenteditorpagesite.cs ===
//------------------------------------------------------------------------------
// <copyright file="IComponentEditorPageSite.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

namespace System.Windows.Forms {
    using System.ComponentModel;

    using System.Diagnostics;

    using System;
    using System.Windows.Forms;
    using Microsoft.Win32;

    /// <include file='doc\IComponentEditorPageSite.uex' path='docs/doc[@for="IComponentEditorPageSite"]/*' />
    /// <internalonly/>
    /// <devdoc>
    ///    <para>The site for a ComponentEditorPage.</para>
    /// </devdoc>
    public interface IComponentEditorPageSite {

        /// <include file='doc\IComponentEditorPageSite.uex' path='docs/doc[@for="IComponentEditorPageSite.GetControl"]/*' />
        /// <devdoc>
        ///     Returns the parent control for the page window.
        /// </devdoc>
        Control GetControl();

        /// <include file='doc\IComponentEditorPageSite.uex' path='docs/doc[@for="IComponentEditorPageSite.SetDirty"]/*' />
        /// <devdoc>
        ///     Notifies the site that the editor is in dirty state.
        /// </devdoc>
        void SetDirty();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\componentmodel\com2interop\com2colorconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="COM2ColorConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms.ComponentModel.Com2Interop {
    using System.Runtime.Serialization.Formatters;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Windows.Forms;
    
    using System.Drawing;    
    using System.Collections;
    using Hashtable = System.Collections.Hashtable;
    using Microsoft.Win32;

    /// <include file='doc\COM2ColorConverter.uex' path='docs/doc[@for="Com2ColorConverter"]/*' />
    /// <devdoc>
    /// This class maps an OLE_COLOR to a managed Color editor.
    /// </devdoc>
    internal class Com2ColorConverter : Com2DataTypeToManagedDataTypeConverter{

         /// <include file='doc\COM2ColorConverter.uex' path='docs/doc[@for="Com2ColorConverter.ManagedType"]/*' />
         /// <devdoc>
         ///     Returns the managed type that this editor maps the property type to.
         /// </devdoc>
         public override Type ManagedType{
            get{
               return typeof(Color);
            }
         }

         /// <include file='doc\COM2ColorConverter.uex' path='docs/doc[@for="Com2ColorConverter.ConvertNativeToManaged"]/*' />
         /// <devdoc>
         ///     Converts the native value into a managed value
         /// </devdoc>
         public override object ConvertNativeToManaged(object nativeValue, Com2PropertyDescriptor pd){
               object baseValue = nativeValue;
               int intVal = 0;

               // get the integer value out of the native...
               //
               if (nativeValue is UInt32){
                  intVal = (int)(UInt32)nativeValue;
               }
               else if (nativeValue is Int32){
                  intVal = (int)nativeValue;
               }

               return ColorTranslator.FromOle(intVal);
         }

         /// <include file='doc\COM2ColorConverter.uex' path='docs/doc[@for="Com2ColorConverter.ConvertManagedToNative"]/*' />
         /// <devdoc>
         ///     Converts the managed value into a native value
         /// </devdoc>
         public override object ConvertManagedToNative(object managedValue, Com2PropertyDescriptor pd, ref bool cancelSet){
               // don't cancel the set
               cancelSet = false;

               // we default to black.
               //
               if (managedValue == null){
                  managedValue = Color.Black;
               }

               if (managedValue is Color){
                  return ColorTranslator.ToOle(((Color)managedValue));

               }
               Debug.Fail("Don't know how to set type:" + managedValue.GetType().Name);
               return 0;
         }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\componentmodel\com2interop\basecamarshaler.cs ===
//------------------------------------------------------------------------------
// <copyright file="BaseCAMarshaler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms.ComponentModel.Com2Interop {
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Windows.Forms;
    using Microsoft.Win32;


    /// <include file='doc\BaseCAMarshaler.uex' path='docs/doc[@for="BaseCAMarshaler"]/*' />
    /// <devdoc>
    ///   This class performs basic operation for marshaling data passed
    ///   in from native in one of the CA*** structs (CADWORD, CAUUID, etc),
    ///   which are structs in which the first word is the number of elements
    ///   and the second is a pointer to an array of such elements.
    ///
    /// </devdoc>
    internal abstract class BaseCAMarshaler {

        private static TraceSwitch CAMarshalSwitch = new TraceSwitch("CAMarshal", "BaseCAMarshaler: Debug CA* struct marshaling");

        private IntPtr caArrayAddress;
        private int count;
        private object[] itemArray;

        /// <include file='doc\BaseCAMarshaler.uex' path='docs/doc[@for="BaseCAMarshaler.BaseCAMarshaler"]/*' />
        /// <devdoc>
        ///     Base ctor
        /// </devdoc>
        protected BaseCAMarshaler(NativeMethods.CA_STRUCT caStruct) : base() {
            if (caStruct == null) {
                count = 0;
                Debug.WriteLineIf(CAMarshalSwitch.TraceVerbose, "BaseCAMarshaler: null passed in!");
            }

            // first 4 bytes is the count
            count = caStruct.cElems;
            caArrayAddress = caStruct.pElems;
            Debug.WriteLineIf(CAMarshalSwitch.TraceVerbose, "Marshaling " + count.ToString() + " items of type " + ItemType.Name);
        }

        ~BaseCAMarshaler() {
            try {
                if (itemArray == null && caArrayAddress != IntPtr.Zero) {
                     object[] items = Items;
                }
            }
            catch {
            }
        }

        protected abstract Array CreateArray();

        /// <include file='doc\BaseCAMarshaler.uex' path='docs/doc[@for="BaseCAMarshaler.ItemType"]/*' />
        /// <devdoc>
        ///     Returns the type of item this marshaler will
        ///     return in the items array.
        /// </devdoc>
        public abstract Type ItemType {
            get;
        }


        /// <include file='doc\BaseCAMarshaler.uex' path='docs/doc[@for="BaseCAMarshaler.Count"]/*' />
        /// <devdoc>
        ///     Returns the count of items that will be or have been
        ///     marshaled.
        /// </devdoc>
        public int Count {
            get {
                return count;
            }
        }



        /// <include file='doc\BaseCAMarshaler.uex' path='docs/doc[@for="BaseCAMarshaler.Items"]/*' />
        /// <devdoc>
        ///     The marshaled items.
        /// </devdoc>
        public virtual object[] Items {
            get {
                try {
                    if (itemArray == null) {
                        itemArray = Get_Items();
                    }
                }
                catch (Exception ex) {
                    Debug.WriteLineIf(CAMarshalSwitch.TraceVerbose, "Marshaling failed: " + ex.GetType().Name + ", " + ex.Message);
                }
#if DEBUG
                if (itemArray != null) {
                    Debug.WriteLineIf(CAMarshalSwitch.TraceVerbose, "Marshaled: " + itemArray.Length.ToString() + " items, array type=" + itemArray.GetType().Name);
                }
#endif
                return itemArray;
            }
        }


        /// <include file='doc\BaseCAMarshaler.uex' path='docs/doc[@for="BaseCAMarshaler.GetItemFromAddress"]/*' />
        /// <devdoc>
        ///     Override this member to perform marshalling of a single item
        ///     given it's native address.
        /// </devdoc>
        protected abstract object GetItemFromAddress(IntPtr addr);

        // Retrieve the items
        private object[] Get_Items() {
            // cycle through the addresses and get an item for each addr
            IntPtr addr;
            Array items = new object[Count]; //cpb vs38262 System.Array.CreateInstance(this.ItemType,count);
            object curItem;
            for (int i = 0; i < count; i++) {
                try {
                    addr = Marshal.ReadIntPtr(caArrayAddress, i * IntPtr.Size);
                    curItem = GetItemFromAddress(addr);
                    if (curItem != null && ItemType.IsInstanceOfType(curItem)) {
                        items.SetValue(curItem, i);
                    }
                    Debug.WriteLineIf(CAMarshalSwitch.TraceVerbose, "Marshaled " + ItemType.Name + " item, value=" + (curItem == null ? "(null)" : curItem.ToString()));
                }
                catch (Exception ex) {
                    Debug.WriteLineIf(CAMarshalSwitch.TraceVerbose, "Failed to marshal " + ItemType.Name + " item, exception=" + ex.GetType().Name +", " +ex.Message);
                }
            }
            // free the array
            Marshal.FreeCoTaskMem(caArrayAddress);
            caArrayAddress = IntPtr.Zero;
            return(object[])items;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\componentmodel\com2interop\com2aboutboxpropertydescriptor.cs ===
//------------------------------------------------------------------------------
// <copyright file="COM2AboutBoxPropertyDescriptor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms.ComponentModel.Com2Interop {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Windows.Forms;
    using System.ComponentModel.Design;    
    using Microsoft.Win32;
    using System.Collections;
    using System.Drawing.Design;
    using System.Windows.Forms.Design;
    
    internal class Com2AboutBoxPropertyDescriptor : Com2PropertyDescriptor {
        private TypeConverter converter;
        private UITypeEditor  editor;
    
        public Com2AboutBoxPropertyDescriptor() : base(NativeMethods.ActiveX.DISPID_ABOUTBOX, "About", new Attribute[]{new DispIdAttribute(NativeMethods.ActiveX.DISPID_ABOUTBOX), 
                                                                                      DesignerSerializationVisibilityAttribute.Hidden, 
                                                                                      new DescriptionAttribute(SR.GetString(SR.AboutBoxDesc)), 
                                                                                      new ParenthesizePropertyNameAttribute(true)}, true, typeof(string), null, false) {
        }
    
        /// <include file='doc\COM2AboutBoxPropertyDescriptor.uex' path='docs/doc[@for="Com2AboutBoxPropertyDescriptor.ComponentType"]/*' />
        /// <devdoc>
        ///     Retrieves the type of the component this PropertyDescriptor is bound to.
        /// </devdoc>
        public override Type ComponentType {
            get {
               return typeof(UnsafeNativeMethods.IDispatch);
            }
        }
        
        
        /// <include file='doc\COM2AboutBoxPropertyDescriptor.uex' path='docs/doc[@for="Com2AboutBoxPropertyDescriptor.Converter"]/*' />
        /// <devdoc>
        ///      Retrieves the type converter for this property.
        /// </devdoc>
        public override TypeConverter Converter {
            get {
                if (converter == null) {
                    converter = new TypeConverter();
                }       
                return converter;
            }
        }
        /// <include file='doc\COM2AboutBoxPropertyDescriptor.uex' path='docs/doc[@for="Com2AboutBoxPropertyDescriptor.IsReadOnly"]/*' />
        /// <devdoc>
        ///     Indicates whether this property is read only.
        /// </devdoc>
        public override bool IsReadOnly { 
            get {
               return true;
            }
        }

        /// <include file='doc\COM2AboutBoxPropertyDescriptor.uex' path='docs/doc[@for="Com2AboutBoxPropertyDescriptor.PropertyType"]/*' />
        /// <devdoc>
        ///     Retrieves the type of the property.
        /// </devdoc>
        public override Type PropertyType {
            get {
               return typeof(string);
            }
        }
        
        /// <include file='doc\COM2AboutBoxPropertyDescriptor.uex' path='docs/doc[@for="Com2AboutBoxPropertyDescriptor.CanResetValue"]/*' />
        /// <devdoc>
        ///     Indicates whether reset will change the value of the component.  If there
        ///     is a DefaultValueAttribute, then this will return true if getValue returns
        ///     something different than the default value.  If there is a reset method and
        ///     a shouldPersist method, this will return what shouldPersist returns.
        ///     If there is just a reset method, this always returns true.  If none of these
        ///     cases apply, this returns false.
        /// </devdoc>
        public override bool CanResetValue(object component) {
            return false;
        }
    
        /// <include file='doc\COM2AboutBoxPropertyDescriptor.uex' path='docs/doc[@for="Com2AboutBoxPropertyDescriptor.GetEditor"]/*' />
        /// <devdoc>
        ///      Retrieves an editor of the requested type.
        /// </devdoc>
        public override object GetEditor(Type editorBaseType) {
            if (editorBaseType == typeof(UITypeEditor)) {
                if (editor == null) {
                    editor = new AboutBoxUITypeEditor();
                }
            }
            
            return editor;
        }

        /// <include file='doc\COM2AboutBoxPropertyDescriptor.uex' path='docs/doc[@for="Com2AboutBoxPropertyDescriptor.GetValue"]/*' />
        /// <devdoc>
        ///     Retrieves the current value of the property on component,
        ///     invoking the getXXX method.  An exception in the getXXX
        ///     method will pass through.
        /// </devdoc>
        public override object GetValue(object component) {
            return "";
        }

        /// <include file='doc\COM2AboutBoxPropertyDescriptor.uex' path='docs/doc[@for="Com2AboutBoxPropertyDescriptor.ResetValue"]/*' />
        /// <devdoc>
        ///     Will reset the default value for this property on the component.  If
        ///     there was a default value passed in as a DefaultValueAttribute, that
        ///     value will be set as the value of the property on the component.  If
        ///     there was no default value passed in, a ResetXXX method will be looked
        ///     for.  If one is found, it will be invoked.  If one is not found, this
        ///     is a nop.
        /// </devdoc>
        public override void ResetValue(object component){
        }

        /// <include file='doc\COM2AboutBoxPropertyDescriptor.uex' path='docs/doc[@for="Com2AboutBoxPropertyDescriptor.SetValue"]/*' />
        /// <devdoc>
        ///     This will set value to be the new value of this property on the
        ///     component by invoking the setXXX method on the component.  If the
        ///     value specified is invalid, the component should throw an exception
        ///     which will be passed up.  The component designer should design the
        ///     property so that getXXX following a setXXX should return the value
        ///     passed in if no exception was thrown in the setXXX call.
        /// </devdoc>
        public override void SetValue(object component, object value) {
            throw new ArgumentException();
        }

        /// <include file='doc\COM2AboutBoxPropertyDescriptor.uex' path='docs/doc[@for="Com2AboutBoxPropertyDescriptor.ShouldSerializeValue"]/*' />
        /// <devdoc>
        ///     Indicates whether the value of this property needs to be persisted. In
        ///     other words, it indicates whether the state of the property is distinct
        ///     from when the component is first instantiated. If there is a default
        ///     value specified in this PropertyDescriptor, it will be compared against the
        ///     property's current value to determine this.  If there is't, the
        ///     shouldPersistXXX method is looked for and invoked if found.  If both
        ///     these routes fail, true will be returned.
        ///
        ///     If this returns false, a tool should not persist this property's value.
        /// </devdoc>
        public override bool ShouldSerializeValue(object component) {
            return false;
        }
        
        public class AboutBoxUITypeEditor : UITypeEditor {
            /// <include file='doc\COM2AboutBoxPropertyDescriptor.uex' path='docs/doc[@for="Com2AboutBoxPropertyDescriptor.AboutBoxUITypeEditor.EditValue"]/*' />
            /// <devdoc>
            ///      Edits the given object value using the editor style provided by
            ///      GetEditorStyle.  A service provider is provided so that any
            ///      required editing services can be obtained.
            /// </devdoc>
            public override object EditValue(ITypeDescriptorContext context, IServiceProvider provider, object value) {
                     object component = context.Instance;
                     
                     if (Marshal.IsComObject(component) && component is UnsafeNativeMethods.IDispatch) {
                        UnsafeNativeMethods.IDispatch pDisp = (UnsafeNativeMethods.IDispatch)component;
                        NativeMethods.tagEXCEPINFO pExcepInfo = new NativeMethods.tagEXCEPINFO();
                        Guid g = Guid.Empty;
            
                        int hr = pDisp.Invoke(NativeMethods.ActiveX.DISPID_ABOUTBOX,
                                              ref g,
                                              SafeNativeMethods.GetThreadLCID(),
                                              NativeMethods.DISPATCH_METHOD,
                                              new NativeMethods.tagDISPPARAMS(),
                                              null,
                                              pExcepInfo, null);
                                              
                        Debug.Assert(NativeMethods.Succeeded(hr), "Failed to launch about box.");
                     }
                     return value;
            }
            
            /// <include file='doc\COM2AboutBoxPropertyDescriptor.uex' path='docs/doc[@for="Com2AboutBoxPropertyDescriptor.AboutBoxUITypeEditor.GetEditStyle"]/*' />
            /// <devdoc>
            ///      Retrieves the editing style of the Edit method.  If the method
            ///      is not supported, this will return None.
            /// </devdoc>
            public override UITypeEditorEditStyle GetEditStyle(ITypeDescriptorContext context) {
                     return UITypeEditorEditStyle.Modal;
            }

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\winformsutils.cs ===
//------------------------------------------------------------------------------
// <copyright file="WinFormsUtils.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;
    using System.Security.Permissions;
    using System.Globalization;
    using System.Windows.Forms;
    using System.Drawing.Design;
    using System.ComponentModel;
    using System.Windows.Forms.ComponentModel;
    using System.Collections;
    using System.Drawing;
    using Microsoft.Win32;
    using System.Text;
    using Util = NativeMethods.Util;

    // Miscellaneous Windows Forms utilities
    internal class WindowsFormsUtils {

        // To enumerate over only part of an array.
        public class ArraySubsetEnumerator : IEnumerator {
            private object[] array; // Perhaps this should really be typed Array, but then we suffer a performance penalty.
            private int total;
            private int current;

            public ArraySubsetEnumerator(object[] array, int count) {
                Debug.Assert(count == 0 || array != null, "if array is null, count should be 0");
                Debug.Assert(array == null || count <= array.Length, "Trying to enumerate more than the array contains");
                this.array = array;
                this.total = count;
                current = -1;
            }

            public bool MoveNext() {
                if (current < total - 1) {
                    current++;
                    return true;
                }
                else
                    return false;
            }

            public void Reset() {
                current = -1;
            }

            public object Current {
                get {
                    if (current == -1)
                        return null;
                    else
                        return array[current];
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\winformssecurity.cs ===
//------------------------------------------------------------------------------
// <copyright file="WinFormsSecurity.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms {

    using System.Diagnostics;
    using System;
    using System.IO;
    using System.Security.Permissions;
    using System.Security;
    using System.Drawing.Printing;

    internal class IntSecurity {
        public static readonly TraceSwitch SecurityDemand = new TraceSwitch("SecurityDemand", "Trace when security demands occur.");
#if DEBUG
        public static readonly BooleanSwitch MapSafeTopLevelToSafeSub = new BooleanSwitch("MapSafeTopLevelToSafeSub", "Maps the SafeTopLevelWindow UI permission to SafeSubWindow permission. Must restart to take effect.");
#endif        

        private static CodeAccessPermission adjustCursorClip;
        private static CodeAccessPermission affectThreadBehavior;
        private static CodeAccessPermission allPrinting;
        private static PermissionSet        allPrintingAndUnmanagedCode; // Can't assert twice in the same method
        private static CodeAccessPermission allWindows;
        private static CodeAccessPermission clipboardRead;
        private static CodeAccessPermission changeWindowRegionForTopLevel;
        private static CodeAccessPermission controlFromHandleOrLocation;
        private static CodeAccessPermission createAnyWindow;
        private static CodeAccessPermission createGraphicsForControl;
        private static CodeAccessPermission defaultPrinting;
        private static CodeAccessPermission fileDialogCustomization;
        private static CodeAccessPermission fileDialogOpenFile;
        private static CodeAccessPermission fileDialogSaveFile;
        private static CodeAccessPermission getCapture;
        private static CodeAccessPermission getParent;
        private static CodeAccessPermission manipulateWndProcAndHandles;
        private static CodeAccessPermission minimizeWindowProgramatically;
        private static CodeAccessPermission modifyCursor;
        private static CodeAccessPermission modifyFocus;
        private static CodeAccessPermission noPrinting;
        private static CodeAccessPermission objectFromWin32Handle;
        private static CodeAccessPermission safePrinting;
        private static CodeAccessPermission safeSubWindows;
        private static CodeAccessPermission safeTopLevelWindows;
        private static CodeAccessPermission sendMessages;
        private static CodeAccessPermission sensitiveSystemInformation;
        private static CodeAccessPermission screenDC;
        private static CodeAccessPermission transparentWindows;
        private static CodeAccessPermission topLevelWindow;
        private static CodeAccessPermission topMostWindow;
        private static CodeAccessPermission unmanagedCode;
        private static CodeAccessPermission unrestrictedEnvironment;
        private static CodeAccessPermission unrestrictedWindows;
        private static CodeAccessPermission win32HandleManipulation;
        private static CodeAccessPermission windowAdornmentModification;

          
        //        
        // Property accessors for permissions.  Don't allocate permissions up front -- always
        // demand create them.  A great many codepaths never need all these permissions so it is wasteful to
        // create them.
        //
        
        
        public static CodeAccessPermission AdjustCursorClip { 
            get { 
                if (adjustCursorClip == null) {
                    adjustCursorClip = AllWindows;
                }
                return adjustCursorClip;
            } 
        }
        
        public static CodeAccessPermission AdjustCursorPosition { 
            get { 
                return AllWindows;
            } 
        }
        
        public static CodeAccessPermission AffectThreadBehavior {
            get { 
                if (affectThreadBehavior == null) {
                    affectThreadBehavior = UnmanagedCode;
                }
                return affectThreadBehavior;
            } 
        }
        
        public static CodeAccessPermission AllPrinting {
            get { 
                if (allPrinting == null) {
                    allPrinting = new PrintingPermission(PrintingPermissionLevel.AllPrinting);
                }
                return allPrinting;
            } 
        }
        
        public static PermissionSet AllPrintingAndUnmanagedCode { // Can't assert twice in the same method. See ASURT 52788.
            get {
                if (allPrintingAndUnmanagedCode == null) {
                    PermissionSet temp = new PermissionSet(PermissionState.None);
                    temp.SetPermission(IntSecurity.UnmanagedCode);
                    temp.SetPermission(IntSecurity.AllPrinting);
                    allPrintingAndUnmanagedCode = temp;
                }
                return allPrintingAndUnmanagedCode;
            } 
        }
        
        public static CodeAccessPermission AllWindows {
            get { 
                if (allWindows == null) {
                    allWindows = new UIPermission(UIPermissionWindow.AllWindows);
                }
                return allWindows;
            } 
        }
        
        public static CodeAccessPermission ClipboardRead {
            get { 
                if (clipboardRead == null) {
                    clipboardRead = new UIPermission(UIPermissionClipboard.AllClipboard);
                }
                return clipboardRead;
            } 
        }
        
        public static CodeAccessPermission ChangeWindowRegionForTopLevel {
            get { 
                if (changeWindowRegionForTopLevel == null) {
                    changeWindowRegionForTopLevel = AllWindows;
                }
                return changeWindowRegionForTopLevel;
            } 
        }
        
        public static CodeAccessPermission ControlFromHandleOrLocation {
            get { 
                if (controlFromHandleOrLocation == null) {
                    controlFromHandleOrLocation = AllWindows;
                }
                return controlFromHandleOrLocation;
            } 
        }
        
        public static CodeAccessPermission CreateAnyWindow {
            get { 
                if (createAnyWindow == null) {
                    createAnyWindow = SafeSubWindows;
                }
                return createAnyWindow;
            } 
        }
        
        public static CodeAccessPermission CreateGraphicsForControl {
            get { 
                if (createGraphicsForControl == null) {
                    createGraphicsForControl = SafeSubWindows;
                }
                return createGraphicsForControl;
            } 
        }
        
        public static CodeAccessPermission DefaultPrinting {
            get { 
                if (defaultPrinting == null) {
                    defaultPrinting = new PrintingPermission(PrintingPermissionLevel.DefaultPrinting);
                }
                return defaultPrinting;
            } 
        }
        
        public static CodeAccessPermission FileDialogCustomization {
            get { 
                if (fileDialogCustomization == null) {
                    fileDialogCustomization = new FileIOPermission(PermissionState.Unrestricted);
                }
                return fileDialogCustomization;
            } 
        }
        
        public static CodeAccessPermission FileDialogOpenFile {
            get { 
                if (fileDialogOpenFile == null) {
                    fileDialogOpenFile = new FileDialogPermission(FileDialogPermissionAccess.Open);
                }
                return fileDialogOpenFile;
            } 
        }
        
        public static CodeAccessPermission FileDialogSaveFile {
            get { 
                if (fileDialogSaveFile == null) {
                    fileDialogSaveFile = new FileDialogPermission(FileDialogPermissionAccess.Save);
                }
                return fileDialogSaveFile;
            } 
        }
        
        public static CodeAccessPermission GetCapture {
            get { 
                if (getCapture == null) {
                    getCapture = AllWindows;
                }
                return getCapture;
            } 
        }
        
        public static CodeAccessPermission GetParent {
            get { 
                if (getParent == null) {
                    getParent = AllWindows;
                }
                return getParent;
            } 
        }
        
        public static CodeAccessPermission ManipulateWndProcAndHandles {
            get { 
                if (manipulateWndProcAndHandles == null) {
                    manipulateWndProcAndHandles = AllWindows;
                }
                return manipulateWndProcAndHandles;
            } 
        }
        
        public static CodeAccessPermission MinimizeWindowProgramatically {
            get { 
                if (minimizeWindowProgramatically == null) {
                    minimizeWindowProgramatically = AllWindows;
                }
                return minimizeWindowProgramatically;
            } 
        }
        
        public static CodeAccessPermission ModifyCursor {
            get { 
                if (modifyCursor == null) {
                    modifyCursor = SafeSubWindows;
                }
                return modifyCursor;
            } 
        }
        
        public static CodeAccessPermission ModifyFocus {
            get { 
                if (modifyFocus == null) {
                    modifyFocus = AllWindows;
                }
                return modifyFocus;
            } 
        }
        
        public static CodeAccessPermission NoPrinting {
            get { 
                if (noPrinting == null) {
                    noPrinting = new PrintingPermission(PrintingPermissionLevel.NoPrinting);
                }
                return noPrinting;
            } 
        }
        
        public static CodeAccessPermission ObjectFromWin32Handle {
            get { 
                if (objectFromWin32Handle == null) {
                    objectFromWin32Handle = UnmanagedCode;
                }
                return objectFromWin32Handle;
            } 
        }
        
        public static CodeAccessPermission SafePrinting {
            get { 
                if (safePrinting == null) {
                    safePrinting = new PrintingPermission(PrintingPermissionLevel.SafePrinting);
                }
                return safePrinting;
            } 
        }
        
        public static CodeAccessPermission SafeSubWindows {
            get { 
                if (safeSubWindows == null) {
                    safeSubWindows = new UIPermission(UIPermissionWindow.SafeSubWindows);
                }
                return safeSubWindows;
            } 
        }
        
        public static CodeAccessPermission SafeTopLevelWindows {
            get { 
                if (safeTopLevelWindows == null) {
                    safeTopLevelWindows = new UIPermission(UIPermissionWindow.SafeTopLevelWindows);
                }
                return safeTopLevelWindows;
            } 
        }
        
        public static CodeAccessPermission SendMessages {
            get { 
                if (sendMessages == null) {
                    sendMessages = AllWindows;
                }
                return sendMessages;
            } 
        }
        
        public static CodeAccessPermission SensitiveSystemInformation {
            get { 
                if (sensitiveSystemInformation == null) {
                    sensitiveSystemInformation = new EnvironmentPermission(PermissionState.Unrestricted);
                }
                return sensitiveSystemInformation;
            } 
        }
        
        public static CodeAccessPermission ScreenDC {
            get { 
                if (screenDC == null) {
                    screenDC = AllWindows;
                }
                return screenDC;
            } 
        }
        
        public static CodeAccessPermission TransparentWindows {
            get { 
                if (transparentWindows == null) {
                    transparentWindows = AllWindows;
                }
                return transparentWindows;
            } 
        }
        
        public static CodeAccessPermission TopLevelWindow {
            get { 
                if (topLevelWindow == null) {
                    topLevelWindow = SafeTopLevelWindows;
                }
                return topLevelWindow;
            } 
        }
        
        public static CodeAccessPermission TopMostWindow {
            get { 
                if (topMostWindow == null) {
                    topMostWindow = AllWindows;
                }
                return topMostWindow;
            } 
        }
        
        public static CodeAccessPermission UnmanagedCode {
            get { 
                if (unmanagedCode == null) {
                    unmanagedCode = new SecurityPermission(SecurityPermissionFlag.UnmanagedCode);
                }
                return unmanagedCode;
            } 
        }
        
        public static CodeAccessPermission UnrestrictedEnvironment {
            get { 
                if (unrestrictedEnvironment == null) {
                    unrestrictedEnvironment = new EnvironmentPermission(PermissionState.Unrestricted);
                }
                return unrestrictedEnvironment;
            } 
        }
        
        public static CodeAccessPermission UnrestrictedWindows {
            get { 
                if (unrestrictedWindows == null) {
                    unrestrictedWindows = AllWindows;
                }
                return unrestrictedWindows;
            } 
        }
        
        public static CodeAccessPermission Win32HandleManipulation {
            get { 
                if (win32HandleManipulation == null) {
                    win32HandleManipulation = UnmanagedCode;
                }
                return win32HandleManipulation;
            } 
        }
        
        public static CodeAccessPermission WindowAdornmentModification {
            get { 
                if (windowAdornmentModification == null) {
                    windowAdornmentModification = AllWindows;
                }
                return windowAdornmentModification;
            } 
        }

        internal static string UnsafeGetFullPath(string fileName) {
            string full = fileName;

            FileIOPermission fiop = new FileIOPermission( PermissionState.None );
            fiop.AllFiles = FileIOPermissionAccess.PathDiscovery;
            fiop.Assert();
            try {
                full = Path.GetFullPath(fileName);
            }
            finally {
                CodeAccessPermission.RevertAssert();
            }
            return full;
        }

        internal static void DemandFileIO(FileIOPermissionAccess access, string fileName) {
            new FileIOPermission(access, UnsafeGetFullPath(fileName)).Demand();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\componentmodel\com2interop\com2enum.cs ===
//------------------------------------------------------------------------------
// <copyright file="COM2Enum.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms.ComponentModel.Com2Interop {
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Windows.Forms;    
    using System.Collections;
    using Microsoft.Win32;
    using System.Globalization;

    /// <include file='doc\COM2Enum.uex' path='docs/doc[@for="Com2Enum"]/*' />
    /// <devdoc>
    /// This class mimics a clr enum that we can create at runtime.
    /// It associates an array of names with an array of values and converts
    /// between them.
    ///
    /// A note here: we compare string values when looking for the value of an item.
    /// Typically these aren't large lists and the perf is worth it.  The reason stems
    /// from IPerPropertyBrowsing, which supplies a list of names and a list of
    /// variants to mimic enum functionality.  If the actual property value is a DWORD,
    /// which translates to VT_UI4, and they specify their values as VT_I4 (which is a common
    /// mistake), they won't compare properly and values can't be updated.
    /// By comparing strings, we avoid this problem and add flexiblity to the system.
    /// </devdoc>
    internal class Com2Enum {

        /// <include file='doc\COM2Enum.uex' path='docs/doc[@for="Com2Enum.names"]/*' />
        /// <devdoc>
        /// Our array of value string names
        /// </devdoc>
        private string[] names;


        /// <include file='doc\COM2Enum.uex' path='docs/doc[@for="Com2Enum.values"]/*' />
        /// <devdoc>
        /// Our values
        /// </devdoc>
        private object[] values;



        /// <include file='doc\COM2Enum.uex' path='docs/doc[@for="Com2Enum.stringValues"]/*' />
        /// <devdoc>
        /// Our cached array of value.ToString()'s
        /// </devdoc>
        private string[] stringValues;

        /// <include file='doc\COM2Enum.uex' path='docs/doc[@for="Com2Enum.allowUnknownValues"]/*' />
        /// <devdoc>
        /// Should we allow values besides what's in the listbox?
        /// </devdoc>
        private bool    allowUnknownValues;

        /// <include file='doc\COM2Enum.uex' path='docs/doc[@for="Com2Enum.Com2Enum"]/*' />
        /// <devdoc>
        /// Our one and only ctor
        /// </devdoc>
        public Com2Enum(string[] names, object[] values) : this(names, values, false) {
        }

        /// <include file='doc\COM2Enum.uex' path='docs/doc[@for="Com2Enum.Com2Enum1"]/*' />
        /// <devdoc>
        /// Our one and only ctor
        /// </devdoc>
        public Com2Enum(string[] names, object[] values, bool allowUnknownValues) {

            this.allowUnknownValues = allowUnknownValues;

            // these have to be null and the same length
            if (names == null ||
                values == null ||
                names.Length != values.Length) {
                throw new ArgumentException(SR.GetString(SR.COM2NamesAndValuesNotEqual));
            }

            PopulateArrays(names, values);
        }

        /// <include file='doc\COM2Enum.uex' path='docs/doc[@for="Com2Enum.IsStrictEnum"]/*' />
        /// <devdoc>
        /// Can this enum be values other than the strict enum?
        /// </devdoc>
        public bool IsStrictEnum {
            get {
                return !this.allowUnknownValues;
            }
        }

        /// <include file='doc\COM2Enum.uex' path='docs/doc[@for="Com2Enum.Values"]/*' />
        /// <devdoc>
        /// Retrieve a copy of the value array
        /// </devdoc>
        public virtual object[] Values {
            get {
                return(object[])this.values.Clone();
            }
        }

        /// <include file='doc\COM2Enum.uex' path='docs/doc[@for="Com2Enum.Names"]/*' />
        /// <devdoc>
        /// Retrieve a copy of the nme array.
        /// </devdoc>
        public virtual string[] Names {
            get {
                return(string[])this.names.Clone();
            }
        }

        /// <include file='doc\COM2Enum.uex' path='docs/doc[@for="Com2Enum.FromString"]/*' />
        /// <devdoc>
        /// Associate a string to the appropriate value.
        /// </devdoc>
        public virtual object FromString(string s) {
            int bestMatch = -1;
        
            for (int i = 0; i < stringValues.Length; i++) {
                if (String.Compare(names[i], s, true, CultureInfo.InvariantCulture) == 0 ||
                    String.Compare(stringValues[i], s, true, CultureInfo.InvariantCulture) == 0) {
                    return values[i];
                }
                
                if (bestMatch == -1 && 0 == String.Compare(names[i], s, true, CultureInfo.InvariantCulture)) {
                    bestMatch = i;
                }
            }
            
            if (bestMatch != -1) {
                return values[bestMatch];    
            }
            
            return allowUnknownValues ? s : null;
        }

        protected virtual void PopulateArrays(string[] names, object[] values) {
            // setup our values...since we have to walk through
            // them anyway to do the ToString, we just copy them here.
            this.names = new string[names.Length];
            this.stringValues = new string[names.Length];
            this.values = new object[names.Length];
            for (int i = 0; i < names.Length; i++) {
                //Debug.WriteLine(names[i] + ": item " + i.ToString() + ",type=" + values[i].GetType().Name + ", value=" + values[i].ToString());
                this.names[i] = names[i];
                this.values[i] = values[i];
                this.stringValues[i] = values[i].ToString();
            }
        }

        /// <include file='doc\COM2Enum.uex' path='docs/doc[@for="Com2Enum.ToString"]/*' />
        /// <devdoc>
        /// Retrieves the string name of a given value.
        /// </devdoc>
        public virtual string ToString(object v) {
            if (v != null) {

                // in case this is a real enum...try to convert it.
                //
                if (values.Length > 0 && v.GetType() != values[0].GetType()) {
                    try {
                        v = Convert.ChangeType(v, values[0].GetType());
                    }
                    catch{
                    }
                }

                // we have to do this do compensate for small discrpencies
                // in a lot of objects in COM2 (DWORD -> VT_IU4, value we get is VT_I4, which
                // convert to Int32, UInt32 respectively
                string strVal = v.ToString();
                for (int i = 0; i < values.Length; i++) {
                    if (String.Compare(stringValues[i], strVal, true, CultureInfo.InvariantCulture) == 0) {
                        return names[i];
                    }
                }
                if (allowUnknownValues) {
                    return strVal;
                }
            }
            return "";
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\componentmodel\com2interop\com2datatypetomanageddatatypeconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="COM2DataTypeToManagedDataTypeConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms.ComponentModel.Com2Interop {
    using System.Runtime.Serialization.Formatters;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Windows.Forms;
    using System.Drawing;
    using System.ComponentModel.Design;    
    using System.Collections;
    using Hashtable = System.Collections.Hashtable;
    using Microsoft.Win32;

    /// <include file='doc\COM2DataTypeToManagedDataTypeConverter.uex' path='docs/doc[@for="Com2DataTypeToManagedDataTypeConverter"]/*' />
    /// <devdoc>
    /// This base class maps an ole defined data type (OLE_COLOR, IFont, etc.),
    ///
    /// </devdoc>
    internal abstract class Com2DataTypeToManagedDataTypeConverter{


         public virtual bool AllowExpand {
             get {
                 return false;
             }
         }

         /// <include file='doc\COM2DataTypeToManagedDataTypeConverter.uex' path='docs/doc[@for="Com2DataTypeToManagedDataTypeConverter.ManagedType"]/*' />
         /// <devdoc>
         ///     Returns the managed type that this editor maps the property type to.
         /// </devdoc>
         public abstract Type ManagedType{
            get;
         }

         /// <include file='doc\COM2DataTypeToManagedDataTypeConverter.uex' path='docs/doc[@for="Com2DataTypeToManagedDataTypeConverter.ConvertNativeToManaged"]/*' />
         /// <devdoc>
         ///     Converts the native value into a managed value
         /// </devdoc>
         public abstract object ConvertNativeToManaged(object nativeValue, Com2PropertyDescriptor pd);

         /// <include file='doc\COM2DataTypeToManagedDataTypeConverter.uex' path='docs/doc[@for="Com2DataTypeToManagedDataTypeConverter.ConvertManagedToNative"]/*' />
         /// <devdoc>
         ///     Converts the managed value into a native value
         /// </devdoc>
         public abstract object ConvertManagedToNative(object managedValue, Com2PropertyDescriptor pd, ref bool cancelSet);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\componentmodel\com2interop\com2componenteditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="COM2ComponentEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms.ComponentModel.Com2Interop {
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;    
    using System.Windows.Forms;
    using System.Windows.Forms.Design;    
    using System.Collections;
    using Microsoft.Win32;

    internal class Com2ComponentEditor : WindowsFormsComponentEditor {
    
        public static bool NeedsComponentEditor(object obj) {
            if (obj is NativeMethods.IPerPropertyBrowsing) {
                 // check for a property page
                 Guid guid = Guid.Empty;
                 int hr = ((NativeMethods.IPerPropertyBrowsing)obj).MapPropertyToPage(NativeMethods.MEMBERID_NIL, out guid);
                 if ((hr == NativeMethods.S_OK) && !guid.Equals(Guid.Empty)) {
                     return true;
                 }
            }
            
            if (obj is NativeMethods.ISpecifyPropertyPages) {
                 try {
                    NativeMethods.tagCAUUID uuids = new NativeMethods.tagCAUUID();
                    try {
                        ((NativeMethods.ISpecifyPropertyPages)obj).GetPages(uuids);
                        if (uuids.cElems > 0) {
                           return true;
                        }
                    }
                    finally {
                        if (uuids.pElems != IntPtr.Zero) {
                            Marshal.FreeCoTaskMem(uuids.pElems);
                        }
                    }
                 }
                 catch (Exception) {
                 }
                 
                 return false;
            }
            return false;
        }
    
        public override bool EditComponent(ITypeDescriptorContext context, object obj, IWin32Window parent) {
        
                IntPtr handle = (parent == null ? IntPtr.Zero : parent.Handle);
        
                // try to get the page guid
                if (obj is NativeMethods.IPerPropertyBrowsing) {
                    // check for a property page
                    Guid guid = Guid.Empty;
                    int hr = ((NativeMethods.IPerPropertyBrowsing)obj).MapPropertyToPage(NativeMethods.MEMBERID_NIL, out guid);
                    if (hr == NativeMethods.S_OK) {
                        if (!guid.Equals(Guid.Empty)) {
                            object o = obj;
                            SafeNativeMethods.OleCreatePropertyFrame(new HandleRef(parent, handle), 0, 0, "PropertyPages", 1, ref o, 1, new Guid[]{guid}, Application.CurrentCulture.LCID, 0, IntPtr.Zero);
                            return true;
                        }
                    }
                } 
                
                if (obj is NativeMethods.ISpecifyPropertyPages) {
                    try {
                       NativeMethods.tagCAUUID uuids = new NativeMethods.tagCAUUID();
                       try {
                           ((NativeMethods.ISpecifyPropertyPages)obj).GetPages(uuids);
                           if (uuids.cElems <= 0) {
                               return false;
                           }
                       }
                       catch (Exception) {
                           return false;
                       }
                       try {
                           object o = obj;
                           SafeNativeMethods.OleCreatePropertyFrame(new HandleRef(parent, handle), 0, 0, "PropertyPages", 1, ref o, uuids.cElems, new HandleRef(uuids, uuids.pElems), Application.CurrentCulture.LCID, 0, IntPtr.Zero);
                           return true;
                       }
                       finally {
                           if (uuids.pElems != IntPtr.Zero) {
                               Marshal.FreeCoTaskMem(uuids.pElems);
                           }
                       }
                  
                    }
                    catch (Exception ex1) {
                        
                        IUIService uiSvc = null;
                        
                        if (context != null) {
                            uiSvc = (IUIService)context.GetService(typeof(IUIService));
                        }
                        
                        String errString = SR.GetString(SR.ErrorPropertyPageFailed);
                        if (uiSvc != null) {
                            uiSvc.ShowError(ex1, errString);
                        }
                        else {
                            MessageBox.Show(errString, "PropertyGrid");
                        }
                    }
                }
                return false;
            }

    }
    


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\componentmodel\com2interop\com2extendedbrowsinghandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="COM2ExtendedBrowsingHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms.ComponentModel.Com2Interop {
    using System.ComponentModel;

    using System.Diagnostics;
    using System;
    
    /// <include file='doc\COM2ExtendedBrowsingHandler.uex' path='docs/doc[@for="Com2ExtendedBrowsingHandler"]/*' />
    /// <devdoc>
    /// This is the base class for handlers for COM2 extended browsing interface
    /// such as IPerPropertyBrowsing, etc.
    ///
    /// These handlers should be stateless.  That is, they should keep no refs to object
    /// and should only work on a give object and dispid.  That way all objects that
    /// support a give interface can share a handler.
    ///
    /// See COM2Properties for the array of handler classes to interface classes
    /// where handlers should be registered.
    /// </devdoc>
    internal abstract class Com2ExtendedBrowsingHandler{
        
         /// <include file='doc\COM2ExtendedBrowsingHandler.uex' path='docs/doc[@for="Com2ExtendedBrowsingHandler.Interface"]/*' />
         /// <devdoc>
         /// The interface that this handler managers
         /// such as IPerPropertyBrowsing, IProvidePropertyBuilder, etc.
         /// </devdoc>
         public abstract Type Interface{
            get;
         }    
         
         /// <include file='doc\COM2ExtendedBrowsingHandler.uex' path='docs/doc[@for="Com2ExtendedBrowsingHandler.SetupPropertyHandlers"]/*' />
         /// <devdoc>
         /// Called to setup the property handlers on a given property
         /// In this method, the handler will add listeners to the events that
         /// the COM2PropertyDescriptor surfaces that it cares about.
         /// </devdoc>
         public virtual void SetupPropertyHandlers(Com2PropertyDescriptor propDesc){
            SetupPropertyHandlers(new Com2PropertyDescriptor[]{propDesc});
         }
         
         /// <include file='doc\COM2ExtendedBrowsingHandler.uex' path='docs/doc[@for="Com2ExtendedBrowsingHandler.SetupPropertyHandlers1"]/*' />
         /// <devdoc>
         /// Called to setup the property handlers on a given properties
         /// In this method, the handler will add listeners to the events that
         /// the Com2PropertyDescriptor surfaces that it cares about.
         /// </devdoc>
         public abstract void SetupPropertyHandlers(Com2PropertyDescriptor[] propDesc);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\componentmodel\com2interop\com2extendeduitypeeditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="COM2ExtendedUITypeEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------


/*
 */
namespace System.Drawing.Design {

    using System.Diagnostics;

    using System.Collections;
    using Microsoft.Win32;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Drawing;
    using System.Drawing.Design;

    /// <include file='doc\COM2ExtendedUITypeEditor.uex' path='docs/doc[@for="Com2ExtendedUITypeEditor"]/*' />
    /// <internalonly/>
    /// <devdoc>
    ///    <para>Provides an editor that provides a way to visually edit the values of a COM2 
    ///       type.</para>
    /// </devdoc>
    internal class Com2ExtendedUITypeEditor : UITypeEditor {
    
        private UITypeEditor innerEditor;
        
        public Com2ExtendedUITypeEditor(UITypeEditor baseTypeEditor) {
            this.innerEditor = baseTypeEditor;
        }
        
        public Com2ExtendedUITypeEditor(Type baseType) {
            this.innerEditor = (UITypeEditor)TypeDescriptor.GetEditor(baseType, typeof(UITypeEditor));
        }
        
        public UITypeEditor InnerEditor {
            get {
               return innerEditor;
            }
        }
  
        /// <include file='doc\COM2ExtendedUITypeEditor.uex' path='docs/doc[@for="Com2ExtendedUITypeEditor.EditValue"]/*' />
        /// <devdoc>
        ///      Edits the given object value using the editor style provided by
        ///      GetEditorStyle.  A service provider is provided so that any
        ///      required editing services can be obtained.
        /// </devdoc>
        public override object EditValue(ITypeDescriptorContext context, IServiceProvider provider, object value) {
            if (innerEditor != null)  {
               return innerEditor.EditValue(context, provider, value);
            }
            else {
               return base.EditValue(context, provider, value);
            }
        }
  
        /// <include file='doc\COM2ExtendedUITypeEditor.uex' path='docs/doc[@for="Com2ExtendedUITypeEditor.GetPaintValueSupported"]/*' />
        /// <devdoc>
        ///      Determines if this editor supports the painting of a representation
        ///      of an object's value.
        /// </devdoc>
        public override bool GetPaintValueSupported(ITypeDescriptorContext context) {
            if (innerEditor != null) {
               return innerEditor.GetPaintValueSupported(context);
            }
            return base.GetPaintValueSupported(context);
        }

        /// <include file='doc\COM2ExtendedUITypeEditor.uex' path='docs/doc[@for="Com2ExtendedUITypeEditor.GetEditStyle"]/*' />
        /// <devdoc>
        ///      Retrieves the editing style of the Edit method.  If the method
        ///      is not supported, this will return None.
        /// </devdoc>
        public override UITypeEditorEditStyle GetEditStyle(ITypeDescriptorContext context) {
            if (innerEditor != null) {
               return innerEditor.GetEditStyle(context);
            }
            return base.GetEditStyle(context);
        }

        /// <include file='doc\COM2ExtendedUITypeEditor.uex' path='docs/doc[@for="Com2ExtendedUITypeEditor.PaintValue"]/*' />
        /// <devdoc>
        ///      Paints a representative value of the given object to the provided
        ///      canvas.  Painting should be done within the boundaries of the
        ///      provided rectangle.
        /// </devdoc>
        public override void PaintValue(PaintValueEventArgs e) {
            if (innerEditor != null) {
               innerEditor.PaintValue(e);
            }
            base.PaintValue(e);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\componentmodel\com2interop\com2enumconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="COM2EnumConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------


/*
 */
namespace System.Windows.Forms.ComponentModel.Com2Interop {

    using System.Diagnostics;
    using System;
    using System.ComponentModel;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;
    using System.Drawing;
    using System.Collections;
    using Microsoft.Win32;
    using System.Globalization;

    internal class Com2EnumConverter : TypeConverter {

        internal readonly Com2Enum com2Enum;
        private  StandardValuesCollection values;

        public Com2EnumConverter(Com2Enum enumObj) {
            com2Enum = enumObj;
        }
        
        /// <include file='doc\COM2EnumConverter.uex' path='docs/doc[@for="Com2EnumConverter.CanConvertFrom"]/*' />
        /// <devdoc>
        ///      Determines if this converter can convert an object in the given source
        ///      type to the native type of the converter.
        /// </devdoc>
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
            if (sourceType == typeof(string)) {
                return true;
            }
            return base.CanConvertFrom(context, sourceType);
        }

        public override bool CanConvertTo(ITypeDescriptorContext context, Type destType) {
           if (base.CanConvertTo(context, destType)) {
               return true;
           }
           return destType.IsEnum;
       }


        /// <include file='doc\COM2EnumConverter.uex' path='docs/doc[@for="Com2EnumConverter.ConvertFrom"]/*' />
        /// <devdoc>
        ///      Converts the given object to the converter's native type.
        /// </devdoc>
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {
            if (value is string) {
                 return com2Enum.FromString((string)value);
            }
            return base.ConvertFrom(context, culture, value);
        }
    
        /// <include file='doc\COM2EnumConverter.uex' path='docs/doc[@for="Com2EnumConverter.ConvertTo"]/*' />
        /// <devdoc>
        ///      Converts the given object to another type.  The most common types to convert
        ///      are to and from a string object.  The default implementation will make a call
        ///      to ToString on the object if the object is valid and if the destination
        ///      type is string.  If this cannot convert to the desitnation type, this will
        ///      throw a NotSupportedException.
        /// </devdoc>
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == null) {
                throw new ArgumentNullException("destinationType");
            }

            if (destinationType == typeof(string)) {
                if (value != null) {
                    string str = com2Enum.ToString(value);
                    return (str == null ? "" : str);
                }
            }

            if (destinationType.IsEnum) {
                return Enum.ToObject(destinationType, value);
            }
            return base.ConvertTo(context, culture, value, destinationType);
        }
     
        /// <include file='doc\COM2EnumConverter.uex' path='docs/doc[@for="Com2EnumConverter.GetStandardValues"]/*' />
        /// <devdoc>
        ///      Retrieves a collection containing a set of standard values
        ///      for the data type this validator is designed for.  This
        ///      will return null if the data type does not support a
        ///      standard set of values.
        /// </devdoc>
        public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context) {
            if (values == null) {
                object[] objValues = com2Enum.Values;
                if (objValues != null) {
                    values = new StandardValuesCollection(objValues);
                }
            }
            return values;
        }
    
        /// <include file='doc\COM2EnumConverter.uex' path='docs/doc[@for="Com2EnumConverter.GetStandardValuesExclusive"]/*' />
        /// <devdoc>
        ///      Determines if the list of standard values returned from
        ///      GetStandardValues is an exclusive list.  If the list
        ///      is exclusive, then no other values are valid, such as
        ///      in an enum data type.  If the list is not exclusive,
        ///      then there are other valid values besides the list of
        ///      standard values GetStandardValues provides.
        /// </devdoc>
        public override bool GetStandardValuesExclusive(ITypeDescriptorContext context) {
            return com2Enum.IsStrictEnum;
        }
        
        /// <include file='doc\COM2EnumConverter.uex' path='docs/doc[@for="Com2EnumConverter.GetStandardValuesSupported"]/*' />
        /// <devdoc>
        ///      Determines if this object supports a standard set of values
        ///      that can be picked from a list.
        /// </devdoc>
        public override bool GetStandardValuesSupported(ITypeDescriptorContext context) {
            return true;
        }
        
        /// <include file='doc\COM2EnumConverter.uex' path='docs/doc[@for="Com2EnumConverter.IsValid"]/*' />
        /// <devdoc>
        ///      Determines if the given object value is valid for this type.
        /// </devdoc>
        public override bool IsValid(ITypeDescriptorContext context, object value) {
            string strValue = com2Enum.ToString(value);
            return strValue != null && strValue != "";
        }

        public void RefreshValues() {
            this.values = null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\componentmodel\com2interop\com2extendedtypeconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="COM2ExtendedTypeConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms.ComponentModel.Com2Interop {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;
    using System.Drawing;
    using Microsoft.Win32;
    using System.Globalization;
    
    using System.Collections;

    /// <include file='doc\COM2ExtendedTypeConverter.uex' path='docs/doc[@for="Com2ExtendedTypeConverter"]/*' />
    /// <devdoc>
    /// Base class for value editors that extend basic functionality.
    /// calls will be delegated to the "base value editor".
    /// </devdoc>
    internal class Com2ExtendedTypeConverter : TypeConverter {
         private TypeConverter innerConverter;
         
         public Com2ExtendedTypeConverter(TypeConverter innerConverter) {
            this.innerConverter = innerConverter;
         }
         
         public Com2ExtendedTypeConverter(Type baseType) {
            this.innerConverter = TypeDescriptor.GetConverter(baseType);
         }
         
         public TypeConverter InnerConverter {
            get {
               return innerConverter;
            }
         }
         
         public TypeConverter GetWrappedConverter(Type t) {
            
            TypeConverter converter = innerConverter;
            
            while (converter != null) {
                if (t.IsInstanceOfType(converter)) {
                    return converter;
                }
                
                if (converter is Com2ExtendedTypeConverter) {
                    converter = ((Com2ExtendedTypeConverter)converter).InnerConverter;
                }
                else {
                    break;
                }
            }
            return null;
         }
         
         
        /// <include file='doc\COM2ExtendedTypeConverter.uex' path='docs/doc[@for="Com2ExtendedTypeConverter.CanConvertFrom"]/*' />
        /// <devdoc>
        ///      Determines if this converter can convert an object in the given source
        ///      type to the native type of the converter.
        /// </devdoc>
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
            if (innerConverter != null) {
               return innerConverter.CanConvertFrom(context, sourceType);
            }
            return base.CanConvertFrom(context, sourceType);
        }
        
        /// <include file='doc\COM2ExtendedTypeConverter.uex' path='docs/doc[@for="Com2ExtendedTypeConverter.CanConvertTo"]/*' />
        /// <devdoc>
        ///      Determines if this converter can convert an object to the given destination
        ///      type.
        /// </devdoc>
        public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType) {
            if (innerConverter != null) {
               return innerConverter.CanConvertTo(context, destinationType);
            }
            return base.CanConvertTo(context, destinationType);
        }
        
        /// <include file='doc\COM2ExtendedTypeConverter.uex' path='docs/doc[@for="Com2ExtendedTypeConverter.ConvertFrom"]/*' />
        /// <devdoc>
        ///      Converts the given object to the converter's native type.
        /// </devdoc>
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {
            if (innerConverter != null) {
               return innerConverter.ConvertFrom(context, culture, value);
            }
            return base.ConvertFrom(context, culture, value);
        }
        
        /// <include file='doc\COM2ExtendedTypeConverter.uex' path='docs/doc[@for="Com2ExtendedTypeConverter.ConvertTo"]/*' />
        /// <devdoc>
        ///      Converts the given object to another type.  The most common types to convert
        ///      are to and from a string object.  The default implementation will make a call
        ///      to ToString on the object if the object is valid and if the destination
        ///      type is string.  If this cannot convert to the desitnation type, this will
        ///      throw a NotSupportedException.
        /// </devdoc>
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (innerConverter != null) {
               return innerConverter.ConvertTo(context, culture, value, destinationType);
            }
            return base.ConvertTo(context, culture, value, destinationType);
        }
        
        /// <include file='doc\COM2ExtendedTypeConverter.uex' path='docs/doc[@for="Com2ExtendedTypeConverter.CreateInstance"]/*' />
        /// <devdoc>
        ///      Creates an instance of this type given a set of property values
        ///      for the object.  This is useful for objects that are immutable, but still
        ///      want to provide changable properties.
        /// </devdoc>
        public override object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues) {
            if (innerConverter != null) {
               return innerConverter.CreateInstance(context, propertyValues);
            }
            return base.CreateInstance(context, propertyValues);
        }
        
        /// <include file='doc\COM2ExtendedTypeConverter.uex' path='docs/doc[@for="Com2ExtendedTypeConverter.GetCreateInstanceSupported"]/*' />
        /// <devdoc>
        ///      Determines if changing a value on this object should require a call to
        ///      CreateInstance to create a new value.
        /// </devdoc>
        public override bool GetCreateInstanceSupported(ITypeDescriptorContext context) {
            if (innerConverter != null) {
               return innerConverter.GetCreateInstanceSupported(context);
            }
            return base.GetCreateInstanceSupported(context);
        }
        
        /// <include file='doc\COM2ExtendedTypeConverter.uex' path='docs/doc[@for="Com2ExtendedTypeConverter.GetProperties"]/*' />
        /// <devdoc>
        ///      Retrieves the set of properties for this type.  By default, a type has
        ///      does not return any properties.  An easy implementation of this method
        ///      can just call TypeDescriptor.GetProperties for the correct data type.
        /// </devdoc>
        public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes) {      
            if (innerConverter != null) {
               return innerConverter.GetProperties(context, value, attributes);
            }
            return base.GetProperties(context, value, attributes);
        }
        
        /// <include file='doc\COM2ExtendedTypeConverter.uex' path='docs/doc[@for="Com2ExtendedTypeConverter.GetPropertiesSupported"]/*' />
        /// <devdoc>
        ///      Determines if this object supports properties.  By default, this
        ///      is false.
        /// </devdoc>
        public override bool GetPropertiesSupported(ITypeDescriptorContext context) {
            if (innerConverter != null) {
               return innerConverter.GetPropertiesSupported(context);
            }
            return base.GetPropertiesSupported(context);
        }
        
        /// <include file='doc\COM2ExtendedTypeConverter.uex' path='docs/doc[@for="Com2ExtendedTypeConverter.GetStandardValues"]/*' />
        /// <devdoc>
        ///      Retrieves a collection containing a set of standard values
        ///      for the data type this validator is designed for.  This
        ///      will return null if the data type does not support a
        ///      standard set of values.
        /// </devdoc>
        public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context) {
            if (innerConverter != null) {
               return innerConverter.GetStandardValues(context);
            }
            return base.GetStandardValues(context);
        }
        
        /// <include file='doc\COM2ExtendedTypeConverter.uex' path='docs/doc[@for="Com2ExtendedTypeConverter.GetStandardValuesExclusive"]/*' />
        /// <devdoc>
        ///      Determines if the list of standard values returned from
        ///      GetStandardValues is an exclusive list.  If the list
        ///      is exclusive, then no other values are valid, such as
        ///      in an enum data type.  If the list is not exclusive,
        ///      then there are other valid values besides the list of
        ///      standard values GetStandardValues provides.
        /// </devdoc>
        public override bool GetStandardValuesExclusive(ITypeDescriptorContext context) {
            if (innerConverter != null) {
               return innerConverter.GetStandardValuesExclusive(context);
            }
            return base.GetStandardValuesExclusive(context);
        }
        
        /// <include file='doc\COM2ExtendedTypeConverter.uex' path='docs/doc[@for="Com2ExtendedTypeConverter.GetStandardValuesSupported"]/*' />
        /// <devdoc>
        ///      Determines if this object supports a standard set of values
        ///      that can be picked from a list.
        /// </devdoc>
        public override bool GetStandardValuesSupported(ITypeDescriptorContext context) {
            if (innerConverter != null) {
               return innerConverter.GetStandardValuesSupported(context);
            }
            return base.GetStandardValuesSupported(context);
        }
        
        /// <include file='doc\COM2ExtendedTypeConverter.uex' path='docs/doc[@for="Com2ExtendedTypeConverter.IsValid"]/*' />
        /// <devdoc>
        ///      Determines if the given object value is valid for this type.
        /// </devdoc>
        public override bool IsValid(ITypeDescriptorContext context, object value) {
            if (innerConverter != null) {
               return innerConverter.IsValid(context, value);
            }
            return base.IsValid(context, value);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\componentmodel\com2interop\com2fontconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="COM2FontConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------


namespace System.Windows.Forms.ComponentModel.Com2Interop {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;    
    using System.Windows.Forms;
    using System.Drawing;
    using System.Collections;
    using Microsoft.Win32;

    /// <include file='doc\COM2FontConverter.uex' path='docs/doc[@for="Com2FontConverter"]/*' />
    /// <devdoc>
    /// This class maps an OLE_COLOR to a managed Color editor.
    /// </devdoc>
    internal class Com2FontConverter : Com2DataTypeToManagedDataTypeConverter {

        private IntPtr lastHandle = IntPtr.Zero;
        private Font lastFont  = null;

        public override bool AllowExpand {
             get {
                 return true;
             }
         }

        /// <include file='doc\COM2FontConverter.uex' path='docs/doc[@for="Com2FontConverter.ManagedType"]/*' />
        /// <devdoc>
        ///     Returns the managed type that this editor maps the property type to.
        /// </devdoc>
        public override Type ManagedType {
            get {
                return typeof(Font);
            }
        }


        /// <include file='doc\COM2FontConverter.uex' path='docs/doc[@for="Com2FontConverter.ConvertNativeToManaged"]/*' />
        /// <devdoc>
        ///     Converts the native value into a managed value
        /// </devdoc>
        public override object ConvertNativeToManaged(object nativeValue, Com2PropertyDescriptor pd) {
            // we're getting an IFont thing here
            SafeNativeMethods.IFont nativeFont = nativeValue as SafeNativeMethods.IFont;

            if (nativeFont == null) {
                lastHandle = IntPtr.Zero;
                lastFont = Control.DefaultFont;
                return lastFont;
            }

            IntPtr fontHandle = nativeFont.GetHFont();

            // see if we have this guy cached
            if (fontHandle == lastHandle && lastFont != null) {
                return lastFont;
            }

            lastHandle = fontHandle;
            
            try {
                // this wasn't working because it was converting everything to 
                // world units.
                //

                lastFont = ControlPaint.FontInPoints(Font.FromHfont(lastHandle));
            }
            catch(ArgumentException) {
                // we will fail on non-truetype fonts, so 
                // just use the default font.
                lastFont = Control.DefaultFont;
            }
            
            return lastFont;
        }

        /// <include file='doc\COM2FontConverter.uex' path='docs/doc[@for="Com2FontConverter.ConvertManagedToNative"]/*' />
        /// <devdoc>
        ///     Converts the managed value into a native value
        /// </devdoc>
        public override object ConvertManagedToNative(object managedValue, Com2PropertyDescriptor pd, ref bool cancelSet) {

            // we default to black.
            //
            if (managedValue == null) {
                managedValue = Control.DefaultFont;
            }

            cancelSet = true;

            if (lastFont != null && lastFont.Equals(managedValue)) {
                // don't do anything here.
                return null;
            }


            lastFont = (Font)managedValue;
            SafeNativeMethods.IFont nativeFont = (SafeNativeMethods.IFont)pd.GetNativeValue(pd.TargetObject);

            // now, push all the values into the native side
            if (nativeFont != null) {
                bool changed = ControlPaint.FontToIFont(lastFont, nativeFont);

                if (changed) {
                    // here, we want to pick up a new font from the handle
                    lastFont = null;
                    ConvertNativeToManaged(nativeFont, pd);

                }
            }
            return null;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\componentmodel\com2interop\com2icategorizepropertieshandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="COM2ICategorizePropertiesHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms.ComponentModel.Com2Interop {
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Windows.Forms;    
    using System.Collections;
    using Microsoft.Win32;

    [System.Security.SuppressUnmanagedCodeSecurityAttribute()]
    internal class Com2ICategorizePropertiesHandler : Com2ExtendedBrowsingHandler {

        public override Type Interface {
            get {
                return typeof(NativeMethods.ICategorizeProperties);
            }
        }

        private string GetCategoryFromObject(object obj, int dispid) {
            if (obj == null) {
                return null;
            }

            if (obj is NativeMethods.ICategorizeProperties) {
                NativeMethods.ICategorizeProperties catObj = (NativeMethods.ICategorizeProperties)obj;

                try {
                    int categoryID = 0;

                    if (NativeMethods.S_OK == catObj.MapPropertyToCategory(dispid, ref categoryID)) {
                        string categoryName = null;
                        
                        switch (categoryID) {
                            case NativeMethods.ActiveX.PROPCAT_Nil:
                                return "";
                            case NativeMethods.ActiveX.PROPCAT_Misc:
                                return SR.GetString(SR.PropertyCategoryMisc);
                            case NativeMethods.ActiveX.PROPCAT_Font:
                                return SR.GetString(SR.PropertyCategoryFont);
                            case NativeMethods.ActiveX.PROPCAT_Position:
                                return SR.GetString(SR.PropertyCategoryPosition);
                            case NativeMethods.ActiveX.PROPCAT_Appearance:
                                return SR.GetString(SR.PropertyCategoryAppearance);
                            case NativeMethods.ActiveX.PROPCAT_Behavior:
                                return SR.GetString(SR.PropertyCategoryBehavior);
                            case NativeMethods.ActiveX.PROPCAT_Data:
                                return SR.GetString(SR.PropertyCategoryData);
                            case NativeMethods.ActiveX.PROPCAT_List:
                                return SR.GetString(SR.PropertyCategoryList);
                            case NativeMethods.ActiveX.PROPCAT_Text:
                                return SR.GetString(SR.PropertyCategoryText);
                            case NativeMethods.ActiveX.PROPCAT_Scale:
                                return SR.GetString(SR.PropertyCategoryScale);
                            case NativeMethods.ActiveX.PROPCAT_DDE:
                                return SR.GetString(SR.PropertyCategoryDDE);
                        }
                        
                        if (NativeMethods.S_OK == catObj.GetCategoryName(categoryID, SafeNativeMethods.GetUserDefaultLCID(), out categoryName)) {
                            return categoryName;
                        }
                    }
                }
                catch (Exception) {
                }
            }
            return null;
        }

        public override void SetupPropertyHandlers(Com2PropertyDescriptor[] propDesc) {
            if (propDesc == null) {
                return;
            }
            for (int i = 0; i < propDesc.Length; i++) {
                propDesc[i].QueryGetBaseAttributes += new GetAttributesEventHandler(this.OnGetAttributes);
            }
        }

        private void OnGetAttributes(Com2PropertyDescriptor sender, GetAttributesEvent attrEvent) {

            string cat = GetCategoryFromObject(sender.TargetObject, sender.DISPID);

            if (cat != null && cat.Length > 0) {
                attrEvent.Add(new CategoryAttribute(cat));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\componentmodel\com2interop\com2imanagedperpropertybrowsinghandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="COM2IManagedPerPropertyBrowsingHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms.ComponentModel.Com2Interop {
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Reflection;
    using System.Windows.Forms;    
    using Microsoft.Win32;
    using System.Collections;

    [System.Security.SuppressUnmanagedCodeSecurityAttribute()]
    internal class Com2IManagedPerPropertyBrowsingHandler : Com2ExtendedBrowsingHandler {

        public override Type Interface {
            get {
                return typeof(NativeMethods.IManagedPerPropertyBrowsing);
            }
        }

        public override void SetupPropertyHandlers(Com2PropertyDescriptor[] propDesc) {
            if (propDesc == null) {
                return;
            }
            for (int i = 0; i < propDesc.Length; i++) {
                propDesc[i].QueryGetDynamicAttributes += new GetAttributesEventHandler(this.OnGetAttributes);
            }
        }

        /// <include file='doc\COM2IManagedPerPropertyBrowsingHandler.uex' path='docs/doc[@for="Com2IManagedPerPropertyBrowsingHandler.OnGetAttributes"]/*' />
        /// <devdoc>
        /// Here is where we handle IVsPerPropertyBrowsing.GetLocalizedPropertyInfo and IVsPerPropertyBrowsing.   HideProperty
        /// such as IPerPropertyBrowsing, IProvidePropertyBuilder, etc.
        /// </devdoc>
        private void OnGetAttributes(Com2PropertyDescriptor sender, GetAttributesEvent attrEvent) {
            Object target = sender.TargetObject;

            if (target is NativeMethods.IManagedPerPropertyBrowsing) {
                Attribute[] attrs = GetComponentAttributes((NativeMethods.IManagedPerPropertyBrowsing)target,sender.DISPID);
                if (attrs != null) {
                    for (int i = 0; i < attrs.Length; i++) {
                        attrEvent.Add(attrs[i]);
                    }
                }
            }
        }

        internal static Attribute[] GetComponentAttributes(NativeMethods.IManagedPerPropertyBrowsing target, int dispid) {
            int cItems = 0;
            IntPtr pbstrs = IntPtr.Zero;
            IntPtr pvars = IntPtr.Zero;

            int hr = target.GetPropertyAttributes(dispid, ref cItems, ref pbstrs, ref pvars);

            if (hr != NativeMethods.S_OK || cItems == 0) {
                return new Attribute[0];
            }

            ArrayList attrs = new ArrayList();

            string[] attrTypeNames = GetStringsFromPtr(pbstrs, cItems);
            Object[] varParams = GetVariantsFromPtr(pvars, cItems);

            Debug.Assert(attrTypeNames.Length == varParams.Length, "Mismatched parameter and attribute name length");
            if (attrTypeNames.Length != varParams.Length) {
                return new Attribute[0];
            }

            // get the types
            Type[] types = new Type[attrTypeNames.Length];
            for (int i = 0; i < attrTypeNames.Length; i++) {
                
                string attrName = attrTypeNames[i];
                
                // try the name first
                Type t = Type.GetType(attrName);
                Assembly a = null;
                
                if (t != null) {
                    a = t.Assembly;    
                }

                if (t == null) {


                    // check for an assembly name.
                    //
                    string assemblyName = "";

                    int comma = attrName.LastIndexOf(',');

                    if (comma != -1) {
                        assemblyName = attrName.Substring(comma);
                        attrName = attrName.Substring(0, comma);
                    }

                    string fieldName;
                    int lastDot = attrName.LastIndexOf('.');
                    if (lastDot != -1) {
                        fieldName = attrName.Substring(lastDot + 1);
                    }
                    else {
                        // somethings odd
                        Debug.Fail("No dot in class name?");
                        continue;
                    }

                    // try to get the field value
                    if (a == null) {
                        t = Type.GetType(attrName.Substring(0,lastDot) + assemblyName);
                    }
                    else {
                        t = a.GetType(attrName.Substring(0,lastDot) + assemblyName);
                    }

                    if (t == null){
                        Debug.Fail("Failed load attribute '" + attrName + assemblyName + "'.  It's Type could not be found.");
                        continue;
                    }

                    Debug.Assert(typeof(Attribute).IsAssignableFrom(t), "Attribute type " + t.FullName + " does not derive from Attribute");
                    if (!typeof(Attribute).IsAssignableFrom(t)) {
                        continue;
                    }

                    if (t != null) {
                        FieldInfo fi = t.GetField(fieldName);

                        // only if it's static
                        if (fi != null && fi.IsStatic) {
                            Object fieldValue = fi.GetValue(null);
                            if (fieldValue is Attribute) {
                                // add it to the list
                                attrs.Add(fieldValue);
                                continue;
                            }
                        }
                        else {
                            Debug.Fail("Couldn't load field '" + fieldName + "' from type '" + attrName.Substring(0,lastDot) + "'.  It does not exist or is not static");
                        }
                    }
                }


                Debug.Assert(typeof(Attribute).IsAssignableFrom(t), "Attribute type " + t.FullName + " does not derive from Attribute");
                if (!typeof(Attribute).IsAssignableFrom(t)) {
                    continue;
                }

                Attribute attr = null;

                // okay, if we got here, we need to build the attribute...
                // get the initalizer value if we've got a one item ctor

                if (!Convert.IsDBNull(varParams[i]) && varParams[i] != null) {
                    ConstructorInfo[] ctors = t.GetConstructors();
                    for (int c=0; c < ctors.Length; c++) {
                        ParameterInfo[] pis = ctors[c].GetParameters();
                        if (pis.Length == 1 && pis[0].ParameterType.IsAssignableFrom(varParams[i].GetType())) {
                            // found a one-parameter ctor, use it
                            // try to construct a default one
                            try {
                                attr = (Attribute)Activator.CreateInstance(t, new Object[]{varParams[i]});
                                attrs.Add(attr);
                            }
                            catch (Exception) {
                                // bummer, nevermind
                                Debug.Fail("Attribute " + t.FullName + " did not have a initalizer specified and has no default constructor");
                                continue;
                            }
                        }
                    }
                }
                else {
                    // try to construct a default one
                    try {
                        attr = (Attribute)Activator.CreateInstance(t);
                        attrs.Add(attr);
                    }
                    catch (Exception) {
                        // bummer, nevermind
                        Debug.Fail("Attribute " + t.FullName + " did not have a initalizer specified and has no default constructor");
                        continue;
                    }
                }
            }

            Attribute[] temp = new Attribute[attrs.Count];
            attrs.CopyTo(temp, 0);
            return temp;
        }

        private static string[] GetStringsFromPtr(IntPtr ptr, int cStrings) {
            if (ptr != IntPtr.Zero) {
                string[] strs = new string[cStrings];
                IntPtr bstr;
                for (int i = 0; i < cStrings; i++) {
                    try{
                        bstr = Marshal.ReadIntPtr(ptr, i*4);
                        if (bstr != IntPtr.Zero) {
                            strs[i] = Marshal.PtrToStringUni(bstr);
                            SafeNativeMethods.SysFreeString(new HandleRef(null, bstr));
                        }
                        else {
                            strs[i] = "";
                        }
                    }
                    catch(Exception ex){
                        Debug.Fail("Failed to marshal component attribute BSTR " + i.ToString(), ex.ToString());
                    }
                }
                try{
                    Marshal.FreeCoTaskMem(ptr);
                }
                catch(Exception ex){
                    Debug.Fail("Failed to free BSTR array memory", ex.ToString());
                }
                return strs;
            }
            else {
                return new string[0];
            }
        }

        private static Object[] GetVariantsFromPtr(IntPtr ptr, int cVariants) {
            if (ptr != IntPtr.Zero) {
                Object[] objects = new Object[cVariants];
                IntPtr curVariant;
                
                for (int i = 0; i < cVariants; i++) {
                    try{
                        curVariant = (IntPtr)((long)ptr + (i* 16 /*sizeof(VARIANT)*/));
                        if (curVariant != IntPtr.Zero) {
                            objects[i] = Marshal.GetObjectForNativeVariant(curVariant);
                        }
                        else {
                            objects[i] = Convert.DBNull;
                        }
                    }
                    catch(Exception ex){
                        Debug.Fail("Failed to marshal component attribute VARIANT " + i.ToString(), ex.ToString());
                    }
                }
                try{
                    Marshal.FreeCoTaskMem(ptr);
                }
                catch(Exception ex){
                    Debug.Fail("Failed to free VARIANT array memory", ex.ToString());
                }

                return objects;
            }
            else {
                return new Object[cVariants];
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\componentmodel\com2interop\com2ivsperpropertybrowsinghandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="COM2IVsPerPropertyBrowsingHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms.ComponentModel.Com2Interop {
    using System.Windows.Forms;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;    
    using Microsoft.Win32;

    /// <include file='doc\COM2IVsPerPropertyBrowsingHandler.uex' path='docs/doc[@for="Com2IVsPerPropertyBrowsingHandler"]/*' />
    /// <devdoc>
    /// This is the base class for handlers for Com2 extended browsing interface
    /// such as IPerPropertyBrowsing, etc.
    ///
    /// These handlers should be stateless.  That is, they should keep no refs to object
    /// and should only work on a give object and dispid.  That way all objects that
    /// support a give interface can share a handler.
    ///
    /// See Com2Properties for the array of handler classes to interface classes
    /// where handlers should be registered.
    /// </devdoc>
    [System.Security.SuppressUnmanagedCodeSecurityAttribute()]
    internal class Com2IVsPerPropertyBrowsingHandler: Com2ExtendedBrowsingHandler {

         /// <include file='doc\COM2IVsPerPropertyBrowsingHandler.uex' path='docs/doc[@for="Com2IVsPerPropertyBrowsingHandler.Interface"]/*' />
         /// <devdoc>
         /// The interface that this handler managers
         /// such as IPerPropertyBrowsing, IProvidePropertyBuilder, etc.
         /// </devdoc>
         public override Type Interface {
            get {
               return typeof(NativeMethods.IVsPerPropertyBrowsing);
            }
         }
         
         public static bool AllowChildProperties(Com2PropertyDescriptor propDesc) {
            if (propDesc.TargetObject is NativeMethods.IVsPerPropertyBrowsing) {
               bool pfHide = false;
               int hr = ((NativeMethods.IVsPerPropertyBrowsing)propDesc.TargetObject).DisplayChildProperties(propDesc.DISPID, ref pfHide);
               return (hr == NativeMethods.S_OK && pfHide);
            }
            return false;
         }

         /// <include file='doc\COM2IVsPerPropertyBrowsingHandler.uex' path='docs/doc[@for="Com2IVsPerPropertyBrowsingHandler.SetupPropertyHandlers"]/*' />
         /// <devdoc>
         /// Called to setup the property handlers on a given properties
         /// In this method, the handler will add listeners to the events that
         /// the Com2PropertyDescriptor surfaces that it cares about.
         /// </devdoc>
         public override void SetupPropertyHandlers(Com2PropertyDescriptor[] propDesc){
               if (propDesc == null){
                  return;
               }
               for (int i = 0; i < propDesc.Length; i++){
                  propDesc[i].QueryGetDynamicAttributes += new GetAttributesEventHandler(this.OnGetDynamicAttributes);
                  propDesc[i].QueryGetBaseAttributes += new GetAttributesEventHandler(this.OnGetBaseAttributes);
                  propDesc[i].QueryGetDisplayName += new GetNameItemEventHandler(this.OnGetDisplayName);
                  propDesc[i].QueryGetIsReadOnly += new GetBoolValueEventHandler(this.OnGetIsReadOnly);
                  
                  propDesc[i].QueryShouldSerializeValue += new GetBoolValueEventHandler(this.OnShouldSerializeValue);
                  propDesc[i].QueryCanResetValue += new GetBoolValueEventHandler(this.OnCanResetPropertyValue);
                  propDesc[i].QueryResetValue += new Com2EventHandler(this.OnResetPropertyValue);
                  
                  propDesc[i].QueryGetTypeConverterAndTypeEditor += new GetTypeConverterAndTypeEditorEventHandler(this.OnGetTypeConverterAndTypeEditor);
                  
               }
         }

         private void OnGetBaseAttributes(Com2PropertyDescriptor sender, GetAttributesEvent attrEvent){
             NativeMethods.IVsPerPropertyBrowsing vsObj = sender.TargetObject as NativeMethods.IVsPerPropertyBrowsing;

             if (vsObj == null) {
                 return;
             }

             // should we localize this?
             string[] pHelpString = new string[1];
             int hr = vsObj.GetLocalizedPropertyInfo(sender.DISPID, SafeNativeMethods.GetUserDefaultLCID(), null, pHelpString);
             if (hr == NativeMethods.S_OK && pHelpString[0] != null){
                attrEvent.Add(new DescriptionAttribute(pHelpString[0]));
             }
         }


         /// <include file='doc\COM2IVsPerPropertyBrowsingHandler.uex' path='docs/doc[@for="Com2IVsPerPropertyBrowsingHandler.OnGetAttributes"]/*' />
         /// <devdoc>
         /// Here is where we handle IVsPerPropertyBrowsing.GetLocalizedPropertyInfo and IVsPerPropertyBrowsing.   HideProperty
         /// such as IPerPropertyBrowsing, IProvidePropertyBuilder, etc.
         /// </devdoc>
         private void OnGetDynamicAttributes(Com2PropertyDescriptor sender, GetAttributesEvent attrEvent){

               if (sender.TargetObject is NativeMethods.IVsPerPropertyBrowsing){
                  NativeMethods.IVsPerPropertyBrowsing vsObj = (NativeMethods.IVsPerPropertyBrowsing)sender.TargetObject;

                  int hr = NativeMethods.S_OK;
                  
                  // we want to avoid allowing clients to force a bad property to be browsable,
                  // so we don't allow things that are marked as non browsable to become browsable,
                  // only the other way around.
                  //
                  if (sender.CanShow) {
                    // should we hide this?
                    bool pfHide = sender.Attributes[typeof(BrowsableAttribute)].Equals(BrowsableAttribute.No);
                  
                    hr = vsObj.HideProperty(sender.DISPID, ref pfHide);
                    if (hr == NativeMethods.S_OK){
                         attrEvent.Add(pfHide ? BrowsableAttribute.No : BrowsableAttribute.Yes);
                    }
                  } 

                  // should we show this
                  if (typeof(UnsafeNativeMethods.IDispatch).IsAssignableFrom(sender.PropertyType) && sender.CanShow){
                     bool pfDisplay = false;
                     hr = vsObj.DisplayChildProperties(sender.DISPID, ref pfDisplay);
                     if (hr == NativeMethods.S_OK && pfDisplay){
                           attrEvent.Add(BrowsableAttribute.Yes);
                     }
                  }
               }
               else {
                  Debug.Fail("Object is not " + Interface.Name + "!");
               }
         }

         private void OnCanResetPropertyValue(Com2PropertyDescriptor sender, GetBoolValueEvent boolEvent) {
               if (sender.TargetObject is NativeMethods.IVsPerPropertyBrowsing) {
                    NativeMethods.IVsPerPropertyBrowsing target = (NativeMethods.IVsPerPropertyBrowsing)sender.TargetObject;
                    bool canReset = boolEvent.Value;
                    int hr = target.CanResetPropertyValue(sender.DISPID, ref canReset);

                    if (NativeMethods.Succeeded(hr)){
                        boolEvent.Value = canReset;
                    }
               }
               else {
                  Debug.Fail("Object is not " + Interface.Name + "!");
               }
         }

         /// <include file='doc\COM2IVsPerPropertyBrowsingHandler.uex' path='docs/doc[@for="Com2IVsPerPropertyBrowsingHandler.OnGetDisplayName"]/*' />
         /// <devdoc>
         /// Here is where we handle IVsPerPropertyBrowsing.GetLocalizedPropertyInfo (part 2)
         /// </devdoc>
         private void OnGetDisplayName(Com2PropertyDescriptor sender, GetNameItemEvent nameItem){
               if (sender.TargetObject is NativeMethods.IVsPerPropertyBrowsing){
                  NativeMethods.IVsPerPropertyBrowsing vsObj = (NativeMethods.IVsPerPropertyBrowsing)sender.TargetObject;

                  // get the localized name, if applicable
                  string[] pNameString = new string[1];
                  int hr = vsObj.GetLocalizedPropertyInfo(sender.DISPID, SafeNativeMethods.GetUserDefaultLCID(), pNameString, null);
                  if (hr == NativeMethods.S_OK && pNameString[0] != null){
                     nameItem.Name = pNameString[0];
                  }
               }
               else {
                  Debug.Fail("Object is not " + Interface.Name + "!");
               }
         }

         /// <include file='doc\COM2IVsPerPropertyBrowsingHandler.uex' path='docs/doc[@for="Com2IVsPerPropertyBrowsingHandler.OnGetIsReadOnly"]/*' />
         /// <devdoc>
         /// Here is where we handle IVsPerPropertyBrowsing.IsPropertyReadOnly
         /// </devdoc>
         private void OnGetIsReadOnly(Com2PropertyDescriptor sender, GetBoolValueEvent gbvevent){
               if (sender.TargetObject is NativeMethods.IVsPerPropertyBrowsing){
                  NativeMethods.IVsPerPropertyBrowsing vsObj = (NativeMethods.IVsPerPropertyBrowsing)sender.TargetObject;

                  // should we make this read only?
                  bool pfResult = false;
                  int hr = vsObj.IsPropertyReadOnly(sender.DISPID, ref pfResult);

                  if (hr == NativeMethods.S_OK){
                     gbvevent.Value = pfResult;
                  }
               }
         }
         
         /// <include file='doc\COM2IVsPerPropertyBrowsingHandler.uex' path='docs/doc[@for="Com2IVsPerPropertyBrowsingHandler.OnGetTypeConverterAndTypeEditor"]/*' />
         /// <devdoc>
         /// Here is where we handle IVsPerPropertyBrowsing.DisplayChildProperties
         /// </devdoc>
         private void OnGetTypeConverterAndTypeEditor(Com2PropertyDescriptor sender, GetTypeConverterAndTypeEditorEvent gveevent) {
            if (sender.TargetObject is NativeMethods.IVsPerPropertyBrowsing){

                  // we only do this for IDispatch types
                  if (sender.CanShow && typeof(UnsafeNativeMethods.IDispatch).IsAssignableFrom(sender.PropertyType)){
                     NativeMethods.IVsPerPropertyBrowsing vsObj = (NativeMethods.IVsPerPropertyBrowsing)sender.TargetObject;

                     // should we make this read only?
                     bool pfResult = false;
                     int hr = vsObj.DisplayChildProperties(sender.DISPID, ref pfResult);
                     
                     if (gveevent.TypeConverter is Com2IDispatchConverter){
                        gveevent.TypeConverter = new Com2IDispatchConverter(sender, (hr == NativeMethods.S_OK && pfResult));
                     }
                     else{
                        gveevent.TypeConverter = new Com2IDispatchConverter(sender, (hr == NativeMethods.S_OK && pfResult), gveevent.TypeConverter);
                     }
                  }
               }
               else {
                  Debug.Fail("Object is not " + Interface.Name + "!");
               }
         }
         
         private void OnResetPropertyValue(Com2PropertyDescriptor sender, EventArgs e) {
               if (sender.TargetObject is NativeMethods.IVsPerPropertyBrowsing) {

                    
                    NativeMethods.IVsPerPropertyBrowsing target = (NativeMethods.IVsPerPropertyBrowsing)sender.TargetObject;
                    int dispid = sender.DISPID;
                    bool canReset = false;
                    int hr = target.CanResetPropertyValue(dispid, ref canReset);

                    if (NativeMethods.Succeeded(hr)){
                        target.ResetPropertyValue(dispid);
                    }
               }
               else {
                  Debug.Fail("Object is not " + Interface.Name + "!");
               }
         }

         private void OnShouldSerializeValue(Com2PropertyDescriptor sender, GetBoolValueEvent gbvevent){
               if (sender.TargetObject is NativeMethods.IVsPerPropertyBrowsing){
                     NativeMethods.IVsPerPropertyBrowsing vsObj = (NativeMethods.IVsPerPropertyBrowsing)sender.TargetObject;

                     // by default we say it's default
                     bool pfResult = true;
                     int hr = vsObj.HasDefaultValue(sender.DISPID,ref pfResult);

                     if (hr == NativeMethods.S_OK && !pfResult){
                        // specify a default value editor
                        gbvevent.Value = true;
                     }
               }
               else {
                  Debug.Fail("Object is not " + Interface.Name + "!");
               }
         }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\componentmodel\com2interop\com2iprovidepropertybuilderhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="COM2IProvidePropertyBuilderHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------


namespace System.Windows.Forms.ComponentModel.Com2Interop {
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Windows.Forms;    
    using System.Collections;
    using Microsoft.Win32;
    using System.Drawing.Design;

    [System.Security.SuppressUnmanagedCodeSecurityAttribute()]
    internal class Com2IProvidePropertyBuilderHandler : Com2ExtendedBrowsingHandler {

        public override Type Interface {
            get {
                return typeof(NativeMethods.IProvidePropertyBuilder);
            }
        }

        private bool GetBuilderGuidString(NativeMethods.IProvidePropertyBuilder target, int dispid, ref string strGuidBldr, int[] bldrType) {
            bool valid = false;
            string[] pGuidBldr = new string[1];
            if (NativeMethods.Failed(target.MapPropertyToBuilder(dispid, bldrType, pGuidBldr, ref valid))) {
                valid = false;
            }
                        
            if (valid && (bldrType[0] & _CTLBLDTYPE.CTLBLDTYPE_FINTERNALBUILDER) == 0) {
                valid = false;
                Debug.Fail("Property Browser doesn't support standard builders -- NYI");
            }

            if (!valid) {
                return false;
            }

            if (pGuidBldr[0] == null) {
                strGuidBldr = Guid.Empty.ToString();
            }
            else {
                strGuidBldr = pGuidBldr[0];
            }
            return true;
        }

        public override void SetupPropertyHandlers(Com2PropertyDescriptor[] propDesc) {
            if (propDesc == null) {
                return;
            }
            for (int i = 0; i < propDesc.Length; i++) {
                propDesc[i].QueryGetBaseAttributes += new GetAttributesEventHandler(this.OnGetBaseAttributes);
                
                propDesc[i].QueryGetTypeConverterAndTypeEditor += new GetTypeConverterAndTypeEditorEventHandler(this.OnGetTypeConverterAndTypeEditor);
                
            }
        }


        /// <include file='doc\COM2IProvidePropertyBuilderHandler.uex' path='docs/doc[@for="Com2IProvidePropertyBuilderHandler.OnGetAttributes"]/*' />
        /// <devdoc>
        /// Here is where we handle IVsPerPropertyBrowsing.GetLocalizedPropertyInfo and IVsPerPropertyBrowsing.   HideProperty
        /// such as IPerPropertyBrowsing, IProvidePropertyBuilder, etc.
        /// </devdoc>
        private void OnGetBaseAttributes(Com2PropertyDescriptor sender, GetAttributesEvent attrEvent) {
            NativeMethods.IProvidePropertyBuilder target = sender.TargetObject as NativeMethods.IProvidePropertyBuilder;

            if (target != null ) {
                string s = null;
                bool builderValid = GetBuilderGuidString(target, sender.DISPID, ref s, new int[1]);
                // we hide IDispatch props by default, we we need to force showing them here
                if (sender.CanShow && builderValid) {
                    if (typeof(UnsafeNativeMethods.IDispatch).IsAssignableFrom(sender.PropertyType)) {
                        attrEvent.Add(BrowsableAttribute.Yes);
                    }
                }
            }
        }
        
        private void OnGetTypeConverterAndTypeEditor(Com2PropertyDescriptor sender, GetTypeConverterAndTypeEditorEvent gveevent) {
            object target = sender.TargetObject;

            if (target is NativeMethods.IProvidePropertyBuilder) {
                NativeMethods.IProvidePropertyBuilder propBuilder = (NativeMethods.IProvidePropertyBuilder)target;
                int[] pctlBldType = new int[1];
                string guidString = null;

                if (GetBuilderGuidString(propBuilder, sender.DISPID, ref guidString, pctlBldType)) {
                    gveevent.TypeEditor = new Com2PropertyBuilderUITypeEditor(sender, guidString, pctlBldType[0], (UITypeEditor)gveevent.TypeEditor);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\componentmodel\com2interop\com2pictureconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="COM2PictureConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------


namespace System.Windows.Forms.ComponentModel.Com2Interop {
    using System.Runtime.Serialization.Formatters;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;    
    using System.Windows.Forms;
    using System.Drawing;    
    using System.Collections;
    using Hashtable = System.Collections.Hashtable;
    using Microsoft.Win32;

    /// <include file='doc\COM2PictureConverter.uex' path='docs/doc[@for="Com2PictureConverter"]/*' />
    /// <devdoc>
    /// This class maps an IPicture to a System.Drawing.Image.
    /// </devdoc>
    internal class Com2PictureConverter : Com2DataTypeToManagedDataTypeConverter {

        object lastManaged;
        IntPtr lastNativeHandle;
        WeakReference pictureRef;
        IntPtr lastPalette = IntPtr.Zero;

        Type pictureType = typeof(Bitmap);

        public Com2PictureConverter(Com2PropertyDescriptor pd) {
            if (pd.DISPID == NativeMethods.ActiveX.DISPID_MOUSEICON || pd.Name.IndexOf("Icon") != -1) {
                pictureType = typeof(Icon);
            }
        }

        /// <include file='doc\COM2PictureConverter.uex' path='docs/doc[@for="Com2PictureConverter.ManagedType"]/*' />
        /// <devdoc>
        ///     Returns the managed type that this editor maps the property type to.
        /// </devdoc>
        public override Type ManagedType {
            get {
                return pictureType;
            }
        }

        /// <include file='doc\COM2PictureConverter.uex' path='docs/doc[@for="Com2PictureConverter.ConvertNativeToManaged"]/*' />
        /// <devdoc>
        ///     Converts the native value into a managed value
        /// </devdoc>
        public override object ConvertNativeToManaged(object nativeValue, Com2PropertyDescriptor pd) {

            if (nativeValue == null) {
                return null;
            }

            Debug.Assert(nativeValue is SafeNativeMethods.IPicture, "nativevalue is not IPicture");

            SafeNativeMethods.IPicture nativePicture = (SafeNativeMethods.IPicture)nativeValue;
            IntPtr handle = nativePicture.GetHandle();

            if (lastManaged != null && handle == lastNativeHandle) {
                return lastManaged;
            }

            lastNativeHandle = handle;
            //lastPalette = nativePicture.GetHPal();
            if (handle != IntPtr.Zero) {
                switch (nativePicture.GetPictureType()) {
                    case  NativeMethods.Ole.PICTYPE_ICON:
                        pictureType = typeof(Icon);
                        lastManaged = Icon.FromHandle(handle);
                        break;
                    case   NativeMethods.Ole.PICTYPE_BITMAP:
                        pictureType = typeof(Bitmap);
                        lastManaged = Image.FromHbitmap(handle);
                        break;
                    default:
                        Debug.Fail("Unknown picture type");
			break;
                }
                pictureRef = new WeakReference(nativePicture);
            }
            else {
                lastManaged = null;
                pictureRef = null;
            }
            return lastManaged;
        }

        /// <include file='doc\COM2PictureConverter.uex' path='docs/doc[@for="Com2PictureConverter.ConvertManagedToNative"]/*' />
        /// <devdoc>
        ///     Converts the managed value into a native value
        /// </devdoc>
        public override object ConvertManagedToNative(object managedValue, Com2PropertyDescriptor pd, ref bool cancelSet) {
            // don't cancel the set
            cancelSet = false;

            if (lastManaged != null && lastManaged.Equals(managedValue) && pictureRef != null && pictureRef.IsAlive) {
                return pictureRef.Target;
            }

            // we have to build an IPicture
            lastManaged = managedValue;

            if (managedValue != null) {
                Guid g = typeof(SafeNativeMethods.IPicture).GUID;
                NativeMethods.PICTDESC pictdesc = null;
                bool own = false;

                if (lastManaged is Icon) {
                    pictdesc = NativeMethods.PICTDESC.CreateIconPICTDESC(((Icon)lastManaged).Handle);
                }
                else if (lastManaged is Bitmap) {
                    pictdesc = NativeMethods.PICTDESC.CreateBitmapPICTDESC(((Bitmap)lastManaged).GetHbitmap(), lastPalette);
                    own = true;
                }
                else {
                    Debug.Fail("Unknown Image type: " + managedValue.GetType().Name);
                }

                SafeNativeMethods.IPicture pict  = SafeNativeMethods.OleCreatePictureIndirect(pictdesc, ref g, own);
                lastNativeHandle = pict.GetHandle();
                pictureRef = new WeakReference(pict);
                return pict;
            }
            else {
                lastManaged = null;
                lastNativeHandle = lastPalette = IntPtr.Zero;
                pictureRef = null;
                return null;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\componentmodel\com2interop\com2idispatchconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="COM2IDispatchConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------



namespace System.Windows.Forms.ComponentModel.Com2Interop {

    using System.Diagnostics;
    using System;
    
    using System.Windows.Forms;
    using System.ComponentModel;
    using System.Collections;
    using Microsoft.Win32;
    using System.Globalization;

    internal class Com2IDispatchConverter : Com2ExtendedTypeConverter{
        Com2PropertyDescriptor propDesc;

        /// <include file='doc\COM2IDispatchConverter.uex' path='docs/doc[@for="Com2IDispatchConverter.none"]/*' />
        /// <devdoc>
        ///     What we return textually for null.
        /// </devdoc>
        protected static readonly string none = SR.GetString(SR.toStringNone);

        private bool allowExpand;


        public Com2IDispatchConverter(Com2PropertyDescriptor propDesc, bool allowExpand, TypeConverter baseConverter) : base(baseConverter){
             this.propDesc = propDesc;
             this.allowExpand = allowExpand;
        }


        public Com2IDispatchConverter(Com2PropertyDescriptor propDesc, bool allowExpand) : base(propDesc.PropertyType){
             this.propDesc = propDesc;
             this.allowExpand = allowExpand;
        }
        
        /// <include file='doc\COM2IDispatchConverter.uex' path='docs/doc[@for="Com2IDispatchConverter.CanConvertFrom"]/*' />
        /// <devdoc>
        ///      Determines if this converter can convert an object in the given source
        ///      type to the native type of the converter.
        /// </devdoc>
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
            return false;
        }
        
        /// <include file='doc\COM2IDispatchConverter.uex' path='docs/doc[@for="Com2IDispatchConverter.CanConvertTo"]/*' />
        /// <devdoc>
        ///      Determines if this converter can convert an object to the given destination
        ///      type.
        /// </devdoc>
        public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType) {
            return destinationType == typeof(string);
        }
        
        
        /// <include file='doc\COM2IDispatchConverter.uex' path='docs/doc[@for="Com2IDispatchConverter.ConvertTo"]/*' />
        /// <devdoc>
        ///      Converts the given object to another type.  The most common types to convert
        ///      are to and from a string object.  The default implementation will make a call
        ///      to ToString on the object if the object is valid and if the destination
        ///      type is string.  If this cannot convert to the desitnation type, this will
        ///      throw a NotSupportedException.
        /// </devdoc>
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == typeof(string)){
               if (value == null){
                  return none;
               }
               
               string text = ComNativeDescriptor.Instance.GetName(value);
   
               if (text == null || text.Length == 0){
                     text = ComNativeDescriptor.Instance.GetClassName(value);
               }
   
               if (text == null){
                  return "(Object)";
               }
               return text;
            }
            return base.ConvertTo(context, culture, value, destinationType);
        }
        
        public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes) {      
            return TypeDescriptor.GetProperties(value, attributes);
        }
        
        /// <include file='doc\COM2IDispatchConverter.uex' path='docs/doc[@for="Com2IDispatchConverter.GetPropertiesSupported"]/*' />
        /// <devdoc>
        ///      Determines if this object supports properties.  By default, this
        ///      is false.
        /// </devdoc>
        public override bool GetPropertiesSupported(ITypeDescriptorContext context) {
            return this.allowExpand;
        }
        
        // no dropdown, please!
        //
        public override bool GetStandardValuesSupported(ITypeDescriptorContext context) {
            return false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\componentmodel\com2interop\com2iperpropertybrowsinghandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="COM2IPerPropertyBrowsingHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms.ComponentModel.Com2Interop {
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Windows.Forms;    
    using System.Collections;
    using Microsoft.Win32;
    using System.Globalization;
    using System.Drawing.Design;

    [System.Security.SuppressUnmanagedCodeSecurityAttribute()]
    internal class Com2IPerPropertyBrowsingHandler : Com2ExtendedBrowsingHandler {
        public override Type Interface {
            get {
                return typeof(NativeMethods.IPerPropertyBrowsing);
            }
        }

        public override void SetupPropertyHandlers(Com2PropertyDescriptor[] propDesc) {
            if (propDesc == null) {
                return;
            }
            for (int i = 0; i < propDesc.Length; i++) {
                propDesc[i].QueryGetBaseAttributes += new GetAttributesEventHandler(this.OnGetBaseAttributes);
                propDesc[i].QueryGetDisplayValue += new GetNameItemEventHandler(this.OnGetDisplayValue);
                
                propDesc[i].QueryGetTypeConverterAndTypeEditor += new GetTypeConverterAndTypeEditorEventHandler(this.OnGetTypeConverterAndTypeEditor);
            }
        }

        private Guid GetPropertyPageGuid(NativeMethods.IPerPropertyBrowsing target, int dispid) {
            // check for a property page
            Guid guid;
            int hr = target.MapPropertyToPage(dispid, out guid);
            if (hr == NativeMethods.S_OK) {
                return guid;
            }
            return Guid.Empty;
        }
        
        internal static string GetDisplayString(NativeMethods.IPerPropertyBrowsing ppb, int dispid, ref bool success) {
            string[] strVal = new string[1];
            int hr = ppb.GetDisplayString(dispid, strVal);
            if (hr == NativeMethods.S_OK) {
                success = (strVal[0] != null);
                //Debug.Assert(success, "IPerPropertyBrowsing::GetDisplayString returned NULL and S_OK -- this is not a valid state. This component does not property implement IPerPropertyBrowsing. (component class=" + TypeDescriptor.GetClassName(ppb) + ")");
                return strVal[0];
            }
            else {
                success = false;
            }   
            return null;
        }

        /// <include file='doc\COM2IPerPropertyBrowsingHandler.uex' path='docs/doc[@for="Com2IPerPropertyBrowsingHandler.OnGetAttributes"]/*' />
        /// <devdoc>
        /// Here is where we handle IVsPerPropertyBrowsing.GetLocalizedPropertyInfo and IVsPerPropertyBrowsing.   HideProperty
        /// such as IPerPropertyBrowsing, IProvidePropertyBuilder, etc.
        /// </devdoc>
        private void OnGetBaseAttributes(Com2PropertyDescriptor sender, GetAttributesEvent attrEvent) {
            NativeMethods.IPerPropertyBrowsing target = sender.TargetObject as NativeMethods.IPerPropertyBrowsing;
            if (target != null) {
                // we hide IDispatch props by default, we we need to force showing them here
                                                                  
                bool validPropPage = !Guid.Empty.Equals(GetPropertyPageGuid(target, sender.DISPID));
                
                if (sender.CanShow && validPropPage) {
                    if (typeof(UnsafeNativeMethods.IDispatch).IsAssignableFrom(sender.PropertyType)) {
                        attrEvent.Add(BrowsableAttribute.Yes);
                    }
                }
            }
        }

        private void OnGetDisplayValue(Com2PropertyDescriptor sender, GetNameItemEvent gnievent) {
            try {
                if (sender.TargetObject is NativeMethods.IPerPropertyBrowsing) {

                    // if we are using the dropdown, don't convert the value
                    // or the values will change when we select them and call back
                    // for the display value.
                    if (sender.Converter is Com2IPerPropertyEnumConverter || sender.ConvertingNativeType) {
                        return;
                    }
                    
                    bool success = true;
                    
                    string displayString = GetDisplayString((NativeMethods.IPerPropertyBrowsing)sender.TargetObject, sender.DISPID, ref success);
                    
                    if (success) {
                        gnievent.Name = displayString;
                    }
                }
            }
            catch (Exception) {
            }
        }

        private void OnGetTypeConverterAndTypeEditor(Com2PropertyDescriptor sender, GetTypeConverterAndTypeEditorEvent gveevent) {
            if (sender.TargetObject is NativeMethods.IPerPropertyBrowsing) {
                NativeMethods.IPerPropertyBrowsing ppb = (NativeMethods.IPerPropertyBrowsing)sender.TargetObject;

                bool hasStrings = false;

                // check for enums
                NativeMethods.CA_STRUCT caStrings = new NativeMethods.CA_STRUCT();
                NativeMethods.CA_STRUCT caCookies = new NativeMethods.CA_STRUCT();

                int hr = NativeMethods.S_OK;

                try {
                    hr = ppb.GetPredefinedStrings(sender.DISPID, caStrings, caCookies);
                }
                catch(ExternalException ex){
                    hr = ex.ErrorCode;
                    Debug.Fail("An exception occurred inside IPerPropertyBrowsing::GetPredefinedStrings(dispid=" + sender.DISPID + "), object type=" + new ComNativeDescriptor().GetClassName(ppb) + ".  This is caused by an exception (usually an AV) inside the object being browsed, and is not a problem in the properties window.");
                }

                // Terminate the existing editor if we created the current one
                // so if the items have disappeared, we don't hold onto the old
                // items.
                if (gveevent.TypeConverter is Com2IPerPropertyEnumConverter) {
                    gveevent.TypeConverter = null;
                }

                if (hr != NativeMethods.S_OK) {
                    hasStrings = false;
                }
                else {
                    hasStrings = true;
                }

                if (hasStrings) {

                    OleStrCAMarshaler stringMarshaler = new OleStrCAMarshaler(caStrings);
                    Int32CAMarshaler  intMarshaler = new Int32CAMarshaler(caCookies);
                    

                    if (stringMarshaler.Count > 0 && intMarshaler.Count > 0) {
                        gveevent.TypeConverter = new Com2IPerPropertyEnumConverter(new Com2IPerPropertyBrowsingEnum(sender, this, stringMarshaler, intMarshaler, true));
                    }
                    else {
                        //hasStrings = false;
                    }
                }

               // if we didn't get any strings, try the proppage edtior
               //
               if (!hasStrings){

                 // this is a _bit_ of a backwards-compat work around...
                 // many older ActiveX controls will show a property page
                 // for all properties since the old grid would only put up the
                 // [...] button for "(Custom)".  If we have a conversion editor,
                 // don't allow this to override it...
                 //
                 if (sender.ConvertingNativeType){
                     return;
                 }

                 Guid g = GetPropertyPageGuid(ppb, sender.DISPID);

                 if (!Guid.Empty.Equals(g)){
                    gveevent.TypeEditor = new Com2PropertyPageUITypeEditor(sender, g, (UITypeEditor)gveevent.TypeEditor);
                 }
               }
            }
        }

        
         // this is just here so we can identify the enums that we added
         private class Com2IPerPropertyEnumConverter : Com2EnumConverter {
             private Com2IPerPropertyBrowsingEnum itemsEnum;
             public Com2IPerPropertyEnumConverter(Com2IPerPropertyBrowsingEnum items) : base(items) {
                this.itemsEnum = items;
             }
             
             public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destType) {

                 if (destType == typeof(string) && !itemsEnum.arraysFetched) {
                     object curValue = itemsEnum.target.GetValue(itemsEnum.target.TargetObject);
                     if (curValue == value || (curValue != null && curValue.Equals(value))) {
                         bool success = false;
                         string val = GetDisplayString((NativeMethods.IPerPropertyBrowsing)itemsEnum.target.TargetObject, itemsEnum.target.DISPID, ref success);
                         if (success) {
                             return val;
                         }
                     }
                 }
                 return base.ConvertTo(context, culture, value, destType);
              }
         }
         
         
         // This exists for perf reasons.   We delay doing this until we
         // are actually asked for the array of values. 
         // 
         private class Com2IPerPropertyBrowsingEnum : Com2Enum {
         
             internal Com2PropertyDescriptor target;
             private Com2IPerPropertyBrowsingHandler handler;
             private OleStrCAMarshaler    nameMarshaller;
             private Int32CAMarshaler     valueMarshaller;
             internal bool                 arraysFetched;
             //private bool                 standardValuesQueried;
         
             public Com2IPerPropertyBrowsingEnum(Com2PropertyDescriptor targetObject, Com2IPerPropertyBrowsingHandler handler, OleStrCAMarshaler names, Int32CAMarshaler values, bool allowUnknowns) : base(new string[0], new object[0], allowUnknowns) {
                this.target = targetObject;
                this.nameMarshaller = names;
                this.valueMarshaller = values;
                this.handler = handler;
                this.arraysFetched = false;
             }
             
             /// <include file='doc\COM2IPerPropertyBrowsingHandler.uex' path='docs/doc[@for="Com2IPerPropertyBrowsingHandler.Com2IPerPropertyBrowsingEnum.Values"]/*' />
             /// <devdoc>
             /// Retrieve a copy of the value array
             /// </devdoc>
             public override object[] Values {
                get {
                    EnsureArrays();
                    return base.Values;
                }
             }
    
             /// <include file='doc\COM2IPerPropertyBrowsingHandler.uex' path='docs/doc[@for="Com2IPerPropertyBrowsingHandler.Com2IPerPropertyBrowsingEnum.Names"]/*' />
             /// <devdoc>
             /// Retrieve a copy of the nme array.
             /// </devdoc>
             public override string[] Names {
                get {
                    EnsureArrays();
                    return base.Names;
                }
             }
             
             /*internal bool StandardValuesQueried {
                get {
                    this.standardValuesQueried = value;
                }
             } */
             
             
             // ensure that we have processed the caStructs into arrays
             // of values and strings
             //
             private void EnsureArrays() {
                if (this.arraysFetched) {
                    return;
                }
                
                this.arraysFetched = true;
                
                try {

                    // marshal the items.
                    object[] nameItems = nameMarshaller.Items;
                    object[] cookieItems=   valueMarshaller.Items;
                    NativeMethods.IPerPropertyBrowsing ppb = (NativeMethods.IPerPropertyBrowsing)target.TargetObject;
                    int itemCount = 0;
                    
                    Debug.Assert(cookieItems != null && nameItems != null, "An item array is null");
    
                    
                    if (nameItems.Length > 0){
    
                        object[] valueItems = new object[cookieItems.Length];
                        NativeMethods.VARIANT var = new NativeMethods.VARIANT();
                        int cookie;
    
                        Debug.Assert(cookieItems.Length == nameItems.Length, "Got uneven names and cookies");
    
                        // for each name item, we ask the object for it's corresponding value.
                        //
                        Type targetType = target.PropertyType;
                        for (int i = 0; i < nameItems.Length; i++) {
                            cookie = (int)cookieItems[i];
                            if (nameItems[i] == null || !(nameItems[i] is string)) {
                                Debug.Fail("Bad IPerPropertyBrowsing item [" + i.ToString() + "], name=" + (nameItems == null ? "(unknown)" : nameItems[i].ToString()));
                                continue;
                            }
                            var.vt = (short)NativeMethods.tagVT.VT_EMPTY;
                            int hr = ppb.GetPredefinedValue(target.DISPID, cookie, var);
                            if (hr == NativeMethods.S_OK && var.vt != (short)NativeMethods.tagVT.VT_EMPTY) {
                                valueItems[i] = var.ToObject();
                                if (valueItems[i].GetType() != targetType) {
                                    if (targetType.IsEnum) {
                                        valueItems[i] = Enum.ToObject(targetType, valueItems[i]);
                                    }
                                    else {
                                        try {
                                            valueItems[i] = Convert.ChangeType(valueItems[i], targetType);
                                        }
                                        catch {
                                            // oh well...
                                        }
                                    }
                                }
                            }
                            var.Clear();
                            itemCount++;
                        }
    
                        // pass this data down to the base Com2Enum object... 
                        if (itemCount > 0) {
                            string[] strings = new string[itemCount];
                            Array.Copy(nameItems, 0, strings, 0, itemCount);
                            base.PopulateArrays(strings, valueItems);
                        }
                    }
                }
                catch (Exception ex) {
                    Debug.Fail("Failed to build IPerPropertyBrowsing editor. " + ex.GetType().Name + ", " + ex.Message);
                }

             }
             
             protected override void PopulateArrays(string[] names, object[] values) {
                // we call base.PopulateArrays directly when we actually want to do this.
             }
             
             public override object FromString(string s) {
                EnsureArrays();
                return base.FromString(s);
             }
             
             public override string ToString(object v) {
                
                // If the value is the object's current value, then
                // ask GetDisplay string first.  This is a perf improvement
                // because this way we don't populate the arrays when an object is selected, only
                // when the dropdown is actually opened.
                //
                if (target.IsCurrentValue(v)) {
             
                    bool success = false;
                
                    string displayString = Com2IPerPropertyBrowsingHandler.GetDisplayString((NativeMethods.IPerPropertyBrowsing)target.TargetObject, target.DISPID, ref success);
                    
                    if (success) {
                        return displayString;
                    }
                }
                
                // couldn't get a display string...do the normal thing.
                //
                EnsureArrays();
                return base.ToString(v);
             }
         }
         
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\componentmodel\com2interop\com2propertybuilderuitypeeditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="COM2PropertyBuilderUITypeEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------


namespace System.Windows.Forms.ComponentModel.Com2Interop {

    using System.Diagnostics;
    using System.Runtime.InteropServices;

    using System;
    
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;
    using System.Drawing;
    using System.Drawing.Design;
    using Microsoft.Win32;

    /// <include file='doc\COM2PropertyBuilderUITypeEditor.uex' path='docs/doc[@for="Com2PropertyBuilderUITypeEditor"]/*' />
    /// <devdoc>
    /// </devdoc>
    internal class Com2PropertyBuilderUITypeEditor : Com2ExtendedUITypeEditor {

        private Com2PropertyDescriptor propDesc;
        string  guidString;
        int     bldrType;

        public Com2PropertyBuilderUITypeEditor(Com2PropertyDescriptor pd, string guidString, int type) : this(pd, guidString, type,pd.PropertyType){
        }

        public Com2PropertyBuilderUITypeEditor(Com2PropertyDescriptor pd, string guidString, int type, Type baseType) : base(baseType) {
            propDesc = pd;
            this.guidString = guidString;
            this.bldrType = type;
        }

        public Com2PropertyBuilderUITypeEditor(Com2PropertyDescriptor pd, string guidString, int type, UITypeEditor baseEditor) : base(baseEditor) {
            propDesc = pd;
            this.guidString = guidString;
            this.bldrType = type;
        }

        /// <include file='doc\COM2PropertyBuilderUITypeEditor.uex' path='docs/doc[@for="Com2PropertyBuilderUITypeEditor.EditValue"]/*' />
        /// <devdoc>
        ///     Takes the value returned from valueAccess.getValue() and modifies or replaces
        ///     the value, passing the result into valueAccess.setValue().  This is where
        ///     an editor can launch a modal dialog or create a drop down editor to allow
        ///     the user to modify the value.  Host assistance in presenting UI to the user
        ///     can be found through the valueAccess.getService function.
        /// </devdoc>
        public override object EditValue(ITypeDescriptorContext context, IServiceProvider provider, object value) {

            IntPtr parentHandle = (IntPtr)UnsafeNativeMethods.GetFocus();

            IUIService uiSvc = (IUIService)provider.GetService(typeof(IUIService));
            if (uiSvc != null) {
                IWin32Window parent = uiSvc.GetDialogOwnerWindow();
                if (parent != null) {
                    parentHandle = parent.Handle;
                }
            }
            
            bool useValue = false;
            //VARIANT pValue = null;
            object pValue = value;

            try{
               object obj = propDesc.TargetObject;
                
              
               if (obj is ICustomTypeDescriptor) {
                  obj = ((ICustomTypeDescriptor)obj).GetPropertyOwner(propDesc);
               }

                
                Debug.Assert(obj is NativeMethods.IProvidePropertyBuilder, "object is not IProvidePropertyBuilder");
                NativeMethods.IProvidePropertyBuilder propBuilder = (NativeMethods.IProvidePropertyBuilder)obj;

                if (NativeMethods.Failed(propBuilder.ExecuteBuilder(propDesc.DISPID,
                                                          guidString,
                                                          null,
                                                          new HandleRef(null, parentHandle),
                                                          ref pValue, ref useValue))){
                    useValue = false;
                }

            }catch(ExternalException ex) {
                Debug.Fail("Failed to show property frame: " + ex.ErrorCode.ToString());
            }

            if (useValue && (bldrType & _CTLBLDTYPE.CTLBLDTYPE_FEDITSOBJDIRECTLY) == 0){
               
               return pValue;//pValue.ToVariant();
            }
            return value;
        }

        /// <include file='doc\COM2PropertyBuilderUITypeEditor.uex' path='docs/doc[@for="Com2PropertyBuilderUITypeEditor.GetEditStyle"]/*' />
        /// <devdoc>
        ///      Retrieves the editing style of the Edit method.  If the method
        ///      is not supported, this will return None.
        /// </devdoc>
        public override UITypeEditorEditStyle GetEditStyle(ITypeDescriptorContext context) {
            return UITypeEditorEditStyle.Modal;
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\componentmodel\com2interop\com2properties.cs ===
//------------------------------------------------------------------------------
// <copyright file="COM2Properties.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms.ComponentModel.Com2Interop {
    using System.Runtime.Remoting;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Windows.Forms;    
    using System.Collections;
    using Microsoft.Win32;


    /// <include file='doc\COM2Properties.uex' path='docs/doc[@for="Com2Properties"]/*' />
    /// <devdoc>
    /// This class is responsible for managing a set or properties for a native object.  It determines
    /// when the properties need to be refreshed, and owns the extended handlers for those properties.
    /// </devdoc>
    internal class Com2Properties {
    
        private static TraceSwitch DbgCom2PropertiesSwitch = new TraceSwitch("DbgCom2Properties", "Com2Properties: debug Com2 properties manager");
        
        
        
        /// <include file='doc\COM2Properties.uex' path='docs/doc[@for="Com2Properties.AGE_THRESHHOLD"]/*' />
        /// <devdoc>
        /// This is the interval that we'll hold props for.  If someone doesn't touch an object
        /// for this amount of time, we'll dump the properties from our cache.
        /// 
        /// 5 minutes -- ticks are 1/10,000,000th of a second
        /// </devdoc>
        private static long AGE_THRESHHOLD = (long)(10000000L * 60L * 5L);

        
        /// <include file='doc\COM2Properties.uex' path='docs/doc[@for="Com2Properties.weakObjRef"]/*' />
        /// <devdoc>
        /// This is the object that gave us the properties.  We hold a WeakRef so we don't addref the object.
        /// </devdoc>
        private WeakReference weakObjRef;
        
        /// <include file='doc\COM2Properties.uex' path='docs/doc[@for="Com2Properties.props"]/*' />
        /// <devdoc>
        /// This is our list of properties.
        /// </devdoc>
        private Com2PropertyDescriptor[] props;
        
        /// <include file='doc\COM2Properties.uex' path='docs/doc[@for="Com2Properties.defaultIndex"]/*' />
        /// <devdoc>
        /// The index of the default property
        /// </devdoc>
        private int           defaultIndex = -1;
        
        /// <include file='doc\COM2Properties.uex' path='docs/doc[@for="Com2Properties.currentHashTable"]/*' />
        /// <devdoc>
        /// The hashtable that owns this property manager...we have a reference to this
        /// so we can remove ourselves if we are disposed (e.g. object timeout)
        /// </devdoc>
        private Hashtable     currentHashTable;
        
        /// <include file='doc\COM2Properties.uex' path='docs/doc[@for="Com2Properties.hashCode"]/*' />
        /// <devdoc>
        /// How we find ourselves in the hashtable.  We hash ourselves based on our
        /// target object hashcode, so we can get the manager object from the
        /// target object in the hashtable.
        /// </devdoc>
        private object        hashCode;
        
        /// <include file='doc\COM2Properties.uex' path='docs/doc[@for="Com2Properties.touchedTime"]/*' />
        /// <devdoc>
        /// The timestamp of the last operation on this property manager, usually
        /// when the property list was fetched.
        /// </devdoc>
        private long          touchedTime;
        
        /// <include file='doc\COM2Properties.uex' path='docs/doc[@for="Com2Properties.nTypeInfos"]/*' />
        /// <devdoc>
        /// For IProvideMultipleClassInfo support, this is the number of typeinfos the
        /// object says it has.  If it changes, we throw away the props and refetch them.
        /// </devdoc>
        private int           nTypeInfos = -1;

#if DEBUG
        private string        dbgObjName;
        private string        dbgObjClass;
#endif

        private int          alwaysValid = 0;

        /// <include file='doc\COM2Properties.uex' path='docs/doc[@for="Com2Properties.extendedInterfaces"]/*' />
        /// <devdoc>
        /// These are the interfaces we recognize for extended browsing.
        /// </devdoc>
        private static Type[] extendedInterfaces = new Type[]{
                                                        typeof(NativeMethods.ICategorizeProperties),
                                                        typeof(NativeMethods.IProvidePropertyBuilder),
                                                        typeof(NativeMethods.IPerPropertyBrowsing),
                                                        typeof(NativeMethods.IVsPerPropertyBrowsing),
                                                        typeof(NativeMethods.IManagedPerPropertyBrowsing)};

        /// <include file='doc\COM2Properties.uex' path='docs/doc[@for="Com2Properties.extendedInterfaceHandlerTypes"]/*' />
        /// <devdoc>
        /// These are the classes of handlers corresponding to the extended
        /// interfaces above.
        /// </devdoc>
        private static Type[] extendedInterfaceHandlerTypes = new Type[]{
                                                        typeof(Com2ICategorizePropertiesHandler),
                                                        typeof(Com2IProvidePropertyBuilderHandler),
                                                        typeof(Com2IPerPropertyBrowsingHandler),
                                                        typeof(Com2IVsPerPropertyBrowsingHandler),
                                                        typeof(Com2IManagedPerPropertyBrowsingHandler)};
                                                


        /// <include file='doc\COM2Properties.uex' path='docs/doc[@for="Com2Properties.Com2Properties"]/*' />
        /// <devdoc>
        /// Default ctor.
        /// </devdoc>
        public Com2Properties(object obj, Com2PropertyDescriptor[] props, int defaultIndex) {
#if DEBUG
            ComNativeDescriptor cnd = new ComNativeDescriptor();
            this.dbgObjName = cnd.GetName(obj);
            if (this.dbgObjName == null) {
                this.dbgObjName = "(null)";
            }
            this.dbgObjClass = cnd.GetClassName(obj);
            if (this.dbgObjClass == null) {
                this.dbgObjClass = "(null)";
            }
            if (DbgCom2PropertiesSwitch.TraceVerbose) Debug.WriteLine("Creating Com2Properties for object " + dbgObjName + ", class=" + dbgObjClass);
#endif
            
            // set up our variables
            SetProps(props);
            weakObjRef = new WeakReference(obj);
            hashCode = obj.GetHashCode();

            this.defaultIndex = defaultIndex;


            // get the type infos count
            if (obj is NativeMethods.IProvideMultipleClassInfo) {
               int infos = 0;
               if (NativeMethods.Succeeded(((NativeMethods.IProvideMultipleClassInfo)obj).GetMultiTypeInfoCount(ref infos))) {
                  this.nTypeInfos = infos;
               }
            }
        }

        internal bool AlwaysValid {
            get {
                return this.alwaysValid > 0;
            }
            set {
                if (value) {
                    if (alwaysValid == 0 && !CheckValid()) {
                        return;
                    }
                    this.alwaysValid++;
                }
                else {
                    if (alwaysValid > 0) {
                        this.alwaysValid--;
                    }
                }
            }
        }

        /// <include file='doc\COM2Properties.uex' path='docs/doc[@for="Com2Properties.DefaultProperty"]/*' />
        /// <devdoc>
        /// Retrieve the default property.
        /// </devdoc>
        public Com2PropertyDescriptor DefaultProperty{
            get{
                if (!CheckValid()) {
                    return null;
                }
                if (defaultIndex == -1) {
                    if (props.Length > 0) {
                        return props[0];
                    }
                    else {
                        return null;
                    }
                }
                Debug.Assert(defaultIndex < props.Length, "Whoops! default index is > props.Length");
                return props[defaultIndex];
            }
        }

        /// <include file='doc\COM2Properties.uex' path='docs/doc[@for="Com2Properties.TargetObject"]/*' />
        /// <devdoc>
        /// The object that created the list of properties.  This will
        /// return null if the timeout has passed or the ref has died.
        /// </devdoc>
        public object TargetObject{
            get{
                if (!CheckValid() || touchedTime == 0) {
#if DEBUG
                    if (DbgCom2PropertiesSwitch.TraceVerbose) Debug.WriteLine("CheckValid called on dead object!");
#endif
                    return null;
                }
                return weakObjRef.Target;
            }
        }

        /// <include file='doc\COM2Properties.uex' path='docs/doc[@for="Com2Properties.TicksSinceTouched"]/*' />
        /// <devdoc>
        /// How long since these props have been queried.
        /// </devdoc>
        public long TicksSinceTouched{
            get{
                if (touchedTime == 0) {
                    return 0;
                }
                return DateTime.Now.Ticks - touchedTime;
            }
        }

        /// <include file='doc\COM2Properties.uex' path='docs/doc[@for="Com2Properties.Properties"]/*' />
        /// <devdoc>
        /// Returns the list of properties
        /// </devdoc>
        public Com2PropertyDescriptor[] Properties{
            get{
                CheckValid();
                if (touchedTime == 0 || props == null) {
                    return null;
                }
                touchedTime = DateTime.Now.Ticks;

                // refresh everyone!
                for (int i = 0; i < props.Length; i++) {
                    props[i].SetNeedsRefresh(Com2PropertyDescriptorRefresh.All, true);
                }

#if DEBUG
                if (DbgCom2PropertiesSwitch.TraceVerbose) Debug.WriteLine("Returning prop array for object " + dbgObjName + ", class=" + dbgObjClass);
#endif
                return props;
            }
        }

        /// <include file='doc\COM2Properties.uex' path='docs/doc[@for="Com2Properties.TooOld"]/*' />
        /// <devdoc>
        /// Should this guy be refreshed because of old age?
        /// </devdoc>
        public bool TooOld{
            get{
                CheckValid();
                if (touchedTime == 0) {
                    return false;
                }
                return TicksSinceTouched > AGE_THRESHHOLD;
            }
        }

        /// <include file='doc\COM2Properties.uex' path='docs/doc[@for="Com2Properties.AddExtendedBrowsingHandlers"]/*' />
        /// <devdoc>
        /// Checks the source object for eache extended browsing inteface
        /// listed in extendedInterfaces and creates a handler from extendedInterfaceHandlerTypes
        /// to handle it.
        /// </devdoc>
        public void AddExtendedBrowsingHandlers(Hashtable handlers) {

            object target = this.TargetObject;
            if (target == null) {
                return;
            }


            // process all our registered types
            Type t;
            for (int i = 0; i < extendedInterfaces.Length; i++) {
                t = extendedInterfaces[i];
                
                // is this object an implementor of the interface?
                //
                if (t.IsInstanceOfType(target)) {
                
                    // since handlers must be stateless, check to see if we've already
                    // created one of this type
                    //
                    Com2ExtendedBrowsingHandler handler = (Com2ExtendedBrowsingHandler)handlers[t];
                    if (handler == null) {
                        handler = (Com2ExtendedBrowsingHandler)Activator.CreateInstance(extendedInterfaceHandlerTypes[i]);
                        handlers[t] = handler;
                    }
                    
                    // make sure we got the right one
                    //
                    if (t.IsAssignableFrom(handler.Interface)) {
#if DEBUG
                        if (DbgCom2PropertiesSwitch.TraceVerbose) Debug.WriteLine("Adding browsing handler type " + handler.Interface.Name + " to object " + dbgObjName + ", class=" + dbgObjClass);
#endif
                        // allow the handler to attach itself to the appropriate properties
                        //
                        handler.SetupPropertyHandlers(props);
                    }
                    else {
                        throw new ArgumentException(SR.GetString(SR.COM2BadHandlerType, t.Name, handler.Interface.Name));
                    }
                }
            }
        }

        
        /// <include file='doc\COM2Properties.uex' path='docs/doc[@for="Com2Properties.AddToHashtable"]/*' />
        /// <devdoc>
        /// Add ourselves to the hashtable and refresh
        /// the time we were accessed
        /// </devdoc>
        public void AddToHashtable(Hashtable hash) {
            currentHashTable = hash;
            touchedTime = DateTime.Now.Ticks;
            hash.Add(hashCode, this);

        }

        public void Dispose() {
#if DEBUG
            if (DbgCom2PropertiesSwitch.TraceVerbose) Debug.WriteLine("Disposing property manager for " + dbgObjName + ", class=" + dbgObjClass);
#endif

            if (currentHashTable != null && currentHashTable.ContainsKey(hashCode)) {
                currentHashTable.Remove(hashCode);
                currentHashTable = null;
            }
            weakObjRef = null;
            props = null;
            touchedTime = 0;
        }

        /// <include file='doc\COM2Properties.uex' path='docs/doc[@for="Com2Properties.CheckValid"]/*' />
        /// <devdoc>
        /// Make sure this property list is still valid.
        ///
        /// 1) WeakRef is still alive
        /// 2) Our timeout hasn't passed
        /// </devdoc>
        public bool CheckValid() {

            if (this.AlwaysValid) {
                return true;
            }

            bool valid = weakObjRef != null && weakObjRef.IsAlive;

            // make sure we have the same number of typeInfos
            if (valid && nTypeInfos != -1) {
               int infos = 0;
               try{
                  if (NativeMethods.Succeeded(((NativeMethods.IProvideMultipleClassInfo)weakObjRef.Target).GetMultiTypeInfoCount(ref infos))) {
                     valid = (infos == this.nTypeInfos);
                  }
               }
               catch(InvalidCastException) {
                  Debug.Fail("Hmmmm...the object being inspected used to implement IProvideMultipleClassInfo, but now it doesn't?");
                  valid = false;
               }
            }
            
            if (!valid && currentHashTable != null) {
                // weak ref has died, so remove this from the hash table
                //
#if DEBUG
                if (DbgCom2PropertiesSwitch.TraceVerbose) Debug.WriteLine("Disposing reference to object " + dbgObjName + ", class=" + dbgObjClass + " (weakRef " + (weakObjRef == null ? "null" : "dead") + ")");
#endif

                Dispose();
            }

            return valid;
        }

        /// <include file='doc\COM2Properties.uex' path='docs/doc[@for="Com2Properties.SetProps"]/*' />
        /// <devdoc>
        /// Set the props for this object, and notify each property
        /// that we are now it's manager
        /// </devdoc>
        internal void SetProps(Com2PropertyDescriptor[] props) {
            this.props = props;
            if (props != null) {
                for (int i = 0; i < props.Length; i++) {
                    props[i].PropertyManager = this;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\componentmodel\com2interop\guidcamarshaler.cs ===
//------------------------------------------------------------------------------
// <copyright file="GuidCAMarshaler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms.ComponentModel.Com2Interop {
    using System.Runtime.InteropServices;
    using System.ComponentModel;

    using System.Diagnostics;
    using System;
    

    /// <include file='doc\GuidCAMarshaler.uex' path='docs/doc[@for="GuidCAMarshaler"]/*' />
    /// <devdoc>
    ///   This class performs marshaling on a CAUUID struct given
    ///   from native code.
    /// </devdoc>
    internal class GuidCAMarshaler: BaseCAMarshaler {
        public GuidCAMarshaler(NativeMethods.CA_STRUCT caStruct) : base(caStruct) {
        }

        /// <include file='doc\GuidCAMarshaler.uex' path='docs/doc[@for="GuidCAMarshaler.ItemType"]/*' />
        /// <devdoc>
        ///     Returns the type of item this marshaler will
        ///     return in the items array.  In this case, the type is Guid.
        /// </devdoc>
        public override Type ItemType {
            get {
                return typeof(Guid);
            }
        }

        protected override Array CreateArray() {
            return new Guid[Count];
        }

        /// <include file='doc\GuidCAMarshaler.uex' path='docs/doc[@for="GuidCAMarshaler.GetItemFromAddress"]/*' />
        /// <devdoc>
        ///     Override this member to perform marshalling of a single item
        ///     given it's native address.
        /// </devdoc>
        protected override object GetItemFromAddress(IntPtr addr) {
            // we actually have to read the guid in here
            int   a; //  the first 4 bytes of the guid.
            short b; //   the next 2 bytes of the guid.
            short c; //   the next 2 bytes of the guid.
            byte d; //   the next byte of the guid.
            byte e; //   the next byte of the guid.
            byte f; //   the next byte of the guid.
            byte g; //   the next byte of the guid.
            byte h; //   the next byte of the guid.
            byte i; //   the next byte of the guid.
            byte j; //   the next byte of the guid.
            byte k; //   the next byte of the guid

            int offset = 0;

            a = Marshal.ReadInt32(addr, offset);
            offset +=4;
            b = Marshal.ReadInt16(addr, offset);
            offset +=2;
            c = Marshal.ReadInt16(addr, offset);
            offset +=2;
            d = Marshal.ReadByte(addr, offset++);
            e = Marshal.ReadByte(addr, offset++);
            f = Marshal.ReadByte(addr, offset++);
            g = Marshal.ReadByte(addr, offset++);
            h = Marshal.ReadByte(addr, offset++);
            i = Marshal.ReadByte(addr, offset++);
            j = Marshal.ReadByte(addr, offset++);
            k = Marshal.ReadByte(addr, offset++);
            return new Guid(a, b, c, d, e, f, g, h, i, j, k);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\componentmodel\com2interop\com2propertydescriptorrefresh.cs ===
//------------------------------------------------------------------------------
// <copyright file="COM2PropertyDescriptorRefresh.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms.ComponentModel.Com2Interop {
    using System.ComponentModel;

    using System.Diagnostics;
        internal class Com2PropertyDescriptorRefresh{
                public const int Attributes         = 0x0001;
                public const int DisplayName        = 0x0002;
                public const int ReadOnly           = 0x0004;
                public const int TypeConverter      = 0x0020;
                public const int TypeEditor         = 0x0040;
                
                public const int All                = 0x00FF;
                
                public const int TypeConverterAttr  = 0x2000;
                public const int TypeEditorAttr     = 0x4000;
                public const int BaseAttributes     = 0x8000;
                
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\componentmodel\com2interop\com2shouldrefreshtypes.cs ===
//------------------------------------------------------------------------------
// <copyright file="COM2ShouldRefreshTypes.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms.ComponentModel.Com2Interop {
    using System.ComponentModel;

    using System.Diagnostics;

    internal enum Com2ShouldRefreshTypes{
        Attributes,
        DisplayName,
        ReadOnly,
        TypeConverter,
        TypeEditor
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\componentmodel\com2interop\com2propertypageuitypeconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="COM2PropertyPageUITypeConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------


namespace System.Windows.Forms.ComponentModel.Com2Interop {
    using System.Runtime.InteropServices;
    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;
    using System.Drawing;
    using System.Drawing.Design;
    using Microsoft.Win32;

    /// <include file='doc\COM2PropertyPageUITypeConverter.uex' path='docs/doc[@for="Com2PropertyPageUITypeEditor"]/*' />
    /// <devdoc>
    /// </devdoc>
    internal class Com2PropertyPageUITypeEditor : Com2ExtendedUITypeEditor, ICom2PropertyPageDisplayService {

        private Com2PropertyDescriptor propDesc;
        private Guid guid;

        public Com2PropertyPageUITypeEditor(Com2PropertyDescriptor pd, Guid guid, UITypeEditor baseEditor) : base(baseEditor){
            propDesc = pd;
            this.guid = guid;
        }

        public Com2PropertyPageUITypeEditor(Com2PropertyDescriptor pd, Guid guid) : this(pd, guid, pd.PropertyType){
            propDesc = pd;
            this.guid = guid;

        }

        public Com2PropertyPageUITypeEditor(Com2PropertyDescriptor pd, Guid guid, Type baseType) : base(baseType){
            propDesc = pd;
            this.guid = guid;
        }

        /// <include file='doc\COM2PropertyPageUITypeConverter.uex' path='docs/doc[@for="Com2PropertyPageUITypeEditor.EditValue"]/*' />
        /// <devdoc>
        ///     Takes the value returned from valueAccess.getValue() and modifies or replaces
        ///     the value, passing the result into valueAccess.setValue().  This is where
        ///     an editor can launch a modal dialog or create a drop down editor to allow
        ///     the user to modify the value.  Host assistance in presenting UI to the user
        ///     can be found through the valueAccess.getService function.
        /// </devdoc>
        public override object EditValue(ITypeDescriptorContext context, IServiceProvider provider, object value) {

            IntPtr hWndParent = UnsafeNativeMethods.GetFocus(); // Windows.GetForegroundWindow

            try {


                ICom2PropertyPageDisplayService propPageSvc = (ICom2PropertyPageDisplayService)provider.GetService(typeof(ICom2PropertyPageDisplayService));

                if (propPageSvc == null) {
                    propPageSvc = this;
                }

                object instance = context.Instance;

                if (!instance.GetType().IsArray) {
                    instance = propDesc.TargetObject;
                    if (instance is ICustomTypeDescriptor) {
                        instance = ((ICustomTypeDescriptor)instance).GetPropertyOwner(propDesc);
                    }
                }

                propPageSvc.ShowPropertyPage(propDesc.Name, instance, propDesc.DISPID, this.guid, hWndParent);

            } catch (Exception ex1) {
                if (provider != null) {
                      IUIService uiSvc = (IUIService)provider.GetService(typeof(IUIService));
                      if (uiSvc != null){
                        uiSvc.ShowError(ex1, SR.GetString(SR.ErrorTypeConverterFailed));
                      }
                }
            }
            return value;
        }

        /// <include file='doc\COM2PropertyPageUITypeConverter.uex' path='docs/doc[@for="Com2PropertyPageUITypeEditor.GetEditStyle"]/*' />
        /// <devdoc>
        ///      Retrieves the editing style of the Edit method.  If the method
        ///      is not supported, this will return None.
        /// </devdoc>
        public override UITypeEditorEditStyle GetEditStyle(ITypeDescriptorContext context) {
            return UITypeEditorEditStyle.Modal;
        }

        public unsafe void ShowPropertyPage(string title, object component, int dispid, Guid pageGuid, IntPtr parentHandle){
            Guid[] guids = new Guid[]{pageGuid};
            IntPtr guidsAddr = Marshal.UnsafeAddrOfPinnedArrayElement(guids, 0);

            object[] objs = component.GetType().IsArray ? (object[])component : new object[]{component};

            int nObjs =  objs.Length;
            IntPtr[] objAddrs = new IntPtr[nObjs];

            try {
                for (int i=0; i < nObjs; i++) {
                    objAddrs[i] = Marshal.GetIUnknownForObject(objs[i]);
                }

                fixed (IntPtr* pAddrs = objAddrs) {
                    SafeNativeMethods.OleCreatePropertyFrame(new HandleRef(null, parentHandle),
                                                             0, 0,
                                                             title,
                                                             nObjs,
                                                             new HandleRef(null, (IntPtr)(long)pAddrs),
                                                             1,
                                                             new HandleRef(null, guidsAddr),
                                                             SafeNativeMethods.GetThreadLCID(),
                                                             0, IntPtr.Zero );
                }
            } finally {
                for (int i=0; i < nObjs; i++) {
                    if (objAddrs[i] != IntPtr.Zero) {
                        Marshal.Release(objAddrs[i]);
                    }
                }
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\componentmodel\com2interop\icom2propertypagedisplayservice.cs ===
//------------------------------------------------------------------------------
// <copyright file="ICOM2PropertyPageDisplayService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms.ComponentModel.Com2Interop {
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Windows.Forms;    
    using System.Collections;
    using Hashtable = System.Collections.Hashtable;
    using Microsoft.Win32;

    /// <include file='doc\ICOM2PropertyPageDisplayService.uex' path='docs/doc[@for="ICom2PropertyPageDisplayService"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public interface ICom2PropertyPageDisplayService {
        /// <include file='doc\ICOM2PropertyPageDisplayService.uex' path='docs/doc[@for="ICom2PropertyPageDisplayService.ShowPropertyPage"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        void ShowPropertyPage(string title, object component, int dispid, Guid pageGuid, IntPtr parentHandle);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\componentmodel\com2interop\com2typeinfoprocessor.cs ===
//------------------------------------------------------------------------------
// <copyright file="COM2TypeInfoProcessor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms.ComponentModel.Com2Interop {
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Windows.Forms;
    using System.ComponentModel.Design;    
    using Microsoft.Win32;
    using System.Collections;
    using Hashtable = System.Collections.Hashtable;
    
    using System.Reflection.Emit;
    using System.Reflection;
    using System.Threading;
   

    /// <include file='doc\COM2TypeInfoProcessor.uex' path='docs/doc[@for="Com2TypeInfoProcessor"]/*' />
    /// <devdoc>
    /// This is the main worker class of Com2 property interop. It takes an IDispatch Object
    /// and translates it's ITypeInfo into Com2PropertyDescriptor objects that are understandable
    /// by managed code.
    ///
    /// This class only knows how to process things that are natively in the typeinfo.  Other property
    /// information such as IPerPropertyBrowsing is handled elsewhere.
    /// </devdoc>
    internal class Com2TypeInfoProcessor {
        
        #if DEBUG
        private static TraceSwitch DbgTypeInfoProcessorSwitch = new TraceSwitch("DbgTypeInfoProcessor", "Com2TypeInfoProcessor: debug Com2 type info processing");
        #else
        private static TraceSwitch DbgTypeInfoProcessorSwitch;
        #endif
        
        
        private static ModuleBuilder moduleBuilder = null;
        
        private static ModuleBuilder ModuleBuilder {
            get {
               if (moduleBuilder == null) {
                  AppDomain currentDomain =  Thread.GetDomain();
                  AssemblyName assemblyName = new AssemblyName();
                  assemblyName.Name = "COM2InteropEmit";
                  AssemblyBuilder aBuilder = currentDomain.DefineDynamicAssembly(assemblyName, AssemblyBuilderAccess.Run);
                  moduleBuilder = aBuilder.DefineDynamicModule("COM2Interop.Emit");
               }
               return moduleBuilder;
            }
        }
        
        private static Hashtable builtEnums;
        private static Hashtable processedLibraries;
        
        
        /// <include file='doc\COM2TypeInfoProcessor.uex' path='docs/doc[@for="Com2TypeInfoProcessor.BuildDropDownName"]/*' />
        /// <devdoc>
        /// Given a value and a current name, this class checks to see if the value is an integer type.
        /// if it is it adds the value, a " - ", then the value name, and returns that as the new value name
        /// If the values of an enum were 0, 1, 2, and the names were Zero, One, Two, the results would be "0 - Zero", "1 - One",
        /// and "2 - Two"
        /// </devdoc>
        public static string BuildDropDownName(Object v, string name) {
            Debug.WriteLineIf(DbgTypeInfoProcessorSwitch.TraceVerbose, "BuildDropDownName: name =" + name + ", value=" + v.ToString());
            if (name == null || name.Length == 0 || Char.IsDigit(name[0])) {
                return name;
            }

            try {
                if (v.GetType() == typeof(byte)
                    || v.GetType() == typeof(short)
                    || v.GetType() == typeof(char)
                    || v.GetType() == typeof(long)
                    || v.GetType() == typeof(int)
                    || v.GetType() == typeof(float)
                    || v.GetType() == typeof(double)) {

                    return(Convert.ToString(v) + " - " + name);
                }
            }
            catch (Exception ex) {
                Debug.Fail("BuildDropDownName: failed to convert value", ex.ToString());
            }
            return name;
        }
        
        /// <include file='doc\COM2TypeInfoProcessor.uex' path='docs/doc[@for="Com2TypeInfoProcessor.FindTypeInfo"]/*' />
        /// <devdoc>
        /// Given an Object, this attempts to locate its type ifo
        /// </devdoc>
        public static UnsafeNativeMethods.ITypeInfo FindTypeInfo(Object obj, bool wantCoClass) {
            UnsafeNativeMethods.ITypeInfo  pTypeInfo = null;

            // this is kind of odd.  What's going on here is that
            // if we want the CoClass (e.g. for the interface name),
            // we need to look for IProvideClassInfo first, then
            // look for the typeinfo from the IDispatch.
            // In the case of many OleAut32 operations, the CoClass
            // doesn't have the interface members on it, although
            // in the shell it usually does, so
            // we need to re-order the lookup if we _actually_ want
            // the CoClass if it's available.
            //

            for (int i = 0; pTypeInfo == null && i < 2; i++) {

                  if (wantCoClass == (i == 0)){
                        if (obj is NativeMethods.IProvideClassInfo) {
                            NativeMethods.IProvideClassInfo pProvideClassInfo = (NativeMethods.IProvideClassInfo)obj;
                            try {
                                pTypeInfo = pProvideClassInfo.GetClassInfo();
                            }
                            catch (Exception) {
                            }
                        }
                  }
                  else {
                       if (obj is UnsafeNativeMethods.IDispatch) {
                            UnsafeNativeMethods.IDispatch iDispatch = (UnsafeNativeMethods.IDispatch)obj;
                            try {
                                pTypeInfo = iDispatch.GetTypeInfo(0, SafeNativeMethods.GetThreadLCID());
                            }
                            catch (Exception) {
                            }
                       }
                  }

            }
            return pTypeInfo;
        }


        /// <include file='doc\COM2TypeInfoProcessor.uex' path='docs/doc[@for="Com2TypeInfoProcessor.FindTypeInfos"]/*' />
        /// <devdoc>
        /// Given an Object, this attempts to locate its type info. If it implementes IProvideMultipleClassInfo
        /// all available type infos will be returned, otherwise the primary one will be alled.
        /// </devdoc>
        private static UnsafeNativeMethods.ITypeInfo[] FindTypeInfos(Object obj, bool wantCoClass){
            
            UnsafeNativeMethods.ITypeInfo[] typeInfos = null;
            int n = 0;
            UnsafeNativeMethods.ITypeInfo temp = null;

            if (obj is NativeMethods.IProvideMultipleClassInfo) {
               NativeMethods.IProvideMultipleClassInfo pCI = (NativeMethods.IProvideMultipleClassInfo)obj;
               if (!NativeMethods.Succeeded(pCI.GetMultiTypeInfoCount(ref n)) || n == 0) {
                  n = 0;
               }

               if (n > 0){
                  typeInfos = new UnsafeNativeMethods.ITypeInfo[n];
                  
                  for (int i = 0; i < n; i++){
                     if (NativeMethods.Failed(pCI.GetInfoOfIndex(i, 1 /*MULTICLASSINFO_GETTYPEINFO*/, ref temp, 0, 0, IntPtr.Zero, IntPtr.Zero))){
                        continue;
                     }
                     Debug.Assert(temp != null, "IProvideMultipleClassInfo::GetInfoOfIndex returned S_OK for ITypeInfo index " + i + ", this is a issue in the object that's being browsed, NOT the property browser.");
                     typeInfos[i] = temp;
                  }
               }
            }

            if (typeInfos == null || typeInfos.Length == 0){
               temp = FindTypeInfo(obj, wantCoClass);
               if (temp != null) {
                   typeInfos = new UnsafeNativeMethods.ITypeInfo[]{temp};
               }
            }

            return typeInfos;
        }
        
        /// <include file='doc\COM2TypeInfoProcessor.uex' path='docs/doc[@for="Com2TypeInfoProcessor.GetNameDispId"]/*' />
        /// <devdoc>
        /// Retrieve the dispid of the property that we are to use as the name
        /// member.  In this case, the grid will put parens around the name.
        /// </devdoc>
        public static int GetNameDispId(UnsafeNativeMethods.IDispatch obj){
            int dispid = NativeMethods.DISPID_UNKNOWN;
            string[] names = null;
            
            ComNativeDescriptor cnd = ComNativeDescriptor.Instance;
            bool succeeded = false;

            // first try to find one with a valid value
            cnd.GetPropertyValue(obj, "__id", ref succeeded);
            
            if (succeeded) {
               names = new string[]{"__id"};
            }
            else {
               cnd.GetPropertyValue(obj, NativeMethods.ActiveX.DISPID_Name, ref succeeded);
               if (succeeded) {
                  dispid = NativeMethods.ActiveX.DISPID_Name;
               }
               else {
                  cnd.GetPropertyValue(obj, "Name", ref succeeded);
                  if (succeeded) {
                     names = new string[]{"Name"};
                  }
               }
            }
            
            // now get the dispid of the one that worked...
            if (names != null) {
               int[] pDispid = new int[]{NativeMethods.DISPID_UNKNOWN};
               Guid g = Guid.Empty;
               int hr = obj.GetIDsOfNames(ref g, names, 1, SafeNativeMethods.GetThreadLCID(), pDispid);
               if (NativeMethods.Succeeded(hr)){

                  dispid = pDispid[0];
               }
            }
            
            return dispid;
        }


        /// <include file='doc\COM2TypeInfoProcessor.uex' path='docs/doc[@for="Com2TypeInfoProcessor.GetProperty"]/*' />
        /// <devdoc>
        /// Gets a specific property from a Com2Object.
        /// </devdoc>
        public static PropertyDescriptor GetProperty(Object obj, string name) {
            if (obj == null || !Marshal.IsComObject(obj)) {
                return null;
            }

            UnsafeNativeMethods.ITypeInfo[] typeInfos = FindTypeInfos(obj, false);

            // oops, looks like this guy doesn't surface any type info
            // this is okay, so we just say it has no props
            if (typeInfos == null || typeInfos.Length == 0) {
                return null;
            }

            UnsafeNativeMethods.IDispatch iDispatch = (UnsafeNativeMethods.IDispatch)obj;
            string[] names = new string[]{name};
            int[] dispid = new int[1];
            Guid g = Guid.Empty;

            dispid[0] = NativeMethods.DISPID_UNKNOWN;
            int hr = iDispatch.GetIDsOfNames(ref g, names, 1, SafeNativeMethods.GetThreadLCID(), dispid);


            if (dispid[0] == NativeMethods.DISPID_UNKNOWN) {
                return null;
            }

            int defaultProp = -1;

            for (int i = 0; i < typeInfos.Length; i++) {
               PropertyDescriptor[] props = InternalGetProperties(obj, typeInfos[i], dispid[0], ref defaultProp);
               if (props != null && props.Length > 0){
                  return props[0];
               }
            }

            return null;
        }

        /// <include file='doc\COM2TypeInfoProcessor.uex' path='docs/doc[@for="Com2TypeInfoProcessor.GetProperties"]/*' />
        /// <devdoc>
        /// Gets the properties for a given Com2 Object.  The returned Com2Properties
        /// Object contains the properties and relevant data about them.
        /// </devdoc>
        public static Com2Properties GetProperties(Object obj) {
            
            Debug.WriteLineIf(DbgTypeInfoProcessorSwitch.TraceVerbose, "Com2TypeInfoProcessor.GetProperties");
            
            if (obj == null || !Marshal.IsComObject(obj)) {
                Debug.WriteLineIf(DbgTypeInfoProcessorSwitch.TraceVerbose, "Com2TypeInfoProcessor.GetProperties returning null: Object is not a com Object");
                return null;
            }

            UnsafeNativeMethods.ITypeInfo[] typeInfos = FindTypeInfos(obj, false);

            // oops, looks like this guy doesn't surface any type info
            // this is okay, so we just say it has no props
            if (typeInfos == null || typeInfos.Length == 0) {
                Debug.WriteLineIf(DbgTypeInfoProcessorSwitch.TraceVerbose, "Com2TypeInfoProcessor.GetProperties :: Didn't get typeinfo");
                return null;
            }


            int defaultProp = -1;
            int temp = -1;
            ArrayList propList = new ArrayList();
            Guid[] typeGuids = new Guid[typeInfos.Length];

            for (int i = 0; i < typeInfos.Length; i++) {
               UnsafeNativeMethods.ITypeInfo ti = typeInfos[i];

               if (ti == null) {
                   continue;
               }

               int[] versions = new int[2];
               Guid typeGuid = GetGuidForTypeInfo(ti, null, versions);
               PropertyDescriptor[] props = null;
               bool dontProcess = typeGuid != Guid.Empty && processedLibraries != null && processedLibraries.Contains(typeGuid);

               if (dontProcess) {
                    CachedProperties cp = (CachedProperties)processedLibraries[typeGuid];
                    
                    if (versions[0] == cp.MajorVersion && versions[1] == cp.MinorVersion) {
                        props = cp.Properties;
                        if (i == 0 && cp.DefaultIndex != -1) {
                            defaultProp = cp.DefaultIndex;
                        }
                    }
                    else {
                        dontProcess = false;
                    }
               }
               
               if (!dontProcess) {
                   props = InternalGetProperties(obj, ti, NativeMethods.MEMBERID_NIL, ref temp);
    
                   // only save the default property from the first type Info
                   if (i == 0 && temp != -1) {
                      defaultProp = temp;
                   }

                   if (processedLibraries == null) {
                        processedLibraries = new Hashtable();
                   }
             
                   if (typeGuid != Guid.Empty) {
                        processedLibraries[typeGuid] = new CachedProperties(props, i == 0 ? defaultProp : -1, versions[0], versions[1]);
                   }
               }

               if (props != null){
                   propList.AddRange(props);
               }
            }
            
            Debug.WriteLineIf(DbgTypeInfoProcessorSwitch.TraceVerbose, "Com2TypeInfoProcessor.GetProperties : returning " + propList.Count.ToString() + " properties");

            // done!
            Com2PropertyDescriptor[] temp2 = new Com2PropertyDescriptor[propList.Count];
            propList.CopyTo(temp2, 0);

            return new Com2Properties(obj, temp2, defaultProp);
        }

        private static Guid GetGuidForTypeInfo(UnsafeNativeMethods.ITypeInfo typeInfo, StructCache structCache, int[] versions) {
            IntPtr pTypeAttr = IntPtr.Zero;
            int hr = typeInfo.GetTypeAttr(ref pTypeAttr);
            if (!NativeMethods.Succeeded(hr)) {
                throw new ExternalException(SR.GetString(SR.TYPEINFOPROCESSORGetTypeAttrFailed, hr), hr);
            }

            Guid g = Guid.Empty;
            NativeMethods.tagTYPEATTR typeAttr = null;
            try {
                

                if (structCache == null) {
                    typeAttr = new NativeMethods.tagTYPEATTR();
                }
                else {
                    typeAttr = (NativeMethods.tagTYPEATTR)structCache.GetStruct(typeof(NativeMethods.tagTYPEATTR));
                }
                UnsafeNativeMethods.PtrToStructure(pTypeAttr, typeAttr);
                g = typeAttr.guid;
                if (versions != null) {
                    versions[0] = typeAttr.wMajorVerNum;
                    versions[1] = typeAttr.wMinorVerNum;
                }
            }
            finally {
                typeInfo.ReleaseTypeAttr(pTypeAttr);
                if (structCache != null && typeAttr != null) {
                    structCache.ReleaseStruct(typeAttr);
                }
            }

            return g;
        }


        /// <include file='doc\COM2TypeInfoProcessor.uex' path='docs/doc[@for="Com2TypeInfoProcessor.GetValueTypeFromTypeDesc"]/*' />
        /// <devdoc>
        /// Resolves a value type for a property from a TYPEDESC.  Value types can be
        /// user defined, which and may be aliased into other type infos.  This function
        /// will recusively walk the ITypeInfos to resolve the type to a clr Type.
        /// </devdoc>
        private static Type GetValueTypeFromTypeDesc(NativeMethods.tagTYPEDESC typeDesc, UnsafeNativeMethods.ITypeInfo typeInfo, Object[] typeData, StructCache structCache) {
            IntPtr hreftype;
            int hr = 0;

            switch ((NativeMethods.tagVT)typeDesc.vt) {
            default:
                return VTToType((NativeMethods.tagVT)typeDesc.vt);

            case NativeMethods.tagVT.VT_UNKNOWN:
            case NativeMethods.tagVT.VT_DISPATCH:
                // get the guid
                typeData[0] = GetGuidForTypeInfo(typeInfo, structCache, null);
                
                // return the type
                return VTToType((NativeMethods.tagVT)typeDesc.vt);

            case NativeMethods.tagVT.VT_USERDEFINED:
                // we'll need to recurse into a user defined reference typeinfo
                Debug.Assert(typeDesc.unionMember != IntPtr.Zero, "typeDesc doesn't contain an hreftype!");
                hreftype = typeDesc.unionMember;
                break;

            case NativeMethods.tagVT.VT_PTR:
                // we'll need to recurse into a user defined reference typeinfo
                Debug.Assert(typeDesc.unionMember != IntPtr.Zero, "typeDesc doesn't contain an refTypeDesc!");
                NativeMethods.tagTYPEDESC refTypeDesc = (NativeMethods.tagTYPEDESC)structCache.GetStruct(typeof(NativeMethods.tagTYPEDESC));
                
                try {

                    try {
                        //(tagTYPEDESC)Marshal.PtrToStructure(typeDesc.unionMember, typeof(tagTYPEDESC));
                        UnsafeNativeMethods.PtrToStructure(typeDesc.unionMember, refTypeDesc);
                    }
                    catch (Exception) {
                        // above is failing, why?
                        refTypeDesc = new NativeMethods.tagTYPEDESC();
                        refTypeDesc.unionMember = (IntPtr)Marshal.ReadInt32(typeDesc.unionMember);
                        refTypeDesc.vt = Marshal.ReadInt16(typeDesc.unionMember, 4);
                    }
    
                    if (refTypeDesc.vt == (int)NativeMethods.tagVT.VT_VARIANT) {
                        return VTToType((NativeMethods.tagVT)refTypeDesc.vt);
                    }
                    hreftype = refTypeDesc.unionMember;
                }
                finally {
                    structCache.ReleaseStruct(refTypeDesc);
                }
                break;
            }

            // get the reference type info
            UnsafeNativeMethods.ITypeInfo refTypeInfo = null;

            hr = typeInfo.GetRefTypeInfo(hreftype, ref refTypeInfo);
            if (!NativeMethods.Succeeded(hr)) {
                throw new ExternalException(SR.GetString(SR.TYPEINFOPROCESSORGetRefTypeInfoFailed, hr), hr);
            }

            try {
                // here is where we look at the next level type info.
                // if we get an enum, process it, otherwise we will recurse
                // or get a dispatch.
                //
                if (refTypeInfo != null) {
                    IntPtr pRefTypeAttr = IntPtr.Zero;
                    hr = refTypeInfo.GetTypeAttr(ref pRefTypeAttr);

                    if (!NativeMethods.Succeeded(hr)) {
                        
                        throw new ExternalException(SR.GetString(SR.TYPEINFOPROCESSORGetTypeAttrFailed, hr), hr);
                    }

                    NativeMethods.tagTYPEATTR refTypeAttr = (NativeMethods.tagTYPEATTR)structCache.GetStruct(typeof(NativeMethods.tagTYPEATTR));//(tagTYPEATTR)Marshal.PtrToStructure(pRefTypeAttr, typeof(tagTYPEATTR));
                    UnsafeNativeMethods.PtrToStructure(pRefTypeAttr, refTypeAttr);
                    try {
                        Guid g = refTypeAttr.guid;

                        // save the guid if we've got one here
                        if (!Guid.Empty.Equals(g)){
                            typeData[0] = g;
                        }

                        switch ((NativeMethods.tagTYPEKIND)refTypeAttr.typekind) {

                            case NativeMethods.tagTYPEKIND.TKIND_ENUM:
                                return ProcessTypeInfoEnum(refTypeInfo, structCache);
                                //return VTToType(tagVT.VT_I4);
                            case NativeMethods.tagTYPEKIND.TKIND_ALIAS:
                                // recurse here
                                return GetValueTypeFromTypeDesc(refTypeAttr.Get_tdescAlias(), refTypeInfo, typeData, structCache);
                            case NativeMethods.tagTYPEKIND.TKIND_DISPATCH:
                                return VTToType(NativeMethods.tagVT.VT_DISPATCH);
                                                        case NativeMethods.tagTYPEKIND.TKIND_INTERFACE:
                                                        case NativeMethods.tagTYPEKIND.TKIND_COCLASS:
                                return VTToType(NativeMethods.tagVT.VT_UNKNOWN);
                            default:
                                return null;
                        }
                    }
                    finally {
                        refTypeInfo.ReleaseTypeAttr(pRefTypeAttr);
                        structCache.ReleaseStruct(refTypeAttr);
                    }
                }
            }
            finally {
                refTypeInfo = null;
            }
            return null;
        }

        private static PropertyDescriptor[] InternalGetProperties(Object obj, UnsafeNativeMethods.ITypeInfo typeInfo, int dispidToGet, ref int defaultIndex) {
        
            if (typeInfo == null) {
                return null;
            }
            
            Hashtable propInfos = new Hashtable();
            
            int nameDispID = GetNameDispId((UnsafeNativeMethods.IDispatch)obj);
            bool addAboutBox = false;
            
            StructCache structCache = new StructCache();            
            
            // properties can live as functions with get_ and put_ or
            // as variables, so we do two steps here.
            try {
                // DO FUNCDESC things
                ProcessFunctions(typeInfo, propInfos, dispidToGet, nameDispID, ref addAboutBox, structCache);
            }
            catch (ExternalException ex) {
                Debug.Fail("ProcessFunctions failed with hr=" + ex.ErrorCode.ToString() + ", message=" + ex.ToString());
            }

            try {
                // DO VARDESC things.
                ProcessVariables(typeInfo, propInfos, dispidToGet, nameDispID, structCache);
            }
            catch (ExternalException ex) {
                Debug.Fail("ProcessVariables failed with hr=" + ex.ErrorCode.ToString() + ", message=" + ex.ToString());
            }

            typeInfo = null;


            // now we take the propertyInfo structures we built up
            // and use them to create the actual descriptors.
            int cProps = propInfos.Count;
            
            if (addAboutBox) {
               cProps++;
            }
            
            PropertyDescriptor[] props = new PropertyDescriptor[cProps];
            int defaultProp = -1;
            
            int hr = NativeMethods.S_OK;
            Object[] pvar = new Object[1];
            ComNativeDescriptor cnd = ComNativeDescriptor.Instance;

            // for each item in uur list, create the descriptor an check
            // if it's the default one.
            foreach (PropInfo pi in propInfos.Values){
                if (!pi.NonBrowsable) {
                    // finally, for each property, make sure we can get the value
                    // if we can't then we should mark it non-browsable

                    try {
                        hr = cnd.GetPropertyValue(obj, pi.DispId, pvar);
                    }
                    catch (ExternalException ex) {
                        hr = ex.ErrorCode;
                        Debug.WriteLineIf(DbgTypeInfoProcessorSwitch.TraceVerbose, "IDispatch::Invoke(PROPGET, " +  pi.Name + ") threw an exception :" + ex.ToString());
                    }
                    if (!NativeMethods.Succeeded(hr)) {
                        Debug.WriteLineIf(DbgTypeInfoProcessorSwitch.TraceVerbose, String.Format("Adding Browsable(false) to property '" + pi.Name + "' because Invoke(dispid=0x{0:X} ,DISPATCH_PROPERTYGET) returned hr=0x{1:X}.  Properties that do not return S_OK are hidden by default.", pi.DispId, hr));
                        pi.Attributes.Add(new BrowsableAttribute(false));
                        pi.NonBrowsable = true;
                    }
                }
                else {
                    hr = NativeMethods.S_OK;
                }

                Attribute[] temp = new Attribute[pi.Attributes.Count];
                pi.Attributes.CopyTo(temp, 0);
                //Debug.Assert(pi.nonbrowsable || pi.valueType != null, "Browsable property '" + pi.name + "' has a null type");
                props[pi.Index] = new Com2PropertyDescriptor(pi.DispId, pi.Name, temp, pi.ReadOnly != PropInfo.ReadOnlyFalse, pi.ValueType, pi.TypeData, !NativeMethods.Succeeded(hr));
                if (pi.IsDefault) {
                    defaultProp = pi.Index;
                }
            }
            
            if (addAboutBox) {
               props[props.Length-1] = new Com2AboutBoxPropertyDescriptor();
            }
            return props;
        }


        private static PropInfo ProcessDataCore(UnsafeNativeMethods.ITypeInfo typeInfo, IDictionary propInfoList, int dispid, int nameDispID, NativeMethods.tagTYPEDESC typeDesc, int flags, StructCache structCache) {
            string          pPropName = null;
            string          pPropDesc = null;


            // get the name and the helpstring
            int hr = typeInfo.GetDocumentation(dispid, ref pPropName, ref pPropDesc, null, null);

            ComNativeDescriptor cnd = ComNativeDescriptor.Instance;


            if (!NativeMethods.Succeeded(hr)) {
                throw new COMException(SR.GetString(SR.TYPEINFOPROCESSORGetDocumentationFailed, dispid, hr, cnd.GetClassName(typeInfo)), hr);
            }

            if (pPropName == null){
               Debug.Fail(String.Format("ITypeInfo::GetDocumentation didn't return a name for DISPID 0x{0:X} but returned SUCEEDED(hr),  Component=" + cnd.GetClassName(typeInfo), dispid));
               return null;
            }

            // now we can create our struct... make sure we don't already have one
            PropInfo pi = (PropInfo)propInfoList[pPropName];

            if (pi == null) {
                pi = new PropInfo();
                pi.Index = propInfoList.Count;
                propInfoList[pPropName] = pi;
                pi.Name = pPropName;
                pi.DispId = dispid;
                pi.Attributes.Add(new DispIdAttribute(pi.DispId));
            }

            if (pPropDesc != null) {
                pi.Attributes.Add(new DescriptionAttribute(pPropDesc));
            }

            // figure out the value type
            if (pi.ValueType == null) {
                Object[] pTypeData = new Object[1];
                try {
                    pi.ValueType = GetValueTypeFromTypeDesc(typeDesc, typeInfo, pTypeData, structCache);
                }
                catch (Exception ex) {
                    Debug.WriteLineIf(DbgTypeInfoProcessorSwitch.TraceVerbose, "Hiding property " + pi.Name + " because value Type could not be resolved: " + ex.ToString());
                }

                // if we can't resolve the type, mark the property as nonbrowsable
                // from the browser
                //
                if (pi.ValueType == null) {
                    pi.NonBrowsable = true;
                }

                if (pi.NonBrowsable) {
                    flags |= (int)NativeMethods.tagVARFLAGS.VARFLAG_FNONBROWSABLE;
                }

                if (pTypeData[0] != null) {
                    pi.TypeData = pTypeData[0];
                }
            }

            // check the flags
            if ((flags & (int)NativeMethods.tagVARFLAGS.VARFLAG_FREADONLY) != 0) {
                pi.ReadOnly = PropInfo.ReadOnlyTrue;
            }

            if ((flags & (int)NativeMethods.tagVARFLAGS.VARFLAG_FHIDDEN) != 0 ||
                (flags & (int)NativeMethods.tagVARFLAGS.VARFLAG_FNONBROWSABLE) != 0 ||
                pi.Name[0] == '_' ||
                dispid == NativeMethods.ActiveX.DISPID_HWND) {
                pi.Attributes.Add(new BrowsableAttribute(false));
                pi.NonBrowsable = true;
            }

            if ((flags & (int)NativeMethods.tagVARFLAGS.VARFLAG_FUIDEFAULT) != 0) {
                pi.IsDefault = true;
            }

            if ((flags & (int)NativeMethods.tagVARFLAGS.VARFLAG_FBINDABLE) != 0 &&
                (flags & (int)NativeMethods.tagVARFLAGS.VARFLAG_FDISPLAYBIND) != 0) {
                pi.Attributes.Add(new BindableAttribute(true));
            }

            // lastly, if it's DISPID_Name, add the ParenthesizeNameAttribute
            if (dispid == nameDispID){
                pi.Attributes.Add(new ParenthesizePropertyNameAttribute(true));
                
                // don't allow merges on the name
                pi.Attributes.Add(new MergablePropertyAttribute(false));
            }

            return pi;
        }

        private static void ProcessFunctions(UnsafeNativeMethods.ITypeInfo typeInfo, IDictionary propInfoList, int dispidToGet, int nameDispID, ref bool addAboutBox, StructCache structCache) {
            IntPtr pTypeAttr = IntPtr.Zero;
            int hr = typeInfo.GetTypeAttr(ref pTypeAttr);

            if (!NativeMethods.Succeeded(hr) || pTypeAttr == IntPtr.Zero) {
                throw new ExternalException(SR.GetString(SR.TYPEINFOPROCESSORGetTypeAttrFailed, hr), hr);
            }

            NativeMethods.tagTYPEATTR         typeAttr = (NativeMethods.tagTYPEATTR)structCache.GetStruct(typeof(NativeMethods.tagTYPEATTR));//(tagTYPEATTR)Marshal.PtrToStructure(pTypeAttr, typeof(tagTYPEATTR));
            UnsafeNativeMethods.PtrToStructure(pTypeAttr, typeAttr);

            try {
                if (typeAttr == null) {
                    return;
                }

                NativeMethods.tagFUNCDESC       funcDesc = (NativeMethods.tagFUNCDESC)structCache.GetStruct(typeof(NativeMethods.tagFUNCDESC));
                NativeMethods.tagELEMDESC       ed = (NativeMethods.tagELEMDESC)structCache.GetStruct(typeof(NativeMethods.tagELEMDESC));
                bool              isPropGet;
                PropInfo          pi;

                for (int i = 0; i < typeAttr.cFuncs; i++) {
                    IntPtr pFuncDesc = IntPtr.Zero;
                    hr = typeInfo.GetFuncDesc(i, ref pFuncDesc);

                    if (!NativeMethods.Succeeded(hr) || pFuncDesc == IntPtr.Zero) {
                        Debug.WriteLineIf(DbgTypeInfoProcessorSwitch.TraceVerbose, String.Format("ProcessTypeInfoEnum: ignoring function item 0x{0:X} because ITypeInfo::GetFuncDesc returned hr=0x{1:X} or NULL", hr));
                        continue;
                    }

                    //funcDesc = (tagFUNCDESC)Marshal.PtrToStructure(pFuncDesc, typeof(tagFUNCDESC));
                    UnsafeNativeMethods.PtrToStructure(pFuncDesc, funcDesc);
                    try {
                        if (funcDesc.invkind == (int)NativeMethods.tagINVOKEKIND.INVOKE_FUNC ||
                            (dispidToGet != NativeMethods.MEMBERID_NIL && funcDesc.memid != dispidToGet)) {
                            
                            if (funcDesc.memid == NativeMethods.ActiveX.DISPID_ABOUTBOX) {
                               addAboutBox = true;
                            }
                            continue;
                        }

                        NativeMethods.tagTYPEDESC typeDesc;

                        // is this a get or a put?
                        isPropGet = (funcDesc.invkind == (int)NativeMethods.tagINVOKEKIND.INVOKE_PROPERTYGET);

                        if (isPropGet) {

                            if (funcDesc.cParams != 0) {
                                
                                continue;
                            }

                            typeDesc = funcDesc.elemdescFunc.tdesc;
                        }
                        else {
                            Debug.Assert(funcDesc.lprgelemdescParam != IntPtr.Zero, "ELEMDESC param is null!");
                            if (funcDesc.lprgelemdescParam == IntPtr.Zero || funcDesc.cParams != 1) {
                                
                                continue;
                            }
                            Marshal.PtrToStructure(funcDesc.lprgelemdescParam, ed);
                            typeDesc = ed.tdesc;
                        }
                        pi = ProcessDataCore(typeInfo, propInfoList, funcDesc.memid, nameDispID, typeDesc, funcDesc.wFuncFlags, structCache);

                        // if we got a setmethod, it's not readonly
                        if (pi != null && !isPropGet) {
                            pi.ReadOnly = PropInfo.ReadOnlyFalse;
                        }
                    }
                    finally {
                        typeInfo.ReleaseFuncDesc(pFuncDesc);
                    }
                }
                structCache.ReleaseStruct(funcDesc);
                structCache.ReleaseStruct(ed);
            }
            finally {
                typeInfo.ReleaseTypeAttr(pTypeAttr);
                structCache.ReleaseStruct(typeAttr);
            }
        }

        /// <include file='doc\COM2TypeInfoProcessor.uex' path='docs/doc[@for="Com2TypeInfoProcessor.ProcessTypeInfoEnum"]/*' />
        /// <devdoc>
        /// This converts a type info that describes a IDL defined enum
        /// into one we can use
        /// </devdoc>
        private static Type ProcessTypeInfoEnum(UnsafeNativeMethods.ITypeInfo enumTypeInfo, StructCache structCache) {

            Debug.WriteLineIf(DbgTypeInfoProcessorSwitch.TraceVerbose, "ProcessTypeInfoEnum entered");

            if (enumTypeInfo == null) {
                Debug.WriteLineIf(DbgTypeInfoProcessorSwitch.TraceVerbose, "ProcessTypeInfoEnum got a NULL enumTypeInfo");
                return null;
            }

            try {
                IntPtr pTypeAttr = IntPtr.Zero;
                int hr = enumTypeInfo.GetTypeAttr(ref pTypeAttr);

                if (!NativeMethods.Succeeded(hr) || pTypeAttr == IntPtr.Zero) {
                        throw new ExternalException(SR.GetString(SR.TYPEINFOPROCESSORGetTypeAttrFailed, hr), hr);
                }

                NativeMethods.tagTYPEATTR typeAttr = (NativeMethods.tagTYPEATTR)structCache.GetStruct(typeof(NativeMethods.tagTYPEATTR));//(tagTYPEATTR)Marshal.PtrToStructure(pTypeAttr, typeof(tagTYPEATTR));
                UnsafeNativeMethods.PtrToStructure(pTypeAttr, typeAttr);

                if (pTypeAttr == IntPtr.Zero) {
                    Debug.WriteLineIf(DbgTypeInfoProcessorSwitch.TraceVerbose, "ProcessTypeInfoEnum: failed to get a typeAttr");
                    return null;
                }

                try {

                    int nItems = typeAttr.cVars;

                    Debug.WriteLineIf(DbgTypeInfoProcessorSwitch.TraceVerbose, "ProcessTypeInfoEnum: processing " + nItems.ToString() + " variables");

                    ArrayList strs = new ArrayList();
                    ArrayList vars = new ArrayList();

                    NativeMethods.tagVARDESC varDesc = (NativeMethods.tagVARDESC)structCache.GetStruct(typeof(NativeMethods.tagVARDESC));
                    Object varValue = null;
                    string enumName = null;
                    string name = null;
                    string helpstr = null;

                    enumTypeInfo.GetDocumentation(NativeMethods.MEMBERID_NIL, ref enumName, ref helpstr, null, null);
                    
                                                            // For each item in the enum type info,
                    // we just need it's name and value, and helpstring if it's there.
                    //
                    for (int i = 0; i < nItems; i++) {
                        IntPtr pVarDesc = IntPtr.Zero;
                        hr = enumTypeInfo.GetVarDesc(i, ref pVarDesc);

                        if (!NativeMethods.Succeeded(hr) || pVarDesc == IntPtr.Zero) {
                            Debug.WriteLineIf(DbgTypeInfoProcessorSwitch.TraceVerbose, String.Format("ProcessTypeInfoEnum: ignoring item 0x{0:X} because ITypeInfo::GetVarDesc returned hr=0x{1:X} or NULL", hr));
                            continue;
                        }

                        try {
                            //varDesc = (tagVARDESC)Marshal.PtrToStructure(pVarDesc, typeof(tagVARDESC));
                            UnsafeNativeMethods.PtrToStructure(pVarDesc, varDesc);

                            if (varDesc == null ||
                                varDesc.varkind != (int)NativeMethods.tagVARKIND.VAR_CONST ||
                                varDesc.unionMember == IntPtr.Zero) {
                                continue;
                            }

                            name = helpstr = null;
                            varValue = null;

                            // get the name and the helpstring

                            hr = enumTypeInfo.GetDocumentation(varDesc.memid,  ref name,  ref helpstr, null, null);


                            if (!NativeMethods.Succeeded(hr)) {
                                Debug.WriteLineIf(DbgTypeInfoProcessorSwitch.TraceVerbose, String.Format("ProcessTypeInfoEnum: ignoring item 0x{0:X} because ITypeInfo::GetDocumentation returned hr=0x{1:X} or NULL", hr));
                                continue;
                            }

                            Debug.WriteLineIf(DbgTypeInfoProcessorSwitch.TraceVerbose, "ProcessTypeInfoEnum got name=" + (name == null ? "(null)" : name) + ", helpstring=" + (helpstr == null ? "(null)" : helpstr));

                            // get the value
                            try {
                                //varValue = (VARIANT)Marshal.PtrToStructure(varDesc.unionMember, typeof(VARIANT));
                                varValue = Marshal.GetObjectForNativeVariant(varDesc.unionMember);
                            }
                            catch (Exception ex) {
                                Debug.WriteLineIf(DbgTypeInfoProcessorSwitch.TraceVerbose, "ProcessTypeInfoEnum: PtrtoStructFailed " + ex.GetType().Name + "," + ex.Message);
                            }

                            /*if (varValue == null) {
                                Debug.Fail("Couldn't get VARIANT from VARIANTDESC");
                                continue;
                            }*/

                            //variant v = varValue.ToVariant();
                            Debug.WriteLineIf(DbgTypeInfoProcessorSwitch.TraceVerbose, "ProcessTypeInfoEnum: adding variable value=" + Convert.ToString(varValue));
                            vars.Add(varValue);

                            // if we have a helpstring, use it, otherwise use name
                            string nameString;
                            if (helpstr != null) {
                                nameString = helpstr;
                            }
                            else {
                                Debug.Assert(name != null, "No name for VARDESC member, but GetDocumentation returned S_OK!");
                                nameString = name;
                            }
                            Debug.WriteLineIf(DbgTypeInfoProcessorSwitch.TraceVerbose, "ProcessTypeInfoEnum: adding name value=" + nameString);
                            strs.Add(nameString/*BuildDropDownName(varValue, nameString)*/);
                        }
                        finally {
                            if (pVarDesc != IntPtr.Zero) {
                                enumTypeInfo.ReleaseVarDesc(pVarDesc);
                            }
                        }
                    }
                    structCache.ReleaseStruct(varDesc);
                    Debug.WriteLineIf(DbgTypeInfoProcessorSwitch.TraceVerbose, "ProcessTypeInfoEnum: returning enum with " + strs.Count.ToString() + " items");

                    // just build our enumerator
                    if (strs.Count > 0) {
                        
                        // get the IUnknown value of the ITypeInfo
                        IntPtr pTypeInfoUnk = Marshal.GetIUnknownForObject(enumTypeInfo);
                        
                        try {
                           enumName = pTypeInfoUnk.ToString() + "_" + enumName;
                           
                           if (builtEnums == null) {
                              builtEnums = new Hashtable();
                           }
                           else if (builtEnums.ContainsKey(enumName)) {
                              return (Type)builtEnums[enumName];
                           }

                           Type enumType = typeof(int);

                           if (vars.Count > 0 && vars[0] != null) {
                               enumType = vars[0].GetType();
                           }
                           
                           EnumBuilder enumBuilder = ModuleBuilder.DefineEnum(enumName, TypeAttributes.Public, enumType);
                           for (int i = 0; i < strs.Count; i++) {
                              enumBuilder.DefineLiteral((string)strs[i], vars[i]);
                           }
                           Type t = enumBuilder.CreateType();
                           builtEnums[enumName] = t;
                           return t;
                        }
                        finally {
                           if (pTypeInfoUnk != IntPtr.Zero) {
                              Marshal.Release(pTypeInfoUnk);
                           }
                        }
                    }

                }
                finally {
                    enumTypeInfo.ReleaseTypeAttr(pTypeAttr);
                    structCache.ReleaseStruct(typeAttr);
                }
            }
            catch (Exception) {
            }
            return null;
        }


        private static void ProcessVariables(UnsafeNativeMethods.ITypeInfo typeInfo, IDictionary propInfoList, int dispidToGet, int nameDispID, StructCache structCache) {
            IntPtr pTypeAttr = IntPtr.Zero;
            int hr = typeInfo.GetTypeAttr(ref pTypeAttr);

            if (!NativeMethods.Succeeded(hr) || pTypeAttr == IntPtr.Zero) {
                throw new ExternalException(SR.GetString(SR.TYPEINFOPROCESSORGetTypeAttrFailed, hr), hr);
            }

            NativeMethods.tagTYPEATTR typeAttr = (NativeMethods.tagTYPEATTR)structCache.GetStruct(typeof(NativeMethods.tagTYPEATTR));//(tagTYPEATTR)Marshal.PtrToStructure(pTypeAttr, typeof(tagTYPEATTR));
            UnsafeNativeMethods.PtrToStructure(pTypeAttr, typeAttr);

            try {
                if (typeAttr == null) {
                    return;
                }
                NativeMethods.tagVARDESC        varDesc = (NativeMethods.tagVARDESC)structCache.GetStruct(typeof(NativeMethods.tagVARDESC));

                for (int i = 0; i < typeAttr.cVars; i++) {
                    IntPtr pVarDesc = IntPtr.Zero;

                    hr = typeInfo.GetVarDesc(i, ref pVarDesc);
                    if (!NativeMethods.Succeeded(hr) || pVarDesc == IntPtr.Zero) {
                        Debug.WriteLineIf(DbgTypeInfoProcessorSwitch.TraceVerbose, String.Format("ProcessTypeInfoEnum: ignoring variable item 0x{0:X} because ITypeInfo::GetFuncDesc returned hr=0x{1:X} or NULL", hr));
                        continue;
                    }

                    //varDesc = (tagVARDESC)Marshal.PtrToStructure(pVarDesc, typeof(tagVARDESC));
                    UnsafeNativeMethods.PtrToStructure(pVarDesc, varDesc);

                    try {

                        if (varDesc.varkind == (int)NativeMethods.tagVARKIND.VAR_CONST ||
                            (dispidToGet != NativeMethods.MEMBERID_NIL && varDesc.memid != dispidToGet)) {
                            continue;
                        }


                        PropInfo pi = ProcessDataCore(typeInfo, propInfoList, varDesc.memid, nameDispID, varDesc.elemdescVar.tdesc, varDesc.wVarFlags, structCache);
                        if (pi.ReadOnly != PropInfo.ReadOnlyTrue) {
                            pi.ReadOnly = PropInfo.ReadOnlyFalse;
                        }
                    }
                    finally {
                        if (pVarDesc != IntPtr.Zero) {
                            typeInfo.ReleaseVarDesc(pVarDesc);
                        }
                    }
                }
                structCache.ReleaseStruct(varDesc);
            }
            finally {
                typeInfo.ReleaseTypeAttr(pTypeAttr);
                structCache.ReleaseStruct(typeAttr);
            }
        }

        private static Type VTToType(NativeMethods.tagVT vt) {
            switch (vt) {
            case NativeMethods.tagVT.VT_EMPTY:
            case NativeMethods.tagVT.VT_NULL:
                return null;
            case NativeMethods.tagVT.VT_I1:
                return typeof(SByte);
            case NativeMethods.tagVT.VT_UI1:
                return typeof(Byte);

            case NativeMethods.tagVT.VT_I2:
                return typeof(Int16);
            case NativeMethods.tagVT.VT_UI2:
                return typeof(UInt16);
                

            case NativeMethods.tagVT.VT_I4:
            case NativeMethods.tagVT.VT_INT:
                return typeof(Int32);
            
            case NativeMethods.tagVT.VT_UI4:
            case NativeMethods.tagVT.VT_UINT:
                return typeof(UInt32);
            
            case NativeMethods.tagVT.VT_I8:
                return typeof(Int64);
            case NativeMethods.tagVT.VT_UI8:
                return typeof(UInt64);

            case NativeMethods.tagVT.VT_R4:
                return typeof(float);

            case NativeMethods.tagVT.VT_R8:
                return typeof(double);

            case NativeMethods.tagVT.VT_CY:
                return typeof(Decimal);
            case NativeMethods.tagVT.VT_DATE:
                return typeof(DateTime);
            case NativeMethods.tagVT.VT_BSTR:
            case NativeMethods.tagVT.VT_LPSTR:
            case NativeMethods.tagVT.VT_LPWSTR:
                return typeof(string);

            case NativeMethods.tagVT.VT_DISPATCH:
                return typeof(UnsafeNativeMethods.IDispatch);
            case NativeMethods.tagVT.VT_UNKNOWN:
                return typeof(Object);

            case NativeMethods.tagVT.VT_ERROR:
            case NativeMethods.tagVT.VT_HRESULT:
                return typeof(int);

            case NativeMethods.tagVT.VT_BOOL:
                return typeof(bool);

            case NativeMethods.tagVT.VT_VARIANT:
                return typeof(Com2Variant);
            case NativeMethods.tagVT.VT_CLSID:
                return typeof(Guid);

            case NativeMethods.tagVT.VT_FILETIME:
                return typeof(NativeMethods.FILETIME);

            case NativeMethods.tagVT.VT_USERDEFINED:
                throw new ArgumentException(SR.GetString(SR.COM2UnhandledVT, "VT_USERDEFINED"));

                /*case VT_ENUM:
                    if (enumNames != null || null != pPropertyInfo.GetEnum()) {
                        return typeof(IEnum);
                    }
                    goto default;*/
            case NativeMethods.tagVT.VT_VOID:
            case NativeMethods.tagVT.VT_PTR:
            case NativeMethods.tagVT.VT_SAFEARRAY:
            case NativeMethods.tagVT.VT_CARRAY:

            case NativeMethods.tagVT.VT_RECORD:
            case NativeMethods.tagVT.VT_BLOB:
            case NativeMethods.tagVT.VT_STREAM:
            case NativeMethods.tagVT.VT_STORAGE:
            case NativeMethods.tagVT.VT_STREAMED_OBJECT:
            case NativeMethods.tagVT.VT_STORED_OBJECT:
            case NativeMethods.tagVT.VT_BLOB_OBJECT:
            case NativeMethods.tagVT.VT_CF:
            case NativeMethods.tagVT.VT_BSTR_BLOB:
            case NativeMethods.tagVT.VT_VECTOR:
            case NativeMethods.tagVT.VT_ARRAY:
            case NativeMethods.tagVT.VT_BYREF:
            case NativeMethods.tagVT.VT_RESERVED:
            default:
                throw new ArgumentException(SR.GetString(SR.COM2UnhandledVT, ((int)vt).ToString()));
            }
        }

        internal class CachedProperties {

            private PropertyDescriptor[] props;

            public readonly int MajorVersion;
            public readonly int MinorVersion;
            private int defaultIndex;

            internal CachedProperties(PropertyDescriptor[] props, int defIndex, int majVersion, int minVersion) {
                this.props = ClonePropertyDescriptors(props);
                this.MajorVersion = majVersion;
                this.MinorVersion = minVersion;
                this.defaultIndex = defIndex;
            }

            public PropertyDescriptor[] Properties {
                get {
                    return ClonePropertyDescriptors(props);
                }
            }

            public int DefaultIndex {
                get {
                    return defaultIndex;
                }
            }

            private PropertyDescriptor[] ClonePropertyDescriptors(PropertyDescriptor[] props) {
                PropertyDescriptor[] retProps = new PropertyDescriptor[props.Length];
                for (int i = 0; i < props.Length; i++) {
                    if (props[i] is ICloneable) {
                        retProps[i] = (PropertyDescriptor)((ICloneable)props[i]).Clone();;
                    }
                    else {
                        retProps[i] = props[i];
                    }
                }
                return retProps;
            }
        }
        
        /// <include file='doc\COM2TypeInfoProcessor.uex' path='docs/doc[@for="Com2TypeInfoProcessor.StructCache"]/*' />
        /// <devdoc>
        /// This class manages a cache of structures that we can use
        /// for passing into native so we don't have to create them every time.
        /// for many objects, these can be used thousands of times.
        /// </devdoc>
        public class StructCache {
           
           private Hashtable queuedTypes = new Hashtable();
           
#if DEBUG
           private Hashtable releaseCheck = new Hashtable();

           ~StructCache() {
                IEnumerator enumRelease = releaseCheck.Keys.GetEnumerator();
                
                while (enumRelease.MoveNext()) {
                    Type t = (Type)enumRelease.Current;
                    if ((int)releaseCheck[t] != 0) {
                        Debug.Assert(false, "Failed to release struct of type " + t.Name);
                    }
                }      
           }
           
#endif
           
           private Queue GetQueue(Type t, bool create) {
               Object queue = queuedTypes[t];
               
               if (queue == null && create){
                  queue = new Queue();
                  queuedTypes[t] = queue;
                  #if DEBUG
                    releaseCheck[t] = 0;
                  #endif
               }
               
               return (Queue)queue;
           }
           
           public Object GetStruct(Type t) {
               Queue queue = GetQueue(t, true);
               
               Object str = null;
               
               if (queue.Count == 0) {
                  str = Activator.CreateInstance(t);
               }
               else {
                  str = queue.Dequeue();
               }
               
               #if DEBUG
                    int count = (int)releaseCheck[t];
                    releaseCheck[t] = ++count;
               #endif
               
               return str;
           }
           
           public void ReleaseStruct(Object str) {
               Type t = str.GetType();
               Queue queue = GetQueue(t, false);
               
               if (queue != null) {
                  queue.Enqueue(str);
                  
                  #if DEBUG
                    int count = (int)releaseCheck[t];
                    releaseCheck[t] = --count;
                  #endif
               } 
           }
            
        }

        private class PropInfo {

            public const int            ReadOnlyUnknown = 0;
            public const int            ReadOnlyTrue =  1;
            public const int            ReadOnlyFalse = 2;

            string               name = null;
            int                  dispid = -1;
            Type                 valueType = null;
            readonly ArrayList   attributes = new ArrayList();
            int                  readOnly = ReadOnlyUnknown;
            bool                 isDefault;
            Object               typeData;
            bool                 nonbrowsable = false;
            int                  index;

            public string Name {
                get { return name; }
                set { name = value; }
            }
            public int DispId {
                get { return dispid; }
                set { dispid = value; }
            }
            public Type ValueType {
                get { return valueType; }
                set { valueType = value; }
            }
            public ArrayList Attributes {
                get { return attributes; }
            }
            public int ReadOnly {
                get { return readOnly; }
                set { readOnly = value; }
            }
            public bool IsDefault {
                get { return isDefault; }
                set { isDefault = value; }
            }
            public object TypeData {
                get { return typeData; }
                set { typeData = value; }
            }
            public bool NonBrowsable {
                get { return nonbrowsable; }
                set { nonbrowsable = value; }
            }
            public int Index{
                get {return index;}
                set {index = value;}
            }


            public override int GetHashCode() {
                if (name != null) {
                    return name.GetHashCode();
                }
                return base.GetHashCode();
            }
        }
    }
    
    
    // just so we can recognize a variant properly...
    /// <include file='doc\COM2TypeInfoProcessor.uex' path='docs/doc[@for="Com2Variant"]/*' />
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Name="FullTrust")]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    public class Com2Variant {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\componentmodel\com2interop\icompropertybrowser.cs ===
//------------------------------------------------------------------------------
// <copyright file="IComPropertyBrowser.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------


namespace System.Windows.Forms.ComponentModel.Com2Interop {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Collections;    
    using System.ComponentModel.Design;
    using System.Windows.Forms;
    using Microsoft.Win32;

    /// <include file='doc\IComPropertyBrowser.uex' path='docs/doc[@for="IComPropertyBrowser"]/*' />
    ///<internalonly/>
    public interface IComPropertyBrowser {

        /// <include file='doc\IComPropertyBrowser.uex' path='docs/doc[@for="IComPropertyBrowser.DropDownDone"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        void DropDownDone();

        /// <include file='doc\IComPropertyBrowser.uex' path='docs/doc[@for="IComPropertyBrowser.InPropertySet"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
    
        bool InPropertySet{get;}
        /// <include file='doc\IComPropertyBrowser.uex' path='docs/doc[@for="IComPropertyBrowser.ComComponentNameChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        
        event ComponentRenameEventHandler ComComponentNameChanged;
        /// <include file='doc\IComPropertyBrowser.uex' path='docs/doc[@for="IComPropertyBrowser.EnsurePendingChangesCommitted"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        bool EnsurePendingChangesCommitted();
        /// <include file='doc\IComPropertyBrowser.uex' path='docs/doc[@for="IComPropertyBrowser.HandleF4"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        void HandleF4();
        /// <include file='doc\IComPropertyBrowser.uex' path='docs/doc[@for="IComPropertyBrowser.LoadState"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        void LoadState(RegistryKey key);
        /// <include file='doc\IComPropertyBrowser.uex' path='docs/doc[@for="IComPropertyBrowser.SaveState"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        void SaveState(RegistryKey key);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\componentmodel\com2interop\comnativedescriptor.cs ===
//------------------------------------------------------------------------------
// <copyright file="ComNativeDescriptor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------


namespace System.Windows.Forms.ComponentModel.Com2Interop {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Collections;    
    using System.ComponentModel.Design;
    using System.Windows.Forms;
    using Microsoft.Win32;

    /// <include file='doc\ComNativeDescriptor.uex' path='docs/doc[@for="ComNativeDescriptor"]/*' />
    /// <devdoc>
    ///     Top level mapping layer between COM Object and TypeDescriptor.
    ///
    /// </devdoc>
    internal class ComNativeDescriptor : IComNativeDescriptorHandler {
      
        private static ComNativeDescriptor handler = null;
        
        public static ComNativeDescriptor Instance {
            get {
                if (handler == null) {
                    handler = new ComNativeDescriptor();
                }
                return handler;
            }
        }

        public string GetClassName(Object component) {

            string name = null;

            // does IVsPerPropretyBrowsing supply us a name?
            if (component is NativeMethods.IVsPerPropertyBrowsing) {
               int hr = ((NativeMethods.IVsPerPropertyBrowsing)component).GetClassName(ref name);
               if (NativeMethods.Succeeded(hr) && name != null) {
                  return name;
               }
               // otherwise fall through...
            }

            UnsafeNativeMethods.ITypeInfo  pTypeInfo = Com2TypeInfoProcessor.FindTypeInfo(component, true);

            if (pTypeInfo == null) {
                //Debug.Fail("The current component failed to return an ITypeInfo");
                return "";
            }

            if (pTypeInfo != null) {
                string desc = null;
                try {
                    pTypeInfo.GetDocumentation(NativeMethods.MEMBERID_NIL, ref name, ref desc, null, null);
                    
                    // strip the leading underscores
                    while (name != null && name.Length > 0 && name[0] == '_') {
                        name = name.Substring(1);
                    }
                    return name;
                }
                catch (Exception) {
                }
            }
            return "";
        }
        
        public TypeConverter GetConverter(Object component) {
            return TypeDescriptor.GetConverter(typeof(IComponent));
        }
        
        public Object GetEditor(Object component, Type baseEditorType) {
            return TypeDescriptor.GetEditor(component.GetType(), baseEditorType);
        }

        public string GetName(Object component) {

            if (!(component is UnsafeNativeMethods.IDispatch)) {
                return "";
            }
            
            int dispid = Com2TypeInfoProcessor.GetNameDispId((UnsafeNativeMethods.IDispatch)component);
            if (dispid != NativeMethods.MEMBERID_NIL) {
                bool success = false;
                object value = GetPropertyValue(component, dispid, ref success);
                
                if (success && value != null) {
                    return value.ToString();
                }
            }
            return "";
        }

        public Object GetPropertyValue(Object component, string propertyName, ref bool succeeded) {

            if (!(component is UnsafeNativeMethods.IDispatch)) {
                return null;
            }

            UnsafeNativeMethods.IDispatch iDispatch = (UnsafeNativeMethods.IDispatch)component;
            string[] names = new string[]{propertyName};
            int[] dispid = new int[1];
            dispid[0] = NativeMethods.DISPID_UNKNOWN;
            Guid g = Guid.Empty;
            try {
               int hr = iDispatch.GetIDsOfNames(ref g, names, 1, SafeNativeMethods.GetThreadLCID(), dispid);
   
               if (dispid[0] == NativeMethods.DISPID_UNKNOWN || NativeMethods.Failed(hr)) {
                   return null;
               }
            }
            catch(Exception) {
                return null;   
            }
            return GetPropertyValue(component, dispid[0], ref succeeded);
        }

        public Object GetPropertyValue(Object component, int dispid, ref bool succeeded) {
            if (!(component is UnsafeNativeMethods.IDispatch)) {
                return null;
            }
            Object[] pVarResult = new Object[1];
            if (GetPropertyValue(component, dispid, pVarResult) == NativeMethods.S_OK) {
                succeeded = true;
                return pVarResult[0];
            }
            else {
                succeeded = false;
                return null;
            }
        }

        internal int GetPropertyValue(Object component, int dispid, Object[] retval) {
            if (!(component is UnsafeNativeMethods.IDispatch)) {
                return NativeMethods.E_NOINTERFACE;
            }
            UnsafeNativeMethods.IDispatch iDispatch = (UnsafeNativeMethods.IDispatch)component;
            try {
                Guid g = Guid.Empty;
                NativeMethods.tagEXCEPINFO pExcepInfo = new NativeMethods.tagEXCEPINFO();
                int hr;

                try{

                   hr = iDispatch.Invoke(dispid,
                                             ref g,
                                             SafeNativeMethods.GetThreadLCID(),
                                             NativeMethods.DISPATCH_PROPERTYGET,
                                             new NativeMethods.tagDISPPARAMS(),
                                             retval,
                                             pExcepInfo, null);

                   /*if (hr != NativeMethods.S_OK){
                     Com2PropertyDescriptor.PrintExceptionInfo(pExcepInfo);

                   } */
                   if (hr == NativeMethods.DISP_E_EXCEPTION) {
                       hr = pExcepInfo.scode;
                   }

                }
                catch(ExternalException ex){
                    hr = ex.ErrorCode;
                }
                return hr;
            }
            catch (Exception) {
                //Debug.Fail(e.ToString() + " " + component.GetType().GUID.ToString() + " " + component.ToString());
            }
            return NativeMethods.E_FAIL;
        }

        /// <include file='doc\ComNativeDescriptor.uex' path='docs/doc[@for="ComNativeDescriptor.IsNameDispId"]/*' />
        /// <devdoc>
        /// Checks if the given dispid matches the dispid that the Object would like to specify
        /// as its identification proeprty (Name, ID, etc).
        /// </devdoc>
        public bool IsNameDispId(Object obj, int dispid) {
            if (obj == null || !obj.GetType().IsCOMObject) {
                return false;
            }
            return dispid == Com2TypeInfoProcessor.GetNameDispId((UnsafeNativeMethods.IDispatch)obj);
        }

        private AttributeCollection staticAttrs = new AttributeCollection(new Attribute[]{BrowsableAttribute.Yes, DesignTimeVisibleAttribute.No});

        /// <include file='doc\ComNativeDescriptor.uex' path='docs/doc[@for="ComNativeDescriptor.nativeProps"]/*' />
        /// <devdoc>
        /// Our collection of Object managers (Com2Properties) for native properties
        /// </devdoc>
        private Hashtable         nativeProps = new Hashtable();
        
        /// <include file='doc\ComNativeDescriptor.uex' path='docs/doc[@for="ComNativeDescriptor.extendedBrowsingHandlers"]/*' />
        /// <devdoc>
        /// Our collection of browsing handlers, which are stateless and shared across objects.
        /// </devdoc>
        private Hashtable         extendedBrowsingHandlers = new Hashtable();
        
        /// <include file='doc\ComNativeDescriptor.uex' path='docs/doc[@for="ComNativeDescriptor.clearCount"]/*' />
        /// <devdoc>
        /// We increment this every time we look at an Object, at specified
        /// intervals, we run through the properies list to see if we should
        /// delete any.
        /// </devdoc>
        private int               clearCount  = 0;
        private const  int        CLEAR_INTERVAL = 25;

        /// <include file='doc\ComNativeDescriptor.uex' path='docs/doc[@for="ComNativeDescriptor.CheckClear"]/*' />
        /// <devdoc>
        /// Checks all our property manages to see if any have become invalid.
        /// </devdoc>
        private void CheckClear(Object component) {
            
            // walk the list every so many calls
            if ((++clearCount % CLEAR_INTERVAL) == 0) {
            
               lock(nativeProps) {
                   clearCount = 0;
                   // ArrayList   removeList = null;
                   
                   ICollection propValues = nativeProps.Values;
                   Com2Properties[] props = new Com2Properties[propValues.Count];
                   
                   propValues.CopyTo(props, 0);
                   
                   for (int i = 0; i < props.Length; i++) {
                      if (props[i].TooOld) {
                           props[i].Dispose();
                      }
                   }
                }
            }
        }

        /// <include file='doc\ComNativeDescriptor.uex' path='docs/doc[@for="ComNativeDescriptor.GetPropsInfo"]/*' />
        /// <devdoc>
        /// Gets the properties manager for an Object.
        /// </devdoc>
        private Com2Properties GetPropsInfo(Object component) {
            // check caches if necessary
            //
            CheckClear(component);

            // Get the property info Object
            //
            Com2Properties propsInfo = (Com2Properties)nativeProps[component.GetHashCode()];
            
            // if we dont' have one, create one and set it up
            //
            if (propsInfo == null || !propsInfo.CheckValid()) {
                propsInfo = Com2TypeInfoProcessor.GetProperties(component);
                if (propsInfo != null) {
                    propsInfo.AddToHashtable(nativeProps);
                    propsInfo.AddExtendedBrowsingHandlers(extendedBrowsingHandlers);
                }
            }
            return propsInfo;
        }

        /// <include file='doc\ComNativeDescriptor.uex' path='docs/doc[@for="ComNativeDescriptor.GetAttributes"]/*' />
        /// <devdoc>
        /// Got attributes?
        /// </devdoc>
        public AttributeCollection GetAttributes(Object component) {

            ArrayList attrs = new ArrayList();

            if (component is NativeMethods.IManagedPerPropertyBrowsing) {
                Object[] temp = Com2IManagedPerPropertyBrowsingHandler.GetComponentAttributes((NativeMethods.IManagedPerPropertyBrowsing)component, NativeMethods.MEMBERID_NIL);
                for (int i = 0; i < temp.Length; ++i) {
                    attrs.Add(temp[i]);
                }
            }
            
            if (Com2ComponentEditor.NeedsComponentEditor(component)) {
                EditorAttribute a = new EditorAttribute(typeof(Com2ComponentEditor), typeof(ComponentEditor));
                attrs.Add(a);
            }

            if (attrs == null || attrs.Count == 0) {
                return staticAttrs;
            }
            else {
                Attribute[] temp = new Attribute[attrs.Count];
                attrs.CopyTo(temp, 0);
                return new AttributeCollection(temp);
            }
        }

        /// <include file='doc\ComNativeDescriptor.uex' path='docs/doc[@for="ComNativeDescriptor.GetDefaultProperty"]/*' />
        /// <devdoc>
        /// Default Property, please
        /// </devdoc>
        public PropertyDescriptor GetDefaultProperty(Object component) {
            CheckClear(component);

            Com2Properties propsInfo = GetPropsInfo(component);
            if (propsInfo != null) {
                return propsInfo.DefaultProperty;
            }
            return null;
        }

        public EventDescriptorCollection GetEvents(Object component) {
            return new EventDescriptorCollection(null);
        }

        public EventDescriptorCollection GetEvents(Object component, Attribute[] attributes) {
            return new EventDescriptorCollection(null);
        }

        public EventDescriptor GetDefaultEvent(Object component) {
            return null;
        }

        /// <include file='doc\ComNativeDescriptor.uex' path='docs/doc[@for="ComNativeDescriptor.GetProperties"]/*' />
        /// <devdoc>
        /// Props!
        /// </devdoc>
        public PropertyDescriptorCollection GetProperties(Object component, Attribute[] attributes) {
            
            Com2Properties propsInfo = GetPropsInfo(component);

            if (propsInfo == null) {
                return PropertyDescriptorCollection.Empty;
            }

            try {
                propsInfo.AlwaysValid = true;
                ArrayList propDescList = null;
                PropertyDescriptor[] props = propsInfo.Properties;
                
                for (int i=0; i < props.Length; i++) {
                    if (!props[i].Attributes.Contains(attributes)) {
                        if (propDescList == null) {
                            propDescList = new ArrayList();
                            
                            // add all the ones we've passed
                            if (i > 0) {
                                // since I can't add a subrange!
                                for (int j = 0; j < i; j++) {
                                    propDescList.Add(props[j]);
                                }
                            }
                         }
                         continue;
                    }
                    else if (propDescList != null){
                        propDescList.Add(props[i]);
                    }
                }
                
                if (propDescList != null) {
                    props = new PropertyDescriptor[propDescList.Count];
                    propDescList.CopyTo(props, 0);
                }
    
                //Debug.Assert(propDescList.Count > 0, "Didn't add any properties! (propInfos=0)");
                return new PropertyDescriptorCollection(props);
            }
            finally {
                propsInfo.AlwaysValid = false;
            }
        }

        /// <include file='doc\ComNativeDescriptor.uex' path='docs/doc[@for="ComNativeDescriptor.ResolveVariantTypeConverterAndTypeEditor"]/*' />
        /// <devdoc>
        /// Looks at at value's type and creates an editor based on that.  We use this to decide which editor to use
        /// for a generic variant.
        /// </devdoc>
        public static void ResolveVariantTypeConverterAndTypeEditor(Object propertyValue, ref TypeConverter currentConverter, Type editorType, ref Object currentEditor) {

            Object curValue = propertyValue;
            if (curValue != null && curValue != null && !Convert.IsDBNull(curValue)){
                  Type t = curValue.GetType();
                  TypeConverter subConverter = TypeDescriptor.GetConverter(t);
                  if (subConverter != null && subConverter.GetType() != typeof(TypeConverter)){
                     currentConverter = subConverter;
                  }
                  Object subEditor = TypeDescriptor.GetEditor(t, editorType);
                  if (subEditor != null) {
                     currentEditor = subEditor;
                  }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\componentmodel\com2interop\int32camarshaler.cs ===
//------------------------------------------------------------------------------
// <copyright file="Int32CAMarshaler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms.ComponentModel.Com2Interop {
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    

    /// <include file='doc\Int32CAMarshaler.uex' path='docs/doc[@for="Int32CAMarshaler"]/*' />
    /// <devdoc>
    ///   This class performs marshaling on a CADWORD struct given
    ///   from native code.
    /// </devdoc>
    internal class Int32CAMarshaler : BaseCAMarshaler {
        public Int32CAMarshaler(NativeMethods.CA_STRUCT caStruct) : base(caStruct) {
        }


        /// <include file='doc\Int32CAMarshaler.uex' path='docs/doc[@for="Int32CAMarshaler.ItemType"]/*' />
        /// <devdoc>
        ///     Returns the type of item this marshaler will
        ///     return in the items array.  In this case, the type is int.
        /// </devdoc>
        public override Type ItemType {
            get {
                return typeof(int);
            }
        }

        protected override Array CreateArray() {
            return new int[Count];
        }

        /// <include file='doc\Int32CAMarshaler.uex' path='docs/doc[@for="Int32CAMarshaler.GetItemFromAddress"]/*' />
        /// <devdoc>
        ///     Override this member to perform marshalling of a single item
        ///     given it's native address.
        /// </devdoc>
        protected override object GetItemFromAddress(IntPtr addr) {
            return addr.ToInt32();
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\componentmodel\com2interop\olestrcamarshaler.cs ===
//------------------------------------------------------------------------------
// <copyright file="OleStrCAMarshaler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms.ComponentModel.Com2Interop {
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;


    /// <include file='doc\OleStrCAMarshaler.uex' path='docs/doc[@for="OleStrCAMarshaler"]/*' />
    /// <devdoc>
    ///   This class performs marshaling on a CALPOLESTR struct given
    ///   from native code.
    /// </devdoc>
    internal class OleStrCAMarshaler: BaseCAMarshaler {
        public OleStrCAMarshaler(NativeMethods.CA_STRUCT caAddr) : base(caAddr) {
        }

        /// <include file='doc\OleStrCAMarshaler.uex' path='docs/doc[@for="OleStrCAMarshaler.ItemType"]/*' />
        /// <devdoc>
        ///     Returns the type of item this marshaler will
        ///     return in the items array.  In this case, the type is string.
        /// </devdoc>
        public override Type ItemType {
            get {
                return typeof(string);
            }
        }

        protected override Array CreateArray() {
            return new string[Count];
        }

        /// <include file='doc\OleStrCAMarshaler.uex' path='docs/doc[@for="OleStrCAMarshaler.GetItemFromAddress"]/*' />
        /// <devdoc>
        ///     Override this member to perform marshalling of a single item
        ///     given it's native address.
        /// </devdoc>
        protected override object GetItemFromAddress(IntPtr addr) {
            string item =  Marshal.PtrToStringUni(addr);
            // free the memory
            Marshal.FreeCoTaskMem(addr);
            return item;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\componentmodel\com2interop\_ctlbldtype.cs ===
//------------------------------------------------------------------------------
// <copyright file="_CTLBLDTYPE.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms.ComponentModel.Com2Interop {
    using System.ComponentModel;
    
    [CLSCompliant(false)]
    internal class _CTLBLDTYPE {
        public const int CTLBLDTYPE_FSTDPROPBUILDER   = 0x00000001;
        public const int CTLBLDTYPE_FINTERNALBUILDER  = 0x00000002;
        public const int CTLBLDTYPE_FEDITSOBJDIRECTLY = 0x00000004;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\design\componenteditorpage.cs ===
//------------------------------------------------------------------------------
// <copyright file="ComponentEditorPage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

namespace System.Windows.Forms.Design {
    using System.Runtime.Remoting;
    using System.ComponentModel;

    using System.Diagnostics;

    using System;
    using System.Security.Permissions;
    using System.Drawing;
    using System.Windows.Forms;
    using System.Windows.Forms.ComponentModel;
    using System.ComponentModel.Design;
    using Microsoft.Win32;

    /// <include file='doc\ComponentEditorPage.uex' path='docs/doc[@for="ComponentEditorPage"]/*' />
    /// <devdoc>
    /// <para>Provides a base implementation for a <see cref='System.Windows.Forms.Design.ComponentEditorPage'/>.</para>
    /// </devdoc>
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Name="FullTrust")]
    public abstract class ComponentEditorPage : Panel {

        IComponentEditorPageSite pageSite;
        IComponent component;
        bool firstActivate;
        bool loadRequired;
        int loading;
        Icon icon;
        bool commitOnDeactivate;

        /// <include file='doc\ComponentEditorPage.uex' path='docs/doc[@for="ComponentEditorPage.ComponentEditorPage"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Windows.Forms.Design.ComponentEditorPage'/> class.
        ///    </para>
        /// </devdoc>
        public ComponentEditorPage() : base() {
            commitOnDeactivate = false;
            firstActivate = true;
            loadRequired = false;
            loading = 0;

            Visible = false;
        }


        /// <include file='doc\ComponentEditorPage.uex' path='docs/doc[@for="ComponentEditorPage.PageSite"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the page site.</para>
        /// </devdoc>
        protected IComponentEditorPageSite PageSite {
            get { return pageSite; }
            set { pageSite = value; }
        }
        /// <include file='doc\ComponentEditorPage.uex' path='docs/doc[@for="ComponentEditorPage.Component"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the component to edit.</para>
        /// </devdoc>
        protected IComponent Component {
            get { return component; }
            set { component = value; }
        }
        /// <include file='doc\ComponentEditorPage.uex' path='docs/doc[@for="ComponentEditorPage.FirstActivate"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether the page is being activated for the first time.</para>
        /// </devdoc>
        protected bool FirstActivate {
            get { return firstActivate; }
            set { firstActivate = value; }
        }
        /// <include file='doc\ComponentEditorPage.uex' path='docs/doc[@for="ComponentEditorPage.LoadRequired"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether a load is required previous to editing.</para>
        /// </devdoc>
        protected bool LoadRequired {
            get { return loadRequired; }
            set { loadRequired = value; }
        }
        /// <include file='doc\ComponentEditorPage.uex' path='docs/doc[@for="ComponentEditorPage.Loading"]/*' />
        /// <devdoc>
        ///    <para>Indicates if loading is taking place.</para>
        /// </devdoc>
        protected int Loading {
            get { return loading; }
            set { loading = value; }
        }

        /// <include file='doc\ComponentEditorPage.uex' path='docs/doc[@for="ComponentEditorPage.CommitOnDeactivate"]/*' />
        /// <devdoc>
        ///    <para> Indicates whether an editor should apply its
        ///       changes before it is deactivated.</para>
        /// </devdoc>
        public bool CommitOnDeactivate {
            get {
                return commitOnDeactivate;
            }
            set {
                commitOnDeactivate = value;
            }
        }

        /// <include file='doc\ComponentEditorPage.uex' path='docs/doc[@for="ComponentEditorPage.CreateParams"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the creation parameters for this control.</para>
        /// </devdoc>
        protected override CreateParams CreateParams {
            [SecurityPermission(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.UnmanagedCode)]
            get {
                CreateParams cp = base.CreateParams;
                cp.Style &= ~(NativeMethods.WS_BORDER | NativeMethods.WS_OVERLAPPED | NativeMethods.WS_DLGFRAME);
                return cp;
            }
        }

        /// <include file='doc\ComponentEditorPage.uex' path='docs/doc[@for="ComponentEditorPage.Icon"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the icon for this page.</para>
        /// </devdoc>
        public Icon Icon {
            get {
                if (icon == null) {
                    icon = new Icon(typeof(ComponentEditorPage), "ComponentEditorPage.ico");
                }
                return icon;
            }
            set {
                icon = value;
            }
        }

        /// <include file='doc\ComponentEditorPage.uex' path='docs/doc[@for="ComponentEditorPage.Title"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Gets or sets the title of the page.</para>
        /// </devdoc>
        public virtual string Title {
            get {
                return base.Text;
            }
        }

        /// <include file='doc\ComponentEditorPage.uex' path='docs/doc[@for="ComponentEditorPage.Activate"]/*' />
        /// <devdoc>
        ///     Activates and displays the page.
        /// </devdoc>
        public virtual void Activate() {
            if (loadRequired) {
                EnterLoadingMode();
                LoadComponent();
                ExitLoadingMode();

                loadRequired = false;
            }
            Visible = true;
            firstActivate = false;
        }

        /// <include file='doc\ComponentEditorPage.uex' path='docs/doc[@for="ComponentEditorPage.ApplyChanges"]/*' />
        /// <devdoc>
        ///    <para>Applies changes to all the components being edited.</para>
        /// </devdoc>
        public virtual void ApplyChanges() {
            SaveComponent();
        }

        /// <include file='doc\ComponentEditorPage.uex' path='docs/doc[@for="ComponentEditorPage.Deactivate"]/*' />
        /// <devdoc>
        ///    <para>Deactivates and hides the page.</para>
        /// </devdoc>
        public virtual void Deactivate() {
            Visible = false;
        }

        /// <include file='doc\ComponentEditorPage.uex' path='docs/doc[@for="ComponentEditorPage.EnterLoadingMode"]/*' />
        /// <devdoc>
        ///    Increments the loading counter, which determines whether a page
        ///    is in loading mode.
        /// </devdoc>
        protected void EnterLoadingMode() {
            loading++;
        }

        /// <include file='doc\ComponentEditorPage.uex' path='docs/doc[@for="ComponentEditorPage.ExitLoadingMode"]/*' />
        /// <devdoc>
        ///    Decrements the loading counter, which determines whether a page
        ///    is in loading mode.
        /// </devdoc>
        protected void ExitLoadingMode() {
            Debug.Assert(loading > 0, "Unbalanced Enter/ExitLoadingMode calls");
            loading--;
        }

        /// <include file='doc\ComponentEditorPage.uex' path='docs/doc[@for="ComponentEditorPage.GetControl"]/*' />
        /// <devdoc>
        ///    <para>Gets the control that represents the window for this page.</para>
        /// </devdoc>
        public virtual Control GetControl() {
            return this;
        }

        /// <include file='doc\ComponentEditorPage.uex' path='docs/doc[@for="ComponentEditorPage.GetSelectedComponent"]/*' />
        /// <devdoc>
        ///    <para>Gets the component that is to be edited.</para>
        /// </devdoc>
        protected IComponent GetSelectedComponent() {
            return component;
        }

        /// <include file='doc\ComponentEditorPage.uex' path='docs/doc[@for="ComponentEditorPage.IsPageMessage"]/*' />
        /// <devdoc>
        ///    <para>Processes messages that could be handled by the page.</para>
        /// </devdoc>
        public virtual bool IsPageMessage(ref Message msg) {
            return PreProcessMessage(ref msg);
        }

        /// <include file='doc\ComponentEditorPage.uex' path='docs/doc[@for="ComponentEditorPage.IsFirstActivate"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether the page is being activated for the first time.</para>
        /// </devdoc>
        protected bool IsFirstActivate() {
            return firstActivate;
        }

        /// <include file='doc\ComponentEditorPage.uex' path='docs/doc[@for="ComponentEditorPage.IsLoading"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether the page is being loaded.</para>
        /// </devdoc>
        protected bool IsLoading() {
            return loading != 0;
        }

        /// <include file='doc\ComponentEditorPage.uex' path='docs/doc[@for="ComponentEditorPage.LoadComponent"]/*' />
        /// <devdoc>
        ///    <para>Loads the component into the page UI.</para>
        /// </devdoc>
        protected abstract void LoadComponent();

        /// <include file='doc\ComponentEditorPage.uex' path='docs/doc[@for="ComponentEditorPage.OnApplyComplete"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Called when the page along with its sibling
        ///       pages have applied their changes.</para>
        /// </devdoc>
        public virtual void OnApplyComplete() {
            ReloadComponent();
        }

        /// <include file='doc\ComponentEditorPage.uex' path='docs/doc[@for="ComponentEditorPage.ReloadComponent"]/*' />
        /// <devdoc>
        ///    <para>Called when the current component may have changed elsewhere
        ///       and needs to be reloded into the UI.</para>
        /// </devdoc>
        protected virtual void ReloadComponent() {
            if (Visible == false) {
                loadRequired = true;
            }
        }

        /// <include file='doc\ComponentEditorPage.uex' path='docs/doc[@for="ComponentEditorPage.SaveComponent"]/*' />
        /// <devdoc>
        ///    <para>Saves the component from the page UI.</para>
        /// </devdoc>
        protected abstract void SaveComponent();

        /// <include file='doc\ComponentEditorPage.uex' path='docs/doc[@for="ComponentEditorPage.SetDirty"]/*' />
        /// <devdoc>
        ///    <para>Sets the page to be in dirty state.</para>
        /// </devdoc>
        protected virtual void SetDirty() {
            if (IsLoading() == false) {
                pageSite.SetDirty();
            }
        }

        /// <include file='doc\ComponentEditorPage.uex' path='docs/doc[@for="ComponentEditorPage.SetComponent"]/*' />
        /// <devdoc>
        ///    <para>Sets the component to be edited.</para>
        /// </devdoc>
        public virtual void SetComponent(IComponent component) {
            this.component = component;
            loadRequired = true;
        }

        /// <include file='doc\ComponentEditorPage.uex' path='docs/doc[@for="ComponentEditorPage.SetSite"]/*' />
        /// <devdoc>
        ///     Sets the site for this page.
        /// </devdoc>
        public virtual void SetSite(IComponentEditorPageSite site) {
            this.pageSite = site;

            pageSite.GetControl().Controls.Add(this);
        }

        /// <include file='doc\ComponentEditorPage.uex' path='docs/doc[@for="ComponentEditorPage.ShowHelp"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Provides help information to the help system.</para>
        /// </devdoc>
        public virtual void ShowHelp() {
        }

        /// <include file='doc\ComponentEditorPage.uex' path='docs/doc[@for="ComponentEditorPage.SupportsHelp"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether the editor supports Help.</para>
        /// </devdoc>
        public virtual bool SupportsHelp() {
            return false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\design\iuiservice.cs ===
//------------------------------------------------------------------------------
// <copyright file="IUIService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.Design {
    
    using System;    
    using Microsoft.Win32;
    using System.Collections;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Drawing;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
    using System.Windows.Forms;

    /// <include file='doc\IUIService.uex' path='docs/doc[@for="IUIService"]/*' />
    /// <devdoc>
    ///    <para> 
    ///       Provides support
    ///       for interaction with the user
    ///       interface of the development environment object that is hosting the designer.</para>
    /// </devdoc>
    [Guid("06A9C74B-5E32-4561-BE73-381B37869F4F")]
    public interface IUIService {
        /// <include file='doc\IUIService.uex' path='docs/doc[@for="IUIService.Styles"]/*' />
        /// <devdoc>
        ///    <para> Gets or sets the collections of
        ///       styles that are specific to the host's environment.</para>
        /// </devdoc>
        IDictionary Styles {get;}
        
        /// <include file='doc\IUIService.uex' path='docs/doc[@for="IUIService.CanShowComponentEditor"]/*' />
        /// <devdoc>
        ///    <para> Indicates whether the component can 
        ///       display a ComponentDesigner.</para>
        /// </devdoc>
        bool CanShowComponentEditor(object component);

        /// <include file='doc\IUIService.uex' path='docs/doc[@for="IUIService.GetDialogOwnerWindow"]/*' />
        /// <devdoc>
        ///    <para>Gets the window that should be used for dialog parenting.</para>
        /// </devdoc>
        IWin32Window GetDialogOwnerWindow();
        

        /// <include file='doc\IUIService.uex' path='docs/doc[@for="IUIService.SetUIDirty"]/*' />
        /// <devdoc>
        ///    <para>Sets a flag indicating the UI is dirty.</para>
        /// </devdoc>
        void SetUIDirty();
                
        /// <include file='doc\IUIService.uex' path='docs/doc[@for="IUIService.ShowComponentEditor"]/*' />
        /// <devdoc>
        /// <para>Attempts to display a ComponentEditor for a component.</para>
        /// </devdoc>
        bool ShowComponentEditor(object component, IWin32Window parent);
        /// <include file='doc\IUIService.uex' path='docs/doc[@for="IUIService.ShowDialog"]/*' />
        /// <devdoc>
        ///    <para>Attempts to display the specified form in a dialog box.</para>
        /// </devdoc>
        
        DialogResult ShowDialog(Form form);

        /// <include file='doc\IUIService.uex' path='docs/doc[@for="IUIService.ShowError"]/*' />
        /// <devdoc>
        ///    <para>Displays the specified error message in a message box.</para>
        /// </devdoc>
        void ShowError(string message);

        /// <include file='doc\IUIService.uex' path='docs/doc[@for="IUIService.ShowError1"]/*' />
        /// <devdoc>
        ///    <para> Displays the specified exception
        ///       and its information in a message box.</para>
        /// </devdoc>
        void ShowError(Exception ex);

        /// <include file='doc\IUIService.uex' path='docs/doc[@for="IUIService.ShowError2"]/*' />
        /// <devdoc>
        ///    <para> Displays the specified exception
        ///       and its information in a message box.</para>
        /// </devdoc>
        void ShowError(Exception ex, string message);
        
        /// <include file='doc\IUIService.uex' path='docs/doc[@for="IUIService.ShowMessage"]/*' />
        /// <devdoc>
        ///    <para>Displays the specified message in a message box.</para>
        /// </devdoc>
        void ShowMessage(string message);

        /// <include file='doc\IUIService.uex' path='docs/doc[@for="IUIService.ShowMessage1"]/*' />
        /// <devdoc>
        ///    <para> Displays the specified message in
        ///       a message box with the specified caption.</para>
        /// </devdoc>
        void ShowMessage(string message, string caption);

        /// <include file='doc\IUIService.uex' path='docs/doc[@for="IUIService.ShowMessage2"]/*' />
        /// <devdoc>
        ///    <para> Displays the specified message in a message box with the specified caption and
        ///       buttons to place on the dialog box.</para>
        /// </devdoc>
        DialogResult ShowMessage(string message, string caption, MessageBoxButtons buttons);

        /// <include file='doc\IUIService.uex' path='docs/doc[@for="IUIService.ShowToolWindow"]/*' />
        /// <devdoc>
        ///    <para>Displays the specified tool window.</para>
        /// </devdoc>
        bool ShowToolWindow(Guid toolWindow);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\componentmodel\com2interop\com2propertydescriptor.cs ===
//------------------------------------------------------------------------------
// <copyright file="COM2PropertyDescriptor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms.ComponentModel.Com2Interop {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Reflection;
    using System.Windows.Forms;    
    using System.ComponentModel.Design;
    using Microsoft.Win32;
    using System.Collections;
    using System.Text;
    using System.Windows.Forms.Design;
    using System.Drawing.Design;
    using System.Globalization;

    /// <include file='doc\COM2PropertyDescriptor.uex' path='docs/doc[@for="Com2PropertyDescriptor"]/*' />
    /// <devdoc>
    /// This class wraps a com native property in a property descriptor.
    /// It maintains all information relative to the basic (e.g. ITypeInfo)
    /// information about the member dispid function, and converts that info
    /// to meaningful managed code information.
    ///
    /// It also allows other objects to register listeners to add extended
    /// information at runtime such as attributes of TypeConverters.
    /// </devdoc>
    [System.Security.SuppressUnmanagedCodeSecurityAttribute()]
    internal class Com2PropertyDescriptor : PropertyDescriptor, ICloneable{
        private EventHandlerList events;

        /// <include file='doc\COM2PropertyDescriptor.uex' path='docs/doc[@for="Com2PropertyDescriptor.baseReadOnly"]/*' />
        /// <devdoc>
        /// Is this guy read only?
        /// </devdoc>
        private bool baseReadOnly;
        private bool readOnly;

        /// <include file='doc\COM2PropertyDescriptor.uex' path='docs/doc[@for="Com2PropertyDescriptor.propertyType"]/*' />
        /// <devdoc>
        /// The resoved native type -> clr type
        /// </devdoc>
        private Type propertyType;

        /// <include file='doc\COM2PropertyDescriptor.uex' path='docs/doc[@for="Com2PropertyDescriptor.dispid"]/*' />
        /// <devdoc>
        /// The dispid. This is also in a DispIDAttiribute, but we
        /// need it a lot.
        /// </devdoc>
        private int  dispid;
        
        private TypeConverter   converter;
        private object          editor;

        /// <include file='doc\COM2PropertyDescriptor.uex' path='docs/doc[@for="Com2PropertyDescriptor.displayName"]/*' />
        /// <devdoc>
        /// The current display name to show for this property
        /// </devdoc>
        private string displayName;

        /// <include file='doc\COM2PropertyDescriptor.uex' path='docs/doc[@for="Com2PropertyDescriptor.typeData"]/*' />
        /// <devdoc>
        /// This is any extra data needed.  For IDispatch types, it's the GUID of
        /// the interface, etc.
        /// </devdoc>
        private object typeData;


        /// <include file='doc\COM2PropertyDescriptor.uex' path='docs/doc[@for="Com2PropertyDescriptor.refreshState"]/*' />
        /// <devdoc>
        /// Keeps track of which data members need to be refreshed.
        /// </devdoc>
        private int  refreshState;
        
        /// <include file='doc\COM2PropertyDescriptor.uex' path='docs/doc[@for="Com2PropertyDescriptor.queryRefresh"]/*' />
        /// <devdoc>
        /// Should we bother asking if refresh is needed?
        /// </devdoc>
        private bool queryRefresh;

        /// <include file='doc\COM2PropertyDescriptor.uex' path='docs/doc[@for="Com2PropertyDescriptor.com2props"]/*' />
        /// <devdoc>
        /// Our properties manager
        /// </devdoc>
        private Com2Properties com2props;


        /// <include file='doc\COM2PropertyDescriptor.uex' path='docs/doc[@for="Com2PropertyDescriptor.baseAttrs"]/*' />
        /// <devdoc>
        /// Our original baseline properties
        /// </devdoc>
        private Attribute[] baseAttrs;

        /// <include file='doc\COM2PropertyDescriptor.uex' path='docs/doc[@for="Com2PropertyDescriptor.lastValue"]/*' />
        /// <devdoc>
        /// Our cached last value -- this is only
        /// for checking if we should ask for a display value
        /// </devdoc>
        private Object lastValue;

        /// <include file='doc\COM2PropertyDescriptor.uex' path='docs/doc[@for="Com2PropertyDescriptor.typeHide"]/*' />
        /// <devdoc>
        /// For Object and dispatch types, we hide them by default.
        /// </devdoc>
        private bool   typeHide;

        /// <include file='doc\COM2PropertyDescriptor.uex' path='docs/doc[@for="Com2PropertyDescriptor.canShow"]/*' />
        /// <devdoc>
        /// Set if the metadata causes this property to always be hidden
        /// </devdoc>
        private bool   canShow;

        /// <include file='doc\COM2PropertyDescriptor.uex' path='docs/doc[@for="Com2PropertyDescriptor.hrHidden"]/*' />
        /// <devdoc>
        /// This property is hidden because its get didn't return S_OK
        /// </devdoc>
        private bool   hrHidden;

        /// <include file='doc\COM2PropertyDescriptor.uex' path='docs/doc[@for="Com2PropertyDescriptor.inAttrQuery"]/*' />
        /// <devdoc>
        /// Set if we are in the process of asking handlers for attributes
        /// </devdoc>
        private bool   inAttrQuery;

        /// <include file='doc\COM2PropertyDescriptor.uex' path='docs/doc[@for="Com2PropertyDescriptor.EventGetDynamicAttributes"]/*' />
        /// <devdoc>
        /// Our event signitures.
        /// </devdoc>
        private static readonly Object EventGetBaseAttributes      = new Object();
        private static readonly Object EventGetDynamicAttributes   = new Object();
        private static readonly Object EventShouldRefresh          = new Object();
        private static readonly Object EventGetDisplayName         = new Object();
        private static readonly Object EventGetDisplayValue        = new Object();
        private static readonly Object EventGetIsReadOnly          = new Object();
        
        
        private static readonly Object EventGetTypeConverterAndTypeEditor   = new Object();
        
        private static readonly Object EventShouldSerializeValue = new Object();
        private static readonly Object EventCanResetValue      = new Object();
        private static readonly Object EventResetValue         = new Object();

        private static readonly Guid GUID_COLOR = new Guid("{66504301-BE0F-101A-8BBB-00AA00300CAB}");
                        

        /// <include file='doc\COM2PropertyDescriptor.uex' path='docs/doc[@for="Com2PropertyDescriptor.oleTypeGuids"]/*' />
        /// <devdoc>
        /// Our map of native types that we can map to managed types for editors
        /// </devdoc>
        private static IDictionary oleConverters;

        static Com2PropertyDescriptor() {
            oleConverters = new SortedList();
            oleConverters[GUID_COLOR] = typeof(Com2ColorConverter);
            oleConverters[typeof(SafeNativeMethods.IFontDisp).GUID] = typeof(Com2FontConverter);
            oleConverters[typeof(SafeNativeMethods.IFont).GUID] = typeof(Com2FontConverter);
            oleConverters[typeof(SafeNativeMethods.IPictureDisp).GUID] = typeof(Com2PictureConverter);
            oleConverters[typeof(SafeNativeMethods.IPicture).GUID] = typeof(Com2PictureConverter);
        }
       
        /// <include file='doc\COM2PropertyDescriptor.uex' path='docs/doc[@for="Com2PropertyDescriptor.valueConverter"]/*' />
        /// <devdoc>
        /// Should we convert our type?
        /// </devdoc>
        private Com2DataTypeToManagedDataTypeConverter valueConverter;


        /// <include file='doc\COM2PropertyDescriptor.uex' path='docs/doc[@for="Com2PropertyDescriptor.Com2PropertyDescriptor"]/*' />
        /// <devdoc>
        /// Ctor.
        /// </devdoc>
        public Com2PropertyDescriptor(int dispid, string name, Attribute[] attrs, bool readOnly, Type propType, Object typeData, bool hrHidden)
        : base(name, attrs) {
            this.baseReadOnly = readOnly;
            this.readOnly = readOnly;

            this.baseAttrs = attrs;
            SetNeedsRefresh(Com2PropertyDescriptorRefresh.BaseAttributes, true);

            this.hrHidden = hrHidden;

            // readonly to begin with are always read only
            SetNeedsRefresh(Com2PropertyDescriptorRefresh.ReadOnly, readOnly);

            this.propertyType = propType;
            
            this.dispid = dispid;

            if (typeData != null) {
                this.typeData = typeData;
                if (typeData is Com2Enum) {
                     converter = new Com2EnumConverter((Com2Enum)typeData);
                }
                else if (typeData is Guid) {
                    valueConverter =  CreateOleTypeConverter((Type)oleConverters[(Guid)typeData]);
                }
            }

            // check if this thing is hidden from metadata
            this.canShow = true;

            if (attrs != null) {
                for (int i = 0; i < attrs.Length; i++) {
                    if (attrs[i].Equals(BrowsableAttribute.No) && !hrHidden) {
                        this.canShow = false;
                        break;
                    }
                }
            }
            
            if (this.canShow && (propType == typeof(Object) || (valueConverter == null && propType == typeof(UnsafeNativeMethods.IDispatch)))) {
                this.typeHide = true;
            }
        }

        protected Attribute[] BaseAttributes {
            get {

                if (GetNeedsRefresh(Com2PropertyDescriptorRefresh.BaseAttributes)) {
                    SetNeedsRefresh(Com2PropertyDescriptorRefresh.BaseAttributes, false);

                    int baseCount = baseAttrs == null ? 0 : baseAttrs.Length;

                    ArrayList attrList = new ArrayList();

                    if (baseCount != 0) {
                        attrList.AddRange(baseAttrs);
                    }

                    OnGetBaseAttributes(new GetAttributesEvent(this, attrList));

                    if (attrList.Count != baseCount) {
                        this.baseAttrs = new Attribute[attrList.Count];
                    }
                    
                    if (baseAttrs != null) {
                        attrList.CopyTo(this.baseAttrs, 0);
                    }
                    else {
                        baseAttrs = new Attribute[0];
                    }
                }

                return baseAttrs;
            }
            set {
                baseAttrs = value;
            }
        }

        /// <include file='doc\COM2PropertyDescriptor.uex' path='docs/doc[@for="Com2PropertyDescriptor.Attributes"]/*' />
        /// <devdoc>
        ///     Attributes
        /// </devdoc>
        public override AttributeCollection Attributes {
            get {
                if (this.AttributesValid || this.InAttrQuery) {
                    return base.Attributes;
                }

                // restore our base attributes
                this.AttributeArray = this.BaseAttributes;

                ArrayList newAttributes = null;

                // if we are forcing a hide
                if (typeHide && canShow) {
                    if (newAttributes == null) {
                        newAttributes = new ArrayList(AttributeArray);
                    }
                    newAttributes.Add(new BrowsableAttribute(false));
                }
                else if (hrHidden) {
                    // check to see if the get still fails
                    Object target = this.TargetObject;
                    if (target != null) {
                        int hr = new ComNativeDescriptor().GetPropertyValue(target, this.dispid, new object[1]);

                        // if not, go ahead and make this a browsable item
                        if (NativeMethods.Succeeded(hr)) {
                            // make it browsable
                            if (newAttributes == null) {
                                newAttributes = new ArrayList(AttributeArray);
                            }
                            newAttributes.Add(new BrowsableAttribute(true));
                            hrHidden = false;
                        }
                    }
                }
                
                this.inAttrQuery = true;
                try {

                    // demand get any extended attributes
                    ArrayList attrList = new ArrayList();

                    OnGetDynamicAttributes(new GetAttributesEvent(this, attrList));

                    Attribute ma;
                    
                    if (attrList.Count != 0 && newAttributes == null) {
                        newAttributes = new ArrayList(AttributeArray);
                    }

                    // push any new attributes into the base type
                    for (int i=0; i < attrList.Count; i++) {
                        ma = (Attribute)attrList[i];
                        newAttributes.Add(ma);
                    }
                }
                finally {
                    this.inAttrQuery = false;
                }

                // these are now valid.
                SetNeedsRefresh(Com2PropertyDescriptorRefresh.Attributes, false);
                
                // If we reconfigured attributes, then poke the new set back in.
                //
                if (newAttributes != null) {
                    Attribute[] temp = new Attribute[newAttributes.Count];
                    newAttributes.CopyTo(temp, 0);
                    AttributeArray = temp;
                }
                
                return base.Attributes;
            }

        }

        /// <include file='doc\COM2PropertyDescriptor.uex' path='docs/doc[@for="Com2PropertyDescriptor.AttributesValid"]/*' />
        /// <devdoc>
        ///     Checks if the attributes are valid.  Asks any clients if they
        ///     would like attributes requeried.
        /// </devdoc>
        protected bool AttributesValid{
            get{
                bool currentRefresh = !GetNeedsRefresh(Com2PropertyDescriptorRefresh.Attributes);
                if (queryRefresh) {
                    GetRefreshStateEvent rse = new GetRefreshStateEvent(this, Com2ShouldRefreshTypes.Attributes, !currentRefresh);
                    OnShouldRefresh(rse);
                    currentRefresh = !rse.Value;
                    SetNeedsRefresh(Com2PropertyDescriptorRefresh.Attributes, rse.Value);
                }
                return currentRefresh;
            }
        }

        /// <include file='doc\COM2PropertyDescriptor.uex' path='docs/doc[@for="Com2PropertyDescriptor.CanShow"]/*' />
        /// <devdoc>
        ///     Checks if this item can be shown.
        /// </devdoc>
        public bool CanShow{
            get{
                return this.canShow;
            }
        }


        /// <include file='doc\COM2PropertyDescriptor.uex' path='docs/doc[@for="Com2PropertyDescriptor.ComponentType"]/*' />
        /// <devdoc>
        ///     Retrieves the type of the component this PropertyDescriptor is bound to.
        /// </devdoc>
        public override Type ComponentType {
            get {
                return typeof(UnsafeNativeMethods.IDispatch);
            }
        }
        
        /// <include file='doc\COM2PropertyDescriptor.uex' path='docs/doc[@for="Com2PropertyDescriptor.Converter"]/*' />
        /// <devdoc>
        ///      Retrieves the type converter for this property.
        /// </devdoc>
        public override TypeConverter Converter {
            get {
               if (TypeConverterValid) {
                  return converter;
               }
               
               Object typeEd = null;
               
               GetTypeConverterAndTypeEditor(ref converter, typeof(UITypeEditor), ref typeEd);
               
               if (!TypeEditorValid) {
                  this.editor = typeEd;
                  SetNeedsRefresh(Com2PropertyDescriptorRefresh.TypeEditor, false);
               }
               SetNeedsRefresh(Com2PropertyDescriptorRefresh.TypeConverter, false);
               
               return converter;
            }
        }

        /// <include file='doc\COM2PropertyDescriptor.uex' path='docs/doc[@for="Com2PropertyDescriptor.ConvertingNativeType"]/*' />
        /// <devdoc>
        ///     Retrieves whether this component is applying a type conversion...
        /// </devdoc>
        public bool ConvertingNativeType {
            get {
                return(valueConverter != null);
            }
        }

        /// <include file='doc\COM2PropertyDescriptor.uex' path='docs/doc[@for="Com2PropertyDescriptor.Data"]/*' />
        /// <devdoc>
        ///     Returns the internal data for this item.  This is meta info
        ///     that is required to disambiguate a type.
        /// </devdoc>
        public Object Data{
            get{
                return typeData;
            }
        }

        /// <include file='doc\COM2PropertyDescriptor.uex' path='docs/doc[@for="Com2PropertyDescriptor.DefaultValue"]/*' />
        /// <devdoc>
        ///      Retrieves the default value for this property.
        /// </devdoc>
        protected virtual Object DefaultValue {
            get {
                return null;
            }
        }

        /// <include file='doc\COM2PropertyDescriptor.uex' path='docs/doc[@for="Com2PropertyDescriptor.DISPID"]/*' />
        /// <devdoc>
        ///     Retrieves the DISPID for this item
        /// </devdoc>
        public int DISPID{
            get{
                return this.dispid;
            }
        }

        /// <include file='doc\COM2PropertyDescriptor.uex' path='docs/doc[@for="Com2PropertyDescriptor.DisplayName"]/*' />
        /// <devdoc>
        ///     Gets the friendly name that should be displayed to the user in a window like
        ///     the Property Browser.
        /// </devdoc>
        public override string DisplayName {
            get {
                if (!this.DisplayNameValid) {
                    GetNameItemEvent gni = new GetNameItemEvent(this, base.DisplayName);
                    OnGetDisplayName(gni);
                    this.displayName = gni.NameString;
                    SetNeedsRefresh(Com2PropertyDescriptorRefresh.DisplayName, false);
                }
                return this.displayName;
            }
        }

        /// <include file='doc\COM2PropertyDescriptor.uex' path='docs/doc[@for="Com2PropertyDescriptor.DisplayNameValid"]/*' />
        /// <devdoc>
        ///     Checks if the property display name is valid
        ///     asks clients if they would like display name requeried.
        /// </devdoc>
        protected bool DisplayNameValid{
            get{
                bool currentRefresh = !(displayName == null || GetNeedsRefresh(Com2PropertyDescriptorRefresh.DisplayName));
                if (queryRefresh) {
                    GetRefreshStateEvent rse = new GetRefreshStateEvent(this, Com2ShouldRefreshTypes.DisplayName, !currentRefresh);
                    OnShouldRefresh(rse);
                    SetNeedsRefresh(Com2PropertyDescriptorRefresh.DisplayName, rse.Value);
                    currentRefresh = !rse.Value;
                }
                return currentRefresh;
            }
        }

        protected EventHandlerList Events {
            get {
                if (events == null) {
                    events = new EventHandlerList();
                }
                return events;
            }
        }

        protected bool InAttrQuery{
            get{
                return this.inAttrQuery;
            }
        }

        /// <include file='doc\COM2PropertyDescriptor.uex' path='docs/doc[@for="Com2PropertyDescriptor.IsReadOnly"]/*' />
        /// <devdoc>
        ///     Indicates whether this property is read only.
        /// </devdoc>
        public override bool IsReadOnly {
            get {
                if (!this.ReadOnlyValid) {
                    this.readOnly |= (this.Attributes[typeof(ReadOnlyAttribute)].Equals(ReadOnlyAttribute.Yes));
                    GetBoolValueEvent gbv = new GetBoolValueEvent(this, this.readOnly);
                    OnGetIsReadOnly(gbv);
                    this.readOnly = gbv.Value;
                    SetNeedsRefresh(Com2PropertyDescriptorRefresh.ReadOnly, false);
                }
                return this.readOnly;
            }
        }

        internal Com2Properties PropertyManager{
            set{
                this.com2props = value;
            }
            get{
                return this.com2props;
            }
        }

        /// <include file='doc\COM2PropertyDescriptor.uex' path='docs/doc[@for="Com2PropertyDescriptor.PropertyType"]/*' />
        /// <devdoc>
        ///     Retrieves the type of the property.
        /// </devdoc>
        public override Type PropertyType {
            get {
                // replace the type with the mapped converter type
                if (valueConverter != null) {
                    return valueConverter.ManagedType;
                }
                else {
                    return propertyType;
                }
            }
        }

        /// <include file='doc\COM2PropertyDescriptor.uex' path='docs/doc[@for="Com2PropertyDescriptor.ReadOnlyValid"]/*' />
        /// <devdoc>
        ///     Checks if the read only state is valid.
        ///     Asks clients if they would like read-only requeried.
        /// </devdoc>
        protected bool ReadOnlyValid{
            get{
                if (baseReadOnly) {
                    return true;
                }
                
                bool currentRefresh = !GetNeedsRefresh(Com2PropertyDescriptorRefresh.ReadOnly);
                
                if (queryRefresh) {
                    GetRefreshStateEvent rse = new GetRefreshStateEvent(this, Com2ShouldRefreshTypes.ReadOnly, !currentRefresh);
                    OnShouldRefresh(rse);
                    SetNeedsRefresh(Com2PropertyDescriptorRefresh.ReadOnly, rse.Value);
                    currentRefresh = !rse.Value;
                }
                return currentRefresh;
            }
        }

        /// <include file='doc\COM2PropertyDescriptor.uex' path='docs/doc[@for="Com2PropertyDescriptor.TargetObject"]/*' />
        /// <devdoc>
        ///     Gets the Object that this descriptor was created for.
        ///     May be null if the Object's ref has died.
        /// </devdoc>
        public virtual Object TargetObject{
            get{
                if (com2props != null) {
                    return com2props.TargetObject;
                }
                return null;
            }
        }
        
        protected bool TypeConverterValid {
            get {
                bool currentRefresh =!(converter == null || GetNeedsRefresh(Com2PropertyDescriptorRefresh.TypeConverter));
                if (queryRefresh) {
                    GetRefreshStateEvent rse = new GetRefreshStateEvent(this, Com2ShouldRefreshTypes.TypeConverter, !currentRefresh);
                    OnShouldRefresh(rse);
                    SetNeedsRefresh(Com2PropertyDescriptorRefresh.TypeConverter, rse.Value);
                    currentRefresh = !rse.Value;
                }
                return currentRefresh;
            }
        }
        
        protected bool TypeEditorValid {
            get {
                bool currentRefresh = !(editor == null || GetNeedsRefresh(Com2PropertyDescriptorRefresh.TypeEditor));
                
                if (queryRefresh) {
                    GetRefreshStateEvent rse = new GetRefreshStateEvent(this, Com2ShouldRefreshTypes.TypeEditor, !currentRefresh);
                    OnShouldRefresh(rse);
                    SetNeedsRefresh(Com2PropertyDescriptorRefresh.TypeEditor, rse.Value);
                    currentRefresh = !rse.Value;
                }
                return currentRefresh;
            }
        }


        public event GetBoolValueEventHandler QueryCanResetValue {
            add {
                Events.AddHandler(EventCanResetValue, value);
            }
            remove {
                Events.RemoveHandler(EventCanResetValue, value);
            }
        }

        public event GetAttributesEventHandler QueryGetBaseAttributes {
            add {
                Events.AddHandler(EventGetBaseAttributes, value);
            }
            remove {
                Events.RemoveHandler(EventGetBaseAttributes, value);
            }
        }

        public event GetAttributesEventHandler QueryGetDynamicAttributes {
            add {
                Events.AddHandler(EventGetDynamicAttributes, value);
            }
            remove {
                Events.RemoveHandler(EventGetDynamicAttributes, value);
            }
        }


        public event GetNameItemEventHandler QueryGetDisplayName {
            add {
                Events.AddHandler(EventGetDisplayName, value);
            }
            remove {
                Events.RemoveHandler(EventGetDisplayName, value);
            }
        }


        public event GetNameItemEventHandler QueryGetDisplayValue {
            add {
                Events.AddHandler(EventGetDisplayValue, value); 
            }
            remove {
                Events.RemoveHandler(EventGetDisplayValue, value);
            }
        }


        public event GetBoolValueEventHandler QueryGetIsReadOnly {
            add {
                Events.AddHandler(EventGetIsReadOnly, value);
            }
            remove {
                Events.RemoveHandler(EventGetIsReadOnly, value);
            }
        }


        public event GetTypeConverterAndTypeEditorEventHandler QueryGetTypeConverterAndTypeEditor {
            add {
                Events.AddHandler(EventGetTypeConverterAndTypeEditor, value);
            }
            remove {
                Events.RemoveHandler(EventGetTypeConverterAndTypeEditor, value);
            }
        }
        

        public event Com2EventHandler QueryResetValue {
            add {
                Events.AddHandler(EventResetValue, value);
            }
            remove {
                Events.RemoveHandler(EventResetValue, value);
            }
        }


        public event GetBoolValueEventHandler QueryShouldSerializeValue {
            add {
                Events.AddHandler(EventShouldSerializeValue, value);
            }
            remove {
                Events.RemoveHandler(EventShouldSerializeValue, value);
            }
        }


        public event GetRefreshStateEventHandler QueryShouldRefresh {
            add {
                Events.AddHandler(EventShouldRefresh, value);
                this.queryRefresh = (Events[EventShouldRefresh] != null);
            }
            remove {
                Events.RemoveHandler(EventShouldRefresh, value);
                this.queryRefresh = (Events[EventShouldRefresh] != null);
            }
        }

        /// <include file='doc\COM2PropertyDescriptor.uex' path='docs/doc[@for="Com2PropertyDescriptor.CanResetValue"]/*' />
        /// <devdoc>
        ///     Indicates whether reset will change the value of the component.  If there
        ///     is a DefaultValueAttribute, then this will return true if getValue returns
        ///     something different than the default value.  If there is a reset method and
        ///     a shouldPersist method, this will return what shouldPersist returns.
        ///     If there is just a reset method, this always returns true.  If none of these
        ///     cases apply, this returns false.
        /// </devdoc>
        public override bool CanResetValue(Object component) {
            if (component == this.TargetObject) {
                GetBoolValueEvent gbv = new GetBoolValueEvent(this, false);
                OnCanResetValue(gbv);
                return gbv.Value;
            }
            return false;
        }

        public object Clone() {
            return new Com2PropertyDescriptor(this.dispid, this.Name, (Attribute[])this.baseAttrs.Clone(), this.readOnly, this.propertyType, this.typeData, this.hrHidden);
        }

        /// <include file='doc\COM2PropertyDescriptor.uex' path='docs/doc[@for="Com2PropertyDescriptor.CreateOleTypeConverter"]/*' />
        /// <devdoc>
        ///     Creates a converter Object, first by looking for a ctor with a Com2ProeprtyDescriptor
        ///     parameter, then using the default ctor if it is not found.
        /// </devdoc>
        private Com2DataTypeToManagedDataTypeConverter CreateOleTypeConverter(Type t) {

            if (t == null) {
                return null;
            }

            ConstructorInfo ctor = t.GetConstructor(new Type[]{typeof(Com2PropertyDescriptor)});
            Com2DataTypeToManagedDataTypeConverter converter;
            if (ctor != null) {
                converter = (Com2DataTypeToManagedDataTypeConverter)ctor.Invoke(new Object[]{this});
            }
            else {
                converter = (Com2DataTypeToManagedDataTypeConverter)Activator.CreateInstance(t);
            }
            return converter;
        }

        /// <include file='doc\COM2PropertyDescriptor.uex' path='docs/doc[@for="Com2PropertyDescriptor.CreateAttributeCollection"]/*' />
        /// <devdoc>
        ///     Creates an instance of the member attribute collection. This can
        ///     be overriden by subclasses to return a subclass of AttributeCollection.
        /// </devdoc>
        protected override AttributeCollection CreateAttributeCollection() {
            return new AttributeCollection(AttributeArray);
        }
        
        private TypeConverter GetBaseTypeConverter() {
        
            if (PropertyType == null) {
                return new TypeConverter();
            }
            
            TypeConverter localConverter = null;
            
            TypeConverterAttribute attr = (TypeConverterAttribute)Attributes[typeof(TypeConverterAttribute)];
            if (attr != null) {
               string converterTypeName = attr.ConverterTypeName;
               if (converterTypeName != null && converterTypeName.Length > 0) {
                   Type converterType = Type.GetType(converterTypeName);
                   if (converterType != null && typeof(TypeConverter).IsAssignableFrom(converterType)) {
                       try {
                          localConverter = (TypeConverter)Activator.CreateInstance(converterType);
                          if (localConverter != null) {
                               refreshState |= Com2PropertyDescriptorRefresh.TypeConverterAttr;
                          }
                       }
                       catch (Exception ex) {
                          Debug.Fail("Failed to create TypeConverter of type '" + attr.ConverterTypeName + "' from Attribute", ex.ToString());
                       }
                   }
               }
            }
            
            // if we didn't get one from the attribute, ask the type descriptor
            if (localConverter == null) {
               // we don't want to create the value editor for the IDispatch props because
                // that will create the reference editor.  We don't want that guy!
                //
                if (!typeof(UnsafeNativeMethods.IDispatch).IsAssignableFrom(this.PropertyType)) {
                     localConverter = base.Converter;
                }
                else {
                     localConverter = new Com2IDispatchConverter(this, false);
                }
            }
            
            if (localConverter == null) {
                localConverter = new TypeConverter();
            }
            return localConverter;
        }
        
        private Object GetBaseTypeEditor(Type editorBaseType) {
            
            if (PropertyType == null) {
                return null;
            }
            
            Object localEditor = null;
            EditorAttribute attr = (EditorAttribute)Attributes[typeof(EditorAttribute)];
            if (attr != null) {
               string editorTypeName = attr.EditorBaseTypeName;
               
               if (editorTypeName != null && editorTypeName.Length > 0) {
                   Type attrEditorBaseType = Type.GetType(editorTypeName);
                   if (attrEditorBaseType != null && attrEditorBaseType == editorBaseType) {
                        Type type = Type.GetType(attr.EditorTypeName);
                        if (type != null) {
                            try {
                               localEditor = Activator.CreateInstance(type);
                               if (localEditor != null) {
                                  refreshState |= Com2PropertyDescriptorRefresh.TypeEditorAttr;
                               }
                            }
                            catch(Exception ex) {
                               Debug.Fail("Failed to create edtior of type '" + attr.EditorTypeName + "' from Attribute", ex.ToString()); 
                            }
                        }
                   }
               }
            }
            if (localEditor == null) {
                 localEditor = base.GetEditor(editorBaseType);
            }
            return localEditor;
        }

        /// <include file='doc\COM2PropertyDescriptor.uex' path='docs/doc[@for="Com2PropertyDescriptor.GetDisplayValue"]/*' />
        /// <devdoc>
        ///     Gets the value that should be displayed to the user, such as in
        ///     the Property Browser.
        /// </devdoc>
        public virtual string GetDisplayValue(string defaultValue) {

            GetNameItemEvent nie = new GetNameItemEvent(this, defaultValue);
            OnGetDisplayValue(nie);

            string str = (nie.Name == null ? null : nie.Name.ToString());
            return str;
        }

        /// <include file='doc\COM2PropertyDescriptor.uex' path='docs/doc[@for="Com2PropertyDescriptor.GetEditor"]/*' />
        /// <devdoc>
        ///      Retrieves an editor of the requested type.
        /// </devdoc>
        public override Object GetEditor(Type editorBaseType) {
               if (TypeEditorValid) {
                  return editor;
               }
               
               if (PropertyType == null) {
                   return null;
               }
               
               if (editorBaseType == typeof(UITypeEditor)) {
                  TypeConverter c = null;
                  GetTypeConverterAndTypeEditor(ref c, editorBaseType, ref editor);
                  
                  if (!TypeConverterValid) {
                     this.converter = c;
                     SetNeedsRefresh(Com2PropertyDescriptorRefresh.TypeConverter, false);
                  }
                  SetNeedsRefresh(Com2PropertyDescriptorRefresh.TypeEditor, false);
               }
               else {
                  editor = base.GetEditor(editorBaseType);
               }
               return editor;
          
        }

        /// <include file='doc\COM2PropertyDescriptor.uex' path='docs/doc[@for="Com2PropertyDescriptor.GetNativeValue"]/*' />
        /// <devdoc>
        ///     Retrieves the current native value of the property on component,
        ///     invoking the getXXX method.  An exception in the getXXX
        ///     method will pass through.
        /// </devdoc>
        public Object GetNativeValue(Object component){
            if (component == null)
                return null;

            if (component is ICustomTypeDescriptor) {
                component = ((ICustomTypeDescriptor)component).GetPropertyOwner(this);
            }

            if (component == null || !Marshal.IsComObject(component) || !(component is UnsafeNativeMethods.IDispatch))
                return null;

            UnsafeNativeMethods.IDispatch pDisp = (UnsafeNativeMethods.IDispatch)component;
            Object[] pVarResult = new Object[1];
            NativeMethods.tagEXCEPINFO pExcepInfo = new NativeMethods.tagEXCEPINFO();
            Guid g = Guid.Empty;

            int hr = pDisp.Invoke(this.dispid,
                                  ref g,
                                  SafeNativeMethods.GetThreadLCID(),
                                  NativeMethods.DISPATCH_PROPERTYGET,
                                  new NativeMethods.tagDISPPARAMS(),
                                  pVarResult,
                                  pExcepInfo, null);

            switch (hr) {
            case NativeMethods.S_OK:
            case NativeMethods.S_FALSE:

                if (pVarResult[0] == null || Convert.IsDBNull(pVarResult[0])) {
                    lastValue = null;
                }
                else {
                    lastValue = pVarResult[0];
                }
                return lastValue;
            case NativeMethods.DISP_E_EXCEPTION:
                //PrintExceptionInfo(pExcepInfo);
                return null;
            default:
                throw new ExternalException(SR.GetString(SR.DispInvokeFailed, "GetValue" , hr), hr);
            }
        }

        /// <include file='doc\COM2PropertyDescriptor.uex' path='docs/doc[@for="Com2PropertyDescriptor.GetNeedsRefresh"]/*' />
        /// <devdoc>
        ///     Checks whether the particular item(s) need refreshing.
        /// </devdoc>
        private bool GetNeedsRefresh(int mask){
            return(refreshState & mask) != 0;
        }


        /// <include file='doc\COM2PropertyDescriptor.uex' path='docs/doc[@for="Com2PropertyDescriptor.GetValue"]/*' />
        /// <devdoc>
        ///     Retrieves the current value of the property on component,
        ///     invoking the getXXX method.  An exception in the getXXX
        ///     method will pass through.
        /// </devdoc>
        public override Object GetValue(Object component) {
            lastValue = GetNativeValue(component);
            // do we need to convert the type?
            if (this.ConvertingNativeType && lastValue != null) {
                lastValue = valueConverter.ConvertNativeToManaged(lastValue, this);
            }
            else if (lastValue != null && propertyType != null && propertyType.IsEnum && lastValue.GetType().IsPrimitive) {
                // we've got to convert the value here -- we built the enum but the native object returns
                // us values as integers
                //
                try {
                    lastValue = Enum.ToObject(propertyType, lastValue);
                }
                catch {
                }
            }
            return lastValue;
        }
        
        /// <include file='doc\COM2PropertyDescriptor.uex' path='docs/doc[@for="Com2PropertyDescriptor.GetTypeConverterAndTypeEditor"]/*' />
        /// <devdoc>
        ///     Retrieves the value editor for the property.  If a value editor is passed
        ///     in as a TypeConverterAttribute, that value editor will be instantiated.
        ///     If no such attribute was found, a system value editor will be looked for.
        ///     See TypeConverter for a description of how system value editors are found.
        ///     If there is no system value editor, null is returned.  If the value editor found
        ///     takes an IEditorSite in its constructor, the parameter will be passed in.
        /// </devdoc>
        public void GetTypeConverterAndTypeEditor(ref TypeConverter typeConverter, Type editorBaseType, ref Object typeEditor) {
        
                // get the base editor and converter, attributes first
                TypeConverter localConverter = typeConverter;
                Object        localEditor    = typeEditor;
                
                if (localConverter == null) {
                     localConverter = GetBaseTypeConverter();
                }
                
                if (localEditor == null) {
                     localEditor = GetBaseTypeEditor(editorBaseType);
                }
                
                // if this is a object, get the value and attempt to create the correct value editor based on that value.
                // we don't do this if the state came from an attribute
                //
                if (0 == (refreshState & Com2PropertyDescriptorRefresh.TypeConverterAttr) && this.PropertyType == typeof(Com2Variant)) {
                    Type editorType = PropertyType;
                    Object value = GetValue(TargetObject);
                    if (value != null) {
                        editorType = value.GetType();
                    }
                    ComNativeDescriptor.ResolveVariantTypeConverterAndTypeEditor(value, ref localConverter, editorBaseType, ref localEditor);
                }
                
                // now see if someone else would like to serve up a value editor
                //
                
                // unwrap the editor if it's one of ours.
                if (localConverter is Com2PropDescMainConverter) {
                    localConverter = ((Com2PropDescMainConverter)localConverter).InnerConverter;
                }
                 
                GetTypeConverterAndTypeEditorEvent e = new GetTypeConverterAndTypeEditorEvent(this, this.TargetObject, localConverter, editorBaseType, localEditor);
                OnGetTypeConverterAndTypeEditor(e);
                localConverter = e.TypeConverter;
                localEditor    = e.TypeEditor;
                
                // just in case one of the handlers nuked our editor...
                //
                if (localConverter == null) {
                     localConverter = GetBaseTypeConverter();
                }
                
                if (localEditor == null) {
                     localEditor = GetBaseTypeEditor(editorBaseType);
                } 
                               
                // wrap the value editor in our main value editor, but only if it isn't "TypeConverter" or already a Com2PropDescMainTypeConverter
                //
                Type localConverterType = localConverter.GetType();
                if (localConverterType != typeof(TypeConverter) && localConverterType != (typeof(Com2PropDescMainConverter))) {
                    localConverter = new Com2PropDescMainConverter(this, localConverter);
                }
                
                // save the values back to the variables.
                //
                typeConverter = localConverter;
                typeEditor    = localEditor;
        }
        
        /// <include file='doc\COM2PropertyDescriptor.uex' path='docs/doc[@for="Com2PropertyDescriptor.IsCurrentValue"]/*' />
        /// <devdoc>
        ///     Is the given value equal to the last known value for this object?
        /// </devdoc>
        public bool IsCurrentValue(object value) {
            return (value == lastValue || (lastValue != null && lastValue.Equals(value)));
        }

        /// <include file='doc\COM2PropertyDescriptor.uex' path='docs/doc[@for="Com2PropertyDescriptor.OnCanResetValue"]/*' />
        /// <devdoc>
        ///     Raises the appropriate event
        /// </devdoc>
        protected void OnCanResetValue(GetBoolValueEvent gvbe) {
            RaiseGetBoolValueEvent(EventCanResetValue, gvbe);
        }

        protected void OnGetBaseAttributes(GetAttributesEvent e) {
            
            try {
                com2props.AlwaysValid = com2props.CheckValid();
    
                GetAttributesEventHandler handler = (GetAttributesEventHandler)Events[EventGetBaseAttributes];
                if (handler != null) handler(this, e);
            }
            finally {
                com2props.AlwaysValid = false;
            }
        }
        
        /// <include file='doc\COM2PropertyDescriptor.uex' path='docs/doc[@for="Com2PropertyDescriptor.OnGetDisplayName"]/*' />
        /// <devdoc>
        ///     Raises the appropriate event
        /// </devdoc>
        protected void OnGetDisplayName(GetNameItemEvent gnie) {
            RaiseGetNameItemEvent(EventGetDisplayName, gnie);
        }

        /// <include file='doc\COM2PropertyDescriptor.uex' path='docs/doc[@for="Com2PropertyDescriptor.OnGetDisplayValue"]/*' />
        /// <devdoc>
        ///     Raises the appropriate event
        /// </devdoc>
        protected void OnGetDisplayValue(GetNameItemEvent gnie) {
            RaiseGetNameItemEvent(EventGetDisplayValue, gnie);
        }

        /// <include file='doc\COM2PropertyDescriptor.uex' path='docs/doc[@for="Com2PropertyDescriptor.OnGetDynamicAttributes"]/*' />
        /// <devdoc>
        ///     Raises the appropriate event
        /// </devdoc>
        protected void OnGetDynamicAttributes(GetAttributesEvent e) {

            try {
                com2props.AlwaysValid = com2props.CheckValid();
                GetAttributesEventHandler handler = (GetAttributesEventHandler)Events[EventGetDynamicAttributes];
                if (handler != null) handler(this, e);
            }
            finally {
                com2props.AlwaysValid = false;
            }
        }



        /// <include file='doc\COM2PropertyDescriptor.uex' path='docs/doc[@for="Com2PropertyDescriptor.OnGetIsReadOnly"]/*' />
        /// <devdoc>
        ///     Raises the appropriate event
        /// </devdoc>
        protected void OnGetIsReadOnly(GetBoolValueEvent gvbe) {
            RaiseGetBoolValueEvent(EventGetIsReadOnly, gvbe);
        }

        protected void OnGetTypeConverterAndTypeEditor(GetTypeConverterAndTypeEditorEvent e) {
            try {
                com2props.AlwaysValid = com2props.CheckValid();
                GetTypeConverterAndTypeEditorEventHandler handler = (GetTypeConverterAndTypeEditorEventHandler)Events[EventGetTypeConverterAndTypeEditor];
                if (handler != null) handler(this, e);  
            }
            finally {
                com2props.AlwaysValid = false;
            }
        }
        
        /// <include file='doc\COM2PropertyDescriptor.uex' path='docs/doc[@for="Com2PropertyDescriptor.OnResetValue"]/*' />
        /// <devdoc>
        ///     Raises the appropriate event
        /// </devdoc>
        protected void OnResetValue(EventArgs e) {
            RaiseCom2Event(EventResetValue, e);
        }

        /// <include file='doc\COM2PropertyDescriptor.uex' path='docs/doc[@for="Com2PropertyDescriptor.OnShouldSerializeValue"]/*' />
        /// <devdoc>
        ///     Raises the appropriate event
        /// </devdoc>
        protected void OnShouldSerializeValue(GetBoolValueEvent gvbe) {
            RaiseGetBoolValueEvent(EventShouldSerializeValue, gvbe);
        }


        /// <include file='doc\COM2PropertyDescriptor.uex' path='docs/doc[@for="Com2PropertyDescriptor.OnShouldRefresh"]/*' />
        /// <devdoc>
        ///     Raises the appropriate event
        /// </devdoc>
        protected void OnShouldRefresh(GetRefreshStateEvent gvbe) {
            RaiseGetBoolValueEvent(EventShouldRefresh, gvbe);
        }

        /// <include file='doc\COM2PropertyDescriptor.uex' path='docs/doc[@for="Com2PropertyDescriptor.RaiseGetBoolValueEvent"]/*' />
        /// <devdoc>
        ///     Raises the appropriate event
        /// </devdoc>
        private void RaiseGetBoolValueEvent(Object key, GetBoolValueEvent e) {
            try {
                com2props.AlwaysValid = com2props.CheckValid();
                GetBoolValueEventHandler handler = (GetBoolValueEventHandler)Events[key];
                if (handler != null) handler(this, e);
            }
            finally {
                com2props.AlwaysValid = false;
            }
        }

        /// <include file='doc\COM2PropertyDescriptor.uex' path='docs/doc[@for="Com2PropertyDescriptor.RaiseCom2Event"]/*' />
        /// <devdoc>
        ///     Raises the appropriate event
        /// </devdoc>
        private void RaiseCom2Event(Object key, EventArgs e) {
            try {
                com2props.AlwaysValid = com2props.CheckValid();
                Com2EventHandler handler = (Com2EventHandler)Events[key];
                if (handler != null) handler(this, e);
            }
            finally {
                com2props.AlwaysValid = false;
            }
        }

        /// <include file='doc\COM2PropertyDescriptor.uex' path='docs/doc[@for="Com2PropertyDescriptor.RaiseGetNameItemEvent"]/*' />
        /// <devdoc>
        ///     Raises the appropriate event
        /// </devdoc>
        private void RaiseGetNameItemEvent(Object key, GetNameItemEvent e) {
            try {
               com2props.AlwaysValid = com2props.CheckValid();
                GetNameItemEventHandler handler = (GetNameItemEventHandler)Events[key];
                if (handler != null) handler(this, e);
            }
            finally {
                com2props.AlwaysValid = false;
            }
        }

        /// <include file='doc\COM2PropertyDescriptor.uex' path='docs/doc[@for="Com2PropertyDescriptor.ResetValue"]/*' />
        /// <devdoc>
        ///     Will reset the default value for this property on the component.  If
        ///     there was a default value passed in as a DefaultValueAttribute, that
        ///     value will be set as the value of the property on the component.  If
        ///     there was no default value passed in, a ResetXXX method will be looked
        ///     for.  If one is found, it will be invoked.  If one is not found, this
        ///     is a nop.
        /// </devdoc>
        public override void ResetValue(Object component) {
            if (component == this.TargetObject) {
                OnResetValue(EventArgs.Empty);
            }
        }

        /// <include file='doc\COM2PropertyDescriptor.uex' path='docs/doc[@for="Com2PropertyDescriptor.SetNeedsRefresh"]/*' />
        /// <devdoc>
        ///     Sets whether the particular item(s) need refreshing.
        /// </devdoc>
        internal void SetNeedsRefresh(int mask, bool value){
            if (value) {
                refreshState |= mask;
            }
            else {
                refreshState &= ~mask;
            }
        }

        /// <include file='doc\COM2PropertyDescriptor.uex' path='docs/doc[@for="Com2PropertyDescriptor.SetValue"]/*' />
        /// <devdoc>
        ///     This will set value to be the new value of this property on the
        ///     component by invoking the setXXX method on the component.  If the
        ///     value specified is invalid, the component should throw an exception
        ///     which will be passed up.  The component designer should design the
        ///     property so that getXXX following a setXXX should return the value
        ///     passed in if no exception was thrown in the setXXX call.
        /// </devdoc>
        public override void SetValue(Object component, Object value) {

            if (this.readOnly) {
                throw new NotSupportedException(SR.GetString(SR.COM2ReadonlyProperty, this.Name ));
            }

            if (component == null || !Marshal.IsComObject(component) || !(component is UnsafeNativeMethods.IDispatch)) {
                return;
            }

            // do we need to convert the type?
            if (valueConverter != null) {
                bool cancel = false;
                value = valueConverter.ConvertManagedToNative(value, this, ref cancel);
                if (cancel) {
                    return;
                }
            }

            UnsafeNativeMethods.IDispatch pDisp = (UnsafeNativeMethods.IDispatch)component;

            NativeMethods.tagDISPPARAMS dp = new NativeMethods.tagDISPPARAMS();
            NativeMethods.tagEXCEPINFO excepInfo = new NativeMethods.tagEXCEPINFO();
            dp.cArgs = 1;
            dp.cNamedArgs = 1;
            int[] namedArgs = new int[]{NativeMethods.DISPID_PROPERTYPUT};
            GCHandle gcHandle = GCHandle.Alloc(namedArgs, GCHandleType.Pinned);

            try {
                dp.rgdispidNamedArgs = Marshal.UnsafeAddrOfPinnedArrayElement(namedArgs, 0);
                IntPtr mem = Marshal.AllocCoTaskMem( 16 /*Marshal.SizeOf(typeof(VARIANT)) */);
                SafeNativeMethods.VariantInit(new HandleRef(null, mem));
                Marshal.GetNativeVariantForObject(value, mem);
                dp.rgvarg = mem;
                try {

                    Guid g = Guid.Empty;
                    int hr = pDisp.Invoke(this.dispid,
                                          ref g,
                                          SafeNativeMethods.GetThreadLCID(),
                                          NativeMethods.DISPATCH_PROPERTYPUT,
                                          dp,
                                          null,
                                          excepInfo, new IntPtr[1]);


                    string errorInfo = null;
                    if (hr == NativeMethods.DISP_E_EXCEPTION && excepInfo.scode != 0) {
                        hr = excepInfo.scode;
                        errorInfo = excepInfo.bstrDescription;
                    }

                    switch (hr) {
                    case NativeMethods.E_ABORT:
                    case NativeMethods.OLE_E_PROMPTSAVECANCELLED:
                        // cancelled checkout, etc.
                        return;
                    case NativeMethods.S_OK:
                    case NativeMethods.S_FALSE:
                        OnValueChanged(component, EventArgs.Empty);
                        return;
                    default:
                        
                        //Debug.Fail(String.Format("IDispatch::Invoke(INVOKE_PROPPUT) returned hr=0x{0:X}", hr));
                        
                        if (pDisp is UnsafeNativeMethods.ISupportErrorInfo) {
                            g = typeof(UnsafeNativeMethods.IDispatch).GUID;
                            if (NativeMethods.Succeeded(((UnsafeNativeMethods.ISupportErrorInfo)pDisp).InterfaceSupportsErrorInfo(ref g))) {
                                UnsafeNativeMethods.IErrorInfo pErrorInfo = null;
                                UnsafeNativeMethods.GetErrorInfo(0, ref pErrorInfo);
                                string info= null;
                                if (pErrorInfo != null) {
                                    if (NativeMethods.Succeeded(pErrorInfo.GetDescription(ref info))) {
                                        errorInfo = info;
                                    }
                                }
                                
                            }
                        }
                        else if (errorInfo == null) {
                            StringBuilder strMessage = new StringBuilder(256);
                        
                            int result = SafeNativeMethods.FormatMessage(NativeMethods.FORMAT_MESSAGE_FROM_SYSTEM | 
                                                                    NativeMethods.FORMAT_MESSAGE_IGNORE_INSERTS,
                                                                    NativeMethods.NullHandleRef, 
                                                                    hr,
                                                                    SafeNativeMethods.GetUserDefaultLCID(),
                                                                    strMessage,
                                                                    255,
                                                                    NativeMethods.NullHandleRef);
                            
                            
                            if (result == 0) {   
                                errorInfo = String.Format(SR.GetString(SR.DispInvokeFailed, "SetValue", hr));
                            }
                            else {       
                                errorInfo = strMessage.ToString();
                                // strip of any trailing cr/lf
                                while (errorInfo.Length > 0 && 
                                        errorInfo[errorInfo.Length -1] == '\n' ||
                                        errorInfo[errorInfo.Length -1] == '\r') {
                                    errorInfo = errorInfo.Substring(0, errorInfo.Length-1);
                                }    
                            }
                        }
                        throw new ExternalException(errorInfo, hr);
                    }
                }
                finally {
                    SafeNativeMethods.VariantClear(new HandleRef(null, mem));
                    Marshal.FreeCoTaskMem(mem);
                }
            }
            finally {
                gcHandle.Free();
            }
        }

        /// <include file='doc\COM2PropertyDescriptor.uex' path='docs/doc[@for="Com2PropertyDescriptor.ShouldSerializeValue"]/*' />
        /// <devdoc>
        ///     Indicates whether the value of this property needs to be persisted. In
        ///     other words, it indicates whether the state of the property is distinct
        ///     from when the component is first instantiated. If there is a default
        ///     value specified in this PropertyDescriptor, it will be compared against the
        ///     property's current value to determine this.  If there is't, the
        ///     shouldPersistXXX method is looked for and invoked if found.  If both
        ///     these routes fail, true will be returned.
        ///
        ///     If this returns false, a tool should not persist this property's value.
        /// </devdoc>
        public override bool ShouldSerializeValue(Object component) {
            GetBoolValueEvent gbv = new GetBoolValueEvent(this, false);
            OnShouldSerializeValue(gbv);
            return gbv.Value;
        }
        /// <include file='doc\COM2PropertyDescriptor.uex' path='docs/doc[@for="Com2PropertyDescriptor.Com2PropDescMainConverter"]/*' />
        /// <devdoc>
        /// we wrap all value editors in this one so we can intercept
        /// the GetTextFromValue calls for objects that would like
        /// to modify the display name
        /// </devdoc>
        private class Com2PropDescMainConverter : Com2ExtendedTypeConverter {
            Com2PropertyDescriptor pd;
            
            private const int CheckSubprops = 0;
            private const int AllowSubprops = 1;
            private const int SupressSubprops = 2;
            
            
            private int subprops = CheckSubprops;
            
            public Com2PropDescMainConverter(Com2PropertyDescriptor pd, TypeConverter baseConverter) : base(baseConverter) {
                  this.pd = pd;
            }
            
            public override Object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, Object value, Type destinationType) {
                  Object baseConversion = base.ConvertTo(context, culture, value, destinationType);
                  if (destinationType == typeof(string)) {
                      // if this is our current value, ask if it should be changed for display,
                      // otherwise we'll ask for our enum drop downs, which we don't wanna do!
                      //
                      if (pd.IsCurrentValue(value)) {
                          // don't ever do this for enum types
                          if (!pd.PropertyType.IsEnum) {
                              Com2EnumConverter baseConverter = (Com2EnumConverter)GetWrappedConverter(typeof(Com2EnumConverter));
                              if (baseConverter == null) {
                                return pd.GetDisplayValue((string)baseConversion);
                              }
                              else {
                                  return baseConverter.ConvertTo(value, destinationType);
                              }
                          }
                      }
                  }
                  return baseConversion;
            }
            
            public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes) {
                PropertyDescriptorCollection props = TypeDescriptor.GetProperties(value, attributes);
                
                if (props != null && props.Count > 0) {
                    TypeDescriptor.SortDescriptorArray(props);
                }
                return props;
            }  
            
            public override bool GetPropertiesSupported(ITypeDescriptorContext context) {
                  if (subprops == CheckSubprops) {
                     if (!base.GetPropertiesSupported(context)){
                        subprops = SupressSubprops;
                     }
                     else {
                        // special case the font converter here.
                        //
                        if ((pd.valueConverter != null && pd.valueConverter.AllowExpand) || Com2IVsPerPropertyBrowsingHandler.AllowChildProperties(this.pd)) {
                           subprops = AllowSubprops;
                        }
                     }
                  }
                  return (subprops == AllowSubprops);
            }
        }
    }

    internal class Com2PropertyEvent : EventArgs {
        readonly Com2PropertyDescriptor prop;

        public Com2PropertyEvent(Com2PropertyDescriptor prop) {
            this.prop = prop;
        }

        public Com2PropertyDescriptor Property {
            get {
                return prop;
            }
        }
    }

    internal class GetAttributesEvent : Com2PropertyEvent {
        private ArrayList attrList;

        public GetAttributesEvent(Com2PropertyDescriptor propDesc, ArrayList attrList) : base(propDesc) {
            this.attrList = attrList;

        }

        public void Add(Attribute attribute) {
            attrList.Add(attribute);
        }
    }

    internal delegate void Com2EventHandler(Com2PropertyDescriptor sender, EventArgs e);

    internal delegate void GetAttributesEventHandler(Com2PropertyDescriptor sender, GetAttributesEvent gaevent);

    internal class GetNameItemEvent : Com2PropertyEvent {
        private Object nameItem;

        public GetNameItemEvent(Com2PropertyDescriptor propDesc, Object defName) : base(propDesc) {
            this.nameItem = defName;

        }

        public Object Name{
            get{
                return nameItem;
            }
            set{
                nameItem = value;
            }
        }

        public string NameString{
            get{
                if (nameItem != null) {
                    return nameItem.ToString();
                }
                return "";
            }
        }
    }


    internal delegate void GetNameItemEventHandler(Com2PropertyDescriptor sender, GetNameItemEvent gnievent);


    internal class GetBoolValueEvent : Com2PropertyEvent {
        private bool value;

        public GetBoolValueEvent(Com2PropertyDescriptor propDesc, bool defValue) : base(propDesc) {
            this.value= defValue;

        }

        public bool Value{
            get{
                return value;
            }
            set{
                // this.value |= value;
                this.value = value;
            }
        }
    }

    internal delegate void GetBoolValueEventHandler(Com2PropertyDescriptor sender, GetBoolValueEvent gbeevent);

    internal class GetRefreshStateEvent : GetBoolValueEvent {

        Com2ShouldRefreshTypes item;

        public GetRefreshStateEvent(Com2PropertyDescriptor propDesc, Com2ShouldRefreshTypes item, bool defValue) : base(propDesc, defValue) {
            this.item = item;

        }

        public Com2ShouldRefreshTypes RefreshItem {
            get{
                return item;
            }
        }
    }

    internal delegate void GetRefreshStateEventHandler(Com2PropertyDescriptor sender, GetRefreshStateEvent gfsevent);
    
    internal delegate void GetTypeConverterAndTypeEditorEventHandler(Com2PropertyDescriptor sender, GetTypeConverterAndTypeEditorEvent e);
    
    internal class GetTypeConverterAndTypeEditorEvent : Com2PropertyEvent {
        private TypeConverter typeConverter;
        private Object        typeEditor;
        private Object        targetObject;
        private Type          editorType;

        public GetTypeConverterAndTypeEditorEvent(Com2PropertyDescriptor propDesc, Object obj, TypeConverter typeConverter, Type editorType, Object typeEditor) : base(propDesc) {
            this.typeEditor = typeEditor;
            this.typeConverter = typeConverter;
            this.targetObject = obj;
            this.editorType = editorType;
        }
        
        public Type   EditorType {
            get {
               return editorType;
            }
        }

        public Object TargetObject{
            get{
                return targetObject;
            }
        }

        public TypeConverter TypeConverter{
            get{
                return typeConverter;
            }
            set{
                typeConverter = value;
            }
        }
        
        public Object TypeEditor{
            get{
                return typeEditor;
            }
            set{
                typeEditor = value;
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\design\eventstab.cs ===
//------------------------------------------------------------------------------
// <copyright file="EventsTab.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms.Design {
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.ComponentModel.Design;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;
    using System.Collections;
    using Microsoft.Win32;


    /// <include file='doc\EventsTab.uex' path='docs/doc[@for="EventsTab"]/*' />
    /// <devdoc>
    ///    <para>Provides a tab on the property browser to display events for selection and linking.</para>
    /// </devdoc>
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Name="FullTrust")]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    public class EventsTab : PropertyTab {
        private IServiceProvider sp;
        private IDesignerHost currentHost;
        private bool          sunkEvent;

        /// <include file='doc\EventsTab.uex' path='docs/doc[@for="EventsTab.EventsTab"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Windows.Forms.Design.EventsTab'/> class.</para>
        /// </devdoc>
        public EventsTab(IServiceProvider sp){
            this.sp = sp;
        }

        /// <include file='doc\EventsTab.uex' path='docs/doc[@for="EventsTab.TabName"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the name of the tab.</para>
        /// </devdoc>
        public override string TabName {
            get {
                return SR.GetString(SR.PBRSToolTipEvents);
            }
        }

        /// <include file='doc\EventsTab.uex' path='docs/doc[@for="EventsTab.HelpKeyword"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the help keyword for the tab.</para>
        /// </devdoc>
        public override string HelpKeyword {
            get {
                return "Events"; // do not localize.
            }
        }
        
             // override this to reject components you don't want to support.
        /// <include file='doc\EventsTab.uex' path='docs/doc[@for="EventsTab.CanExtend"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether the specified object can be extended.</para>
        /// </devdoc>
        public override bool CanExtend(Object extendee) {
            return !Marshal.IsComObject(extendee);
        }

        private void OnActiveDesignerChanged(object sender, ActiveDesignerEventArgs adevent){
            currentHost = adevent.NewDesigner;
        }

        /// <include file='doc\EventsTab.uex' path='docs/doc[@for="EventsTab.GetDefaultProperty"]/*' />
        /// <devdoc>
        ///    <para>Gets the default property from the specified object.</para>
        /// </devdoc>
        public override PropertyDescriptor GetDefaultProperty(object obj) {

            IEventBindingService eventPropertySvc = GetEventPropertyService(obj, null);

            if (eventPropertySvc == null) {
                return null;
            }

            // Find the default event.  Note that we rely on GetEventProperties caching
            // the property to event match, so we can == on the default event.
            // We assert that this always works.
            //
            EventDescriptor defEvent = TypeDescriptor.GetDefaultEvent(obj);
            if (defEvent != null) {
                return eventPropertySvc.GetEventProperty(defEvent);
            }
            return null;
        }

        private IEventBindingService GetEventPropertyService(object obj, ITypeDescriptorContext context) {

            IEventBindingService eventPropertySvc = null;

            if (!sunkEvent){
               IDesignerEventService des = (IDesignerEventService)sp.GetService(typeof(IDesignerEventService));

               Debug.Assert(des != null, "Unable to get DesignerEventService for EventsTab");

               if (des != null){
                   des.ActiveDesignerChanged += new ActiveDesignerEventHandler(this.OnActiveDesignerChanged);
               }
               sunkEvent = true;
            }

            if (eventPropertySvc == null && currentHost != null) {
               eventPropertySvc = (IEventBindingService)currentHost.GetService(typeof(IEventBindingService));
            }

            if (eventPropertySvc == null && obj is IComponent){
                  ISite site = ((IComponent)obj).Site;

                  if (site != null) {
                      eventPropertySvc = (IEventBindingService)site.GetService(typeof(IEventBindingService));
                  }
            }

            if (eventPropertySvc == null && context != null) {
                eventPropertySvc = (IEventBindingService)context.GetService(typeof(IEventBindingService));
            }
            return eventPropertySvc;
        }

        /// <include file='doc\EventsTab.uex' path='docs/doc[@for="EventsTab.GetProperties"]/*' />
        /// <devdoc>
        ///    <para> Gets all the properties of the tab.</para>
        /// </devdoc>
        public override PropertyDescriptorCollection GetProperties(object component, Attribute[] attributes) {
            return GetProperties(null, component, attributes);
        }

        /// <include file='doc\EventsTab.uex' path='docs/doc[@for="EventsTab.GetProperties2"]/*' />
        /// <devdoc>
        ///    <para>Gets the properties of the specified component...</para>
        /// </devdoc>
        public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object component, Attribute[] attributes) {
            //Debug.Assert(component != null, "Can't get properties for a null item!");

            IEventBindingService eventPropertySvc = GetEventPropertyService(component, context);

            if (eventPropertySvc == null) {
                return new PropertyDescriptorCollection(null);
            }
            EventDescriptorCollection events = TypeDescriptor.GetEvents(component, attributes);
            PropertyDescriptorCollection realEvents = eventPropertySvc.GetEventProperties(events);


            // Add DesignerSerializationVisibilityAttribute.Content to attributes to see if we have any.
            Attribute[] attributesPlusNamespace = new Attribute[attributes.Length + 1];
            Array.Copy(attributes, 0, attributesPlusNamespace, 0, attributes.Length);
            attributesPlusNamespace[attributes.Length] = DesignerSerializationVisibilityAttribute.Content;

            // If we do, then we traverse them to see if they have any events under the current attributes,
            // and if so, we'll show them as top-level properties so they can be drilled down into to get events.
            PropertyDescriptorCollection namespaceProperties = TypeDescriptor.GetProperties(component, attributesPlusNamespace);
            if (namespaceProperties.Count > 0) {
                ArrayList list = null;
                for (int i = 0; i < namespaceProperties.Count; i++) {
                    PropertyDescriptor nsProp = namespaceProperties[i];

                    TypeConverter tc = nsProp.Converter;

                    if (!tc.GetPropertiesSupported()) {
                         continue;
                    }

                    Object namespaceValue = nsProp.GetValue(component);
                    EventDescriptorCollection namespaceEvents = TypeDescriptor.GetEvents(namespaceValue, attributes);
                    if (namespaceEvents.Count > 0) {
                        if (list == null) {
                            list = new ArrayList();
                        }

                        // make this non-mergable
                        //
                        nsProp = TypeDescriptor.CreateProperty(nsProp.ComponentType, nsProp, MergablePropertyAttribute.No);
                        list.Add(nsProp);
                    }
                }

                // we've found some, so add them to the event list.
                if (list != null) {
                    PropertyDescriptor[] realNamespaceProperties = new PropertyDescriptor[list.Count];
                    list.CopyTo(realNamespaceProperties, 0);
                    PropertyDescriptor[] finalEvents = new PropertyDescriptor[realEvents.Count + realNamespaceProperties.Length];
                    realEvents.CopyTo(finalEvents, 0);
                    Array.Copy(realNamespaceProperties, 0, finalEvents, realEvents.Count, realNamespaceProperties.Length);
                    realEvents = new PropertyDescriptorCollection(finalEvents);
                }
            }

            return realEvents;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\design\iwinformseditorservice.cs ===
//------------------------------------------------------------------------------
// <copyright file="IWinFormsEditorService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.Design {

    using System.Diagnostics;

    using System.Windows.Forms;

    /// <include file='doc\IWinFormsEditorService.uex' path='docs/doc[@for="IWindowsFormsEditorService"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides an interface to display Win Forms dialog
    ///       boxes and controls.
    ///    </para>
    /// </devdoc>
    public interface IWindowsFormsEditorService {

        /// <include file='doc\IWinFormsEditorService.uex' path='docs/doc[@for="IWindowsFormsEditorService.CloseDropDown"]/*' />
        /// <devdoc>
        /// <para>Closes a previously opened drop down
        /// list.</para>
        /// </devdoc>
        void CloseDropDown();
    
        /// <include file='doc\IWinFormsEditorService.uex' path='docs/doc[@for="IWindowsFormsEditorService.DropDownControl"]/*' />
        /// <devdoc>
        ///    <para>Displays the specified control in a drop down list.</para>
        /// </devdoc>
        void DropDownControl(Control control);
    
        /// <include file='doc\IWinFormsEditorService.uex' path='docs/doc[@for="IWindowsFormsEditorService.ShowDialog"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Shows the specified dialog box.
        ///    </para>
        /// </devdoc>
        DialogResult ShowDialog(Form dialog);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\design\propertytab.cs ===
//------------------------------------------------------------------------------
// <copyright file="PropertyTab.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms.Design {
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Drawing;    
    using System.Windows.Forms;
    using Microsoft.Win32;

    /// <include file='doc\PropertyTab.uex' path='docs/doc[@for="PropertyTab"]/*' />
    /// <devdoc>
    ///    <para>Provides a base class for property tabs.</para>
    /// </devdoc>
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Name="FullTrust")]
    public abstract class PropertyTab : IExtenderProvider {

        private Object[] components; 
        private Bitmap   bitmap;
        private bool     checkedBmp;

        /// <include file='doc\PropertyTab.uex' path='docs/doc[@for="PropertyTab.Finalize"]/*' />
        ~PropertyTab() {
            Dispose(false);
        }

        // don't override this. Just put a 16x16 bitmap in a file with the same name as your class in your resources.
        /// <include file='doc\PropertyTab.uex' path='docs/doc[@for="PropertyTab.Bitmap"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets a bitmap to display in the property tab.</para>
        /// </devdoc>
        public virtual Bitmap Bitmap {
            get {
                if (!checkedBmp && bitmap == null) {
                    string bmpName = GetType().Name + ".bmp";
                    try {
                        bitmap = new Bitmap(GetType(), bmpName);
                    }
                    catch (Exception ex) {
                        Debug.Fail("Failed to find bitmap '" + bmpName + "' for class " + GetType().FullName, ex.ToString());
                    }
                    checkedBmp = true;
                }
                return bitmap;
            }
        }

        // don't override this either.
        /// <include file='doc\PropertyTab.uex' path='docs/doc[@for="PropertyTab.Components"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the array of components the property tab is associated with.</para>
        /// </devdoc>
        public virtual Object[] Components {
            get {
                return components;
            }
            set {
                this.components = value;
            }
        }

        // okay.  Override this to give a good TabName.
        /// <include file='doc\PropertyTab.uex' path='docs/doc[@for="PropertyTab.TabName"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the name for the property tab.</para>
        /// </devdoc>
        public abstract string TabName {
            get;
        }
        
        /// <include file='doc\PropertyTab.uex' path='docs/doc[@for="PropertyTab.HelpKeyword"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the help keyword that is to be associated with this tab. This defaults
        ///       to the tab name.</para>
        /// </devdoc>
        public virtual string HelpKeyword {
            get {
                return TabName;
            }
        }

        // override this to reject components you don't want to support.
        /// <include file='doc\PropertyTab.uex' path='docs/doc[@for="PropertyTab.CanExtend"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether the specified object be can extended.</para>
        /// </devdoc>
        public virtual bool CanExtend(Object extendee) {
            return true;
        }

        /// <include file='doc\PropertyTab.uex' path='docs/doc[@for="PropertyTab.Dispose"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual void Dispose() {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <include file='doc\PropertyTab.uex' path='docs/doc[@for="PropertyTab.Dispose2"]/*' />
        protected virtual void Dispose(bool disposing) {
            if (disposing) {
                if (bitmap != null) {
                    bitmap.Dispose();
                    bitmap = null;
                }
            }
        }

        // return the default property item
        /// <include file='doc\PropertyTab.uex' path='docs/doc[@for="PropertyTab.GetDefaultProperty"]/*' />
        /// <devdoc>
        ///    <para>Gets the default property of the specified component.</para>
        /// </devdoc>
        public virtual PropertyDescriptor GetDefaultProperty(Object component) {
            return TypeDescriptor.GetDefaultProperty(component);
        }

        // okay, override this to return whatever you want to return... All properties must apply to component.
        /// <include file='doc\PropertyTab.uex' path='docs/doc[@for="PropertyTab.GetProperties"]/*' />
        /// <devdoc>
        ///    <para>Gets the properties of the specified component.</para>
        /// </devdoc>
        public virtual PropertyDescriptorCollection GetProperties(Object component) {
            return GetProperties(component, null);
        }

        /// <include file='doc\PropertyTab.uex' path='docs/doc[@for="PropertyTab.GetProperties1"]/*' />
        /// <devdoc>
        ///    <para>Gets the properties of the specified component which match the specified 
        ///       attributes.</para>
        /// </devdoc>
        public abstract PropertyDescriptorCollection GetProperties(object component, Attribute[] attributes);

        /// <include file='doc\PropertyTab.uex' path='docs/doc[@for="PropertyTab.GetProperties2"]/*' />
        /// <devdoc>
        ///    <para>Gets the properties of the specified component...</para>
        /// </devdoc>
        public virtual PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object component, Attribute[] attributes) {
             return GetProperties(component, attributes);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\design\winformscomponenteditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="WinFormsComponentEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

namespace System.Windows.Forms.Design {
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Windows.Forms;
    using System.ComponentModel.Design;
    using System.Drawing;    
    using Microsoft.Win32;

    /// <include file='doc\WinFormsComponentEditor.uex' path='docs/doc[@for="WindowsFormsComponentEditor"]/*' />
    /// <devdoc>
    ///    <para> Provides a base class for editors that support any type 
    ///       of <see cref='System.ComponentModel.IComponent'/>
    ///       objects.</para>
    /// </devdoc>
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Name="FullTrust")]
    public abstract class WindowsFormsComponentEditor : ComponentEditor {
        
        /// <include file='doc\WinFormsComponentEditor.uex' path='docs/doc[@for="WindowsFormsComponentEditor.EditComponent"]/*' />
        /// <devdoc>
        ///    <para> Activates a UI used to edit the component.</para>
        /// </devdoc>
        public override bool EditComponent(ITypeDescriptorContext context, object component){
            return EditComponent(context, component, null);
        }
    
        /// <include file='doc\WinFormsComponentEditor.uex' path='docs/doc[@for="WindowsFormsComponentEditor.EditComponent1"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Activates the advanced UI used to edit the component.</para>
        /// </devdoc>
        public bool EditComponent(object component, IWin32Window owner) {
            return EditComponent(null, component, owner);
        }
        
        /// <include file='doc\WinFormsComponentEditor.uex' path='docs/doc[@for="WindowsFormsComponentEditor.EditComponent2"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Activates the advanced UI used to edit the component.</para>
        /// </devdoc>
        public virtual bool EditComponent(ITypeDescriptorContext context, object component, IWin32Window owner) {
            bool changed = false;
            Type[] pageControlTypes = GetComponentEditorPages();

            if ((pageControlTypes != null) && (pageControlTypes.Length != 0)) {
                ComponentEditorForm form = new ComponentEditorForm(component,
                                                                   pageControlTypes);

                if (form.ShowForm(owner, GetInitialComponentEditorPageIndex()) == DialogResult.OK)
                    changed = true;
            }

            return changed;
        }

        /// <include file='doc\WinFormsComponentEditor.uex' path='docs/doc[@for="WindowsFormsComponentEditor.GetComponentEditorPages"]/*' />
        /// <devdoc>
        /// <para>Gets the set of <see cref='System.Windows.Forms.Design.ComponentEditorPage'/> pages to be used.</para>
        /// </devdoc>
        protected virtual Type[] GetComponentEditorPages() {
            return null;
        }

        /// <include file='doc\WinFormsComponentEditor.uex' path='docs/doc[@for="WindowsFormsComponentEditor.GetInitialComponentEditorPageIndex"]/*' />
        /// <devdoc>
        /// <para>Gets the index of the <see cref='System.Windows.Forms.Design.ComponentEditorPage'/> to be shown by default as the 
        ///    first active page.</para>
        /// </devdoc>
        protected virtual int GetInitialComponentEditorPageIndex() {
            return 0;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\winforms\managed\system\winforms\printing\printcontrollerwithstatusdialog.cs ===
//------------------------------------------------------------------------------
// <copyright file="PrintControllerWithStatusDialog.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Windows.Forms {
    using System.Diagnostics;
    using System;
    using System.Threading;
    using System.Drawing;
    using Microsoft.Win32;
    using System.ComponentModel;
    using System.Drawing.Printing;
    using System.Security;
    using System.Security.Permissions;

    /// <include file='doc\PrintControllerWithStatusDialog.uex' path='docs/doc[@for="PrintControllerWithStatusDialog"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class PrintControllerWithStatusDialog : PrintController {
        private PrintController underlyingController;
        private PrintDocument document;
        private BackgroundThread backgroundThread;
        private int pageNumber;
        private string dialogTitle;

        /// <include file='doc\PrintControllerWithStatusDialog.uex' path='docs/doc[@for="PrintControllerWithStatusDialog.PrintControllerWithStatusDialog"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public PrintControllerWithStatusDialog(PrintController underlyingController) 
        : this(underlyingController, SR.GetString(SR.PrintControllerWithStatusDialog_DialogTitlePrint)) {
        }

        /// <include file='doc\PrintControllerWithStatusDialog.uex' path='docs/doc[@for="PrintControllerWithStatusDialog.PrintControllerWithStatusDialog1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public PrintControllerWithStatusDialog(PrintController underlyingController, string dialogTitle) {
            this.underlyingController = underlyingController;
            this.dialogTitle = dialogTitle;
        }

        /// <include file='doc\PrintControllerWithStatusDialog.uex' path='docs/doc[@for="PrintControllerWithStatusDialog.OnStartPrint"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Implements StartPrint by delegating to the underlying controller.
        ///    </para>
        /// </devdoc>
        public override void OnStartPrint(PrintDocument document, PrintEventArgs e) {
            base.OnStartPrint(document, e);

            this.document = document;
            pageNumber = 1;

            if (SystemInformation.UserInteractive) {
                backgroundThread = new BackgroundThread(this); // starts running & shows dialog automatically
            }

            // OnStartPrint does the security check... lots of 
            // extra setup to make sure that we tear down
            // correctly...
            //
            try {
                underlyingController.OnStartPrint(document, e);
            }
            catch (Exception ex) {
                if (backgroundThread != null) {
                    backgroundThread.Stop();
                }
                throw ex;
            }
            finally {
                if (backgroundThread != null && backgroundThread.canceled)
                    e.Cancel = true;
            }
        }

        /// <include file='doc\PrintControllerWithStatusDialog.uex' path='docs/doc[@for="PrintControllerWithStatusDialog.OnStartPage"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Implements StartPage by delegating to the underlying controller.
        ///    </para>
        /// </devdoc>
        public override Graphics OnStartPage(PrintDocument document, PrintPageEventArgs e) {
            base.OnStartPage(document, e);

            if (backgroundThread != null) {
                backgroundThread.UpdateLabel();
            }
            Graphics result = underlyingController.OnStartPage(document, e);
            if (backgroundThread != null && backgroundThread.canceled)
                e.Cancel = true;
            return result;
        }

        /// <include file='doc\PrintControllerWithStatusDialog.uex' path='docs/doc[@for="PrintControllerWithStatusDialog.OnEndPage"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Implements EndPage by delegating to the underlying controller.
        ///    </para>
        /// </devdoc>
        public override void OnEndPage(PrintDocument document, PrintPageEventArgs e) {
            underlyingController.OnEndPage(document, e);
            if (backgroundThread != null && backgroundThread.canceled)
                e.Cancel = true;
            pageNumber++;

            base.OnEndPage(document, e);
        }

        /// <include file='doc\PrintControllerWithStatusDialog.uex' path='docs/doc[@for="PrintControllerWithStatusDialog.OnEndPrint"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Implements EndPrint by delegating to the underlying controller.
        ///    </para>
        /// </devdoc>
        public override void OnEndPrint(PrintDocument document, PrintEventArgs e) {
            underlyingController.OnEndPrint(document, e);
            if (backgroundThread != null && backgroundThread.canceled)
                e.Cancel = true;

            if (backgroundThread != null) {
                backgroundThread.Stop();
            }

            base.OnEndPrint(document, e);
        }

        private class BackgroundThread {
            private PrintControllerWithStatusDialog parent;
            private StatusDialog dialog;
            private Thread thread;
            internal bool canceled = false;
            private bool alreadyStopped = false;

            // Called from any thread
            internal BackgroundThread(PrintControllerWithStatusDialog parent) {
                this.parent = parent;

                // Calling Application.DoEvents() from within a paint event causes all sorts of problems,
                // so we need to put the dialog on its own thread.
                thread = new Thread(new ThreadStart(Run));
                thread.ApartmentState = ApartmentState.STA;
                thread.Start();
            }

            // on correct thread
            [
                UIPermission(SecurityAction.Assert, Window=UIPermissionWindow.AllWindows),
                SecurityPermission(SecurityAction.Assert, Flags=SecurityPermissionFlag.UnmanagedCode),
            ] 
            private void Run() {
                // SECREVIEW : need all permissions to make the window not get adorned...
                //
                try {
                    lock (this) {
                        if (alreadyStopped) {
                            return;
                        }

                        dialog = new StatusDialog(this, parent.dialogTitle);
                        ThreadUnsafeUpdateLabel();
                        dialog.Visible = true;
                    }

                    if (!alreadyStopped) {
                        Application.Run(dialog);
                    }
                }
                finally {
                    lock (this) {
                        if (dialog != null) {
                            dialog.Dispose();
                            dialog = null;
                        }
                    }
                }
            }

            // Called from any thread
            internal void Stop() {
                lock (this) {
                    if (dialog != null && dialog.IsHandleCreated) {
                        dialog.BeginInvoke(new MethodInvoker(dialog.Close));
                        return;
                    }
                    alreadyStopped = true;
                }
            }

            // on correct thread
            private void ThreadUnsafeUpdateLabel() {
                // "page {0} of {1}"
                dialog.label1.Text = SR.GetString(SR.PrintControllerWithStatusDialog_NowPrinting, 
                                                   parent.pageNumber, parent.document.DocumentName);
            }

            // Called from any thread
            internal void UpdateLabel() {
                if (dialog != null && dialog.IsHandleCreated) {
                    dialog.BeginInvoke(new MethodInvoker(ThreadUnsafeUpdateLabel));
                    // Don't wait for a response
                }
            }
        }

        private class StatusDialog : Form {
            internal Label label1;
            private Button button1;
            private BackgroundThread backgroundThread;

            internal StatusDialog(BackgroundThread backgroundThread, string dialogTitle) {
                InitializeComponent();
                this.backgroundThread = backgroundThread;
                this.Text = dialogTitle;
                this.MinimumSize = Size;
            }

            private void InitializeComponent() {
                this.label1 = new Label();
                this.button1 = new Button();

                label1.Location = new Point(8, 16);
                label1.TextAlign = ContentAlignment.MiddleCenter;
                label1.Size = new Size(240, 64);
                label1.TabIndex = 1;
                label1.Anchor = AnchorStyles.Top | AnchorStyles.Left | AnchorStyles.Right;

                button1.Size = new Size(75, 23);
                button1.TabIndex = 0;
                button1.Text = SR.GetString(SR.PrintControllerWithStatusDialog_Cancel);
                button1.Location = new Point(88, 88);
                button1.Anchor = AnchorStyles.Bottom;
                button1.Click += new EventHandler(button1_Click);

                this.AutoScaleBaseSize = new Size(5,